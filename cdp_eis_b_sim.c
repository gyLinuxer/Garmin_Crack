/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __cdecl sub_10001000(int a1);
bool __cdecl sub_100010B0(int a1, int a2);
// int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>);
int __cdecl sub_10001180(int a1, int a2);
char __cdecl sub_100011B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_100012F0(int a1, int a2);
int sub_100014D0(void); // weak
unsigned int sub_100014E0();
int __cdecl sub_100015D0(int a1, int a2);
int __cdecl sub_100015F0(int a1);
unsigned int sub_10001620();
int __cdecl sub_10001640(int a1, char *a2, int a3, int a4);
char __cdecl sub_100016D0(int a1, int a2, int a3);
char __cdecl sub_10001740(int a1, int a2, int a3);
int sub_100017B0();
_DWORD *__cdecl sub_100017D0(int a1);
unsigned int __cdecl sub_100017F0(int a1, int a2, int a3);
// void __usercall sub_10001860(int a1@<esi>);
// char __usercall sub_100018B0@<al>(int a1@<esi>);
// void __usercall sub_10001990(int a1@<esi>, int a2);
// void __usercall sub_10001A60(int a1@<esi>, int a2);
// int __usercall sub_10001B00@<eax>(int a1@<edi>, int a2);
char __thiscall sub_10001CD0(int this);
signed int __cdecl sub_10001CF0(int a1, int a2);
char __cdecl sub_10001E40(int a1, int a2, __int16 a3);
char __cdecl sub_10001E70(int a1, int a2, __int16 a3);
char __cdecl sub_10001EA0(unsigned int a1);
// int __usercall sub_100021D0@<eax>(unsigned int a1@<eax>);
// void __usercall __noreturn sub_10002260(char *a1@<edi>);
int __cdecl sub_100024A0(int a1, int a2);
char __cdecl sub_100024C0(int a1, unsigned int a2);
char sub_10002500();
char __thiscall sub_10002520(int this);
// void *__usercall sub_10002690@<eax>(unsigned int a1@<ecx>, int a2@<ebx>);
char __cdecl sub_10002840(int a1);
int __cdecl sub_10002860(int a1, int a2);
int __cdecl sub_100028E0(int a1, __int16 a2, __int16 a3);
__int16 __cdecl sub_10002920(unsigned __int8 a1);
char __cdecl sub_10002940(int (__cdecl *a1)(int));
char __cdecl sub_10002980(int (__cdecl *a1)(int));
char __cdecl sub_100029A0(int a1, __int16 *a2, _BYTE *a3);
// char __usercall sub_10002A20@<al>(int a1@<ecx>, int a2@<edi>, int a3);
_WORD *__cdecl sub_10002B80(int a1);
int __cdecl sub_10002BF0(int a1);
char __fastcall sub_10002C20(char *a1, unsigned __int8 a2);
// int __usercall sub_10002C40@<eax>(char a1@<bl>, int edi0@<edi>, float a2, float a3);
// int __usercall sub_10003170@<eax>(int a1@<ecx>, int a2@<esi>, int a3, float a4, float a5);
int __cdecl sub_100032B0(float, float, char); // idb
// int __usercall sub_10003330@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4, float a5, float a6, float a7, float a8);
int __cdecl sub_100034B0(int a1);
// char __usercall sub_100035F0@<al>(char a1@<bl>, char a2, char a3, char a4);
double __cdecl sub_100036E0(char, _DWORD); // weak
// char __usercall sub_10003820@<al>(__int16 a1@<ax>);
double __cdecl sub_10003860(float a1, char a2);
// int __usercall sub_10003920@<eax>(int a1@<esi>, char a2);
// int __usercall sub_100039C0@<eax>(int a1@<eax>);
// char __usercall sub_10003A20@<al>(int a1@<edi>);
// char __usercall sub_10003AE0@<al>(int a1@<eax>, char a2@<dl>);
// _DWORD *__usercall sub_10003B10@<eax>(_DWORD *result@<eax>, _DWORD *a2@<ecx>, char a3, char a4);
int __cdecl sub_10003B50(char a1);
// char __usercall sub_10003B70@<al>(int a1@<esi>, int a2, int a3);
// int __usercall sub_10003C50@<eax>(_BYTE *a1@<edi>, float *a2, float *a3);
// void __usercall sub_10003E20(int a1@<eax>, int a2@<edi>, float a3, float a4, int a5);
void __cdecl sub_10003E70(int a1);
void __cdecl sub_100040A0(int a1);
// char __usercall sub_10004220@<al>(int a1@<eax>, int a2@<ecx>, char a3);
// void __usercall sub_10004450(int a1@<ebx>);
int __thiscall sub_10004EF0(int this);
// int __usercall sub_10005970@<eax>(int edi0@<edi>, int a1);
// int __usercall sub_100062A0@<eax>(int edi0@<edi>, int a1);
// int __usercall sub_10006CE0@<eax>(int a1@<eax>);
// char __usercall sub_10008FA0@<al>(int a1@<edi>);
char __cdecl sub_10009550(int a1);
// void __usercall sub_10009570(int a1@<eax>);
void __cdecl sub_10009A80(int a1);
void __cdecl sub_1000A7D0(int a1);
void __cdecl sub_1000BA50(int a1);
void __cdecl sub_1000BEE0(int a1);
// void __usercall sub_1000BFA0(int a1@<ecx>, int a2@<eax>, int edi0@<edi>, int esi0@<esi>, float a3, float a4, float a5, char a6, int a7);
// int __usercall sub_1000C1F0@<eax>(int a1@<ebx>, unsigned int a2@<esi>, int a3);
char __cdecl sub_1000C230(int a1, int a2);
int sub_1000C2F0(); // weak
void __cdecl sub_1000C360(int a1, int a2);
void __cdecl sub_1000C510(int a1, void *a2);
char __cdecl sub_1000C800(int a1, int a2);
void __cdecl sub_1000C8A0(int a1, int a2);
// __int16 __usercall sub_1000CB70@<ax>(int a1@<esi>);
// _DWORD *__usercall sub_1000CBD0@<eax>(_DWORD *result@<eax>, char a2@<dl>, _BYTE *a3@<ecx>);
// signed int __usercall sub_1000CCD0@<eax>(char a1@<al>);
// BOOL __usercall sub_1000CD10@<eax>(float *a1@<edx>, float *a2@<ecx>, float *a3@<edi>, float *a4@<esi>, int a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15, float a16, float a17);
// double __usercall sub_1000CDB0@<st0>(char a1@<al>);
signed int __fastcall sub_1000CE60(int a1, __int16 a2);
// double __usercall sub_1000CE90@<st0>(__int16 a1@<ax>);
signed int __cdecl sub_1000CED0(void *a1, unsigned __int8 a2, float a3, char a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
// double __usercall sub_1000D000@<st0>(char a1@<al>);
char __fastcall sub_1000D070(int a1, int a2);
// void __usercall sub_1000D110(int a1@<esi>);
// BOOL __usercall sub_1000D1B0@<eax>(int a1@<eax>);
// void __usercall sub_1000D290(int a1@<esi>);
// __int16 __usercall sub_1000D430@<ax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_1000D490@<eax>(int result@<eax>, int a2@<ecx>);
// char __usercall sub_1000D4A0@<al>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4);
// void __usercall sub_1000D540(int a1@<edx>, int a2@<esi>, float a3, float a4);
signed int __cdecl sub_1000D5B0(signed int a1, unsigned __int8 a2, char a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
// void __usercall sub_1000D6C0(int a1@<edx>, int a2@<ebx>, float a3, float a4);
// char __usercall sub_1000D750@<al>(int a1@<eax>);
// int __usercall sub_1000D8C0@<eax>(int a1@<esi>);
int __cdecl sub_1000D920(int a1);
// int __usercall sub_1000DDA0@<eax>(int a1@<eax>);
// int __usercall sub_1000DF20@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char a4);
int __cdecl sub_1000E370(int a1, int a2, signed int a3, char a4);
// int __usercall sub_1000E650@<eax>(int a1@<edi>, int a2, int a3, int a4, char a5);
int __cdecl sub_1000E790(int a1, int a2, int a3, char a4);
char *__thiscall sub_1000EBA0(int this);
unsigned int __thiscall sub_1000FFC0(int this);
int __cdecl sub_10010D10(int a1);
// char __usercall sub_10010DD0@<al>(int a1@<esi>);
// int __usercall sub_10010E20@<eax>(void *a1@<ecx>, int a2@<esi>);
int sub_10010EC0(); // weak
// char __usercall sub_10010EF0@<al>(int a1@<esi>);
// char __usercall sub_10011170@<al>(int a1@<esi>);
// void __usercall sub_100114D0(int a1@<eax>, float a2@<esi>);
// void __usercall sub_100116F0(int a1@<ebx>, int a2@<esi>, int a3);
// void __usercall sub_10011A80(int a1@<eax>);
// int __usercall sub_10012D00@<eax>(int a1@<esi>);
// char __usercall sub_10012D50@<al>(int a1@<edi>);
int __cdecl sub_10012EA0(float, float); // idb
// void __usercall sub_10012F00(int a1@<eax>);
// void __usercall sub_10012FC0(int a1@<eax>);
void __cdecl sub_10013B50(int a1);
char __cdecl sub_10013C10(int a1, char a2);
int __cdecl sub_10013C50(int a1, int a2);
// double __usercall sub_10013C70@<st0>(unsigned int a1@<esi>);
// char __usercall sub_10013CB0@<al>(int a1@<edi>);
int __cdecl sub_10013DD0(float); // idb
// double __usercall sub_10013E30@<st0>(int a1@<eax>);
// int __usercall sub_10013E50@<eax>(int result@<eax>, int a2@<ecx>, signed int a3);
char __cdecl sub_10013E80(int a1);
void __cdecl sub_10013F90(int a1);
int __cdecl sub_10014250(char a1, char a2, char a3);
int __cdecl sub_100142F0(char a1);
int sub_10014380(void); // weak
char __cdecl sub_10014390(char a1);
char sub_100143B0();
_WORD *__cdecl sub_100143C0(int a1);
char __cdecl sub_10014460(unsigned int a1);
// _WORD *__usercall sub_100144B0@<eax>(int a1@<edi>, int a2);
char __cdecl sub_10014560(int a1);
char sub_100145E0();
void __cdecl sub_100145F0(unsigned int a1);
int sub_10014610(void); // weak
int __cdecl sub_10014620(int a1, unsigned __int8 a2, char a3);
char __cdecl sub_10014670(int a1, unsigned __int8 a2, __int16 a3);
int __cdecl sub_100146C0(int a1, unsigned __int8 a2);
// char __usercall sub_10014790@<al>(int a1@<eax>, int a2@<ecx>, char a3);
char __cdecl sub_10014820(int a1, unsigned __int8 a2);
char __cdecl sub_10014850(int a1, unsigned __int8 a2, char a3);
// int __usercall sub_10014890@<eax>(int a1@<eax>, char a2@<bl>, int a3);
int __cdecl sub_100148B0(int a1, char a2);
int __cdecl sub_100148D0(int a1);
int __cdecl sub_10014B40(int a1, void *a2, unsigned __int8 a3, char a4, unsigned __int8 a5);
int __cdecl nullsub_1(_DWORD, _DWORD);
int sub_10015480(void); // weak
_DWORD sub_100154B0(); // weak
int __cdecl j_gdi_pvg_begin(_DWORD); // weak
int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD); // weak
int __cdecl sub_10015570(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_buffer_data(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_cmd_list_execute(_DWORD); // weak
int __cdecl j_gdi_pvg_cmd_list_start(_DWORD, _DWORD); // weak
int __cdecl j_gdi_pvg_cmd_list_stop(_DWORD); // weak
int __cdecl sub_10015610(float, float, float, float); // idb
int __cdecl sub_10015640(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_gdi_pvg_color_u32(_DWORD); // weak
int __cdecl j_gdi_pvg_disable(_DWORD); // weak
int __cdecl j_gdi_pvg_disable_client_state(_DWORD); // weak
int __cdecl j_gdi_pvg_draw_arrays(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_100156C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl j_gdi_pvg_enable(_DWORD); // weak
int __cdecl j_gdi_pvg_enable_client_state(_DWORD); // weak
int __stdcall j_gdi_pvg_end(_DWORD); // weak
int j_gdi_pvg_flush(void); // weak
int __cdecl j_gdi_pvg_gen_buffers(_DWORD, _DWORD); // weak
int sub_10015760();
int __cdecl sub_10015770(float); // idb
int __cdecl j_gdi_pvg_load_identity(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_100157C0(float, float, float, float, float, float); // idb
int j_gdi_pvg_pop_attrib(void); // weak
int j_gdi_pvg_pop_matrix(void); // weak
int __cdecl j_gdi_pvg_push_attrib(_DWORD); // weak
int j_gdi_pvg_push_matrix(void); // weak
int __cdecl j_gdi_pvg_read_matrix(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10015850(float, float, float, float); // idb
int __cdecl j_gdi_pvg_scissor(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10015890(float, float); // idb
int __cdecl sub_100158B0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_100158F0(int, int, float); // idb
int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10015920(float, float, float); // idb
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl sub_10015960(float, float); // idb
int __cdecl sub_10015980(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// time_t __cdecl static _mkgmtime(struct tm *Tm);
char *__cdecl sub_100159E0(int a1, char *a2, int a3, char *a4, int a5);
char sub_10015B10();
char __cdecl sub_10015B20(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10015C20(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10015C90(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_10015CD0();
int __cdecl sub_10015D20(int a1);
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10015D40(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_10015DA0(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_10015E10(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_10015E50(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_10015EE0(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_10015F30(int a1);
int __cdecl sub_10015F50(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10015F80(int a1, int a2, int a3, char a4);
char __cdecl sub_10015FA0(int a1);
signed int __cdecl sub_10015FD0(unsigned int a1, int a2, int a3);
int __cdecl sub_10015FF0(int a1, int a2, int a3);
int __cdecl sub_10016010(int a1);
int sub_10016030();
int __cdecl sub_10016050(int a1, int a2);
__int16 __cdecl sub_10016080(int a1);
int sub_100160A0();
int __cdecl sub_100160C0(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10016100(int a1, int a2, int a3, int a4);
int __cdecl sub_10016130(int a1);
int __cdecl sub_10016150(int a1);
int __cdecl sub_10016170(int a1, int a2);
int __cdecl sub_100161A0(int a1, int a2, int a3, int a4);
int __cdecl sub_100161D0(int a1, int a2);
int __cdecl sub_10016200(int a1);
int __cdecl sub_10016220(int a1);
char __cdecl sub_10016240(int a1, int a2);
int __cdecl sub_100162B0(_BYTE *a1);
int __cdecl sub_100162F0(int a1, int a2);
int __cdecl sub_10016320(int a1, int a2);
int __cdecl sub_10016340(int a1);
int __cdecl sub_10016380(int a1, int a2, int a3);
char __cdecl sub_100163A0(int a1, int a2, int a3);
int __cdecl sub_100163E0(int, void *, int, void *); // idb
int __cdecl sub_10016420(int a1, int a2, int a3);
int __cdecl sub_10016450(int a1, int a2, int a3);
int __cdecl sub_10016470(int a1, int a2, int a3);
int __cdecl sub_100164D0(int a1, int a2, int a3);
char __cdecl sub_10016510(int a1, int a2, int a3);
int __cdecl sub_10016550(int, void *, int, void *); // idb
int __cdecl sub_100165A0(unsigned int a1);
int __cdecl sub_100165C0(float, float, float, float, float, int, int); // idb
void sub_100165F0();
int __cdecl sub_10016600(int a1);
char __cdecl sub_10016660(_DWORD *a1, int a2, int a3, _DWORD *a4, unsigned int a5);
int sub_10016700();
signed int __fastcall sub_10016730(char *a1);
// int __usercall sub_10016780@<eax>(unsigned int a1@<eax>);
double __cdecl sub_10016790(int a1, int a2, float a3, float a4, float a5);
double __cdecl sub_10016930(int a1, int a2, float a3);
double __cdecl sub_10016990(int a1, int a2, float a3);
double __cdecl sub_100169F0(int a1, int a2, float a3, float a4, float a5);
double __cdecl sub_10016B80(int a1, int a2, float a3);
void __cdecl sub_10016BE0(int a1, _BYTE *a2);
int __cdecl sub_10016C10(int a1, int a2);
int sub_10016C30(void); // weak
int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
unsigned int __cdecl sub_10016C80(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10016E30@<eax>(int a1@<esi>);
int __cdecl sub_10016EE0(int a1, unsigned __int64 a2);
// int __usercall sub_10016F90@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10017020(int a1, void *a2, int a3, int a4, int a5);
int sub_10017170(void); // weak
signed int sub_10017190();
int __cdecl sub_100171A0(unsigned int a1);
void __cdecl sub_10017200(__int16 a1, _BYTE *a2);
int __cdecl sub_10017230(int a1, int a2);
// int __usercall sub_10017290@<eax>(const char **a1@<esi>);
// int __usercall sub_10017590@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_100175B0(int a1);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
char __cdecl sub_10017690(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
void *__cdecl sub_100177C0(int a1, __int16 a2);
char __cdecl sub_100177F0(int a1, int a2, char *a3);
int __cdecl sub_10017850(int a1, int a2, int a3, signed int a4, int a5);
// char __usercall sub_100179A0@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// char __usercall sub_10017A60@<al>(unsigned __int16 a1@<di>, int a2);
// signed int __usercall sub_10017AC0@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3);
signed int __cdecl sub_10017C20(int a1, int a2, signed int a3);
char __cdecl sub_10017C80(int a1, int a2, int a3, char *a4);
char __cdecl sub_10017EE0(int a1, int a2, int a3, char *a4);
char __cdecl sub_100180D0(int a1, int a2, int a3, char *a4, int a5);
char __cdecl sub_10018330(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10018560(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
int __cdecl sub_10018640(unsigned int a1, char a2, int a3, int a4);
char __cdecl sub_100186A0(int a1, int a2, int a3, double *a4);
// char __usercall sub_10018BA0@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4);
// char __usercall sub_10018C80@<al>(int a1@<eax>, int a2, int a3, int a4);
// char __usercall sub_10019750@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5);
// char __usercall sub_10019810@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4);
char __cdecl sub_10019850(int a1, int a2, int *a3, float *a4, int a5);
char __cdecl sub_1001A140(int a1, int a2, int *a3, int a4, int a5);
// int __usercall sub_1001A1B0@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_1001A290(int a1, int a2, int a3, int a4, _WORD *a5);
// unsigned int __usercall sub_1001A840@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3);
char __cdecl sub_1001A8F0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
char __cdecl sub_1001A990(int a1, float a2, int a3);
int __cdecl sub_1001AAF0(int, char, float, int); // idb
// int __usercall sub_1001ACB0@<eax>(int result@<eax>);
// char __usercall sub_1001ACD0@<al>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4, int a5);
// void __usercall sub_1001AD00(int a1@<esi>, int a2, _WORD *a3);
// int __usercall sub_1001AE90@<eax>(int result@<eax>);
// int __usercall sub_1001AEB0@<eax>(int result@<eax>, int a2@<edx>, int a3@<edi>);
int __cdecl sub_1001AEE0(int, int, int, float, float, float, float, int); // idb
char __cdecl sub_1001B2C0(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_1001B3B0@<al>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4, int a5);
// int __usercall sub_1001B3E0@<eax>(int result@<eax>);
char __cdecl sub_1001B420(int a1, int a2, int a3, int a4, _WORD *a5);
double __cdecl sub_1001B500(float a1, float a2);
double __cdecl sub_1001B520(float a1, float a2);
// int __usercall sub_1001B540@<eax>(int a1@<esi>);
// void __usercall sub_1001B590(int a1@<esi>, int a2@<edi>);
void __cdecl sub_1001BC80(int a1, int a2);
// void __usercall sub_1001BD10(int a1@<edi>, int a2);
// signed int __usercall sub_1001BDF0@<eax>(int a1@<ebx>);
void __cdecl sub_1001BE30(int a1);
// int __usercall sub_1001BFD0@<eax>(int a1@<edi>, int a2@<esi>);
// void __usercall sub_1001C020(int a1@<eax>, int a2);
// int __usercall sub_1001C120@<eax>(int result@<eax>);
// void __usercall sub_1001C270(int a1@<ebx>);
// char __usercall sub_1001C340@<al>(int a1@<ebx>, int a2@<edi>, int a3, float a4);
// int __usercall sub_1001C550@<eax>(int a1@<edx>, unsigned __int8 a2@<cl>, int a3@<ebx>, unsigned __int8 a4, int a5);
char __cdecl sub_1001C770(int a1, float a2, int a3);
char __cdecl sub_1001C7A0(int a1, float a2, int a3);
char __cdecl sub_1001C7C0(int a1, float a2, int a3);
int __cdecl sub_1001C7F0(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
int __cdecl sub_1001C810(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
int __cdecl sub_1001C830(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
char __cdecl sub_1001C850(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_1001C950(int a1, float a2, int a3);
int __cdecl sub_1001C9A0(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4);
// char __usercall sub_1001C9E0@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5);
// char __usercall sub_1001CAD0@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5);
// char __usercall sub_1001CC60@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5);
// int __usercall sub_1001CED0@<eax>(int a1@<esi>, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_1001D240(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
unsigned __int8 __cdecl sub_1001D2B0(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
unsigned __int8 __cdecl sub_1001D410(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_1001D570(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_1001D5E0(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_1001D650(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_1001D6C0(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_1001D730(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
signed int __cdecl sub_1001D7A0(_BYTE *a1, int a2);
// void __usercall sub_1001D810(int a1@<ebx>, int a2);
// void __usercall sub_1001D8C0(int a1@<esi>, int a2, int a3, int a4, _WORD *a5);
// void __usercall sub_1001D9C0(int a1@<edi>, int a2);
// int __usercall sub_1001DA90@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7);
char __cdecl sub_1001DCC0(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_1001DDC0(int, int, int, float, float, float, float); // idb
// __int16 __usercall sub_1001DE00@<ax>(int a1@<eax>, int a2@<esi>);
// const char *__usercall sub_1001DE40@<eax>(const char *result@<eax>, unsigned __int8 a2@<bl>, char *a3);
char __cdecl sub_1001DF40(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_1001DFF0@<al>(int ebx0@<ebx>, int a1, int a2, int a3, int *a4, _WORD *a5);
signed int __cdecl sub_1001EBE0(_BYTE *a1, int a2);
signed int __cdecl sub_1001EC50(int a1, signed int a2, int a3);
int __cdecl sub_1001EC90(int a1, int a2);
// void __usercall sub_1001ECC0(int a1@<eax>, int a2);
// int __usercall sub_1001EDB0@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7);
int __cdecl sub_1001EF80(int, int, int, float, float, float, float); // idb
char __cdecl sub_1001EFC0(int a1, int a2, int a3, float a4, float a5, float a6, float a7);
void __cdecl sub_1001F130(int a1, int a2);
// void __usercall sub_1001F200(int a1@<esi>, int a2);
char __cdecl sub_1001F310(int a1, int a2, int a3, int a4, _WORD *a5);
// int __usercall sub_1001F3D0@<eax>(int a1@<eax>);
// void __usercall sub_1001F450(int a1@<edi>, int a2@<esi>);
// void __usercall sub_1001F530(int a1@<eax>, int a2@<ecx>);
int __thiscall sub_1001F540(int this);
char __cdecl sub_1001F610(int a1, int a2, int a3, int a4, _WORD *a5);
// char __usercall sub_1001F660@<al>(int a1@<edi>, int a2, int a3, int a4, int a5, _WORD *a6);
signed int __cdecl sub_1001FCA0(_BYTE *a1, int a2);
// void __usercall sub_1001FD10(int a1@<esi>);
// void __usercall sub_1001FE20(int a1@<esi>);
void __cdecl sub_10020160(int a1, int a2);
// void __usercall sub_10020200(int a1@<esi>, int a2);
// void __usercall sub_10020320(int a1@<eax>, int a2);
char __cdecl sub_10020430(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_10020510(int, int, int, float, float, float, float, int); // idb
int __cdecl sub_10020990(int a1);
void __cdecl sub_10020BA0(int a1, float a2, float a3, int a4);
void __cdecl sub_10020E60(int a1, signed int a2, char a3, int a4);
void __cdecl sub_10020EB0(int a1, unsigned __int8 a2, char a3, int a4);
// int __usercall sub_100211D0@<eax>(int result@<eax>);
// void __usercall sub_10021210(int a1@<esi>, int a2);
// int __usercall sub_100213B0@<eax>(int result@<eax>);
// int __usercall sub_100213D0@<eax>(int result@<eax>, int a2@<edx>, int a3@<edi>);
// void __usercall sub_10021400(int a1@<edi>, int a2);
// void __usercall sub_100214D0(int a1@<esi>, _BYTE *a2, int a3, float a4, float a5, float a6, float a7, char a8);
// void __usercall sub_10021990(int a1@<eax>);
void __cdecl sub_10021B30(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8);
void __cdecl sub_10021B70(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8);
// void __usercall sub_10021FC0(int a1@<esi>, int a2);
// char __usercall sub_100220D0@<al>(int a1@<edi>, int a2, int a3, int a4, int a5, _WORD *a6);
bool __cdecl sub_100221D0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
int __cdecl sub_100222D0(unsigned int a1);
char *__cdecl sub_10022300(unsigned int a1);
int __cdecl sub_10022320(unsigned int a1);
signed int __cdecl sub_10022340(__int16 a1);
signed int __cdecl sub_10022370(int a1);
void *sub_100223A0();
// int __usercall sub_100223B0@<eax>(_BYTE *a1@<eax>);
// char __usercall sub_100223E0@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3);
// char __usercall sub_10022430@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7);
__int16 __cdecl sub_10022930(_BYTE *a1, unsigned int a2);
int __cdecl sub_10022990(unsigned int a1, unsigned int a2, float *a3);
int sub_100229C0();
int __cdecl sub_10022A60(int a1, int a2, int a3, unsigned __int8 a4);
char __cdecl sub_10022BE0(int a1, const char *a2, int *a3);
int __cdecl sub_10022C20(unsigned int a1, char a2);
char __cdecl sub_10022C80(int a1, const char *a2, int *a3, int a4);
int __cdecl sub_10022E90(int a1, int a2, unsigned int a3, int a4);
__int16 __cdecl sub_10022F60(char *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_10022FF0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7);
void __cdecl sub_10023210(int a1, int (__cdecl *a2)(int));
// unsigned int __usercall sub_10023250@<eax>(unsigned int result@<eax>);
// int __usercall sub_10023290@<eax>(int result@<eax>);
void __cdecl sub_100232C0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5);
void __cdecl sub_10023670(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4);
void __cdecl sub_10023690(int a1, unsigned __int8 a2);
double __cdecl sub_100236F0(unsigned __int16 a1);
unsigned __int8 __cdecl sub_10023720(unsigned int a1);
int __cdecl sub_10023750(unsigned int a1, unsigned __int8 a2, char a3);
int __cdecl sub_100237D0(unsigned int a1);
char __cdecl sub_10023800(__int64 a1);
double __cdecl sub_100238A0(unsigned int a1);
char __cdecl sub_10023910(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4);
// char __usercall sub_10023940@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6);
// char __usercall sub_100239E0@<al>(int a1@<ebx>, _BYTE *a2, int *a3);
signed int sub_10023C30();
int sub_10023CB0();
char __cdecl sub_10023D20(char a1);
int __cdecl sub_10023D40(float); // idb
int sub_10023DD0();
int sub_10023E60();
int __cdecl sub_10023F30(unsigned __int16 a1, char a2, int a3);
int sub_10024000();
void sub_10024060();
signed int sub_10024070();
unsigned int __cdecl sub_10024080(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_100240F0(int, int, int, int, int, char, char *); // idb
char *__cdecl sub_10024680(unsigned __int8 a1);
signed int sub_10024740();
int sub_10024760();
int sub_100247C0();
char *sub_10024830();
int __cdecl sub_10024900(const void *a1);
signed int __cdecl sub_100249B0(unsigned __int8 a1);
char __cdecl sub_100249F0(unsigned __int8 a1);
signed int __cdecl sub_10024A30(unsigned __int8 a1, unsigned __int8 a2);
signed int __cdecl sub_10024A90(unsigned __int8 a1);
char __cdecl sub_10024AD0(int a1);
char __cdecl sub_10024B10(int a1);
char __cdecl sub_10024B50(int a1);
char __cdecl sub_10024B90(int a1);
char __cdecl sub_10024BD0(int a1);
char __cdecl sub_10024C10(unsigned __int8 a1);
char __cdecl sub_10024C50(unsigned __int8 a1);
char __cdecl sub_10024C90(unsigned __int8 a1);
char __cdecl sub_10024CD0(unsigned __int8 a1);
char __cdecl sub_10024D10(unsigned __int8 a1);
int __cdecl sub_10024D50(unsigned __int8 a1);
int sub_10024D90();
int __cdecl sub_10024E30(_BYTE *a1, _BYTE *a2);
int sub_10024E60();
int __fastcall sub_10024E70(unsigned __int8 a1);
int __fastcall sub_10024E90(unsigned __int8 a1);
void *__cdecl sub_10024EB0(char a1, void *a2);
int __cdecl sub_10024F80(int a1);
char sub_10025140();
int __cdecl sub_100252A0(float, float); // idb
bool __cdecl sub_100252F0(float *a1);
int sub_10025390();
char __cdecl sub_100253C0(void *a1);
char __cdecl sub_10025420(float *a1);
char __cdecl sub_10025520(void *a1);
char __cdecl sub_10025580(void *a1);
char __cdecl sub_100255E0(float *a1);
char __cdecl sub_10025610(float *a1);
char __cdecl sub_100256B0(char *a1);
double sub_100256E0(void); // weak
char __thiscall sub_10025700(void *this);
char __thiscall sub_10025730(void *this);
char __fastcall sub_10025760(int a1);
char __thiscall sub_100257D0(void *this);
char __fastcall sub_10025800(int a1);
char sub_10025850();
BOOL __thiscall sub_10025860(void *this);
int __thiscall sub_10025880(void *this);
char __thiscall sub_100259D0(void *this);
char __thiscall sub_10025A00(void *this);
char __fastcall sub_10025A30(int a1);
char __thiscall sub_10025A80(void *this);
char __thiscall sub_10025AB0(void *this);
int sub_10025AE0();
char __thiscall sub_10025B10(void *this);
char __fastcall sub_10025B40(int a1);
char __cdecl sub_10025B90(int a1);
int __cdecl sub_10025BB0(int, char *); // idb
char __thiscall sub_10025C10(void *this);
char __thiscall sub_10025C30(void *this);
char __thiscall sub_10025C50(void *this);
int __thiscall sub_10025C70(void *this);
int __thiscall sub_10025C90(void *this);
char __thiscall sub_10025CB0(void *this);
int __thiscall sub_10025CD0(void *this);
char __thiscall sub_10025CF0(void *this);
char __thiscall sub_10025D10(void *this);
char sub_10025D30();
BOOL sub_10025D50();
int __cdecl sub_10025D70(char a1);
int __cdecl sub_10025D80(char a1);
int __cdecl sub_10025D90(char a1);
int __cdecl sub_10025DA0(char a1);
int __cdecl sub_10025DB0(char *, char *); // idb
// void *__usercall sub_10025DF0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10025E40();
char __cdecl sub_10027C40(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10027EB0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
// int __usercall sub_10027ED0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
char __cdecl sub_10027F20(int a1, int a2, int a3, int a4, _WORD *a5);
__int16 __cdecl sub_10027FA0(char a1);
// _BYTE *__usercall sub_10027FD0@<eax>(int a1@<edi>, int a2@<esi>);
char __cdecl sub_100280C0(int a1, int a2, int a3, int a4, _WORD *a5);
// int __usercall sub_10028240@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebp>);
// char __usercall sub_10028710@<al>(int a1@<ebp>, int a2, int a3, int a4, int a5, _WORD *a6);
// char __usercall sub_10028740@<al>(int a1@<esi>, int a2, int a3, int a4, int a5, _WORD *a6);
// BOOL __usercall sub_100289C0@<eax>(int a1@<ecx>, int a2@<esi>);
// int __usercall sub_10028A00@<eax>(int result@<eax>);
// int __usercall sub_10028B00@<eax>(int result@<eax>);
int __cdecl sub_10028C00(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// int __usercall sub_10029950@<eax>(int a1@<ebx>, int a2@<edi>, int *a3);
// int __usercall sub_1002AAB0@<eax>(int a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, _DWORD *a8);
// int __usercall sub_1002AF30@<eax>(int a1@<ebx>, int a2, float a3, float a4, float a5, float a6, float a7, int *a8, int a9);
// int __usercall sub_1002B160@<eax>(int a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, int a7);
// unsigned __int8 __usercall sub_1002B400@<al>(int a1@<ebx>, _DWORD *a2@<edi>, int a3, int a4, int a5, float a6, float a7, float a8, float a9);
// bool __usercall sub_1002B6A0@<al>(int a1@<esi>);
// double __usercall sub_1002B790@<st0>(int a1@<eax>, float a2@<ecx>);
// int __usercall sub_1002B7E0@<eax>(int a1@<edx>, float *a2@<ecx>, int a3@<ebx>, float a4, int a5);
// char __usercall sub_1002B890@<al>(int a1@<eax>, int a2@<ecx>);
// signed int __usercall sub_1002B990@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>);
// unsigned int __usercall sub_1002BAE0@<eax>(int a1@<edx>, int a2@<edi>, int a3@<esi>);
// void __usercall sub_1002BB20(void *a1@<ecx>, int a2@<esi>);
// unsigned int __usercall sub_1002BC50@<eax>(int a1@<eax>, int a2@<ebx>);
int *__cdecl sub_1002BCB0(int a1, int *a2);
// int __usercall sub_1002C250@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, float *a4@<edi>, int a5, int a6, _DWORD *a7);
// char __usercall sub_1002C2B0@<al>(int a1@<eax>, int a2);
unsigned int __cdecl sub_10032950(int a1);
// char __usercall sub_100332A0@<al>(int a1@<ebx>, int a2);
char __cdecl sub_10034160(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_10034240(unsigned __int16 a1);
char __cdecl sub_10034250(int a1, int a2, int a3, int a4, __int16 *a5);
signed int __cdecl sub_100348B0(int a1);
void __cdecl sub_100348D0(int a1);
void __cdecl sub_10034CB0(_BYTE *a1, int a2);
int __cdecl sub_10034D90(int a1, char a2, int a3);
int __cdecl sub_10034DC0(int a1, int a2);
int __cdecl sub_10034DE0(float, char, int, int); // idb
int __cdecl sub_10034E90(float, char *, float, float, float, int, int); // idb
int __cdecl sub_10035080(float, float, float, int, int); // idb
int __cdecl sub_10035190(int, char, float, int); // idb
// int __usercall sub_100353D0@<eax>(int result@<eax>);
// void __usercall sub_100354E0(int a1@<esi>, int a2@<edi>);
// void __usercall sub_10035690(int a1@<esi>);
// int __usercall sub_10035840@<eax>(int result@<eax>, int a2@<edx>, int a3@<edi>);
// void __usercall sub_10035870(int a1@<edi>, int a2);
int __thiscall sub_10035900(int this);
// void __usercall sub_10035950(int a1@<esi>);
int __cdecl sub_100359F0(int, int, int, float, float, float, float); // idb
void __cdecl sub_10035D00(float a1, char *a2, float a3, float a4, float a5, int a6);
int __cdecl sub_10035D90(int a1);
int __cdecl sub_10035DF0(float, float, int, int); // idb
// void __usercall sub_10035E20(int a1@<esi>, int a2);
char __cdecl sub_10035EC0(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_10035FB0(float, float, float, int); // idb
unsigned __int8 __cdecl sub_100360D0(char a1, int a2);
// char __usercall sub_10036210@<al>(int a1@<eax>);
char sub_10036230();
// char __usercall sub_10036470@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, _WORD *a5, int a6);
// char __usercall sub_10037760@<al>(int a1@<ebx>, int a2, int a3, _WORD *a4, int a5, _WORD *a6);
_DWORD *__cdecl sub_10037820(_DWORD *a1);
int __cdecl sub_10037830(int *a1, int a2);
_DWORD *__cdecl sub_10037860(_DWORD *a1, int a2);
char __cdecl sub_10037870(int a1, int a2, int a3);
char __cdecl sub_100378A0(int a1, _WORD *a2, int a3);
__int16 __cdecl sub_100378D0(unsigned int a1);
bool __cdecl sub_100378F0(char *a1, int *a2, _DWORD *a3);
int __cdecl sub_10037940(int a1, int a2, char *a3, int a4);
char __cdecl sub_100379B0(int a1, char *a2, int a3);
int __cdecl sub_10037A60(int a1);
char __cdecl sub_10037AE0(char a1);
char __cdecl sub_10037B20(char a1);
signed int __cdecl sub_10037B90(char a1);
char __cdecl sub_10037C10(char a1);
char __cdecl sub_10037C80(char a1);
char __cdecl sub_10037D30(int a1);
char __thiscall sub_10037E30(void *this);
int __cdecl sub_10037E40(int *a1);
// char __usercall sub_10037E70@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10037F10(const char *a1);
char __cdecl sub_10037F50(void *a1);
signed int __cdecl sub_10037FA0(unsigned int a1, int a2);
char **sub_10038340();
int __cdecl j_nullsub_1(_DWORD); // weak
int __cdecl sub_10038360(int a1);
int __cdecl sub_10038370(int a1);
char __cdecl sub_10038380(char a1, unsigned __int16 a2, char a3);
void __cdecl sub_100383B0(const char *a1, unsigned int a2, int a3);
void __cdecl sub_10038400(const char *a1, char a2, char a3);
int __cdecl sub_10038450(int a1, _BYTE *a2, int a3);
int __cdecl sub_100384A0(void *, size_t); // idb
int __cdecl sub_100384D0(int, char *, int); // idb
int __cdecl sub_10038530(char *, size_t, char *, va_list); // idb
int sub_10038570(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_100385A0(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_100385E0(int a1, int a2);
signed int __cdecl sub_10038600(int (__cdecl *a1)(int));
char *__cdecl sub_10038630(unsigned __int8 a1);
int __cdecl sub_10038660(int, float, float, float, float, int); // idb
int __cdecl sub_10038760(unsigned int a1, int a2);
int __cdecl sub_100388C0(int a1, int a2);
int __cdecl sub_10038970(float); // idb
int __cdecl sub_10038A00(float); // idb
double __cdecl sub_10038A30(float a1, int a2, int a3);
int __cdecl sub_10038B90(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7);
int __cdecl sub_10038CD0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
// void __usercall sub_10038D10(int a1@<eax>, int a2@<edi>, int a3@<esi>, char a4);
void *sub_10038E60();
// int __usercall sub_10038E70@<eax>(int a1@<edi>, int a2@<esi>, char a3);
void __cdecl sub_10038F40(int a1, int a2, int a3);
int __cdecl sub_10038F60(int a1, int a2);
int __cdecl sub_10038F80(int a1, int a2);
int __cdecl sub_10038FA0(unsigned __int8 a1);
void __cdecl sub_10038FD0(float a1, float a2, float a3, float a4, char a5);
void __cdecl sub_10039220(float a1, float a2, float a3, float a4, float a5, float a6, char a7);
// int __usercall sub_100392A0@<eax>(char a1@<al>, int a2@<ecx>, int a3@<ebx>, int a4);
int __cdecl sub_10039380(int a1, int a2, int a3);
int __cdecl sub_100393A0(int a1, int a2, int a3);
int __cdecl sub_100393C0(int a1, int a2, int a3);
_BYTE *__cdecl sub_10039430(int a1, int a2, char a3);
int __cdecl sub_10039460(int a1);
int __cdecl sub_100395F0(int a1);
int __cdecl sub_10039900(int a1);
int __cdecl sub_10039A80(float, float, float, float, char, int); // idb
int __cdecl sub_10039B30(int a1);
int __cdecl sub_10039EC0(float, float, float, float, int, int); // idb
// int __usercall sub_1003A060@<eax>(int a1@<edi>, float a2, float a3, float a4, float a5, float a6, float a7, int a8);
int __cdecl sub_1003A310(float, float, float, float, int); // idb
int __cdecl sub_1003A420(float, float, float, float, int, float); // idb
int __cdecl sub_1003A4D0(float, float, float, float, int, float); // idb
int __cdecl sub_1003A550(float, float, float, float, int, float, int); // idb
int __cdecl sub_1003A780(float, float, float, float, float, int, int); // idb
int __cdecl sub_1003ABF0(float, float, float, int); // idb
int __cdecl sub_1003AC80(int, int, int, float); // idb
char __cdecl sub_1003AD10(int a1, int a2, unsigned __int16 a3, int a4, char a5);
int __cdecl sub_1003AEE0(float, float, float, int); // idb
int __cdecl sub_1003B300(float, float, float, float, int); // idb
int __cdecl sub_1003B4C0(int a1);
int __cdecl sub_1003B570(int a1, int a2, unsigned __int16 a3, int a4, char a5);
int __cdecl sub_1003B680(float, float, float, float, float, int, int); // idb
int __cdecl sub_1003BB00(int a1);
int __cdecl sub_1003BE00(int a1);
// int __usercall sub_1003BEB0@<eax>(int edi0@<edi>, int a1, int a2, unsigned __int8 a3, char a4);
int __cdecl sub_1003C070(float, float, float, float, float, int, int); // idb
void __cdecl sub_1003C3C0(int a1);
void __cdecl sub_1003C630(int a1);
// int __usercall sub_1003C670@<eax>(char a1@<al>, int a2@<ecx>, char a3);
// void __usercall sub_1003C9A0(int a1@<ebx>, int a2@<esi>, char a3);
// int __usercall sub_1003CA40@<eax>(int a1@<esi>, float a2, float a3, float a4, float a5, char a6);
// void __usercall sub_1003CBC0(int *a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, float a8);
int __cdecl sub_1003CCC0(int a1, char a2);
// int __usercall sub_1003CCE0@<eax>(int edi0@<edi>, int a1);
void __cdecl sub_1003E0F0(int a1, int a2);
int __cdecl sub_1003E110(int, float, float, float, float); // idb
int __cdecl sub_1003E150(int, float, float, float, float); // idb
int __cdecl sub_1003E190(int a1, char a2);
void __cdecl sub_1003E1B0(float a1, float a2, float a3, float a4, float a5, int a6, int a7);
// void __usercall sub_1003E200(int a1@<edx>, int a2@<ecx>, char a3);
void __cdecl sub_1003E280(int a1, int a2);
void __cdecl sub_1003E2A0(int a1, int a2);
void __cdecl sub_1003E2C0(int a1, int a2);
bool __cdecl sub_1003E3E0(char a1);
int __cdecl sub_1003E410(unsigned __int8 a1);
int __cdecl sub_1003E420(unsigned int a1, float *a2);
__int16 __cdecl sub_1003E450(int a1, int a2, int a3);
char __cdecl sub_1003E480(int a1, int a2, int a3, int a4);
char __cdecl sub_1003E4B0(int a1, int a2, int a3);
char __cdecl sub_1003E4E0(__int16 a1);
char __cdecl sub_1003E540(int a1);
int __cdecl sub_1003E5B0(char a1);
signed int sub_1003E5D0();
// signed int __usercall sub_1003E620@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_1003E6C0@<eax>(char a1@<al>);
// int __usercall sub_1003E6E0@<eax>(char a1@<al>);
// signed __int16 __usercall sub_1003E700@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_1003E940(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_1003EAA0(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_1003EC20(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_1003ED80(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_1003EEC0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_1003EFA0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_1003F220(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_1003F250(char a1, int a2, void *a3);
char __cdecl sub_1003F280(char a1, int a2, void *a3, int a4);
int __cdecl sub_1003F2B0(void *); // idb
bool __cdecl sub_1003F2E0(float *a1);
char __cdecl sub_1003F380(float *a1);
double sub_1003F620();
double sub_1003F650();
int sub_1003F680();
int sub_1003F6A0();
char __cdecl sub_1003F6F0(char a1);
int __cdecl sub_1003F710(char a1);
// void __usercall sub_1003F730(int a1@<esi>, int a2, float a3);
// char __usercall sub_1003F890@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3);
// char __usercall sub_1003F980@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4);
char __cdecl sub_1003FC60(float *a1);
char __cdecl sub_1003FCD0(float *a1);
char __cdecl sub_1003FCF0(float *a1);
char __cdecl sub_1003FD10(float *a1);
char __cdecl sub_1003FDA0(float *a1);
char __cdecl sub_1003FE10(float *a1);
char __cdecl sub_1003FEE0(float *a1);
char __cdecl sub_1003FFB0(float *a1);
char __cdecl sub_10040080(float *a1);
char __cdecl sub_10040120(float *a1);
double sub_10040190();
char __cdecl sub_100401F0(float *a1);
bool __cdecl sub_10040290(int a1, void *a2, int a3);
char __cdecl sub_10040310(unsigned __int16 a1);
bool __cdecl sub_10040380(int a1, void *a2);
char __cdecl sub_100403B0(char a1, void *a2);
char __thiscall sub_10040400(void *this);
char sub_10040420();
double __cdecl sub_10040460(char a1);
double sub_100404E0(void); // weak
int __cdecl sub_100404F0(unsigned __int16 a1);
char *__cdecl sub_10040510(unsigned __int16 a1);
int __cdecl sub_10040550(void *); // idb
char __cdecl sub_10040580(char a1);
char __thiscall sub_100405A0(void *this);
int __thiscall sub_100405D0(void *this);
bool __cdecl sub_100405F0(char a1);
char __cdecl sub_10040660(float a1, int a2);
char __cdecl sub_10040700(unsigned __int16 a1, float *a2);
void sub_10040820();
double __cdecl sub_10040830(float a1);
signed int sub_10040890();
// char __usercall sub_100408A0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3);
char __cdecl sub_10040DE0(unsigned __int8 a1, _DWORD *a2);
char __cdecl sub_10040E50(bool *a1);
char __cdecl sub_10040F90(unsigned __int16 a1, int a2, char a3);
char __cdecl sub_10041190(char a1);
char __cdecl sub_100411B0(unsigned int a1, float *a2);
double __cdecl sub_100415D0(int a1, unsigned __int16 a2, char a3, char *a4);
double __cdecl sub_100419A0(int a1, unsigned int a2);
double __cdecl sub_10041FD0(int a1, unsigned int a2);
char __cdecl sub_100426C0(int a1, unsigned __int8 a2, unsigned __int8 a3);
char __cdecl sub_10042760(int a1, void *a2);
// void *__usercall sub_100428C0@<eax>(int a1@<eax>, unsigned __int16 a2@<di>, void *a3@<esi>);
void *sub_100428F0();
bool sub_10042F00();
char __cdecl sub_10042F50(char a1);
BOOL sub_10042FD0();
char __cdecl sub_10043010(unsigned __int8 a1);
int __cdecl sub_100430B0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
char __thiscall sub_10043240(void *this);
char __cdecl sub_100432D0(int a1, char a2);
char __cdecl sub_10043390(int a1, char a2);
char __cdecl sub_10043450(char a1);
char __cdecl sub_10043480(char a1);
BOOL __fastcall sub_100434B0(int a1);
bool __thiscall sub_100434E0(void *this);
char __thiscall sub_10043520(void *this);
// char __usercall sub_10043590@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_100435D0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10043670(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_100436B0(char a1, char a2, void *a3);
char __cdecl sub_10043710(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10043750(char a1, char a2, void *a3);
char __cdecl sub_10043780(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100437C0(char a1, char a2, void *a3);
char __cdecl sub_10043800(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10043840(char a1, char a2, void *a3);
char __cdecl sub_10043890(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_100438D0(char a1, char a2, void *a3);
char __cdecl sub_10043910(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10043950(char a1, char a2, void *a3);
char __cdecl sub_10043990(char a1, void *a2);
char __cdecl sub_100439C0(char a1, void *a2);
char __cdecl sub_100439F0(char a1, void *a2);
char __cdecl sub_10043A20(char a1, void *a2);
char __cdecl sub_10043A50(char a1, void *a2);
char __cdecl sub_10043A80(char a1, void *a2);
char __cdecl sub_10043AB0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10043AF0(char a1, char a2, void *a3);
char __cdecl sub_10043B40(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10043B80(char a1, char a2, void *a3);
char __cdecl sub_10043BB0(char a1, void *a2);
char __cdecl sub_10043BE0(char a1, void *a2);
char __cdecl sub_10043C10(char a1, void *a2);
char __cdecl sub_10043C40(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_10043FE0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10044050(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100440B0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10044120(char a1, _BYTE *a2);
char __thiscall sub_10044160(void *this);
char __cdecl sub_100441D0(char a1, int a2);
char __cdecl sub_10044200(char a1, int a2);
char __cdecl sub_10044230(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
char *__cdecl sub_10044400(char **a1);
int sub_10044450();
int __cdecl sub_10044490(_BYTE *a1, int a2);
signed int __cdecl sub_10044500(_BYTE *a1, int a2);
// int __usercall sub_100445A0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_100445D0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_100447A0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_10044800@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10044890@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_100448E0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10044940@<eax>(int a1@<eax>);
// int __usercall sub_10044960@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_100449A0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10044A30@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10044B80@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10044C20@<eax>(int result@<eax>);
char *__cdecl sub_10044C60(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10044E10@<eax>(int a1@<eax>);
// int __usercall sub_10044E40@<eax>(int a1@<esi>);
void __cdecl sub_10044E70(int (**a1)(void), char **a2, _DWORD *a3);
int sub_100452E0();
void *sub_10045330();
char *sub_10045390();
char sub_100453B0();
char __cdecl sub_100453C0(int a1, int a2, unsigned int a3);
// int *__usercall sub_10045400@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_10045450();
int __cdecl sub_10045460(_DWORD *a1, int a2, int a3);
int __cdecl sub_10045510(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10045720@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_100457E0(char a1);
int *__cdecl sub_10045880(_BYTE *a1);
// int __usercall sub_10045940@<eax>(int a1@<eax>);
// signed int __usercall sub_10045AA0@<eax>(int a1@<esi>);
int __cdecl sub_10045B10(int, int); // weak
char **sub_10045DF0();
// int __usercall sub_10045E00@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_10045EF0(char *a1);
int sub_10046130();
int __cdecl sub_10046210(int a1, int a2, char a3);
_DWORD *sub_10046260();
int sub_10046270();
void sub_10046290();
signed int sub_100462A0();
signed int sub_100462B0();
char sub_100462E0();
bool __cdecl sub_10046350(float *a1);
void sub_100463B0();
int sub_100463C0();
char sub_100463F0();
void sub_10046490();
int __cdecl sub_100464A0(char, int, __int16, __int16, void *); // idb
signed int sub_100464B0();
int sub_100464C0();
int sub_100464D0();
void sub_100464F0();
char __cdecl sub_10046500(unsigned __int8 a1);
signed int sub_10046560();
// char __usercall sub_10046570@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_10046650(int a1, char a2, void *a3);
char __cdecl sub_100466D0(int a1, void *a2);
int __cdecl sub_100466F0(int a1, int a2);
BOOL __cdecl sub_10046700(unsigned int a1);
char __thiscall sub_10046770(void *this);
void __cdecl sub_10046790(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_100467C0(int a1);
signed int sub_100467E0();
void __cdecl sub_10046810(_BYTE *a1);
char __cdecl sub_10046830(int a1, size_t a2, void *a3);
int __cdecl sub_10046870(int a1);
char __fastcall sub_10046890(int *a1);
char sub_10046AB0();
signed int sub_10046AD0();
int sub_10046B00();
signed int __cdecl sub_10046B50(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10046BB0(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_10046BD0(unsigned int a1);
bool __cdecl sub_10046BF0(int a1);
int __cdecl sub_10046CC0(int a1);
int __cdecl sub_10046CE0(int a1, int a2);
signed int __cdecl sub_10046D20(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_10046DE0(int a1);
// int __usercall sub_10046E20@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10046ED0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_100470A0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_100470B0@<eax>(int result@<eax>);
// char __usercall sub_100470D0@<al>(int a1@<eax>);
// int __usercall sub_100470F0@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_10047130(int a1, int a2);
// int __usercall sub_10047150@<eax>(int a1@<esi>);
// signed int __usercall sub_10047190@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_100473A0(int a1);
signed int __cdecl sub_10047610(unsigned int a1, int a2, int a3);
// int __usercall sub_100476B0@<eax>(int a1@<eax>);
// int __usercall sub_100476D0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10047700@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit(int);
// char __usercall sub_100477F0@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10047820@<eax>(int a1@<eax>);
signed int __cdecl sub_10047850(unsigned int a1);
signed int __cdecl sub_100478A0(int a1, int a2);
signed int __cdecl sub_10047A90(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10047AF0(unsigned int a1, int a2, int a3);
int __cdecl sub_10047C80(unsigned __int8 *a1);
int __cdecl sub_10047CA0(unsigned __int8 *a1, int a2);
int __cdecl sub_10047CD0(unsigned __int8 *a1);
char __cdecl sub_10047CF0(char a1);
signed int __cdecl sub_10047D20(signed int a1);
int __cdecl sub_10047D60(char a1);
int __cdecl sub_10047DA0(char a1);
char __cdecl sub_10047DE0(float a1, int a2, char a3, int a4);
void __cdecl sub_10047ED0(char a1, _DWORD *a2, _DWORD *a3, char a4);
char __cdecl sub_10047F10(char a1, _DWORD *a2, int *a3, char a4, int a5);
char __cdecl sub_10047FA0(char a1, _DWORD *a2, int *a3, char a4, int a5);
int __cdecl sub_10048030(int a1);
// int __usercall sub_10048050@<eax>(const char *a1@<eax>, int a2@<ecx>);
// int __usercall sub_100480D0@<eax>(int a1@<ebx>, float a2, float a3, int a4, int a5, int a6, float a7, char a8);
double __cdecl sub_10048270(float a1, float a2, int a3, float a4);
int __cdecl sub_10048350(_BYTE *a1);
char __cdecl sub_10048380(_BYTE *a1, _BYTE *a2);
char __cdecl sub_100483D0(_BYTE *a1, _BYTE *a2);
int sub_10048420();
__int16 sub_100484F0();
// int __usercall sub_10048550@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
char sub_100485D0();
int (__cdecl *(*sub_10048790())[2])(int, int);
signed int __cdecl sub_100488C0(int a1);
bool __cdecl sub_100488E0(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_10048920(unsigned __int16 a1);
bool sub_10048950();
bool sub_10048960();
int __cdecl sub_10048980(char a1);
// int __usercall sub_10048990@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_100489A0@<al>(char a1@<bl>, char a2);
char __cdecl sub_10048A60(char a1, char a2);
int __cdecl sub_10048A80(int a1, unsigned int a2);
__int16 __cdecl sub_10048B70(int a1, unsigned int a2);
__int16 __cdecl sub_10048BC0(unsigned int *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_10048C40(int *a1, int a2);
// unsigned int __usercall sub_10048C60@<eax>(int a1@<eax>);
char __cdecl sub_10048EA0(int a1, int a2, int a3, int a4, __int16 *a5);
char __cdecl sub_10048F80(unsigned __int16 a1);
int __cdecl sub_100490D0(_BYTE *a1);
int __cdecl sub_100490F0(unsigned __int8 *a1);
int __cdecl sub_10049110(unsigned __int8 *a1);
int __cdecl sub_10049130(unsigned __int8 *a1);
int __cdecl sub_10049150(unsigned __int8 *a1);
_DWORD __cdecl sub_10049170(_DWORD); // weak
int __cdecl sub_10049180(int a1);
int __cdecl sub_100491C0(int a1);
signed int __fastcall sub_100491E0(unsigned __int8 a1);
char __cdecl sub_100491F0(unsigned __int8 a1);
__int16 __cdecl sub_10049210(unsigned __int8 a1);
int __cdecl sub_10049230(int a1);
int __cdecl sub_10049240(void *); // idb
int __cdecl sub_100492C0(int a1, int a2);
signed int __cdecl sub_100492F0(int a1, int a2, int a3);
char __cdecl sub_10049310(_DWORD *a1);
char __cdecl sub_10049420(int a1, unsigned int a2);
bool __cdecl sub_10049450(const void **a1, int a2);
bool __cdecl sub_10049480(const void **a1, int a2);
bool __cdecl sub_100494B0(const void **a1, int a2);
bool __cdecl sub_100494E0(const void **a1, int a2);
bool __cdecl sub_10049510(const void **a1, int a2);
bool __cdecl sub_10049540(int a1, int a2);
bool __cdecl sub_10049580(int a1, int a2);
bool __cdecl sub_100495C0(const void **a1, int a2);
bool __cdecl sub_100495F0(const void **a1, int a2);
char __cdecl sub_10049620(int a1, unsigned int a2);
bool __cdecl sub_10049650(const void **a1, int a2);
bool __cdecl sub_10049680(const void **a1, int a2);
bool __cdecl sub_100496B0(const void **a1, int a2);
bool __cdecl sub_100496E0(const void **a1, int a2);
bool __cdecl sub_10049710(const void **a1, int a2);
bool __cdecl sub_10049740(const void **a1, int a2);
bool __cdecl sub_10049770(const void **a1, int a2);
bool __cdecl sub_100497A0(const void **a1, int a2);
bool __cdecl sub_100497D0(const void **a1, int a2);
bool __cdecl sub_10049800(const void **a1, int a2);
int __cdecl sub_10049830(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_100498A0(int a1, char a2);
int __cdecl sub_100498C0(int a1, int a2, int a3);
int __cdecl sub_100498F0(int a1, int a2, int a3, int a4);
int __cdecl sub_10049920(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10049960(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_100499A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_100499F0(int a1);
char __cdecl sub_10049A20(int a1);
char __cdecl sub_10049A30(int a1, int a2);
signed int __cdecl sub_10049BB0(int a1);
signed int __cdecl sub_10049BF0(int a1, int a2, int a3);
char __cdecl sub_10049C90(int a1);
char __cdecl sub_10049CF0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_10049D60(char *a1);
int __cdecl sub_10049E00(int a1, int a2, int a3);
bool __cdecl sub_10049E70(int a1, unsigned int a2, int a3);
char __cdecl sub_10049F00(int a1, int a2, char a3, char a4);
char __cdecl sub_10049FB0(int a1);
char __cdecl sub_10049FC0(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1004A040(int a1, const char *a2))(const char *);
signed int __cdecl sub_1004A090(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1004A0E0(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1004A260();
const char *__cdecl sub_1004A270(unsigned int a1);
int __cdecl sub_1004A290(int a1, int a2, int a3, int a4);
int __cdecl sub_1004A340(int a1);
int __cdecl sub_1004A360(int a1);
char *sub_1004A380(char *a1, ...);
// char *__usercall sub_1004A3C0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1004A3E0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1004A5C0();
int sub_1004A5E0();
int __cdecl sub_1004A600(int a1, int a2);
int __cdecl sub_1004A660(int a1);
int __cdecl sub_1004A670(int a1, int a2);
int __cdecl sub_1004A6D0(int a1);
bool __cdecl sub_1004A6E0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1004A820(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1004ABD0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1004B020(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1004B4E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1004B8A0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1004BCA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1004C060(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1004C5A0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1004C980(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1004CD40(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1004D0E0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1004D4E0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1004D880(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1004DE60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1004E250(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_1004E5F0();
// BOOL __usercall sub_1004E620@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_1004E790@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_1004EA00(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_1004ED00(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_1004EDB0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_1004EDF0(int a1, int a2);
char __cdecl sub_1004EE30(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_1004FBE0(int a1, int a2);
char **__cdecl sub_1004FC60(int a1);
int (**sub_1004FCA0())();
int (__cdecl *__cdecl sub_1004FCB0(const char *a1))(const char *);
const char *sub_1004FCD0();
__int64 sub_1004FCE0();
const char *sub_1004FCF0();
// int __usercall sub_1004FD00@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_1004FD50(int a1, int a2);
int sub_1004FD80(); // weak
// int __usercall sub_1004FEA0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10050220(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_10051040(int a1);
int __cdecl sub_100510B0(int a1);
char sub_100510F0();
char __cdecl sub_10051170(int a1, int a2);
char __cdecl sub_10051290(int a1);
unsigned int __cdecl sub_100512A0(char *a1);
int __cdecl sub_100512C0(_BYTE *a1);
int __cdecl sub_100512E0(unsigned __int8 *a1);
unsigned int __cdecl sub_10051300(int a1, int a2);
unsigned int __cdecl sub_10051630(int a1, int a2);
unsigned int __cdecl sub_10051A70(_BYTE *a1);
int __cdecl sub_10051A90(unsigned __int8 *a1);
int __cdecl sub_10051AB0(unsigned __int8 *a1);
int __cdecl sub_10051AD0(_BYTE *a1);
int __cdecl sub_10051AF0(int a1);
// void __cdecl __noreturn exit_1(int);
int __cdecl sub_10051B40(unsigned __int8 *a1);
int __cdecl sub_10051B60(int a1);
unsigned int __cdecl sub_10051BF0(int a1);
signed int __cdecl sub_10051C10(int a1);
unsigned int __cdecl sub_10051C60(int a1);
int __cdecl sub_10051CC0(_BYTE *a1);
unsigned int __cdecl sub_10051CE0(_BYTE *a1);
int __cdecl sub_10051D00(unsigned __int8 *a1);
int __cdecl sub_10051D20(_BYTE *a1);
signed int __cdecl sub_10051D40(_BYTE *a1, int a2);
int __cdecl sub_10051D70(_BYTE *a1, int a2);
signed int __cdecl sub_10051DB0(_BYTE *a1, int a2);
int __cdecl sub_10051DE0(int a1, int a2);
int __cdecl sub_10051E70(unsigned __int8 *a1);
int __cdecl sub_10051E90(int a1);
int __cdecl sub_10051EC0(unsigned __int8 *a1);
unsigned int __cdecl sub_10051EE0(int a1);
int __cdecl sub_10051F10(int a1);
int __cdecl sub_10052000(int a1);
signed int __cdecl sub_10052110(unsigned __int8 *a1, int a2);
int __cdecl sub_10052140(int a1);
int __cdecl sub_10052170(unsigned __int8 *a1);
int __cdecl sub_100521D0(int a1);
signed int __cdecl sub_100521E0(_BYTE *a1, int a2);
int __cdecl sub_10052210(int a1, int a2);
signed int __cdecl sub_10052290(int a1);
_DWORD __cdecl sub_10052320(_DWORD); // weak
int __cdecl sub_10052330(int a1);
unsigned int __cdecl sub_100523B0(int a1);
unsigned int __cdecl sub_100523F0(int a1);
int __cdecl sub_10052440(int a1);
int __cdecl sub_10052470(int a1);
unsigned int __cdecl sub_100524A0(int a1);
unsigned int __cdecl sub_100524D0(int a1);
unsigned int __cdecl sub_100524F0(int a1);
void __cdecl __noreturn sub_10052530(int a1);
signed int __cdecl sub_100526A0(int a1, int a2);
// time_t __cdecl static _mkgmtime_0(struct tm *Tm);
// signed int __usercall sub_10052700@<eax>(int a1@<eax>, int a2@<edi>);
signed int __cdecl sub_100527D0(int a1);
signed int __cdecl sub_100527E0(_BYTE *a1, char a2, int a3);
int __cdecl sub_10052830(int, float, float, int, int); // idb
unsigned int __cdecl sub_10052920(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10052970(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_10052A30(void *a1, size_t a2, int a3);
int __cdecl sub_10052A90(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_10052AE0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10052B80(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char __cdecl sub_10052C30(unsigned __int16 a1);
char __cdecl sub_10052CD0(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_10052DE0(char a1);
char __cdecl sub_10052E30(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
char __cdecl sub_10052E90(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_10052EF0(char a1);
char __thiscall sub_10052F20(void *this);
signed int __cdecl sub_10052F30(char a1, char a2);
int __cdecl sub_10052F90(char a1);
signed int __cdecl sub_10052FD0(char a1, char a2, char a3);
int __cdecl sub_10053040(char a1);
int __cdecl sub_10053080(char a1);
char __cdecl sub_100530C0(char a1, int a2);
char __cdecl sub_100530E0(char a1, int a2);
char __cdecl sub_10053110(char a1, int a2);
char __cdecl sub_10053160(char a1, int a2);
char __cdecl sub_10053190(char a1, int a2);
char __cdecl sub_100531B0(int a1);
char __cdecl sub_100531D0(char a1, void *a2);
char __cdecl sub_10053280(char a1);
int __cdecl sub_100532E0(char *a1, char a2);
bool __cdecl sub_10053350(int a1, void *a2);
char __cdecl sub_10053410(int a1, bool *a2);
int __cdecl sub_100534D0(int, float); // idb
int __cdecl sub_100534F0(int, float); // idb
char __cdecl sub_10053510(int a1, float *a2);
// char __usercall sub_10053570@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5);
// double __usercall sub_10053680@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4);
unsigned __int8 __cdecl sub_10053780(int a1, int a2, char a3, void *a4);
char __cdecl sub_10053910(unsigned __int16 a1, void *a2);
int __cdecl sub_10053970(void *, void *, size_t, int, int); // idb
int __cdecl sub_10053A20(unsigned __int16 a1);
// int __usercall sub_10053A60@<eax>(unsigned __int16 a1@<di>);
int __cdecl sub_10053AA0(unsigned __int16 a1);
signed int __cdecl sub_10053AF0(unsigned __int8 a1);
char __cdecl sub_10053C20(char a1);
char sub_10053C50();
BOOL __cdecl sub_10053CF0(int a1, int a2);
char __cdecl sub_10053D10(int a1, char a2, int a3, int a4, int a5);
int __cdecl sub_10053D50(char a1);
char __cdecl sub_10053DA0(int a1, int a2, int a3, int a4, int a5, int a6);
char __cdecl sub_10053E10(char a1);
signed int __cdecl sub_10053E50(char a1);
int __cdecl sub_10053E90(int a1);
char __cdecl sub_10053EA0(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10053EE0(const char *a1, int a2);
// char *__usercall sub_10053F50@<eax>(char *result@<eax>);
void __cdecl sub_10053F80(char *a1);
void __cdecl sub_10054040(char *a1, char *a2);
void *__cdecl sub_100540A0(int a1);
char __thiscall sub_10054230(void *this);
// _DWORD *__usercall sub_10054250@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
int sub_10054280(); // weak
int sub_100542E0(); // weak
char __cdecl sub_10054330(int a1, int a2);
_DWORD *sub_10054430();
int __cdecl sub_100544C0(char a1);
_DWORD __cdecl sub_100544F0(char); // weak
// signed int __usercall sub_10054500@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100555B0@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_10055610@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10056390@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_100563B0(int a1, unsigned int a2);
// int __usercall sub_10056410@<eax>(int result@<eax>);
// int __usercall sub_10056450@<eax>(int result@<eax>);
// unsigned int __usercall sub_10057B70@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_10057C70@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10057CF0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10057D90@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_10057E50@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10057EB0@<eax>(char *a1@<edi>);
// int __usercall sub_10057F70@<eax>(int a1@<ebx>);
char __cdecl sub_10058030(char *a1, size_t a2, int a3);
char __cdecl sub_10058080(char *a1, unsigned int a2, int a3);
bool __cdecl sub_100580D0(int a1, int a2);
// int __usercall sub_10058100@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_10058310@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_10058360(int a1, int a2);
signed int __cdecl sub_100583F0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_10058520(void *a1, int a2);
// BOOL __usercall sub_100585A0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10058640@<eax>(int result@<eax>);
unsigned int __fastcall sub_100586D0(unsigned int a1, int a2);
// int __usercall sub_100586F0@<eax>(int result@<eax>);
// int __usercall sub_10058780@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_10058C00@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10058CB0@<eax>(int a1@<edi>);
// int __usercall sub_10058D10@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10058EE0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_10058F60(int a1, int a2);
// unsigned int __usercall sub_10058FD0@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_10059180@<eax>(int a1@<esi>, int a2);
// int __usercall sub_10059250@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_10059300@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_10059340@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_100593A0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10059480@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10059A20@<eax>(int a1@<eax>);
// int __usercall sub_10059C60@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10059D00@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10059EE0@<eax>(int a1@<edi>);
// int __usercall sub_1005A020@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_1005A2D0(int a1, int a2);
// signed int __usercall sub_1005A590@<eax>(int a1@<eax>);
// _WORD *__usercall sub_1005A660@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_1005A880(int a1, int a2);
signed int __cdecl sub_1005AB90(int a1, int a2);
signed int __cdecl sub_1005AFA0(int a1, int a2);
int __cdecl sub_1005B110(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_1005B210(int a1);
// signed int __usercall sub_1005B230@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_1005B6D0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_1005B720@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_1005B740(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1005BAF0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_1005BC30@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_1005BC80@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_1005BD20@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_1005BD40(int a1);
// int __usercall sub_1005BD50@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1005C3F0@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_1005CDD0@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1005D100(int a1, int a2);
char __cdecl sub_1005D120(char a1, void *a2);
unsigned __int8 __cdecl sub_1005D170(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_1005D1B0(char a1, _DWORD *a2);
char __cdecl sub_1005D1F0(char a1);
char __cdecl sub_1005D220(char a1, void *a2);
int __cdecl sub_1005D2A0(char a1, _DWORD *a2);
void __cdecl sub_1005D2F0(char a1, char a2);
char __cdecl sub_1005D360(int a1, int a2);
char __cdecl sub_1005D3B0(int a1, int a2);
char __cdecl sub_1005D460(int a1, int a2);
char __cdecl sub_1005D4C0(int a1, int a2);
int __cdecl sub_1005D590(char a1, char *a2);
int __cdecl sub_1005D5E0(unsigned __int8 *a1);
unsigned int __cdecl sub_1005D600(void *a1);
unsigned int __cdecl sub_1005D620(void *a1);
unsigned int __cdecl sub_1005D640(void *a1);
unsigned int __cdecl sub_1005D660(void *a1);
unsigned int __cdecl sub_1005D680(void *a1);
int __cdecl sub_1005D6A0(int a1);
int __cdecl sub_1005D6F0(void *); // idb
unsigned int __cdecl sub_1005D7C0(void *a1);
int __cdecl sub_1005D820(int a1, int a2);
// char __usercall sub_1005D960@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_1005DA30(_DWORD *a1, char *a2);
BOOL __cdecl sub_1005DB10(unsigned int a1);
BOOL __cdecl sub_1005DB30(int a1);
_DWORD __cdecl sub_1005DB50(_DWORD); // weak
unsigned int __cdecl sub_1005DB60(int a1, char a2);
signed int __cdecl sub_1005DBC0(void *a1, int a2, unsigned int a3);
int __cdecl sub_1005DBE0(int a1, int a2, int a3);
char __cdecl sub_1005DC00(const char *a1, const char *a2);
int __cdecl sub_1005DD40(int a1, int a2, unsigned int a3);
int sub_1005DDC0();
void __cdecl sub_1005DDD0(int a1);
int __cdecl sub_1005DE00(int a1);
bool __cdecl sub_1005DE20(int a1);
void *__cdecl sub_1005DE50(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_1005DE90@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_1005DEB0@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_1005DED0(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_1005DF00(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_1005DFE0(int a1, int a2, int a3);
// void *__usercall sub_1005E090@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_1005E310(int a1, int a2);
char __cdecl sub_1005E3E0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_1005E450@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_1005E7B0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_1005E8C0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_1005EA50(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_1005EBA0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_1005ECF0(int a1, int a2);
signed int __cdecl sub_1005ED30(int a1, int a2);
bool __cdecl sub_1005ED90(signed int a1);
int sub_1005EE00();
char sub_1005F120();
char sub_1005F340();
char sub_1005F540();
char sub_1005F6C0();
char sub_1005F840();
char sub_1005F9B0();
char sub_1005FAB0();
char sub_1005FC10();
char sub_1005FD70();
char sub_1005FED0();
char sub_10060040();
char sub_100601A0();
char sub_10060300();
char sub_10060520();
char sub_10060680();
char sub_100607E0();
char sub_10060940();
char sub_10060AB0();
char sub_10060C10();
char sub_10060D70();
char sub_10060F90();
char sub_10061190();
char sub_10061310();
char sub_10061490();
char sub_10061600();
char sub_100616F0();
char sub_10061850();
char sub_100619B0();
char sub_10061B10();
char sub_10061C80();
char sub_10061DE0();
char sub_10061F40();
char sub_10062140();
char sub_100622A0();
char sub_10062400();
char sub_10062560();
char sub_100626D0();
char sub_10062830();
char sub_10062990();
char sub_10062F30();
char sub_10063140();
char sub_10063330();
char sub_100634A0();
char sub_10063610();
char sub_10063770();
char sub_10063860();
char sub_100639C0();
char sub_10063B20();
char sub_10063C80();
char sub_10063DF0();
char sub_10063F50();
char sub_100640B0();
char sub_100642B0();
char sub_10064410();
char sub_10064570();
char sub_100646D0();
char sub_10064840();
char sub_100649A0();
char sub_10064B00();
char sub_10064D10();
char sub_10064F00();
char sub_10065070();
char sub_100651E0();
char sub_10065340();
char sub_10065430();
char sub_10065590();
char sub_100656F0();
char sub_10065850();
char sub_100659C0();
char sub_10065B20();
char sub_10065C80();
char sub_10065E80();
char sub_10065FE0();
char sub_10066140();
char sub_100662A0();
char sub_10066410();
char sub_10066570();
char **sub_100666D0();
int __cdecl sub_100666E0(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_10066700@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_10066710@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_10066940(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10066990(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_100669E0(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_10066A30(int a1))(int);
int __cdecl sub_10066AB0(int a1, int a2);
int (__cdecl *__cdecl sub_10066B30(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_10066B80(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_10066BC0(int a1, int a2, int a3))(int);
int __cdecl sub_10066C20(char a1, char a2);
// bool __usercall sub_10066CD0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10066D00@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10066DA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10066E20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10066EA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10066F20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_10066FA0(char a1);
char sub_10067040();
bool __cdecl sub_10067050(void *a1);
char __cdecl sub_10067090(char a1);
char __cdecl sub_100670C0(char a1);
// char __usercall sub_100670F0@<al>(void *a1@<esi>);
// char __usercall sub_10067130@<al>(float *a1@<esi>);
char __cdecl sub_10067150(float *a1);
char __cdecl sub_100671B0(float *a1);
char __cdecl sub_10067210(float *a1);
// char __usercall sub_10067270@<al>(int a1@<esi>);
char __cdecl sub_10067310(float *a1);
char __cdecl sub_10067360(float *a1);
char __cdecl sub_100673B0(float *a1);
char __cdecl sub_10067410(float *a1);
// char __usercall sub_10067470@<al>(float *a1@<esi>, char a2);
char __cdecl sub_10067560(float a1, int a2);
// char __usercall sub_100675D0@<al>(float *a1@<esi>);
char __cdecl sub_10067650(float *a1);
char __cdecl sub_100676B0(float *a1);
char __cdecl sub_10067740(float *a1);
// char __usercall sub_100677D0@<al>(float *a1@<esi>);
// char __usercall sub_10067B70@<al>(float *a1@<esi>);
// char __usercall sub_10067BE0@<al>(float *a1@<esi>);
// char __usercall sub_10067C00@<al>(float *a1@<esi>);
// void __usercall sub_10067C90(float *a1@<esi>);
char __cdecl sub_10067D20(float *a1);
// char __usercall sub_10067E40@<al>(float *a1@<esi>, float a2);
// char __usercall sub_10068040@<al>(float *a1@<esi>, float a2);
// char __usercall sub_100680D0@<al>(float *a1@<eax>);
// char __usercall sub_100680E0@<al>(float *a1@<eax>);
// char __usercall sub_100680F0@<al>(float *a1@<eax>);
// char __usercall sub_10068100@<al>(float *a1@<eax>);
// int __usercall sub_10068110@<eax>(char a1@<dl>, int a2@<ecx>, float *a3);
// char __usercall sub_10068140@<al>(float *a1@<esi>);
// char __usercall sub_100681E0@<al>(float *a1@<esi>);
char __cdecl sub_100682C0(float *a1);
// char __usercall sub_10068310@<al>(float *a1@<esi>);
// char __usercall sub_100683F0@<al>(float *a1@<esi>);
// char __usercall sub_100684D0@<al>(float *a1@<esi>);
// char __usercall sub_10068570@<al>(float *a1@<esi>);
// char __usercall sub_10068610@<al>(float *a1@<esi>);
// char __usercall sub_100686B0@<al>(float *a1@<esi>);
char __cdecl sub_10068790(float *a1);
bool __cdecl sub_10068830(float *a1);
// char __usercall sub_100688E0@<al>(float *a1@<esi>);
// char __usercall sub_10068960@<al>(float *a1@<esi>);
// char __usercall sub_100689F0@<al>(float *a1@<esi>);
int __cdecl sub_10068A60(float *a1);
int __cdecl sub_10068C90(float *a1);
int __cdecl sub_10068EC0(float *a1);
int __cdecl sub_100690F0(float *a1);
// char __usercall sub_10069320@<al>(float *a1@<esi>);
// char __usercall sub_100693B0@<al>(float *a1@<esi>);
bool __cdecl sub_10069420(float *a1);
char __cdecl sub_10069480(float a1, void *a2);
char __cdecl sub_10069D30(void *a1);
char __cdecl sub_10069D50(void *a1);
bool __thiscall sub_10069EA0(void *this);
char __cdecl sub_10069EC0(int a1, char a2, char a3, int a4, void *a5, size_t a6);
bool __cdecl sub_1006A060(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_1006A0F0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_1006A190(char a1);
char __cdecl sub_1006A210(char a1, int a2);
// int __usercall sub_1006A380@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1006A3C0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1006A400();
char __cdecl sub_1006A410(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1006A470(char a1, void *a2);
char __cdecl sub_1006A590(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1006A610(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
int __cdecl sub_1006A7C0(char a1);
int __cdecl sub_1006A7E0(int, void *); // idb
// int __usercall sub_1006A840@<eax>(char a1@<al>);
BOOL __cdecl sub_1006A870(char a1, int a2);
int __cdecl sub_1006A8A0(int, char, int, int, void *); // idb
char __cdecl sub_1006A8D0(void *a1);
BOOL __cdecl sub_1006A8F0(int a1);
char __cdecl sub_1006A910(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_1006A940(char a1, void *a2);
// signed int __usercall sub_1006A980@<eax>(char a1@<al>);
bool __cdecl sub_1006A9A0(char a1, void *a2);
bool __cdecl sub_1006AA90(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_1006AAC0(unsigned __int8 a1);
// BOOL __usercall sub_1006AAD0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_1006AB00(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_1006ACB0(unsigned __int8 a1, int a2);
bool __cdecl sub_1006ACF0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char __cdecl sub_1006ADE0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1006AE80(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1006AF00(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1006AF70(char a1, void *a2);
char __cdecl sub_1006AFF0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1006B070(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1006B0F0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1006B160(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_1006B270(char a1, void *a2);
bool __cdecl sub_1006B290(unsigned __int8 a1, char *a2);
char __cdecl sub_1006B2D0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_1006B310();
char __cdecl sub_1006B370(int a1, char *a2);
BOOL __cdecl sub_1006B460(int a1, int a2);
char __cdecl sub_1006B480(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_1006B4C0(int a1, int a2);
BOOL __cdecl sub_1006B570(int a1, int a2);
char __cdecl sub_1006B590(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1006B5D0(char a1);
// __int16 __usercall sub_1006B610@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1006B620(unsigned __int8 a1, char *a2);
char __cdecl sub_1006B6F0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_1006B770(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_1006B8A0(char a1, int a2);
bool __cdecl sub_1006B920(void *a1);
char __cdecl sub_1006B970(char a1, int a2);
// __int16 __usercall sub_1006BA50@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1006BA60(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_1006BAF0(unsigned __int8 a1, char a2);
bool __cdecl sub_1006BBB0(__int16 a1, char a2, int a3, int a4, void *a5);
int __cdecl sub_1006BCB0(int a1, int a2);
char __cdecl sub_1006BCD0(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
int __cdecl sub_1006BDA0(char, float, int, int, int); // idb
double sub_1006C3F0();
double __cdecl sub_1006C420(int a1, float a2, float a3);
char __cdecl sub_1006C460(float *a1, float *a2, float *a3, char a4);
char __cdecl sub_1006C9F0(char a1);
char __cdecl sub_1006CA30(char a1);
double __cdecl sub_1006CA50(float a1);
// int __cdecl FNT_get_fnt_hdr(_DWORD); weak
// int __cdecl BMP_get_bm_def(_DWORD); weak
// int __cdecl BMP_get_xfrm(_DWORD); weak
// int TXT_get_static_string(void); weak
int __cdecl sub_1006CAF0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
unsigned int __cdecl sub_1006CC00(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
int __cdecl sub_1006CCE0(int a1);
int __cdecl sub_1006D030(int a1);
unsigned int __cdecl sub_1006D210(int a1);
int __cdecl sub_1006D740(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
_WORD *__cdecl sub_1006D7A0(int a1);
int __cdecl sub_1006D800(int a1, int a2, char a3);
void sub_1006D8F0();
int __cdecl sub_1006D900(int a1, _BYTE *a2, int a3);
char __cdecl sub_1006D940(char a1, char a2);
int __cdecl sub_1006D960(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7);
bool __cdecl sub_1006E1A0(_BYTE *a1);
bool __cdecl sub_1006E240(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_1006E350(int a1, _BYTE *a2, int a3);
int __cdecl sub_1006E440(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
int __cdecl sub_1006E530(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
int __cdecl sub_1006E790(int a1, __int16 a2, __int16 a3, char a4);
int __cdecl sub_1006ECE0(int a1);
int __cdecl sub_1006EEB0(int a1, signed int a2, signed int a3);
char __cdecl sub_1006F380(int a1);
char *__cdecl sub_1006F4F0(int a1);
int __cdecl sub_1006F640(int a1, int a2);
unsigned int __cdecl sub_1006F760(int a1, int a2);
int __cdecl sub_1006F900(int a1, int a2, int a3);
int __cdecl sub_1006F980(int a1, int a2, int a3);
char __cdecl sub_1006FA00(int a1, signed int a2, int a3, int a4);
int __cdecl sub_1006FB10(int a1, signed int a2, signed int a3);
int __cdecl sub_1006FC00(int a1, signed int a2, int a3, int a4);
int __cdecl sub_1006FD00(int a1, int a2);
char *__cdecl sub_1006FE30(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_1006FF70(int a1, signed int a2, int a3, int *a4);
int __cdecl sub_100701C0(int a1, signed int a2, int a3);
int __cdecl sub_10070300(int a1, signed int a2, int a3);
int __cdecl sub_10070440(int a1);
// int (*__usercall sub_10070450@<eax>(int a1@<eax>, double *a2@<ecx>, int a3@<edi>, int a4@<esi>, int a5, int a6, char a7, double a8, int a9))(void);
// int __usercall sub_10070520@<eax>(int result@<eax>, _DWORD *a2@<edi>, unsigned int a3@<esi>, char a4);
int (*__cdecl sub_10070560(char a1, double a2, int a3, int a4, int a5, int a6))(void);
double __cdecl sub_100705F0(float a1, float a2);
int __cdecl sub_10070690(signed int a1, signed int a2);
double __cdecl sub_100706D0(float a1, float a2);
int __cdecl sub_10070770(float); // idb
double __cdecl sub_100707A0(float a1, float a2);
int __cdecl sub_10070810(float, int, int); // idb
int __cdecl sub_10070830(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_10070850(unsigned int *a1, signed int a2, unsigned int a3);
double __cdecl sub_10070980(int a1);
int __cdecl sub_100709C0(float, int, int); // idb
int __cdecl sub_100709E0(int a1, int a2, int a3);
int __cdecl sub_10070A00(int a1, int a2);
void __cdecl sub_10070A20(int a1, int a2);
int __cdecl sub_10070A70(int a1, _DWORD *a2);
int __cdecl sub_10070C80(int a1, int *a2, int *a3);
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_color4f(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_color_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_line_width(_DWORD); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_rotatef(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_coord2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_coord_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_tex_envf(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_translatef(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD); weak
// int __cdecl gdi_pvg_vertex_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int SYS_exit_krnl(void); weak
// int SYS_enter_krnl(void); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_cnt(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_dsply_alrt(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_hdr_text(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD); weak
// int sprintf(char *, const char *, ...);
// int _snprintf(char *, size_t, const char *, ...);
// char *__cdecl strncpy(char *, const char *, size_t);
// void *__cdecl memset(void *, int, size_t);
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// char *__cdecl strrchr(const char *, int);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// int __cdecl strncmp(const char *, const char *, size_t);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// double __cdecl atof(const char *);
// char *__cdecl strchr(const char *, int);
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isalnum(int);
// int __cdecl isprint(int);
// double __usercall sub_10072A6A@<st0>(double@<st0>); weak
// double __cdecl floor(double);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10073208(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// char *__cdecl strpbrk(const char *, const char *);
int __cdecl sub_1007419A(int, FILE *); // idb
int __cdecl sub_10074D2F(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __cdecl sub_100754BE(_DWORD *a1);
signed int __cdecl sub_100754F5(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_1007613B();
int (*sub_100765E8())(void);
void __cdecl sub_1007660C(); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall _cintrindisp2(_DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_1007B55F(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_1007C705(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_1007C7AB(int, int, struct localeinfo_struct *); // idb
DWORD __cdecl sub_1007CC12(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_1007CDAE(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_1007D3D0(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1007D4F0(signed int a1);
void **sub_1007D54E();
signed int sub_1007D554();
// int __cdecl _fileno(FILE *);
void sub_1007D945();
// int _get_sse2_info(void); weak
int sub_1007D9FD();
int sub_1007DEF2();
int __cdecl sub_1007E0AF(int a1);
int __cdecl sub_1007E0B9(int a1);
int __cdecl sub_1007E0C3(int a1);
int __cdecl sub_1007E1A2(int a1);
signed int __cdecl sub_1007FB49(int a1, int a2);
signed int __cdecl sub_1008008B(int a1, int a2);
int sub_10080799();
int __cdecl sub_100811AC(FILE *); // idb
int __cdecl sub_100812CC(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
signed int __cdecl sub_1008220B(signed int a1);
signed int __cdecl sub_1008228C(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_1008239D(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_1008269E();
int __cdecl sub_100826A7(int a1, int a2, int a3);
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_100834B1(signed int a1);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_10083690(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_100836E0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_10083750(int a1);
int __cdecl sub_10083790(int a1);
int __cdecl sub_100837D0(int a1);
int __cdecl sub_10083810(int a1);
int __cdecl sub_10083850(int a1, int a2, int a3, int a4);
int __cdecl sub_100838C0(int a1, int a2, int a3);
__int16 __cdecl sub_10083960(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_100839A0(int a1, _DWORD *a2, _BYTE *a3);
double __cdecl sub_10083A00(float a1);
char sub_10083A30();
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1000D200; // weak
_UNKNOWN unk_1008487C; // weak
__int16 word_10085470 = 2573; // weak
int dword_10085A38[] = { 2 }; // weak
int (__cdecl *off_10085A3C)(int, int, int, int, int) = &sub_10037760; // weak
int dword_10085A40[] = { 16 }; // weak
int dword_10085A44[] = { 126 }; // weak
int (__cdecl *off_10085A48)(int, int, int, int, int) = &sub_10035EC0; // weak
int dword_10085A4C[] = { 4 }; // weak
int dword_10085A50[] = { 127 }; // weak
int (__cdecl *off_10085A54)(int, int, int, int, int) = &sub_100220D0; // weak
int dword_10085A58[] = { 4 }; // weak
int dword_10085A5C[] = { 128 }; // weak
int (__cdecl *off_10085A60)(int, int, int, int, int) = &sub_10020430; // weak
int dword_10085A64[] = { 4 }; // weak
int dword_10085A68[] = { 10 }; // weak
int (__cdecl *off_10085A6C)(int, int, int, int, int) = &sub_1001F660; // weak
int dword_10085A70[] = { 12 }; // weak
int dword_10085A74[] = { 14 }; // weak
int (__cdecl *off_10085A78)(int, int, int, int, int) = &sub_1001F610; // weak
int dword_10085A7C[] = { 4 }; // weak
_UNKNOWN unk_10086150; // weak
_UNKNOWN unk_10086158; // weak
_UNKNOWN unk_10086178; // weak
char byte_100879F8[9] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_10087FF4; // weak
_UNKNOWN unk_10087FF8; // weak
_UNKNOWN unk_10087FFC; // weak
_UNKNOWN unk_10088000; // weak
_UNKNOWN unk_10088004; // weak
_UNKNOWN unk_10088008; // weak
_UNKNOWN unk_1008800C; // weak
_UNKNOWN unk_10088010; // weak
_UNKNOWN unk_10088014; // weak
char byte_10088018[] = { '\0' }; // weak
__int16 word_1008801A[] = { 118 }; // weak
char byte_10088030[] = { '\0' }; // weak
__int16 word_10088032[] = { 25 }; // weak
_UNKNOWN unk_10088088; // weak
_UNKNOWN unk_10088108; // weak
_UNKNOWN unk_10088158; // weak
_UNKNOWN unk_100881F8; // weak
_UNKNOWN unk_10088248; // weak
_UNKNOWN unk_10088A30; // weak
_UNKNOWN unk_10088FC0; // weak
_UNKNOWN unk_10089080; // weak
_UNKNOWN unk_10089140; // weak
_UNKNOWN unk_10089278; // weak
_UNKNOWN unk_10089400; // weak
_UNKNOWN unk_10089464; // weak
_UNKNOWN unk_10089468; // weak
_UNKNOWN unk_100894C0; // weak
_UNKNOWN unk_100894C4; // weak
_UNKNOWN unk_100894C8; // weak
_UNKNOWN unk_100894DC; // weak
_UNKNOWN unk_100894EC; // weak
_UNKNOWN unk_10089510; // weak
_UNKNOWN unk_10089514; // weak
_UNKNOWN unk_10089518; // weak
_UNKNOWN unk_1008951C; // weak
_UNKNOWN unk_10089520; // weak
_UNKNOWN unk_10089548; // weak
_UNKNOWN unk_100896F0; // weak
_UNKNOWN unk_10089744; // weak
_UNKNOWN unk_10089748; // weak
_UNKNOWN unk_100897D8; // weak
_UNKNOWN unk_100897DC; // weak
_UNKNOWN unk_100897E8; // weak
__int16 word_100897F0 = 48; // weak
_UNKNOWN unk_10089878; // weak
_UNKNOWN unk_100898E4; // weak
_UNKNOWN unk_100898F0; // weak
__int16 word_100898FC = 21574; // weak
_UNKNOWN unk_10089918; // weak
__int16 word_10089924 = 17297; // weak
_UNKNOWN unk_10089A7C; // weak
_UNKNOWN unk_10089A80; // weak
_UNKNOWN unk_10089A84; // weak
_UNKNOWN unk_10089A88; // weak
_UNKNOWN unk_10089A8C; // weak
_UNKNOWN unk_1008A038; // weak
_UNKNOWN unk_1008A044; // weak
int (__cdecl *off_1008A06C[3])(int, int, char, int) = { &sub_1001C810, &sub_1001C830, &sub_1001C7F0 }; // weak
__int16 word_1008A078[] = { 0 }; // weak
__int16 word_1008A07A[] = { 0 }; // weak
_UNKNOWN unk_1008A12C; // weak
_UNKNOWN unk_1008A140; // weak
_UNKNOWN unk_1008A464; // weak
_UNKNOWN unk_1008AC48; // weak
_UNKNOWN unk_1008AC88; // weak
_UNKNOWN unk_1008ACD8; // weak
_UNKNOWN unk_1008ACEC; // weak
_UNKNOWN unk_1008B2E0; // weak
_UNKNOWN unk_1008B2F8; // weak
_UNKNOWN unk_1008B33C; // weak
_UNKNOWN unk_1008B370; // weak
_UNKNOWN unk_1008B37C; // weak
_UNKNOWN unk_1008B418; // weak
_UNKNOWN unk_1008C1B0; // weak
char byte_1008DDD4[] = { '\0' }; // weak
int (__cdecl *off_1008DDDC)(int) = &sub_10002BF0; // weak
char byte_1008DDE0[] = { '\0' }; // weak
_UNKNOWN unk_1008DDE1; // weak
_UNKNOWN unk_1008EE60; // weak
_UNKNOWN unk_1008EF50; // weak
_UNKNOWN unk_1008F010; // weak
_UNKNOWN unk_1008F038; // weak
_UNKNOWN unk_1008F0F8; // weak
_UNKNOWN unk_1008F1B0; // weak
_UNKNOWN unk_1008F260; // weak
_UNKNOWN unk_1008F388; // weak
_UNKNOWN unk_1008F428; // weak
_UNKNOWN unk_1008F448; // weak
_UNKNOWN unk_1008F480; // weak
_UNKNOWN unk_1008F584; // weak
_UNKNOWN unk_1008F5C0; // weak
_UNKNOWN unk_1008F630; // weak
_UNKNOWN unk_1008F6D0; // weak
char byte_1008F6D1[] = { '\x17' }; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
int dword_10093EF8[] = { 6103 }; // weak
int dword_10093EFC[] = { 8000 }; // weak
char *off_10094568 = "/shr_mem/cdp_mngr_intf.shr"; // weak
float flt_10098490[] = {  1.0 }; // weak
float flt_1009849C[] = { -1.0 }; // weak
char byte_100984B4[] = { '\x02' }; // weak
_UNKNOWN unk_100984F8; // weak
_UNKNOWN unk_1009B8C0; // weak
_UNKNOWN unk_1009B8CC; // weak
char byte_1009C48C[] = { '\b' }; // weak
_UNKNOWN unk_1009CFD5; // weak
_UNKNOWN unk_1009D00E; // weak
char byte_1009D010[] = { '\x0E' }; // weak
char *off_1009D040 = "/shr_mem/udb_intf.shr"; // weak
char aWgs84[21] = "WGS 84              "; // weak
_UNKNOWN unk_1009E058; // weak
_UNKNOWN unk_1009EC24; // weak
char byte_1009EC25[] = { '\x0E' }; // weak
_UNKNOWN unk_100A3CF0; // weak
__int16 word_100A3CF2[] = { 4838 }; // weak
_UNKNOWN unk_100A3D28; // weak
_UNKNOWN unk_100A3D2C; // weak
_UNKNOWN unk_100A4E28; // weak
_UNKNOWN unk_100A4FB8; // weak
_UNKNOWN unk_100A5148; // weak
_UNKNOWN unk_100A5340; // weak
_UNKNOWN unk_100A5478; // weak
_UNKNOWN unk_100A547C; // weak
int dword_100A5C48[] = { 0 }; // weak
_UNKNOWN unk_100A5EB8; // weak
_UNKNOWN unk_100A5F88; // weak
_UNKNOWN unk_100A6058; // weak
_UNKNOWN unk_100A6128; // weak
_UNKNOWN unk_100A61F8; // weak
_UNKNOWN unk_100A62C8; // weak
_UNKNOWN unk_100A6398; // weak
_UNKNOWN unk_100A6468; // weak
_UNKNOWN unk_100A6538; // weak
_UNKNOWN unk_100A6608; // weak
_UNKNOWN unk_100A66D8; // weak
_UNKNOWN unk_100A67A8; // weak
_UNKNOWN unk_100A6878; // weak
_UNKNOWN unk_100A6948; // weak
_UNKNOWN unk_100A6A18; // weak
_UNKNOWN unk_100A6AE8; // weak
_UNKNOWN unk_100A6BB8; // weak
_UNKNOWN unk_100A6C88; // weak
_UNKNOWN unk_100A6D58; // weak
_UNKNOWN unk_100A6E28; // weak
_UNKNOWN unk_100A6EF8; // weak
_UNKNOWN unk_100A6FC8; // weak
_UNKNOWN unk_100A7098; // weak
_UNKNOWN unk_100A7168; // weak
_UNKNOWN unk_100A7238; // weak
_UNKNOWN unk_100A7308; // weak
_UNKNOWN unk_100A73D8; // weak
_UNKNOWN unk_100A74A8; // weak
_UNKNOWN unk_100A7578; // weak
_UNKNOWN unk_100A7648; // weak
_UNKNOWN unk_100A7718; // weak
_UNKNOWN unk_100A77E8; // weak
_UNKNOWN unk_100A78B8; // weak
_UNKNOWN unk_100A7988; // weak
_UNKNOWN unk_100A7A58; // weak
_UNKNOWN unk_100A7B28; // weak
_UNKNOWN unk_100A7BF8; // weak
_UNKNOWN unk_100A7CC8; // weak
_UNKNOWN unk_100A7D98; // weak
_UNKNOWN unk_100A7E68; // weak
_UNKNOWN unk_100A7F38; // weak
_UNKNOWN unk_100A8008; // weak
_UNKNOWN unk_100A80D8; // weak
_UNKNOWN unk_100A81A8; // weak
_UNKNOWN unk_100A8278; // weak
_UNKNOWN unk_100A8348; // weak
_UNKNOWN unk_100A8418; // weak
_UNKNOWN unk_100A84E8; // weak
_UNKNOWN unk_100A85B8; // weak
_UNKNOWN unk_100A8688; // weak
_UNKNOWN unk_100A8758; // weak
_UNKNOWN unk_100A8828; // weak
_UNKNOWN unk_100A88F8; // weak
_UNKNOWN unk_100A89C8; // weak
_UNKNOWN unk_100A8A98; // weak
_UNKNOWN unk_100A8B68; // weak
_UNKNOWN unk_100A8C38; // weak
_UNKNOWN unk_100A8D08; // weak
_UNKNOWN unk_100A8DD8; // weak
_UNKNOWN unk_100A8EA8; // weak
_UNKNOWN unk_100A8F78; // weak
_UNKNOWN unk_100A9048; // weak
_UNKNOWN unk_100A9118; // weak
_UNKNOWN unk_100A91E8; // weak
_UNKNOWN unk_100A92B8; // weak
_UNKNOWN unk_100A9388; // weak
_UNKNOWN unk_100A9458; // weak
int dword_100AA670 = 4294901760; // idb
int dword_100AA6AC[] = { 0 }; // weak
_UNKNOWN unk_100AA6E8; // weak
_UNKNOWN unk_100AA6FC; // weak
__int16 word_100AB23C[] = { 81 }; // weak
_UNKNOWN unk_100AB7D4; // weak
_UNKNOWN unk_100AB880; // weak
void *off_100AB884 = &unk_100AB7F4; // weak
char *off_100AC2C0[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_100AC130 }; // weak
_UNKNOWN unk_100AC2D4; // weak
__int16 word_100AD4C0[] = { 0 }; // weak
_UNKNOWN unk_100AE1D8; // weak
_UNKNOWN unk_100AE1F8; // weak
_UNKNOWN unk_100AE860; // weak
float flt_100AE864[] = {  16.0 }; // weak
float flt_100AE868[] = {  8.0 }; // weak
float flt_100AE8A8[] = { -1.0 }; // weak
float flt_100AE8AC[] = {  1.0 }; // weak
float flt_100AE8B0[] = {  10.0 }; // weak
void *off_100AF0E8 = &unk_10089520; // weak
int dword_100B01D4[] = { 88 }; // weak
__int16 word_100B0684[] = { 836 }; // weak
char *off_100B06A4 = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_100B06B8 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_100B06CC = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_100B06E0 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_100B06F4 = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_100B0708 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
_UNKNOWN unk_100B162C; // weak
_UNKNOWN unk_100B1630; // weak
wchar_t a___0[8] = L":;<=>?@"; // weak
wchar_t aAbcde_0[6] = L"ABCDE"; // weak
_UNKNOWN unk_100B2778; // weak
char *off_100B35E8 = "/shr_mem/iop_gea_intf.shr"; // weak
_UNKNOWN unk_100B3BE8; // weak
_UNKNOWN unk_100B3BF0; // weak
char byte_100B3BF8[] = { '\x01' }; // weak
__int16 word_100B48D0[] = { 100 }; // weak
int dword_100B5770[] = { 2175 }; // weak
_UNKNOWN unk_100B6658; // weak
char *off_100B67FC[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_100B6810 }; // weak
char *off_100B69A0 = "true"; // weak
char byte_100B69A4[] = { '\x01' }; // weak
char *off_100B6A08 = "failure listener"; // weak
_UNKNOWN unk_100B71B0; // weak
char *off_100B7848 = "/shr_mem/pvt_intf.shr"; // weak
char *off_100B78AC = "/shr_mem/nav_intf.shr"; // weak
char *off_100B791C = "/shr_mem/dat_intf.shr"; // weak
char *off_100B7950 = "/shr_mem/iop_fltr_data_intf.shr"; // weak
int (__cdecl *off_100B7EA8)(int, size_t, void *) = &sub_10046830; // weak
int (*off_100B83F0[4])() = { &sub_10046AF0, &sub_10046AD0, &sub_10046AE0, &sub_10046AD0 }; // weak
_UNKNOWN unk_100CDA68; // weak
int dword_100CDA6C = 4294967295; // weak
int dword_100CDA70 = 0; // weak
int dword_100CDA74 = 4278255615; // weak
int dword_100CDA78 = 0; // weak
int dword_100CDA7C[] = { 4278190080 }; // weak
int dword_100CDA80[] = { 4278255615 }; // weak
int dword_100CDA84 = 0; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_100CDD40 = "006-D0170-"; // weak
int (__cdecl *(*off_100CDD44)[2])(int, int) = &off_100E2D18; // weak
_BYTE word_100CE2EE[2794] =
{
  0,
  0,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  47,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  49,
  27,
  0,
  0,
  68,
  69,
  70,
  65,
  85,
  76,
  84,
  32,
  80,
  82,
  79,
  70,
  73,
  76,
  69,
  0,
  0,
  78,
  79,
  78,
  69,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  128,
  63,
  205,
  204,
  76,
  61,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  64,
  205,
  204,
  204,
  60,
  2,
  0,
  0,
  0,
  0,
  0,
  128,
  64,
  205,
  204,
  76,
  60,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  65,
  10,
  215,
  35,
  60,
  4,
  0,
  0,
  0,
  0,
  0,
  32,
  65,
  10,
  215,
  35,
  60,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  180,
  66,
  2,
  0,
  0,
  0,
  0,
  0,
  52,
  67,
  3,
  0,
  0,
  0,
  0,
  0,
  135,
  67,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2,
  23,
  21,
  3,
  3,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  18,
  10,
  18,
  10,
  28,
  14,
  29,
  14,
  29,
  14,
  29,
  10,
  29,
  10,
  28,
  10,
  24,
  10,
  24,
  0,
  24,
  0,
  23,
  0,
  22,
  0,
  23,
  0,
  23,
  0,
  23,
  0,
  28,
  0,
  24,
  0,
  22,
  0,
  20,
  10,
  24,
  10,
  18,
  10,
  20,
  10,
  24,
  10,
  13,
  10,
  20,
  10,
  28,
  10,
  18,
  0,
  22,
  0,
  22,
  0,
  20,
  0,
  18,
  10,
  18,
  0,
  28,
  0,
  23,
  0,
  22,
  10,
  28,
  10,
  22,
  10,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  28,
  0,
  0,
  1,
  0,
  136,
  25,
  0,
  0,
  1,
  0,
  1,
  0,
  137,
  25,
  0,
  0,
  2,
  0,
  1,
  0,
  138,
  25,
  0,
  0,
  4,
  0,
  1,
  0,
  139,
  25,
  0,
  0,
  5,
  0,
  1,
  0,
  140,
  25,
  0,
  0,
  6,
  0,
  1,
  0,
  141,
  25,
  0,
  0,
  18,
  0,
  1,
  0,
  142,
  25,
  0,
  0,
  19,
  0,
  1,
  0,
  143,
  25,
  0,
  0,
  20,
  0,
  1,
  0,
  144,
  25,
  0,
  0,
  21,
  0,
  1,
  0,
  145,
  25,
  0,
  0,
  22,
  0,
  1,
  0,
  146,
  25,
  0,
  0,
  23,
  0,
  1,
  0,
  147,
  25,
  0,
  0,
  25,
  0,
  1,
  0,
  148,
  25,
  0,
  0,
  26,
  0,
  1,
  0,
  149,
  25,
  0,
  0,
  27,
  0,
  1,
  0,
  150,
  25,
  0,
  0,
  28,
  0,
  1,
  0,
  151,
  25,
  0,
  0,
  29,
  0,
  1,
  0,
  152,
  25,
  0,
  0,
  30,
  0,
  1,
  0,
  153,
  25,
  0,
  0,
  31,
  0,
  1,
  0,
  154,
  25,
  0,
  0,
  32,
  0,
  4,
  0,
  155,
  25,
  0,
  0,
  36,
  0,
  4,
  0,
  156,
  25,
  0,
  0,
  40,
  0,
  1,
  0,
  157,
  25,
  0,
  0,
  41,
  0,
  1,
  0,
  158,
  25,
  0,
  0,
  42,
  0,
  1,
  0,
  159,
  25,
  0,
  0,
  43,
  0,
  1,
  0,
  160,
  25,
  0,
  0,
  44,
  0,
  1,
  0,
  161,
  25,
  0,
  0,
  45,
  0,
  1,
  0,
  162,
  25,
  0,
  0,
  46,
  0,
  1,
  0,
  163,
  25,
  0,
  0,
  47,
  0,
  1,
  0,
  164,
  25,
  0,
  0,
  49,
  0,
  1,
  0,
  166,
  25,
  0,
  0,
  50,
  0,
  30,
  0,
  167,
  25,
  0,
  0,
  80,
  0,
  1,
  0,
  168,
  25,
  0,
  0,
  81,
  0,
  1,
  0,
  169,
  25,
  0,
  0,
  84,
  0,
  4,
  0,
  170,
  25,
  0,
  0,
  88,
  0,
  1,
  0,
  171,
  25,
  0,
  0,
  89,
  0,
  1,
  0,
  172,
  25,
  0,
  0,
  92,
  0,
  4,
  0,
  173,
  25,
  0,
  0,
  96,
  0,
  4,
  0,
  174,
  25,
  0,
  0,
  100,
  0,
  1,
  0,
  175,
  25,
  0,
  0,
  208,
  0,
  4,
  0,
  168,
  23,
  0,
  0,
  104,
  0,
  1,
  0,
  177,
  25,
  0,
  0,
  105,
  0,
  1,
  0,
  178,
  25,
  0,
  0,
  106,
  0,
  1,
  0,
  179,
  25,
  0,
  0,
  107,
  0,
  1,
  0,
  180,
  25,
  0,
  0,
  108,
  0,
  1,
  0,
  181,
  25,
  0,
  0,
  109,
  0,
  1,
  0,
  182,
  25,
  0,
  0,
  110,
  0,
  1,
  0,
  183,
  25,
  0,
  0,
  111,
  0,
  1,
  0,
  184,
  25,
  0,
  0,
  112,
  0,
  1,
  0,
  185,
  25,
  0,
  0,
  113,
  0,
  1,
  0,
  186,
  25,
  0,
  0,
  114,
  0,
  1,
  0,
  187,
  25,
  0,
  0,
  115,
  0,
  1,
  0,
  188,
  25,
  0,
  0,
  116,
  0,
  1,
  0,
  189,
  25,
  0,
  0,
  117,
  0,
  1,
  0,
  190,
  25,
  0,
  0,
  118,
  0,
  1,
  0,
  191,
  25,
  0,
  0,
  120,
  0,
  4,
  0,
  192,
  25,
  0,
  0,
  124,
  0,
  4,
  0,
  193,
  25,
  0,
  0,
  128,
  0,
  4,
  0,
  194,
  25,
  0,
  0,
  132,
  0,
  4,
  0,
  195,
  25,
  0,
  0,
  136,
  0,
  4,
  0,
  196,
  25,
  0,
  0,
  140,
  0,
  1,
  0,
  197,
  25,
  0,
  0,
  141,
  0,
  1,
  0,
  198,
  25,
  0,
  0,
  142,
  0,
  1,
  0,
  199,
  25,
  0,
  0,
  144,
  0,
  2,
  0,
  200,
  25,
  0,
  0,
  146,
  0,
  1,
  0,
  201,
  25,
  0,
  0,
  147,
  0,
  1,
  0,
  202,
  25,
  0,
  0,
  148,
  0,
  1,
  0,
  203,
  25,
  0,
  0,
  149,
  0,
  1,
  0,
  204,
  25,
  0,
  0,
  150,
  0,
  1,
  0,
  205,
  25,
  0,
  0,
  151,
  0,
  1,
  0,
  206,
  25,
  0,
  0,
  152,
  0,
  1,
  0,
  207,
  25,
  0,
  0,
  153,
  0,
  1,
  0,
  208,
  25,
  0,
  0,
  154,
  0,
  1,
  0,
  209,
  25,
  0,
  0,
  155,
  0,
  1,
  0,
  210,
  25,
  0,
  0,
  156,
  0,
  1,
  0,
  211,
  25,
  0,
  0,
  157,
  0,
  1,
  0,
  212,
  25,
  0,
  0,
  158,
  0,
  1,
  0,
  213,
  25,
  0,
  0,
  159,
  0,
  1,
  0,
  214,
  25,
  0,
  0,
  160,
  0,
  1,
  0,
  215,
  25,
  0,
  0,
  161,
  0,
  1,
  0,
  216,
  25,
  0,
  0,
  162,
  0,
  1,
  0,
  217,
  25,
  0,
  0,
  163,
  0,
  1,
  0,
  218,
  25,
  0,
  0,
  164,
  0,
  1,
  0,
  219,
  25,
  0,
  0,
  165,
  0,
  1,
  0,
  220,
  25,
  0,
  0,
  166,
  0,
  1,
  0,
  221,
  25,
  0,
  0,
  167,
  0,
  1,
  0,
  222,
  25,
  0,
  0,
  168,
  0,
  1,
  0,
  223,
  25,
  0,
  0,
  169,
  0,
  1,
  0,
  224,
  25,
  0,
  0,
  170,
  0,
  1,
  0,
  225,
  25,
  0,
  0,
  171,
  0,
  1,
  0,
  226,
  25,
  0,
  0,
  172,
  0,
  1,
  0,
  227,
  25,
  0,
  0,
  173,
  0,
  1,
  0,
  228,
  25,
  0,
  0,
  174,
  0,
  1,
  0,
  229,
  25,
  0,
  0,
  177,
  0,
  1,
  0,
  231,
  25,
  0,
  0,
  178,
  0,
  1,
  0,
  232,
  25,
  0,
  0,
  179,
  0,
  1,
  0,
  233,
  25,
  0,
  0,
  180,
  0,
  1,
  0,
  234,
  25,
  0,
  0,
  181,
  0,
  1,
  0,
  235,
  25,
  0,
  0,
  182,
  0,
  5,
  0,
  236,
  25,
  0,
  0,
  187,
  0,
  1,
  0,
  237,
  25,
  0,
  0,
  188,
  0,
  1,
  0,
  238,
  25,
  0,
  0,
  189,
  0,
  1,
  0,
  239,
  25,
  0,
  0,
  190,
  0,
  1,
  0,
  240,
  25,
  0,
  0,
  191,
  0,
  1,
  0,
  241,
  25,
  0,
  0,
  192,
  0,
  1,
  0,
  242,
  25,
  0,
  0,
  193,
  0,
  1,
  0,
  243,
  25,
  0,
  0,
  194,
  0,
  1,
  0,
  244,
  25,
  0,
  0,
  195,
  0,
  1,
  0,
  245,
  25,
  0,
  0,
  196,
  0,
  1,
  0,
  246,
  25,
  0,
  0,
  197,
  0,
  1,
  0,
  28,
  26,
  0,
  0,
  198,
  0,
  1,
  0,
  29,
  26,
  0,
  0,
  199,
  0,
  1,
  0,
  30,
  26,
  0,
  0,
  200,
  0,
  1,
  0,
  117,
  26,
  0,
  0,
  201,
  0,
  1,
  0,
  118,
  26,
  0,
  0,
  202,
  0,
  1,
  0,
  124,
  26,
  0,
  0,
  203,
  0,
  1,
  0,
  144,
  26,
  0,
  0,
  204,
  0,
  1,
  0,
  145,
  26,
  0,
  0,
  205,
  0,
  1,
  0,
  30,
  27,
  0,
  0,
  206,
  0,
  1,
  0,
  149,
  26,
  0,
  0,
  32,
  0,
  0,
  0,
  150,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  167,
  26,
  0,
  0,
  4,
  0,
  0,
  0,
  168,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  169,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  170,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  171,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  172,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  176,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  241,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  244,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  247,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  248,
  26,
  0,
  0,
  1,
  0,
  0,
  0,
  249,
  26,
  0,
  0,
  13,
  0,
  0,
  0,
  29,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  40,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  39,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  47,
  27,
  0,
  0,
  1,
  0,
  0,
  0,
  49,
  27,
  0,
  0
}; // idb
__int16 word_100CEE20[] = { 43 }; // weak
char byte_100CEE24[] = { '\x06' }; // weak
char *off_100CF3CC[18] =
{
  "FAIL",
  "PASS",
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100CF3D4[16] =
{
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100CF3DC[14] =
{
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100CF3F8[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_100CF404[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_100CF40C[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_100CF6C0; // weak
_UNKNOWN unk_100CF6FC; // weak
char *off_100CFAB8 = "printf_listener"; // weak
int (*off_100D07A0[2])() = { &sub_100666D0, &sub_10038340 }; // weak
char *off_100D0850 = "gate_listener"; // weak
_UNKNOWN unk_100D19A8; // weak
int dword_100D19AC[] = { 1312 }; // weak
_UNKNOWN unk_100D32E8; // weak
int dword_100D32EC[] = { 6006 }; // weak
char byte_100D3330[] = { '\x01' }; // weak
__int16 word_100D3332[] = { 3020 }; // weak
_UNKNOWN unk_100D4040; // weak
char byte_100D4044[] = { '\0' }; // weak
_UNKNOWN unk_100D4158; // weak
_UNKNOWN unk_100D4170; // weak
_UNKNOWN unk_100D41B8; // weak
int dword_100D41BC[] = { 6767 }; // weak
_UNKNOWN unk_100D41C8; // weak
_UNKNOWN unk_100D41E0; // weak
_UNKNOWN unk_100D41F8; // weak
int dword_100D41FC[] = { 6769 }; // weak
_UNKNOWN unk_100D4210; // weak
int dword_100D4214[] = { 6093 }; // weak
int (__cdecl *off_100D6448[3])(char) = { &sub_10037C10, &sub_10037B20, &sub_10037AE0 }; // weak
__int16 word_100D64AC[] = { 464 }; // weak
char byte_100D6D39[] = { '\x1E' }; // weak
_UNKNOWN unk_100DA128; // weak
int dword_100DA12C[] = { 0 }; // weak
_UNKNOWN unk_100DA4C8; // weak
int dword_100DA4CC[] = { 0 }; // weak
_UNKNOWN unk_100DB170; // weak
void *off_100DB174 = &unk_100DAEE8; // weak
_WORD dword_100DB318[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100DB718[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100DBB18[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100DBF18[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100DC318[] = { 99 }; // weak
int dword_100DC718[] = { 25344 }; // weak
int dword_100DCB18[] = { 6488064 }; // weak
int dword_100DCF18[] = { 1660944384 }; // weak
int dword_100DD340[] = { 128 }; // weak
int dword_100DD350[] = { 0 }; // weak
int dword_100DD360[] = { 0 }; // weak
char byte_100DD3D1[] = { '\0' }; // weak
char byte_100DD3D2[] = { '\0' }; // weak
char byte_100DD3D3[] = { '\0' }; // weak
char byte_100DD3D4[] = { '\x10' }; // weak
int dword_100DD3E8[] = { 0 }; // weak
_UNKNOWN unk_100DD460; // weak
_UNKNOWN unk_100DD8E0; // weak
char byte_100DD958[] = { '\0' }; // weak
char byte_100DDA58[] = { '\0' }; // weak
char byte_100DDB58[] = { '\0' }; // weak
int dword_100DDC58[] = { 0 }; // weak
int dword_100DDCD0[] = { 0 }; // weak
int (__cdecl *off_100DDD50)(int, int) = &sub_1005AFA0; // weak
int dword_100DDF38[] = { 0 }; // weak
int dword_100DDF80[] = { 16 }; // weak
_UNKNOWN unk_100DDFD0; // weak
_UNKNOWN unk_100DE050; // weak
_UNKNOWN unk_100DE0D0; // weak
_UNKNOWN unk_100DE148; // weak
_UNKNOWN unk_100DE1C0; // weak
_UNKNOWN unk_100DF1C0; // weak
int dword_100E1E2C[] = { 1600085855 }; // weak
_UNKNOWN unk_100E2CE8; // weak
char byte_100E2CE9[] = { '\0' }; // weak
int (__cdecl *off_100E2D18[2])(int, int) = { &sub_1005D460, &sub_1005D4C0 }; // weak
_UNKNOWN unk_100E2D20; // weak
_UNKNOWN unk_100E2D21; // weak
_UNKNOWN unk_100E2E88; // weak
_UNKNOWN unk_100E2EAC; // weak
_UNKNOWN unk_100E3038; // weak
char off_100E3C60[] = { '', '', '\f', '\x10' }; // idb
int dword_100E3C7C = 1; // idb
char byte_100E3C98[] = { '\x01' }; // weak
void *off_100E3C9C = &unk_100897E8; // weak
void *off_100E3CA0 = &unk_100897DC; // weak
char off_100E3CA4[8] = { 'L', '<', '\x0E', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100E3D28[] = { '\0' }; // weak
char byte_100E3D29[] = { '\0' }; // weak
int dword_100E3D2C[] = { 0 }; // weak
char *off_100E3D30 = "0, 0, 0"; // weak
double dbl_100E3F98[] = {  0.0 }; // weak
double dbl_100E3FA0[] = {  0.0 }; // weak
double dbl_100E3FA8[] = {  0.0 }; // weak
int dword_100E3FB0[] = { 0 }; // weak
char off_100E3FB4[32] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100E4BB8[] = {  0.0 }; // weak
float flt_100E4BBC[] = {  0.0 }; // weak
float flt_100E4BC0[] = {  0.0 }; // weak
int dword_100E4BC4[] = { 0 }; // weak
char off_100E4BC8[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_100E534C[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100F9FA8
}; // weak
int dword_100E5360[] = { 0 }; // weak
int dword_100E5364[] = { 0 }; // weak
int dword_100E5368[] = { 0 }; // weak
int dword_100E536C[] = { 0 }; // weak
char *off_100E5370 = "0, 0, 0"; // weak
__int16 word_100E5AF8[] = { 0 }; // weak
__int16 word_100E5AFA[] = { 0 }; // weak
__int16 word_100E5AFC[] = { 0 }; // weak
int dword_100E5B00[] = { 0 }; // weak
char *off_100E5B04 = "0, 0, 0"; // weak
int dword_100E6108[] = { 0 }; // weak
int dword_100E610C[] = { 0 }; // weak
int dword_100E6110[] = { 0 }; // weak
int dword_100E6114[] = { 0 }; // weak
char off_100E6118[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100E68A0[] = { 0 }; // weak
int dword_100E68A4[] = { 0 }; // weak
int dword_100E68A8[] = { 0 }; // weak
int dword_100E68AC[] = { 0 }; // weak
int dword_100E68B0[] = { 0 }; // weak
int dword_100E68B4[] = { 0 }; // weak
int dword_100E68B8[] = { 0 }; // weak
char off_100E68BC[32] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100E74C0[] = { '\0' }; // weak
char byte_100E74C1[] = { '\0' }; // weak
char byte_100E74C2[] = { '\0' }; // weak
int dword_100E74C4[] = { 0 }; // weak
char *off_100E74C8 = "0, 0, 0"; // weak
int dword_100E7950[] = { 0 }; // weak
int dword_100E7954[] = { 0 }; // weak
int dword_100E7958[] = { 0 }; // weak
int dword_100E795C[] = { 0 }; // weak
char *off_100E7960 = "0, 0, 0"; // weak
int dword_100E80E8[] = { 0 }; // weak
int dword_100E80EC[] = { 0 }; // weak
int dword_100E80F0[] = { 0 }; // weak
int dword_100E80F4[] = { 0 }; // weak
char off_100E80F8[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100E8458[] = { 0 }; // weak
__int16 word_100E845A[] = { 0 }; // weak
__int16 word_100E845C[] = { 0 }; // weak
int dword_100E8460[] = { 0 }; // weak
char *off_100E8464 = "0, 0, 0"; // weak
int dword_100E8718[] = { 0 }; // weak
int dword_100E871C[] = { 0 }; // weak
int dword_100E8720[] = { 0 }; // weak
int dword_100E8724[] = { 0 }; // weak
char off_100E8728[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100E8A88[] = { 0 }; // weak
int dword_100E8A8C[] = { 0 }; // weak
int dword_100E8A90[] = { 0 }; // weak
int dword_100E8A94[] = { 0 }; // weak
int dword_100E8A98[] = { 0 }; // weak
int dword_100E8A9C[] = { 0 }; // weak
int dword_100E8AA0[] = { 0 }; // weak
char *off_100E8AA4 = "0, 0, 0"; // weak
char byte_100E9008[] = { '\0' }; // weak
char byte_100E9009[] = { '\0' }; // weak
char byte_100E900A[] = { '\0' }; // weak
int dword_100E900C[] = { 0 }; // weak
char *off_100E9010 = "0, 0, 0"; // weak
int dword_100E9218[] = { 0 }; // weak
int dword_100E921C[] = { 0 }; // weak
int dword_100E9220[] = { 0 }; // weak
int dword_100E9224[] = { 0 }; // weak
char off_100E9228[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100E9588[] = { '\x01' }; // weak
void *off_100E958C = &unk_100897E8; // weak
void *off_100E9590 = &unk_100897DC; // weak
char off_100E9594[8] = { '', '7', '\x0E', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100E9618[] = { '\0' }; // weak
char byte_100E9619[] = { '\0' }; // weak
int dword_100E961C[] = { 0 }; // weak
char *off_100E9620 = "0, 0, 0"; // weak
double dbl_100E9888[] = {  0.0 }; // weak
double dbl_100E9890[] = {  0.0 }; // weak
double dbl_100E9898[] = {  0.0 }; // weak
int dword_100E98A0[] = { 0 }; // weak
char *off_100E98A4 = "0, 0, 0"; // weak
float flt_100EA4A8[] = {  0.0 }; // weak
float flt_100EA4AC[] = {  0.0 }; // weak
float flt_100EA4B0[] = {  0.0 }; // weak
int dword_100EA4B4[] = { 0 }; // weak
char off_100EA4B8[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100EAC40[] = { 0 }; // weak
int dword_100EAC44[] = { 0 }; // weak
int dword_100EAC48[] = { 0 }; // weak
int dword_100EAC4C[] = { 0 }; // weak
char *off_100EAC50 = "0, 0, 0"; // weak
__int16 word_100EB3D8[] = { 0 }; // weak
__int16 word_100EB3DA[] = { 0 }; // weak
__int16 word_100EB3DC[] = { 0 }; // weak
int dword_100EB3E0[] = { 0 }; // weak
char *off_100EB3E4 = "0, 0, 0"; // weak
int dword_100EB9E8[] = { 0 }; // weak
int dword_100EB9EC[] = { 0 }; // weak
int dword_100EB9F0[] = { 0 }; // weak
int dword_100EB9F4[] = { 0 }; // weak
char off_100EB9F8[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100EC180[] = { 0 }; // weak
int dword_100EC184[] = { 0 }; // weak
int dword_100EC188[] = { 0 }; // weak
int dword_100EC18C[] = { 0 }; // weak
int dword_100EC190[] = { 0 }; // weak
int dword_100EC194[] = { 0 }; // weak
int dword_100EC198[] = { 0 }; // weak
char off_100EC19C[32] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100ECDA0[] = { '\0' }; // weak
char byte_100ECDA1[] = { '\0' }; // weak
char byte_100ECDA2[] = { '\0' }; // weak
int dword_100ECDA4[] = { 0 }; // weak
char *off_100ECDA8 = "0, 0, 0"; // weak
int dword_100ED230[] = { 0 }; // weak
int dword_100ED234[] = { 0 }; // weak
int dword_100ED238[] = { 0 }; // weak
int dword_100ED23C[] = { 0 }; // weak
char *off_100ED240 = "0, 0, 0"; // weak
int dword_100ED9C8[] = { 0 }; // weak
int dword_100ED9CC[] = { 0 }; // weak
int dword_100ED9D0[] = { 0 }; // weak
int dword_100ED9D4[] = { 0 }; // weak
char off_100ED9D8[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100EDD38[] = { 0 }; // weak
__int16 word_100EDD3A[] = { 0 }; // weak
__int16 word_100EDD3C[] = { 0 }; // weak
int dword_100EDD40[] = { 0 }; // weak
char *off_100EDD44 = "0, 0, 0"; // weak
int dword_100EDFF8[] = { 0 }; // weak
int dword_100EDFFC[] = { 0 }; // weak
int dword_100EE000[] = { 0 }; // weak
int dword_100EE004[] = { 0 }; // weak
char off_100EE008[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100EE368[] = { 0 }; // weak
int dword_100EE36C[] = { 0 }; // weak
int dword_100EE370[] = { 0 }; // weak
int dword_100EE374[] = { 0 }; // weak
int dword_100EE378[] = { 0 }; // weak
int dword_100EE37C[] = { 0 }; // weak
int dword_100EE380[] = { 0 }; // weak
char *off_100EE384 = "0, 0, 0"; // weak
char byte_100EE8E8[] = { '\0' }; // weak
char byte_100EE8E9[] = { '\0' }; // weak
char byte_100EE8EA[] = { '\0' }; // weak
int dword_100EE8EC[] = { 0 }; // weak
char *off_100EE8F0 = "0, 0, 0"; // weak
int dword_100EEAF8[] = { 0 }; // weak
int dword_100EEAFC[] = { 0 }; // weak
int dword_100EEB00[] = { 0 }; // weak
int dword_100EEB04[] = { 0 }; // weak
char off_100EEB08[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100EEE68[] = { '\x01' }; // weak
void *off_100EEE6C = &unk_100897E8; // weak
void *off_100EEE70 = &unk_100897E8; // weak
char off_100EEE74[8] = { '8', '7', '\x0E', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100EEEB8[] = { '\0' }; // weak
char byte_100EEEB9[] = { '\0' }; // weak
int dword_100EEEBC[] = { 0 }; // weak
char *off_100EEEC0 = "0, 0, 0"; // weak
double dbl_100EF128[] = {  0.0 }; // weak
double dbl_100EF130[] = {  0.0 }; // weak
double dbl_100EF138[] = {  0.0 }; // weak
int dword_100EF140[] = { 0 }; // weak
char *off_100EF144 = "0, 0, 0"; // weak
float flt_100EFD48[] = {  0.0 }; // weak
float flt_100EFD4C[] = {  0.0 }; // weak
float flt_100EFD50[] = {  0.0 }; // weak
int dword_100EFD54[] = { 0 }; // weak
char off_100EFD58[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100F04E0[] = { 0 }; // weak
int dword_100F04E4[] = { 0 }; // weak
int dword_100F04E8[] = { 0 }; // weak
int dword_100F04EC[] = { 0 }; // weak
char *off_100F04F0 = "0, 0, 0"; // weak
__int16 word_100F0C78[] = { 0 }; // weak
__int16 word_100F0C7A[] = { 0 }; // weak
__int16 word_100F0C7C[] = { 0 }; // weak
int dword_100F0C80[] = { 0 }; // weak
char *off_100F0C84 = "0, 0, 0"; // weak
int dword_100F1288[] = { 0 }; // weak
int dword_100F128C[] = { 0 }; // weak
int dword_100F1290[] = { 0 }; // weak
int dword_100F1294[] = { 0 }; // weak
char off_100F1298[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100F1A20[] = { 0 }; // weak
int dword_100F1A24[] = { 0 }; // weak
int dword_100F1A28[] = { 0 }; // weak
int dword_100F1A2C[] = { 0 }; // weak
int dword_100F1A30[] = { 0 }; // weak
int dword_100F1A34[] = { 0 }; // weak
int dword_100F1A38[] = { 0 }; // weak
char off_100F1A3C[32] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100F2640[] = { '\0' }; // weak
char byte_100F2641[] = { '\0' }; // weak
char byte_100F2642[] = { '\0' }; // weak
int dword_100F2644[] = { 0 }; // weak
char *off_100F2648 = "0, 0, 0"; // weak
int dword_100F2AD0[] = { 0 }; // weak
int dword_100F2AD4[] = { 0 }; // weak
int dword_100F2AD8[] = { 0 }; // weak
int dword_100F2ADC[] = { 0 }; // weak
char *off_100F2AE0 = "0, 0, 0"; // weak
int dword_100F3268[] = { 0 }; // weak
int dword_100F326C[] = { 0 }; // weak
int dword_100F3270[] = { 0 }; // weak
int dword_100F3274[] = { 0 }; // weak
char off_100F3278[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100F35D8[] = { 0 }; // weak
__int16 word_100F35DA[] = { 0 }; // weak
__int16 word_100F35DC[] = { 0 }; // weak
int dword_100F35E0[] = { 0 }; // weak
char *off_100F35E4 = "0, 0, 0"; // weak
int dword_100F3898[] = { 0 }; // weak
int dword_100F389C[] = { 0 }; // weak
int dword_100F38A0[] = { 0 }; // weak
int dword_100F38A4[] = { 0 }; // weak
char off_100F38A8[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100F3C08[] = { 0 }; // weak
int dword_100F3C0C[] = { 0 }; // weak
int dword_100F3C10[] = { 0 }; // weak
int dword_100F3C14[] = { 0 }; // weak
int dword_100F3C18[] = { 0 }; // weak
int dword_100F3C1C[] = { 0 }; // weak
int dword_100F3C20[] = { 0 }; // weak
char *off_100F3C24 = "0, 0, 0"; // weak
char byte_100F4188[] = { '\0' }; // weak
char byte_100F4189[] = { '\0' }; // weak
char byte_100F418A[] = { '\0' }; // weak
int dword_100F418C[] = { 0 }; // weak
char *off_100F4190 = "0, 0, 0"; // weak
int dword_100F4398[] = { 0 }; // weak
int dword_100F439C[] = { 0 }; // weak
int dword_100F43A0[] = { 0 }; // weak
int dword_100F43A4[] = { 0 }; // weak
char off_100F43A8[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100F4708[] = { '\x01' }; // weak
void *off_100F470C = &unk_100897E8; // weak
void *off_100F4710 = &unk_100897E8; // weak
char off_100F4714[8] = { '', '6', '\x0E', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100F4758[] = { '\0' }; // weak
char byte_100F4759[] = { '\0' }; // weak
int dword_100F475C[] = { 0 }; // weak
char *off_100F4760 = "0, 0, 0"; // weak
double dbl_100F49C8[] = {  0.0 }; // weak
double dbl_100F49D0[] = {  0.0 }; // weak
double dbl_100F49D8[] = {  0.0 }; // weak
int dword_100F49E0[] = { 0 }; // weak
char *off_100F49E4 = "0, 0, 0"; // weak
float flt_100F55E8[] = {  0.0 }; // weak
float flt_100F55EC[] = {  0.0 }; // weak
float flt_100F55F0[] = {  0.0 }; // weak
int dword_100F55F4[] = { 0 }; // weak
char off_100F55F8[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100F5D80[] = { 0 }; // weak
int dword_100F5D84[] = { 0 }; // weak
int dword_100F5D88[] = { 0 }; // weak
int dword_100F5D8C[] = { 0 }; // weak
char *off_100F5D90 = "0, 0, 0"; // weak
__int16 word_100F6518[] = { 0 }; // weak
__int16 word_100F651A[] = { 0 }; // weak
__int16 word_100F651C[] = { 0 }; // weak
int dword_100F6520[] = { 0 }; // weak
char *off_100F6524 = "0, 0, 0"; // weak
int dword_100F6B28[] = { 0 }; // weak
int dword_100F6B2C[] = { 0 }; // weak
int dword_100F6B30[] = { 0 }; // weak
int dword_100F6B34[] = { 0 }; // weak
char off_100F6B38[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100F72C0[] = { 0 }; // weak
int dword_100F72C4[] = { 0 }; // weak
int dword_100F72C8[] = { 0 }; // weak
int dword_100F72CC[] = { 0 }; // weak
int dword_100F72D0[] = { 0 }; // weak
int dword_100F72D4[] = { 0 }; // weak
int dword_100F72D8[] = { 0 }; // weak
char off_100F72DC[32] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100F7EE0[] = { '\0' }; // weak
char byte_100F7EE1[] = { '\0' }; // weak
char byte_100F7EE2[] = { '\0' }; // weak
int dword_100F7EE4[] = { 0 }; // weak
char *off_100F7EE8 = "0, 0, 0"; // weak
int dword_100F8370[] = { 0 }; // weak
int dword_100F8374[] = { 0 }; // weak
int dword_100F8378[] = { 0 }; // weak
int dword_100F837C[] = { 0 }; // weak
char *off_100F8380 = "0, 0, 0"; // weak
int dword_100F8B08[] = { 0 }; // weak
int dword_100F8B0C[] = { 0 }; // weak
int dword_100F8B10[] = { 0 }; // weak
int dword_100F8B14[] = { 0 }; // weak
char off_100F8B18[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100F8E78[] = { 0 }; // weak
__int16 word_100F8E7A[] = { 0 }; // weak
__int16 word_100F8E7C[] = { 0 }; // weak
int dword_100F8E80[] = { 0 }; // weak
char *off_100F8E84 = "0, 0, 0"; // weak
int dword_100F9138[] = { 0 }; // weak
int dword_100F913C[] = { 0 }; // weak
int dword_100F9140[] = { 0 }; // weak
int dword_100F9144[] = { 0 }; // weak
char off_100F9148[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100F94A8[] = { 0 }; // weak
int dword_100F94AC[] = { 0 }; // weak
int dword_100F94B0[] = { 0 }; // weak
int dword_100F94B4[] = { 0 }; // weak
int dword_100F94B8[] = { 0 }; // weak
int dword_100F94BC[] = { 0 }; // weak
int dword_100F94C0[] = { 0 }; // weak
char *off_100F94C4 = "0, 0, 0"; // weak
char byte_100F9A28[] = { '\0' }; // weak
char byte_100F9A29[] = { '\0' }; // weak
char byte_100F9A2A[] = { '\0' }; // weak
int dword_100F9A2C[] = { 0 }; // weak
char *off_100F9A30 = "0, 0, 0"; // weak
int dword_100F9C38[] = { 0 }; // weak
int dword_100F9C3C[] = { 0 }; // weak
int dword_100F9C40[] = { 0 }; // weak
int dword_100F9C44[] = { 0 }; // weak
char off_100F9C48[20] =
{
  '',
  ';',
  '\x0E',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100FAC28; // weak
int dword_100FDDFC[] = { 0 }; // weak
_UNKNOWN off_100FDE00; // weak
_UNKNOWN unk_100FDE90; // weak
_UNKNOWN unk_100FDE94; // weak
_UNKNOWN unk_100FDE98; // weak
_UNKNOWN unk_100FDE9C; // weak
_UNKNOWN unk_100FDEA0; // weak
_UNKNOWN unk_100FDEA4; // weak
_UNKNOWN unk_100FDEA8; // weak
_UNKNOWN unk_100FDEAC; // weak
_UNKNOWN unk_100FFA80; // weak
int dword_100FFA84[] = { 0 }; // weak
_UNKNOWN unk_100FFA98; // weak
int dword_100FFA9C[] = { 0 }; // weak
_UNKNOWN unk_100FFAC0; // weak
int dword_100FFAC4[] = { 0 }; // weak
_UNKNOWN unk_100FFAF0; // weak
int dword_100FFAF4[] = { 0 }; // weak
char byte_100FFBA8[] = { '\x01' }; // weak
__int16 word_100FFBAA[] = { 3020 }; // weak
_UNKNOWN unk_10103808; // weak
int dword_10105A78 = 64; // weak
__int16 word_10105A7C[] = { 6782 }; // weak
__int16 word_10105A80[] = { 128 }; // weak
_UNKNOWN unk_10105A9C; // weak
_DWORD dword_10105AA0[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
char *off_10107940 = "/shr_mem/iop_gtx_intf.shr"; // weak
int dword_10107984[] = { 6829 }; // weak
__int16 word_10108D28[] = { 1565 }; // weak
__int16 word_10108D2C[] = { 534 }; // weak
char byte_10108D30[] = { '\x04' }; // weak
__int16 word_10108D32[] = { 6512 }; // weak
int dword_10108D48[] = { 118000 }; // weak
__int16 word_10109872[] = { 233 }; // weak
int dword_10109878[] = { 6201 }; // weak
__int16 word_1010B594[] = { 114 }; // weak
__int16 word_1010B6A0[] = { 551 }; // weak
char byte_1010BCBA[] = { '\x04' }; // weak
char byte_1010BCBF[] = { '\a' }; // weak
char byte_101125E8[] = { '\0' }; // weak
char byte_101125F4[12] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\xFF',
  '\0',
  '\x01',
  '\0'
}; // idb
int dword_10112600 = 0; // idb
int dword_10112F10[] = { 0 }; // weak
_UNKNOWN unk_1011CC80; // weak
int dword_1011CC84[] = { 3535 }; // weak
_UNKNOWN unk_1011CCB8; // weak
int dword_1011CCBC[] = { 6813 }; // weak
_UNKNOWN unk_1011CCF0; // weak
int dword_1011CCF4[] = { 9036 }; // weak
_UNKNOWN unk_1011CD28; // weak
int dword_1011CD2C[] = { 6763 }; // weak
_UNKNOWN unk_1011D560; // weak
_UNKNOWN unk_1011D568; // weak
int (*off_1011F25C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_1011F280; // weak
_UNKNOWN unk_1011FA00; // weak
void *off_1011FCE0 = &unk_102D2B80; // weak
_UNKNOWN unk_1011FCF0; // weak
_UNKNOWN unk_1011FD50; // weak
int dword_1011FF60 = 2; // weak
int dword_10120150 = 1024; // weak
int dword_10120154 = 4294966273; // weak
int dword_10120158 = 53; // weak
int dword_1012015C = 11; // weak
int dword_10120160 = 64; // weak
int dword_10120164 = 1023; // weak
int dword_10120168 = 128; // weak
int dword_1012016C = 4294967169; // weak
int dword_10120170 = 24; // weak
int dword_10120174 = 8; // weak
int dword_10120178 = 32; // weak
int dword_1012017C = 127; // weak
_UNKNOWN unk_10120800; // weak
char byte_10120804 = '\0'; // weak
int dword_10120808 = 0; // weak
_UNKNOWN unk_10120810; // weak
char byte_101208E0 = '\0'; // weak
char byte_101208E8 = '\0'; // idb
int dword_101218E8; // weak
char byte_101218F0[]; // weak
char byte_101218F2; // weak
__int16 word_101218F4[]; // weak
int dword_101218F8; // weak
int dword_101218FC; // weak
__int16 word_10121900[]; // weak
_UNKNOWN unk_10121908; // weak
_UNKNOWN unk_101219A0; // weak
int dword_1017E5A0; // weak
int dword_1017E5A4; // weak
int dword_1017E5A8; // weak
char byte_1017E5AC; // weak
_UNKNOWN unk_1017E5B0; // weak
char byte_10183450; // weak
char byte_10183451; // weak
int dword_10183454; // weak
int dword_10183458; // weak
int dword_1018345C; // weak
int dword_10183460; // weak
int dword_10183464; // weak
int dword_10183468; // weak
int dword_10188CF0; // weak
_DWORD dword_10194B20[16]; // idb
int dword_10194B60[]; // weak
int dword_10194BA0; // weak
int dword_10194BA8[]; // weak
int dword_101A1BCC; // weak
__int16 word_101A1BD8[]; // weak
char byte_101A1C00[]; // weak
void (__cdecl *dword_101A1D00[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_101A1D20; // weak
__int16 word_101A6E8C; // weak
__int16 word_101A6E90; // weak
__int16 word_101A6E94; // weak
int dword_101A6E98; // weak
float flt_101A6E9C; // weak
float flt_101A6EA0; // weak
int dword_101A6EA4; // weak
_UNKNOWN unk_101A6EA8; // weak
_UNKNOWN unk_101A6EA9; // weak
_UNKNOWN unk_101A6EBF; // weak
_UNKNOWN unk_101A6EC0; // weak
_UNKNOWN unk_101A6EC1; // weak
_UNKNOWN unk_101A6EC2; // weak
_UNKNOWN unk_101A6EC4; // weak
_UNKNOWN unk_101A6EC8; // weak
_UNKNOWN unk_101A6ECC; // weak
_UNKNOWN unk_101A6EEC; // weak
_UNKNOWN unk_101A6F0C; // weak
_UNKNOWN unk_101A6F2C; // weak
_UNKNOWN unk_101A6F4C; // weak
_UNKNOWN unk_101A6F6C; // weak
_UNKNOWN unk_101A6F8C; // weak
_UNKNOWN unk_101A6FAC; // weak
_UNKNOWN unk_101A6FCC; // weak
_UNKNOWN unk_101A6FEC; // weak
_UNKNOWN unk_101A700C; // weak
_UNKNOWN unk_101A702C; // weak
_UNKNOWN unk_101A704C; // weak
_UNKNOWN unk_101A706C; // weak
_UNKNOWN unk_101A708C; // weak
_UNKNOWN unk_101A70AC; // weak
_UNKNOWN unk_101A70CC; // weak
_UNKNOWN unk_101A70EC; // weak
_UNKNOWN unk_101A710C; // weak
_UNKNOWN unk_101A712C; // weak
_UNKNOWN unk_101A714C; // weak
_UNKNOWN unk_101A716C; // weak
_UNKNOWN unk_101A718C; // weak
_UNKNOWN unk_101A71AC; // weak
_UNKNOWN unk_101A71CC; // weak
_UNKNOWN unk_101A71EC; // weak
_UNKNOWN unk_101A720C; // weak
_UNKNOWN unk_101A722C; // weak
_UNKNOWN unk_101A724C; // weak
_UNKNOWN unk_101A7250; // weak
_UNKNOWN unk_101A7254; // weak
_UNKNOWN unk_101A7258; // weak
_UNKNOWN unk_101A725C; // weak
_UNKNOWN unk_101A7260; // weak
_UNKNOWN unk_101A7264; // weak
_UNKNOWN unk_101A7284; // weak
_UNKNOWN unk_101A72A4; // weak
_UNKNOWN unk_101A72C4; // weak
_UNKNOWN unk_101A72E4; // weak
_UNKNOWN unk_101A7304; // weak
_UNKNOWN unk_101A7324; // weak
_UNKNOWN unk_101A7344; // weak
_UNKNOWN unk_101A7364; // weak
_UNKNOWN unk_101A7365; // weak
_UNKNOWN unk_101A7366; // weak
_UNKNOWN unk_101A73B8; // weak
_UNKNOWN unk_101A73D8; // weak
_UNKNOWN unk_101A73F8; // weak
_UNKNOWN unk_101A73FC; // weak
_UNKNOWN unk_101A7400; // weak
_UNKNOWN unk_101A7404; // weak
_UNKNOWN unk_101A7424; // weak
_UNKNOWN unk_101A7444; // weak
_UNKNOWN unk_101A7464; // weak
_UNKNOWN unk_101A7484; // weak
_UNKNOWN unk_101A74A4; // weak
_UNKNOWN unk_101A74C4; // weak
_UNKNOWN unk_101A74E4; // weak
_UNKNOWN unk_101A7504; // weak
_UNKNOWN unk_101A7524; // weak
_UNKNOWN unk_101A756C; // weak
_UNKNOWN unk_101A75B4; // weak
_UNKNOWN unk_101A75FC; // weak
_UNKNOWN unk_101A7644; // weak
_UNKNOWN unk_101A768C; // weak
_UNKNOWN unk_101A76D4; // weak
_UNKNOWN unk_101A771C; // weak
_UNKNOWN unk_101A7764; // weak
_UNKNOWN unk_101A77AC; // weak
_UNKNOWN unk_101A77F4; // weak
_UNKNOWN unk_101A783C; // weak
_UNKNOWN unk_101A7884; // weak
_UNKNOWN unk_101A78CC; // weak
_UNKNOWN unk_101A7914; // weak
_UNKNOWN unk_101A795C; // weak
_UNKNOWN unk_101A79A4; // weak
_UNKNOWN unk_101A79EC; // weak
_UNKNOWN unk_101A7A34; // weak
_UNKNOWN unk_101A7A7C; // weak
_UNKNOWN unk_101A7AC4; // weak
_UNKNOWN unk_101A7B0C; // weak
_UNKNOWN unk_101A7B54; // weak
_UNKNOWN unk_101A7B9C; // weak
_UNKNOWN unk_101A7BE4; // weak
_UNKNOWN unk_101A7C2C; // weak
_UNKNOWN unk_101A7C74; // weak
_UNKNOWN unk_101A7CBC; // weak
_UNKNOWN unk_101A7D04; // weak
_UNKNOWN unk_101A7D4C; // weak
_UNKNOWN unk_101A7D94; // weak
_UNKNOWN unk_101A7DAC; // weak
_UNKNOWN unk_101A7DCC; // weak
_UNKNOWN unk_101A7DEC; // weak
_UNKNOWN unk_101A7DF0; // weak
_UNKNOWN unk_101A7E94; // weak
_UNKNOWN unk_101A7F38; // weak
_UNKNOWN unk_101A7FDC; // weak
_UNKNOWN unk_101A8080; // weak
_UNKNOWN unk_101A8124; // weak
_UNKNOWN unk_101A81C8; // weak
_UNKNOWN unk_101A826C; // weak
_UNKNOWN unk_101A8310; // weak
_UNKNOWN unk_101A83B4; // weak
_UNKNOWN unk_101A8458; // weak
_UNKNOWN unk_101A84FC; // weak
_UNKNOWN unk_101A85A0; // weak
_UNKNOWN unk_101A8644; // weak
_UNKNOWN unk_101A86E8; // weak
_UNKNOWN unk_101A878C; // weak
_UNKNOWN unk_101A8830; // weak
_UNKNOWN unk_101A88D4; // weak
_UNKNOWN unk_101A8978; // weak
_UNKNOWN unk_101A8A1C; // weak
_UNKNOWN unk_101A8AC0; // weak
_UNKNOWN unk_101A8B64; // weak
_UNKNOWN unk_101A8C08; // weak
_UNKNOWN unk_101A8CAC; // weak
_UNKNOWN unk_101A8D50; // weak
_UNKNOWN unk_101A8DF4; // weak
_UNKNOWN unk_101A8E98; // weak
_UNKNOWN unk_101A8F3C; // weak
_UNKNOWN unk_101A8FE0; // weak
_UNKNOWN unk_101A9084; // weak
_UNKNOWN unk_101A9128; // weak
_UNKNOWN unk_101A91CC; // weak
_UNKNOWN unk_101A9270; // weak
_UNKNOWN unk_101A9314; // weak
_UNKNOWN unk_101A93B8; // weak
_UNKNOWN unk_101A945C; // weak
_UNKNOWN unk_101A9500; // weak
_UNKNOWN unk_101A95A4; // weak
_UNKNOWN unk_101A9648; // weak
_UNKNOWN unk_101A96EC; // weak
_UNKNOWN unk_101A9790; // weak
_UNKNOWN unk_101A9834; // weak
_UNKNOWN unk_101A98D8; // weak
_UNKNOWN unk_101A997C; // weak
_UNKNOWN unk_101A9A20; // weak
_UNKNOWN unk_101A9AC4; // weak
_UNKNOWN unk_101A9B68; // weak
_UNKNOWN unk_101A9C0C; // weak
_UNKNOWN unk_101A9CB0; // weak
_UNKNOWN unk_101A9D54; // weak
_UNKNOWN unk_101A9DF8; // weak
_UNKNOWN unk_101A9E9C; // weak
_UNKNOWN unk_101A9F40; // weak
_UNKNOWN unk_101A9FE4; // weak
_UNKNOWN unk_101AA088; // weak
_UNKNOWN unk_101AA12C; // weak
_UNKNOWN unk_101AA1D0; // weak
_UNKNOWN unk_101AA274; // weak
_UNKNOWN unk_101AA318; // weak
_UNKNOWN unk_101AA3BC; // weak
_UNKNOWN unk_101AA460; // weak
_UNKNOWN unk_101AA504; // weak
_UNKNOWN unk_101AA5A8; // weak
_UNKNOWN unk_101AA64C; // weak
_UNKNOWN unk_101AA6F0; // weak
_UNKNOWN unk_101AA794; // weak
_UNKNOWN unk_101AA838; // weak
_UNKNOWN unk_101AA8DC; // weak
_UNKNOWN unk_101AA980; // weak
_UNKNOWN unk_101AAA24; // weak
_UNKNOWN unk_101AAAC8; // weak
_UNKNOWN unk_101AAB6C; // weak
_UNKNOWN unk_101AAC10; // weak
_UNKNOWN unk_101AACB4; // weak
_UNKNOWN unk_101AAD58; // weak
_UNKNOWN unk_101AADFC; // weak
_UNKNOWN unk_101AAEA0; // weak
_UNKNOWN unk_101AAF44; // weak
_UNKNOWN unk_101AAFE8; // weak
_UNKNOWN unk_101AB08C; // weak
_UNKNOWN unk_101AB130; // weak
_UNKNOWN unk_101AB1D4; // weak
_UNKNOWN unk_101AB278; // weak
_UNKNOWN unk_101AB31C; // weak
_UNKNOWN unk_101AB3C0; // weak
_UNKNOWN unk_101AB464; // weak
_UNKNOWN unk_101AB508; // weak
_UNKNOWN unk_101AB5AC; // weak
_UNKNOWN unk_101AB650; // weak
_UNKNOWN unk_101AB6F4; // weak
_UNKNOWN unk_101AB798; // weak
_UNKNOWN unk_101AB83C; // weak
_UNKNOWN unk_101AB8E0; // weak
_UNKNOWN unk_101AB984; // weak
_UNKNOWN unk_101ABA28; // weak
_UNKNOWN unk_101ABACC; // weak
_UNKNOWN unk_101ABB70; // weak
_UNKNOWN unk_101ABC14; // weak
_UNKNOWN unk_101ABCB8; // weak
_UNKNOWN unk_101ABD5C; // weak
_UNKNOWN unk_101ABE00; // weak
_UNKNOWN unk_101ABE20; // weak
_UNKNOWN unk_101ABE40; // weak
_UNKNOWN unk_101ABE60; // weak
_UNKNOWN unk_101ABE80; // weak
_UNKNOWN unk_101ABEA8; // weak
_UNKNOWN unk_101ABEC4; // weak
_UNKNOWN unk_101ABEE0; // weak
_UNKNOWN unk_101ABEFC; // weak
_UNKNOWN unk_101ABF18; // weak
_UNKNOWN unk_101ABF34; // weak
_UNKNOWN unk_101ABF50; // weak
_UNKNOWN unk_101ABF6C; // weak
_UNKNOWN unk_101ABF88; // weak
_UNKNOWN unk_101ABFA4; // weak
_UNKNOWN unk_101ABFC0; // weak
_UNKNOWN unk_101ABFDC; // weak
_UNKNOWN unk_101ABFF8; // weak
_UNKNOWN unk_101AC014; // weak
_UNKNOWN unk_101AC030; // weak
_UNKNOWN unk_101AC04C; // weak
_UNKNOWN unk_101AC068; // weak
_UNKNOWN unk_101AC084; // weak
_UNKNOWN unk_101AC0A0; // weak
_UNKNOWN unk_101AC0BC; // weak
_UNKNOWN unk_101AC0D8; // weak
_UNKNOWN unk_101AC0F4; // weak
_UNKNOWN unk_101AC110; // weak
_UNKNOWN unk_101AC12C; // weak
_UNKNOWN unk_101AC148; // weak
_UNKNOWN unk_101AC164; // weak
_UNKNOWN unk_101AC180; // weak
_UNKNOWN unk_101AC19C; // weak
_UNKNOWN unk_101AC1B8; // weak
_UNKNOWN unk_101AC1D4; // weak
_UNKNOWN unk_101AC1F0; // weak
_UNKNOWN unk_101AC20C; // weak
_UNKNOWN unk_101AC228; // weak
_UNKNOWN unk_101AC244; // weak
_UNKNOWN unk_101AC260; // weak
_UNKNOWN unk_101AC27C; // weak
_UNKNOWN unk_101AC298; // weak
_UNKNOWN unk_101AC2B4; // weak
_UNKNOWN unk_101AC2D0; // weak
_UNKNOWN unk_101AC2EC; // weak
_UNKNOWN unk_101AC308; // weak
_UNKNOWN unk_101AC324; // weak
_UNKNOWN unk_101AC340; // weak
_UNKNOWN unk_101AC35C; // weak
_UNKNOWN unk_101AC378; // weak
_UNKNOWN unk_101AC394; // weak
_UNKNOWN unk_101AC3B0; // weak
_UNKNOWN unk_101AC3CC; // weak
_UNKNOWN unk_101AC3E8; // weak
_UNKNOWN unk_101AC404; // weak
_UNKNOWN unk_101AC420; // weak
_UNKNOWN unk_101AC43C; // weak
_UNKNOWN unk_101AC458; // weak
_UNKNOWN unk_101AC474; // weak
_UNKNOWN unk_101AC490; // weak
_UNKNOWN unk_101AC4AC; // weak
_UNKNOWN unk_101AC4C8; // weak
_UNKNOWN unk_101AC4E4; // weak
_UNKNOWN unk_101AC500; // weak
_UNKNOWN unk_101AC51C; // weak
_UNKNOWN unk_101AC538; // weak
_UNKNOWN unk_101AC554; // weak
_UNKNOWN unk_101AC570; // weak
_UNKNOWN unk_101AC58C; // weak
_UNKNOWN unk_101AC5A8; // weak
_UNKNOWN unk_101AC5C4; // weak
_UNKNOWN unk_101AC5E0; // weak
_UNKNOWN unk_101AC5FC; // weak
_UNKNOWN unk_101AC618; // weak
_UNKNOWN unk_101AC634; // weak
_UNKNOWN unk_101AC650; // weak
_UNKNOWN unk_101AC66C; // weak
_UNKNOWN unk_101AC688; // weak
_UNKNOWN unk_101AC6A4; // weak
_UNKNOWN unk_101AC6C0; // weak
_UNKNOWN unk_101AC6DC; // weak
_UNKNOWN unk_101AC6F8; // weak
_UNKNOWN unk_101AC714; // weak
_UNKNOWN unk_101AC730; // weak
_UNKNOWN unk_101AC74C; // weak
_UNKNOWN unk_101AC768; // weak
_UNKNOWN unk_101AC784; // weak
_UNKNOWN unk_101AC7A0; // weak
_UNKNOWN unk_101AC7BC; // weak
_UNKNOWN unk_101AC7D8; // weak
_UNKNOWN unk_101AC7F4; // weak
_UNKNOWN unk_101AC810; // weak
_UNKNOWN unk_101AC82C; // weak
_UNKNOWN unk_101AC848; // weak
_UNKNOWN unk_101AC864; // weak
_UNKNOWN unk_101AC880; // weak
_UNKNOWN unk_101AC89C; // weak
_UNKNOWN unk_101AC8B8; // weak
_UNKNOWN unk_101AC8D4; // weak
_UNKNOWN unk_101AC8F0; // weak
_UNKNOWN unk_101AC90C; // weak
_UNKNOWN unk_101AC928; // weak
_UNKNOWN unk_101AC944; // weak
_UNKNOWN unk_101AC960; // weak
_UNKNOWN unk_101AC97C; // weak
_UNKNOWN unk_101AC998; // weak
_UNKNOWN unk_101AC99C; // weak
_UNKNOWN unk_101AC9A0; // weak
_UNKNOWN unk_101AC9A4; // weak
_UNKNOWN unk_101AC9A8; // weak
_UNKNOWN unk_101AC9AC; // weak
_UNKNOWN unk_101AC9B0; // weak
_UNKNOWN unk_101AC9B4; // weak
_UNKNOWN unk_101AC9B8; // weak
_UNKNOWN unk_101AC9BC; // weak
_UNKNOWN unk_101AC9C0; // weak
_UNKNOWN unk_101AC9C4; // weak
_UNKNOWN unk_101AC9C8; // weak
_UNKNOWN unk_101AC9CC; // weak
_UNKNOWN unk_101AC9D0; // weak
_UNKNOWN unk_101AC9D4; // weak
_UNKNOWN unk_101AC9D8; // weak
_UNKNOWN unk_101AC9DC; // weak
_UNKNOWN unk_101AC9E0; // weak
_UNKNOWN unk_101ACAC4; // weak
_UNKNOWN unk_101ADC84; // weak
_UNKNOWN unk_101ADC88; // weak
_UNKNOWN unk_101ADCB0; // weak
_UNKNOWN unk_101ADCD8; // weak
_UNKNOWN unk_101ADD18; // weak
_UNKNOWN unk_101ADD98; // weak
_UNKNOWN unk_101ADD9C; // weak
_UNKNOWN unk_101ADDA0; // weak
_UNKNOWN unk_101ADDA2; // weak
_UNKNOWN unk_101ADDA4; // weak
_UNKNOWN unk_101ADDA5; // weak
_UNKNOWN unk_101ADDA6; // weak
_UNKNOWN unk_101ADDA8; // weak
_UNKNOWN unk_101ADE0C; // weak
_UNKNOWN unk_101ADE14; // weak
_UNKNOWN unk_101ADE1C; // weak
_UNKNOWN unk_101ADE24; // weak
_UNKNOWN unk_101ADE2C; // weak
_UNKNOWN unk_101ADE34; // weak
_UNKNOWN unk_101ADE3C; // weak
_UNKNOWN unk_101ADE44; // weak
_UNKNOWN unk_101ADE4C; // weak
_UNKNOWN unk_101ADE54; // weak
_UNKNOWN unk_101ADE5C; // weak
_UNKNOWN unk_101ADE64; // weak
_UNKNOWN unk_101ADE6C; // weak
_UNKNOWN unk_101ADE74; // weak
_UNKNOWN unk_101ADE7C; // weak
_UNKNOWN unk_101ADE84; // weak
_UNKNOWN unk_101ADE8C; // weak
_UNKNOWN unk_101ADE94; // weak
_UNKNOWN unk_101ADE9C; // weak
_UNKNOWN unk_101ADEA4; // weak
_UNKNOWN unk_101ADEAC; // weak
_UNKNOWN unk_101ADEB4; // weak
_UNKNOWN unk_101ADEBC; // weak
_UNKNOWN unk_101ADEC4; // weak
_UNKNOWN unk_101ADECC; // weak
_UNKNOWN unk_101ADED4; // weak
_UNKNOWN unk_101ADEDC; // weak
_UNKNOWN unk_101ADEE4; // weak
_UNKNOWN unk_101ADEEC; // weak
_UNKNOWN unk_101ADEF4; // weak
_UNKNOWN unk_101ADEFC; // weak
_UNKNOWN unk_101ADF04; // weak
_UNKNOWN unk_101ADF0C; // weak
_UNKNOWN unk_101ADF14; // weak
_UNKNOWN unk_101ADF1C; // weak
_UNKNOWN unk_101ADF24; // weak
_UNKNOWN unk_101ADF2C; // weak
_UNKNOWN unk_101ADF34; // weak
_UNKNOWN unk_101ADF3C; // weak
_UNKNOWN unk_101ADF44; // weak
_UNKNOWN unk_101AE12C; // weak
_UNKNOWN unk_101AE13C; // weak
_UNKNOWN unk_101AE14C; // weak
_UNKNOWN unk_101AE15C; // weak
_UNKNOWN unk_101AE15D; // weak
_UNKNOWN unk_101AE15E; // weak
_UNKNOWN unk_101AE160; // weak
_UNKNOWN unk_101AE164; // weak
_UNKNOWN unk_101AE20C; // weak
_UNKNOWN unk_101AE210; // weak
_UNKNOWN unk_101AE214; // weak
_UNKNOWN unk_101AE264; // weak
_UNKNOWN unk_101AE268; // weak
_UNKNOWN unk_101AE26C; // weak
_UNKNOWN unk_101AE35C; // weak
_UNKNOWN unk_101AE44C; // weak
_UNKNOWN unk_101AE450; // weak
_UNKNOWN unk_101AE458; // weak
_UNKNOWN unk_101AE460; // weak
_UNKNOWN unk_101AE468; // weak
_UNKNOWN unk_101AE470; // weak
_UNKNOWN unk_101AE478; // weak
_UNKNOWN unk_101AE480; // weak
_UNKNOWN unk_101AE488; // weak
_UNKNOWN unk_101AE490; // weak
_UNKNOWN unk_101AE498; // weak
_UNKNOWN unk_101AE4A0; // weak
_UNKNOWN unk_101AE4A8; // weak
_UNKNOWN unk_101AE4AC; // weak
_UNKNOWN unk_101AE4B0; // weak
_UNKNOWN unk_101AE4B4; // weak
_UNKNOWN unk_101AE508; // weak
_UNKNOWN unk_101AE55C; // weak
_UNKNOWN unk_101AE564; // weak
_UNKNOWN unk_101AE568; // weak
_UNKNOWN unk_101AE56C; // weak
_UNKNOWN unk_101AE570; // weak
_UNKNOWN unk_101AE574; // weak
_UNKNOWN unk_101AE77C; // weak
_UNKNOWN unk_101AE8DC; // weak
_UNKNOWN unk_101AE8F4; // weak
_UNKNOWN unk_101AE90C; // weak
_UNKNOWN unk_101AE916; // weak
_UNKNOWN unk_101AE918; // weak
_UNKNOWN unk_101AE928; // weak
_UNKNOWN unk_101AE92C; // weak
_UNKNOWN unk_101AE930; // weak
_UNKNOWN unk_101AE934; // weak
_UNKNOWN unk_101AE935; // weak
_UNKNOWN unk_101AE938; // weak
_UNKNOWN unk_101AE988; // weak
_UNKNOWN unk_101AE98C; // weak
_UNKNOWN unk_101AE98D; // weak
_UNKNOWN unk_101AE98E; // weak
_UNKNOWN unk_101AE98F; // weak
_UNKNOWN unk_101AE9A3; // weak
_UNKNOWN unk_101AE9A4; // weak
_UNKNOWN unk_101AE9A5; // weak
_UNKNOWN unk_101AE9A6; // weak
_UNKNOWN unk_101AE9A8; // weak
_UNKNOWN unk_101AEA48; // weak
_UNKNOWN unk_101AEA98; // weak
_UNKNOWN unk_101AEA9C; // weak
_UNKNOWN unk_101AEAA0; // weak
_UNKNOWN unk_101AEAA4; // weak
_UNKNOWN unk_101AEAA8; // weak
_UNKNOWN unk_101AEAAC; // weak
_UNKNOWN unk_101AEAB0; // weak
_UNKNOWN unk_101AEAB4; // weak
_UNKNOWN unk_101AEAB8; // weak
_UNKNOWN unk_101AEABC; // weak
_UNKNOWN unk_101AEAC0; // weak
_UNKNOWN unk_101AEAC4; // weak
_UNKNOWN unk_101AEAC8; // weak
_UNKNOWN unk_101AEC08; // weak
_UNKNOWN unk_101AEC14; // weak
_UNKNOWN unk_101AEC5C; // weak
_UNKNOWN unk_101AEC5D; // weak
_UNKNOWN unk_101AEC88; // weak
_UNKNOWN unk_101AECB8; // weak
_UNKNOWN unk_101AECE0; // weak
_UNKNOWN unk_101AECE4; // weak
_UNKNOWN unk_101AECE8; // weak
_UNKNOWN unk_101AECEC; // weak
_UNKNOWN unk_101AED1C; // weak
_UNKNOWN unk_101AED1D; // weak
_UNKNOWN unk_101AED1E; // weak
_UNKNOWN unk_101AED20; // weak
_UNKNOWN unk_101AED24; // weak
_UNKNOWN unk_101AED28; // weak
_UNKNOWN unk_101AED2C; // weak
_UNKNOWN unk_101AED30; // weak
_UNKNOWN unk_101AED34; // weak
_UNKNOWN unk_101AED38; // weak
_UNKNOWN unk_101AED3C; // weak
_UNKNOWN unk_101AED40; // weak
_UNKNOWN unk_101AED44; // weak
_UNKNOWN unk_101AF0A4; // weak
_UNKNOWN unk_101AF0A8; // weak
_UNKNOWN unk_101AF0B2; // weak
_UNKNOWN unk_101AF0BC; // weak
_UNKNOWN unk_101B0878; // weak
_UNKNOWN unk_101B0884; // weak
char byte_101B0890; // weak
char byte_101B0891; // weak
_UNKNOWN unk_101B0898; // weak
__int16 word_101B0938; // weak
__int16 word_101B093C; // weak
__int16 word_101B0940; // weak
_UNKNOWN unk_101B0948; // weak
__int16 word_101B09E8; // weak
int dword_101B09EC; // weak
__int16 word_101B09F0; // weak
__int16 word_101B09F8[]; // weak
_UNKNOWN unk_101B0A19; // weak
int dword_101B203C[]; // weak
int dword_101B2050; // weak
int dword_101B2054; // weak
int dword_101B2078; // weak
int dword_101B207C; // weak
int dword_101B2080; // weak
int dword_101B2084; // weak
int dword_101B2088; // weak
int dword_101B208C; // weak
int dword_101B2090; // weak
int dword_101B2094; // weak
int dword_101B2098; // weak
int dword_101B209C; // weak
int dword_101B20A0; // weak
int dword_101B20A4; // weak
char byte_101B20A8; // weak
int dword_101B20AC; // weak
_UNKNOWN unk_101B20B0; // weak
_UNKNOWN unk_101B2788; // weak
_UNKNOWN unk_101B2E60; // weak
_UNKNOWN unk_101B3538; // weak
_UNKNOWN unk_101B3C10; // weak
_UNKNOWN unk_101B42E8; // weak
_UNKNOWN unk_101B49C0; // weak
_UNKNOWN unk_101B5098; // weak
_UNKNOWN unk_101B5770; // weak
_UNKNOWN unk_101B5E48; // weak
_UNKNOWN unk_101B6520; // weak
_UNKNOWN unk_101B6BF8; // weak
_UNKNOWN unk_101B72D0; // weak
_UNKNOWN unk_101B79A8; // weak
_UNKNOWN unk_101B8080; // weak
_UNKNOWN unk_101B8758; // weak
_UNKNOWN unk_101B8E30; // weak
_UNKNOWN unk_101B9508; // weak
_UNKNOWN unk_101B9BE0; // weak
_UNKNOWN unk_101BA2B8; // weak
_UNKNOWN unk_101BA990; // weak
_UNKNOWN unk_101BB068; // weak
_UNKNOWN unk_101BB740; // weak
_UNKNOWN unk_101BBE18; // weak
_UNKNOWN unk_101BC4F0; // weak
_UNKNOWN unk_101BCBC8; // weak
_UNKNOWN unk_101BD2A0; // weak
_UNKNOWN unk_101BD978; // weak
_UNKNOWN unk_101BE050; // weak
_UNKNOWN unk_101BE728; // weak
_UNKNOWN unk_101BEE00; // weak
_UNKNOWN unk_101BF4D8; // weak
_UNKNOWN unk_101BFBB0; // weak
_UNKNOWN unk_101C0288; // weak
_UNKNOWN unk_101C0960; // weak
_UNKNOWN unk_101C1038; // weak
_UNKNOWN unk_101C1710; // weak
_UNKNOWN unk_101C1DE8; // weak
_UNKNOWN unk_101C24C0; // weak
_UNKNOWN unk_101C2B98; // weak
_UNKNOWN unk_101C3270; // weak
_UNKNOWN unk_101C3948; // weak
_UNKNOWN unk_101C4020; // weak
_UNKNOWN unk_101C46F8; // weak
_UNKNOWN unk_101C4DD0; // weak
_UNKNOWN unk_101C54A8; // weak
_UNKNOWN unk_101C5B80; // weak
_UNKNOWN unk_101C6258; // weak
_UNKNOWN unk_101C6930; // weak
_UNKNOWN unk_101C7008; // weak
_UNKNOWN unk_101C76E0; // weak
_UNKNOWN unk_101C7DB8; // weak
_UNKNOWN unk_101C8490; // weak
_UNKNOWN unk_101C8B68; // weak
_UNKNOWN unk_101C9240; // weak
_UNKNOWN unk_101C9918; // weak
_UNKNOWN unk_101C9FF0; // weak
_UNKNOWN unk_101CA6C8; // weak
_UNKNOWN unk_101CADA0; // weak
_UNKNOWN unk_101CB478; // weak
_UNKNOWN unk_101CBB50; // weak
_UNKNOWN unk_101CC228; // weak
_UNKNOWN unk_101CC900; // weak
_UNKNOWN unk_101CCFD8; // weak
_UNKNOWN unk_101CD6B0; // weak
_UNKNOWN unk_101CDD88; // weak
_UNKNOWN unk_101CE460; // weak
_UNKNOWN unk_101CEB38; // weak
_UNKNOWN unk_101CF210; // weak
_UNKNOWN unk_101CF8E8; // weak
_UNKNOWN unk_101CFFC0; // weak
_UNKNOWN unk_101D0698; // weak
_UNKNOWN unk_101D0D70; // weak
_UNKNOWN unk_101D1448; // weak
_UNKNOWN unk_101D1B20; // weak
_UNKNOWN unk_101D21F8; // weak
_UNKNOWN unk_101D28D0; // weak
_UNKNOWN unk_101D2FA8; // weak
_UNKNOWN unk_101D3680; // weak
_UNKNOWN unk_101D3D58; // weak
_UNKNOWN unk_101D4430; // weak
_UNKNOWN unk_101D4B08; // weak
_UNKNOWN unk_101D51E0; // weak
_UNKNOWN unk_101D58B8; // weak
_UNKNOWN unk_101D5F90; // weak
_UNKNOWN unk_101D6668; // weak
_UNKNOWN unk_101D6D40; // weak
_UNKNOWN unk_101D7418; // weak
_UNKNOWN unk_101D7AF0; // weak
_UNKNOWN unk_101D81C8; // weak
_UNKNOWN unk_101D88A0; // weak
_UNKNOWN unk_101D8F78; // weak
_UNKNOWN unk_101D9650; // weak
_UNKNOWN unk_101D9D28; // weak
_UNKNOWN unk_101DA400; // weak
_UNKNOWN unk_101DAAD8; // weak
_UNKNOWN unk_101DB1B0; // weak
_UNKNOWN unk_101DB888; // weak
_UNKNOWN unk_101DBF60; // weak
_UNKNOWN unk_101DC638; // weak
_UNKNOWN unk_101DCD10; // weak
int dword_101DE488; // weak
_UNKNOWN unk_101DE490; // weak
char byte_101DE768[]; // weak
char byte_101DE769[]; // weak
char byte_101DE788[]; // weak
char byte_101DE789[]; // weak
_UNKNOWN unk_101DF9D0; // weak
_UNKNOWN unk_101E1380; // weak
int dword_101E1A20; // weak
_UNKNOWN unk_101E1A28; // weak
int dword_101E2F68; // weak
char byte_101E2F70[]; // weak
char byte_101E2F74[]; // weak
char byte_101E2F75[]; // weak
int dword_101E2F7C[]; // weak
int dword_101E2F84[]; // weak
int dword_101E2FB8[]; // weak
int dword_101E2FBC; // weak
int dword_101E2FC0; // weak
int dword_101E2FC4; // weak
int dword_101E2FC8; // weak
int dword_101E2FCC[]; // weak
int dword_101E2FD0; // weak
int dword_101E2FD4; // weak
int dword_101E2FD8; // weak
int dword_101E2FDC; // weak
_UNKNOWN unk_101E2FE0; // weak
int dword_101E30F8; // weak
int dword_101E30FC; // weak
int dword_101F0848; // weak
int dword_101F084C; // weak
int dword_101F0850; // weak
int dword_101F0854; // weak
char byte_101F0858; // weak
char byte_101F0860[104]; // idb
char byte_101F08C8; // idb
char byte_101F09C8[254]; // idb
char byte_101F0AC6[]; // weak
char byte_101F0AC7[]; // weak
char byte_101F0EC8[2800]; // idb
char byte_101F19B8[1022]; // idb
char byte_101F1DB6[]; // weak
char byte_101F1DB7[]; // weak
char byte_101F1DB8[1022]; // idb
char byte_101F21B6[]; // weak
char byte_101F21B7[]; // weak
char byte_101F21B8[1022]; // idb
char byte_101F25B6[]; // weak
char byte_101F25B7[]; // weak
int dword_101F55B8[]; // weak
int dword_101F55CC[]; // weak
char byte_101F55E0[2800]; // idb
char byte_101F60D0[2800]; // idb
char byte_101F6BC0[2800]; // idb
int dword_101F76B0[]; // weak
int dword_101F76C4[]; // weak
char byte_101F76D8[2796]; // idb
char byte_101F81C4[]; // weak
char byte_101F81C8[559]; // idb
char byte_101F83F7[]; // weak
int dword_101F8CB8[]; // weak
int dword_101F8CCC[]; // weak
char byte_101F8CE0[2800]; // idb
int dword_101F97D0; // weak
_UNKNOWN unk_101F97D8; // weak
_UNKNOWN unk_101FA330; // weak
int dword_101FC694; // weak
int dword_101FC698; // weak
int dword_101FC69C; // weak
int dword_101FC6A0; // weak
int dword_1025C3F8; // weak
char byte_1025C400[]; // weak
char byte_1025C450[]; // weak
_UNKNOWN unk_102637A0; // weak
_UNKNOWN unk_102637A8; // weak
_UNKNOWN unk_102637B0; // weak
char byte_102657B8; // weak
char byte_102657B9; // weak
_UNKNOWN unk_102657C8; // weak
_UNKNOWN unk_102686D0; // weak
_UNKNOWN unk_10268BD0; // weak
_UNKNOWN unk_10268C78; // weak
char byte_1026B530[]; // weak
char byte_1026B531[]; // weak
_UNKNOWN unk_1026B5D0; // weak
int dword_1026B8A0[]; // weak
int dword_1026B8A4[]; // weak
char byte_1026BDC0; // weak
char byte_1026BDC1; // weak
char byte_1026BDC2; // weak
char byte_1026BDC3; // weak
_UNKNOWN unk_1026BDC8; // weak
_UNKNOWN unk_1026BDE8; // weak
char byte_1026CE90; // weak
char byte_1026CE91; // weak
int dword_1026CEAC; // weak
int dword_1026CEB0; // weak
int dword_1026D1E0; // weak
int dword_1026D1EC; // weak
int dword_1026D810; // weak
int dword_1026D81C; // weak
int dword_1026D828; // weak
int dword_1026D82C; // weak
int dword_1026D830; // weak
int dword_1026D84C; // weak
int dword_1026D850; // weak
int dword_1026D854; // weak
int dword_1026D858; // weak
int dword_1026D85C; // weak
int dword_1026D918; // weak
char byte_1026D91C; // weak
char byte_1026D91D; // weak
char byte_1026D91E; // weak
int dword_1026D920; // weak
_UNKNOWN unk_1026D924; // weak
char byte_102D1940; // weak
char byte_102D1941; // weak
char byte_102D1942; // weak
char byte_102D1944; // weak
char byte_102D194B; // weak
__int16 word_102D194E; // weak
__int16 word_102D1950; // weak
__int16 word_102D1954; // weak
int dword_102D1958; // weak
int dword_102D195C; // weak
int dword_102D1974; // weak
int dword_102D1980; // weak
int dword_102D1988; // weak
char byte_102D1AC8; // weak
int dword_102D1B1C; // weak
char byte_102D1B20; // weak
int dword_102D1B40[]; // weak
_BYTE dword_102D1B44[1120]; // idb
int dword_102D1FA8; // weak
_UNKNOWN unk_102D1FAC; // weak
int dword_102D1FC0[]; // weak
char byte_102D1FC4[]; // weak
int dword_102D21C0; // weak
int dword_102D21C4; // weak
char byte_102D21C8; // weak
int dword_102D21CC; // weak
char byte_102D21D0; // weak
int dword_102D21D4; // weak
char byte_102D21D8; // weak
int dword_102D21DC; // weak
_UNKNOWN unk_102D21E0; // weak
int dword_102D21E4[]; // weak
char byte_102D21F1[]; // weak
int dword_102D22A8; // weak
int dword_102D22AC; // weak
char byte_102D22B0; // weak
int dword_102D22C0[]; // weak
__int16 word_102D22C4[]; // weak
int dword_102D22C8[]; // weak
int dword_102D22CC; // weak
int dword_102D22D0; // weak
int dword_102D22D4; // weak
int dword_102D22D8; // weak
__int16 word_102D22DC; // weak
int dword_102D22E0; // weak
int dword_102D2328; // weak
int dword_102D2388; // weak
int dword_102D23B8; // weak
int dword_102D2400; // weak
int dword_102D24A8; // weak
int dword_102D24B4; // weak
int dword_102D24C4; // weak
__int16 word_102D24C8; // weak
int dword_102D24D0; // weak
__int16 word_102D24D4; // weak
int dword_102D24DC; // weak
int dword_102D25E4; // weak
int dword_102D265C; // weak
__int16 word_102D2660; // weak
_UNKNOWN unk_102D29C8; // weak
_UNKNOWN unk_102D29C9; // weak
_UNKNOWN unk_102D29CA; // weak
__int16 word_102D29E0[]; // weak
char byte_102D2B0C; // weak
char byte_102D2B0D; // weak
int dword_102D2B10; // weak
char byte_102D2B14; // weak
int dword_102D2B18; // weak
int dword_102D2B20; // weak
int dword_102D2B24; // weak
int dword_102D2B28; // weak
int dword_102D2B2C; // weak
int dword_102D2B30; // weak
int dword_102D2B34; // weak
int dword_102D2B44; // weak
char byte_102D2B48[]; // weak
int dword_102D2B4C; // weak
int dword_102D2B68; // weak
void *dword_102D2B6C; // idb
int dword_102D3B80; // weak
UINT uNumber; // idb
int dword_102D3BA0[]; // weak
int dword_102D3CA0; // weak
int dword_102D3CB8; // weak


//----- (10001000) --------------------------------------------------------
char __cdecl sub_10001000(int a1)
{
  int *v1; // ecx@1
  __int16 v2; // bx@1
  __int16 v3; // di@1
  char result; // al@1
  bool v5; // zf@1
  __int16 v6; // bp@1
  int v7; // ecx@3
  __int16 v8; // si@4
  __int16 v9; // dx@5
  char v10; // [sp+13h] [bp-1h]@1
  int v11; // [sp+18h] [bp+4h]@1

  v1 = (int *)a1;
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 28);
  result = 0;
  v5 = a1 == dword_102D1FA8;
  v10 = 0;
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v11 = (unsigned __int16)(*(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1);
  if ( v5 )
  {
    result = 1;
    v10 = 1;
  }
  v7 = *v1;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_WORD *)(v7 + 28);
      if ( v3 >= v8 )
      {
        v9 = *(_WORD *)(v7 + 30);
        if ( v2 >= v9 && v6 <= *(_WORD *)(v7 + 34) + v9 - 1 && (signed __int16)v11 <= *(_WORD *)(v7 + 32) + v8 - 1 )
          break;
      }
      v7 = *(_DWORD *)v7;
      if ( !v7 )
        return v10;
    }
    result = 1;
  }
  return result;
}
// 102D1FA8: using guessed type int dword_102D1FA8;

//----- (100010B0) --------------------------------------------------------
bool __cdecl sub_100010B0(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)(a2 + 24);
  return v2 == 1 || v2 == 3;
}

//----- (100010D0) --------------------------------------------------------
int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>)
{
  signed int v2; // ST1C_4@2
  float v3; // ST10_4@2
  float v4; // ST08_4@2

  if ( *(_BYTE *)(result + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    ((void (*)(void))j_gdi_pvg_load_identity)();
    v2 = *(_WORD *)(a2 + 32);
    v3 = (double)*(_WORD *)(a2 + 34);
    v4 = (double)v2;
    sub_100157C0(0.0, v4, 0.0, v3, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity(v2);
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 10015780: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 100157A0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 100157B0: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 100159C0: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001180) --------------------------------------------------------
int __cdecl sub_10001180(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@2

  v2 = a2;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( sub_100010B0(v3, v2) )
        break;
      v2 = *(_DWORD *)(v2 + 4);
    }
    while ( v2 );
  }
  return v2;
}

//----- (100011B0) --------------------------------------------------------
char __cdecl sub_100011B0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@2

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_100028E0(a1, a4, a5);
      LOBYTE(v6) = -1;
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_10015CD0();
        sub_10015D20(1);
        v6 = sub_10015C90(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = dword_1017E5A0;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_10015CD0();
      sub_10015D20(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_10015C90(a4, a5, 59);
      LOBYTE(v6) = sub_100010D0(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(v6 + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_10015C20(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}
// 1017E5A0: using guessed type int dword_1017E5A0;

//----- (100012F0) --------------------------------------------------------
char __cdecl sub_100012F0(int a1, int a2)
{
  __int64 v2; // rax@4
  char result; // al@4
  int v4; // eax@5
  int v5; // eax@6
  int v6; // edx@6
  int v7; // eax@7
  int v8; // esi@9

  if ( !a2 )
    sub_10015C20(".\\cdp_cnvs_utl.c", 388, 1, 0);
  switch ( *(_BYTE *)(a2 + 24) & 3 )
  {
    case 0:
      *(_WORD *)(a1 + 270) = *(_WORD *)(a2 + 32);
      *(_WORD *)(a1 + 268) = *(_WORD *)(a2 + 34);
      *(_BYTE *)(a1 + 272) = 8;
      v2 = *(_WORD *)(a2 + 32) + 255;
      *(_WORD *)(a1 + 274) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
      *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 48);
      *(_BYTE *)(a1 + 273) = 0;
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      *(_WORD *)(a1 + 434) = 0;
      *(_WORD *)(a1 + 432) = 0;
      result = 1;
      break;
    case 1:
      v4 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v4 + 8) != *(_DWORD *)(a1 + 44) )
      {
        *(_DWORD *)(v4 + 52) = *(_DWORD *)(a1 + 24);
        sub_100010D0(a1, *(_DWORD *)(a1 + 56));
        v5 = *(_DWORD *)(a1 + 56);
        v6 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 52) = v6;
      }
      *(_DWORD *)(a1 + 264) = dword_1017E5A0;
      v7 = a1 + 264;
      *(_DWORD *)(v7 + 4) = *(&dword_1017E5A0 + 1);
      *(_DWORD *)(v7 + 8) = *(&dword_1017E5A0 + 2);
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      sub_1006CAF0(a1 + 392, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
      *(_WORD *)(a1 + 434) = *(_WORD *)(a2 + 28);
      *(_WORD *)(a1 + 432) = *(_WORD *)(a2 + 30);
      result = 1;
      break;
    case 2:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      result = 1;
      break;
    case 3:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      v8 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v8 + 8) == *(_DWORD *)(a1 + 44) )
        goto LABEL_12;
      sub_100010D0(a1, v8);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
      result = 1;
      break;
    default:
      sub_10015C20(".\\cdp_cnvs_utl.c", 473, 1, 0);
LABEL_12:
      result = 1;
      break;
  }
  return result;
}
// 100157A0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 1017E5A0: using guessed type int dword_1017E5A0;

//----- (100014E0) --------------------------------------------------------
unsigned int sub_100014E0()
{
  int *v0; // ecx@1
  unsigned int result; // eax@1
  int v2; // ecx@3
  int v3; // ecx@3
  int v4; // ecx@3
  int v5; // ecx@3
  int v6; // ecx@3
  int v7; // ecx@3
  int v8; // edx@3

  v0 = dword_102D1B44;
  result = 0;
  do
  {
    *(v0 - 1) = 0;
    *(_BYTE *)v0 = 0;
    v0 += 2;
  }
  while ( (signed int)v0 < (signed int)&unk_102D1FAC );
  do
  {
    v2 = dword_10085A38[result];
    dword_102D1B40[2 * v2] = *(int *)((char *)&off_10085A3C + result * 4);
    dword_102D1B44[2 * v2] = dword_10085A40[result];
    v3 = dword_10085A44[result];
    dword_102D1B40[2 * v3] = *(int *)((char *)&off_10085A48 + result * 4);
    dword_102D1B44[2 * v3] = dword_10085A4C[result];
    v4 = dword_10085A50[result];
    dword_102D1B40[2 * v4] = *(int *)((char *)&off_10085A54 + result * 4);
    dword_102D1B44[2 * v4] = dword_10085A58[result];
    v5 = dword_10085A5C[result];
    dword_102D1B40[2 * v5] = *(int *)((char *)&off_10085A60 + result * 4);
    dword_102D1B44[2 * v5] = dword_10085A64[result];
    v6 = dword_10085A68[result];
    dword_102D1B40[2 * v6] = *(int *)((char *)&off_10085A6C + result * 4);
    dword_102D1B44[2 * v6] = dword_10085A70[result];
    v7 = dword_10085A74[result];
    dword_102D1B40[2 * v7] = *(int *)((char *)&off_10085A78 + result * 4);
    v8 = dword_10085A7C[result];
    result += 18;
    dword_102D1B44[2 * v7] = v8;
  }
  while ( result < 90 );
  return result * 4;
}
// 10085A38: using guessed type int dword_10085A38[];
// 10085A3C: using guessed type int (__cdecl *off_10085A3C)(int, int, int, int, int);
// 10085A40: using guessed type int dword_10085A40[];
// 10085A44: using guessed type int dword_10085A44[];
// 10085A48: using guessed type int (__cdecl *off_10085A48)(int, int, int, int, int);
// 10085A4C: using guessed type int dword_10085A4C[];
// 10085A50: using guessed type int dword_10085A50[];
// 10085A54: using guessed type int (__cdecl *off_10085A54)(int, int, int, int, int);
// 10085A58: using guessed type int dword_10085A58[];
// 10085A5C: using guessed type int dword_10085A5C[];
// 10085A60: using guessed type int (__cdecl *off_10085A60)(int, int, int, int, int);
// 10085A64: using guessed type int dword_10085A64[];
// 10085A68: using guessed type int dword_10085A68[];
// 10085A6C: using guessed type int (__cdecl *off_10085A6C)(int, int, int, int, int);
// 10085A70: using guessed type int dword_10085A70[];
// 10085A74: using guessed type int dword_10085A74[];
// 10085A78: using guessed type int (__cdecl *off_10085A78)(int, int, int, int, int);
// 10085A7C: using guessed type int dword_10085A7C[];
// 102D1B40: using guessed type int dword_102D1B40[];
// 102D1B44: using guessed type int dword_102D1B44[];

//----- (100015D0) --------------------------------------------------------
int __cdecl sub_100015D0(int a1, int a2)
{
  int result; // eax@1

  for ( result = *(_DWORD *)(a1 + 48); result; result = *(_DWORD *)(result + 4) )
  {
    if ( *(_DWORD *)(result + 8) == a2 )
      break;
  }
  return result;
}

//----- (100015F0) --------------------------------------------------------
int __cdecl sub_100015F0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (10001620) --------------------------------------------------------
unsigned int sub_10001620()
{
  char *v0; // eax@1
  signed int v1; // esi@3
  void *v2; // ecx@3
  unsigned int result; // eax@4
  char v4; // dl@4

  byte_102D1B20 = 0;
  sub_10037820(&unk_10120800);
  sub_10023D20(0);
  v0 = byte_102D1FC4;
  do
  {
    *((_DWORD *)v0 - 1) = sub_10010EC0;
    *v0 = 0;
    v0 += 8;
  }
  while ( (signed int)v0 < (signed int)&dword_102D21C4 );
  v1 = 4;
  v2 = &unk_1008487C;
  do
  {
    result = 8 * *(_BYTE *)v2;
    dword_102D1FC0[result / 4] = *((_DWORD *)v2 + 1);
    v4 = *((_BYTE *)v2 + 8);
    v2 = (char *)v2 + 12;
    --v1;
    byte_102D1FC4[result] = v4;
  }
  while ( v1 );
  return result;
}
// 10010EC0: using guessed type int sub_10010EC0();
// 102D1B20: using guessed type char byte_102D1B20;
// 102D1FC0: using guessed type int dword_102D1FC0[];
// 102D21C4: using guessed type int dword_102D21C4;

//----- (10001640) --------------------------------------------------------
int __cdecl sub_10001640(int a1, char *a2, int a3, int a4)
{
  if ( !a2 )
    sub_10015C20(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *((_DWORD *)a2 + 3) = sub_10002860(a1, a3);
  *((_DWORD *)a2 + 14) = sub_10002860(a1, 4 * a4 + 4);
  a2[68] = a4;
  a2[231] = 0;
  if ( a4 > 0 )
  {
    *((_DWORD *)a2 + 15) = sub_10002860(a1, 4 * a4);
    *((_DWORD *)a2 + 16) = sub_10002860(a1, a4);
  }
  return *((_DWORD *)a2 + 3);
}

//----- (100016D0) --------------------------------------------------------
char __cdecl sub_100016D0(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 1;
  v9 = 1000;
  v4 = sub_100161D0(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10015C20(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (10001740) --------------------------------------------------------
char __cdecl sub_10001740(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 2;
  v9 = 1000;
  v4 = sub_100161D0(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10015C20(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (100017B0) --------------------------------------------------------
int sub_100017B0()
{
  int result; // eax@1

  result = sub_100160A0();
  dword_10120808 = result;
  byte_10120804 = 0;
  return result;
}
// 10120804: using guessed type char byte_10120804;
// 10120808: using guessed type int dword_10120808;

//----- (100017D0) --------------------------------------------------------
_DWORD *__cdecl sub_100017D0(int a1)
{
  return sub_10037860(&unk_10120800, a1);
}

//----- (100017F0) --------------------------------------------------------
unsigned int __cdecl sub_100017F0(int a1, int a2, int a3)
{
  unsigned int result; // eax@1

  result = (a3 * (1000 / *(_WORD *)(a1 + 20)) + 500) / 1000;
  if ( result >= 1 )
  {
    if ( result >= 0xFF )
      result = 255;
    *(_BYTE *)(a2 + 243) = result;
    *(_BYTE *)(a2 + 244) = result;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a2 + 243) = 1;
    *(_BYTE *)(a2 + 244) = 1;
  }
  return result;
}

//----- (10001860) --------------------------------------------------------
void __usercall sub_10001860(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_10015760();
    sub_10015CD0();
    sub_10015D20(1);
    *(_DWORD *)(a1 + 28) = sub_10015C90(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 57);
    sub_10015CD0();
    *(_DWORD *)(a1 + 24) = sub_10015C90(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 59);
  }
}

//----- (100018B0) --------------------------------------------------------
char __usercall sub_100018B0@<al>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@9
  char result; // al@13
  char v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v8 = 2;
  byte_1026D91E = *v1 == -32749;
  byte_102D1B20 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_DWORD *)(a1 + 56);
  sub_100163E0(9129, &v7, 2, &v8);
  v4 = *(_DWORD *)(a1 + 64);
  if ( (v4 == 1 || v4 == 9) && sub_10037E30(v3) != 2 && v7 & 0x1C )
  {
    byte_1026D91E = 0;
    byte_102D1B20 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_10025D30() )
  {
    byte_1026D91E = 0;
    byte_102D1B20 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 && *(_BYTE *)(v5 + 230) != -1 && !*(_BYTE *)(v5 + 238) )
  {
    sub_100379B0(a1, (char *)v5, (int)&unk_100AB7D4);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v2;
  result = sub_10014560(a1);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1026D91E: using guessed type char byte_1026D91E;
// 102D1B20: using guessed type char byte_102D1B20;

//----- (10001990) --------------------------------------------------------
void __usercall sub_10001990(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  __int64 v3; // rax@8

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 != -1 )
  {
    if ( *(_BYTE *)(a1 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 3) == 2 )
        sub_10015570(v2, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), 0, 0, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 34));
    }
    else if ( *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 52));
      v3 = *(_WORD *)(a1 + 32) + 255;
      sub_100156C0(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(a1 + 34), 57, 15, *(_DWORD *)(a1 + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 24));
      sub_10015570(
        *(_DWORD *)(a1 + 52),
        *(_WORD *)(a1 + 28),
        *(_WORD *)(a1 + 30),
        0,
        0,
        *(_WORD *)(a1 + 32),
        *(_WORD *)(a1 + 34));
    }
  }
}
// 100157A0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (10001A60) --------------------------------------------------------
void __usercall sub_10001A60(int a1@<esi>, int a2)
{
  __int16 v2; // ST1C_2@5
  __int16 v3; // ST14_2@5
  __int16 v4; // ST10_2@5
  int v5; // [sp+0h] [bp-Ch]@5
  __int16 v6; // [sp+4h] [bp-8h]@5
  __int16 v7; // [sp+6h] [bp-6h]@5
  char v8; // [sp+8h] [bp-4h]@5
  char v9; // [sp+9h] [bp-3h]@5
  __int16 v10; // [sp+Ah] [bp-2h]@5

  if ( !(*(_BYTE *)(a1 + 24) & 3) && *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
  {
    v2 = *(_WORD *)(a1 + 34);
    v7 = *(_WORD *)(a1 + 32);
    v3 = *(_WORD *)(a1 + 30);
    v4 = *(_WORD *)(a1 + 28);
    v10 = (unsigned __int16)((v7 + 255) / 256) << 8;
    v5 = *(_DWORD *)(a1 + 48);
    v6 = v2;
    v8 = 8;
    v9 = 0;
    sub_1006CC00(a2 + 392, (int)&v5, 0, 0, v4, v3, v7, v2);
  }
}

//----- (10001B00) --------------------------------------------------------
int __usercall sub_10001B00@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  __int64 v3; // rax@8
  int result; // eax@11

  v2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)(v2 + 4) )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      break;
    if ( sub_100010B0(a1, v2) )
      break;
  }
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( v2 )
    {
      if ( (*(_BYTE *)(v2 + 24) & 3) == 1 )
      {
        j_gdi_pvg_make_window_current(*(_DWORD *)(v2 + 52));
        v3 = *(_WORD *)(a1 + 16) + 255;
        sub_100156C0(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(v2 + 34), 57, 15, *(_DWORD *)(v2 + 48));
        j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
        sub_10015570(
          *(_DWORD *)(v2 + 52),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 32),
          *(_WORD *)(v2 + 34));
      }
      nullsub_1(a1, 1);
      do
      {
        sub_10001990(v2, a1);
        v2 = *(_DWORD *)v2;
      }
      while ( v2 );
    }
    result = nullsub_1(a1, 0);
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
  }
  if ( v2 && *(_BYTE *)(v2 + 26) )
    nullsub_1(a1, 1);
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)v2 )
    sub_10001A60(v2, a1);
  result = nullsub_1(a1, 0);
  if ( *(_BYTE *)(a1 + 11) )
  {
    result = sub_100156C0(
               0,
               0,
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
               57,
               15,
               **(_DWORD **)(a1 + 444));
LABEL_21:
    if ( *(_BYTE *)(a1 + 11) )
      result = j_gdi_pvg_update_display_wdw();
  }
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 10015790: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 100157A0: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 10015950: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (10001CD0) --------------------------------------------------------
char __thiscall sub_10001CD0(int this)
{
  char result; // al@1

  result = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(this + 56) + 26) && **(_WORD **)(this + 52) == -32696 )
  {
    result = 1;
    *(_BYTE *)(this + 6) = 2;
  }
  return result;
}

//----- (10001CF0) --------------------------------------------------------
signed int __cdecl sub_10001CF0(int a1, int a2)
{
  const void *v2; // edx@1
  int v3; // ebx@1
  char v4; // al@4
  char v6; // al@13
  char v7; // al@14
  int v8; // [sp-Ch] [bp-FCh]@15
  __int16 *v9; // [sp-8h] [bp-F8h]@15
  int v10; // [sp+Ch] [bp-E4h]@1
  __int16 v11; // [sp+18h] [bp-D8h]@7
  int v12; // [sp+1Ch] [bp-D4h]@12

  v2 = (const void *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v10 = 0;
  if ( !v3 )
  {
    if ( *(_WORD *)a2 > 0x8001u && *(_WORD *)a2 < 0x800Du )
    {
      v3 = *(_DWORD *)(a1 + 48);
      v4 = 1;
      goto LABEL_7;
    }
    v3 = 0;
  }
  v4 = 0;
LABEL_7:
  qmemcpy(&v11, (const void *)a2, 0xCCu);
  if ( !v4 )
  {
    sub_100016D0(a1, (int)&v11, 204);
    return 1;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      qmemcpy(&v11, v2, 0xCCu);
      v12 = v3;
      if ( v11 != -32760 )
        break;
      v6 = *(_BYTE *)(v3 + 243);
      if ( v6 )
      {
        v7 = v6 - 1;
        *(_BYTE *)(v3 + 243) = v7;
        if ( !v7 )
        {
          v11 = -32648;
          v9 = &v11;
          *(_BYTE *)(v3 + 243) = *(_BYTE *)(v3 + 244);
          v8 = a1;
LABEL_17:
          sub_100016D0(v8, (int)v9, 204);
          ++v10;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( sub_100010B0(a1, v3) )
        return v10;
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        return v10;
      v2 = (const void *)a2;
    }
    v9 = &v11;
    v8 = a1;
    goto LABEL_17;
  }
  return v10;
}

//----- (10001E40) --------------------------------------------------------
char __cdecl sub_10001E40(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_100016D0(a1, (int)&v4, 8);
}

//----- (10001E70) --------------------------------------------------------
char __cdecl sub_10001E70(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10001740(a1, (int)&v4, 8);
}

//----- (10001EA0) --------------------------------------------------------
char __cdecl sub_10001EA0(unsigned int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  __int16 v3; // dx@2
  unsigned int v4; // ebx@3
  _DWORD *v5; // eax@3
  char v6; // dl@3
  __int16 v7; // ax@10
  unsigned __int16 v8; // cx@14
  int v9; // eax@31
  int v10; // eax@31
  int v11; // eax@41
  __int16 v12; // ax@48
  char v13; // al@52
  _WORD *v14; // edx@55
  int v15; // ebp@58
  int v17; // [sp+0h] [bp-10h]@0
  int v18; // [sp+0h] [bp-10h]@51

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 < 0x8000u )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = *(_WORD *)(v1 + 8);
    *(_WORD *)v1 = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v2;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v3;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_10037830((int *)&unk_10120800, a1);
  v5 = *(_DWORD **)(a1 + 32);
  v6 = 0;
  if ( v5 )
  {
    while ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) != v5 )
    {
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v6 = 1;
  }
LABEL_8:
  if ( v4 )
  {
    if ( !v6 )
    {
      v7 = **(_WORD **)(a1 + 52);
      if ( v7 != -32703 )
      {
        if ( v7 == -32744 )
          return v7;
        v4 = 0;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  LOBYTE(v7) = sub_10014460(a1);
  if ( !(_BYTE)v7 )
  {
    v8 = **(_WORD **)(a1 + 52);
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_100018B0(a1);
        goto LABEL_40;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v4 + 24) & 3) || (*(_BYTE *)(v4 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v4 + 52));
        if ( v4 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v4 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v4 + 4);
          **(_DWORD **)(v4 + 4) = 0;
        }
        else
        {
          sub_100015F0(a1);
        }
        goto LABEL_40;
      case 0x8022:
      case 0x8078:
        if ( *(_BYTE *)(a1 + 4) || v4 && sub_10001000(v4) )
          v4 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && sub_10025D30() != byte_10120804 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_10120804 = sub_10025D30();
        }
        goto LABEL_40;
      case 0x8041:
        v9 = sub_10002860(a1, 332);
        v4 = v9;
        qmemcpy((void *)v9, &unk_10086178, 0x14Cu);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        v10 = *(_DWORD *)(a1 + 48);
        if ( v10 )
        {
          *(_DWORD *)(v4 + 4) = v10;
          **(_DWORD **)(a1 + 48) = v4;
          *(_BYTE *)(v4 + 243) = *(_BYTE *)(*(_DWORD *)(v4 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v4;
        --*(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 48) = v4;
        goto LABEL_40;
      default:
        if ( !v4 )
        {
          if ( v8 <= 0x800Eu || v8 >= 0xFFFFu )
            goto LABEL_67;
          v4 = *(_DWORD *)(a1 + 48);
LABEL_40:
          if ( !v4 )
            goto LABEL_67;
        }
        v11 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v4;
        *(_BYTE *)(a1 + 6) = 1;
        *(_DWORD *)(v11 + 4) = v4;
        if ( **(_WORD **)(a1 + 52) == -32665 )
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
        sub_100143C0(a1);
        if ( *(_BYTE *)(a1 + 6) == 1 && !sub_10001CD0(a1) )
          (*(void (__cdecl **)(unsigned int))(v4 + 8))(a1);
        if ( !v4 || v4 > *(_DWORD *)(a1 + 48) && (v12 = **(_WORD **)(a1 + 52), v12 != -32703) && v12 != -32744 )
        {
LABEL_67:
          v4 = 0;
          *(_DWORD *)(a1 + 56) = 0;
        }
        LOBYTE(v7) = nullsub_1(a1, v17);
        if ( v4 )
        {
          v13 = *(_BYTE *)(a1 + 6);
          if ( v13 == 1 || v13 == 3 )
            nullsub_1(a1, v18);
          v14 = *(_WORD **)(a1 + 52);
          if ( *v14 == 32792 )
          {
            LOBYTE(v7) = sub_100024C0(0, v4);
            if ( !*(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 56) = 0;
            *(_BYTE *)(a1 + 1) = 1;
          }
          else if ( *v14 == 32871 )
          {
            LOBYTE(v7) = sub_10001E40(a1, *(_DWORD *)(a1 + 56), -32734);
          }
          else
          {
            v7 = *v14 + 32648;
            if ( *v14 == 32888 )
            {
              v15 = *(_DWORD *)(a1 + 56);
              if ( v15 )
                *(_BYTE *)(v15 + 26) = 1;
            }
          }
        }
        break;
    }
  }
  return v7;
}
// 10015CC0: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 10120804: using guessed type char byte_10120804;

//----- (100021D0) --------------------------------------------------------
int __usercall sub_100021D0@<eax>(unsigned int a1@<eax>)
{
  unsigned int v1; // edi@1
  int result; // eax@1
  __int16 v3; // ax@2
  bool v4; // al@4
  char v5; // [sp+4h] [bp-4h]@1

  v1 = a1;
  for ( result = sub_10016050(*(_DWORD *)(a1 + 52), (int)&v5);
        result != 1;
        result = sub_10016050(*(_DWORD *)(v1 + 52), (int)&v5) )
  {
    v3 = **(_WORD **)(v1 + 52);
    v4 = v3 == -32696 || v3 == -32734;
    *(_BYTE *)(v1 + 10) = v4;
    sub_10001EA0(v1);
    if ( *(_BYTE *)(v1 + 6) != 1 && *(_BYTE *)(v1 + 10) && (*(_BYTE *)(v1 + 392) || *(_BYTE *)(v1 + 1)) )
    {
      sub_10001B00(v1, (int)&dword_1017E5A0);
      *(_BYTE *)(v1 + 10) = 0;
    }
  }
  return result;
}
// 1017E5A0: using guessed type int dword_1017E5A0;

//----- (10002260) --------------------------------------------------------
void __usercall __noreturn sub_10002260(char *a1@<edi>)
{
  void *v1; // ecx@8
  unsigned int v2; // esi@16
  int v3; // eax@19
  int v4; // [sp+10h] [bp-ECh]@1
  char v5; // [sp+14h] [bp-E8h]@9
  char v6; // [sp+18h] [bp-E4h]@5

  dword_102D1B1C = (int)&dword_1026D920;
  sub_100162B0(&v4);
  if ( !(v4 & 0x10) )
    sub_10015C20(".\\cdp_main.c", 403, 1, 0);
  v4 |= 0x10u;
  if ( !sub_10016240(1, 20000) )
    sub_10015C20(".\\cdp_main.c", 428, 1, 0);
  sub_10015480();
  sub_10037F50(&v6);
  sub_100165F0();
  while ( 1 )
  {
    byte_102D1AC8 = 0;
    if ( v4 & 0x10 || v4 & 0x8000 )
    {
      sub_100015F0((int)&byte_102D1940);
      byte_102D1942 = sub_10025CB0(v1);
      byte_102D1944 = 0;
      dword_102D1974 = (int)&unk_10120810;
      word_102D194E = 0;
      word_102D1950 = 0;
      dword_102D1980 = 5;
      word_102D1954 = 125;
      dword_102D1958 = -1;
      dword_102D195C = -1;
      byte_102D194B = 1;
      dword_102D1988 = 0;
      byte_102D1940 = 0;
      while ( sub_10016050(dword_102D1974, (int)&v5) != 1 )
        ;
      sub_100014D0();
      sub_10002840((int)&byte_102D1940);
      sub_100144B0((int)a1, (int)&byte_102D1940);
      sub_10038370((int)&unk_10086150);
      sub_10038360((int)&unk_10086158);
      sub_10001860((int)&byte_102D1940);
      sub_100145F0((unsigned int)&byte_102D1940);
    }
    if ( v4 & 2 )
      sub_100021D0((unsigned int)&byte_102D1940);
    if ( v4 & 1 )
    {
      v4 |= 0x20000000u;
      if ( (unsigned int)(sub_100160A0() - dword_10120808) >= 0x3E8 )
      {
        dword_10120808 += 1000;
        j_nullsub_1(&byte_102D1940);
        sub_10037E40((int *)&v6);
      }
    }
    v2 = 0x40000000;
    do
    {
      if ( v2 != 0x8000 && v2 & v4 )
      {
        v3 = sub_10037A60(v2);
        sub_10001CF0((int)&byte_102D1940, v3);
        sub_100021D0((unsigned int)&byte_102D1940);
      }
      v2 >>= 1;
    }
    while ( v2 >= 0x200 );
    if ( byte_102D1AC8 || byte_102D1941 )
    {
      a1 = &byte_102D1940;
      sub_10001B00((int)&byte_102D1940, (int)&dword_1017E5A0);
    }
    sub_100162B0(&v4);
  }
}
// 100014D0: using guessed type int sub_100014D0(void);
// 10015480: using guessed type int sub_10015480(void);
// 10038350: using guessed type int __cdecl j_nullsub_1(_DWORD);
// 10120808: using guessed type int dword_10120808;
// 1017E5A0: using guessed type int dword_1017E5A0;
// 1026D920: using guessed type int dword_1026D920;
// 102D1940: using guessed type char byte_102D1940;
// 102D1941: using guessed type char byte_102D1941;
// 102D1942: using guessed type char byte_102D1942;
// 102D1944: using guessed type char byte_102D1944;
// 102D194B: using guessed type char byte_102D194B;
// 102D194E: using guessed type __int16 word_102D194E;
// 102D1950: using guessed type __int16 word_102D1950;
// 102D1954: using guessed type __int16 word_102D1954;
// 102D1958: using guessed type int dword_102D1958;
// 102D195C: using guessed type int dword_102D195C;
// 102D1974: using guessed type int dword_102D1974;
// 102D1980: using guessed type int dword_102D1980;
// 102D1988: using guessed type int dword_102D1988;
// 102D1AC8: using guessed type char byte_102D1AC8;
// 102D1B1C: using guessed type int dword_102D1B1C;

//----- (100024A0) --------------------------------------------------------
int __cdecl sub_100024A0(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256) << 8;
}

//----- (100024C0) --------------------------------------------------------
char __cdecl sub_100024C0(int a1, unsigned int a2)
{
  char result; // al@4

  if ( !a2 || a2 < (unsigned int)&unk_1026D924 || a2 >= dword_1026D920 )
    result = sub_10015C20(".\\cdp_mem.c", 222, 1, 0);
  dword_1026D920 = a2;
  return result;
}
// 1026D920: using guessed type int dword_1026D920;

//----- (10002500) --------------------------------------------------------
char sub_10002500()
{
  char result; // al@1

  byte_101208E0 = 0;
  result = sub_10015FA0((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( result )
    byte_101208E0 = 1;
  return result;
}
// 101208E0: using guessed type char byte_101208E0;

//----- (10002520) --------------------------------------------------------
char __thiscall sub_10002520(int this)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  int v3; // ecx@5
  int v4; // eax@5
  char *v5; // edi@6
  char v7[4]; // [sp+4h] [bp-ACh]@1
  int v8; // [sp+8h] [bp-A8h]@1
  int v9; // [sp+Ch] [bp-A4h]@1
  int v10; // [sp+10h] [bp-A0h]@1
  int v11; // [sp+14h] [bp-9Ch]@1
  char v12; // [sp+18h] [bp-98h]@1
  char v13; // [sp+2Ch] [bp-84h]@1

  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_100160C0((int)&v12, 1, *(_DWORD *)(this + 64), 20);
  sub_10038570(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v12);
  LOBYTE(v1) = sub_10015FA0((int)&v13);
  if ( (_BYTE)v1 )
  {
    v1 = j_FIL_vfs_open(&v13, 4, 0);
    v2 = v1;
    if ( v1 < 0xFFFFFFC2
      && v1
      && (sub_10015E10(v1, &byte_101208E8, 4096),
          sub_10015D40(v2),
          (v1 = (unsigned int)strstr(&byte_101208E8, "usage:")) != 0) )
    {
      v3 = v1 - (_DWORD)&byte_101208E8;
      v4 = v1 - (_DWORD)&byte_101208E8 + 7;
      if ( v4 < v3 + 27 )
      {
        v5 = &v7[-v4];
        do
        {
          if ( !((LOBYTE(word_100AD4C0[(unsigned __int8)*(&byte_101208E8 + v4)]) >> 4) & 1) )
            break;
          v5[v4] = *(&byte_101208E8 + v4);
          ++v4;
        }
        while ( v4 < v3 + 27 );
      }
      v1 = j__atol(v7);
      dword_101218E8 = v1;
    }
    else
    {
      dword_101218E8 = 0;
    }
  }
  else
  {
    dword_101218E8 = 0;
  }
  return v1;
}
// 10015E00: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100AD4C0: using guessed type __int16 word_100AD4C0[];
// 101218E8: using guessed type int dword_101218E8;

//----- (10002690) --------------------------------------------------------
void *__usercall sub_10002690@<eax>(unsigned int a1@<ecx>, int a2@<ebx>)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  void *result; // eax@1
  int v5; // ecx@3
  unsigned int v6; // ebp@3
  _DWORD *i; // esi@5
  int v8; // esi@9
  int v9; // [sp+8h] [bp-198h]@1
  char v10; // [sp+Ch] [bp-194h]@3
  char v11; // [sp+20h] [bp-180h]@1
  char v12; // [sp+54h] [bp-14Ch]@4
  char v13; // [sp+11Ch] [bp-84h]@3

  v2 = 0;
  v3 = a1;
  result = memset(&v11, 0, 0x32u);
  v9 = 0;
  if ( a2 && dword_101218E8 < v3 )
  {
    v5 = *(_DWORD *)(a2 + 64);
    dword_101218E8 = v3;
    sub_100160C0((int)&v10, 1, v5, 20);
    sub_10038570(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v10);
    v6 = j_FIL_vfs_open(&v13, 10, 0);
    sub_10038450((int)&byte_101208E8, "HEAP STATISTICS:\r\n", 4096);
    if ( v3 > 0x64000 )
    {
      sub_10038450((int)&v12, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_100385A0(&byte_101208E8, &v12, 4096);
    }
    sub_10038570(&v12, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v10, v3, 409600);
    result = (void *)sub_100385A0(&byte_101208E8, &v12, 4096);
    for ( i = *(_DWORD **)(a2 + 32); i; ++v2 )
    {
      sub_100029A0((int)i, (__int16 *)&v9, &v11);
      sub_10038570(&v12, 0xC8u, "  Page[%d]: %s\r\n", v2, &v11);
      result = (void *)sub_100385A0(&byte_101208E8, &v12, 4096);
      i = (_DWORD *)*i;
    }
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
      {
        v8 = sub_100384A0(&byte_101208E8, 0x1000u);
        j_FIL_vfs_write(v6, &byte_101208E8, v8);
        sub_10015F50(v6, v8, 0);
        result = (void *)sub_10015D40(v6);
      }
    }
  }
  return result;
}
// 10015E00: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10015F70: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 101218E8: using guessed type int dword_101218E8;

//----- (10002840) --------------------------------------------------------
char __cdecl sub_10002840(int a1)
{
  char result; // al@2

  dword_1026D920 = (int)&unk_1026D924;
  if ( byte_101208E0 )
    result = sub_10002520(a1);
  return result;
}
// 101208E0: using guessed type char byte_101208E0;
// 1026D920: using guessed type int dword_1026D920;

//----- (10002860) --------------------------------------------------------
int __cdecl sub_10002860(int a1, int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@4

  v2 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_101208E0 )
    sub_10002690(dword_1026D920 + 4 * v2 - *(_DWORD *)(a1 + 476), a1);
  if ( !a2 || (result = dword_1026D920, dword_1026D920 + 4 * v2 > *(_DWORD *)(a1 + 476) + 409604) )
  {
    sub_10015C20(".\\cdp_mem.c", 371, 1, 0);
    result = dword_1026D920;
  }
  dword_1026D920 = result + 4 * v2;
  return result;
}
// 101208E0: using guessed type char byte_101208E0;
// 1026D920: using guessed type int dword_1026D920;

//----- (100028E0) --------------------------------------------------------
int __cdecl sub_100028E0(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_100024A0(a2, a3);
  return sub_10002860(a1, v3);
}

//----- (10002920) --------------------------------------------------------
__int16 __cdecl sub_10002920(unsigned __int8 a1)
{
  return *(_WORD *)(dword_1026D918 + 4 * (unsigned __int8)byte_101218F0[a1] + 2);
}
// 1026D918: using guessed type int dword_1026D918;

//----- (10002940) --------------------------------------------------------
char __cdecl sub_10002940(int (__cdecl *a1)(int))
{
  signed int v1; // esi@1

  v1 = sub_10038600(a1);
  if ( v1 == -1 )
    sub_10015C20(".\\cdp_page_list.c", 705, 1, 0);
  return byte_1008DDE0[56 * v1];
}

//----- (10002980) --------------------------------------------------------
char __cdecl sub_10002980(int (__cdecl *a1)(int))
{
  return *(_BYTE *)(dword_1026D918 + 4 * (unsigned __int8)byte_101218F0[(unsigned __int8)sub_10002940(a1)] + 1);
}
// 1026D918: using guessed type int dword_1026D918;

//----- (100029A0) --------------------------------------------------------
char __cdecl sub_100029A0(int a1, __int16 *a2, _BYTE *a3)
{
  int v3; // esi@1
  _BYTE *v4; // ecx@1
  _BYTE *v5; // edx@1
  char *v6; // eax@2
  char v7; // cl@3

  v3 = 56 * sub_10038600(*(int (__cdecl **)(int))(a1 + 8));
  *a2 = sub_10002920(byte_1008DDE0[v3]);
  v4 = *(_BYTE **)(a1 + 252);
  v5 = a3;
  if ( v4 )
  {
    do
    {
      LOBYTE(v6) = *v4;
      *v5++ = *v4++;
    }
    while ( (_BYTE)v6 );
  }
  else
  {
    v6 = (char *)&unk_1008DDE1 + v3;
    do
    {
      v7 = *v6;
      v6[a3 - ((char *)&unk_1008DDE1 + v3)] = *v6;
      ++v6;
    }
    while ( v7 );
  }
  return (unsigned int)v6;
}

//----- (10002A20) --------------------------------------------------------
char __usercall sub_10002A20@<al>(int a1@<ecx>, int a2@<edi>, int a3)
{
  signed int v3; // eax@1
  signed int v4; // esi@3
  char *v5; // edi@3
  int v6; // eax@4
  int v7; // eax@8
  char *v8; // esi@8
  int v9; // ecx@9
  signed int v10; // edi@13
  int (__cdecl **v11)(int); // ebp@13
  int v12; // ST0C_4@15
  int v14; // [sp-Eh] [bp-10h]@3
  int v15; // [sp-2h] [bp-4h]@1

  v15 = a1;
  dword_1026D918 = (int)byte_1008DDD4;
  dword_101218F8 = 0;
  BYTE3(v15) = 0;
  byte_101218F2 = 1;
  v3 = 0;
  do
  {
    byte_101218F0[(unsigned __int8)byte_1008DDD4[4 * v3]] = v3;
    ++v3;
  }
  while ( v3 <= 1 );
  v4 = 0;
  v14 = a2;
  v5 = byte_1008DDE0;
  memset(&unk_10121908, 1, 1u);
  do
  {
    LOBYTE(v6) = *v5;
    if ( (unsigned __int8)*v5 < 1u )
    {
      v6 = (unsigned __int8)v6;
      if ( !*((_BYTE *)&v15 + (unsigned __int8)v6 + 3) )
      {
        word_101218F4[v6] = v4;
        *((_BYTE *)&v15 + (unsigned __int8)v6 + 3) = 1;
      }
    }
    ++v4;
    v5 += 56;
  }
  while ( v4 < 1 );
  dword_101218FC = (int)*(&off_1008DDDC + 14 * (unsigned __int16)word_101218F4[0]);
  v7 = 0;
  BYTE3(v15) = 0;
  v8 = byte_1008DDE0;
  do
  {
    LOBYTE(v9) = *v8;
    if ( (unsigned __int8)*v8 < 1u )
    {
      v9 = (unsigned __int8)v9;
      if ( !*((_BYTE *)&v15 + (unsigned __int8)v9 + 3) )
      {
        word_10121900[v9] = v7;
        *((_BYTE *)&v15 + (unsigned __int8)v9 + 3) = 1;
      }
    }
    --v7;
    v8 -= 56;
  }
  while ( v7 >= 0 );
  sub_100145E0();
  sub_10002B80(a3);
  sub_100143C0(a3);
  v10 = 0;
  v11 = &off_1008DDDC;
  do
  {
    (*v11)(a3);
    ++v10;
    v11 += 14;
  }
  while ( v10 < 1 );
  nullsub_1(a3, v14);
  nullsub_1(a3, v12);
  return sub_100024C0(0, *(_DWORD *)(a3 + 56));
}
// 10002A20: could not find valid save-restore pair for edi
// 1008DDDC: using guessed type int (__cdecl *off_1008DDDC)(int);
// 101218F2: using guessed type char byte_101218F2;
// 101218F4: using guessed type __int16 word_101218F4[];
// 101218F8: using guessed type int dword_101218F8;
// 101218FC: using guessed type int dword_101218FC;
// 10121900: using guessed type __int16 word_10121900[];
// 1026D918: using guessed type int dword_1026D918;

//----- (10002B80) --------------------------------------------------------
_WORD *__cdecl sub_10002B80(int a1)
{
  void *v1; // eax@1

  v1 = (void *)sub_10002860(a1, 332);
  *(_DWORD *)(a1 + 56) = v1;
  qmemcpy(v1, &unk_10086178, 0x14Cu);
  sub_10001640(a1, *(char **)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_1006D800(a1 + 392, (int)&dword_1017E5A0, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_1006D7A0(a1 + 392);
}
// 1017E5A0: using guessed type int dword_1017E5A0;

//----- (10002BF0) --------------------------------------------------------
int __cdecl sub_10002BF0(int a1)
{
  unsigned int v1; // eax@1

  v1 = *(_BYTE *)dword_102D2B4C;
  if ( v1 >= 0x3F )
    LOBYTE(v1) = 63;
  return ((int (__cdecl *)(int, _DWORD, _DWORD))dword_102D1FC0[2 * (unsigned __int8)v1])(a1, 0, 0);
}
// 102D1FC0: using guessed type int dword_102D1FC0[];
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10002C20) --------------------------------------------------------
char __fastcall sub_10002C20(char *a1, unsigned __int8 a2)
{
  char result; // al@1

  result = *a1;
  if ( !((unsigned __int8)*a1 & a2) )
  {
    *a1 = a2 | result;
    result = sub_10016450(9187, (int)a1, 1);
  }
  return result;
}

//----- (10002C40) --------------------------------------------------------
int __usercall sub_10002C40@<eax>(char a1@<bl>, int edi0@<edi>, float a2, float a3)
{
  float v4; // ST2C_4@2
  float v5; // ST34_4@2
  float v6; // ST30_4@2
  float v7; // ST2C_4@2
  float v8; // ST20_4@2
  float v9; // ST2C_4@4
  float v10; // ST34_4@4
  float v11; // ST30_4@4
  float v12; // ST2C_4@4
  float v13; // ST20_4@4
  float v14; // ST2C_4@6
  float v15; // ST34_4@6
  float v16; // ST30_4@6
  float v17; // ST2C_4@6
  float v18; // ST20_4@6
  float v19; // ST2C_4@9
  float v20; // ST34_4@9
  float v21; // ST30_4@9
  double v22; // ST38_8@9
  float v23; // ST2C_4@9
  double v24; // st7@9
  signed int v25; // esi@9
  int v27; // [sp+1Ch] [bp-50h]@0
  int v28; // [sp+1Ch] [bp-50h]@9
  float v29; // [sp+20h] [bp-4Ch]@9
  float v30; // [sp+24h] [bp-48h]@9
  float v31; // [sp+28h] [bp-44h]@9
  float v32; // [sp+2Ch] [bp-40h]@9
  float v33; // [sp+34h] [bp-38h]@1
  float v34; // [sp+38h] [bp-34h]@1
  int v35; // [sp+3Ch] [bp-30h]@1
  float v36; // [sp+40h] [bp-2Ch]@1
  int v37; // [sp+44h] [bp-28h]@1
  int v38; // [sp+48h] [bp-24h]@1
  float v39; // [sp+4Ch] [bp-20h]@1
  float v40; // [sp+50h] [bp-1Ch]@1
  double v41; // [sp+58h] [bp-14h]@9
  char v42; // [sp+60h] [bp-Ch]@1

  sub_10038450((int)&v42, byte_100879F8, 5);
  v36 = 9.0;
  v39 = 0.5;
  v40 = 0.5;
  v37 = -16777216;
  v33 = a2;
  v38 = -1;
  v35 = 1;
  v34 = a3;
  switch ( a1 )
  {
    case 0:
      sub_10015770(1.0);
      j_gdi_pvg_begin(66);
      j_gdi_pvg_color_u32(-1);
      v4 = a3 + 10.0;
      v5 = a2 - 13.0;
      sub_10015960(v5, v4);
      v6 = a2 + 13.0;
      sub_10015960(v6, v4);
      v7 = a3 - 10.0;
      sub_10015960(v6, v7);
      sub_10015960(v5, v7);
      j_gdi_pvg_end(LODWORD(v8));
      sub_10038450((int)&v42, &unk_100894EC, 5);
      break;
    case 1:
      sub_1003A060(edi0, a2, a3, 13.0, 11.4, 0.0, 360.0, -16711936);
      v38 = -16711936;
      sub_10038450((int)&v42, &unk_100894DC, 5);
      break;
    case 3:
      sub_10015770(1.0);
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(-65536);
      v9 = a3 + 10.0;
      v10 = a2 - 13.0;
      sub_10015960(v10, v9);
      v11 = a2 + 13.0;
      sub_10015960(v11, v9);
      v12 = a3 - 10.0;
      sub_10015960(v11, v12);
      sub_10015960(v10, v12);
      j_gdi_pvg_end(LODWORD(v13));
      sub_10038450((int)&v42, &unk_100894EC, 5);
      v37 = -65536;
      v38 = -1;
      break;
    case 4:
      sub_1003A060(edi0, a2, a3, 13.0, 0.0, 0.0, 360.0, -65536);
      v38 = -1;
      v37 = -65536;
      sub_10038450((int)&v42, &unk_100894DC, 5);
      break;
    case 5:
      sub_10015770(1.0);
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(-1);
      v14 = a3 + 10.0;
      v15 = a2 - 13.0;
      sub_10015960(v15, v14);
      v16 = a2 + 13.0;
      sub_10015960(v16, v14);
      v17 = a3 - 10.0;
      sub_10015960(v16, v17);
      sub_10015960(v15, v17);
      j_gdi_pvg_end(LODWORD(v18));
      j_gdi_pvg_color_u32(-65536);
      goto LABEL_7;
    default:
LABEL_7:
      if ( a1 != 5 )
        j_gdi_pvg_color_u32(-256);
      sub_10015770(1.5);
      j_gdi_pvg_begin(66);
      v19 = a3 + 10.0;
      v41 = a2 - 13.0;
      v20 = v41;
      sub_10015960(v20, v19);
      v21 = a2 + 13.0;
      sub_10015960(v21, v19);
      v22 = a3 - 10.0;
      v23 = v22;
      sub_10015960(v21, v23);
      sub_10015960(v20, v23);
      j_gdi_pvg_end(v27);
      v24 = v22;
      v32 = v22;
      v31 = v32;
      v29 = v41;
      v30 = v29;
      j_gdi_pvg_scissor((signed int)v41, (signed int)v24, 26, 20);
      j_gdi_pvg_enable(36);
      j_gdi_pvg_begin(64);
      v25 = 8;
      do
      {
        v31 = v31 + 5.150000095367432;
        v30 = v30 + 5.150000095367432;
        sub_10015960(v29, v31);
        sub_10015960(v30, v32);
        --v25;
      }
      while ( v25 );
      j_gdi_pvg_end(v28);
      j_gdi_pvg_disable(36);
      break;
  }
  return sub_10038F80((int)&v42, (int)&v33);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10015880: using guessed type int __cdecl j_gdi_pvg_scissor(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10003170) --------------------------------------------------------
int __usercall sub_10003170@<eax>(int a1@<ecx>, int a2@<esi>, int a3, float a4, float a5)
{
  int result; // eax@1
  unsigned int v6; // ecx@9
  char *v7; // [sp-Ch] [bp-3Ch]@5
  _BYTE *v8; // [sp-8h] [bp-38h]@5
  float v9; // [sp+0h] [bp-30h]@1
  float v10; // [sp+4h] [bp-2Ch]@1
  int v11; // [sp+8h] [bp-28h]@1
  float v12; // [sp+Ch] [bp-24h]@1
  int v13; // [sp+10h] [bp-20h]@1
  int v14; // [sp+14h] [bp-1Ch]@1
  float v15; // [sp+18h] [bp-18h]@1
  float v16; // [sp+1Ch] [bp-14h]@1
  float v17; // [sp+20h] [bp-10h]@1
  char v18; // [sp+24h] [bp-Ch]@5

  v15 = 0.5;
  result = a3 & 0xF000000;
  v16 = 0.0;
  v13 = -16777216;
  v17 = 0.0;
  v14 = -16711681;
  v11 = 1;
  v12 = 9.0;
  v9 = a4;
  v10 = a5;
  if ( (a3 & 0xF000000u) > 0x2000000 )
  {
    if ( result == 0x4000000 )
    {
LABEL_17:
      v8 = &unk_10089514;
      goto LABEL_18;
    }
    if ( result == 0x8000000 )
    {
      v8 = &unk_10089518;
      v7 = &v18;
      goto LABEL_19;
    }
  }
  else
  {
    if ( (a3 & 0xF000000) == 0x2000000 )
    {
      v8 = &unk_1008951C;
LABEL_18:
      v7 = &v18;
      goto LABEL_19;
    }
    if ( !result )
      return result;
    if ( result == 0x1000000 )
    {
LABEL_5:
      v8 = &unk_10089520;
      v7 = &v18;
      goto LABEL_19;
    }
  }
  v6 = a1 & 0xF000000;
  result = v6;
  if ( v6 <= 0x4000000 )
  {
    if ( v6 != 0x4000000 )
    {
      if ( v6 != 0x1000000 )
      {
        if ( v6 != 0x2000000 )
          return result;
        v8 = &unk_1008951C;
        v7 = &v18;
        goto LABEL_19;
      }
      goto LABEL_5;
    }
    goto LABEL_17;
  }
  if ( v6 != 0x8000000 )
    return result;
  v8 = &unk_10089518;
  v7 = &v18;
LABEL_19:
  sub_10038450((int)v7, v8, 5);
  sub_100393A0(a2, (int)&unk_10089510, (int)&v9);
  v10 = v10 + v12 + 4.0;
  return sub_100393A0(a2, (int)&v18, (int)&v9);
}

//----- (100032B0) --------------------------------------------------------
int __cdecl sub_100032B0(float a1, float a2, char a3)
{
  double v3; // st7@2
  float v5; // [sp+0h] [bp-20h]@4
  float v6; // [sp+4h] [bp-1Ch]@4
  float v7; // [sp+8h] [bp-18h]@4
  float v8; // [sp+Ch] [bp-14h]@4
  float v9; // [sp+10h] [bp-10h]@4
  float v10; // [sp+14h] [bp-Ch]@4
  float v11; // [sp+18h] [bp-8h]@2
  int v12; // [sp+1Ch] [bp-4h]@4

  if ( a3 )
  {
    v11 = 0.0;
    v3 = a1 + 18.0;
  }
  else
  {
    v11 = 180.0;
    v3 = a1 - 18.0;
  }
  v5 = v3;
  v12 = -256;
  v6 = a2 - 4.0;
  v7 = 12.0;
  v10 = 11.0;
  v8 = 0.5;
  v9 = 0.5;
  return sub_100395F0((int)&v5);
}

//----- (10003330) --------------------------------------------------------
int __usercall sub_10003330@<eax>(int a1@<eax>, int a2@<edi>, int a3@<esi>, int a4, float a5, float a6, float a7, float a8)
{
  double v8; // ST1C_8@2
  double v9; // ST14_8@2
  float v10; // ST0C_4@2
  int result; // eax@2
  float v12; // [sp+18h] [bp-24h]@1
  float v13; // [sp+1Ch] [bp-20h]@1
  int v14; // [sp+20h] [bp-1Ch]@1
  float v15; // [sp+24h] [bp-18h]@1
  int v16; // [sp+28h] [bp-14h]@1
  int v17; // [sp+2Ch] [bp-10h]@1
  float v18; // [sp+30h] [bp-Ch]@1
  float v19; // [sp+34h] [bp-8h]@1
  float v20; // [sp+38h] [bp-4h]@1
  float v21; // [sp+44h] [bp+8h]@2
  float v22; // [sp+4Ch] [bp+10h]@2
  float v23; // [sp+4Ch] [bp+10h]@2
  float v24; // [sp+50h] [bp+14h]@2
  float v25; // [sp+50h] [bp+14h]@2
  float v26; // [sp+50h] [bp+14h]@2

  v15 = a7;
  v16 = a2;
  v17 = a1;
  v18 = 0.5;
  v19 = 0.5;
  v14 = sub_10038970(a7);
  v20 = 0.0;
  v12 = a5;
  v13 = a6;
  if ( LOBYTE(a8) )
  {
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(a2);
    v22 = sub_10016B80(v14, a3, v15) + 3.0;
    v24 = sub_10016990(v14, a3, v15) + 3.0;
    v8 = v24 * 0.5;
    v25 = a6 - v8;
    v9 = 0.5 * v22;
    v23 = a5 - v9;
    sub_10015960(v23, v25);
    v21 = a5 + v9;
    sub_10015960(v21, v25);
    v26 = a6 + v8;
    sub_10015960(v21, v26);
    sub_10015960(v23, v26);
    j_gdi_pvg_end(LODWORD(v10));
    j_gdi_pvg_disable(35);
    result = sub_100388C0(a3, (int)&v12);
  }
  else
  {
    result = sub_100393A0(a4, a3, (int)&v12);
  }
  return result;
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (100034B0) --------------------------------------------------------
int __cdecl sub_100034B0(int a1)
{
  int v1; // ebx@1
  double v2; // st7@2
  float v3; // ST34_4@9
  int v4; // eax@6
  float v6; // [sp+20h] [bp-24h]@2
  int v7; // [sp+24h] [bp-20h]@4
  float v8; // [sp+28h] [bp-1Ch]@2
  char v9; // [sp+30h] [bp-14h]@6

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( *(_BYTE *)(v1 + 52873) )
  {
    v6 = 54.0;
    v8 = 626.0;
    v2 = 643.0;
  }
  else
  {
    v6 = 55.0;
    v8 = 629.0;
    v2 = 650.0;
  }
  v7 = -16711681;
  if ( *(_BYTE *)(v1 + 52840) )
    v7 = -16711936;
  v4 = sub_1003E410(4u);
  sub_10038570(&v9, 0x10u, "%.0f%s", *(float *)(v1 + 52836), v4);
  sub_10003330(v7, -16777216, (int)&v9, a1, v6, v8, 13.0, 0.0);
  if ( *(_BYTE *)(v1 + 52841) )
    sub_10038450((int)&v9, &unk_10089548, 16);
  else
    sub_10038450((int)&v9, &unk_10089518, 16);
  v3 = v2;
  return sub_10003330(v7, -16777216, (int)&v9, a1, v6, v3, 13.0, 0.0);
}

//----- (100035F0) --------------------------------------------------------
char __usercall sub_100035F0@<al>(char a1@<bl>, char a2, char a3, char a4)
{
  char v4; // al@1

  v4 = a2;
  if ( a2 == a1 )
  {
    if ( sub_1003E540((int)"_lg_lever_disag") )
      return 5;
    v4 = a2;
  }
  if ( !v4 )
  {
    if ( a1 )
    {
      if ( a4 )
        goto LABEL_33;
      if ( !a3 || !sub_1003E540((int)"_lg_lever_disag") )
        return 1;
      goto LABEL_17;
    }
LABEL_16:
    if ( a4 )
      goto LABEL_22;
LABEL_17:
    if ( !a3 )
      goto LABEL_18;
LABEL_27:
    if ( sub_1003E540((int)"_lg_lever_disag") && !a2 && a1 )
      return 4;
    if ( a4 )
    {
      v4 = a2;
      goto LABEL_32;
    }
    return 2;
  }
  if ( a1 )
    goto LABEL_16;
  if ( !a4 )
  {
    if ( a3 || !sub_1003E540((int)"_lg_lever_disag") )
      return 0;
LABEL_18:
    if ( !sub_1003E540((int)"_lg_lever_disag") || !a2 || a1 )
      return 2;
    return 3;
  }
LABEL_22:
  if ( v4 && !a1 )
    return 3;
  if ( !a4 )
  {
    if ( !a3 )
      return 2;
    goto LABEL_27;
  }
LABEL_32:
  if ( v4 )
    return 2;
LABEL_33:
  if ( !a1 )
    return 2;
  return 4;
}

//----- (100036E0) --------------------------------------------------------
unsigned __int8 __usercall sub_100036E0@<al>(unsigned __int8 a1@<dl>, unsigned __int8 a2, int a3)
{
  unsigned __int8 result; // al@1
  float v4; // [sp+0h] [bp-28h]@1
  __int16 v5; // [sp+4h] [bp-24h]@1
  __int16 v6; // [sp+6h] [bp-22h]@1
  __int16 v7; // [sp+8h] [bp-20h]@1
  __int16 v8; // [sp+Ah] [bp-1Eh]@1
  __int16 v9; // [sp+Ch] [bp-1Ch]@1
  __int16 v10; // [sp+Eh] [bp-1Ah]@1
  __int16 v11; // [sp+10h] [bp-18h]@1
  __int16 v12; // [sp+12h] [bp-16h]@1
  __int16 v13; // [sp+14h] [bp-14h]@1
  __int16 v14; // [sp+16h] [bp-12h]@1
  __int16 v15; // [sp+18h] [bp-10h]@1
  __int16 v16; // [sp+1Ah] [bp-Eh]@1
  __int16 v17; // [sp+1Ch] [bp-Ch]@1
  __int16 v18; // [sp+1Eh] [bp-Ah]@1
  __int16 v19; // [sp+20h] [bp-8h]@1
  __int16 v20; // [sp+22h] [bp-6h]@1

  result = a2;
  v4 = 9.8999998e24;
  v9 = 3020;
  v10 = 3020;
  v11 = 869;
  v12 = 912;
  v13 = 868;
  v14 = 911;
  v15 = 866;
  v16 = 909;
  v17 = 865;
  v18 = 908;
  v19 = 867;
  v20 = 910;
  v5 = 870;
  v6 = 913;
  v7 = 1278;
  v8 = 1279;
  if ( !(a3 & 0x200000) )
    goto LABEL_11;
  if ( a2 == 4 )
    return sub_1003F220(1, (unsigned __int16)*(&v5 + a1), 0, 4, &v4);
  if ( a2 == 5 )
  {
    if ( *(_BYTE *)dword_102D2B4C == 38 )
      return sub_1003F220(1, (unsigned __int16)*(&v7 + a1), 0, 4, &v4);
  }
  else
  {
LABEL_11:
    if ( !a2 )
      return result;
  }
  return sub_1003F220(1, (unsigned __int16)*(&v9 + a1 + 2 * a2), 0, 4, &v4);
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10003820) --------------------------------------------------------
char __usercall sub_10003820@<al>(__int16 a1@<ax>)
{
  unsigned int v1; // eax@1
  char result; // al@5

  v1 = a1 & 0x7C00;
  if ( v1 <= 0x1000 )
  {
    if ( v1 == 4096 )
      return 3;
    if ( v1 == 1024 )
      return 1;
    if ( v1 == 2048 )
      return 2;
    return 0;
  }
  if ( v1 == 0x2000 )
  {
    result = 4;
  }
  else
  {
    if ( v1 != 0x4000 )
      return 0;
    result = 5;
  }
  return result;
}

//----- (10003860) --------------------------------------------------------
double __cdecl sub_10003860(float a1, char a2)
{
  float v3; // [sp+Ch] [bp-40h]@1
  int v4; // [sp+10h] [bp-3Ch]@1
  float v5; // [sp+14h] [bp-38h]@1
  float v6; // [sp+18h] [bp-34h]@1
  float v7; // [sp+1Ch] [bp-30h]@1
  float v8; // [sp+20h] [bp-2Ch]@1
  float v9; // [sp+24h] [bp-28h]@1
  float v10; // [sp+28h] [bp-24h]@1
  float v11; // [sp+2Ch] [bp-20h]@1
  float v12; // [sp+30h] [bp-1Ch]@1
  float v13; // [sp+34h] [bp-18h]@1
  float v14; // [sp+38h] [bp-14h]@1
  float v15; // [sp+3Ch] [bp-10h]@1
  float v16; // [sp+40h] [bp-Ch]@1
  float v17; // [sp+44h] [bp-8h]@1
  float v18; // [sp+48h] [bp-4h]@1

  *(float *)&v4 = -6.0029998;
  v7 = -0.001;
  v10 = 1.372;
  v13 = 4.2199998;
  v16 = 13.0;
  v5 = *(float *)(dword_102D2B4C + 6540);
  v8 = *(float *)(dword_102D2B4C + 6548);
  v11 = *(float *)(dword_102D2B4C + 6552);
  v14 = *(float *)(dword_102D2B4C + 6556);
  v17 = *(float *)(dword_102D2B4C + 6560);
  v6 = 1.0;
  v9 = 1.0;
  v12 = 1.0;
  v15 = 1.0;
  v18 = 1.0;
  v3 = 9.8999998e24;
  if ( a2 )
    v3 = sub_10038A30(a1, (int)&v4, 5);
  return v3;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10003920) --------------------------------------------------------
int __usercall sub_10003920@<eax>(int a1@<esi>, char a2)
{
  int result; // eax@3
  int v3; // [sp+Ch] [bp-4h]@0
  float v4; // [sp+14h] [bp+4h]@3

  sub_10035D90(v3);
  if ( !a2 )
  {
    *(float *)(a1 + 2372) = 0.0;
    *(float *)(a1 + 2356) = *(float *)(a1 + 2360);
    *(float *)(a1 + 2364) = *(float *)(a1 + 2368);
    *(float *)(a1 + 2420) = *(float *)(a1 + 2424);
    *(float *)(a1 + 2428) = *(float *)(a1 + 2432);
    *(float *)(a1 + 2436) = 0.0;
  }
  v4 = *(float *)(a1 + 20) * 0.9200000166893005;
  result = sub_10035DF0(v4, -0.30000001, 2, a1);
  *(float *)(a1 + 2500) = 2.0;
  *(_BYTE *)(a1 + 5556) = 3;
  *(_DWORD *)(a1 + 2540) = -65536;
  return result;
}

//----- (100039C0) --------------------------------------------------------
int __usercall sub_100039C0@<eax>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(double *)(v1 + 31932) = -1.868440395194937;
  *(_DWORD *)(v1 + 31972) = 10000;
  *(_DWORD *)(v1 + 31976) = sub_100160A0;
  *(double *)(v1 + 31940) = 0.8737027300113839;
  v1 += 31888;
  *(double *)(v1 + 60) = 0.02104955273076243;
  *(double *)(v1 + 68) = 0.0;
  *(double *)(v1 + 76) = -0.02104955273076243;
  return sub_10070440(v1);
}

//----- (10003A20) --------------------------------------------------------
char __usercall sub_10003A20@<al>(int a1@<edi>)
{
  _WORD *v1; // ecx@1
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // eax@2
  char result; // al@7
  __int16 v6; // [sp+4h] [bp-D0h]@7

  sub_100160A0();
  v1 = *(_WORD **)(a1 + 52);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = *v1 != -32747;
  *(_BYTE *)(v2 + 52860) = *v1 == -32747;
  *(_BYTE *)(v2 + 52872) = 1;
  if ( v3 )
    v4 = sub_100160A0() + 300;
  else
    v4 = sub_100160A0() + 700;
  v3 = *(_BYTE *)(v2 + 52873) == 0;
  *(_DWORD *)(v2 + 52864) = v4;
  if ( v3 )
    sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10088FC0, v2, 0, 255);
  else
    sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10089080, v2, 0, 255);
  v6 = -32734;
  result = sub_10001740(a1, (int)&v6, 204);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10003AE0) --------------------------------------------------------
char __usercall sub_10003AE0@<al>(int a1@<eax>, char a2@<dl>)
{
  char *v2; // esi@1

  v2 = (char *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 52841);
  *v2 = a2;
  sub_10016450(9152, (int)v2, 1);
  return sub_1003F6F0(*v2);
}

//----- (10003B10) --------------------------------------------------------
_DWORD *__usercall sub_10003B10@<eax>(_DWORD *result@<eax>, _DWORD *a2@<ecx>, char a3, char a4)
{
  if ( a3 )
  {
    *a2 = -1;
    *result = -65536;
  }
  else if ( a4 )
  {
    *a2 = -16777216;
    *result = -256;
  }
  else
  {
    *a2 = -16711936;
    *result = -16777216;
  }
  return result;
}

//----- (10003B50) --------------------------------------------------------
int __cdecl sub_10003B50(char a1)
{
  return sub_10016450(9159, (int)&a1, 1);
}

//----- (10003B70) --------------------------------------------------------
char __usercall sub_10003B70@<al>(int a1@<esi>, int a2, int a3)
{
  char v3; // bl@1
  int v4; // edi@1
  char v5; // al@5
  char v6; // cl@5
  char v7; // dl@12
  char result; // al@14
  char v9; // [sp+Ah] [bp-Eh]@1
  char v10; // [sp+Bh] [bp-Dh]@2
  int v11; // [sp+Ch] [bp-Ch]@3
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v3 = 0;
  v9 = 0;
  LOBYTE(v12) = 0;
  v4 = sub_100160A0();
  if ( sub_10040380(a2, &v13) && sub_10040380(a3, &v10) )
  {
    if ( !sub_10040380(147, &v11) )
    {
      v3 = 1;
      LOBYTE(v12) = 1;
      LOBYTE(v11) = 0;
    }
    v5 = v13;
    v6 = v10;
    if ( (_BYTE)v13 != v10 || *(_BYTE *)(a1 + 1) != *(_BYTE *)a1 )
      v9 = 1;
    if ( *(_BYTE *)(a1 + 8) != v3
      || *(_BYTE *)(a1 + 2) != (_BYTE)v11
      || *(_BYTE *)(a1 + 1) != (_BYTE)v13
      || *(_BYTE *)a1 != v10 )
    {
      v7 = v11;
      *(_BYTE *)(a1 + 8) = v3;
      *(_BYTE *)(a1 + 2) = v7;
      *(_BYTE *)(a1 + 1) = v5;
      *(_BYTE *)a1 = v6;
      if ( v9 )
        *(_DWORD *)(a1 + 4) = v4;
    }
    result = sub_100035F0(v6, v5, v11, v12);
  }
  else
  {
    result = 5;
  }
  return result;
}

//----- (10003C50) --------------------------------------------------------
int __usercall sub_10003C50@<eax>(_BYTE *a1@<edi>, float *a2, float *a3)
{
  char v3; // bl@9
  double v4; // st7@9
  int v5; // ecx@9
  char v6; // dl@10
  int result; // eax@18
  int v8; // [sp+8h] [bp-14h]@7
  int v9; // [sp+Ch] [bp-10h]@3
  int v10; // [sp+10h] [bp-Ch]@1
  int v11; // [sp+14h] [bp-8h]@5
  int v12; // [sp+18h] [bp-4h]@5

  if ( !sub_1003F220(0, 256, 0, 4, &v10) )
    v10 = 0;
  if ( !sub_1003F220(1, 859, 0, 4, &v9) )
    v9 = 0;
  LOBYTE(v12) = sub_10003820(v10);
  *a2 = sub_100036E0(v12, v9);
  if ( !sub_1003F220(0, 257, 0, 4, &v11) )
    v11 = 0;
  if ( !sub_1003F220(1, 902, 0, 4, &v8) )
    v8 = 0;
  v3 = sub_10003820(v11);
  v4 = sub_100036E0(v3, v8);
  v5 = v8;
  *a3 = v4;
  if ( (v9 | v5) & 0x200000 )
  {
    v6 = 3;
  }
  else if ( v9 & 0x100000 && v5 & 0x100000 )
  {
    v6 = 2;
  }
  else
  {
    v6 = v9 & 0x80000 && v5 & 0x80000;
  }
  LOBYTE(result) = v3;
  if ( (unsigned __int8)v12 > (signed int)(unsigned __int8)v3 )
    LOBYTE(result) = v12;
  result = (unsigned __int8)result;
  switch ( (unsigned __int8)result )
  {
    case 4u:
      result = (unsigned __int8)v6 - 1;
      if ( v6 == 1 )
      {
        *a1 = 5;
      }
      else
      {
        result = (unsigned __int8)v6 - 2;
        if ( v6 == 2 )
        {
          *a1 = 6;
        }
        else
        {
          result = (unsigned __int8)v6 - 3;
          if ( v6 == 3 )
            *a1 = 7;
          else
            *a1 = 4;
        }
      }
      break;
    case 2u:
      *a1 = 9;
      break;
    case 1u:
      *a1 = 10;
      break;
    case 3u:
      *a1 = 8;
      break;
    case 5u:
      *a1 = 0;
      result = dword_102D2B4C;
      if ( *(_BYTE *)dword_102D2B4C == 38 )
      {
        result = (unsigned __int8)v6 - 1;
        if ( v6 == 1 )
        {
          *a1 = 1;
        }
        else
        {
          result = (unsigned __int8)v6 - 2;
          if ( v6 == 2 )
          {
            *a1 = 2;
          }
          else
          {
            result = (unsigned __int8)v6 - 3;
            if ( v6 == 3 )
              *a1 = 3;
          }
        }
      }
      break;
    default:
      *a1 = 11;
      break;
  }
  return result;
}
// 100036E0: using guessed type double __cdecl sub_100036E0(char, _DWORD);
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10003E20) --------------------------------------------------------
void __usercall sub_10003E20(int a1@<eax>, int a2@<edi>, float a3, float a4, int a5)
{
  int v5; // esi@1
  int v6; // ecx@1

  v5 = a1;
  sub_10035DF0(a3, a4, a1, a2);
  v6 = (v5 << 6) + a2;
  *(_DWORD *)(v6 + 2412) = a5;
  if ( 9.8999998e24 == a3 )
    *(_BYTE *)(v6 + 2416) = 1;
}

//----- (10003E70) --------------------------------------------------------
void __cdecl sub_10003E70(int a1)
{
  int v1; // esi@1
  double v2; // st7@6
  double v3; // st7@11
  float v4; // ST1C_4@27
  float v5; // ST1C_4@27
  float v6; // ST1C_4@27
  double v7; // st7@27
  float v8; // ST1C_4@30
  float v9; // ST1C_4@30
  float v10; // ST1C_4@30
  char v11; // [sp+14h] [bp-6Ch]@3
  char v12[4]; // [sp+19h] [bp-67h]@7
  char v13[4]; // [sp+22h] [bp-5Eh]@18
  float v14; // [sp+28h] [bp-58h]@27
  float v15; // [sp+2Ch] [bp-54h]@27
  float v16; // [sp+30h] [bp-50h]@27
  float v17; // [sp+34h] [bp-4Ch]@8
  float v18; // [sp+38h] [bp-48h]@13
  char v19; // [sp+48h] [bp-38h]@1
  char v20[4]; // [sp+4Dh] [bp-33h]@5
  char v21[4]; // [sp+56h] [bp-2Ah]@15
  float v22; // [sp+5Ch] [bp-24h]@30
  float v23; // [sp+60h] [bp-20h]@30
  float v24; // [sp+64h] [bp-1Ch]@30
  float v25; // [sp+68h] [bp-18h]@6
  float v26; // [sp+6Ch] [bp-14h]@11

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( !sub_1003F220(6, 219, 0, 52, &v19) )
    memset(&v19, 0, 0x34u);
  if ( !sub_1003F220(6, 220, 0, 52, &v11) )
    memset(&v11, 0, 0x34u);
  if ( v20[2] )
  {
    v2 = v25;
  }
  else
  {
    if ( !v12[2] )
      goto LABEL_10;
    v2 = v17;
  }
  *(float *)(v1 + 428) = v2;
LABEL_10:
  if ( v20[3] )
  {
    v3 = v26;
  }
  else
  {
    if ( !v12[3] )
      goto LABEL_15;
    v3 = v18;
  }
  *(float *)(v1 + 440) = v3;
LABEL_15:
  if ( !v21[0] )
    goto LABEL_21;
  if ( v20[0] )
  {
    if ( v20[1] && !v13[0] && v12[0] && v12[1] )
      goto LABEL_27;
LABEL_21:
    if ( v20[0] )
      goto LABEL_24;
  }
  if ( v12[0] && v12[1] )
    goto LABEL_27;
LABEL_24:
  if ( !v20[1] && v12[0] && v12[1] != v20[1] )
  {
LABEL_27:
    v4 = v16 * 57.29578018188477;
    *(float *)(v1 + 476) = sub_10003860(v4, v13[0]);
    v5 = v14 * 57.29578018188477;
    *(float *)(v1 + 452) = sub_10003860(v5, v12[0]);
    v6 = v15 * 57.29578018188477;
    v7 = sub_10003860(v6, v12[1]);
    goto LABEL_32;
  }
  if ( v20[0] && v20[1] )
  {
    v8 = v24 * 57.29578018188477;
    *(float *)(v1 + 476) = sub_10003860(v8, v21[0]);
    v9 = v22 * 57.29578018188477;
    *(float *)(v1 + 452) = sub_10003860(v9, v20[0]);
    v10 = v23 * 57.29578018188477;
    v7 = sub_10003860(v10, v20[1]);
  }
  else
  {
    v7 = 9.8999998e24;
    *(float *)(v1 + 476) = 9.8999998e24;
    *(float *)(v1 + 452) = 9.8999998e24;
  }
LABEL_32:
  *(float *)(v1 + 464) = v7;
}

//----- (100040A0) --------------------------------------------------------
void __cdecl sub_100040A0(int a1)
{
  int v1; // esi@1
  double v2; // st7@6
  double v3; // st7@11
  float v4; // ST18_4@17
  double v5; // st7@17
  float v6; // ST18_4@17
  float v7; // ST18_4@17
  float v8; // ST18_4@17
  float v9; // ST18_4@17
  char v10; // [sp+10h] [bp-6Ch]@3
  char v11; // [sp+16h] [bp-66h]@16
  char v12; // [sp+17h] [bp-65h]@7
  char v13; // [sp+18h] [bp-64h]@12
  float v14; // [sp+28h] [bp-54h]@17
  float v15; // [sp+30h] [bp-4Ch]@8
  float v16; // [sp+34h] [bp-48h]@13
  char v17; // [sp+44h] [bp-38h]@1
  char v18; // [sp+49h] [bp-33h]@15
  char v19; // [sp+4Bh] [bp-31h]@5
  char v20; // [sp+4Ch] [bp-30h]@10
  float v21; // [sp+58h] [bp-24h]@17
  float v22; // [sp+64h] [bp-18h]@6
  float v23; // [sp+68h] [bp-14h]@11

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( !sub_1003F220(6, 219, 0, 52, &v17) )
    memset(&v17, 0, 0x34u);
  if ( !sub_1003F220(6, 220, 0, 52, &v10) )
    memset(&v10, 0, 0x34u);
  if ( v19 )
  {
    v2 = v22;
  }
  else
  {
    if ( !v12 )
      goto LABEL_10;
    v2 = v15;
  }
  *(float *)(v1 + 428) = v2;
LABEL_10:
  if ( v20 )
  {
    v3 = v23;
LABEL_14:
    *(float *)(v1 + 440) = v3;
    goto LABEL_15;
  }
  if ( v13 )
  {
    v3 = v16;
    goto LABEL_14;
  }
LABEL_15:
  if ( v18 && v11 )
  {
    v4 = v14 * 57.29578018188477;
    v5 = v4;
    v6 = 57.29578018188477 * v21;
    v7 = (v5 + v6) * 0.5 + 13.0;
    v8 = sub_100707A0(v7, 0.0099999998);
    *(float *)(v1 + 476) = v8;
    v9 = v8 * -1.0;
    *(float *)(v1 + 452) = v9;
    *(float *)(v1 + 464) = v9;
  }
  else
  {
    *(float *)(v1 + 452) = 9.8999998e24;
    *(float *)(v1 + 464) = 9.8999998e24;
    *(float *)(v1 + 476) = 9.8999998e24;
  }
}

//----- (10004220) --------------------------------------------------------
char __usercall sub_10004220@<al>(int a1@<eax>, int a2@<ecx>, char a3)
{
  int v3; // esi@1
  char v4; // al@12
  char result; // al@31
  char v6; // al@32
  int v7; // [sp-2h] [bp-4h]@1

  v7 = a2;
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  BYTE3(v7) = 0;
  sub_100163E0(9159, (char *)&v7 + 2, 1, (char *)&v7 + 3);
  if ( *(_DWORD *)(v3 + 52880) <= 0u )
  {
    if ( a3 || !*(_BYTE *)(v3 + 52901) || *(_BYTE *)(v3 + 52842) != BYTE2(v7) )
    {
      *(_BYTE *)(v3 + 52901) = 1;
      *(_BYTE *)(v3 + 52842) = BYTE2(v7);
      if ( BYTE2(v7) )
      {
        sub_10014250(35, 1, 0);
        sub_10014250(36, 0, 0);
      }
      else
      {
        sub_10014250(35, 0, 0);
        sub_10014250(36, 1, 0);
      }
    }
    sub_10014250(42, 0, 0);
  }
  else if ( a3 || *(_BYTE *)(v3 + 52901) == 1 )
  {
    *(_BYTE *)(v3 + 52901) = 0;
    sub_10014250(35, -1, 1);
    sub_10014250(36, -1, 1);
  }
  v4 = *(_BYTE *)(v3 + 52875);
  *(_BYTE *)(v3 + 52874) = v4 && *(_DWORD *)(v3 + 52880) > 0u;
  if ( v4 && *(_DWORD *)(v3 + 52880) > 0u && (!*(_DWORD *)(v3 + 52832) || *(_BYTE *)(v3 + 52840)) )
  {
    if ( a3 || !*(_BYTE *)(v3 + 52900) )
    {
      if ( *(_BYTE *)(v3 + 52841) )
      {
        sub_10014250(39, 1, 0);
        sub_10014250(40, 0, 0);
      }
      else
      {
        sub_10014250(39, 0, 0);
        sub_10014250(40, 1, 0);
      }
      *(_BYTE *)(v3 + 52900) = 1;
      sub_10014250(37, 0, 0);
      sub_10014250(38, 0, 0);
      sub_10014250(41, 0, 0);
      sub_10014250(42, 0, 0);
      goto LABEL_30;
    }
LABEL_31:
    result = *(_BYTE *)(v3 + 31884);
    if ( result == *(_BYTE *)(v3 + 52902) )
      return result;
    goto LABEL_32;
  }
  if ( !a3 && *(_BYTE *)(v3 + 52900) != 1 )
    goto LABEL_31;
  *(_BYTE *)(v3 + 52900) = 0;
  sub_10014250(37, 0, 1);
  sub_10014250(38, 0, 1);
  sub_10014250(39, -1, 1);
  sub_10014250(40, -1, 1);
  sub_10014250(41, 0, 1);
  if ( *(_DWORD *)(v3 + 52832) > 0u )
    sub_10014250(42, -1, 1);
LABEL_30:
  if ( !a3 )
    goto LABEL_31;
LABEL_32:
  v6 = *(_BYTE *)(v3 + 31884);
  *(_BYTE *)(v3 + 52902) = v6;
  if ( v6 )
    result = sub_10014250(43, 0, 0);
  else
    result = sub_10014250(43, -1, 1);
  return result;
}

//----- (10004450) --------------------------------------------------------
void __usercall sub_10004450(int a1@<ebx>)
{
  int v1; // ebp@1
  char v2; // al@1
  double v3; // st7@2
  char v4; // al@14
  double v5; // st7@15
  int v6; // edi@20
  int v7; // eax@20
  void *v8; // esi@20
  double v9; // st7@29
  float v10; // ST2C_4@32
  int v11; // edi@31
  double v12; // st7@34
  float v13; // ST2C_4@37
  double v14; // st7@39
  bool v15; // al@47
  int v16; // eax@53
  float v17; // ST34_4@68
  float v18; // ST34_4@72
  float v19; // ST18_4@72
  float v20; // ST34_4@72
  float v21; // ST14_4@72
  float v22; // ST34_4@72
  float v23; // ST10_4@72
  float v24; // ST34_4@72
  unsigned int v25; // eax@99
  bool v26; // cf@99
  bool v27; // zf@99
  unsigned int v28; // eax@100
  unsigned int v29; // eax@101
  char v30; // al@104
  float v31; // ST34_4@111
  float v32; // ST34_4@111
  double v33; // st7@111
  float v34; // ST34_4@115
  float v35; // ST18_4@115
  float v36; // ST34_4@115
  float v37; // ST14_4@115
  float v38; // ST34_4@115
  float v39; // ST10_4@115
  float v40; // ST34_4@115
  float v41; // ST14_4@120
  double v42; // st7@122
  float v43; // ST2C_4@125
  char *v44; // [sp+8h] [bp-54h]@116
  float v45; // [sp+Ch] [bp-50h]@11
  float v46; // [sp+Ch] [bp-50h]@111
  char *v47; // [sp+10h] [bp-4Ch]@116
  float v48; // [sp+20h] [bp-3Ch]@4
  float v49; // [sp+20h] [bp-3Ch]@17
  float v50; // [sp+20h] [bp-3Ch]@41
  float v51; // [sp+24h] [bp-38h]@2
  float v52; // [sp+24h] [bp-38h]@15
  float v53; // [sp+24h] [bp-38h]@29
  float v54; // [sp+24h] [bp-38h]@34
  float v55; // [sp+24h] [bp-38h]@39
  float v56; // [sp+24h] [bp-38h]@122
  float v57; // [sp+2Ch] [bp-30h]@0
  signed int v58; // [sp+2Ch] [bp-30h]@49
  char v59; // [sp+33h] [bp-29h]@46
  int v60; // [sp+34h] [bp-28h]@49
  int v61; // [sp+38h] [bp-24h]@42
  int v62; // [sp+3Ch] [bp-20h]@62
  float v63; // [sp+40h] [bp-1Ch]@43
  int v64; // [sp+44h] [bp-18h]@45
  float v65; // [sp+48h] [bp-14h]@44
  char v66; // [sp+4Ch] [bp-10h]@53

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = *(_BYTE *)(v1 + 52873);
  if ( v2 )
  {
    LOBYTE(v57) = 1;
    v51 = 40.0;
    v3 = 70.0;
  }
  else
  {
    LOBYTE(v57) = 0;
    v51 = 68.0;
    v3 = 63.0;
  }
  v48 = v3;
  if ( *(_BYTE *)(v1 + 12056) )
  {
    sub_10003330(-16777216, -256, (int)"FAIL", a1, v51, v48, 13.0, v57);
  }
  else if ( *(_BYTE *)(v1 + 12058) )
  {
    sub_10003330(-16777216, -16711681, (int)&unk_10089518, a1, v51, v48, 13.0, 0.0);
  }
  else if ( *(_BYTE *)(v1 + 12060) )
  {
    if ( v2 )
    {
      v51 = v51 + 10.0;
      v48 = v48 + 23.0;
    }
    v45 = 13.0;
    if ( *(_BYTE *)(v1 + 52860) )
      sub_10003330(-16777216, -256, (int)&unk_100896F0, a1, v51, v48, v45, 0.0);
    else
      sub_10003330(-256, -16777216, (int)&unk_100896F0, a1, v51, v48, v45, 0.0);
  }
  v4 = *(_BYTE *)(v1 + 52873);
  if ( v4 )
  {
    LOBYTE(v57) = 1;
    v52 = 121.0;
    v5 = 70.0;
  }
  else
  {
    LOBYTE(v57) = 0;
    v52 = 208.0;
    v5 = 63.0;
  }
  v49 = v5;
  if ( *(_BYTE *)(v1 + 12057) )
  {
    sub_10003330(-16777216, -256, (int)"FAIL", a1, v52, v49, 13.0, v57);
    goto LABEL_28;
  }
  if ( *(_BYTE *)(v1 + 12059) )
  {
    v6 = -16711681;
    v7 = -16777216;
    v8 = &unk_10089518;
  }
  else
  {
    if ( !*(_BYTE *)(v1 + 12061) )
      goto LABEL_28;
    if ( v4 )
    {
      v52 = v52 + 10.0;
      v49 = v49 + 23.0;
    }
    v8 = &unk_100896F0;
    if ( *(_BYTE *)(v1 + 52860) )
    {
      v6 = -256;
      v7 = -16777216;
    }
    else
    {
      v6 = -16777216;
      v7 = -256;
    }
  }
  sub_10003330(v7, v6, (int)v8, a1, v52, v49, 13.0, 0.0);
LABEL_28:
  if ( *(_BYTE *)(v1 + 52873) )
  {
    LOBYTE(v57) = 1;
    v53 = 38.0;
    v9 = 160.0;
  }
  else
  {
    LOBYTE(v57) = 0;
    v53 = 68.0;
    v9 = 173.0;
  }
  v11 = -65536;
  if ( *(_BYTE *)(v1 + 23256) )
  {
    v10 = v9;
    sub_10003330(-1, -65536, (int)"FIRE", a1, v53, v10, 13.0, v57);
  }
  if ( *(_BYTE *)(v1 + 52873) )
  {
    LOBYTE(v57) = 1;
    v54 = 113.0;
    v12 = 160.0;
  }
  else
  {
    LOBYTE(v57) = 0;
    v54 = 208.0;
    v12 = 173.0;
  }
  if ( *(_BYTE *)(v1 + 23257) )
  {
    v13 = v12;
    sub_10003330(-1, -65536, (int)"FIRE", a1, v54, v13, 13.0, v57);
  }
  if ( *(_BYTE *)(v1 + 52873) )
  {
    v55 = 29.0;
    v14 = 572.0;
  }
  else
  {
    v55 = 68.0;
    v14 = 489.0;
  }
  v50 = v14;
  if ( *(_BYTE *)dword_102D2B4C != 38 )
  {
    if ( *(_BYTE *)dword_102D2B4C != 31 || !(*(_BYTE *)(v1 + 52904) & 1) )
    {
      v47 = byte_100879F8;
      v44 = &v66;
LABEL_118:
      sub_10038570(v44, 9u, v47);
      v11 = -16777216;
      v16 = -16777216;
      goto LABEL_119;
    }
    if ( sub_1003E540((int)"_splr_red_spdbrk") )
    {
      if ( *(_BYTE *)(v1 + 52850) != 3 )
        *(_BYTE *)(v1 + 52850) = 3;
      goto LABEL_96;
    }
    if ( sub_1003E540((int)"_splr_red_x") )
    {
      if ( *(_BYTE *)(v1 + 52850) == 4 )
        goto LABEL_96;
      *(_BYTE *)(v1 + 52850) = 4;
    }
    else if ( sub_1003E540((int)"_splr_wht_fail") )
    {
      if ( *(_BYTE *)(v1 + 52850) == 5 )
        goto LABEL_96;
      *(_BYTE *)(v1 + 52850) = 5;
    }
    else if ( sub_1003E540((int)"_splr_gnd_splr") )
    {
      if ( *(_BYTE *)(v1 + 52850) == 1 )
        goto LABEL_96;
      *(_BYTE *)(v1 + 52850) = 1;
    }
    else if ( sub_1003E540((int)"_splr_grn_spdbrk") )
    {
      if ( *(_BYTE *)(v1 + 52850) == 2 )
        goto LABEL_96;
      *(_BYTE *)(v1 + 52850) = 2;
    }
    else if ( sub_1003E540((int)"_splr_grn_closed") )
    {
      if ( !*(_BYTE *)(v1 + 52850) )
        goto LABEL_96;
      *(_BYTE *)(v1 + 52850) = 0;
    }
    else
    {
      if ( *(_BYTE *)(v1 + 52850) == 6 )
        goto LABEL_96;
      *(_BYTE *)(v1 + 52850) = 6;
    }
    *(_DWORD *)(v1 + 52856) = sub_100160A0();
LABEL_96:
    if ( *(_BYTE *)(v1 + 52850) == 3
      || (*(_BYTE *)(v1 + 52850) == 4 ? (v29 = sub_100160A0() - *(_DWORD *)(v1 + 52856),
                                         v26 = v29 < 0xFA0,
                                         v27 = v29 == 4000) : *(_BYTE *)(v1 + 52850) == 5 ? (v28 = sub_100160A0()
                                                                                                 - *(_DWORD *)(v1 + 52856),
                                                                                             v26 = v28 < 0x2710,
                                                                                             v27 = v28 == 10000) : (v25 = sub_100160A0() - *(_DWORD *)(v1 + 52856), v26 = v25 < 0x3E8, v27 = v25 == 1000),
          !v26 && !v27) )
    {
      *(_BYTE *)(v1 + 52852) = *(_BYTE *)(v1 + 52850);
    }
    v30 = *(_BYTE *)(v1 + 52852);
    if ( v30 != 6 )
      *(_BYTE *)(v1 + 52851) = 0;
    switch ( v30 )
    {
      case 0:
        sub_10038570(&v66, 9u, "CLOSED");
        v11 = -16777216;
        v16 = -16711936;
        goto LABEL_119;
      case 1:
        if ( *(_BYTE *)(v1 + 52873) )
        {
          sub_10038570(&v66, 9u, "SPLR");
          v11 = -16777216;
          v31 = v50 + 13.0;
          sub_10003330(-16711936, -16777216, (int)&v66, a1, v55, v31, 13.0, 0.0);
          sub_10038570(&v66, 9u, "GND");
          v46 = 13.0;
          v16 = -16711936;
          v32 = v50 - 6.5;
          v33 = v32;
          goto LABEL_120;
        }
        sub_10038570(&v66, 9u, "GND SPLR");
LABEL_110:
        v11 = -16777216;
        v16 = -16711936;
        break;
      case 2:
        sub_10038570(&v66, 9u, "SPDBRK");
        goto LABEL_110;
      case 5:
        sub_10038570(&v66, 9u, "FAIL");
        v11 = -1;
        v16 = -16777216;
        goto LABEL_119;
      case 3:
        sub_10038570(&v66, 9u, "SPDBRK");
        v16 = -1;
        goto LABEL_119;
      case 4:
        v34 = v50 - 10.0 + 1.0;
        v35 = v34;
        v36 = v55 + 18.0;
        v37 = v36;
        v38 = v50 + 10.0 + 1.0;
        v39 = v38;
        v40 = v55 - 18.0;
        sub_10038FD0(v40, v39, v37, v35, 0);
        goto LABEL_121;
      default:
        v47 = byte_100879F8;
        v44 = &v66;
        goto LABEL_118;
    }
    goto LABEL_119;
  }
  v15 = sub_1003F220(6, 628, 0, 4, &v61)
     && sub_1003F220(6, 163, 0, 4, &v63)
     && sub_1003F220(6, 164, 0, 4, &v65)
     && sub_1003F220(6, 165, 0, 4, &v64)
     && sub_1003F220(6, 149, 0, 1, &v59);
  v60 = -16711936;
  v58 = -16777216;
  if ( !v15 || !v59 )
  {
    v18 = v50 - 10.0 + 1.0;
    v19 = v18;
    v20 = v55 + 18.0;
    v21 = v20;
    v22 = v50 + 10.0 + 1.0;
    v23 = v22;
    v24 = v55 - 18.0;
    sub_10038FD0(v24, v23, v21, v19, 0);
    goto LABEL_121;
  }
  if ( sub_1003E540((int)"_splrout_to_cfg") && sub_1003E540((int)"_takeoff") )
  {
    v60 = -1;
    sub_10038570(&v66, 9u, "SPDBRK");
    v16 = v60;
    goto LABEL_119;
  }
  if ( v64 & 0x400 )
  {
    v60 = -16777216;
    v58 = -256;
    sub_10038570(&v66, 9u, "FAIL");
  }
  else if ( v63 <= 0.17453292 || v65 <= 0.17453292 )
  {
    sub_10038570(&v66, 9u, "CLOSED");
  }
  else if ( v61 & 0x4000 || (unsigned int)(sub_100160A0() - *(_DWORD *)(v1 + 52892)) < 0x2710 )
  {
    sub_10038570(&v66, 9u, "SPLR");
    v17 = v50 + 13.0;
    sub_10003330(-16711936, -16777216, (int)&v66, a1, v55, v17, 13.0, 0.0);
    sub_10038570(&v66, 9u, "GND");
    v50 = v50 - 6.5;
    if ( v61 & 0x4000 )
    {
      v11 = -16777216;
      *(_DWORD *)(v1 + 52892) = sub_100160A0();
      v16 = v60;
      goto LABEL_119;
    }
  }
  else if ( v61 & 0x4000000
         && v61 & 0x8000000
         && sub_1003F220(6, 581, 0, 4, &v62)
         && (v62 & 0x800 || (unsigned int)(sub_100160A0() - *(_DWORD *)(v1 + 52896)) < 0x1388) )
  {
    sub_10038570(&v66, 9u, "STEEP");
    if ( v62 & 0x800 )
    {
      v11 = -16777216;
      *(_DWORD *)(v1 + 52896) = sub_100160A0();
      v16 = v60;
      goto LABEL_119;
    }
  }
  else
  {
    sub_10038570(&v66, 9u, "SPDBRK");
  }
  v11 = v58;
  v16 = v60;
LABEL_119:
  v46 = 13.0;
  v33 = v50;
LABEL_120:
  v41 = v33;
  sub_10003330(v16, v11, (int)&v66, a1, v55, v41, v46, 0.0);
LABEL_121:
  if ( *(_BYTE *)(v1 + 52873) )
  {
    v56 = 120.0;
    v42 = 399.0;
  }
  else
  {
    v56 = 243.0;
    v42 = 405.0;
  }
  if ( *(_BYTE *)(v1 + 31234) )
  {
    v43 = v42;
    sub_10003330(-16711936, -16777216, (int)"HI FIELD", a1, v56, v43, 7.0, 0.0);
    *(_DWORD *)(v1 + 31236) = 0;
    sub_10016450(41094, v1 + 31236, 4);
  }
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10004EF0) --------------------------------------------------------
int __thiscall sub_10004EF0(int this)
{
  int v1; // esi@1
  int v2; // edi@1
  char v3; // bl@1
  double v4; // st7@2
  float v5; // ST18_4@4
  double v6; // st6@5
  double v7; // st7@8
  double v8; // st6@11
  double v9; // st6@16
  char v10; // al@28
  double v11; // st7@41
  double v12; // st7@48
  char *v13; // eax@53
  double v14; // st7@71
  float v15; // ST3C_4@72
  float v16; // ST1C_4@72
  float v17; // ST3C_4@72
  float v18; // ST3C_4@72
  float v19; // ST1C_4@72
  float v20; // ST3C_4@72
  float v21; // ST3C_4@72
  float v22; // ST1C_4@72
  float v23; // ST3C_4@72
  float v24; // ST3C_4@72
  float v25; // ST1C_4@72
  float v26; // ST3C_4@72
  int v27; // ST18_4@72
  float v28; // ST3C_4@72
  float v29; // ST1C_4@72
  float v30; // ST3C_4@72
  float v31; // ST3C_4@72
  float v32; // ST1C_4@72
  float v33; // ST3C_4@72
  float v34; // ST3C_4@72
  float v35; // ST1C_4@72
  float v36; // ST3C_4@72
  float v37; // ST3C_4@72
  float v38; // ST3C_4@72
  double v39; // st7@72
  float v40; // ST3C_4@73
  float v41; // ST1C_4@73
  float v42; // ST3C_4@73
  float v43; // ST3C_4@73
  float v44; // ST1C_4@73
  float v45; // ST3C_4@73
  float v46; // ST3C_4@73
  float v47; // ST1C_4@73
  float v48; // ST3C_4@73
  float v49; // ST3C_4@73
  float v50; // ST1C_4@73
  float v51; // ST3C_4@73
  int v52; // ST18_4@73
  float v53; // ST3C_4@73
  float v54; // ST1C_4@73
  float v55; // ST3C_4@73
  float v56; // ST3C_4@73
  float v57; // ST1C_4@73
  float v58; // ST3C_4@73
  float v59; // ST3C_4@73
  float v60; // ST1C_4@73
  float v61; // ST3C_4@73
  float v62; // ST3C_4@73
  float v63; // ST3C_4@73
  float v64; // ST18_4@74
  char *v66; // [sp+0h] [bp-8Ch]@19
  const char *v67; // [sp+4h] [bp-88h]@19
  float v68; // [sp+8h] [bp-84h]@2
  float *v69; // [sp+8h] [bp-84h]@53
  float v70; // [sp+8h] [bp-84h]@72
  int v71; // [sp+Ch] [bp-80h]@0
  float v72; // [sp+2Ch] [bp-60h]@7
  float v73; // [sp+30h] [bp-5Ch]@7
  int v74; // [sp+34h] [bp-58h]@1
  float v75; // [sp+38h] [bp-54h]@1
  int v76; // [sp+3Ch] [bp-50h]@1
  int v77; // [sp+40h] [bp-4Ch]@1
  float v78; // [sp+44h] [bp-48h]@1
  float v79; // [sp+48h] [bp-44h]@1
  float v80; // [sp+4Ch] [bp-40h]@1
  int v81; // [sp+50h] [bp-3Ch]@55
  int v82; // [sp+54h] [bp-38h]@56
  int v83; // [sp+58h] [bp-34h]@57
  int v84; // [sp+5Ch] [bp-30h]@58
  float v85; // [sp+60h] [bp-2Ch]@40
  float v86; // [sp+64h] [bp-28h]@46
  float v87; // [sp+68h] [bp-24h]@40
  float v88; // [sp+6Ch] [bp-20h]@40
  float v89; // [sp+70h] [bp-1Ch]@40
  float v90; // [sp+74h] [bp-18h]@40
  float v91; // [sp+78h] [bp-14h]@41
  int v92; // [sp+7Ch] [bp-10h]@41
  char v93; // [sp+80h] [bp-Ch]@8

  v1 = this;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 56) + 12);
  v78 = 0.5;
  v76 = -16777216;
  v79 = 1.0;
  v77 = -1;
  v74 = 1;
  v80 = 0.0;
  v75 = 9.0;
  v3 = *(_BYTE *)(v2 + 31993);
  if ( *(_BYTE *)(v2 + 52873) )
  {
    sub_10002C40(v3, v2, 75.0, 514.0);
    sub_10002C40(*(_BYTE *)(v2 + 31992), v2, 25.0, 529.0);
    v68 = 529.0;
    v4 = 125.0;
  }
  else
  {
    sub_10002C40(v3, v2, 68.0, 552.0);
    sub_10002C40(*(_BYTE *)(v2 + 31992), v2, 34.0, 583.0);
    v68 = 583.0;
    v4 = 102.0;
  }
  v5 = v4;
  sub_10002C40(*(_BYTE *)(v2 + 31994), v2, v5, v68);
  v79 = 0.0;
  v77 = -16711681;
  if ( *(_BYTE *)(v2 + 52873) )
    v6 = 4.0;
  else
    v6 = 5.0;
  v72 = v6;
  v73 = 2.0;
  if ( 9.8999998e24 == *(float *)(v2 + 12048) )
  {
    v7 = 2.0;
  }
  else
  {
    v78 = 0.0;
    sub_10038570(&v93, 8u, "%.1f", *(float *)(v2 + 12048) * 100.0);
    sub_100393A0(v1, (int)&v93, (int)&v72);
    v7 = 2.0;
  }
  if ( *(_BYTE *)(v2 + 52873) )
    v8 = 146.0;
  else
    v8 = 273.0;
  v72 = v8;
  v73 = v7;
  if ( 9.8999998e24 != *(float *)(v2 + 12052) )
  {
    v78 = 1.0;
    sub_10038570(&v93, 8u, "%.1f", *(float *)(v2 + 12052) * 100.0);
    sub_100393A0(v1, (int)&v93, (int)&v72);
    v7 = 2.0;
  }
  v77 = -16711681;
  v78 = 0.5;
  if ( *(_BYTE *)(v2 + 52873) )
    v9 = 75.0;
  else
    v9 = 139.0;
  v72 = v9;
  v73 = v7;
  switch ( *(_BYTE *)(v2 + 12062) )
  {
    case 0:
    case 1:
    case 2:
      v67 = "GA";
      v66 = &v93;
      break;
    case 3:
      v67 = "GA-RSV";
      goto LABEL_27;
    case 8:
      v67 = "CON";
      v66 = &v93;
      break;
    case 9:
      v67 = "CLB";
      v66 = &v93;
      break;
    case 0xA:
      v67 = "CRZ";
      goto LABEL_27;
    case 7:
      v67 = "TO-RSV";
      v66 = &v93;
      break;
    case 4:
    case 5:
    case 6:
      v67 = (const char *)&unk_10089748;
      v66 = &v93;
      break;
    default:
      v67 = byte_100879F8;
LABEL_27:
      v66 = &v93;
      break;
  }
  sub_10038450((int)v66, v67, 8);
  sub_100393A0(v1, (int)&v93, (int)&v72);
  v73 = v73 + v75 + 4.0;
  sub_10038450((int)&v93, &unk_10089744, 8);
  v10 = *(_BYTE *)(v2 + 12062);
  if ( v10 == 5 || v10 == 1 )
  {
    v77 = -1;
    sub_100393A0(v1, (int)&v93, (int)&v72);
  }
  else if ( v10 == 6 || v10 == 2 )
  {
    v77 = -16711936;
    sub_100393A0(v1, (int)&v93, (int)&v72);
  }
  if ( *(_BYTE *)(v2 + 52873) )
  {
    sub_10003170(*(_DWORD *)(v2 + 23264), v1, *(_DWORD *)(v2 + 23260), 12.0, 188.0);
    sub_10003170(*(_DWORD *)(v2 + 23272), v1, *(_DWORD *)(v2 + 23268), 134.0, 188.0);
  }
  else
  {
    sub_10003170(*(_DWORD *)(v2 + 23264), v1, *(_DWORD *)(v2 + 23260), 11.0, 202.0);
    sub_10003170(*(_DWORD *)(v2 + 23272), v1, *(_DWORD *)(v2 + 23268), 261.0, 202.0);
  }
  if ( 9.8999998e24 != *(float *)(v2 + 384) && (0.0 != *(float *)(v2 + 384) || *(_BYTE *)(v2 + 31232)) )
  {
    v87 = 13.0;
    v90 = 9.0;
    v88 = 0.55000001;
    v89 = 0.55000001;
    v85 = *(float *)(v2 + 29676) + 29.0;
    if ( *(_BYTE *)(v2 + 31232) )
    {
      v91 = 270.0;
      v11 = *(float *)(v2 + 29680);
      v92 = -65536;
    }
    else
    {
      if ( *(float *)(v2 + 384) <= 0.0 )
      {
        v91 = 90.0;
        v11 = *(float *)(v2 + 29680) - 13.0;
      }
      else
      {
        v91 = 270.0;
        v11 = *(float *)(v2 + 29680);
      }
      v92 = -16711936;
    }
    v86 = v11 + 1.0;
    sub_100395F0((int)&v85);
  }
  v77 = -1;
  v78 = 0.5;
  v79 = 1.0;
  if ( *(_BYTE *)(v2 + 52873) )
  {
    v72 = 29.0;
    v12 = 554.0;
  }
  else
  {
    v72 = 68.0;
    v12 = 464.0;
  }
  v73 = v12;
  if ( *(_BYTE *)dword_102D2B4C == 38 || *(_BYTE *)dword_102D2B4C == 31 && *(_BYTE *)(v2 + 52904) & 1 )
  {
    v69 = &v72;
    v13 = sub_10040510(0x17C4u);
  }
  else
  {
    v69 = &v72;
    v13 = sub_10040510(0x17B4u);
  }
  sub_100393A0(v1, (int)v13, (int)v69);
  if ( !sub_100403B0(0, &v81) )
  {
    v81 = 0;
    v82 = 0;
  }
  if ( !sub_100403B0(1, &v83) )
  {
    v83 = 0;
    v84 = 0;
  }
  if ( BYTE3(v81) == 1 || BYTE3(v83) == 1 )
    sub_100032B0(*(float *)(v2 + 32132), *(float *)(v2 + 32136), 0);
  if ( BYTE3(v81) == 2 || BYTE3(v83) == 2 )
    sub_100032B0(*(float *)(v2 + 32132), *(float *)(v2 + 32136), 1);
  if ( (_BYTE)v82 == 1 || (_BYTE)v84 == 1 )
    sub_100032B0(*(float *)(v2 + 37692), *(float *)(v2 + 37696), 0);
  if ( (_BYTE)v82 == 2 || (_BYTE)v84 == 2 )
    sub_100032B0(*(float *)(v2 + 37692), *(float *)(v2 + 37696), 1);
  sub_10015770(1.0);
  j_gdi_pvg_begin(72);
  j_gdi_pvg_color_u32(*(_DWORD *)(v2 + 46648));
  v14 = *(float *)(v2 + 46692) - 3.0;
  if ( *(_BYTE *)dword_102D2B4C == 31 )
  {
    v15 = v14;
    v16 = v15;
    v17 = *(float *)(v2 + 46688) + 4.0;
    sub_10015960(v17, v16);
    v18 = *(float *)(v2 + 46692) - 3.0;
    v19 = v18;
    v20 = *(float *)(v2 + 46688) - *(float *)(v2 + 46620) - 4.0;
    sub_10015960(v20, v19);
    v21 = *(float *)(v2 + 46624) + *(float *)(v2 + 46692) + 3.0;
    v22 = v21;
    v23 = *(float *)(v2 + 46688) - *(float *)(v2 + 46620) - 4.0;
    sub_10015960(v23, v22);
    v24 = *(float *)(v2 + 46624) + *(float *)(v2 + 46692) + 3.0;
    v25 = v24;
    v26 = *(float *)(v2 + 46688) + 4.0;
    sub_10015960(v26, v25);
    j_gdi_pvg_end(v27);
    j_gdi_pvg_begin(66);
    j_gdi_pvg_color_u32(-1);
    v28 = *(float *)(v2 + 46692) - 3.0;
    v29 = v28;
    v30 = *(float *)(v2 + 46688) + 4.0;
    sub_10015960(v30, v29);
    v31 = *(float *)(v2 + 46692) - 3.0;
    v32 = v31;
    v33 = *(float *)(v2 + 46688) - *(float *)(v2 + 46620) - 4.0;
    sub_10015960(v33, v32);
    v34 = *(float *)(v2 + 46624) + *(float *)(v2 + 46692) + 3.0;
    v35 = v34;
    v36 = *(float *)(v2 + 46688) - *(float *)(v2 + 46620) - 4.0;
    sub_10015960(v36, v35);
    v37 = *(float *)(v2 + 46624) + *(float *)(v2 + 46692) + 3.0;
    v70 = v37;
    v38 = *(float *)(v2 + 46688) + 4.0;
    v39 = v38;
  }
  else
  {
    v40 = v14;
    v41 = v40;
    v42 = *(float *)(v2 + 46688) + 4.0;
    sub_10015960(v42, v41);
    v43 = *(float *)(v2 + 46692) - 3.0;
    v44 = v43;
    v45 = *(float *)(v2 + 46688) - *(float *)(v2 + 46620) - 4.0 - 3.0;
    sub_10015960(v45, v44);
    v46 = *(float *)(v2 + 46624) + *(float *)(v2 + 46692) + 3.0;
    v47 = v46;
    v48 = *(float *)(v2 + 46688) - *(float *)(v2 + 46620) - 4.0 - 3.0;
    sub_10015960(v48, v47);
    v49 = *(float *)(v2 + 46624) + *(float *)(v2 + 46692) + 3.0;
    v50 = v49;
    v51 = *(float *)(v2 + 46688) + 4.0;
    sub_10015960(v51, v50);
    j_gdi_pvg_end(v52);
    j_gdi_pvg_begin(66);
    j_gdi_pvg_color_u32(-1);
    v53 = *(float *)(v2 + 46692) - 3.0;
    v54 = v53;
    v55 = *(float *)(v2 + 46688) + 4.0;
    sub_10015960(v55, v54);
    v56 = *(float *)(v2 + 46692) - 3.0;
    v57 = v56;
    v58 = *(float *)(v2 + 46688) - *(float *)(v2 + 46620) - 4.0 - 3.0;
    sub_10015960(v58, v57);
    v59 = *(float *)(v2 + 46624) + *(float *)(v2 + 46692) + 3.0;
    v60 = v59;
    v61 = *(float *)(v2 + 46688) - *(float *)(v2 + 46620) - 4.0 - 3.0;
    sub_10015960(v61, v60);
    v62 = *(float *)(v2 + 46624) + *(float *)(v2 + 46692) + 3.0;
    v70 = v62;
    v63 = *(float *)(v2 + 46688) + 4.0;
    v39 = v63;
  }
  v64 = v39;
  sub_10015960(v64, v70);
  return j_gdi_pvg_end(v71);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10005970) --------------------------------------------------------
int __usercall sub_10005970@<eax>(int edi0@<edi>, int a1)
{
  int v2; // edi@1
  char v3; // al@3
  bool v4; // bl@5
  unsigned int v5; // esi@10
  _DWORD *v6; // eax@13
  float v7; // ST1C_4@13
  signed int v8; // esi@14
  float *v9; // ebp@15
  signed int v10; // eax@18
  char v11; // bl@26
  bool v12; // zf@26
  char v13; // cl@35
  unsigned int v14; // eax@92
  int *v15; // ecx@92
  char *v16; // edx@92
  int v17; // esi@96
  int v18; // eax@97
  _BYTE *v19; // ecx@97
  _BYTE *v20; // edx@97
  int v21; // eax@99
  _BYTE *v22; // ecx@99
  _BYTE *v23; // edx@99
  _BYTE *v24; // ecx@101
  _BYTE *v25; // edx@101
  signed int v26; // eax@103
  double v27; // st7@109
  int v28; // edi@111
  float v29; // ST1C_4@112
  float v30; // ST18_4@112
  float v31; // ST14_4@112
  int v33; // [sp+14h] [bp-74h]@1
  int v34; // [sp+14h] [bp-74h]@111
  char v35; // [sp+27h] [bp-61h]@2
  int v36; // [sp+28h] [bp-60h]@1
  char v37; // [sp+2Dh] [bp-5Bh]@3
  bool v38; // [sp+2Eh] [bp-5Ah]@5
  char v39; // [sp+2Fh] [bp-59h]@10
  float v40; // [sp+30h] [bp-58h]@1
  float v41; // [sp+34h] [bp-54h]@18
  char v42; // [sp+3Ah] [bp-4Eh]@1
  char v43; // [sp+3Bh] [bp-4Dh]@3
  int v44; // [sp+3Ch] [bp-4Ch]@26
  float v45; // [sp+40h] [bp-48h]@109
  float v46; // [sp+44h] [bp-44h]@111
  float v47; // [sp+48h] [bp-40h]@111
  float v48; // [sp+4Ch] [bp-3Ch]@111
  float v49; // [sp+50h] [bp-38h]@111
  int v50; // [sp+54h] [bp-34h]@1
  char v51; // [sp+58h] [bp-30h]@91
  double v52; // [sp+5Ch] [bp-2Ch]@111
  double v53; // [sp+64h] [bp-24h]@111
  double v54; // [sp+6Ch] [bp-1Ch]@111
  double v55; // [sp+74h] [bp-14h]@111
  char v56; // [sp+7Ch] [bp-Ch]@32

  v40 = 13.0;
  v33 = edi0;
  v50 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v36 = 0;
  if ( !sub_1003F220(0, 53, 0, 1, &v42)
    || !sub_1003F220(0, 54, 0, 1, &v35)
    || (v3 = sub_1003F220(0, 55, 0, 1, &v43), v37 = 1, !v3) )
  {
    v37 = 0;
  }
  v4 = (v42 & 8) == 8;
  v38 = (v42 & 0x10) == 16;
  if ( v37 && (v42 & 8) != 8 && (*(float *)(v2 + 488) >= -1.0 && *(float *)(v2 + 488) <= 1.0 || (v42 & 0x10) == 16) )
  {
    v39 = 1;
    v5 = 57;
  }
  else
  {
    v39 = 0;
    v5 = 58;
  }
  if ( !*(_BYTE *)(v2 + 52873) )
  {
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_enable(34);
    j_gdi_pvg_color_u32(-1);
    v6 = (_DWORD *)sub_100165A0(v5);
    j_gdi_pvg_bind_texture(34, *v6);
    j_gdi_pvg_begin(72);
    sub_10015890(0.0, 0.0);
    sub_10015960(143.0, 552.0);
    sub_10015890(0.0, 1.0);
    sub_10015960(143.0, 536.0);
    sub_10015890(1.0, 1.0);
    sub_10015960(261.0, 536.0);
    sub_10015890(1.0, 0.0);
    sub_10015960(261.0, 552.0);
    j_gdi_pvg_end(LODWORD(v7));
    j_gdi_pvg_disable(34);
    j_gdi_pvg_disable(35);
  }
  v8 = -16777216;
  if ( !v37 || (v9 = (float *)(v2 + 488), *(float *)(v2 + 488) < -5.0) || *v9 > 40.889999 )
  {
    v9 = (float *)(v2 + 488);
    *(float *)(v2 + 488) = 9.8999998e24;
    v10 = -65536;
    v41 = -1.7014118e38;
    goto LABEL_25;
  }
  if ( !v4 )
  {
    if ( sub_1003E540((int)"A: NO TO FLAP") )
    {
      v10 = -65536;
      v41 = -6.7790628e38/*NaN*/;
      v8 = -1;
      goto LABEL_26;
    }
    if ( v38 )
    {
      v10 = -1;
      v8 = -16777216;
      v41 = -6.8056469e38/*NaN*/;
      goto LABEL_26;
    }
    v10 = -16711936;
    v41 = -1.7014118e38;
LABEL_25:
    v8 = v10;
    goto LABEL_26;
  }
  v10 = -256;
  v41 = -6.8055435e38/*NaN*/;
LABEL_26:
  v11 = v39;
  v12 = v39 == 0;
  v44 = v8;
  *(_BYTE *)(v2 + 49577) = 2;
  *(_BYTE *)(v2 + 49579) = 0;
  *(_BYTE *)(v2 + 49580) = 0;
  *(_BYTE *)(v2 + 49582) = 2;
  if ( !v12 && !*(_BYTE *)(v2 + 52873) )
  {
    *(_BYTE *)(v2 + 49577) = 1;
    *(_BYTE *)(v2 + 49579) = 1;
    *(_BYTE *)(v2 + 49580) = 1;
    *(_BYTE *)(v2 + 49582) = 1;
  }
  *(_DWORD *)(v2 + 49296) = v10;
  *(_DWORD *)(v2 + 47280) = v9;
  if ( v10 == -16777216 || !v37 )
    *(_DWORD *)(v2 + 47280) = &unk_10087FF4;
  *(_DWORD *)(v2 + 47284) = &unk_10087FF4;
  sub_10038450((int)&v56, byte_100879F8, 5);
  if ( v37 )
  {
    if ( v43 & 8 || v38 )
      goto LABEL_38;
    v13 = v35;
    if ( v35 & 0x10 && !(v35 & 0xF) )
    {
      *(_DWORD *)(v2 + 47284) = &unk_10088014;
      BYTE1(v36) = 4;
LABEL_38:
      v13 = v35;
      goto LABEL_39;
    }
    if ( !(v35 & 0x10) )
    {
      if ( v35 & 8 && !(v35 & 7) )
      {
        *(_DWORD *)(v2 + 47284) = &unk_10088010;
        BYTE1(v36) = 3;
        goto LABEL_38;
      }
      if ( !(v35 & 8) && v35 & 4 && !(v35 & 3) )
      {
        *(_DWORD *)(v2 + 47284) = &unk_1008800C;
        BYTE1(v36) = 2;
        goto LABEL_38;
      }
      if ( !(v35 & 0xC) && v35 & 2 && !(v35 & 1) )
      {
        *(_DWORD *)(v2 + 47284) = &unk_10088008;
        BYTE1(v36) = 1;
        goto LABEL_38;
      }
      if ( !(v35 & 0xE) && v35 & 1 )
      {
        if ( !v11 )
        {
          *(_DWORD *)(v2 + 47284) = &unk_10088004;
          v13 = v35;
        }
        BYTE1(v36) = 0;
        goto LABEL_39;
      }
    }
    BYTE1(v36) = 5;
LABEL_39:
    if ( *v9 >= 5.0 )
    {
      if ( *v9 >= 18.0 )
      {
        if ( *v9 < 31.0 && v13 & 4 )
        {
          sub_10038450((int)&v56, &unk_100897DC, 5);
          LOBYTE(v36) = 2;
          BYTE2(v36) = 2;
        }
        else if ( *v9 < 31.0 && v13 & 8 )
        {
          sub_10038450((int)&v56, &unk_100897D8, 5);
          LOBYTE(v36) = 3;
          BYTE2(v36) = 3;
        }
        else if ( *v9 < 31.0 || *v9 >= 40.889999 )
        {
          sub_10038450((int)&v56, "--", 5);
          LOBYTE(v36) = 5;
          BYTE2(v36) = 5;
        }
        else
        {
          sub_10038450((int)&v56, "FULL", 5);
          v40 = 9.0;
          LOBYTE(v36) = 4;
          BYTE2(v36) = 4;
        }
      }
      else
      {
        sub_10038450((int)&v56, &unk_100897E8, 5);
        LOBYTE(v36) = 1;
        BYTE2(v36) = 1;
      }
    }
    else
    {
      sub_10038450((int)&v56, &word_100897F0, 5);
      LOBYTE(v36) = 0;
      BYTE2(v36) = 0;
    }
    if ( v8 == -16711936 )
    {
      if ( *v9 <= 1.0 && v35 & 1 )
      {
        sub_10038450((int)&v56, &word_100897F0, 5);
        LOBYTE(v36) = 0;
      }
      else if ( *v9 >= 9.0 && *v9 <= 11.0 && v35 & 2 )
      {
        sub_10038450((int)&v56, &unk_100897E8, 5);
        LOBYTE(v36) = 1;
      }
      else if ( *v9 >= 25.0 && *v9 <= 27.0 && v35 & 4 )
      {
        sub_10038450((int)&v56, &unk_100897DC, 5);
        LOBYTE(v36) = 2;
      }
      else if ( *v9 >= 25.0 && *v9 <= 27.0 && v35 & 8 )
      {
        sub_10038450((int)&v56, &unk_100897D8, 5);
        LOBYTE(v36) = 3;
      }
      else if ( *v9 >= 35.0 && v35 & 0x10 )
      {
        sub_10038450((int)&v56, "FULL", 5);
        v40 = 9.0;
        LOBYTE(v36) = 4;
        *v9 = 40.0;
      }
      else
      {
        sub_10038450((int)&v56, "--", 5);
        LOBYTE(v36) = 5;
      }
    }
  }
  if ( sub_10016380(9150, (int)&v51, 4) )
  {
LABEL_107:
    sub_10016450(9150, (int)&v36, 4);
    goto LABEL_108;
  }
  v14 = 4;
  v15 = &v36;
  v16 = &v51;
  do
  {
    if ( *(_DWORD *)v16 != *v15 )
      goto LABEL_96;
    v14 -= 4;
    ++v15;
    v16 += 4;
  }
  while ( v14 >= 4 );
  if ( !v14 )
  {
LABEL_105:
    v26 = 0;
    goto LABEL_106;
  }
LABEL_96:
  v17 = (unsigned __int8)*v16 - *(_BYTE *)v15;
  if ( (unsigned __int8)*v16 == *(_BYTE *)v15 )
  {
    v18 = v14 - 1;
    v19 = (char *)v15 + 1;
    v20 = v16 + 1;
    if ( !v18 )
      goto LABEL_105;
    v17 = *v20 - *v19;
    if ( *v20 == *v19 )
    {
      v21 = v18 - 1;
      v22 = v19 + 1;
      v23 = v20 + 1;
      if ( !v21 )
        goto LABEL_105;
      v17 = *v23 - *v22;
      if ( *v23 == *v22 )
      {
        v24 = v22 + 1;
        v25 = v23 + 1;
        if ( v21 == 1 )
          goto LABEL_105;
        v17 = *v25 - *v24;
        if ( *v25 == *v24 )
          goto LABEL_105;
      }
    }
  }
  v26 = 1;
  if ( v17 <= 0 )
    v26 = -1;
LABEL_106:
  if ( v26 )
    goto LABEL_107;
LABEL_108:
  if ( *(_BYTE *)(v2 + 52873) )
  {
    v45 = 83.0;
    v27 = 581.0;
  }
  else
  {
    v45 = 179.0;
    v27 = 577.0;
  }
  v49 = v27;
  sub_10015770(1.0);
  j_gdi_pvg_begin(72);
  v28 = LODWORD(v41);
  j_gdi_pvg_color_u32(LODWORD(v41));
  v54 = v49 + 10.0 + 1.0;
  v41 = v54;
  v55 = v45 - 18.0;
  v47 = v55;
  sub_10015960(v47, v41);
  v53 = v45 + 18.0;
  v48 = v53;
  sub_10015960(v48, v41);
  v52 = v49 - 10.0 + 1.0;
  v46 = v52;
  sub_10015960(v48, v46);
  sub_10015960(v47, v46);
  j_gdi_pvg_end(v33);
  if ( 9.8999998e24 == *v9 )
  {
    v40 = v52;
    v29 = v40;
    v40 = v53;
    v30 = v40;
    v40 = v54;
    v31 = v40;
    v40 = v55;
    sub_10038FD0(v40, v31, v30, v29, 0);
  }
  else
  {
    sub_10003330(v44, v28, (int)&v56, v50, v45, v49, v40, 0.0);
  }
  j_gdi_pvg_begin(66);
  j_gdi_pvg_color_u32(-1);
  sub_10015960(v47, v41);
  sub_10015960(v48, v41);
  sub_10015960(v48, v46);
  sub_10015960(v47, v46);
  return j_gdi_pvg_end(v34);
}
// 10005970: could not find valid save-restore pair for edi
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 100897F0: using guessed type __int16 word_100897F0;

//----- (100062A0) --------------------------------------------------------
int __usercall sub_100062A0@<eax>(int edi0@<edi>, int a1)
{
  int v2; // edi@1
  char v3; // bl@3
  char v4; // cl@5
  bool v5; // bl@20
  char v6; // dl@24
  unsigned int v7; // esi@29
  _DWORD *v8; // eax@32
  float v9; // ST1C_4@32
  float *v10; // esi@35
  int v11; // ebp@35
  signed int v12; // eax@39
  char v13; // cl@65
  bool v14; // zf@65
  double v15; // st7@108
  double v16; // st7@110
  unsigned int v17; // eax@114
  int *v18; // ecx@114
  char *v19; // edx@114
  int v20; // esi@118
  int v21; // eax@119
  _BYTE *v22; // ecx@119
  _BYTE *v23; // edx@119
  int v24; // eax@121
  _BYTE *v25; // ecx@121
  _BYTE *v26; // edx@121
  _BYTE *v27; // ecx@123
  _BYTE *v28; // edx@123
  signed int v29; // eax@125
  double v30; // st7@131
  float v31; // ST1C_4@134
  float v32; // ST18_4@134
  float v33; // ST14_4@134
  float v34; // ST1C_4@134
  float v35; // ST18_4@134
  float v36; // ST14_4@134
  int v38; // [sp+14h] [bp-74h]@1
  char v39; // [sp+26h] [bp-62h]@5
  char v40; // [sp+26h] [bp-62h]@29
  char v41; // [sp+27h] [bp-61h]@10
  char v42; // [sp+28h] [bp-60h]@13
  char v43; // [sp+29h] [bp-5Fh]@16
  char v44; // [sp+2Ah] [bp-5Eh]@10
  unsigned __int8 v45; // [sp+2Bh] [bp-5Dh]@3
  int v46; // [sp+2Ch] [bp-5Ch]@1
  float v47; // [sp+30h] [bp-58h]@1
  float v48; // [sp+34h] [bp-54h]@108
  float v49; // [sp+38h] [bp-50h]@135
  char v50; // [sp+3Eh] [bp-4Ah]@1
  char v51; // [sp+3Fh] [bp-49h]@1
  float v52; // [sp+40h] [bp-48h]@108
  float v53; // [sp+44h] [bp-44h]@133
  float v54; // [sp+48h] [bp-40h]@131
  int v55; // [sp+4Ch] [bp-3Ch]@43
  int v56; // [sp+50h] [bp-38h]@5
  double v57; // [sp+54h] [bp-34h]@77
  int v58; // [sp+5Ch] [bp-2Ch]@1
  char v59; // [sp+60h] [bp-28h]@113
  double v60; // [sp+64h] [bp-24h]@134
  double v61; // [sp+6Ch] [bp-1Ch]@134
  double v62; // [sp+74h] [bp-14h]@134
  char v63; // [sp+7Ch] [bp-Ch]@78

  v47 = 13.0;
  v38 = edi0;
  v58 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v50 = 1;
  v46 = 0;
  if ( !sub_1003F220(6, 148, 0, 1, &v51) || !v51 )
  {
    v3 = 0;
    goto LABEL_4;
  }
  v3 = 1;
  if ( !sub_1003F220(6, 150, 0, 1, &v45) )
  {
LABEL_4:
    v50 = 0;
    v45 = 5;
  }
  v4 = sub_1003F220(6, 161, 0, 4, &v56);
  v39 = v4;
  if ( !v3 || 9.8999998e24 == *(float *)(v2 + 488) || !v4 || v56 & 0x10000 || sub_1003E540((int)"_fc_miscmp") )
  {
    v41 = 0;
    goto LABEL_11;
  }
  v41 = 1;
  v44 = 1;
  if ( *(float *)(v2 + 488) >= 0.5 )
LABEL_11:
    v44 = 0;
  if ( !v39 || (v42 = 1, !(v56 & 0x800)) )
    v42 = 0;
  if ( !v39 || (v43 = 1, !(v56 & 0x400)) )
    v43 = 0;
  v5 = sub_1003E540((int)"_takeoff") && sub_1003E540((int)"_flpout_to_cfg");
  v6 = v44;
  if ( v41 && v44 && !v5 && (!v43 || v42) )
  {
    v40 = 1;
    v7 = 57;
  }
  else
  {
    v40 = 0;
    v7 = 58;
  }
  if ( !*(_BYTE *)(v2 + 52873) )
  {
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_enable(34);
    j_gdi_pvg_color_u32(-1);
    v8 = (_DWORD *)sub_100165A0(v7);
    j_gdi_pvg_bind_texture(34, *v8);
    j_gdi_pvg_begin(72);
    sub_10015890(0.0, 0.0);
    sub_10015960(143.0, 552.0);
    sub_10015890(0.0, 1.0);
    sub_10015960(143.0, 536.0);
    sub_10015890(1.0, 1.0);
    sub_10015960(261.0, 536.0);
    sub_10015890(1.0, 0.0);
    sub_10015960(261.0, 552.0);
    j_gdi_pvg_end(LODWORD(v9));
    j_gdi_pvg_disable(34);
    j_gdi_pvg_disable(35);
    v6 = v44;
  }
  *(_BYTE *)(v2 + 49577) = 2;
  *(_BYTE *)(v2 + 49579) = 0;
  *(_BYTE *)(v2 + 49580) = 0;
  *(_BYTE *)(v2 + 49582) = 2;
  if ( v40 )
  {
    *(_BYTE *)(v2 + 49579) = 1;
    *(_BYTE *)(v2 + 49580) = 1;
  }
  v10 = (float *)(v2 + 488);
  *(_DWORD *)(v2 + 47280) = v2 + 488;
  *(_DWORD *)(v2 + 47284) = &unk_10087FF4;
  v11 = -16777216;
  if ( !v6 && !v43 && !v5 && v41 )
  {
    v12 = -16711936;
    goto LABEL_40;
  }
  if ( v42 && v6 || !v43 )
  {
    if ( !v5 )
      goto LABEL_53;
  }
  else if ( !v5 )
  {
    if ( v41 )
    {
      v12 = -256;
      goto LABEL_57;
    }
    goto LABEL_53;
  }
  if ( v41 )
  {
    v12 = -65536;
    goto LABEL_57;
  }
LABEL_53:
  if ( v40 && *(_BYTE *)(v2 + 52873) )
  {
    v12 = -1;
  }
  else
  {
    v12 = -16777216;
    *(_BYTE *)(v2 + 49577) = 1;
    *(_DWORD *)(v2 + 47280) = &unk_10087FF4;
  }
LABEL_57:
  if ( v43 )
  {
    if ( !v42 || !v6 )
    {
      if ( !v5 )
      {
        v55 = -16777216;
        v11 = -256;
        goto LABEL_65;
      }
LABEL_63:
      v55 = -1;
      v11 = -65536;
      goto LABEL_65;
    }
LABEL_62:
    if ( !v5 )
    {
      v55 = -16777216;
      v11 = -16711681;
      goto LABEL_65;
    }
    goto LABEL_63;
  }
LABEL_40:
  if ( v42 && v6 )
    goto LABEL_62;
  if ( v5 )
    goto LABEL_63;
  v55 = -16711936;
LABEL_65:
  v13 = v50;
  v14 = v50 == 0;
  *(_DWORD *)(v2 + 49296) = v12;
  if ( !v14 )
  {
    BYTE1(v46) = v45;
    if ( !v40 )
    {
      if ( v45 )
      {
        switch ( v45 )
        {
          case 1u:
            *(_DWORD *)(v2 + 47284) = &unk_100894C0;
            break;
          case 2u:
            *(_DWORD *)(v2 + 47284) = &unk_100894C4;
            break;
          case 3u:
            *(_DWORD *)(v2 + 47284) = &unk_100894C4;
            break;
          case 4u:
            *(_DWORD *)(v2 + 47284) = &unk_100894C8;
            break;
        }
      }
      else
      {
        *(_DWORD *)(v2 + 47284) = &unk_10089464;
      }
    }
  }
  v57 = 0.0 + 1.0;
  if ( *v10 >= v57 )
  {
    if ( *v10 >= 9.0 )
    {
      if ( *v10 >= 27.0 )
      {
        sub_10038450((int)&v63, "FULL", 5);
        v47 = 9.0;
        LOBYTE(v46) = 4;
        BYTE2(v46) = 4;
      }
      else if ( v13 && v45 <= 2u )
      {
        sub_10038450((int)&v63, &unk_100897DC, 5);
        LOBYTE(v46) = 2;
        BYTE2(v46) = 2;
      }
      else
      {
        sub_10038450((int)&v63, &unk_100897D8, 5);
        LOBYTE(v46) = 3;
        BYTE2(v46) = 3;
      }
    }
    else
    {
      sub_10038450((int)&v63, &unk_100897E8, 5);
      LOBYTE(v46) = 1;
      BYTE2(v46) = 1;
    }
  }
  else
  {
    sub_10038450((int)&v63, &word_100897F0, 5);
    LOBYTE(v46) = 0;
    BYTE2(v46) = 0;
  }
  if ( v11 != -256 )
  {
    if ( *v10 >= -0.800000011920929 && *v10 < v57 && !v45 )
    {
      sub_10038450((int)&v63, &word_100897F0, 5);
      LOBYTE(v46) = 0;
      goto LABEL_107;
    }
    if ( *v10 >= 7.0 && *v10 < 9.0 && v45 == 1 )
    {
      sub_10038450((int)&v63, &unk_100897E8, 5);
      LOBYTE(v46) = 1;
      goto LABEL_107;
    }
    if ( *v10 >= 25.0 && *v10 < 27.0 )
    {
      if ( v45 == 2 )
      {
        sub_10038450((int)&v63, &unk_100897DC, 5);
        LOBYTE(v46) = 2;
        goto LABEL_107;
      }
      if ( v45 == 3 )
      {
        sub_10038450((int)&v63, &unk_100897D8, 5);
        LOBYTE(v46) = 3;
        goto LABEL_107;
      }
    }
    if ( *v10 < 34.0 || *v10 >= 36.0 || v45 != 4 )
    {
      sub_10038450((int)&v63, "--", 5);
      LOBYTE(v46) = 5;
    }
    else
    {
      sub_10038450((int)&v63, "FULL", 5);
      v47 = 9.0;
      LOBYTE(v46) = 4;
    }
  }
LABEL_107:
  if ( 9.8999998e24 != *v10 )
  {
    v48 = *v10;
    v52 = *(float *)(v2 + 47448);
    v15 = v48;
    if ( v52 >= (double)v48 )
      v15 = v52;
    v48 = v15;
    v16 = v48;
    *v10 = v48;
    v48 = *(float *)(v2 + 47452);
    if ( v48 <= v16 )
      v16 = v48;
    v48 = v16;
    *v10 = v48;
  }
  if ( sub_10016380(9150, (int)&v59, 4) )
  {
LABEL_129:
    sub_10016450(9150, (int)&v46, 4);
    goto LABEL_130;
  }
  v17 = 4;
  v18 = &v46;
  v19 = &v59;
  do
  {
    if ( *(_DWORD *)v19 != *v18 )
      goto LABEL_118;
    v17 -= 4;
    ++v18;
    v19 += 4;
  }
  while ( v17 >= 4 );
  if ( !v17 )
  {
LABEL_127:
    v29 = 0;
    goto LABEL_128;
  }
LABEL_118:
  v20 = (unsigned __int8)*v19 - *(_BYTE *)v18;
  if ( (unsigned __int8)*v19 == *(_BYTE *)v18 )
  {
    v21 = v17 - 1;
    v22 = (char *)v18 + 1;
    v23 = v19 + 1;
    if ( !v21 )
      goto LABEL_127;
    v20 = *v23 - *v22;
    if ( *v23 == *v22 )
    {
      v24 = v21 - 1;
      v25 = v22 + 1;
      v26 = v23 + 1;
      if ( !v24 )
        goto LABEL_127;
      v20 = *v26 - *v25;
      if ( *v26 == *v25 )
      {
        v27 = v25 + 1;
        v28 = v26 + 1;
        if ( v24 == 1 )
          goto LABEL_127;
        v20 = *v28 - *v27;
        if ( *v28 == *v27 )
          goto LABEL_127;
      }
    }
  }
  v29 = 1;
  if ( v20 <= 0 )
    v29 = -1;
LABEL_128:
  if ( v29 )
    goto LABEL_129;
LABEL_130:
  if ( *(_BYTE *)(v2 + 52873) )
  {
    v54 = 83.0;
    v30 = 581.0;
  }
  else
  {
    v54 = 179.0;
    v30 = 577.0;
  }
  v53 = v30;
  sub_10015770(1.0);
  if ( v41 )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(v11);
    v62 = v53 + 10.0 + 1.0;
    v49 = v62;
    v60 = v54 - 18.0;
    v48 = v60;
    sub_10015960(v48, v49);
    v61 = v54 + 18.0;
    v52 = v61;
    sub_10015960(v52, v49);
    v57 = v53 - 10.0 + 1.0;
    v49 = v57;
    sub_10015960(v52, v49);
    sub_10015960(v48, v49);
    j_gdi_pvg_end(v38);
    sub_10003330(v55, v11, (int)&v63, v58, v54, v53, v47, 0.0);
  }
  else
  {
    v57 = v53 - 10.0 + 1.0;
    v61 = v54 + 18.0;
    v62 = v53 + 10.0 + 1.0;
    v60 = v54 - 18.0;
    v47 = v57;
    v31 = v47;
    v47 = v61;
    v32 = v47;
    v47 = v62;
    v33 = v47;
    v47 = v60;
    sub_10038FD0(v47, v33, v32, v31, 0);
    v47 = *(float *)(v2 + 47256) + 25.0;
    v34 = v47;
    v47 = *(float *)(v2 + 47260) * 0.5 + *(float *)(v2 + 47252);
    v35 = v47;
    v36 = *(float *)(v2 + 47256);
    v47 = *(float *)(v2 + 47252) - *(float *)(v2 + 47260);
    sub_10038FD0(v47, v36, v35, v34, 0);
  }
  j_gdi_pvg_begin(66);
  j_gdi_pvg_color_u32(-1);
  v49 = v62;
  v48 = v60;
  sub_10015960(v48, v49);
  v52 = v61;
  sub_10015960(v52, v49);
  v49 = v57;
  sub_10015960(v52, v49);
  sub_10015960(v48, v49);
  return j_gdi_pvg_end(v38);
}
// 100062A0: could not find valid save-restore pair for edi
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 100897F0: using guessed type __int16 word_100897F0;

//----- (10006CE0) --------------------------------------------------------
int __usercall sub_10006CE0@<eax>(int a1@<eax>)
{
  int v1; // ebp@1
  bool v2; // zf@1
  float *v3; // esi@1
  double v4; // st7@2
  char v5; // al@4
  float v6; // ST4C_4@7
  double v7; // st7@8
  float *v8; // esi@8
  char v9; // al@11
  float v10; // ST4C_4@14
  double v11; // st7@15
  float *v12; // esi@15
  double v13; // st7@18
  float *v14; // esi@18
  float *v15; // esi@39
  float *v16; // esi@42
  double v17; // st6@45
  float *v18; // esi@45
  double v19; // st7@48
  float *v20; // esi@48
  double v21; // st7@51
  float *v22; // esi@51
  double v23; // st7@54
  float *v24; // esi@54
  double v25; // st7@57
  float *v26; // esi@57
  double v27; // st7@60
  float *v28; // esi@60
  float v29; // ST4C_4@66
  double v30; // st7@74
  double v31; // st7@75
  double v32; // st7@76
  float v33; // ST4C_4@81
  double v34; // st7@86
  double v35; // st7@87
  float v36; // ST44_4@92
  int result; // eax@92
  float v38; // [sp+8h] [bp-28h]@69
  float v39; // [sp+Ch] [bp-24h]@15
  float v40; // [sp+Ch] [bp-24h]@18
  float v41; // [sp+Ch] [bp-24h]@42
  float v42; // [sp+Ch] [bp-24h]@45
  float v43; // [sp+Ch] [bp-24h]@66
  float v44; // [sp+Ch] [bp-24h]@69
  float v45; // [sp+10h] [bp-20h]@15
  float v46; // [sp+10h] [bp-20h]@18
  float v47; // [sp+10h] [bp-20h]@21
  float v48; // [sp+10h] [bp-20h]@24
  float v49; // [sp+10h] [bp-20h]@27
  float v50; // [sp+10h] [bp-20h]@30
  float v51; // [sp+10h] [bp-20h]@33
  float v52; // [sp+10h] [bp-20h]@36
  float v53; // [sp+10h] [bp-20h]@39
  float v54; // [sp+10h] [bp-20h]@42
  float v55; // [sp+10h] [bp-20h]@45
  float v56; // [sp+10h] [bp-20h]@48
  float v57; // [sp+10h] [bp-20h]@51
  float v58; // [sp+10h] [bp-20h]@54
  float v59; // [sp+10h] [bp-20h]@57
  float v60; // [sp+10h] [bp-20h]@60
  float v61; // [sp+10h] [bp-20h]@66
  float v62; // [sp+24h] [bp-Ch]@75
  float v63; // [sp+28h] [bp-8h]@75
  float v64; // [sp+28h] [bp-8h]@86

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  qmemcpy((void *)(v1 + 520), (const void *)(dword_102D2B4C + 3912), 0xA4u);
  v2 = *(_BYTE *)(v1 + 52873) == 0;
  qmemcpy((void *)(v1 + 684), (const void *)(dword_102D2B4C + 3912), 0xA4u);
  v3 = (float *)(v1 + 848);
  if ( v2 )
  {
    sub_100359F0(v1 + 848, (int)byte_100879F8, dword_102D2B4C + 3912, 23.0, 18.0, 90.0, 90.0);
    *(float *)(v1 + 1068) = 135.0;
    *(_BYTE *)(v1 + 2920) = 1;
    *(float *)(v1 + 1072) = 405.0;
    *(float *)(v1 + 3152) = 96.0;
    v4 = 18.0;
  }
  else
  {
    sub_100359F0(v1 + 848, (int)byte_100879F8, dword_102D2B4C + 3912, 4.0, 15.0, 110.0, 110.0);
    *(float *)(v1 + 1068) = 110.0;
    *(_DWORD *)(v1 + 2924) = 53;
    *(float *)(v1 + 1072) = 250.0;
    *(_BYTE *)(v1 + 3144) = 1;
    *(float *)(v1 + 3180) = 0.5;
    *(float *)(v1 + 3184) = 0.5;
    *(float *)(v1 + 3148) = *(float *)(v1 + 856) * 0.5 + *v3 - 12.0;
    *(float *)(v1 + 3152) = 70.0;
    v4 = 15.0;
  }
  *(float *)(v1 + 3188) = v4;
  *(float *)(v1 + 1172) = *(float *)(v1 + 1072) - *(float *)(v1 + 1068);
  *(_BYTE *)(v1 + 3192) = 1;
  sub_10034DE0(COERCE_FLOAT(1), 2, v1 + 12040, v1 + 848);
  *(_DWORD *)(v1 + 2988) = -16711681;
  *(_DWORD *)(v1 + 928) = v1 + 120;
  sub_10034DE0(COERCE_FLOAT(2), 5, v1 + 12048, v1 + 848);
  *(_DWORD *)(v1 + 3024) = -16711681;
  sub_10034DE0(0.0, 3, v1 + 116, v1 + 848);
  v5 = *(_BYTE *)(v1 + 52873);
  *(_DWORD *)(v1 + 2952) = -8355712;
  if ( v5 )
    *(_DWORD *)(v1 + 900) = &unk_10087FF4;
  *(_BYTE *)(v1 + 3144) = 3;
  sub_10003920((int)v3, v5);
  if ( *(_BYTE *)dword_102D2B4C == 38 )
  {
    ++*(_BYTE *)(v1 + 6404);
    v6 = *(float *)(v1 + 868) * 0.9200000166893005;
    sub_10035DF0(v6, 0.30000001, 3, v1 + 848);
    *(float *)(v1 + 3412) = 2.0;
    *(_DWORD *)(v1 + 3452) = -16711681;
  }
  v7 = *(float *)(v1 + 2904);
  *(_BYTE *)(v1 + 3199) = 1;
  *(_BYTE *)(v1 + 3198) = 2;
  *(_BYTE *)(v1 + 3197) = 2;
  *(_DWORD *)(v1 + 2916) = -16711936;
  *(float *)(v1 + 2904) = v7 - 4.0;
  sub_10034CB0((_BYTE *)(dword_102D2B4C + 3912), v1 + 848);
  sub_10034DC0(dword_102D2B4C + 20480, v1 + 848);
  *(_WORD *)(v1 + 6406) = 9;
  sub_10034D90(v1 + 112, 1, v1 + 848);
  sub_100348D0(v1 + 848);
  v8 = (float *)(v1 + 6444);
  if ( *(_BYTE *)(v1 + 52873) )
  {
    sub_100359F0(v1 + 6444, (int)byte_100879F8, dword_102D2B4C + 3912, 85.0, 15.0, 110.0, 110.0);
    *(float *)(v1 + 6664) = 110.0;
    *(_DWORD *)(v1 + 8520) = 53;
    *(float *)(v1 + 6668) = 250.0;
    *(float *)(v1 + 6768) = 140.0;
    *(float *)(v1 + 8776) = 0.5;
    *(float *)(v1 + 8780) = 0.5;
    *(float *)(v1 + 8744) = *(float *)(v1 + 6452) * 0.5 + *v8 - 12.0;
    *(float *)(v1 + 8748) = 70.0;
    *(float *)(v1 + 8784) = 15.0;
    sub_10035D90(v1 + 6444);
  }
  else
  {
    sub_100359F0(v1 + 6444, (int)byte_100879F8, dword_102D2B4C + 3912, 163.0, 18.0, 90.0, 90.0);
    *(float *)(v1 + 6664) = 135.0;
    *(_BYTE *)(v1 + 8516) = 1;
    *(float *)(v1 + 6668) = 405.0;
    *(float *)(v1 + 6768) = 270.0;
    *(float *)(v1 + 8748) = 96.0;
    *(float *)(v1 + 8784) = 18.0;
  }
  *(_BYTE *)(v1 + 8788) = 1;
  sub_10034DE0(COERCE_FLOAT(1), 2, v1 + 12044, v1 + 6444);
  *(_DWORD *)(v1 + 8584) = -16711681;
  sub_10034DE0(COERCE_FLOAT(2), 5, v1 + 12052, v1 + 6444);
  *(_DWORD *)(v1 + 8620) = -16711681;
  *(_DWORD *)(v1 + 6524) = v1 + 132;
  sub_10034DE0(0.0, 3, v1 + 128, v1 + 6444);
  v9 = *(_BYTE *)(v1 + 52873);
  *(_DWORD *)(v1 + 8548) = -8355712;
  if ( v9 )
    *(_DWORD *)(v1 + 6496) = &unk_10087FF4;
  *(_BYTE *)(v1 + 8740) = 3;
  sub_10003920((int)v8, v9);
  if ( *(_BYTE *)dword_102D2B4C == 38 )
  {
    ++*(_BYTE *)(v1 + 12000);
    v10 = *(float *)(v1 + 6464) * 0.9200000166893005;
    sub_10035DF0(v10, 0.30000001, 3, v1 + 6444);
    *(float *)(v1 + 9008) = 2.0;
    *(_DWORD *)(v1 + 9048) = -16711681;
  }
  v11 = *(float *)(v1 + 8500);
  *(_BYTE *)(v1 + 8795) = 1;
  *(_BYTE *)(v1 + 8794) = 2;
  *(_BYTE *)(v1 + 8793) = 2;
  *(float *)(v1 + 8500) = v11 - 4.0;
  *(_DWORD *)(v1 + 8512) = -16711936;
  sub_100348D0(v1 + 6444);
  sub_10034CB0((_BYTE *)(dword_102D2B4C + 3912), v1 + 6444);
  sub_10034DC0(dword_102D2B4C + 20480, v1 + 6444);
  *(_WORD *)(v1 + 12002) = 9;
  sub_10034D90(v1 + 124, 1, v1 + 6444);
  v45 = 70.0;
  v39 = 70.0;
  v12 = (float *)(v1 + 12064);
  if ( *(_BYTE *)(v1 + 52873) )
  {
    sub_100359F0(v1 + 12064, (int)byte_100879F8, dword_102D2B4C + 5388, 15.0, 125.0, v39, v45);
    *(float *)(v1 + 12284) = 110.0;
    *(_DWORD *)(v1 + 14140) = 53;
    *(float *)(v1 + 12288) = 250.0;
    *(float *)(v1 + 12388) = 140.0;
    *(float *)(v1 + 14120) = *(float *)(v1 + 14120) + 4.0;
    *(float *)(v1 + 14364) = *(float *)(v1 + 12072) * 0.5 + *v12;
    *(float *)(v1 + 14368) = 160.0;
    *(float *)(v1 + 14404) = 15.0;
    sub_10035D90(v1 + 12064);
  }
  else
  {
    sub_100359F0(v1 + 12064, (int)byte_100879F8, dword_102D2B4C + 5388, 33.0, 138.0, v39, v45);
    *(float *)(v1 + 12284) = 140.0;
    *(float *)(v1 + 12288) = 400.0;
    *(float *)(v1 + 12388) = 260.0;
    *(_BYTE *)(v1 + 14136) = 1;
    *(float *)(v1 + 14368) = 198.0;
    *(float *)(v1 + 14404) = 18.0;
    sub_10034DE0(0.0, 3, v1 + 296, v1 + 12064);
    *(_DWORD *)(v1 + 14168) = -8355712;
    *(_BYTE *)(v1 + 14360) = 1;
  }
  sub_10003920((int)v12, *(_BYTE *)(v1 + 52873));
  sub_10035DF0(9.8999998e24, -0.30000001, 3, v1 + 12064);
  *(_DWORD *)(v1 + 14668) = -65536;
  *(_BYTE *)(v1 + 14672) = 1;
  *(float *)(v1 + 14628) = 2.0;
  ++*(_BYTE *)(v1 + 17620);
  sub_10035DF0(9.8999998e24, -0.30000001, 2, v1 + 12064);
  *(_BYTE *)(v1 + 14608) = 1;
  *(_DWORD *)(v1 + 14604) = -256;
  *(float *)(v1 + 14564) = 2.0;
  v13 = *(float *)(v1 + 14120);
  *(_BYTE *)(v1 + 14408) = 1;
  *(_BYTE *)(v1 + 14415) = 1;
  *(_BYTE *)(v1 + 14414) = 2;
  *(_BYTE *)(v1 + 14413) = 2;
  *(float *)(v1 + 14120) = v13 - 2.0;
  *(_DWORD *)(v1 + 14132) = -16711936;
  sub_10034CB0((_BYTE *)(dword_102D2B4C + 5388), v1 + 12064);
  sub_10034DC0(dword_102D2B4C + 20732, v1 + 12064);
  *(_WORD *)(v1 + 17622) = 17;
  sub_10034D90(v1 + 292, 1, v1 + 12064);
  sub_100348D0(v1 + 12064);
  v2 = *(_BYTE *)(v1 + 52873) == 0;
  v46 = 70.0;
  v40 = 70.0;
  *(_BYTE *)(v1 + 17628) = 1;
  v14 = (float *)(v1 + 17660);
  if ( v2 )
  {
    sub_100359F0(v1 + 17660, (int)byte_100879F8, dword_102D2B4C + 5388, 173.0, 138.0, v40, v46);
    *(float *)(v1 + 17880) = 140.0;
    *(float *)(v1 + 17884) = 400.0;
    *(float *)(v1 + 17984) = 260.0;
    *(_BYTE *)(v1 + 19732) = 1;
    *(float *)(v1 + 19964) = 198.0;
    sub_10034DE0(0.0, 3, v1 + 308, v1 + 17660);
    *(_DWORD *)(v1 + 19764) = -8355712;
    *(_BYTE *)(v1 + 19956) = 1;
    *(float *)(v1 + 20000) = 18.0;
  }
  else
  {
    sub_100359F0(v1 + 17660, (int)byte_100879F8, dword_102D2B4C + 5388, 90.0, 125.0, v40, v46);
    *(float *)(v1 + 17880) = 110.0;
    *(_DWORD *)(v1 + 19736) = 53;
    *(float *)(v1 + 17884) = 250.0;
    *(float *)(v1 + 17984) = 140.0;
    *(float *)(v1 + 19716) = *(float *)(v1 + 19716) + 4.0;
    *(float *)(v1 + 19960) = *(float *)(v1 + 17668) * 0.5 + *v14;
    *(float *)(v1 + 19964) = 160.0;
    *(float *)(v1 + 20000) = 15.0;
    sub_10035D90(v1 + 17660);
  }
  sub_10003920((int)v14, *(_BYTE *)(v1 + 52873));
  sub_10035DF0(9.8999998e24, -0.30000001, 3, v1 + 17660);
  *(_DWORD *)(v1 + 20264) = -65536;
  *(_BYTE *)(v1 + 20268) = 1;
  *(float *)(v1 + 20224) = 2.0;
  ++*(_BYTE *)(v1 + 23216);
  sub_10035DF0(9.8999998e24, -0.30000001, 2, v1 + 17660);
  *(_DWORD *)(v1 + 20200) = -256;
  *(_BYTE *)(v1 + 20204) = 1;
  *(float *)(v1 + 20160) = 2.0;
  *(_BYTE *)(v1 + 20004) = 1;
  *(_BYTE *)(v1 + 20010) = 2;
  *(_BYTE *)(v1 + 20011) = 1;
  *(_BYTE *)(v1 + 20009) = 2;
  *(_WORD *)(v1 + 23218) = 17;
  *(_DWORD *)(v1 + 19728) = -16711936;
  *(float *)(v1 + 19716) = *(float *)(v1 + 19716) - 2.0;
  sub_10034CB0((_BYTE *)(dword_102D2B4C + 5388), v1 + 17660);
  sub_10034DC0(dword_102D2B4C + 20732, v1 + 17660);
  sub_10034D90(v1 + 304, 1, v1 + 17660);
  sub_100348D0(v1 + 17660);
  *(_BYTE *)(v1 + 23224) = 1;
  v47 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EFC0(v1 + 23276, (int)"N2%", dword_102D2B4C + 3912, 4.0, 214.0, 142.0, v47);
  else
    sub_1001EFC0(v1 + 23276, (int)"N2%", dword_102D2B4C + 3912, 5.0, 233.0, 268.0, v47);
  *(_BYTE *)(v1 + 23450) = 2;
  *(_WORD *)(v1 + 23792) = 9;
  *(_DWORD *)(v1 + 23316) = -16711936;
  *(_DWORD *)(v1 + 23312) = -16777216;
  *(_BYTE *)(v1 + 23348) = 1;
  *(_BYTE *)(v1 + 23396) = 1;
  *(_DWORD *)(v1 + 23324) = v1 + 324;
  *(_DWORD *)(v1 + 23372) = v1 + 336;
  *(float *)(v1 + 23344) = 13.0;
  *(float *)(v1 + 23392) = 13.0;
  *(float *)(v1 + 23456) = *(float *)(v1 + 23308);
  *(float *)(v1 + 23500) = 9.0;
  *(float *)(v1 + 23296) = *(float *)(dword_102D2B4C + 20480);
  *(float *)(v1 + 23300) = *(float *)(dword_102D2B4C + 20484);
  *(float *)(v1 + 23328) = *(float *)(dword_102D2B4C + 20480);
  *(float *)(v1 + 23332) = *(float *)(dword_102D2B4C + 20484);
  *(float *)(v1 + 23376) = *(float *)(dword_102D2B4C + 20480);
  *(float *)(v1 + 23380) = *(float *)(dword_102D2B4C + 20484);
  v48 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EFC0(v1 + 23888, (int)"PRES PSI", dword_102D2B4C + 4076, 4.0, 242.0, 142.0, v48);
  else
    sub_1001EFC0(v1 + 23888, (int)"OIL PRES PSI", dword_102D2B4C + 4076, 5.0, 254.0, 268.0, v48);
  *(_BYTE *)(v1 + 24062) = 2;
  *(_WORD *)(v1 + 24404) = 14;
  *(_DWORD *)(v1 + 23936) = v1 + 144;
  *(_DWORD *)(v1 + 23984) = v1 + 156;
  *(_BYTE *)(v1 + 23960) = 1;
  *(_BYTE *)(v1 + 24008) = 1;
  *(float *)(v1 + 23956) = 13.0;
  *(float *)(v1 + 24004) = 13.0;
  *(float *)(v1 + 24068) = *(float *)(v1 + 23920);
  *(float *)(v1 + 24112) = 9.0;
  *(float *)(v1 + 23908) = *(float *)(dword_102D2B4C + 20508);
  *(float *)(v1 + 23912) = *(float *)(dword_102D2B4C + 20512);
  *(float *)(v1 + 23940) = *(float *)(dword_102D2B4C + 20508);
  *(float *)(v1 + 23944) = *(float *)(dword_102D2B4C + 20512);
  *(float *)(v1 + 23988) = *(float *)(dword_102D2B4C + 20508);
  *(float *)(v1 + 23992) = *(float *)(dword_102D2B4C + 20512);
  *(_BYTE *)(v1 + 24412) = 1;
  v49 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EFC0(v1 + 24500, (int)"TEMP C", dword_102D2B4C + 4076, 4.0, 259.0, 142.0, v49);
  else
    sub_1001EFC0(v1 + 24500, (int)"OIL TEMP C", dword_102D2B4C + 4240, 5.0, 275.0, 268.0, v49);
  *(_BYTE *)(v1 + 24674) = 2;
  *(_WORD *)(v1 + 25016) = 17;
  *(_DWORD *)(v1 + 24548) = v1 + 168;
  *(_DWORD *)(v1 + 24596) = v1 + 180;
  *(float *)(v1 + 24568) = 13.0;
  *(float *)(v1 + 24616) = 13.0;
  *(_BYTE *)(v1 + 24572) = 1;
  *(_BYTE *)(v1 + 24620) = 1;
  *(float *)(v1 + 24680) = *(float *)(v1 + 24532);
  *(float *)(v1 + 24724) = 9.0;
  *(float *)(v1 + 24520) = *(float *)(dword_102D2B4C + 20536);
  *(float *)(v1 + 24524) = *(float *)(dword_102D2B4C + 20540);
  *(float *)(v1 + 24552) = *(float *)(dword_102D2B4C + 20536);
  *(float *)(v1 + 24556) = *(float *)(dword_102D2B4C + 20540);
  *(float *)(v1 + 24600) = *(float *)(dword_102D2B4C + 20536);
  *(float *)(v1 + 24604) = *(float *)(dword_102D2B4C + 20540);
  *(_BYTE *)(v1 + 25024) = 1;
  v50 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EFC0(v1 + 25112, (int)"FF KPH", dword_102D2B4C + 5060, 4.0, 288.0, 142.0, v50);
  else
    sub_1001EFC0(v1 + 25112, (int)"FF KPH", dword_102D2B4C + 5060, 5.0, 312.0, 268.0, v50);
  *(_WORD *)(v1 + 25628) = 32;
  *(_BYTE *)(v1 + 25287) = 2;
  *(_DWORD *)(v1 + 25160) = v1 + 264;
  *(_DWORD *)(v1 + 25208) = v1 + 276;
  *(float *)(v1 + 25180) = 13.0;
  *(float *)(v1 + 25228) = 13.0;
  *(_BYTE *)(v1 + 25184) = 1;
  *(_BYTE *)(v1 + 25232) = 1;
  *(float *)(v1 + 25292) = *(float *)(v1 + 25144);
  *(float *)(v1 + 25336) = 9.0;
  *(_BYTE *)(v1 + 25636) = 0;
  *(float *)(v1 + 25132) = *(float *)(dword_102D2B4C + 20676);
  *(float *)(v1 + 25136) = *(float *)(dword_102D2B4C + 20680);
  *(float *)(v1 + 25164) = *(float *)(dword_102D2B4C + 20676);
  *(float *)(v1 + 25168) = *(float *)(dword_102D2B4C + 20680);
  *(float *)(v1 + 25212) = *(float *)(dword_102D2B4C + 20676);
  *(float *)(v1 + 25216) = *(float *)(dword_102D2B4C + 20680);
  v51 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
  {
    sub_1001EFC0(v1 + 25724, (int)"FQ LB", dword_102D2B4C + 4404, 4.0, 325.0, 142.0, v51);
    *(float *)(v1 + 25900) = *(float *)(v1 + 25732) * 0.5 + *(float *)(v1 + 25724);
    *(float *)(v1 + 25904) = *(float *)(v1 + 25728) - 6.0;
    *(float *)(v1 + 25940) = 0.5;
    *(float *)(v1 + 25944) = 1.0;
  }
  else
  {
    sub_1001EFC0(v1 + 25724, (int)"FQ LB", dword_102D2B4C + 4404, 5.0, 333.0, 268.0, v51);
    *(float *)(v1 + 25904) = *(float *)(v1 + 25756);
  }
  *(_WORD *)(v1 + 26240) = 30;
  *(_BYTE *)(v1 + 25899) = 2;
  *(_DWORD *)(v1 + 25772) = v1 + 192;
  *(_DWORD *)(v1 + 25820) = v1 + 204;
  *(float *)(v1 + 25792) = 13.0;
  *(float *)(v1 + 25840) = 13.0;
  *(_BYTE *)(v1 + 25796) = 1;
  *(_BYTE *)(v1 + 25844) = 1;
  *(float *)(v1 + 25948) = 9.0;
  *(_BYTE *)(v1 + 26248) = 0;
  *(float *)(v1 + 25744) = *(float *)(dword_102D2B4C + 20564);
  *(float *)(v1 + 25748) = *(float *)(dword_102D2B4C + 20568);
  *(float *)(v1 + 25776) = *(float *)(dword_102D2B4C + 20564);
  *(float *)(v1 + 25780) = *(float *)(dword_102D2B4C + 20568);
  *(float *)(v1 + 25824) = *(float *)(dword_102D2B4C + 20564);
  *(float *)(v1 + 25828) = *(float *)(dword_102D2B4C + 20568);
  v52 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EF80(v1 + 26336, (int)byte_100879F8, dword_102D2B4C + 4568, 75.0, 338.0, 142.0, v52);
  else
    sub_1001EF80(v1 + 26336, (int)byte_100879F8, dword_102D2B4C + 4568, 139.0, 367.0, 268.0, v52);
  *(_WORD *)(v1 + 26852) = 30;
  *(_DWORD *)(v1 + 26384) = v1 + 240;
  *(float *)(v1 + 26404) = 13.0;
  *(float *)(v1 + 26396) = 0.5;
  v15 = (float *)(v1 + 26948);
  *(float *)(v1 + 26364) = *(float *)(v1 + 26336);
  *(_BYTE *)(v1 + 26408) = 1;
  *(_BYTE *)(v1 + 26860) = 0;
  *(float *)(v1 + 26356) = *(float *)(dword_102D2B4C + 20592);
  *(float *)(v1 + 26360) = *(float *)(dword_102D2B4C + 20596);
  *(float *)(v1 + 26388) = *(float *)(dword_102D2B4C + 20592);
  *(float *)(v1 + 26392) = *(float *)(dword_102D2B4C + 20596);
  v53 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
  {
    sub_1001EF80(v1 + 26948, (int)"TEMP", dword_102D2B4C + 5224, 34.0, 317.0, 142.0, v53);
    *(_BYTE *)(v1 + 27123) = 1;
    *(float *)(v1 + 26976) = *v15;
    *(float *)(v1 + 26980) = *(float *)(v1 + 26952) + 2.0;
  }
  else
  {
    sub_1001EF80(v1 + 26948, (int)"TEMP", dword_102D2B4C + 5224, 5.0, 385.0, 117.0, v53);
    *(float *)(v1 + 26976) = *(float *)(v1 + 26956) * 0.5 + *v15 + 10.0;
  }
  *(_BYTE *)(v1 + 27122) = 2;
  *(_WORD *)(v1 + 27464) = 17;
  *(float *)(v1 + 27008) = 1.0;
  *(_DWORD *)(v1 + 26996) = v1 + 288;
  *(float *)(v1 + 27016) = 13.0;
  *(_BYTE *)(v1 + 27020) = 1;
  *(float *)(v1 + 27172) = 9.0;
  *(float *)(v1 + 27124) = *v15;
  *(float *)(v1 + 27128) = *(float *)(v1 + 26952);
  *(float *)(v1 + 26968) = *(float *)(dword_102D2B4C + 20704);
  *(float *)(v1 + 26972) = *(float *)(dword_102D2B4C + 20708);
  *(float *)(v1 + 27000) = *(float *)(dword_102D2B4C + 20704);
  *(float *)(v1 + 27004) = *(float *)(dword_102D2B4C + 20708);
  sub_10038450(v1 + 27244, &word_10089924, 21);
  *(_BYTE *)(v1 + 27121) = 2;
  *(float *)(v1 + 27228) = *(float *)(v1 + 26976) + 1.0;
  *(_DWORD *)(v1 + 27240) = -1;
  v16 = (float *)(v1 + 27560);
  *(float *)(v1 + 27276) = 9.0;
  *(_BYTE *)(v1 + 27472) = 1;
  v54 = 13.0;
  v41 = 117.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EF80(v1 + 27560, (int)"BATT 1", dword_102D2B4C + 5552, 0.0, 371.0, v41, v54);
  else
    sub_1001EF80(v1 + 27560, (int)"BATT 1", dword_102D2B4C + 5552, 5.0, 415.0, v41, v54);
  *(_BYTE *)(v1 + 27735) = 2;
  *(_BYTE *)(v1 + 27733) = 2;
  *(_WORD *)(v1 + 28076) = 21;
  *(float *)(v1 + 27784) = 9.0;
  *(float *)(v1 + 27736) = *v16;
  *(float *)(v1 + 27588) = *(float *)(v1 + 27568) + *v16;
  *(float *)(v1 + 27628) = 13.0;
  *(float *)(v1 + 27620) = 1.0;
  *(_DWORD *)(v1 + 27608) = v1 + 348;
  *(_BYTE *)(v1 + 27632) = 1;
  *(float *)(v1 + 27580) = *(float *)(dword_102D2B4C + 20760);
  *(float *)(v1 + 27584) = *(float *)(dword_102D2B4C + 20764);
  sub_1001EC90(dword_102D2B4C + 20760, v1 + 27560);
  sub_10038450(v1 + 27856, &unk_10089918, 21);
  *(float *)(v1 + 27840) = *(float *)(v1 + 27568) + *v16 + 3.0;
  v17 = *(float *)(v1 + 27568) + *v16;
  v18 = (float *)(v1 + 28172);
  *(float *)(v1 + 27840) = v17 + 3.0;
  *(_DWORD *)(v1 + 27852) = -1;
  *(float *)(v1 + 27888) = 9.0;
  v55 = 13.0;
  v42 = 117.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EF80(v1 + 28172, (int)"BATT 2", dword_102D2B4C + 5552, 0.0, 388.0, v42, v55);
  else
    sub_1001EF80(v1 + 28172, (int)"BATT 2", dword_102D2B4C + 5552, 5.0, 436.0, v42, v55);
  *(_BYTE *)(v1 + 28345) = 2;
  *(_BYTE *)(v1 + 28347) = 2;
  *(_WORD *)(v1 + 28688) = 21;
  *(float *)(v1 + 28396) = 9.0;
  *(float *)(v1 + 28348) = *v18;
  *(float *)(v1 + 28200) = *(float *)(v1 + 28180) + *v18;
  *(float *)(v1 + 28240) = 13.0;
  *(float *)(v1 + 28232) = 1.0;
  *(_DWORD *)(v1 + 28220) = v1 + 360;
  *(_BYTE *)(v1 + 28244) = 1;
  *(float *)(v1 + 28192) = *(float *)(dword_102D2B4C + 20760);
  *(float *)(v1 + 28196) = *(float *)(dword_102D2B4C + 20764);
  sub_1001EC90(dword_102D2B4C + 20760, v1 + 28172);
  sub_10038450(v1 + 28468, &unk_10089918, 21);
  v19 = *(float *)(v1 + 28180) + *v18;
  v20 = (float *)(v1 + 28784);
  *(float *)(v1 + 28452) = v19 + 3.0;
  *(_DWORD *)(v1 + 28464) = -1;
  *(float *)(v1 + 28500) = 9.0;
  v56 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EF80(v1 + 28784, (int)"ALT", dword_102D2B4C + 5880, 0.0, 418.0, 112.0, v56);
  else
    sub_1001EF80(v1 + 28784, (int)"ALT", dword_102D2B4C + 5880, 144.0, 427.0, 96.0, v56);
  *(_BYTE *)(v1 + 28958) = 2;
  *(_BYTE *)(v1 + 28957) = 2;
  *(_WORD *)(v1 + 29300) = 26;
  *(float *)(v1 + 29008) = 9.0;
  *(float *)(v1 + 28960) = *v20;
  *(float *)(v1 + 28812) = *(float *)(v1 + 28792) + *v20;
  *(float *)(v1 + 28852) = 13.0;
  *(float *)(v1 + 28844) = 1.0;
  *(_DWORD *)(v1 + 28832) = v1 + 372;
  *(_BYTE *)(v1 + 28856) = 1;
  *(float *)(v1 + 28804) = *(float *)(dword_102D2B4C + 20816);
  *(float *)(v1 + 28808) = *(float *)(dword_102D2B4C + 20820);
  sub_1001EC90(dword_102D2B4C + 20816, v1 + 28784);
  *(_WORD *)(v1 + 29080) = 21574;
  *(_BYTE *)(v1 + 29082) = 0;
  v21 = *(float *)(v1 + 28792) + *v20;
  v22 = (float *)(v1 + 29396);
  *(float *)(v1 + 29064) = v21 + 3.0;
  *(_DWORD *)(v1 + 29076) = -1;
  *(float *)(v1 + 29112) = 9.0;
  *(_BYTE *)(v1 + 29308) = 1;
  v57 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EF80(v1 + 29396, (int)"RATE", dword_102D2B4C + 6044, 0.0, 435.0, 112.0, v57);
  else
    sub_1001EF80(v1 + 29396, (int)"RATE", dword_102D2B4C + 6044, 144.0, 448.0, 96.0, v57);
  *(_BYTE *)(v1 + 29570) = 2;
  *(_BYTE *)(v1 + 29569) = 2;
  *(_WORD *)(v1 + 29912) = 27;
  *(float *)(v1 + 29620) = 9.0;
  *(float *)(v1 + 29572) = *v22;
  *(float *)(v1 + 29424) = *(float *)(v1 + 29404) + *v22;
  *(float *)(v1 + 29464) = 13.0;
  *(float *)(v1 + 29456) = 1.0;
  *(_DWORD *)(v1 + 29444) = v1 + 384;
  *(_BYTE *)(v1 + 29468) = 1;
  *(float *)(v1 + 29416) = *(float *)(dword_102D2B4C + 20844);
  *(float *)(v1 + 29420) = *(float *)(dword_102D2B4C + 20848);
  sub_1001EC90(dword_102D2B4C + 20844, v1 + 29396);
  sub_10038450(v1 + 29692, &unk_100898F0, 21);
  v23 = *(float *)(v1 + 29404) + *v22;
  v24 = (float *)(v1 + 30008);
  *(float *)(v1 + 29676) = v23 + 3.0;
  *(_DWORD *)(v1 + 29688) = -1;
  *(float *)(v1 + 29724) = 9.0;
  *(_BYTE *)(v1 + 29920) = 1;
  v58 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EF80(v1 + 30008, (int)"DELTA-P", dword_102D2B4C + 6208, 0.0, 452.0, 112.0, v58);
  else
    sub_1001EF80(v1 + 30008, (int)"DELTA-P", dword_102D2B4C + 6208, 144.0, 469.0, 96.0, v58);
  *(_WORD *)(v1 + 30524) = 15;
  *(_BYTE *)(v1 + 30181) = 2;
  *(_BYTE *)(v1 + 30183) = 2;
  *(float *)(v1 + 30232) = 9.0;
  *(float *)(v1 + 30184) = *v24;
  *(float *)(v1 + 30036) = *(float *)(v1 + 30016) + *v24;
  *(float *)(v1 + 30076) = 13.0;
  *(float *)(v1 + 30068) = 1.0;
  *(_DWORD *)(v1 + 30056) = v1 + 408;
  *(_BYTE *)(v1 + 30080) = 1;
  *(float *)(v1 + 30028) = *(float *)(dword_102D2B4C + 20872);
  *(float *)(v1 + 30032) = *(float *)(dword_102D2B4C + 20876);
  sub_1001EC90(dword_102D2B4C + 20872, v1 + 30008);
  sub_10038450(v1 + 30304, &unk_100898E4, 21);
  v25 = *(float *)(v1 + 30016) + *v24;
  v26 = (float *)(v1 + 31240);
  *(float *)(v1 + 30288) = v25 + 3.0;
  *(_DWORD *)(v1 + 30300) = -1;
  *(float *)(v1 + 30336) = 9.0;
  *(_BYTE *)(v1 + 30532) = 1;
  v59 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EF80(v1 + 31240, (int)"LFE", dword_102D2B4C + 6208, 0.0, 469.0, 112.0, v59);
  else
    sub_1001EF80(v1 + 31240, (int)"LFE", dword_102D2B4C + 6208, 144.0, 490.0, 96.0, v59);
  *(_BYTE *)(v1 + 31414) = 2;
  *(_BYTE *)(v1 + 31413) = 2;
  *(float *)(v1 + 31676) = *(float *)(v1 + 31264);
  *(_WORD *)(v1 + 31756) = 26;
  *(float *)(v1 + 31464) = 9.0;
  *(float *)(v1 + 31416) = *v26;
  *(float *)(v1 + 31268) = *(float *)(v1 + 31248) + *v26;
  *(float *)(v1 + 31308) = 13.0;
  *(float *)(v1 + 31300) = 1.0;
  *(_DWORD *)(v1 + 31288) = v1 + 396;
  *(_BYTE *)(v1 + 31312) = 1;
  sub_10038450(v1 + 31536, &word_100898FC, 21);
  v27 = *(float *)(v1 + 31248) + *v26;
  v28 = (float *)(v1 + 30620);
  *(float *)(v1 + 31520) = v27 + 3.0;
  *(_DWORD *)(v1 + 31532) = -1;
  *(float *)(v1 + 31568) = 9.0;
  *(_BYTE *)(v1 + 31764) = 1;
  v60 = 13.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_1001EF80(v1 + 30620, dword_102D2B4C + 5860, dword_102D2B4C + 5716, 0.0, 486.0, 112.0, v60);
  else
    sub_1001EF80(v1 + 30620, dword_102D2B4C + 5860, dword_102D2B4C + 5716, 144.0, 511.0, 96.0, v60);
  *(_WORD *)(v1 + 31136) = 14;
  *(float *)(v1 + 30844) = 9.0;
  *(float *)(v1 + 30796) = *v28;
  *(float *)(v1 + 30648) = *(float *)(v1 + 30628) + *v28;
  *(float *)(v1 + 30688) = 13.0;
  *(float *)(v1 + 30680) = 1.0;
  *(_DWORD *)(v1 + 30668) = v1 + 420;
  *(_BYTE *)(v1 + 30692) = 1;
  *(float *)(v1 + 30640) = *(float *)(dword_102D2B4C + 20788);
  *(float *)(v1 + 30644) = *(float *)(dword_102D2B4C + 20792);
  *(float *)(v1 + 30672) = *(float *)(dword_102D2B4C + 20788);
  *(float *)(v1 + 30676) = *(float *)(dword_102D2B4C + 20792);
  sub_10038450(v1 + 30916, &unk_100898E4, 21);
  *(_BYTE *)(v1 + 30793) = 2;
  *(_BYTE *)(v1 + 30795) = 2;
  *(float *)(v1 + 30900) = *(float *)(v1 + 30628) + *v28 + 3.0;
  *(_DWORD *)(v1 + 30912) = -1;
  *(float *)(v1 + 30948) = 9.0;
  *(_BYTE *)(v1 + 31144) = 1;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_100359F0(v1 + 47228, (int)byte_100879F8, dword_102D2B4C + 6700, 59.0, 521.0, 80.0, 80.0);
  else
    sub_100359F0(v1 + 47228, (int)byte_100879F8, dword_102D2B4C + 6700, 158.0, 493.0, 100.0, 100.0);
  *(_BYTE *)(v1 + 49578) = 1;
  *(_BYTE *)(v1 + 49577) = 2;
  *(float *)(v1 + 47448) = *(float *)(dword_102D2B4C + 6704);
  v29 = *(float *)(dword_102D2B4C + 6708);
  *(float *)(v1 + 47452) = v29;
  *(float *)(v1 + 47552) = v29 - *(float *)(v1 + 47448);
  *(_BYTE *)(v1 + 49300) = 1;
  *(_WORD *)(v1 + 52786) = 10;
  sub_10034DE0(0.0, 3, v1 + 488, v1 + 47228);
  *(_DWORD *)(v1 + 49332) = -8355712;
  sub_10034DE0(COERCE_FLOAT(1), 4, (int)&unk_10087FF4, v1 + 47228);
  *(_DWORD *)(v1 + 49368) = -16711681;
  *(_BYTE *)(v1 + 49524) = 2;
  sub_10035D90(v1 + 47228);
  sub_10034D90(v1 + 484, 1, v1 + 47228);
  sub_100348D0(v1 + 47228);
  v61 = 100.0;
  v43 = 100.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_100359F0(v1 + 32032, (int)"ROLL", dword_102D2B4C + 6372, -6.0, 628.0, v43, v61);
  else
    sub_100359F0(v1 + 32032, (int)"ROLL", dword_102D2B4C + 6372, 18.0, 629.0, v43, v61);
  *(_BYTE *)(v1 + 34382) = 1;
  *(_BYTE *)(v1 + 34380) = 1;
  *(_BYTE *)(v1 + 34385) = 2;
  *(_BYTE *)(v1 + 34104) = 8;
  *(float *)(v1 + 32252) = 235.0;
  *(float *)(v1 + 32256) = 305.0;
  *(float *)(v1 + 32356) = 305.0 - *(float *)(v1 + 32252);
  *(float *)(v1 + 34088) = *(float *)(v1 + 32044) * 0.119999997317791;
  *(float *)(v1 + 34084) = *(float *)(v1 + 32040) * 0.5;
  *(float *)(v1 + 32180) = 9.0;
  *(float *)(v1 + 32136) = *(float *)(v1 + 32036) - 9.0;
  *(_WORD *)(v1 + 37590) = 10;
  sub_10035190((int)&unk_10088108, 5, 0.0, v1 + 32032);
  sub_10034CB0((_BYTE *)(dword_102D2B4C + 6372), v1 + 32032);
  sub_10034D90(v1 + 424, 1, v1 + 32032);
  sub_100348D0(v1 + 32032);
  v44 = 10.0;
  v38 = 60.0;
  if ( *(_BYTE *)(v1 + 52873) )
    sub_10021B30(v1 + 37628, (int)&unk_10089878, dword_102D2B4C + 6372, 13.0, 672.0, v38, v44, 0);
  else
    sub_10021B30(v1 + 37628, (int)&unk_10089878, dword_102D2B4C + 6372, 38.0, 673.0, v38, v44, 0);
  *(_BYTE *)(v1 + 41815) = 1;
  *(_BYTE *)(v1 + 41816) = 1;
  *(_WORD *)(v1 + 41940) = 10;
  *(float *)(v1 + 37740) = 9.0;
  *(float *)(v1 + 37696) = *(float *)(v1 + 37696) - 2.0;
  *(float *)(v1 + 38092) = 11.0;
  *(float *)(v1 + 38088) = 11.0;
  *(_BYTE *)(v1 + 38142) = 0;
  sub_10020EB0((int)&unk_100881F8, 5u, 0, v1 + 37628);
  sub_10020E60(v1 + 436, 1, 1, v1 + 37628);
  if ( *(_BYTE *)dword_102D2B4C == 31 )
  {
    if ( *(_BYTE *)(v1 + 52873) )
    {
      v30 = 90.0;
LABEL_75:
      v63 = v30;
      v62 = 623.0;
      v31 = 55.0;
      goto LABEL_81;
    }
    v32 = 208.0;
  }
  else
  {
    if ( *(_BYTE *)(v1 + 52873) )
    {
      v30 = 83.0;
      goto LABEL_75;
    }
    v32 = 199.0;
  }
  v63 = v32;
  v62 = 624.0;
  v31 = 60.0;
LABEL_81:
  v33 = v31;
  sub_10021B70(v1 + 42120, (int)"PITCH", dword_102D2B4C + 6536, v63, v62, 20.0, v33, 1);
  *(_BYTE *)(v1 + 46308) = 1;
  *(_BYTE *)(v1 + 46306) = 2;
  *(float *)(v1 + 42584) = 11.0;
  *(float *)(v1 + 42580) = 11.0;
  *(_BYTE *)(v1 + 42634) = 0;
  *(float *)(v1 + 42648) = 11.0;
  *(float *)(v1 + 42644) = 11.0;
  *(_BYTE *)(v1 + 42698) = 0;
  *(_BYTE *)(v1 + 42604) = 0;
  *(_BYTE *)(v1 + 42668) = 0;
  *(float *)(v1 + 42232) = 9.0;
  *(_BYTE *)(v1 + 46307) = 1;
  *(float *)(v1 + 42128) = *(float *)(v1 + 42128) - 2.0;
  if ( *(_BYTE *)dword_102D2B4C == 31 )
  {
    *(_WORD *)(v1 + 46432) = 10;
    sub_10020E60(v1 + 448, 2, 1, v1 + 42120);
    sub_10020EB0((int)&unk_10088158, 0xAu, 0, v1 + 42120);
  }
  else
  {
    *(_WORD *)(v1 + 46432) = 12;
    *(_DWORD *)(v1 + 42152) = v1 + 464;
    *(_DWORD *)(v1 + 42176) = v1 + 468;
  }
  if ( *(_BYTE *)dword_102D2B4C == 31 )
  {
    if ( *(_BYTE *)(v1 + 52873) )
    {
      v64 = 118.0;
      v34 = 650.0;
      goto LABEL_92;
    }
    v35 = 243.0;
  }
  else
  {
    if ( *(_BYTE *)(v1 + 52873) )
    {
      v64 = 115.0;
      v34 = 650.0;
      goto LABEL_92;
    }
    v35 = 238.0;
  }
  v64 = v35;
  v34 = 654.0;
LABEL_92:
  v36 = v34;
  sub_1001EF80(v1 + 46612, (int)byte_100879F8, dword_102D2B4C + 6536, v64, v36, 28.0, 13.0);
  *(_BYTE *)(v1 + 46786) = 2;
  *(_BYTE *)(v1 + 46785) = 1;
  *(_BYTE *)(v1 + 46787) = 1;
  sub_1001EC50(v1 + 472, 1, v1 + 46612);
  *(float *)(v1 + 46680) = 13.0;
  *(float *)(v1 + 46672) = 1.0;
  *(float *)(v1 + 46676) = 0.0;
  *(float *)(v1 + 46688) = *(float *)(v1 + 46640);
  *(float *)(v1 + 46692) = *(float *)(v1 + 46644);
  result = dword_102D2B4C;
  if ( *(_BYTE *)dword_102D2B4C == 31 )
  {
    *(_WORD *)(v1 + 47128) = 10;
  }
  else
  {
    *(_WORD *)(v1 + 47128) = 12;
    *(float *)(v1 + 46636) = *(float *)(v1 + 46632) * -1.0;
    *(float *)(v1 + 46632) = 0.0;
    *(float *)(v1 + 46664) = 0.0;
    *(float *)(v1 + 46668) = *(float *)(v1 + 46636);
  }
  return result;
}
// 100898FC: using guessed type __int16 word_100898FC;
// 10089924: using guessed type __int16 word_10089924;
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10008FA0) --------------------------------------------------------
char __usercall sub_10008FA0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  void *v2; // ecx@1
  void *v3; // ecx@1
  bool v4; // al@3
  float *v5; // ecx@5
  int v6; // eax@5
  signed int v7; // edx@5
  double v8; // st6@6
  void *v9; // ecx@7
  char v10; // al@13
  double v11; // st7@17
  float v12; // ST40_4@17
  int v13; // ecx@24
  char result; // al@24
  _WORD *v15; // [sp-20h] [bp-44h]@22
  char *v16; // [sp-1Ch] [bp-40h]@22
  int v17; // [sp-18h] [bp-3Ch]@22
  char v18; // [sp+16h] [bp-Eh]@11
  char v19; // [sp+17h] [bp-Dh]@11
  char v20; // [sp+18h] [bp-Ch]@11
  char v21; // [sp+19h] [bp-Bh]@13
  char v22; // [sp+1Ah] [bp-Ah]@13
  char v23; // [sp+1Bh] [bp-9h]@16
  int v24; // [sp+1Ch] [bp-8h]@11
  float v25; // [sp+20h] [bp-4h]@17

  v1 = sub_10001640(a1, *(char **)(a1 + 56), 52908, 0);
  sub_100011B0(a1, 0, 0, *(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 3);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_BYTE *)(v1 + 52860) = 0;
  *(_BYTE *)(v1 + 52872) = 0;
  v4 = sub_10025D10(v2) == 1 || sub_10025CF0(v3) == 2;
  *(_BYTE *)(v1 + 52873) = v4;
  v5 = (float *)&unk_10088088;
  v6 = v1 + 116;
  v7 = 32;
  do
  {
    v8 = *v5;
    ++v5;
    *(float *)(v6 - 4) = v8;
    v6 += 12;
    --v7;
    *(float *)(v6 - 12) = 1.0;
    *(float *)(v6 - 8) = 1.0;
  }
  while ( v7 );
  sub_10006CE0(a1);
  sub_100039C0(a1);
  *(float *)(v1 + 12048) = 9.8999998e24;
  *(_DWORD *)v1 = v1 + 848;
  *(float *)(v1 + 12052) = 9.8999998e24;
  *(float *)(v1 + 12040) = 9.8999998e24;
  *(_DWORD *)(v1 + 4) = v1 + 6444;
  *(float *)(v1 + 12044) = 9.8999998e24;
  *(_DWORD *)(v1 + 8) = v1 + 12064;
  *(_DWORD *)(v1 + 12) = v1 + 17660;
  *(_DWORD *)(v1 + 16) = v1 + 23276;
  *(_DWORD *)(v1 + 20) = v1 + 23888;
  *(_DWORD *)(v1 + 24) = v1 + 24500;
  *(_DWORD *)(v1 + 32) = v1 + 25724;
  *(_DWORD *)(v1 + 36) = v1 + 26336;
  *(_DWORD *)(v1 + 28) = v1 + 25112;
  *(_DWORD *)(v1 + 40) = v1 + 26948;
  *(_DWORD *)(v1 + 44) = v1 + 27560;
  *(_DWORD *)(v1 + 48) = v1 + 28172;
  *(_DWORD *)(v1 + 52) = v1 + 28784;
  *(_DWORD *)(v1 + 56) = v1 + 29396;
  *(_DWORD *)(v1 + 60) = v1 + 30008;
  *(_DWORD *)(v1 + 64) = v1 + 31240;
  *(_DWORD *)(v1 + 68) = v1 + 30620;
  *(_DWORD *)(v1 + 72) = v1 + 32032;
  *(_DWORD *)(v1 + 76) = v1 + 37628;
  *(_DWORD *)(v1 + 80) = v1 + 42120;
  *(_DWORD *)(v1 + 84) = v1 + 46612;
  *(_DWORD *)(v1 + 88) = v1 + 47228;
  *(_DWORD *)(v1 + 92) = 0;
  *(_DWORD *)(v1 + 96) = &unk_10087FF8;
  *(_DWORD *)(v1 + 100) = &unk_10087FFC;
  *(_DWORD *)(v1 + 104) = &unk_10088000;
  *(_DWORD *)(v1 + 108) = v1 + 52830;
  *(_BYTE *)(v1 + 12056) = 0;
  *(_BYTE *)(v1 + 12057) = 0;
  *(_BYTE *)(v1 + 12058) = 0;
  *(_BYTE *)(v1 + 12059) = 0;
  *(_BYTE *)(v1 + 12060) = 0;
  *(_BYTE *)(v1 + 12061) = 0;
  *(_BYTE *)(v1 + 23256) = 0;
  *(_BYTE *)(v1 + 23257) = 0;
  *(_BYTE *)(v1 + 31232) = 0;
  *(_BYTE *)(v1 + 31233) = 0;
  *(_BYTE *)(v1 + 31234) = 0;
  *(_BYTE *)(v1 + 31852) = 0;
  *(_BYTE *)(v1 + 31853) = 0;
  *(_BYTE *)(v1 + 52874) = 0;
  *(_BYTE *)(v1 + 52875) = 0;
  *(_WORD *)(v1 + 52830) = 6;
  *(_DWORD *)(v1 + 52832) = 0;
  *(_DWORD *)(v1 + 31860) = 0;
  *(_DWORD *)(v1 + 31872) = 0;
  *(float *)(v1 + 31880) = 0.0;
  *(_BYTE *)(v1 + 31876) = 0;
  *(float *)(v1 + 52836) = 0.0;
  *(_BYTE *)(v1 + 31884) = 0;
  *(_BYTE *)(v1 + 52840) = 0;
  *(_BYTE *)(v1 + 52841) = 1;
  *(_DWORD *)(v1 + 47224) = 0;
  *(_DWORD *)(v1 + 52880) = sub_100160A0();
  *(_BYTE *)(v1 + 52850) = 6;
  *(_BYTE *)(v1 + 52852) = 6;
  *(_BYTE *)(v1 + 52851) = 1;
  *(_DWORD *)(v1 + 52856) = 0;
  *(_BYTE *)(v1 + 32008) = 0;
  *(_BYTE *)(v1 + 32009) = 0;
  *(_BYTE *)(v1 + 32010) = 0;
  *(_DWORD *)(v1 + 32012) = 0;
  *(_BYTE *)(v1 + 32016) = 0;
  *(_BYTE *)(v1 + 31996) = 0;
  *(_BYTE *)(v1 + 31997) = 0;
  *(_BYTE *)(v1 + 31998) = 0;
  *(_DWORD *)(v1 + 32000) = 0;
  *(_BYTE *)(v1 + 32004) = 0;
  *(_BYTE *)(v1 + 32020) = 0;
  *(_BYTE *)(v1 + 32021) = 0;
  *(_BYTE *)(v1 + 32022) = 0;
  *(_DWORD *)(v1 + 32024) = 0;
  *(_BYTE *)(v1 + 32028) = 0;
  *(_BYTE *)(v1 + 52877) = 4;
  *(_DWORD *)(v1 + 52888) = sub_100405D0(v9);
  *(_BYTE *)(v1 + 52843) = 0;
  *(_BYTE *)(v1 + 52844) = 0;
  *(_BYTE *)(v1 + 52845) = 0;
  *(_DWORD *)(v1 + 52892) = 0;
  *(_DWORD *)(v1 + 52896) = 0;
  strcpy((char *)(v1 + 52824), "--");
  sub_10016BE0(37, (_BYTE *)(v1 + 52904));
  if ( sub_10016380(9201, v1 + 52884, 4) )
  {
    *(_DWORD *)(v1 + 52884) = 0;
    sub_10016450(9201, v1 + 52884, 4);
  }
  if ( sub_10016380(9202, v1 + 52876, 1) )
  {
    *(_BYTE *)(v1 + 52876) = 0;
    sub_10016450(9202, v1 + 52876, 1);
  }
  v18 = 0;
  sub_100163E0(41095, (void *)(v1 + 31235), 1, &v18);
  v24 = 0;
  sub_100163E0(41094, (void *)(v1 + 31236), 4, &v24);
  v19 = 0;
  sub_100163E0(9175, (void *)(v1 + 31864), 1, &v19);
  sub_10040550((void *)(v1 + 31856));
  *(float *)(v1 + 31868) = *(float *)(v1 + 31856);
  v20 = 1;
  sub_100163E0(9152, (void *)(v1 + 52841), 1, &v20);
  sub_1003F6F0(*(_BYTE *)(v1 + 52841));
  if ( sub_10016380(9159, v1 + 52842, 1) )
  {
    *(_BYTE *)(v1 + 52842) = 0;
    sub_10003B50(0);
  }
  v21 = 0;
  sub_100163E0(9186, &v22, 1, &v21);
  v10 = v22;
  if ( v22 == 1 )
  {
    *(_WORD *)(v1 + 52830) = 1754;
LABEL_15:
    *(_BYTE *)(v1 + 52840) = 0;
    goto LABEL_16;
  }
  *(_WORD *)(v1 + 52830) = 6;
  if ( v10 != 2 )
    goto LABEL_15;
  *(_BYTE *)(v1 + 52840) = 1;
LABEL_16:
  v23 = 0;
  sub_100163E0(9187, (void *)(v1 + 52845), 1, &v23);
  *(_BYTE *)(v1 + 52845) &= ~*(_BYTE *)(v1 + 52888);
  sub_10016450(9187, v1 + 52845, 1);
  if ( *(_BYTE *)(v1 + 52845) )
  {
    sub_1003F2B0((void *)(v1 + 52836));
  }
  else
  {
    sub_1003F2E0((float *)(v1 + 52836));
    v25 = sub_100707A0(*(float *)(v1 + 52836), 1.0);
    v11 = v25;
    *(float *)(v1 + 52836) = v25;
    v12 = v11;
    sub_1003F710(SLOBYTE(v12));
  }
  if ( *(_BYTE *)(v1 + 52873) )
  {
    sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10089080, v1, 0, 255);
    v17 = v1 + 92;
    v16 = (char *)&unk_10089278;
    v15 = *(_WORD **)(a1 + 52);
  }
  else
  {
    sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_10088FC0, v1, 0, 255);
    v17 = v1 + 92;
    v16 = (char *)&unk_10089140;
    v15 = *(_WORD **)(a1 + 52);
  }
  sub_10038CD0(a1, v15, v16, v17, 0, 255);
  *(_BYTE *)(v1 + 52900) = 0;
  *(_BYTE *)(v1 + 52901) = 0;
  *(_BYTE *)(v1 + 52902) = 0;
  sub_10004220(a1, v13, 1);
  sub_100017F0(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001E70(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10009550) --------------------------------------------------------
char __cdecl sub_10009550(int a1)
{
  sub_10003B50(0);
  return sub_10003AE0(a1, 1);
}

//----- (10009570) --------------------------------------------------------
void __usercall sub_10009570(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@1
  char v4; // al@2
  double v5; // st7@11
  float v6; // ST10_4@11
  double v7; // st7@16
  float v8; // ST10_4@16
  char v9; // dl@21
  int v10; // ecx@22
  double v11; // st7@26
  char v12; // dl@28
  double v13; // st7@30
  double v14; // st7@31
  double v15; // st7@35
  float v16; // ST10_4@39
  int v17; // eax@39
  char v18; // al@40
  char v19; // [sp+12h] [bp-6h]@2
  char v20; // [sp+13h] [bp-5h]@2
  float v21; // [sp+14h] [bp-4h]@11

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = *(_DWORD *)(a1 + 52);
  switch ( *(_BYTE *)(v3 + 8) )
  {
    case 0x19:
      *(_BYTE *)(v2 + 52875) = 1;
      sub_10004220(a1, v3, 1);
      v20 = 0;
      sub_100163E0(9186, &v19, 1, &v20);
      v4 = v19;
      if ( v19 == 1 )
      {
        *(_BYTE *)(v2 + 52840) = 0;
        *(_WORD *)(v2 + 52830) = 1754;
      }
      else
      {
        *(_WORD *)(v2 + 52830) = 6;
        if ( v4 == 2 )
        {
          *(_BYTE *)(v2 + 52840) = 1;
        }
        else
        {
          *(_DWORD *)(v2 + 52832) = 0;
          *(_BYTE *)(v2 + 52840) = 0;
        }
      }
      return;
    case 0x2A:
      *(_BYTE *)(v2 + 52845) &= ~*(_BYTE *)(v2 + 52888);
      *(_BYTE *)(v2 + 52875) = 0;
      sub_10016450(9187, v2 + 52845, 1);
      if ( !*(_BYTE *)(v2 + 52845) )
      {
        *(_DWORD *)(v2 + 52832) = 0;
        *(_BYTE *)(v2 + 52840) = 0;
        v19 = 0;
        sub_10016450(9186, (int)&v19, 1);
        *(_WORD *)(v2 + 52830) = 6;
      }
      return;
    case 0x23:
      sub_10003B50(1);
      return;
    case 0x24:
      sub_10003B50(0);
      return;
    case 0x25:
      *(_WORD *)(v2 + 52830) = 6;
      *(_DWORD *)(v2 + 52832) = 0;
      *(_BYTE *)(v2 + 52840) = 0;
      v19 = 0;
      sub_10016450(9186, (int)&v19, 1);
      v21 = *(float *)(v2 + 52836) - 1.0;
      v5 = v21;
      *(float *)(v2 + 52836) = v21;
      v6 = v5;
      sub_1003F710(SLOBYTE(v6));
      if ( sub_10070770(*(float *)(v2 + 52836)) <= -99 )
      {
        *(_BYTE *)(v2 + 52844) = 1;
        sub_10014250(37, 0, 1);
      }
      if ( *(_BYTE *)(v2 + 52843) )
      {
        *(_BYTE *)(v2 + 52843) = 0;
        sub_10014250(38, 0, 0);
      }
      sub_10002C20((char *)(v2 + 52845), *(_BYTE *)(v2 + 52888));
      return;
    case 0x26:
      *(_WORD *)(v2 + 52830) = 6;
      *(_DWORD *)(v2 + 52832) = 0;
      *(_BYTE *)(v2 + 52840) = 0;
      v19 = 0;
      sub_10016450(9186, (int)&v19, 1);
      v21 = *(float *)(v2 + 52836) + 1.0;
      v7 = v21;
      *(float *)(v2 + 52836) = v21;
      v8 = v7;
      sub_1003F710(SLOBYTE(v8));
      if ( sub_10070770(*(float *)(v2 + 52836)) >= 99 )
      {
        *(_BYTE *)(v2 + 52843) = 1;
        sub_10014250(38, 0, 1);
      }
      if ( *(_BYTE *)(v2 + 52844) )
      {
        *(_BYTE *)(v2 + 52844) = 0;
        sub_10014250(37, 0, 0);
      }
      sub_10002C20((char *)(v2 + 52845), *(_BYTE *)(v2 + 52888));
      return;
    case 0x27:
      *(_WORD *)(v2 + 52830) = 6;
      *(_DWORD *)(v2 + 52832) = 0;
      *(_BYTE *)(v2 + 52840) = 0;
      v19 = 0;
      sub_10016450(9186, (int)&v19, 1);
      v9 = 1;
      goto LABEL_22;
    case 0x28:
      *(_WORD *)(v2 + 52830) = 6;
      *(_DWORD *)(v2 + 52832) = 0;
      *(_BYTE *)(v2 + 52840) = 0;
      v19 = 0;
      sub_10016450(9186, (int)&v19, 1);
      v9 = 0;
LABEL_22:
      sub_10003AE0(v1, v9);
      sub_10004220(v1, v10, 1);
      return;
    case 0x29:
      *(_DWORD *)(v2 + 52832) = sub_100160A0();
      *(_BYTE *)(v2 + 52840) = 0;
      v19 = 0;
      sub_10016450(9186, (int)&v19, 1);
      *(_WORD *)(v2 + 52830) = 6;
      sub_1003F680();
      return;
    case 0x1B:
      if ( 9.8999998e24 == *(float *)(v2 + 392) )
        v11 = 2438.3999;
      else
        v11 = *(float *)(v2 + 396);
      v12 = *(_BYTE *)(v2 + 31864);
      *(float *)(v2 + 31856) = v11;
      *(_BYTE *)(v2 + 31852) = 1;
      *(_DWORD *)(v2 + 31860) = 0;
      *(_BYTE *)(v2 + 31876) = v12;
      *(_BYTE *)(v2 + 31864) = 0;
      sub_10004220(a1, v3, 1);
      return;
    case 0x2B:
      *(float *)(v2 + 31856) = *(float *)(v2 + 31880);
      return;
    case 0x2C:
      v13 = *(float *)(v2 + 396) + 152.3999938964844;
      goto LABEL_31;
    case 0x2E:
      v13 = *(float *)(v2 + 396) + 15.23999977111816;
LABEL_31:
      v21 = v13;
      v14 = v21;
      if ( v21 > 4267.5048828125 )
        v14 = 4267.5049;
      goto LABEL_33;
    case 0x2D:
      v15 = *(float *)(v2 + 396) - 152.3999938964844;
      goto LABEL_36;
    case 0x2F:
      v15 = *(float *)(v2 + 396) - 15.23999977111816;
LABEL_36:
      v21 = v15;
      v14 = v21;
      if ( v21 >= -305.1047973632812 )
      {
LABEL_33:
        v21 = v14;
        *(float *)(v2 + 31856) = v21;
      }
      else
      {
        v21 = -305.1048;
        *(float *)(v2 + 31856) = -305.1048;
      }
      break;
    case 0x30:
      v16 = *(float *)(v2 + 31856);
      sub_10040580(SLOBYTE(v16));
      v17 = sub_100160A0();
      *(float *)(v2 + 31868) = *(float *)(v2 + 31856);
      *(_DWORD *)(v2 + 31860) = v17;
      *(_DWORD *)(v2 + 31872) = 0;
      break;
    default:
      v18 = *(_BYTE *)(v2 + 31876);
      *(float *)(v2 + 31856) = *(float *)(v2 + 31868);
      *(_BYTE *)(v2 + 31852) = 0;
      *(_BYTE *)(v2 + 31864) = v18;
      break;
  }
}

//----- (10009A80) --------------------------------------------------------
void __cdecl sub_10009A80(int a1)
{
  int v1; // ecx@1
  int v2; // ebp@1
  double v3; // st7@2
  float *v4; // eax@4
  signed int v5; // ecx@4
  unsigned int v6; // esi@6
  double v7; // st7@7
  int v8; // eax@7
  double v9; // st7@10
  unsigned int v10; // esi@14
  double v11; // st7@15
  int v12; // eax@15
  double v13; // st7@16
  double v14; // st7@22
  double v15; // st7@25
  double v16; // st7@28
  bool v17; // al@63
  bool v18; // al@71
  int *v19; // edi@78
  int *v20; // esi@80
  int *v21; // edi@85
  int *v22; // esi@87
  float *v23; // esi@94
  _BYTE *v24; // edi@100
  int *v25; // esi@100
  char v26; // al@100
  double v27; // st7@112
  char v28; // bl@113
  double v29; // st7@115
  char v30; // al@130
  bool v31; // bl@133
  bool v32; // zf@140
  int v33; // ecx@145
  int v34; // ecx@158
  char v35; // [sp+29h] [bp-47h]@138
  int v36; // [sp+2Ah] [bp-46h]@54
  int v37; // [sp+30h] [bp-40h]@56
  float v38; // [sp+34h] [bp-3Ch]@1
  float v39; // [sp+38h] [bp-38h]@1
  float v40; // [sp+3Ch] [bp-34h]@9
  int v41; // [sp+40h] [bp-30h]@34
  int v42; // [sp+44h] [bp-2Ch]@98
  float v43; // [sp+48h] [bp-28h]@110
  float v44; // [sp+4Ch] [bp-24h]@4
  char v45[4]; // [sp+50h] [bp-20h]@2
  float v46; // [sp+54h] [bp-1Ch]@21
  float v47; // [sp+58h] [bp-18h]@24
  int v48; // [sp+5Ch] [bp-14h]@100
  int v49; // [sp+60h] [bp-10h]@111
  float v50; // [sp+64h] [bp-Ch]@117
  int v51[2]; // [sp+68h] [bp-8h]@115

  v38 = 0.0;
  v1 = *(_DWORD *)(a1 + 56);
  v39 = 0.0;
  v2 = *(_DWORD *)(v1 + 12);
  if ( *(_BYTE *)dword_102D2B4C == 31 )
  {
    *(float *)v45 = 0.0028206001;
    v3 = 34473.789;
  }
  else
  {
    *(float *)v45 = 0.0058761998;
    v3 = 2068.3899;
  }
  v44 = v3;
  v4 = (float *)(v2 + 116);
  v5 = 32;
  do
  {
    *v4 = 9.8999998e24;
    v4 += 3;
    --v5;
  }
  while ( v5 );
  v6 = 0;
  do
  {
    v7 = sub_100236F0(word_10088032[v6]);
    v8 = (unsigned __int8)byte_10088030[v6 * 2];
    v6 += 2;
    *(float *)(v2 + 12 * v8 + 116) = v7;
  }
  while ( v6 < 44 );
  if ( *(_BYTE *)dword_102D2B4C == 38 )
  {
    if ( sub_1003F220(6, 151, 0, 4, &v40) )
    {
      *(float *)(v2 + 488) = v40 * 57.29578018188477;
      v9 = 9.8999998e24;
      goto LABEL_14;
    }
  }
  else if ( sub_1003F220(0, 58, 0, 4, &v40) )
  {
    *(float *)(v2 + 488) = v40;
    v9 = 9.8999998e24;
    goto LABEL_14;
  }
  v9 = 9.8999998e24;
  *(float *)(v2 + 488) = 9.8999998e24;
LABEL_14:
  *(float *)(v2 + 496) = v9;
  v10 = 0;
  *(float *)(v2 + 500) = v9;
  *(float *)(v2 + 504) = v9;
  *(float *)(v2 + 508) = v9;
  *(float *)(v2 + 512) = v9;
  *(float *)(v2 + 516) = v9;
  do
  {
    v11 = sub_100236F0(word_1008801A[v10]);
    v12 = (unsigned __int8)byte_10088018[v10 * 2];
    v10 += 2;
    *(float *)(v2 + 4 * v12 + 496) = v11;
  }
  while ( v10 < 12 );
  v13 = v44;
  if ( v44 >= (double)*(float *)(v2 + 140) )
    *(float *)(v2 + 140) = 0.0;
  if ( *(float *)(v2 + 152) <= v13 )
    *(float *)(v2 + 152) = 0.0;
  if ( sub_1003E540((int)"ELEC EMERGENCY") )
  {
    if ( sub_1003F220(1, 877, 0, 4, &v46) )
      v14 = v46;
    else
      v14 = 9.8999998e24;
    *(float *)(v2 + 260) = v14;
    if ( sub_1003F220(1, 920, 0, 4, &v47) )
      v15 = v47;
    else
      v15 = 9.8999998e24;
    *(float *)(v2 + 272) = v15;
  }
  v16 = *(float *)v45;
  if ( *(float *)v45 >= (double)*(float *)(v2 + 260) )
    *(float *)(v2 + 260) = 0.0;
  if ( *(float *)(v2 + 272) <= v16 )
    *(float *)(v2 + 272) = 0.0;
  if ( sub_1003F220(1, 875, 0, 4, &v38)
    && sub_1003F220(1, 876, 0, 4, &v39)
    && sub_1003F220(1, 858, 0, 4, &v41)
    && v41 & 0x4000000
    && v39 < (double)v38 )
  {
    *(float *)(v2 + 532) = v39;
    *(float *)(v2 + 536) = v38;
    sub_10034CB0((_BYTE *)(v2 + 520), v2 + 848);
  }
  else
  {
    sub_10034CB0((_BYTE *)(dword_102D2B4C + 3912), v2 + 848);
  }
  if ( sub_1003F220(1, 918, 0, 4, &v38)
    && sub_1003F220(1, 919, 0, 4, &v39)
    && sub_1003F220(1, 901, 0, 4, &v41)
    && v41 & 0x4000000
    && v39 < (double)v38 )
  {
    *(float *)(v2 + 696) = v39;
    *(float *)(v2 + 700) = v38;
    sub_10034CB0((_BYTE *)(v2 + 684), v2 + 6444);
  }
  else
  {
    sub_10034CB0((_BYTE *)(dword_102D2B4C + 3912), v2 + 6444);
  }
  sub_10003C50((_BYTE *)(v2 + 12062), (float *)(v2 + 12048), (float *)(v2 + 12052));
  if ( !sub_10040700(0x57u, (float *)(v2 + 12040)) )
    *(float *)(v2 + 12040) = 9.8999998e24;
  if ( !sub_10040700(0x58u, (float *)(v2 + 12044)) )
    *(float *)(v2 + 12044) = 9.8999998e24;
  if ( !sub_1003F220(1, 1449, 9, 1, (void *)(v2 + 12060)) )
    *(_BYTE *)(v2 + 12060) = 0;
  if ( !sub_1003F220(1, 1449, 10, 1, (void *)(v2 + 12061)) )
    *(_BYTE *)(v2 + 12061) = 0;
  *(_BYTE *)(v2 + 12058) = 0;
  *(_BYTE *)(v2 + 12059) = 0;
  if ( sub_1003F220(0, 233, 0, 4, (char *)&v36 + 2) )
    *(_BYTE *)(v2 + 12058) = (*(int *)((char *)&v36 + 2) & 0x10000) == 0x10000;
  if ( sub_1003F220(0, 236, 0, 4, &v37) )
    *(_BYTE *)(v2 + 12059) = (v37 & 0x10000) == 0x10000;
  *(_BYTE *)(v2 + 12056) = 0;
  *(_BYTE *)(v2 + 52846) = 0;
  *(_BYTE *)(v2 + 52847) = 0;
  if ( sub_1003F220(0, 234, 0, 4, (char *)&v36 + 2) )
  {
    *(_BYTE *)(v2 + 12056) = (HIWORD(v36) & 0x800) == 2048;
    *(_BYTE *)(v2 + 52846) = (HIWORD(v36) & 0x400) == 1024;
  }
  if ( sub_1003F220(0, 235, 0, 4, (char *)&v36 + 2) )
  {
    v17 = *(_BYTE *)(v2 + 12056) || HIWORD(v36) & 0x800;
    *(_BYTE *)(v2 + 12056) = v17;
    *(_BYTE *)(v2 + 52847) = (HIWORD(v36) & 0x400) == 1024;
  }
  *(_BYTE *)(v2 + 12057) = 0;
  *(_BYTE *)(v2 + 52848) = 0;
  *(_BYTE *)(v2 + 52849) = 0;
  if ( sub_1003F220(0, 237, 0, 4, &v37) )
  {
    *(_BYTE *)(v2 + 12057) = (v37 & 0x800) == 2048;
    *(_BYTE *)(v2 + 52848) = (v37 & 0x400) == 1024;
  }
  if ( sub_1003F220(0, 238, 0, 4, &v37) )
  {
    v18 = *(_BYTE *)(v2 + 12057) || v37 & 0x800;
    *(_BYTE *)(v2 + 12057) = v18;
    *(_BYTE *)(v2 + 52849) = (v37 & 0x400) == 1024;
  }
  if ( !sub_10040380(65, (void *)(v2 + 23256)) )
    *(_BYTE *)(v2 + 23256) = 0;
  if ( !sub_10040380(66, (void *)(v2 + 23257)) )
    *(_BYTE *)(v2 + 23257) = 0;
  v19 = (int *)(v2 + 23260);
  if ( !sub_1003F220(1, 973, 0, 4, (void *)(v2 + 23260)) )
    *v19 = -1;
  v20 = (int *)(v2 + 23264);
  if ( !sub_1003F220(1, 979, 0, 4, (void *)(v2 + 23264)) )
    *v20 = -1;
  if ( *(_BYTE *)(v2 + 52847) && !*(_BYTE *)(v2 + 52846) )
  {
    *(int *)((char *)&v36 + 2) = *v20;
    *v20 = *v19;
    *v19 = *(int *)((char *)&v36 + 2);
  }
  v21 = (int *)(v2 + 23268);
  if ( !sub_1003F220(1, 985, 0, 4, (void *)(v2 + 23268)) )
    *v21 = -1;
  v22 = (int *)(v2 + 23272);
  if ( !sub_1003F220(1, 991, 0, 4, (void *)(v2 + 23272)) )
    *v22 = -1;
  if ( *(_BYTE *)(v2 + 52849) && !*(_BYTE *)(v2 + 52848) )
  {
    v37 = *v22;
    *v22 = *v21;
    *v21 = v37;
  }
  if ( *(_BYTE *)(v2 + 31852) )
  {
    *(float *)(v2 + 392) = *(float *)(v2 + 31856);
  }
  else
  {
    v23 = (float *)(v2 + 392);
    if ( !sub_10040700(0xC5u, (float *)(v2 + 392)) || *v23 < -305.1048 || *v23 > 4267.5049 )
      *v23 = 9.8999998e24;
  }
  *(_BYTE *)(v2 + 31232) = 0;
  *(_BYTE *)(v2 + 31233) = 0;
  *(_BYTE *)(v2 + 31234) = 0;
  if ( sub_1003F220(1, 743, 0, 4, &v42) )
  {
    *(_BYTE *)(v2 + 31232) = (unsigned __int16)(v42 & 0x8000) == 0x8000;
    *(_BYTE *)(v2 + 31233) = (v42 & 0x82000) != 0;
    *(_BYTE *)(v2 + 31234) = (v42 & 0x10000000) == 0x10000000;
  }
  v24 = (_BYTE *)(v2 + 31235);
  BYTE1(v36) = 0;
  sub_100163E0(41095, (void *)(v2 + 31235), 1, (char *)&v36 + 1);
  v25 = (int *)(v2 + 31236);
  v48 = 0;
  sub_100163E0(41094, (void *)(v2 + 31236), 4, &v48);
  v26 = *(_BYTE *)(v2 + 31234);
  if ( !v26 )
    goto LABEL_170;
  if ( !*v24 )
  {
    *v24 = 1;
LABEL_109:
    sub_10016450(41095, v2 + 31235, 1);
    *v25 = 0;
    sub_10016450(41094, v2 + 31236, 4);
    goto LABEL_110;
  }
  if ( !v26 )
  {
LABEL_170:
    if ( *v24 )
    {
      if ( *v25 )
      {
        if ( (unsigned int)(sub_100160A0() - *v25) > 0x493E0 )
        {
          *v24 = 0;
          goto LABEL_109;
        }
      }
      else
      {
        *v25 = sub_100160A0();
        sub_10016450(41094, v2 + 31236, 4);
      }
    }
  }
LABEL_110:
  if ( sub_10040700(0x75u, &v43)
    && sub_10040660(v43, (int)&v49)
    && (v27 = *(float *)&v49, *(float *)v45 = *(float *)&v49, (v49 & 0x7F800000) != 2139095040) )
  {
    v28 = 1;
  }
  else
  {
    v27 = 9.8999998e24;
    v28 = 0;
    v43 = 9.8999998e24;
  }
  *(float *)(v2 + 31980) = v27;
  v29 = *(float *)(v2 + 31980);
  v45[0] = v28;
  sub_10070560(v28, v29, v2 + 31932, v2 + 31888, (int)&v36, (int)v51);
  *(float *)(v2 + 31984) = 9.8999998e24;
  if ( (_BYTE)v36 )
    *(float *)(v2 + 31984) = *(double *)v51;
  *(float *)(v2 + 31988) = 9.8999998e24;
  if ( sub_10025580(&v50) && v43 != 9.8999998e24 )
    *(float *)(v2 + 31988) = v43 - v50;
  if ( 9.8999998e24 == *(float *)(v2 + 368) && v28 )
    *(float *)(v2 + 368) = *(float *)(v2 + 31980);
  if ( 9.8999998e24 == *(float *)(v2 + 380) && (_BYTE)v36 )
    *(float *)(v2 + 380) = *(float *)(v2 + 31984);
  if ( 9.8999998e24 == *(float *)(v2 + 404) )
    *(float *)(v2 + 404) = *(float *)(v2 + 31988);
  if ( !sub_1003F380((float *)(v2 + 416)) )
    *(float *)(v2 + 416) = 9.8999998e24;
  *(_BYTE *)(v2 + 31992) = sub_10003B70(v2 + 31996, 249, 26);
  *(_BYTE *)(v2 + 31994) = sub_10003B70(v2 + 32020, 264, 28);
  v30 = sub_10003B70(v2 + 32008, 253, 27);
  *(float *)(v2 + 428) = 9.8999998e24;
  *(float *)(v2 + 440) = 9.8999998e24;
  *(_BYTE *)(v2 + 31993) = v30;
  *(float *)(v2 + 452) = 9.8999998e24;
  *(float *)(v2 + 464) = 9.8999998e24;
  *(float *)(v2 + 476) = 9.8999998e24;
  if ( *(_BYTE *)dword_102D2B4C == 31 )
    sub_10003E70(a1);
  else
    sub_100040A0(a1);
  v31 = sub_1003E540((int)"_eng_no_to_1") == 0;
  if ( !*(_BYTE *)(v2 + 52874)
    || *(_DWORD *)(v2 + 52832) <= 0u
    || sub_100160A0() <= (unsigned int)(*(_DWORD *)(v2 + 52832) + 5000)
    || *(_BYTE *)(v2 + 52840) )
  {
    if ( v31
      && *(_BYTE *)(v2 + 52874)
      && *(_DWORD *)(v2 + 52832) > 0u
      && sub_100160A0() > (unsigned int)(*(_DWORD *)(v2 + 52832) + 10000) )
    {
      *(_DWORD *)(v2 + 52832) = 0;
      sub_10004220(a1, v33, 0);
      sub_100142F0(3);
      *(_BYTE *)(v2 + 52875) = 0;
      *(_WORD *)(v2 + 52830) = 6;
      *(_BYTE *)(v2 + 52840) = 0;
      v35 = 0;
      sub_10016450(9186, (int)&v35, 1);
    }
  }
  else if ( v31 )
  {
    *(_BYTE *)(v2 + 52840) = 1;
    v35 = 2;
    sub_10016450(9186, (int)&v35, 1);
    v32 = *(_BYTE *)(v2 + 52845) == 0;
    *(_WORD *)(v2 + 52830) = 6;
    if ( !v32 )
    {
      *(_BYTE *)(v2 + 52845) = 0;
      sub_10016450(9187, v2 + 52845, 1);
    }
  }
  else
  {
    *(_WORD *)(v2 + 52830) = 1754;
    *(_DWORD *)(v2 + 52832) = 0;
    v35 = 1;
    sub_10016450(9186, (int)&v35, 1);
    if ( *(_BYTE *)(v2 + 52845) )
    {
      *(_BYTE *)(v2 + 52845) = 0;
      sub_10016450(9187, v2 + 52845, 1);
    }
  }
  if ( *(_DWORD *)(v2 + 31860) > 0u && sub_100160A0() > (unsigned int)(*(_DWORD *)(v2 + 31860) + 1000) )
  {
    *(_BYTE *)(v2 + 31853) = *(_BYTE *)(v2 + 31852);
    *(_BYTE *)(v2 + 31852) = 0;
    *(_DWORD *)(v2 + 31860) = 0;
    *(_BYTE *)(v2 + 31864) = 1;
    sub_10016450(9175, v2 + 31864, 1);
  }
  sub_10023690(v2 + 112, 0x20u);
  if ( 9.8999998e24 == *(float *)(v2 + 192) || 9.8999998e24 == *(float *)(v2 + 204) )
    *(float *)(v2 + 240) = 9.8999998e24;
  else
    *(float *)(v2 + 240) = *(float *)(v2 + 204) + *(float *)(v2 + 192);
  if ( 9.8999998e24 == *(float *)(v2 + 216) || 9.8999998e24 == *(float *)(v2 + 228) )
    *(float *)(v2 + 252) = 9.8999998e24;
  else
    *(float *)(v2 + 252) = *(float *)(v2 + 228) + *(float *)(v2 + 216);
  v34 = dword_102D2B4C;
  if ( *(float *)(dword_102D2B4C + 20564) > (double)*(float *)(v2 + 192)
    || *(float *)(dword_102D2B4C + 20568) < (double)*(float *)(v2 + 192)
    || *(float *)(dword_102D2B4C + 20564) > (double)*(float *)(v2 + 204)
    || *(float *)(dword_102D2B4C + 20568) < (double)*(float *)(v2 + 204) )
  {
    *(float *)(v2 + 240) = 9.8999998e24;
    v34 = dword_102D2B4C;
  }
  if ( *(float *)(v34 + 20620) > (double)*(float *)(v2 + 216)
    || *(float *)(v34 + 20624) < (double)*(float *)(v2 + 216)
    || *(float *)(v34 + 20620) > (double)*(float *)(v2 + 228)
    || *(float *)(v34 + 20624) < (double)*(float *)(v2 + 228) )
  {
    *(float *)(v2 + 252) = 9.8999998e24;
  }
}
// 1008801A: using guessed type __int16 word_1008801A[];
// 10088032: using guessed type __int16 word_10088032[];
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000A7D0) --------------------------------------------------------
void __cdecl sub_1000A7D0(int a1)
{
  int v1; // ecx@1
  int v2; // esi@1
  char v3; // al@1
  bool v4; // c3@1
  bool v5; // c3@3
  bool v6; // dl@7
  char v7; // dl@9
  float *v8; // ecx@28
  double v9; // st7@30
  bool v10; // dl@34
  float *v11; // ecx@36
  char v12; // dl@36
  double v13; // st7@38
  char v14; // bl@40
  int v15; // edx@43
  bool v16; // bl@64
  bool v17; // dl@68
  char v18; // dl@70
  float *v19; // ecx@73
  double v20; // st7@75
  char v21; // cl@77
  bool v22; // bl@79
  bool v23; // dl@83
  char v24; // dl@85
  float *v25; // ecx@88
  double v26; // st7@90
  char v27; // bl@92
  char v28; // dl@92
  char v29; // dl@106
  char v30; // dl@112
  char v31; // dl@126
  double v32; // st7@133
  double v33; // st7@136
  double v34; // st7@137
  char v35; // bl@138
  char v36; // al@138
  char v37; // cl@145
  bool v38; // c3@161
  bool v39; // zf@180
  int v40; // eax@181
  int *v41; // edi@195
  _BYTE *v42; // ebp@195
  double v43; // st7@195
  double v44; // st7@219
  bool v45; // c3@222
  char v46; // al@240
  int v47; // [sp+0h] [bp-54h]@136
  const char *v48; // [sp+4h] [bp-50h]@136
  char v49; // [sp+24h] [bp-30h]@144
  char v50; // [sp+25h] [bp-2Fh]@1
  char v51; // [sp+26h] [bp-2Eh]@1
  char v52; // [sp+27h] [bp-2Dh]@1
  int v53; // [sp+28h] [bp-2Ch]@9
  int v54; // [sp+2Ch] [bp-28h]@1
  int v55; // [sp+30h] [bp-24h]@1
  int v56; // [sp+34h] [bp-20h]@1
  float v57; // [sp+38h] [bp-1Ch]@16
  float v58; // [sp+3Ch] [bp-18h]@213
  int v59; // [sp+40h] [bp-14h]@10
  float v60; // [sp+44h] [bp-10h]@1
  float v61; // [sp+48h] [bp-Ch]@1
  int v62; // [sp+4Ch] [bp-8h]@75
  int v63; // [sp+50h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v61 = 0.0;
  v2 = *(_DWORD *)(v1 + 12);
  v60 = 0.0;
  v63 = 0;
  v52 = 0;
  v50 = sub_1003F220(1, 857, 0, 4, &v55);
  v3 = sub_1003F220(1, 900, 0, 4, &v56);
  v54 = *(int *)(v2 + 496);
  v51 = v3;
  sub_10035DF0(*(float *)&v54, -0.30000001, 2, v2 + 848);
  v4 = 9.8999998e24 == *(float *)&v54;
  *(_DWORD *)(v2 + 3388) = -65536;
  if ( v4 )
    *(_BYTE *)(v2 + 3392) = 1;
  v54 = *(int *)(v2 + 500);
  sub_10035DF0(*(float *)&v54, -0.30000001, 2, v2 + 6444);
  v5 = 9.8999998e24 == *(float *)&v54;
  *(_DWORD *)(v2 + 8984) = -65536;
  if ( v5 )
    *(_BYTE *)(v2 + 8988) = 1;
  v6 = v50 && v55 & 0x800;
  LOBYTE(v53) = v6;
  sub_10003B10((_DWORD *)(v2 + 3156), (_DWORD *)(v2 + 3160), v6, 0);
  *(_DWORD *)(v2 + 2952) = v7 != 0 ? -65536 : -8355712;
  if ( *(_BYTE *)dword_102D2B4C == 38 )
  {
    v59 = 0;
    if ( ((*(_BYTE *)(v2 + 52846) || !*(_BYTE *)(v2 + 52847)) && sub_1003F220(1, 1342, 0, 4, &v59)
       || !*(_BYTE *)(v2 + 52846) && sub_1003F220(1, 1343, 0, 4, &v59))
      && v59 & 0x40000
      && sub_1003F220(1, 1276, 0, 4, &v57) )
    {
      v57 = v57 * 0.009999999776482582;
      sub_10035080(v57, 0.30000001, 5.0, 3, v2 + 848);
      *(_DWORD *)(v2 + 3452) = -16711681;
    }
    else
    {
      *(_BYTE *)(v2 + 3456) = 1;
    }
    if ( ((*(_BYTE *)(v2 + 52848) || !*(_BYTE *)(v2 + 52849)) && sub_1003F220(1, 1344, 0, 4, &v59)
       || !*(_BYTE *)(v2 + 52848) && sub_1003F220(1, 1345, 0, 4, &v59))
      && v59 & 0x40000
      && sub_1003F220(1, 1277, 0, 4, &v57) )
    {
      v57 = v57 * 0.009999999776482582;
      sub_10035080(v57, 0.30000001, 5.0, 3, v2 + 6444);
      *(_DWORD *)(v2 + 9048) = -16711681;
    }
    else
    {
      *(_BYTE *)(v2 + 9052) = 1;
    }
  }
  v8 = *(float **)(v2 + 3168);
  if ( *(float *)(v2 + 3176) < (double)*v8 || *(float *)(v2 + 3172) > (double)*v8 )
  {
    v54 = *(_BYTE *)(v2 + 52873) != 0 ? 65 : 88;
    v9 = (double)v54;
  }
  else
  {
    v54 = *(_BYTE *)(v2 + 52873) != 0 ? 70 : 96;
    v9 = (double)v54;
  }
  v39 = v51 == 0;
  *(float *)(v2 + 3152) = v9;
  v10 = !v39 && v56 & 0x800;
  LOBYTE(v53) = v10;
  sub_10003B10((_DWORD *)(v2 + 8752), (_DWORD *)(v2 + 8756), v10, 0);
  v11 = *(float **)(v2 + 8764);
  *(_DWORD *)(v2 + 8548) = v12 != 0 ? -65536 : -8355712;
  if ( *(float *)(v2 + 8772) < (double)*v11 || *(float *)(v2 + 8768) > (double)*v11 )
  {
    v54 = *(_BYTE *)(v2 + 52873) != 0 ? 65 : 88;
    v13 = (double)v54;
  }
  else
  {
    v54 = *(_BYTE *)(v2 + 52873) != 0 ? 70 : 96;
    v13 = (double)v54;
  }
  v14 = v50;
  *(float *)(v2 + 8748) = v13;
  if ( !v14 || (LOBYTE(v53) = 1, !(v55 & 0x2000)) )
    LOBYTE(v53) = 0;
  sub_10003B10((_DWORD *)(v2 + 23312), (_DWORD *)(v2 + 23316), v53, 0);
  if ( !v51 || (LOBYTE(v53) = 1, !(v15 & v56)) )
    LOBYTE(v53) = 0;
  sub_10003B10((_DWORD *)(v2 + 23360), (_DWORD *)(v2 + 23364), v53, 0);
  if ( v14 && v55 & 0x400000 )
    sub_10003E20(2, v2 + 12064, *(float *)(v2 + 512), -0.30000001, -256);
  else
    *(_BYTE *)(v2 + 14608) = 1;
  if ( v50 && v55 & 0x2000000 )
    sub_10003E20(3, v2 + 12064, *(float *)(v2 + 504), -0.30000001, -65536);
  else
    *(_BYTE *)(v2 + 14672) = 1;
  if ( v51 && v56 & 0x400000 )
    sub_10003E20(2, v2 + 17660, *(float *)(v2 + 516), -0.30000001, -256);
  else
    *(_BYTE *)(v2 + 20204) = 1;
  if ( v51 && v56 & 0x2000000 )
    sub_10003E20(3, v2 + 17660, *(float *)(v2 + 508), -0.30000001, -65536);
  else
    *(_BYTE *)(v2 + 20268) = 1;
  v16 = v50 && v55 & 0x10000;
  LOBYTE(v53) = v16;
  v17 = v50 && v55 & 0x40000;
  LOBYTE(v54) = v17;
  sub_10003B10((_DWORD *)(v2 + 14372), (_DWORD *)(v2 + 14376), v53, v17);
  if ( v16 )
    *(_DWORD *)(v2 + 14168) = -65536;
  else
    *(_DWORD *)(v2 + 14168) = v18 != 0 ? -256 : -8355712;
  v19 = *(float **)(v2 + 14384);
  if ( *(float *)(v2 + 14392) < (double)*v19 || *(float *)(v2 + 14388) > (double)*v19 )
  {
    v62 = *(_BYTE *)(v2 + 52873) != 0 ? 155 : 190;
    v20 = (double)v62;
  }
  else
  {
    v62 = *(_BYTE *)(v2 + 52873) != 0 ? 160 : 198;
    v20 = (double)v62;
  }
  v21 = v51;
  *(float *)(v2 + 14368) = v20;
  v22 = v21 && v56 & 0x10000;
  LOBYTE(v53) = v22;
  v23 = v21 && v56 & 0x40000;
  LOBYTE(v54) = v23;
  sub_10003B10((_DWORD *)(v2 + 19968), (_DWORD *)(v2 + 19972), v53, v23);
  if ( v22 )
    *(_DWORD *)(v2 + 19764) = -65536;
  else
    *(_DWORD *)(v2 + 19764) = v24 != 0 ? -256 : -8355712;
  v25 = *(float **)(v2 + 19980);
  if ( *(float *)(v2 + 19988) < (double)*v25 || *(float *)(v2 + 19984) > (double)*v25 )
  {
    v62 = *(_BYTE *)(v2 + 52873) != 0 ? 155 : 190;
    v26 = (double)v62;
  }
  else
  {
    v62 = *(_BYTE *)(v2 + 52873) != 0 ? 160 : 198;
    v26 = (double)v62;
  }
  *(float *)(v2 + 19964) = v26;
  v27 = sub_1003F220(1, 856, 0, 4, &v55);
  v28 = sub_1003F220(1, 899, 0, 4, &v56);
  if ( v27 && v55 & 0x4000 )
    *(_DWORD *)(v2 + 23936) = &unk_10087FF4;
  else
    *(_DWORD *)(v2 + 23936) = v2 + 144;
  if ( v28 && v56 & 0x4000 )
    *(_DWORD *)(v2 + 23984) = &unk_10087FF4;
  else
    *(_DWORD *)(v2 + 23984) = v2 + 156;
  if ( !v27 || (LOBYTE(v54) = 1, !(v55 & 0x800)) )
    LOBYTE(v54) = 0;
  if ( !v27 || (LOBYTE(v53) = 1, !(v55 & 0x10000)) )
    LOBYTE(v53) = 0;
  sub_10003B10((_DWORD *)(v2 + 23924), (_DWORD *)(v2 + 23928), v53, v54);
  if ( !v29 || (LOBYTE(v54) = 1, !(v56 & 0x800)) )
    LOBYTE(v54) = 0;
  if ( !v29 || (LOBYTE(v53) = 1, !(v56 & 0x10000)) )
    LOBYTE(v53) = 0;
  sub_10003B10((_DWORD *)(v2 + 23972), (_DWORD *)(v2 + 23976), v53, v54);
  if ( v27 && v55 & 0x2000 )
    *(_DWORD *)(v2 + 24548) = &unk_10087FF4;
  else
    *(_DWORD *)(v2 + 24548) = v2 + 168;
  if ( v30 && v56 & 0x2000 )
    *(_DWORD *)(v2 + 24596) = &unk_10087FF4;
  else
    *(_DWORD *)(v2 + 24596) = v2 + 180;
  if ( !v27 || (LOBYTE(v54) = 1, !(v55 & 0x400)) )
    LOBYTE(v54) = 0;
  if ( !v27 || (LOBYTE(v53) = 1, !(v55 & 0x8000)) )
    LOBYTE(v53) = 0;
  sub_10003B10((_DWORD *)(v2 + 24536), (_DWORD *)(v2 + 24540), v53, v54);
  if ( !v31 || (LOBYTE(v54) = 1, !(v56 & 0x400)) )
    LOBYTE(v54) = 0;
  if ( !v31 || (LOBYTE(v53) = 1, !(v56 & 0x8000)) )
    LOBYTE(v53) = 0;
  sub_10003B10((_DWORD *)(v2 + 24584), (_DWORD *)(v2 + 24588), v53, v54);
  if ( sub_10040F90(*(_WORD *)(v2 + 25628), 0, 0) == 25 )
  {
    sub_10038450(v2 + 25304, "FF PPH", 21);
    v32 = 0.00031339945;
  }
  else
  {
    sub_10038450(v2 + 25304, "FF KPH", 21);
    v32 = 0.00034546363;
  }
  *(float *)(v2 + 256) = v32;
  *(float *)(v2 + 268) = v32;
  if ( sub_10040F90(0x1Eu, 0, 0) == 24 )
  {
    *(_DWORD *)(v2 + 25772) = v2 + 192;
    *(_DWORD *)(v2 + 25820) = v2 + 204;
    *(float *)(v2 + 25776) = *(float *)(dword_102D2B4C + 20564);
    *(float *)(v2 + 25780) = *(float *)(dword_102D2B4C + 20568);
    *(float *)(v2 + 25824) = *(float *)(dword_102D2B4C + 20564);
    *(float *)(v2 + 25828) = *(float *)(dword_102D2B4C + 20568);
    *(float *)(v2 + 25744) = *(float *)(dword_102D2B4C + 20564);
    v33 = *(float *)(dword_102D2B4C + 20568);
    *(_DWORD *)(v2 + 26384) = v2 + 240;
    *(float *)(v2 + 25748) = v33;
    *(float *)(v2 + 26388) = *(float *)(dword_102D2B4C + 20592);
    *(float *)(v2 + 26392) = *(float *)(dword_102D2B4C + 20596);
    *(float *)(v2 + 26356) = *(float *)(dword_102D2B4C + 20592);
    *(float *)(v2 + 26360) = *(float *)(dword_102D2B4C + 20596);
    sub_1001EBE0((_BYTE *)(dword_102D2B4C + 4404), v2 + 25724);
    v48 = "FQ LB";
    v47 = v2 + 25916;
  }
  else
  {
    *(_DWORD *)(v2 + 25772) = v2 + 216;
    *(_DWORD *)(v2 + 25820) = v2 + 228;
    *(float *)(v2 + 25776) = *(float *)(dword_102D2B4C + 20620);
    *(float *)(v2 + 25780) = *(float *)(dword_102D2B4C + 20624);
    *(float *)(v2 + 25824) = *(float *)(dword_102D2B4C + 20620);
    *(float *)(v2 + 25828) = *(float *)(dword_102D2B4C + 20624);
    *(float *)(v2 + 25744) = *(float *)(dword_102D2B4C + 20620);
    v34 = *(float *)(dword_102D2B4C + 20624);
    *(_DWORD *)(v2 + 26384) = v2 + 252;
    *(float *)(v2 + 25748) = v34;
    *(float *)(v2 + 26388) = *(float *)(dword_102D2B4C + 20648);
    *(float *)(v2 + 26392) = *(float *)(dword_102D2B4C + 20652);
    *(float *)(v2 + 26356) = *(float *)(dword_102D2B4C + 20648);
    *(float *)(v2 + 26360) = *(float *)(dword_102D2B4C + 20652);
    sub_1001EBE0((_BYTE *)(dword_102D2B4C + 4732), v2 + 25724);
    v48 = "FQ KG";
    v47 = v2 + 25916;
  }
  sub_10038450(v47, v48, 21);
  v35 = sub_1003F220(0, 364, 0, 4, &v55);
  v36 = sub_1003F220(0, 366, 0, 4, &v56);
  LOBYTE(v54) = v35 && v55 & 0x1400 || v36 && v56 & 0x1400;
  sub_10003B10((_DWORD *)(v2 + 26984), (_DWORD *)(v2 + 26988), 0, v54);
  if ( sub_10040380(272, &v49) )
  {
    v37 = v49;
  }
  else
  {
    v37 = 0;
    v49 = 0;
  }
  LOBYTE(v53) = 9.8999998e24 != *(float *)(v2 + 372)
             && (*(float *)(v2 + 372) >= 4328.1602
              || *(float *)(v2 + 372) > 4267.2002 && *(_DWORD *)(v2 + 28820) == -65536
              || v37
              || *(_BYTE *)(v2 + 31233));
  if ( 9.8999998e24 == *(float *)(v2 + 372)
    || *(float *)(v2 + 372) < 2520.696
    || v37
    || *(_BYTE *)(v2 + 31233)
    || (v39 = *(_BYTE *)(v2 + 31235) == 0, LOBYTE(v54) = 1, !v39) )
  {
    LOBYTE(v54) = 0;
  }
  sub_10003B10((_DWORD *)(v2 + 28820), (_DWORD *)(v2 + 28824), v53, v54);
  v38 = 9.8999998e24 == *(float *)(v2 + 384);
  LOBYTE(v53) = *(_BYTE *)(v2 + 31232);
  LOBYTE(v54) = !v38 && (*(float *)(v2 + 384) < -12.69999980926514 || *(float *)(v2 + 384) > 12.69999980926514);
  sub_10003B10((_DWORD *)(v2 + 29432), (_DWORD *)(v2 + 29436), v53, v54);
  if ( *(float *)(v2 + 29420) < (double)*(float *)(v2 + 384) || *(float *)(v2 + 29416) > (double)*(float *)(v2 + 384) )
    *(float *)(v2 + 384) = 9.8999998e24;
  if ( *(_BYTE *)(v2 + 31852) )
  {
    *(_DWORD *)(v2 + 31276) = -16711681;
    *(_DWORD *)(v2 + 31280) = -16777216;
    goto LABEL_190;
  }
  if ( 9.8999998e24 == *(float *)(v2 + 392) )
  {
    *(_DWORD *)(v2 + 31872) = 0;
    goto LABEL_190;
  }
  if ( 9.8999998e24 != *(float *)(v2 + 31856) )
    v61 = *(float *)(v2 + 31856) - *(float *)(v2 + 392);
  if ( 9.8999998e24 == *(float *)(v2 + 31856)
    || (v54 = LODWORD(v61) & 0x7FFFFFFF, COERCE_FLOAT(LODWORD(v61) & 0x7FFFFFFF) >= 1.524) )
  {
    v39 = *(_DWORD *)(v2 + 31872) == 0;
    if ( !*(_DWORD *)(v2 + 31872) )
    {
      v40 = sub_100160A0();
      *(_DWORD *)(v2 + 31872) = v40;
      v39 = v40 == 0;
    }
    if ( !v39 && sub_100160A0() > (unsigned int)(*(_DWORD *)(v2 + 31872) + 30000) )
    {
      *(_DWORD *)(v2 + 31276) = -16777216;
      *(_DWORD *)(v2 + 31280) = -256;
      goto LABEL_187;
    }
    *(_DWORD *)(v2 + 31276) = -256;
  }
  else
  {
    v39 = *(_BYTE *)(v2 + 31864) == 0;
    *(_DWORD *)(v2 + 31872) = 0;
    if ( !v39 && !*(_BYTE *)(v2 + 31853) )
    {
      *(_DWORD *)(v2 + 31276) = -16777216;
      *(_DWORD *)(v2 + 31280) = -16711936;
      goto LABEL_187;
    }
    *(_DWORD *)(v2 + 31276) = -16711681;
  }
  *(_DWORD *)(v2 + 31280) = -16777216;
LABEL_187:
  if ( *(_BYTE *)(v2 + 31853) )
    *(_BYTE *)(v2 + 31853) = 0;
LABEL_190:
  *(_DWORD *)(v2 + 42628) = -16711936;
  *(_DWORD *)(v2 + 42692) = -16711936;
  *(_DWORD *)(v2 + 46648) = -16777216;
  *(_DWORD *)(v2 + 46652) = -16711936;
  sub_10040E50((bool *)&v49);
  if ( v49 )
  {
    if ( !*(_DWORD *)(v2 + 52880) )
    {
      *(_DWORD *)(v2 + 52880) = sub_100160A0();
      sub_10009550(a1);
    }
  }
  else
  {
    *(_DWORD *)(v2 + 52880) = 0;
  }
  if ( *(_BYTE *)dword_102D2B4C == 31 )
  {
    sub_10025420(&v60);
    v41 = (int *)(v2 + 52884);
    v60 = v60 * 1.943844437599182;
    sub_100163E0(9201, (void *)(v2 + 52884), 4, &v63);
    v42 = (_BYTE *)(v2 + 52876);
    sub_100163E0(9202, (void *)(v2 + 52876), 1, &v52);
    v43 = v60;
    if ( *(_BYTE *)(v2 + 52876) || v43 > 60.0 )
    {
      if ( *(_BYTE *)(v2 + 52876) != 1 || v43 <= 60.0 )
      {
        *v41 = 0;
        goto LABEL_209;
      }
      if ( !*v41 )
      {
        *v41 = sub_100160A0();
        goto LABEL_209;
      }
      if ( sub_100160A0() <= (unsigned int)(*v41 + 10000) )
        goto LABEL_210;
      *v42 = 0;
    }
    else
    {
      if ( !*v41 )
      {
        *v41 = sub_100160A0();
LABEL_209:
        sub_10016450(9201, v2 + 52884, 4);
LABEL_210:
        if ( (v49 && sub_100160A0() > (unsigned int)(*(_DWORD *)(v2 + 52880) + 60000) || *v42)
          && (sub_10040700(0x8Eu, &v58) && v58 > 1.029744258676657
           || sub_10040700(0x8Fu, &v58) && v58 > 1.029744258676657
           || sub_10040380(306, &v49) && v49) )
        {
          v44 = 9.8999998e24;
          if ( 9.8999998e24 == *(float *)(v2 + 480)
            || *(float *)(v2 + 42500) > (double)*(float *)(v2 + 480)
            || *(float *)(v2 + 42508) < (double)*(float *)(v2 + 480) )
          {
            v45 = 9.8999998e24 == *(float *)(v2 + 480);
            *(_DWORD *)(v2 + 42628) = -65536;
            *(_DWORD *)(v2 + 42692) = -65536;
            if ( !v45 )
            {
              *(_DWORD *)(v2 + 46648) = -65536;
              *(_DWORD *)(v2 + 46652) = -1;
            }
          }
        }
        else
        {
          v44 = 9.8999998e24;
          if ( 9.8999998e24 == *(float *)(v2 + 480) )
          {
            *(_DWORD *)(v2 + 42628) = -256;
            *(_DWORD *)(v2 + 42692) = -256;
          }
        }
        if ( v44 != *(float *)(v2 + 480) )
        {
          *(float *)(v2 + 452) = *(float *)(v2 + 476);
          *(float *)(v2 + 464) = *(float *)(v2 + 476);
          *(float *)(v2 + 480) = *(float *)(dword_102D2B4C + 6544) - *(float *)(v2 + 480);
        }
        goto LABEL_244;
      }
      if ( sub_100160A0() <= (unsigned int)(*v41 + 30000) )
        goto LABEL_210;
      *v42 = 1;
    }
    sub_10016450(9202, v2 + 52876, 1);
    *v41 = 0;
    sub_10016450(9201, v2 + 52884, 4);
    goto LABEL_210;
  }
  if ( v49 == 1
    && (sub_10040700(0x8Eu, &v58) && v58 > 1.029744258676657
     || sub_10040700(0x8Fu, &v58) && v58 > 1.029744258676657
     || sub_10040380(52, &v49) && v49) )
  {
    v44 = 9.8999998e24;
    if ( 9.8999998e24 != *(float *)(v2 + 480)
      && (*(float *)(v2 + 42492) > (double)*(float *)(v2 + 456) || *(float *)(v2 + 42500) < (double)*(float *)(v2 + 456)) )
    {
      *(_DWORD *)(v2 + 42628) = -65536;
      *(_DWORD *)(v2 + 42692) = -65536;
      *(_DWORD *)(v2 + 46648) = -65536;
      *(_DWORD *)(v2 + 46652) = -1;
    }
  }
  else
  {
    v44 = 9.8999998e24;
  }
  v46 = *(_BYTE *)(v2 + 52877);
  *(_DWORD *)(v2 + 42324) = -16711936;
  if ( v46 == 3 || v46 == 4 || v46 == 5 )
    *(_DWORD *)(v2 + 42324) = -1;
LABEL_244:
  if ( v44 == *(float *)(v2 + 456) || v44 == *(float *)(v2 + 468) )
  {
    *(float *)(v2 + 452) = v44;
    *(float *)(v2 + 464) = v44;
    *(float *)(v2 + 476) = v44;
  }
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000BA50) --------------------------------------------------------
void __cdecl sub_1000BA50(int a1)
{
  int v1; // ebp@1
  int v2; // esi@1
  int v3; // eax@1
  int v4; // ecx@5
  char v5; // bl@7
  char *v6; // edi@20
  unsigned __int8 v7; // al@21
  unsigned __int8 v8; // al@23
  unsigned __int8 v9; // cl@24
  float v10; // ST18_4@28
  char v11; // al@30
  int v12; // ecx@39
  _WORD *v13; // [sp-Ch] [bp-34h]@49
  char *v14; // [sp-8h] [bp-30h]@49
  int v15; // [sp-4h] [bp-2Ch]@49
  char v16; // [sp+1Ah] [bp-Eh]@1
  char v17; // [sp+1Bh] [bp-Dh]@20
  char v18; // [sp+1Ch] [bp-Ch]@30
  char v19; // [sp+1Dh] [bp-Bh]@30
  char v20; // [sp+1Eh] [bp-Ah]@38
  char v21; // [sp+1Fh] [bp-9h]@39
  float v22; // [sp+20h] [bp-8h]@1
  unsigned int v23; // [sp+24h] [bp-4h]@39

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v22 = 0.0;
  v16 = 0;
  v3 = sub_100160A0();
  if ( *(_BYTE *)(v2 + 52872) )
  {
    *(_BYTE *)(v2 + 52872) = 0;
    goto LABEL_5;
  }
  if ( (unsigned int)(*(_DWORD *)(v2 + 52864) - v3) >= 0x7D && (unsigned int)(v3 - *(_DWORD *)(v2 + 52868)) >= 0xC8 )
  {
LABEL_5:
    *(_DWORD *)(v2 + 52868) = v3;
    LOBYTE(a1) = *(_BYTE *)(v2 + 52841);
    sub_100163E0(9152, (void *)(v2 + 52841), 1, &a1);
    sub_1003F6F0(*(_BYTE *)(v2 + 52841));
    if ( (_BYTE)a1 != *(_BYTE *)(v2 + 52841) )
      sub_10004220(v1, v4, 1);
    sub_10009A80(v1);
    sub_1000A7D0(v1);
    v5 = *(_BYTE *)(v2 + 52877);
    if ( sub_1003E540((int)&unk_10089A8C) )
    {
      *(_BYTE *)(v2 + 52877) = 0;
      if ( v5 == 5 )
      {
        *(_BYTE *)(v2 + 31864) = 0;
        sub_10016450(9175, v2 + 31864, 1);
        goto LABEL_20;
      }
    }
    else if ( sub_1003E540((int)&unk_10089A88) )
    {
      *(_BYTE *)(v2 + 52877) = 1;
    }
    else if ( sub_1003E540((int)&unk_10089A84) )
    {
      *(_BYTE *)(v2 + 52877) = 2;
    }
    else if ( sub_1003E540((int)&unk_10089A80) )
    {
      *(_BYTE *)(v2 + 52877) = 3;
    }
    else
    {
      *(_BYTE *)(v2 + 52877) = (sub_1003E540((int)&unk_10089A7C) != 0) + 4;
    }
    if ( !v5 && *(_BYTE *)(v2 + 52877) )
    {
      sub_10023CB0();
      sub_1003F6A0();
    }
LABEL_20:
    v6 = (char *)(v2 + 52845);
    v17 = 0;
    sub_100163E0(9187, (void *)(v2 + 52845), 1, &v17);
    if ( *(_BYTE *)(v2 + 52874) )
    {
      v8 = *v6;
      if ( *v6 )
      {
        v9 = *(_BYTE *)(v2 + 52888);
        if ( !(v8 & v9) )
        {
          *v6 = v9 | v8;
          sub_10016450(9187, v2 + 52845, 1);
          *(_DWORD *)(v2 + 52832) = 0;
        }
      }
    }
    else
    {
      v7 = *(_BYTE *)(v2 + 52888);
      if ( (v7 & (unsigned __int8)*v6) == v7 )
      {
        *v6 &= ~v7;
        sub_10016450(9187, v2 + 52845, 1);
      }
    }
    if ( *v6 )
    {
      sub_1003F2B0((void *)(v2 + 52836));
    }
    else
    {
      v6 = (char *)(v2 + 52836);
      sub_1003F2E0((float *)(v2 + 52836));
      *(float *)(v2 + 52836) = sub_100707A0(*(float *)(v2 + 52836), 1.0);
      sub_1003F2B0(&v22);
      if ( *(float *)(v2 + 52836) != v22 )
      {
        v10 = *(float *)v6;
        sub_1003F710(SLOBYTE(v10));
      }
    }
    v18 = 0;
    sub_100163E0(9186, &v19, 1, &v18);
    v11 = v19;
    if ( v19 == 1 )
    {
      *(_WORD *)(v2 + 52830) = 1754;
      *(_DWORD *)(v2 + 52832) = 0;
    }
    else
    {
      *(_WORD *)(v2 + 52830) = 6;
      if ( v11 == 2 )
      {
        *(_BYTE *)(v2 + 52840) = 1;
        goto LABEL_33;
      }
    }
    *(_BYTE *)(v2 + 52840) = 0;
LABEL_33:
    if ( sub_1003F220(1, 1339, 0, 1, &v16) && v16 && !*(_DWORD *)(v2 + 52832) )
      *(_DWORD *)(v2 + 52832) = sub_100160A0();
    if ( !*(_BYTE *)(v2 + 31852) )
    {
      v20 = 0;
      sub_100163E0(9175, (void *)(v2 + 31864), 1, &v20);
      v6 = (char *)(v2 + 31856);
      sub_10040550((void *)(v2 + 31856));
      *(float *)(v2 + 31868) = *(float *)(v2 + 31856);
    }
    sub_100239E0(v5, &v21, (int *)&v23);
    if ( sub_100238A0(v23) == 9.9999996e24 )
    {
      *(_BYTE *)(v2 + 31884) = 0;
    }
    else
    {
      *(_BYTE *)(v2 + 31884) = 1;
      *(float *)(v2 + 31880) = sub_100238A0(v23);
    }
    sub_10004220(v1, v12, 0);
    if ( *(_BYTE *)(v2 + 52873) )
    {
      sub_10038CD0(v1, *(_WORD **)(v1 + 52), (char *)&unk_10088A30, (int)&unk_10089468, 0, 255);
      sub_10004EF0(v1);
      if ( *(_BYTE *)dword_102D2B4C == 31 )
        sub_10005970((int)v6, v1);
      else
        sub_100062A0((int)v6, v1);
      sub_10038CD0(v1, *(_WORD **)(v1 + 52), (char *)&unk_10089080, v2, 0, 255);
      if ( !*(_BYTE *)(v2 + 52874) )
        goto LABEL_56;
      v15 = v2 + 92;
      v14 = (char *)&unk_10089278;
      v13 = *(_WORD **)(v1 + 52);
    }
    else
    {
      sub_10038CD0(v1, *(_WORD **)(v1 + 52), (char *)&unk_10088248, (int)&unk_10089400, 0, 255);
      sub_10004EF0(v1);
      if ( *(_BYTE *)dword_102D2B4C == 31 )
        sub_10005970((int)v6, v1);
      else
        sub_100062A0((int)v6, v1);
      sub_10038CD0(v1, *(_WORD **)(v1 + 52), (char *)&unk_10088FC0, v2, 0, 255);
      if ( !*(_BYTE *)(v2 + 52874) )
        goto LABEL_56;
      v15 = v2 + 92;
      v14 = (char *)&unk_10089140;
      v13 = *(_WORD **)(v1 + 52);
    }
    sub_10038CD0(v1, v13, v14, v15, 0, 255);
    sub_100034B0(v1);
LABEL_56:
    sub_10004450(v1);
    *(_BYTE *)(v1 + 6) = 2;
  }
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000BEE0) --------------------------------------------------------
void __cdecl sub_1000BEE0(int a1)
{
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8015:
    case 0x8016:
      sub_10003A20(a1);
      break;
    default:
      return;
    case 0x8041:
      sub_10008FA0(a1);
      break;
    case 0x8022:
    case 0x8078:
      sub_1000BA50(a1);
      break;
    case 0x806E:
      sub_10009570(a1);
      break;
  }
}

//----- (1000BFA0) --------------------------------------------------------
void __usercall sub_1000BFA0(int a1@<ecx>, int a2@<eax>, int edi0@<edi>, int esi0@<esi>, float a3, float a4, float a5, char a6, int a7)
{
  double v9; // st6@3
  float v10; // ST1C_4@6
  signed int v11; // esi@6
  float v12; // ST00_4@9
  int v13; // [sp+18h] [bp-2Ch]@6
  float v14; // [sp+1Ch] [bp-28h]@1
  float v15; // [sp+1Ch] [bp-28h]@6
  float v16; // [sp+20h] [bp-24h]@3
  float v17; // [sp+24h] [bp-20h]@3
  int v18; // [sp+28h] [bp-1Ch]@3
  float v19; // [sp+2Ch] [bp-18h]@3
  int v20; // [sp+30h] [bp-14h]@3
  int v21; // [sp+34h] [bp-10h]@3
  float v22; // [sp+38h] [bp-Ch]@3
  float v23; // [sp+3Ch] [bp-8h]@3
  float v24; // [sp+48h] [bp+4h]@3
  float v25; // [sp+4Ch] [bp+8h]@6
  float v26; // [sp+4Ch] [bp+8h]@6
  float v27; // [sp+50h] [bp+Ch]@3

  v14 = 11.4;
  if ( LOBYTE(a5) )
    v14 = 0.0;
  v9 = a3;
  a2 = (unsigned __int8)a2;
  v20 = -16777216;
  v21 = a1;
  v18 = 1;
  v24 = a3 - 13.0;
  v27 = a4 - 13.0;
  v19 = 9.0;
  v22 = 0.5;
  v23 = 0.5;
  v16 = v9;
  v17 = a4;
  if ( (_BYTE)a2 )
  {
    if ( a2 == 1 )
    {
      j_gdi_pvg_color_u32(a1);
      sub_10015770(1.5);
      j_gdi_pvg_begin(66);
      sub_10015960(v24, v27);
      v25 = v24 + 26.0;
      sub_10015960(v25, v27);
      v10 = v27 + 26.0;
      sub_10015960(v25, v10);
      sub_10015960(v24, v10);
      j_gdi_pvg_end(esi0);
      v15 = v27;
      v26 = v24;
      j_gdi_pvg_scissor((signed int)v24, (signed int)v27, 26, 26);
      j_gdi_pvg_enable(36);
      j_gdi_pvg_begin(64);
      v11 = 9;
      do
      {
        v15 = v15 + 5.150000095367432;
        v26 = v26 + 5.150000095367432;
        sub_10015960(v26, v27);
        sub_10015960(v24, v15);
        --v11;
      }
      while ( v11 );
      j_gdi_pvg_end(v13);
      j_gdi_pvg_disable(36);
    }
    else
    {
      sub_10039220(v24, v27, 26.0, 26.0, 0.0, 0.0, 0);
    }
  }
  else
  {
    v12 = v9;
    sub_1003A060(edi0, v12, a4, 13.0, v14, 0.0, 360.0, a1);
    if ( a6 )
      sub_10038F80(a7, (int)&v16);
  }
}
// 1000BFA0: could not find valid save-restore pair for esi
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10015880: using guessed type int __cdecl j_gdi_pvg_scissor(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000C1F0) --------------------------------------------------------
int __usercall sub_1000C1F0@<eax>(int a1@<ebx>, unsigned int a2@<esi>, int a3)
{
  unsigned int v3; // edi@1
  signed int v4; // eax@1

  v3 = 0;
  memcpy((void *)a1, (const void *)(a1 + 4), 4 * a2 - 4);
  v4 = 0;
  for ( *(_DWORD *)(a1 + 4 * a2 - 4) = a3; v4 < (signed int)a2; ++v4 )
    v3 += *(_DWORD *)(a1 + 4 * v4);
  return v3 / a2;
}

//----- (1000C230) --------------------------------------------------------
char __cdecl sub_1000C230(int a1, int a2)
{
  _WORD *v2; // esi@1
  char result; // al@1

  v2 = *(_WORD **)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 28 * a2 + 2752) + 12);
  *v2 = 68;
  result = sub_1003F220(1, 239, 0, 1, &a1);
  if ( result )
  {
    result = a1;
    switch ( (unsigned __int8)a1 )
    {
      case 0u:
        *v2 = 4857;
        break;
      case 1u:
        *v2 = 6154;
        break;
      case 2u:
        *v2 = 3749;
        break;
      case 3u:
        *v2 = 4370;
        break;
      case 4u:
        *v2 = 1033;
        break;
      case 5u:
        *v2 = 1035;
        break;
      case 6u:
        *v2 = 4497;
        break;
      case 7u:
        *v2 = 6418;
        break;
      case 8u:
        *v2 = 4989;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (1000C360) --------------------------------------------------------
void __cdecl sub_1000C360(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  bool v4; // zf@1
  int v5; // esi@1
  _DWORD *v6; // eax@2
  float v7; // ST30_4@2
  float v8; // ST1C_4@2
  float v9; // [sp+14h] [bp-8h]@1
  float v10; // [sp+18h] [bp-4h]@1
  float v11; // [sp+20h] [bp+4h]@1
  float v12; // [sp+20h] [bp+4h]@2
  float v13; // [sp+24h] [bp+8h]@1

  v2 = a2;
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v4 = *(_BYTE *)(v3 + a2 + 404) == 3;
  v5 = *(_DWORD *)(*(_DWORD *)(v3 + 28 * a2 + 2752) + 12);
  v10 = *(float *)(v5 + 8) * 0.9077000021934509;
  v9 = *(float *)(v5 + 12) * 0.1230769976973534;
  v11 = *(float *)v5 - 1.0;
  v13 = *(float *)(v5 + 2048) - v9 * 0.5;
  if ( v4 )
  {
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_enable(34);
    j_gdi_pvg_color_u32(-1);
    v6 = (_DWORD *)sub_100165A0(0x3Au);
    j_gdi_pvg_bind_texture(34, *v6);
    j_gdi_pvg_begin(72);
    sub_10015890(0.0, 0.0);
    v7 = v13 + v9;
    sub_10015960(v11, v7);
    sub_10015890(0.0, 1.0);
    sub_10015960(v11, v13);
    sub_10015890(1.0, 1.0);
    v12 = v11 + v10;
    sub_10015960(v12, v13);
    sub_10015890(1.0, 0.0);
    sub_10015960(v12, v7);
    j_gdi_pvg_end(LODWORD(v8));
    j_gdi_pvg_disable(34);
    j_gdi_pvg_disable(35);
    if ( 9.8999998e24 == *(float *)(v3 + 28 * (v2 + 98)) )
    {
      *(_BYTE *)(v5 + 2350) = 0;
      *(_BYTE *)(v5 + 2349) = 1;
    }
    else
    {
      *(_BYTE *)(v5 + 2350) = 1;
      *(_BYTE *)(v5 + 2349) = 2;
    }
  }
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1000C510) --------------------------------------------------------
void __cdecl sub_1000C510(int a1, void *a2)
{
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  float v5; // ST30_4@1
  int v6; // ebp@1
  bool v7; // zf@1
  double v8; // st7@1
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st6@1
  double v12; // st6@1
  double v13; // st5@1
  float *v14; // esi@2
  int v15; // eax@3
  int v16; // ecx@4
  char v17; // bl@5
  char v18; // al@5
  int v19; // eax@7
  float v20; // [sp+8h] [bp-54h]@4
  char v21; // [sp+Ch] [bp-50h]@4
  char *v22; // [sp+10h] [bp-4Ch]@4
  char v23; // [sp+25h] [bp-37h]@5
  char v24; // [sp+26h] [bp-36h]@5
  char v25; // [sp+27h] [bp-35h]@5
  signed int v26; // [sp+28h] [bp-34h]@2
  float v27; // [sp+30h] [bp-2Ch]@1
  char v28; // [sp+34h] [bp-28h]@1
  char v29; // [sp+35h] [bp-27h]@1
  char v30; // [sp+36h] [bp-26h]@1
  char v31; // [sp+37h] [bp-25h]@1
  char v32; // [sp+38h] [bp-24h]@1
  char v33; // [sp+39h] [bp-23h]@1
  float v34; // [sp+3Ch] [bp-20h]@1
  float v35; // [sp+40h] [bp-1Ch]@1
  char v36; // [sp+44h] [bp-18h]@1
  char v37; // [sp+45h] [bp-17h]@1
  char v38; // [sp+46h] [bp-16h]@1
  char v39; // [sp+47h] [bp-15h]@1
  char v40; // [sp+48h] [bp-14h]@1
  char v41; // [sp+49h] [bp-13h]@1
  float v42; // [sp+4Ch] [bp-10h]@1
  float v43; // [sp+50h] [bp-Ch]@1
  char v44; // [sp+54h] [bp-8h]@1
  char v45; // [sp+55h] [bp-7h]@1
  char v46; // [sp+56h] [bp-6h]@1
  char v47; // [sp+57h] [bp-5h]@1
  char v48; // [sp+58h] [bp-4h]@1
  char v49; // [sp+59h] [bp-3h]@1
  float v50; // [sp+60h] [bp+4h]@1
  char v51; // [sp+60h] [bp+4h]@5
  char v52; // [sp+64h] [bp+8h]@5

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = a2;
  v4 = *(_DWORD *)(*(_DWORD *)(v2 + 28 * (_DWORD)a2 + 2752) + 12);
  v5 = *(float *)v4;
  v6 = *(_DWORD *)(v2 + 28 * (_DWORD)a2 + 2760);
  v7 = *((_BYTE *)a2 + v2 + 404) == 3;
  v27 = *(float *)(v4 + 4);
  v8 = *(float *)(v4 + 8);
  v28 = 0;
  v9 = v8 * 0.5;
  v29 = 1;
  v10 = *(float *)v4;
  v30 = 2;
  v31 = 3;
  v32 = 4;
  v33 = 5;
  v36 = 6;
  v34 = v10 - v9;
  v37 = 7;
  v11 = *(float *)(v4 + 12);
  v38 = 8;
  v12 = v11 + *(float *)(v4 + 4);
  v39 = 9;
  v40 = 10;
  v41 = 11;
  v50 = v12;
  v44 = 12;
  v45 = 13;
  v35 = v50;
  v46 = 14;
  v13 = *(float *)v4;
  v47 = 15;
  v48 = 16;
  v49 = 17;
  v42 = v9 + v13;
  v43 = v50;
  if ( v7 )
  {
    v14 = &v27;
    v26 = 3;
    do
    {
      if ( sub_10025CF0(v3) == 4 )
      {
        v22 = (char *)&unk_100894EC;
        v21 = *(_BYTE *)(v6 + 2);
        v16 = *(_DWORD *)(v6 + 4);
        LODWORD(v20) = *(_BYTE *)v6;
        LOBYTE(v15) = 0;
      }
      else
      {
        v17 = sub_1003E4E0(*(_WORD *)(v2 + 2 * *((_BYTE *)v14 + 4) + 504));
        v52 = sub_1003E4E0(*(_WORD *)(v2 + 2 * *((_BYTE *)v14 + 9) + 504));
        v23 = sub_1003E4E0(*(_WORD *)(v2 + 2 * *((_BYTE *)v14 + 8) + 504));
        v51 = sub_1003E4E0(*(_WORD *)(v2 + 2 * *((_BYTE *)v14 + 5) + 504));
        v24 = sub_1003E4E0(*(_WORD *)(v2 + 2 * *((_BYTE *)v14 + 6) + 504));
        v18 = sub_1003E4E0(*(_WORD *)(v2 + 2 * *((_BYTE *)v14 + 7) + 504));
        v25 = v18;
        v3 = (void *)(unsigned __int8)v17;
        v15 = (unsigned __int8)v17
            + (unsigned __int8)v52
            + (unsigned __int8)v23
            + (unsigned __int8)v51
            + (unsigned __int8)v24
            + (unsigned __int8)v18;
        if ( v15 == 1 )
        {
          if ( v17 )
          {
            v19 = *(_BYTE *)(v6 + 1);
            LOBYTE(v19) = 0;
            sub_1000BFA0(
              *(_DWORD *)(v6 + 8),
              v19,
              v2,
              (int)v14,
              *(v14 - 1),
              *v14,
              COERCE_FLOAT(*(_BYTE *)(v6 + 1)),
              *(_BYTE *)(v6 + 2),
              (int)&unk_100894DC);
          }
          if ( v51 )
          {
            LOBYTE(v15) = 0;
            sub_1000BFA0(
              *(_DWORD *)(v6 + 4),
              v15,
              v2,
              (int)v14,
              *(v14 - 1),
              *v14,
              COERCE_FLOAT(*(_BYTE *)v6),
              *(_BYTE *)(v6 + 2),
              (int)&unk_100894EC);
          }
          if ( v52 )
          {
            LOBYTE(v15) = 0;
            sub_1000BFA0(-65536, v15, v2, (int)v14, *(v14 - 1), *v14, COERCE_FLOAT(1), 0, (int)byte_100879F8);
          }
          if ( v23 )
          {
            LOBYTE(v15) = 1;
            sub_1000BFA0(-65536, v15, v2, (int)v14, *(v14 - 1), *v14, 0.0, 0, (int)byte_100879F8);
          }
          if ( v24 )
          {
            LOBYTE(v15) = 1;
            sub_1000BFA0(-1, v15, v2, (int)v14, *(v14 - 1), *v14, 0.0, 0, (int)byte_100879F8);
          }
          if ( !v25 )
            goto LABEL_21;
          v16 = -256;
          LOBYTE(v15) = 1;
        }
        else
        {
          v16 = -65536;
          LOBYTE(v15) = 2;
        }
        v22 = byte_100879F8;
        v21 = 0;
        v20 = 0.0;
      }
      sub_1000BFA0(v16, v15, v2, (int)v14, *(v14 - 1), *v14, v20, v21, (int)v22);
LABEL_21:
      v14 += 4;
      --v26;
    }
    while ( v26 );
  }
}

//----- (1000C800) --------------------------------------------------------
char __cdecl sub_1000C800(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ebx@1
  signed int v4; // edx@1
  char *v5; // ecx@1
  float *v6; // eax@1
  char result; // al@4
  char v8; // [sp+10h] [bp-48h]@4
  char v9; // [sp+18h] [bp-40h]@1
  int v10; // [sp+5Ch] [bp+4h]@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = *(_DWORD *)(v2 + 28 * a2 + 2748);
  v10 = *(_DWORD *)(*(_DWORD *)(v2 + 28 * a2 + 2752) + 12);
  v4 = 0;
  v5 = &v9;
  v6 = (float *)(v2 + 28 * (a2 + 98));
  do
  {
    if ( v4 + a2 >= v3 + a2 )
      break;
    ++v4;
    *((float *)v5 - 1) = *v6;
    v6 += 7;
    v5 += 12;
    *((float *)v5 - 3) = *(v6 - 7);
  }
  while ( v4 < 6 );
  result = sub_100426C0((int)&v8, 0, v3);
  *(_BYTE *)(v10 + 978) = result;
  return result;
}

//----- (1000C8A0) --------------------------------------------------------
void __cdecl sub_1000C8A0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int v4; // edx@1
  int v5; // esi@1
  int v6; // edx@3
  double v7; // st7@3
  double v8; // st6@3
  double v9; // st5@4
  double v10; // ST50_8@8
  double v11; // ST40_8@8
  signed int v12; // esi@8
  float v13; // ST50_4@9
  float v14; // ST40_4@9
  float v15; // ST38_4@9
  float v16; // ST40_4@9
  int v17; // [sp+1Ch] [bp-48h]@0
  float v18; // [sp+2Ch] [bp-38h]@1
  float v19; // [sp+2Ch] [bp-38h]@3
  float v20; // [sp+2Ch] [bp-38h]@8
  float v21; // [sp+30h] [bp-34h]@1
  float v22; // [sp+34h] [bp-30h]@1
  float v23; // [sp+38h] [bp-2Ch]@1
  float v24; // [sp+38h] [bp-2Ch]@8
  float v25; // [sp+3Ch] [bp-28h]@1
  float v26; // [sp+48h] [bp-1Ch]@8
  double v27; // [sp+54h] [bp-10h]@8
  double v28; // [sp+5Ch] [bp-8h]@8

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = v2 + 28 * a2;
  v4 = *(_DWORD *)(*(_DWORD *)(v3 + 2752) + 12);
  v5 = *(_DWORD *)(v3 + 2760);
  v18 = *(float *)(v2 + 28 * (a2 + 98));
  v25 = *(float *)v4;
  v21 = *(float *)(v4 + 4);
  v22 = *(float *)(v4 + 8);
  v23 = *(float *)(v4 + 12);
  if ( *(_BYTE *)(v2 + a2 + 404) == 3 )
  {
    if ( 9.8999998e24 == v18 )
    {
      sub_10039220(v25, v21, v23, v23, 0.0, 0.0, 0);
    }
    else
    {
      sub_100252A0(*(float *)(v4 + 24), *(float *)(v4 + 20));
      v7 = v22;
      v8 = v18;
      v19 = 0.125 * v22 * *(float *)(v5 + 8) * (v18 / *(float *)(v6 + 24)) + *(float *)(v5 + 12);
      *(float *)(v5 + 12) = v19;
      if ( v22 * 0.25 > v19 )
      {
        v9 = 0.5;
      }
      else
      {
        v9 = 0.5;
        *(float *)(v5 + 12) = v19 - v7 * 0.5;
      }
      if ( *(float *)(v5 + 12) < 0.25 * -v7 )
        *(float *)(v5 + 12) = v7 * v9 + *(float *)(v5 + 12);
      v28 = v7 * v9;
      v10 = v25 - v28;
      v20 = v10 + *(float *)(v5 + 12);
      v26 = v8 * -8.0 / *(float *)(v6 + 24);
      j_gdi_pvg_enable(36);
      v27 = 0.5 * v23;
      v11 = v21 - v27;
      j_gdi_pvg_scissor((signed int)v10, (signed int)v11, (signed int)v22, (signed int)v23);
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      j_gdi_pvg_enable(38);
      sub_10015770(1.5);
      j_gdi_pvg_color_u32(-1);
      v24 = v11;
      v12 = 4;
      do
      {
        j_gdi_pvg_begin(66);
        v14 = v20 - 8.0;
        sub_10015960(v14, v21);
        v15 = v26 + v20;
        sub_10015960(v15, v24);
        v16 = v20 + 8.0;
        sub_10015960(v16, v21);
        v13 = v21 + v27;
        sub_10015960(v15, v13);
        j_gdi_pvg_end(v17);
        --v12;
        v20 = v20 + v28;
      }
      while ( v12 );
      sub_10015770(1.0);
      j_gdi_pvg_disable(38);
      j_gdi_pvg_disable(35);
      j_gdi_pvg_disable(36);
    }
  }
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10015880: using guessed type int __cdecl j_gdi_pvg_scissor(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1000CB70) --------------------------------------------------------
__int16 __usercall sub_1000CB70@<ax>(int a1@<esi>)
{
  __int16 v2; // [sp+0h] [bp-A0h]@1

  memset(&v2, 0, 0x9Cu);
  v2 = -1;
  sub_1003E4B0((int)&v2, a1, 1);
  return v2;
}

//----- (1000CBD0) --------------------------------------------------------
_DWORD *__usercall sub_1000CBD0@<eax>(_DWORD *result@<eax>, char a2@<dl>, _BYTE *a3@<ecx>)
{
  *a3 = 0;
  *result = 0;
  switch ( a2 )
  {
    case 1:
      *a3 = 0;
      *result = 54;
      break;
    case 2:
    case 0xD:
    case 0x11:
      *a3 = 2;
      *result = 138;
      break;
    case 3:
    case 0xE:
    case 0x12:
      *a3 = 3;
      *result = 138;
      break;
    case 4:
    case 0x13:
      *a3 = 4;
      *result = 138;
      break;
    case 5:
      *a3 = 5;
      *result = 138;
      break;
    case 6:
      *a3 = 7;
      *result = 66;
      break;
    case 7:
      *a3 = 8;
      *result = 53;
      break;
    case 8:
      *a3 = 10;
      *result = 68;
      break;
    case 9:
      *a3 = 11;
      *result = 69;
      break;
    case 0xA:
      *a3 = 13;
      *result = 110;
      break;
    case 0xB:
      *a3 = 0;
      *result = 5;
      break;
    case 0xC:
      *a3 = 1;
      *result = 6;
      break;
    case 0xF:
    case 0x14:
      *a3 = 0;
      *result = 138;
      break;
    case 0x10:
    case 0x15:
      *a3 = 1;
      *result = 138;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1000CCD0) --------------------------------------------------------
signed int __usercall sub_1000CCD0@<eax>(char a1@<al>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 2:
      result = -16711936;
      break;
    case 3:
      result = -256;
      break;
    case 4:
      result = -65536;
      break;
    case 5:
      result = -16711681;
      break;
    default:
      result = -1;
      break;
  }
  return result;
}

//----- (1000CD10) --------------------------------------------------------
BOOL __usercall sub_1000CD10@<eax>(float *a1@<edx>, float *a2@<ecx>, float *a3@<edi>, float *a4@<esi>, int a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15, float a16, float a17)
{
  double v17; // st7@4

  if ( !*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a5 + 56) + 12) + 6341) )
  {
    *a2 = a6;
    *a1 = a7;
    *a4 = a8;
    v17 = a9;
    goto LABEL_7;
  }
  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a5 + 56) + 12) + 6341) == 1 )
  {
    *a2 = a10;
    *a1 = a11;
    *a4 = a12;
    v17 = a13;
    goto LABEL_7;
  }
  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a5 + 56) + 12) + 6341) == 2 )
  {
    *a2 = a14;
    *a1 = a15;
    *a4 = a16;
    v17 = a17;
LABEL_7:
    *a3 = v17;
  }
  return 9.8999998e24 != *a2 && 9.8999998e24 != *a1 && 9.8999998e24 != *a4 && 9.8999998e24 != *a3;
}

//----- (1000CDB0) --------------------------------------------------------
double __usercall sub_1000CDB0@<st0>(char a1@<al>)
{
  double result; // st7@2
  float v2; // [sp+0h] [bp-4h]@1

  v2 = 0.0;
  switch ( a1 )
  {
    case 1:
      result = (float)7.0;
      break;
    case 2:
      result = (float)9.0;
      break;
    case 3:
      result = (float)12.0;
      break;
    case 4:
      result = (float)13.0;
      break;
    case 5:
      result = (float)15.0;
      break;
    case 6:
      result = (float)17.0;
      break;
    case 7:
      result = (float)18.0;
      break;
    case 8:
      v2 = 23.0;
      goto LABEL_10;
    default:
LABEL_10:
      result = v2;
      break;
  }
  return result;
}

//----- (1000CE60) --------------------------------------------------------
signed int __fastcall sub_1000CE60(int a1, __int16 a2)
{
  signed int result; // eax@1
  int v3; // ecx@1

  result = 11;
  v3 = 0;
  while ( word_1008A078[2 * v3] != a2 )
  {
    if ( (unsigned int)++v3 >= 0x2D )
      return result;
  }
  return (unsigned __int16)word_1008A07A[2 * v3];
}
// 1008A078: using guessed type __int16 word_1008A078[];
// 1008A07A: using guessed type __int16 word_1008A07A[];

//----- (1000CE90) --------------------------------------------------------
double __usercall sub_1000CE90@<st0>(__int16 a1@<ax>)
{
  float v2; // [sp+0h] [bp-8h]@1
  float v3; // [sp+4h] [bp-4h]@2

  v2 = 9.8999998e24;
  if ( a1 && sub_10042760(a1, &v3) )
    v2 = v3;
  return v2;
}

//----- (1000CED0) --------------------------------------------------------
signed int __cdecl sub_1000CED0(void *a1, unsigned __int8 a2, float a3, char a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  signed int v65; // ebx@1
  void *v66; // esi@2
  char *v67; // edi@2
  int v68; // ecx@4
  int v69; // edx@4
  bool v70; // zf@4
  int v71; // eax@5
  float v72; // ST28_4@5
  int v73; // ecx@5
  signed int v75; // [sp+10h] [bp-5A0h]@1
  float v76; // [sp+18h] [bp-598h]@4
  float v77; // [sp+1Ch] [bp-594h]@4
  char v78[4]; // [sp+20h] [bp-590h]@4
  int v79; // [sp+24h] [bp-58Ch]@4
  char v80; // [sp+28h] [bp-588h]@1
  char v81; // [sp+34h] [bp-57Ch]@2

  qmemcpy(&v80, &a4, 0x57Cu);
  v65 = 0;
  memset(a1, 0, 16 * a2);
  v75 = 0;
  if ( (unsigned __int8)v80 > 0u )
  {
    v66 = a1;
    v67 = &v81;
    do
    {
      if ( v65 >= a2 )
        break;
      v76 = *((float *)v67 - 2);
      v77 = a3 * *(float *)v67;
      strncpy(v78, v67 + 4, 7u);
      v68 = *(_DWORD *)v78;
      *(float *)v66 = v76;
      v69 = v79;
      *((float *)v66 + 1) = v77;
      v70 = a65 == 0;
      *((_DWORD *)v66 + 2) = v68;
      *((_DWORD *)v66 + 3) = v69;
      if ( !v70 )
      {
        strncpy(v78, byte_100879F8, 7u);
        v71 = *(_DWORD *)v78;
        ++v65;
        v72 = v77 * -1.0;
        v66 = (char *)v66 + 16;
        *(float *)v66 = v76;
        v73 = v79;
        *((float *)v66 + 1) = v72;
        *((_DWORD *)v66 + 2) = v71;
        *((_DWORD *)v66 + 3) = v73;
      }
      v67 += 28;
      ++v65;
      v66 = (char *)v66 + 16;
      ++v75;
    }
    while ( v75 < (unsigned __int8)v80 );
  }
  return v65;
}
// 1000CED0: too many input arguments, some ignored

//----- (1000D000) --------------------------------------------------------
double __usercall sub_1000D000@<st0>(char a1@<al>)
{
  double result; // st7@2

  switch ( a1 )
  {
    case 2:
      result = (float)2.0;
      break;
    case 3:
      result = (float)4.0;
      break;
    case 4:
      result = (float)3.0;
      break;
    case 5:
      result = (float)5.0;
      break;
    default:
      result = (float)1.0;
      break;
  }
  return result;
}

//----- (1000D070) --------------------------------------------------------
char __fastcall sub_1000D070(int a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@6

  v2 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  if ( *(_BYTE *)(a2 + 2) )
  {
    if ( *(_BYTE *)(a2 + 2) == 1 )
    {
      *(_DWORD *)(v2 + 6348) = 686;
      *(_DWORD *)(v2 + 6344) = 279;
    }
    else if ( *(_BYTE *)(a2 + 2) == 2 )
    {
      *(_DWORD *)(v2 + 6348) = 742;
      *(_DWORD *)(v2 + 6344) = 279;
    }
  }
  else
  {
    v3 = *(_BYTE *)(v2 + 6342) == 0;
    *(_DWORD *)(v2 + 6348) = 686;
    *(_DWORD *)(v2 + 6344) = 151;
    if ( !v3 )
      *(_DWORD *)(v2 + 6344) = 210;
  }
  if ( *(_BYTE *)(v2 + 6341) == 1 )
    *(_DWORD *)(v2 + 6344) = 1024;
  return sub_100011B0(a2, 0, 0, *(_WORD *)(v2 + 6344), *(_WORD *)(v2 + 6348), 3);
}

//----- (1000D110) --------------------------------------------------------
void __usercall sub_1000D110(int a1@<esi>)
{
  int v1; // edi@1
  double v2; // st7@4
  char v3; // [sp+7h] [bp-5h]@1
  float v4; // [sp+8h] [bp-4h]@4

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10016BE0(9, &v3);
  if ( *(_BYTE *)(v1 + 6341) == 1 )
  {
    if ( v3 == 21 )
    {
      sub_10014B40(a1, &unk_1008A038, 1u, 3, 1u);
    }
    else if ( v3 == 22 )
    {
      sub_10014B40(a1, &unk_1008A044, 4u, 3, 1u);
      v4 = *(float *)(dword_102D2B4C + 29376);
      v2 = v4;
      *(float *)(v1 + 6352) = v4;
      if ( 0.0 == v2 )
        sub_10014620(a1, 0x40u, 2);
    }
  }
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000D1B0) --------------------------------------------------------
BOOL __usercall sub_1000D1B0@<eax>(int a1@<eax>)
{
  return *(_BYTE *)(a1 + 8) && (*(_WORD *)a1 || 9.8999998e24 != *(float *)(a1 + 4));
}

//----- (1000D290) --------------------------------------------------------
void __usercall sub_1000D290(int a1@<esi>)
{
  double v1; // st7@1
  float v2; // ST10_4@1
  float v3; // ST30_4@1
  float v4; // ST08_4@1
  float v5; // ST30_4@1
  float v6; // ST04_4@1
  float v7; // ST30_4@1
  float *v8; // ecx@1
  int v9; // edi@2
  double v10; // st7@12
  float v11; // ST34_4@12
  double v12; // st4@12
  double v13; // st1@12
  float v14; // ST34_4@12
  float v15; // [sp+24h] [bp-14h]@1
  float v16; // [sp+28h] [bp-10h]@1
  float v17; // [sp+2Ch] [bp-Ch]@1
  float v18; // [sp+30h] [bp-8h]@1
  float v19; // [sp+34h] [bp-4h]@3
  float v20; // [sp+34h] [bp-4h]@5
  float v21; // [sp+34h] [bp-4h]@7
  float v22; // [sp+34h] [bp-4h]@9

  v1 = *(float *)(a1 + 212) * 0.5;
  v2 = *(float *)(a1 + 224);
  *(_DWORD *)(a1 + 1948) = 49;
  v3 = v1;
  v4 = v3;
  v5 = *(float *)(a1 + 208) + v1;
  v6 = v5;
  v7 = v1 + *(float *)(a1 + 204);
  sub_1003E1B0(v7, v6, v4, *(float *)(a1 + 220), v2, a1 + 1556, a1 + 1948);
  v8 = (float *)(a1 + 1560);
  v15 = *(float *)(a1 + 1556);
  v16 = v15;
  v17 = *(float *)(a1 + 1560);
  v18 = v17;
  if ( *(_DWORD *)(a1 + 1948) > 0 )
  {
    v9 = *(_DWORD *)(a1 + 1948);
    do
    {
      v19 = *(v8 - 1);
      if ( v19 >= (double)v15 )
        v15 = v19;
      v20 = *(v8 - 1);
      if ( v20 <= (double)v16 )
        v16 = v20;
      v21 = *v8;
      if ( v21 >= (double)v17 )
        v17 = v21;
      v22 = *v8;
      if ( v22 <= (double)v18 )
        v18 = v22;
      v8 += 2;
      --v9;
    }
    while ( v9 );
  }
  v10 = v15 - v16;
  v11 = v10 * 0.75;
  v12 = v11;
  *(float *)(a1 + 32) = v11;
  v13 = v17 - v18;
  v14 = 0.75 * v13;
  *(float *)(a1 + 36) = v14;
  *(float *)(a1 + 24) = v16 + (v10 - v12) * 0.5;
  *(float *)(a1 + 28) = v18 + 0.5 * (v13 - v14);
}

//----- (1000D430) --------------------------------------------------------
__int16 __usercall sub_1000D430@<ax>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // edi@1
  int v3; // ebx@1
  signed int v4; // ebp@1
  __int16 result; // ax@2

  v2 = 1752 * a1;
  v3 = 16 * a1 + *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12) + 1140;
  v4 = 4;
  do
  {
    result = sub_1000CB70(v2 + dword_102D2B44 + 1576);
    *(_WORD *)v3 = result;
    *(_BYTE *)(v3 + 2) = *(_BYTE *)(v2 + dword_102D2B44 + 1607);
    v3 += 4;
    v2 += 35;
    --v4;
  }
  while ( v4 );
  return result;
}
// 102D2B44: using guessed type int dword_102D2B44;

//----- (1000D490) --------------------------------------------------------
int __usercall sub_1000D490@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_WORD *)result = *(_WORD *)a2;
  *(float *)(result + 4) = *(float *)(a2 + 4);
  return result;
}

//----- (1000D4A0) --------------------------------------------------------
char __usercall sub_1000D4A0@<al>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4)
{
  signed int v4; // ebp@1
  double v5; // st7@2
  int v6; // edi@2
  float *v7; // esi@2
  char v9; // [sp+7h] [bp-1h]@1

  v4 = 0;
  v9 = 1;
  if ( !*a2 )
    return a1;
  v5 = 9.8999998e24;
  v6 = a1 + 12;
  v7 = (float *)(a2 + 104);
  do
  {
    if ( *v7 > 1.0 )
    {
      if ( v5 == *v7 )
        goto LABEL_8;
      sub_10015C20(".\\cdp_pg_eis_generic_eis.c", 4639, 1, "Gauge config error: gauge->prcnt is larger then 1.0");
      v5 = 9.8999998e24;
    }
    if ( v5 != *v7 )
    {
      ++v9;
      *(float *)(v6 + 4) = a4 * *v7;
      *(float *)v6 = *(v7 - 23);
    }
LABEL_8:
    ++v4;
    ++v7;
    v6 += 12;
  }
  while ( v4 < *a2 );
  LOBYTE(a1) = v9;
  if ( (unsigned __int8)v9 > 1u )
    *(_BYTE *)a3 = v9;
  return a1;
}

//----- (1000D540) --------------------------------------------------------
void __usercall sub_1000D540(int a1@<edx>, int a2@<esi>, float a3, float a4)
{
  char v4; // al@5

  *(float *)(a2 + 28) = *(float *)(a1 + 4);
  *(float *)(a2 + 24) = *(float *)a1;
  if ( 9.8999998e24 != *(float *)(a1 + 8) )
    *(float *)a2 = *(float *)(a1 + 8) + a3;
  if ( 9.8999998e24 != *(float *)(a1 + 12) )
    *(float *)(a2 + 4) = *(float *)(a1 + 12) + a4;
  v4 = *(_BYTE *)(a1 + 24);
  if ( v4 )
    *(float *)(a2 + 40) = sub_1000CDB0(v4);
  if ( *(float *)(a1 + 16) >= 0.0 )
    *(float *)(a2 + 32) = *(float *)(a1 + 16);
  if ( *(float *)(a1 + 20) >= 0.0 )
    *(float *)(a2 + 36) = *(float *)(a1 + 20);
}

//----- (1000D5B0) --------------------------------------------------------
signed int __cdecl sub_1000D5B0(signed int a1, unsigned __int8 a2, char a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  signed int result; // eax@1
  char *v66; // esi@2
  int v67; // edi@2
  float *v68; // ebx@2
  int v69; // edx@6
  float *v70; // [sp+Ch] [bp-59Ch]@2
  signed int *v71; // [sp+10h] [bp-598h]@2
  signed int v72; // [sp+14h] [bp-594h]@4
  int v73; // [sp+18h] [bp-590h]@2
  float v74; // [sp+1Ch] [bp-58Ch]@6
  char v75; // [sp+20h] [bp-588h]@1
  char v76; // [sp+29h] [bp-57Fh]@2

  result = a1;
  qmemcpy(&v75, &a3, 0x57Cu);
  if ( (signed int)a2 > 0 )
  {
    v70 = (float *)(a1 + 48);
    v66 = &v76;
    v67 = a1 + 16;
    v68 = (float *)(a1 + 44);
    v71 = (signed int *)(a1 + 56);
    v73 = a2;
    do
    {
      if ( *v66 )
        v72 = sub_1000CCD0(*v66);
      else
        v72 = *v71;
      v74 = sub_1000D000(*(v66 - 1));
      *(float *)v67 = v74;
      *(_DWORD *)v69 = v72;
      if ( -1.0 != *(float *)(v66 + 15) )
        *v68 = *(float *)(v66 + 15);
      if ( -1.0 != *(float *)(v66 + 19) )
        *v70 = *(float *)(v66 + 19);
      if ( a65 )
      {
        v70 += 16;
        *(float *)(v67 + 64) = v74;
        v68 += 16;
        v67 += 64;
        *(_DWORD *)(v69 + 64) = v72;
      }
      result = 64;
      v71 += 16;
      v70 += 16;
      v66 += 28;
      v68 += 16;
      v67 += 64;
      --v73;
    }
    while ( v73 );
  }
  return result;
}
// 1000D5B0: too many input arguments, some ignored

//----- (1000D6C0) --------------------------------------------------------
void __usercall sub_1000D6C0(int a1@<edx>, int a2@<ebx>, float a3, float a4)
{
  char v4; // al@11

  if ( memcmp((const void *)a1, byte_100879F8, 1u) )
    strcpy((char *)(a2 + 16), (const char *)a1);
  if ( 9.8999998e24 != *(float *)(a1 + 16) )
    *(float *)a2 = a3 + *(float *)(a1 + 16);
  if ( 9.8999998e24 != *(float *)(a1 + 20) )
    *(float *)(a2 + 4) = *(float *)(a1 + 20) + a4;
  if ( *(float *)(a1 + 24) >= 0.0 )
    *(float *)(a2 + 40) = *(float *)(a1 + 24);
  if ( *(float *)(a1 + 28) >= 0.0 )
    *(float *)(a2 + 44) = *(float *)(a1 + 28);
  v4 = *(_BYTE *)(a1 + 32);
  if ( v4 )
    *(float *)(a2 + 48) = sub_1000CDB0(v4);
}

//----- (1000D750) --------------------------------------------------------
char __usercall sub_1000D750@<al>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // ebp@1
  float *v3; // esi@1
  float *v4; // eax@1
  signed int v5; // ecx@1
  signed int v6; // edi@3
  int v7; // esi@5
  signed int v8; // edi@5
  unsigned int v9; // esi@9
  void (__cdecl **v10)(_DWORD, _DWORD); // edi@9
  _BYTE *v11; // esi@13
  _BYTE *v12; // ebx@13
  int v13; // edi@13
  int v14; // eax@14
  signed int v15; // esi@20
  int v16; // ebx@20
  int v17; // ecx@21
  bool v18; // zf@26
  int v20; // [sp+10h] [bp-18h]@13
  int v21; // [sp+14h] [bp-14h]@13
  signed int v22; // [sp+18h] [bp-10h]@13
  int v23; // [sp+24h] [bp-4h]@20

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = (float *)(v2 + 2744);
  v4 = (float *)(v2 + 2744);
  v5 = 100;
  do
  {
    *v4 = 9.8999998e24;
    v4 += 7;
    --v5;
  }
  while ( v5 );
  v6 = 100;
  do
  {
    *v3 = sub_1000CE90(*((_WORD *)v3 - 2));
    v3 += 7;
    --v6;
  }
  while ( v6 );
  v7 = v2 + 5540;
  v8 = 100;
  do
  {
    if ( *(_WORD *)v7 )
      *(float *)(v7 + 4) = sub_1000CE90(*(_WORD *)v7);
    v7 += 8;
    --v8;
  }
  while ( v8 );
  v9 = 0;
  v10 = (void (__cdecl **)(_DWORD, _DWORD))(v2 + 2756);
  do
  {
    if ( *v10 )
      (*v10)(v1, v9);
    ++v9;
    v10 += 7;
  }
  while ( v9 < 0x64 );
  v11 = (_BYTE *)(v2 + 404);
  v12 = (_BYTE *)(v2 + 542);
  v20 = v2 + 404;
  v13 = v2 + 2764;
  v21 = v2 + 542;
  v22 = 100;
  do
  {
    LOBYTE(v14) = sub_1003E4E0(*((_WORD *)v12 - 1));
    if ( (_BYTE)v14 || (LOBYTE(v14) = sub_10042F00(), !(_BYTE)v14) && *v12 )
      *v11 = 0;
    else
      *v11 = 3;
    if ( *(_DWORD *)v13 )
    {
      v15 = 0;
      v23 = (int)&v12[-257 - v2];
      v16 = (int)&v12[-542 - v2];
      do
      {
        LOBYTE(v14) = sub_1003E4E0(*(_WORD *)(v2 + 4 * (v15 + v23)));
        v17 = *(_DWORD *)v13;
        if ( (_BYTE)v14 )
        {
          *(_BYTE *)v17 = *(_BYTE *)(v2 + 4 * (v16 + v15) + 1142);
          v14 = *(_DWORD *)v13;
          *(_BYTE *)(*(_DWORD *)v13 + 24) = 1;
          v15 = 4;
        }
        else
        {
          *(_BYTE *)(v17 + 24) = 0;
        }
        ++v15;
      }
      while ( v15 < 4 );
      v11 = (_BYTE *)v20;
      v12 = (_BYTE *)v21;
    }
    ++v11;
    v12 += 4;
    v13 += 28;
    v18 = v22-- == 1;
    v20 = (int)v11;
    v21 = (int)v12;
  }
  while ( !v18 );
  return v14;
}

//----- (1000D8C0) --------------------------------------------------------
int __usercall sub_1000D8C0@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  _WORD *v2; // eax@1
  int result; // eax@2

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008A12C, (int)&unk_1008A464, 0, 255);
  v2 = *(_WORD **)(a1 + 52);
  if ( *v2 == -32703 )
    result = sub_10038CD0(a1, v2, (char *)&unk_1008A140, v1 + 4, 0, 255);
  else
    result = sub_10038CD0(a1, v2, (char *)&unk_1008A140, v1 + 4, v1 + 404, 255);
  return result;
}

//----- (1000D920) --------------------------------------------------------
int __cdecl sub_1000D920(int a1)
{
  int result; // eax@1
  int v2; // ecx@1
  _BYTE *v3; // esi@2
  int v4; // ebp@2
  int v5; // ebx@9
  int v6; // edx@11
  int v7; // eax@23
  float v8; // [sp-14h] [bp-8Ch]@9
  float v9; // [sp-10h] [bp-88h]@9
  float v10; // [sp-Ch] [bp-84h]@9
  float v11; // [sp-8h] [bp-80h]@9
  float v12; // [sp-4h] [bp-7Ch]@9
  float v13; // [sp+0h] [bp-78h]@9
  float v14; // [sp+4h] [bp-74h]@9
  float v15; // [sp+8h] [bp-70h]@9
  float v16; // [sp+Ch] [bp-6Ch]@9
  float v17; // [sp+10h] [bp-68h]@9
  float v18; // [sp+14h] [bp-64h]@9
  float v19; // [sp+18h] [bp-60h]@9
  int v20; // [sp+1Ch] [bp-5Ch]@18
  bool v21; // [sp+2Fh] [bp-49h]@7
  float v22; // [sp+30h] [bp-48h]@9
  float v23; // [sp+34h] [bp-44h]@9
  float v24; // [sp+38h] [bp-40h]@9
  float v25; // [sp+3Ch] [bp-3Ch]@9
  float v26; // [sp+40h] [bp-38h]@11
  _BYTE *v27; // [sp+44h] [bp-34h]@2
  float v28; // [sp+48h] [bp-30h]@11
  float v29; // [sp+4Ch] [bp-2Ch]@11
  int v30; // [sp+50h] [bp-28h]@2
  float v31; // [sp+54h] [bp-24h]@23
  float v32; // [sp+58h] [bp-20h]@23
  int v33; // [sp+5Ch] [bp-1Ch]@23
  float v34; // [sp+60h] [bp-18h]@23
  int v35; // [sp+64h] [bp-14h]@23
  int v36; // [sp+68h] [bp-10h]@23
  float v37; // [sp+6Ch] [bp-Ch]@23
  float v38; // [sp+70h] [bp-8h]@23
  float v39; // [sp+74h] [bp-4h]@23

  result = *(_BYTE *)(dword_102D2B44 + 175200);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( result > 0 )
  {
    v3 = (_BYTE *)(v2 + 942);
    v4 = 0;
    v27 = (_BYTE *)(v2 + 942);
    v30 = result;
    while ( 1 )
    {
      v21 = sub_1003E4E0(*((_WORD *)v3 - 1)) || !sub_10042F00() && *v3;
      v5 = dword_102D2B44;
      qmemcpy(&v8, (const void *)(dword_102D2B44 + v4 + 175244), 0x30u);
      result = sub_1000CD10(&v22, &v23, &v24, &v25, a1, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);
      if ( (_BYTE)result && !v21 )
      {
        sub_1000CCD0(*(_BYTE *)(v5 + v4 + 175205));
        v29 = sub_1000CDB0(*(_BYTE *)(v5 + v4 + 175240));
        v26 = 0.5;
        v28 = 0.0;
        if ( *(float *)(v5 + v4 + 175232) >= 0.0 )
          v26 = *(float *)(v5 + v4 + 175232);
        if ( *(float *)(v5 + v4 + 175236) >= 0.0 )
          v28 = *(float *)(v5 + v4 + 175236);
        result = *(_BYTE *)(v5 + v4 + 175204);
        switch ( result )
        {
          case 1:
            result = sub_1003A060((int)&v24, v23, v22, v25, v24, 0.0, 360.0, v6);
            break;
          case 2:
            v29 = v22 + v24;
            v17 = v29;
            v29 = v23 + v25;
            result = sub_1003A420(v23, v22, v29, v17, v6, 1.0);
            break;
          case 3:
            j_gdi_pvg_color_u32(v6);
            sub_10015770(1.0);
            j_gdi_pvg_begin(67);
            sub_10015960(v23, v22);
            sub_10015960(v25, v24);
            result = j_gdi_pvg_end(v20);
            break;
          case 4:
            if ( v26 == 0.0 || 1.0 == v26 )
              result = sub_1003E110(v5 + v4 + 175208, v23, v22, v25, v24);
            else
              result = sub_1003E150(v5 + v4 + 175208, v23, v22, v25, v24);
            break;
          case 5:
            v35 = 0;
            v31 = v23;
            v36 = v6;
            v32 = v22;
            v37 = v26;
            v38 = v28;
            v7 = sub_10038970(v29);
            v34 = v29;
            v33 = v7;
            v39 = sub_10016930(v7, dword_102D2B44 + v4 + 175208, v29);
            result = sub_100393A0(a1, dword_102D2B44 + v4 + 175208, (int)&v31);
            break;
          case 6:
            result = sub_10039EC0(v23, v22, v25, v24, v6, -16777216);
            break;
          case 7:
            result = sub_1003C070(v23, v22, v25, v24, 0.0, v6, -16777216);
            break;
          case 8:
            result = sub_1003C070(v23, v22, v25, v24, COERCE_FLOAT(1), v6, -16777216);
            break;
          case 9:
            result = sub_1003C070(v23, v22, v25, v24, COERCE_FLOAT(2), v6, -16777216);
            break;
          case 10:
            result = sub_1003C070(v23, v22, v25, v24, COERCE_FLOAT(3), v6, -16777216);
            break;
          default:
            break;
        }
      }
      v27 += 4;
      v4 += 120;
      if ( !--v30 )
        break;
      v3 = v27;
    }
  }
  return result;
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 102D2B44: using guessed type int dword_102D2B44;

//----- (1000DDA0) --------------------------------------------------------
int __usercall sub_1000DDA0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // edi@1
  double v3; // st6@6
  double v4; // st7@6
  double v5; // st5@7
  float v6; // ST00_4@12
  double v7; // st7@12
  float v8; // ST04_4@14
  int result; // eax@14
  int v10; // [sp+8h] [bp-10h]@0
  float v11; // [sp+10h] [bp-8h]@6
  float v12; // [sp+14h] [bp-4h]@6

  v1 = a1;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_1000D8C0(a1);
  if ( *(_BYTE *)(v2 + 6760) )
  {
    sub_10013F90(v2 + 6360);
    if ( *(_BYTE *)(dword_102D2B4C + 24) == 2 )
      sub_10013F90(v2 + 6560);
  }
  sub_1000D750(v1);
  sub_1000D920(v1);
  j_gdi_pvg_color_u32(-1);
  sub_10015770(1.0);
  j_gdi_pvg_begin(64);
  if ( !*(_BYTE *)(v2 + 6341) )
  {
    v11 = (double)*(signed int *)(v2 + 6344) + 0.0;
    v5 = (double)*(signed int *)(v2 + 6348) + 0.0;
    goto LABEL_9;
  }
  if ( *(_BYTE *)(v2 + 6341) == 2 )
  {
    v11 = 151.0;
    v5 = 686.0;
LABEL_9:
    v12 = v5;
    v3 = 0.0;
    v4 = 151.0;
    goto LABEL_10;
  }
  v3 = 0.0;
  v4 = 151.0;
  v11 = 0.0;
  v12 = 0.0;
LABEL_10:
  if ( *(_BYTE *)(v2 + 6342) && *(_BYTE *)(v2 + 6341) != 1 )
  {
    v11 = v4;
    v12 = 469.0;
    v6 = v4;
    sub_10015960(v6, 469.0);
    sub_10015960(210.0, 469.0);
    sub_10015960(209.0, 468.0);
    sub_10015960(209.0, 686.0);
    v7 = 0.0;
  }
  else
  {
    v7 = v3;
  }
  v8 = v7;
  sub_10015960(v11, v8);
  sub_10015960(v11, v12);
  result = j_gdi_pvg_end(v10);
  *(_BYTE *)(v1 + 6) = 2;
  return result;
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000DF20) --------------------------------------------------------
int __usercall sub_1000DF20@<eax>(int a1@<edx>, int a2@<ecx>, int a3, char a4)
{
  int v4; // ebx@1
  int v5; // eax@1
  bool v6; // zf@1
  int v7; // esi@1
  double v8; // st7@2
  double v9; // st7@3
  char v10; // al@3
  float v11; // ebx@3
  float v12; // edx@5
  const char *v13; // esi@6
  int v14; // edi@6
  char *v15; // eax@7
  char v16; // cl@8
  double v17; // st7@10
  int v18; // eax@11
  int v19; // esi@12
  int v20; // ecx@12
  int v21; // ecx@16
  char v22; // dl@16
  float v23; // eax@17
  __int16 v24; // ax@19
  double v25; // st7@19
  int v26; // edx@19
  int v27; // eax@19
  int result; // eax@19
  char v29; // [sp+4h] [bp-E50h]@3
  int v30; // [sp+8h] [bp-E4Ch]@3
  int v31; // [sp+Ch] [bp-E48h]@3
  int v32; // [sp+10h] [bp-E44h]@3
  int v33; // [sp+14h] [bp-E40h]@3
  int v34; // [sp+18h] [bp-E3Ch]@3
  int v35; // [sp+1Ch] [bp-E38h]@3
  int v36; // [sp+20h] [bp-E34h]@3
  int v37; // [sp+24h] [bp-E30h]@3
  int v38; // [sp+28h] [bp-E2Ch]@3
  int v39; // [sp+2Ch] [bp-E28h]@3
  int v40; // [sp+30h] [bp-E24h]@3
  int v41; // [sp+34h] [bp-E20h]@3
  int v42; // [sp+38h] [bp-E1Ch]@3
  int v43; // [sp+3Ch] [bp-E18h]@3
  int v44; // [sp+40h] [bp-E14h]@3
  int v45; // [sp+44h] [bp-E10h]@3
  int v46; // [sp+48h] [bp-E0Ch]@3
  int v47; // [sp+4Ch] [bp-E08h]@3
  int v48; // [sp+50h] [bp-E04h]@3
  int v49; // [sp+54h] [bp-E00h]@3
  int v50; // [sp+58h] [bp-DFCh]@3
  int v51; // [sp+5Ch] [bp-DF8h]@3
  int v52; // [sp+60h] [bp-DF4h]@3
  int v53; // [sp+64h] [bp-DF0h]@3
  int v54; // [sp+68h] [bp-DECh]@3
  int v55; // [sp+6Ch] [bp-DE8h]@3
  int v56; // [sp+70h] [bp-DE4h]@3
  int v57; // [sp+74h] [bp-DE0h]@3
  int v58; // [sp+78h] [bp-DDCh]@3
  int v59; // [sp+7Ch] [bp-DD8h]@3
  int v60; // [sp+80h] [bp-DD4h]@3
  int v61; // [sp+84h] [bp-DD0h]@3
  int v62; // [sp+88h] [bp-DCCh]@3
  int v63; // [sp+8Ch] [bp-DC8h]@3
  int v64; // [sp+90h] [bp-DC4h]@3
  int v65; // [sp+94h] [bp-DC0h]@3
  int v66; // [sp+98h] [bp-DBCh]@3
  int v67; // [sp+9Ch] [bp-DB8h]@3
  int v68; // [sp+A0h] [bp-DB4h]@3
  int v69; // [sp+A4h] [bp-DB0h]@3
  int v70; // [sp+A8h] [bp-DACh]@3
  int v71; // [sp+ACh] [bp-DA8h]@3
  int v72; // [sp+B0h] [bp-DA4h]@3
  int v73; // [sp+B4h] [bp-DA0h]@3
  int v74; // [sp+B8h] [bp-D9Ch]@3
  int v75; // [sp+BCh] [bp-D98h]@3
  int v76; // [sp+C0h] [bp-D94h]@3
  int v77; // [sp+C4h] [bp-D90h]@3
  int v78; // [sp+C8h] [bp-D8Ch]@3
  int v79; // [sp+CCh] [bp-D88h]@3
  int v80; // [sp+D0h] [bp-D84h]@3
  int v81; // [sp+D4h] [bp-D80h]@3
  int v82; // [sp+D8h] [bp-D7Ch]@3
  int v83; // [sp+DCh] [bp-D78h]@3
  int v84; // [sp+E0h] [bp-D74h]@3
  int v85; // [sp+E4h] [bp-D70h]@3
  int v86; // [sp+E8h] [bp-D6Ch]@3
  int v87; // [sp+ECh] [bp-D68h]@3
  int v88; // [sp+F0h] [bp-D64h]@3
  int v89; // [sp+F4h] [bp-D60h]@12
  float v90; // [sp+570h] [bp-8E4h]@10
  float v91; // [sp+574h] [bp-8E0h]@10
  float v92; // [sp+578h] [bp-8DCh]@10
  float v93; // [sp+57Ch] [bp-8D8h]@10
  float v94; // [sp+580h] [bp-8D4h]@3
  float v95; // [sp+594h] [bp-8C0h]@2
  char v96[4]; // [sp+598h] [bp-8BCh]@1
  int v97; // [sp+59Ch] [bp-8B8h]@1
  float v98; // [sp+5A0h] [bp-8B4h]@7
  int v99; // [sp+5A4h] [bp-8B0h]@1
  int v100; // [sp+5A8h] [bp-8ACh]@3
  int v101; // [sp+5ACh] [bp-8A8h]@3
  char v102; // [sp+5B4h] [bp-8A0h]@6
  char v103; // [sp+8CCh] [bp-588h]@3

  v4 = a2;
  v5 = 1752 * a3;
  v99 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  v6 = *(_BYTE *)(1752 * a3 + dword_102D2B44 + 1716) == 0;
  v7 = a1;
  *(_DWORD *)v96 = a1;
  v97 = 1752 * a3;
  if ( !v6 )
  {
    *(float *)(a1 + 220) = *(float *)(v5 + dword_102D2B44 + 1720);
    v95 = *(float *)(v5 + dword_102D2B44 + 1724);
    v8 = v95;
    *(float *)(a1 + 224) = v95;
    *(float *)(a1 + 324) = v8 - *(float *)(a1 + 220);
    *(float *)(a1 + 2060) = *(float *)(a1 + 220);
    sub_1000D290(a1);
  }
  sub_1000D430(a3, v4);
  *(_DWORD *)(28 * a3 + v99 + 2764) = v7 + 5568;
  v9 = *(float *)(v7 + 4);
  v100 = 28 * a3;
  v94 = v9;
  sub_1000D6C0(v97 + dword_102D2B44, v7 + 100, *(float *)v7, v94);
  sub_1000D6C0(v97 + dword_102D2B44 + 36, v7 + 152, *(float *)v7, *(float *)(v7 + 4));
  v95 = *(float *)(v7 + 224) - *(float *)(v7 + 220);
  sub_1000D4A0(v7 + 308, (_BYTE *)(164 * a3 + dword_102D2B4C + 3912), v7 + 404, v95);
  sub_10034CB0((_BYTE *)(164 * a3 + dword_102D2B4C + 3912), v7);
  v94 = 0.0;
  qmemcpy(&v103, (const void *)(v97 + dword_102D2B44 + 140), 0x57Cu);
  qmemcpy(&v29, (const void *)(v97 + dword_102D2B44 + 140), 0x57Cu);
  v10 = sub_1000CED0(
          &v101,
          0x32u,
          -0.2,
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          v36,
          v37,
          v38,
          v39,
          v40,
          v41,
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          v58,
          v59,
          v60,
          v61,
          v62,
          v63,
          v64,
          v65,
          v66,
          v67,
          v68,
          v69,
          v70,
          v71,
          v72,
          v73,
          v74,
          v75,
          v76,
          v77,
          v78,
          v79,
          v80,
          v81,
          v82,
          v83,
          v84,
          v85,
          v86,
          v87,
          v88);
  v11 = *(float *)v96;
  sub_10035190((int)&v101, v10, 0.0, *(int *)v96);
  v95 = 1.1;
  if ( *(_BYTE *)(v97 + dword_102D2B44 + 1717) )
    v95 = -0.5;
  v12 = 0.0;
  v6 = *(_BYTE *)(LODWORD(v11) + 5556) == 0;
  *(_DWORD *)v96 = 0;
  if ( !v6 )
  {
    v13 = &v102;
    v14 = LODWORD(v11) + 2392;
    do
    {
      v15 = (char *)v14;
      LODWORD(v98) = v14 + 1;
      do
        v16 = *v15++;
      while ( v16 );
      if ( v15 != (char *)LODWORD(v98) )
      {
        v17 = *((float *)v13 - 1);
        v94 = v11;
        v93 = v12;
        v98 = v17 * v95;
        v92 = v98;
        v91 = *(float *)(v14 + 16);
        v90 = 1.0;
        sub_10034E90(*((float *)v13 - 2), "%.0f", 1.0, v91, v98, SLODWORD(v12), SLODWORD(v11));
        strcpy((char *)v14, v13);
        v12 = *(float *)v96;
      }
      v18 = *(_BYTE *)(LODWORD(v11) + 5556);
      ++LODWORD(v12);
      v14 += 64;
      v13 += 16;
      *(float *)v96 = v12;
    }
    while ( SLODWORD(v12) < v18 );
  }
  v94 = 0.0;
  qmemcpy(&v29, &v103, 0x57Cu);
  sub_1000D5B0(
    LODWORD(v11) + 2356,
    *(_BYTE *)(LODWORD(v11) + 5556),
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    v58,
    v59,
    v60,
    v61,
    v62,
    v63,
    v64,
    v65,
    v66,
    v67,
    v68,
    v69,
    v70,
    v71,
    v72,
    v73,
    v74,
    v75,
    v76,
    v77,
    v78,
    v79,
    v80,
    v81,
    v82,
    v83,
    v84,
    v85,
    v86,
    v87,
    v88,
    v89);
  v19 = v97;
  if ( (unsigned __int8)sub_1000D1B0(v97 + dword_102D2B44 + 80) )
  {
    sub_1000D490(v99 + 8 * a3 + 5540, v20);
    sub_1000CBD0(&v95, *(_BYTE *)(v19 + dword_102D2B44 + 88), v96);
    sub_10034DE0(0.0, v96[0], v99 + 8 * a3 + 5544, SLODWORD(v11));
    *(_DWORD *)(LODWORD(v11) + 2104) = sub_1000CCD0(*(_BYTE *)(v19 + dword_102D2B44 + 89));
    if ( LODWORD(v95) != 138 )
      *(float *)(LODWORD(v11) + 2112) = v95;
    *(_BYTE *)(LODWORD(v11) + 2296) = 1;
    *(float *)(LODWORD(v11) + 2100) = 0.0;
  }
  v21 = dword_102D2B44;
  v22 = *(_BYTE *)(v19 + dword_102D2B44 + 73);
  if ( v22 )
  {
    sub_1000CBD0(&v95, v22, v96);
    v23 = v95;
    v6 = LODWORD(v95) == 138;
    *(_BYTE *)(LODWORD(v11) + 2072) = v96[0];
    if ( !v6 )
      *(float *)(LODWORD(v11) + 2076) = v23;
  }
  v24 = sub_1000CE60(v21, *(_WORD *)(v19 + dword_102D2B44 + 78));
  v25 = *(float *)(LODWORD(v11) + 4);
  v26 = v100;
  *(_WORD *)(LODWORD(v11) + 5558) = v24;
  v94 = v25;
  sub_1000D540(v26 + dword_102D2B4C + 20480, LODWORD(v11) + 2300, *(float *)LODWORD(v11), v94);
  v27 = v99 + 28 * (a3 + 98);
  *(_DWORD *)(LODWORD(v11) + 44) = v27;
  *(_DWORD *)(LODWORD(v11) + 48) = v27;
  *(_DWORD *)(LODWORD(v11) + 2320) = v27;
  *(_BYTE *)(LODWORD(v11) + 2348) = (a4 & 1u) >= 1;
  *(_BYTE *)(LODWORD(v11) + 2351) = (a4 & 4u) >= 1;
  result = a3;
  *(_BYTE *)(LODWORD(v11) + 2350) = (a4 & 2u) >= 1;
  return result;
}
// 102D2B44: using guessed type int dword_102D2B44;
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000E370) --------------------------------------------------------
int __cdecl sub_1000E370(int a1, int a2, signed int a3, char a4)
{
  int v4; // ecx@0
  int v5; // esi@1
  int v6; // ecx@1
  double v7; // st7@2
  double v8; // st7@4
  float v9; // ebx@4
  float v10; // ST08_4@4
  unsigned __int8 v11; // al@4
  unsigned __int8 v12; // dl@4
  int v13; // eax@5
  int v14; // edi@5
  char v15; // dl@6
  int *v16; // eax@8
  int *v17; // ecx@8
  int v18; // edx@8
  bool v19; // zf@8
  char v21; // [sp+4h] [bp-E68h]@4
  int v22; // [sp+8h] [bp-E64h]@4
  int v23; // [sp+Ch] [bp-E60h]@4
  int v24; // [sp+10h] [bp-E5Ch]@4
  int v25; // [sp+14h] [bp-E58h]@4
  int v26; // [sp+18h] [bp-E54h]@4
  int v27; // [sp+1Ch] [bp-E50h]@4
  int v28; // [sp+20h] [bp-E4Ch]@4
  int v29; // [sp+24h] [bp-E48h]@4
  int v30; // [sp+28h] [bp-E44h]@4
  int v31; // [sp+2Ch] [bp-E40h]@4
  int v32; // [sp+30h] [bp-E3Ch]@4
  int v33; // [sp+34h] [bp-E38h]@4
  int v34; // [sp+38h] [bp-E34h]@4
  int v35; // [sp+3Ch] [bp-E30h]@4
  int v36; // [sp+40h] [bp-E2Ch]@4
  int v37; // [sp+44h] [bp-E28h]@4
  int v38; // [sp+48h] [bp-E24h]@4
  int v39; // [sp+4Ch] [bp-E20h]@4
  int v40; // [sp+50h] [bp-E1Ch]@4
  int v41; // [sp+54h] [bp-E18h]@4
  int v42; // [sp+58h] [bp-E14h]@4
  int v43; // [sp+5Ch] [bp-E10h]@4
  int v44; // [sp+60h] [bp-E0Ch]@4
  int v45; // [sp+64h] [bp-E08h]@4
  int v46; // [sp+68h] [bp-E04h]@4
  int v47; // [sp+6Ch] [bp-E00h]@4
  int v48; // [sp+70h] [bp-DFCh]@4
  int v49; // [sp+74h] [bp-DF8h]@4
  int v50; // [sp+78h] [bp-DF4h]@4
  int v51; // [sp+7Ch] [bp-DF0h]@4
  int v52; // [sp+80h] [bp-DECh]@4
  int v53; // [sp+84h] [bp-DE8h]@4
  int v54; // [sp+88h] [bp-DE4h]@4
  int v55; // [sp+8Ch] [bp-DE0h]@4
  int v56; // [sp+90h] [bp-DDCh]@4
  int v57; // [sp+94h] [bp-DD8h]@4
  int v58; // [sp+98h] [bp-DD4h]@4
  int v59; // [sp+9Ch] [bp-DD0h]@4
  int v60; // [sp+A0h] [bp-DCCh]@4
  int v61; // [sp+A4h] [bp-DC8h]@4
  int v62; // [sp+A8h] [bp-DC4h]@4
  int v63; // [sp+ACh] [bp-DC0h]@4
  int v64; // [sp+B0h] [bp-DBCh]@4
  int v65; // [sp+B4h] [bp-DB8h]@4
  int v66; // [sp+B8h] [bp-DB4h]@4
  int v67; // [sp+BCh] [bp-DB0h]@4
  int v68; // [sp+C0h] [bp-DACh]@4
  int v69; // [sp+C4h] [bp-DA8h]@4
  int v70; // [sp+C8h] [bp-DA4h]@4
  int v71; // [sp+CCh] [bp-DA0h]@4
  int v72; // [sp+D0h] [bp-D9Ch]@4
  int v73; // [sp+D4h] [bp-D98h]@4
  int v74; // [sp+D8h] [bp-D94h]@4
  int v75; // [sp+DCh] [bp-D90h]@4
  int v76; // [sp+E0h] [bp-D8Ch]@4
  int v77; // [sp+E4h] [bp-D88h]@4
  int v78; // [sp+E8h] [bp-D84h]@4
  int v79; // [sp+ECh] [bp-D80h]@4
  int v80; // [sp+F0h] [bp-D7Ch]@4
  int v81; // [sp+F4h] [bp-D78h]@4
  int v82; // [sp+F8h] [bp-D74h]@4
  int v83; // [sp+FCh] [bp-D70h]@4
  float v84; // [sp+580h] [bp-8ECh]@4
  float v85; // [sp+584h] [bp-8E8h]@4
  float v86; // [sp+588h] [bp-8E4h]@4
  float v87; // [sp+59Ch] [bp-8D0h]@2
  char v88; // [sp+5A3h] [bp-8C9h]@7
  int v89; // [sp+5A4h] [bp-8C8h]@4
  float v90; // [sp+5A8h] [bp-8C4h]@4
  char *v91; // [sp+5ACh] [bp-8C0h]@5
  int *v92; // [sp+5B0h] [bp-8BCh]@1
  float v93; // [sp+5B4h] [bp-8B8h]@1
  int v94; // [sp+5B8h] [bp-8B4h]@1
  int v95; // [sp+5BCh] [bp-8B0h]@5
  char v96; // [sp+5C0h] [bp-8ACh]@7
  char v97; // [sp+5C4h] [bp-8A8h]@4
  char v98; // [sp+8E4h] [bp-588h]@4

  v94 = a1;
  v5 = v4;
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v93 = *(float *)&v5;
  v92 = (int *)v6;
  if ( a3 <= 1 )
  {
    v7 = -0.60000002;
    LOBYTE(v87) = 0;
  }
  else
  {
    v7 = -0.30000001;
    LOBYTE(v87) = 1;
  }
  *(float *)&v89 = v7;
  v86 = *(float *)(v5 + 4);
  LODWORD(v90) = 1752 * a2;
  sub_1000D6C0(1752 * a2 + dword_102D2B44, v5 + 64, *(float *)v5, v86);
  sub_1000D6C0(1752 * a2 + dword_102D2B44 + 36, v5 + 116, *(float *)v5, *(float *)(v5 + 4));
  v8 = *(float *)&v89;
  v9 = v93;
  *(_WORD *)(v5 + 4312) = sub_1000CE60(dword_102D2B44, *(_WORD *)(1752 * a2 + dword_102D2B44 + 78));
  v86 = v9;
  v85 = 0.0;
  qmemcpy(&v98, (const void *)(1752 * a2 + dword_102D2B44 + 140), 0x57Cu);
  v84 = v87;
  qmemcpy(&v21, (const void *)(1752 * a2 + dword_102D2B44 + 140), 0x57Cu);
  v10 = v8;
  v11 = sub_1000CED0(
          &v97,
          0x32u,
          v10,
          v21,
          v22,
          v23,
          v24,
          v25,
          v26,
          v27,
          v28,
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          v36,
          v37,
          v38,
          v39,
          v40,
          v41,
          v42,
          v43,
          v44,
          v45,
          v46,
          v47,
          v48,
          v49,
          v50,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          v58,
          v59,
          v60,
          v61,
          v62,
          v63,
          v64,
          v65,
          v66,
          v67,
          v68,
          v69,
          v70,
          v71,
          v72,
          v73,
          v74,
          v75,
          v76,
          v77,
          v78,
          v79,
          v80);
  sub_10020EB0((int)&v97, v11, SLOBYTE(v85), SLODWORD(v86));
  v12 = *(_BYTE *)(LODWORD(v9) + 4036);
  v86 = v87;
  qmemcpy(&v23, &v98, 0x57Cu);
  sub_1000D5B0(
    LODWORD(v9) + 836,
    v12,
    v23,
    v24,
    v25,
    v26,
    v27,
    v28,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38,
    v39,
    v40,
    v41,
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    v48,
    v49,
    v50,
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    v58,
    v59,
    v60,
    v61,
    v62,
    v63,
    v64,
    v65,
    v66,
    v67,
    v68,
    v69,
    v70,
    v71,
    v72,
    v73,
    v74,
    v75,
    v76,
    v77,
    v78,
    v79,
    v80,
    v81,
    v82,
    v83);
  if ( a3 > 0 )
  {
    v87 = v90;
    LODWORD(v90) = LODWORD(v9) + 4324;
    v89 = LODWORD(v9) + 4060;
    v13 = (int)v92;
    v14 = (int)&v92[7 * (a2 + 98)];
    v92 = (int *)(LODWORD(v9) + 52);
    v91 = (char *)(LODWORD(v9) + 484);
    v95 = -2744 - v13;
    v93 = *(float *)&a3;
    do
    {
      sub_1000D430(a2, v94);
      v15 = *(_BYTE *)(LODWORD(v87) + dword_102D2B44 + 73);
      if ( v15 )
      {
        sub_1000CBD0(&v96, v15, &v88);
        v91[30] = v88;
      }
      strncpy(v91, (const char *)(LODWORD(v87) + dword_102D2B44 + 1736), 7u);
      sub_1000D540(v14 + v95 + dword_102D2B4C + 20480, v89 - 20, *(float *)LODWORD(v9), *(float *)(LODWORD(v9) + 4));
      v16 = v92;
      v17 = (int *)v89;
      v18 = LODWORD(v90);
      v91 += 64;
      LODWORD(v87) += 1752;
      *(v92 - 6) = v14;
      *v16 = v14;
      *v17 = v14;
      v92 = v16 + 1;
      ++a2;
      *(_DWORD *)(v14 + 20) = v18;
      v14 += 28;
      v19 = LODWORD(v93)-- == 1;
      v89 = (int)(v17 + 12);
      LODWORD(v90) = v18 + 28;
    }
    while ( !v19 );
  }
  *(_BYTE *)(LODWORD(v9) + 4185) = (a4 & 1u) >= 1;
  *(_BYTE *)(LODWORD(v9) + 4188) = (a4 & 4u) >= 1;
  *(_BYTE *)(LODWORD(v9) + 4187) = (a4 & 2u) >= 1;
  return a2 - 1;
}
// 102D2B44: using guessed type int dword_102D2B44;
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000E650) --------------------------------------------------------
int __usercall sub_1000E650@<eax>(int a1@<edi>, int a2, int a3, int a4, char a5)
{
  int v5; // esi@1
  int v6; // ecx@1
  __int16 v7; // ax@1
  int v8; // edx@1
  int *v9; // ebx@2
  _DWORD *v10; // ebp@2
  int result; // eax@4
  int v12; // [sp+14h] [bp-8h]@1
  int v13; // [sp+14h] [bp-8h]@2
  int v14; // [sp+18h] [bp-4h]@2
  int v15; // [sp+28h] [bp+Ch]@2

  v5 = a3;
  v12 = *(_DWORD *)(*(_DWORD *)(a2 + 56) + 12);
  sub_1000D6C0(dword_102D2B44 + 1752 * a3, a1 + 176, *(float *)a1, *(float *)(a1 + 4));
  sub_1000D6C0(dword_102D2B44 + 1752 * a3 + 36, a1 + 280, *(float *)a1, *(float *)(a1 + 4));
  v7 = sub_1000CE60(v6, *(_WORD *)(dword_102D2B44 + 1752 * a3 + 78));
  v8 = a4;
  *(_WORD *)(a1 + 516) = v7;
  if ( a4 > 0 )
  {
    v9 = (int *)(v12 + 28 * a3 + 2764);
    v15 = a1 + 528;
    v10 = (_DWORD *)(a1 + 48);
    v14 = -2764 - v12;
    v13 = v8;
    do
    {
      sub_1000D430(v5, a2);
      sub_1000D540((int)v9 + v14 + dword_102D2B4C + 20480, (int)(v10 - 5), *(float *)a1, *(float *)(a1 + 4));
      *v10 = v9 - 5;
      *v9 = v15;
      v15 += 28;
      v5 = ++a3;
      v10 += 12;
      v9 += 7;
      --v13;
    }
    while ( v13 );
  }
  result = v5 - 1;
  *(_BYTE *)(a1 + 174) = (a5 & 2u) >= 1;
  return result;
}
// 102D2B44: using guessed type int dword_102D2B44;
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000E790) --------------------------------------------------------
int __cdecl sub_1000E790(int a1, int a2, int a3, char a4)
{
  int v4; // ecx@0
  int v5; // esi@1
  int v6; // edi@1
  double v7; // st7@2
  char v8; // dl@6
  int v9; // eax@9
  int v10; // ebx@9
  char v11; // cl@12
  float v12; // ebx@15
  const void *v13; // eax@15
  unsigned __int8 v14; // al@15
  int v15; // esi@15
  int v16; // ecx@15
  int v17; // ecx@16
  int v18; // edi@17
  double v19; // st7@17
  int *v20; // ebx@17
  int *v21; // eax@17
  int v22; // edx@17
  int v23; // ecx@17
  char v25; // [sp+4h] [bp-E90h]@15
  int v26; // [sp+8h] [bp-E8Ch]@15
  int v27; // [sp+Ch] [bp-E88h]@15
  int v28; // [sp+10h] [bp-E84h]@15
  int v29; // [sp+14h] [bp-E80h]@15
  int v30; // [sp+18h] [bp-E7Ch]@15
  int v31; // [sp+1Ch] [bp-E78h]@15
  int v32; // [sp+20h] [bp-E74h]@15
  int v33; // [sp+24h] [bp-E70h]@15
  int v34; // [sp+28h] [bp-E6Ch]@15
  int v35; // [sp+2Ch] [bp-E68h]@15
  int v36; // [sp+30h] [bp-E64h]@15
  int v37; // [sp+34h] [bp-E60h]@15
  int v38; // [sp+38h] [bp-E5Ch]@15
  int v39; // [sp+3Ch] [bp-E58h]@15
  int v40; // [sp+40h] [bp-E54h]@15
  int v41; // [sp+44h] [bp-E50h]@15
  int v42; // [sp+48h] [bp-E4Ch]@15
  int v43; // [sp+4Ch] [bp-E48h]@15
  int v44; // [sp+50h] [bp-E44h]@15
  int v45; // [sp+54h] [bp-E40h]@15
  int v46; // [sp+58h] [bp-E3Ch]@15
  int v47; // [sp+5Ch] [bp-E38h]@15
  int v48; // [sp+60h] [bp-E34h]@15
  int v49; // [sp+64h] [bp-E30h]@15
  int v50; // [sp+68h] [bp-E2Ch]@15
  int v51; // [sp+6Ch] [bp-E28h]@15
  int v52; // [sp+70h] [bp-E24h]@15
  int v53; // [sp+74h] [bp-E20h]@15
  int v54; // [sp+78h] [bp-E1Ch]@15
  int v55; // [sp+7Ch] [bp-E18h]@15
  int v56; // [sp+80h] [bp-E14h]@15
  int v57; // [sp+84h] [bp-E10h]@15
  int v58; // [sp+88h] [bp-E0Ch]@15
  int v59; // [sp+8Ch] [bp-E08h]@15
  int v60; // [sp+90h] [bp-E04h]@15
  int v61; // [sp+94h] [bp-E00h]@15
  int v62; // [sp+98h] [bp-DFCh]@15
  int v63; // [sp+9Ch] [bp-DF8h]@15
  int v64; // [sp+A0h] [bp-DF4h]@15
  int v65; // [sp+A4h] [bp-DF0h]@15
  int v66; // [sp+A8h] [bp-DECh]@15
  int v67; // [sp+ACh] [bp-DE8h]@15
  int v68; // [sp+B0h] [bp-DE4h]@15
  int v69; // [sp+B4h] [bp-DE0h]@15
  int v70; // [sp+B8h] [bp-DDCh]@15
  int v71; // [sp+BCh] [bp-DD8h]@15
  int v72; // [sp+C0h] [bp-DD4h]@15
  int v73; // [sp+C4h] [bp-DD0h]@15
  int v74; // [sp+C8h] [bp-DCCh]@15
  int v75; // [sp+CCh] [bp-DC8h]@15
  int v76; // [sp+D0h] [bp-DC4h]@15
  int v77; // [sp+D4h] [bp-DC0h]@15
  int v78; // [sp+D8h] [bp-DBCh]@15
  int v79; // [sp+DCh] [bp-DB8h]@15
  int v80; // [sp+E0h] [bp-DB4h]@15
  int v81; // [sp+E4h] [bp-DB0h]@15
  int v82; // [sp+E8h] [bp-DACh]@15
  int v83; // [sp+ECh] [bp-DA8h]@15
  int v84; // [sp+F0h] [bp-DA4h]@15
  int v85; // [sp+F4h] [bp-DA0h]@15
  int v86; // [sp+F8h] [bp-D9Ch]@15
  int v87; // [sp+FCh] [bp-D98h]@15
  float v88; // [sp+580h] [bp-914h]@15
  float v89; // [sp+584h] [bp-910h]@15
  float v90; // [sp+588h] [bp-90Ch]@4
  char v91; // [sp+59Fh] [bp-8F5h]@7
  int v92; // [sp+5A0h] [bp-8F4h]@4
  int v93; // [sp+5A4h] [bp-8F0h]@9
  int v94; // [sp+5A8h] [bp-8ECh]@8
  int v95; // [sp+5ACh] [bp-8E8h]@9
  int v96; // [sp+5B0h] [bp-8E4h]@9
  float v97; // [sp+5B4h] [bp-8E0h]@1
  int v98; // [sp+5B8h] [bp-8DCh]@9
  float v99; // [sp+5BCh] [bp-8D8h]@13
  int v100; // [sp+5C0h] [bp-8D4h]@9
  int v101; // [sp+5C4h] [bp-8D0h]@9
  int *v102; // [sp+5C8h] [bp-8CCh]@9
  int v103; // [sp+5CCh] [bp-8C8h]@9
  float v104; // [sp+5D0h] [bp-8C4h]@4
  int v105; // [sp+5D4h] [bp-8C0h]@9
  int *v106; // [sp+5D8h] [bp-8BCh]@9
  float v107; // [sp+5DCh] [bp-8B8h]@2
  int v108; // [sp+5E0h] [bp-8B4h]@1
  int v109; // [sp+5E4h] [bp-8B0h]@9
  char v110; // [sp+5E8h] [bp-8ACh]@7
  char v111; // [sp+5ECh] [bp-8A8h]@15
  char v112; // [sp+90Ch] [bp-588h]@15

  v108 = a1;
  v5 = v4;
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v97 = *(float *)&v4;
  if ( a3 <= 1 )
  {
    v107 = 0.30000001;
    v7 = 0.2;
  }
  else
  {
    v107 = 0.60000002;
    v7 = 0.40000001;
  }
  v104 = v7;
  v90 = *(float *)(v4 + 4);
  v92 = 1752 * a2;
  sub_1000D6C0(1752 * a2 + dword_102D2B44, v4 + 116, *(float *)v4, v90);
  sub_1000D6C0(1752 * a2 + dword_102D2B44 + 36, v5 + 272, *(float *)v5, *(float *)(v5 + 4));
  *(_WORD *)(v5 + 11450) = sub_1000CE60(dword_102D2B44, *(_WORD *)(1752 * a2 + dword_102D2B44 + 78));
  if ( *(_BYTE *)(1752 * a2 + dword_102D2B44 + 1716) )
    *(_BYTE *)(v5 + 11449) = 0;
  v8 = *(_BYTE *)(1752 * a2 + dword_102D2B44 + 73);
  if ( v8 )
  {
    sub_1000CBD0(&v110, v8, &v91);
    *(_BYTE *)(v5 + 11544) = v91;
  }
  v94 = 0;
  if ( a3 > 0 )
  {
    v102 = (int *)(v5 + 11316);
    v98 = 0;
    v9 = a2;
    v105 = v5 + 11460;
    v93 = 1752 * a2;
    v103 = v6 + 28 * (a2 + 98);
    v10 = 164 * a2;
    v92 = v6 + 8 * a2 + 5544;
    v106 = (int *)(v5 + 40);
    v101 = v5 + 1332;
    v100 = v6 + 5540;
    v95 = 164 * a2;
    v96 = v5 + 10956;
    v109 = -2744 - v6;
    while ( 1 )
    {
      sub_1000D430(v9, v108);
      sub_1000D4A0(v96, (_BYTE *)(v10 + dword_102D2B4C + 3912), v96 + 96, *(float *)(v5 + 12));
      sub_1001C950(v95 + dword_102D2B4C + 3912, v104, v5);
      if ( v94 == 3 || (v11 = *(_BYTE *)(v93 + dword_102D2B44 + 72), v11 == 8) || (LOBYTE(v99) = 0, v11 == 9) )
        LOBYTE(v99) = 1;
      v12 = v97;
      v90 = v97;
      v13 = (const void *)(v93 + dword_102D2B44 + 140);
      v89 = 0.0;
      v88 = v99;
      qmemcpy(&v112, v13, 0x57Cu);
      qmemcpy(&v25, v13, 0x57Cu);
      v88 = COERCE_FLOAT(sub_1000CED0(&v111, 0x32u, v107, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84));
      off_1008A06C[v94]((int)&v111, LOBYTE(v88), LOBYTE(v89), SLODWORD(v90));
      v14 = *(_BYTE *)(LODWORD(v12) + v94 + 10932);
      v90 = v99;
      qmemcpy(&v27, &v112, 0x57Cu);
      sub_1000D5B0(
        v101,
        v14,
        v27,
        v28,
        v29,
        v30,
        v31,
        v32,
        v33,
        v34,
        v35,
        v36,
        v37,
        v38,
        v39,
        v40,
        v41,
        v42,
        v43,
        v44,
        v45,
        v46,
        v47,
        v48,
        v49,
        v50,
        v51,
        v52,
        v53,
        v54,
        v55,
        v56,
        v57,
        v58,
        v59,
        v60,
        v61,
        v62,
        v63,
        v64,
        v65,
        v66,
        v67,
        v68,
        v69,
        v70,
        v71,
        v72,
        v73,
        v74,
        v75,
        v76,
        v77,
        v78,
        v79,
        v80,
        v81,
        v82,
        v83,
        v84,
        v85,
        v86,
        v87);
      v15 = v93;
      if ( (unsigned __int8)sub_1000D1B0(v93 + dword_102D2B44 + 80) )
      {
        sub_1000D490(v100, v98 + v16 + 80);
        sub_1000CBD0(&v110, *(_BYTE *)(v15 + dword_102D2B44 + 88), &v91);
        v17 = v92;
        *(_BYTE *)(LODWORD(v12) + 80) = v91;
        *(_DWORD *)(LODWORD(v12) + 76) = v17;
      }
      v18 = v103;
      v90 = *(float *)(LODWORD(v12) + 4);
      v19 = *(float *)LODWORD(v12);
      v20 = v102;
      v89 = v19;
      sub_1000D540(v103 + v109 + dword_102D2B4C + 20480, (int)(v102 - 5), v89, v90);
      v21 = v106;
      v22 = v105;
      v23 = v94;
      v96 += 120;
      v101 += 3200;
      ++a2;
      v95 += 164;
      *(v106 - 3) = v18;
      *v21 = v18;
      *v20 = v18;
      v98 += 1752;
      v93 += 1752;
      v5 = LODWORD(v97);
      v106 = v21 + 1;
      v100 += 8;
      v92 += 8;
      *(_DWORD *)(v18 + 20) = v22;
      v94 = v23 + 1;
      v102 = v20 + 12;
      v105 = v22 + 28;
      v103 = v18 + 28;
      if ( v23 + 1 >= a3 )
        break;
      v10 = v95;
      v9 = a2;
    }
  }
  *(_BYTE *)(v5 + 11440) = (a4 & 1u) >= 1;
  *(_BYTE *)(v5 + 11445) = (a4 & 4u) >= 1;
  *(_BYTE *)(v5 + 11444) = (a4 & 2u) >= 1;
  return a2 - 1;
}
// 1008A06C: using guessed type int (__cdecl *off_1008A06C[3])(int, int, char, int);
// 102D2B44: using guessed type int dword_102D2B44;
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000EBA0) --------------------------------------------------------
char *__thiscall sub_1000EBA0(int this)
{
  int v1; // ebx@1
  int v2; // ecx@1
  int v3; // eax@1
  int v4; // ecx@3
  _DWORD *v5; // eax@3
  char *result; // eax@3
  float v7; // edi@3
  _DWORD *v8; // ecx@4
  __int16 v9; // ax@4
  int v10; // esi@4
  _DWORD *v11; // eax@4
  int v12; // eax@5
  int v13; // esi@5
  int v14; // eax@6
  int v15; // esi@6
  int v16; // eax@8
  int v17; // eax@9
  char *v18; // edx@9
  float v19; // esi@9
  double v20; // st7@9
  unsigned int v21; // ebx@9
  int v22; // ecx@13
  __int16 v23; // ax@13
  _DWORD *v24; // edx@13
  double v25; // st7@13
  char v26; // al@13
  int v27; // ebx@13
  unsigned __int8 v28; // dl@13
  signed int v29; // ecx@13
  float *v30; // eax@14
  double v31; // st6@15
  char v32; // al@16
  char *v33; // esi@16
  unsigned __int8 v34; // cl@16
  _DWORD *v35; // edx@16
  bool v36; // zf@16
  int v37; // edx@16
  int v38; // eax@17
  int v39; // eax@18
  int v40; // edi@19
  int *v41; // eax@20
  int *v42; // ecx@20
  int v43; // edx@20
  _DWORD *v44; // ecx@21
  int v45; // eax@22
  double v46; // st7@22
  int v47; // edi@22
  _DWORD *v48; // ebx@22
  int v49; // esi@22
  double v50; // st7@23
  int v51; // eax@28
  double v52; // st7@28
  int v53; // edi@28
  _DWORD *v54; // ebx@28
  int v55; // esi@28
  double v56; // st7@29
  int v57; // eax@31
  int v58; // eax@32
  int v59; // esi@32
  signed int v60; // eax@32
  float *v61; // ecx@33
  int v62; // eax@36
  int v63; // esi@36
  int v64; // eax@36
  signed int v65; // ecx@36
  float *v66; // eax@37
  double v67; // st7@37
  double v68; // st4@38
  double v69; // st4@38
  double v70; // st7@39
  signed int v71; // ecx@41
  int v72; // eax@42
  double v73; // st6@42
  double v74; // st5@43
  int v75; // eax@45
  int v76; // eax@45
  signed int v77; // ecx@45
  float *v78; // eax@46
  double v79; // st7@46
  double v80; // st4@47
  double v81; // st4@47
  double v82; // st7@48
  signed int v83; // ecx@50
  int v84; // eax@51
  double v85; // st6@51
  double v86; // st5@52
  int v87; // eax@54
  int v88; // esi@54
  int v89; // eax@56
  int v90; // eax@57
  int v91; // eax@58
  int v92; // eax@59
  int v93; // eax@60
  int v94; // esi@60
  int v95; // eax@60
  int v96; // eax@61
  int v97; // ecx@61
  int v98; // ecx@62
  int v99; // eax@63
  int v100; // esi@63
  double v101; // st7@63
  int v102; // eax@63
  int v103; // edi@63
  int v104; // eax@63
  char v105; // dl@63
  int v106; // edi@63
  int v107; // ecx@63
  int v108; // edx@63
  int v109; // ecx@65
  int v110; // ecx@67
  int v111; // ecx@67
  int v112; // edx@67
  int v113; // eax@68
  int v114; // esi@68
  double v115; // st7@68
  int v116; // edi@68
  int v117; // ecx@68
  double v118; // st6@68
  int v119; // eax@70
  int v120; // eax@70
  int v121; // edx@70
  int v122; // eax@71
  int v123; // esi@71
  int v124; // edi@71
  int v125; // eax@71
  double v126; // st7@71
  int v127; // esi@71
  signed int v128; // eax@71
  _DWORD *v129; // ecx@71
  int v130; // edx@71
  int v131; // esi@72
  _WORD *v132; // eax@72
  int v133; // edx@72
  double v134; // st7@72
  int v135; // ecx@72
  int v136; // edx@72
  signed int v137; // eax@72
  double v138; // st7@72
  int v139; // esi@72
  char v140; // [sp+4h] [bp-E80h]@13
  int v141; // [sp+8h] [bp-E7Ch]@13
  int v142; // [sp+Ch] [bp-E78h]@13
  int v143; // [sp+10h] [bp-E74h]@13
  int v144; // [sp+14h] [bp-E70h]@13
  int v145; // [sp+18h] [bp-E6Ch]@13
  int v146; // [sp+1Ch] [bp-E68h]@13
  int v147; // [sp+20h] [bp-E64h]@13
  int v148; // [sp+24h] [bp-E60h]@13
  int v149; // [sp+28h] [bp-E5Ch]@13
  int v150; // [sp+2Ch] [bp-E58h]@13
  int v151; // [sp+30h] [bp-E54h]@13
  int v152; // [sp+34h] [bp-E50h]@13
  int v153; // [sp+38h] [bp-E4Ch]@13
  int v154; // [sp+3Ch] [bp-E48h]@13
  int v155; // [sp+40h] [bp-E44h]@13
  int v156; // [sp+44h] [bp-E40h]@13
  int v157; // [sp+48h] [bp-E3Ch]@13
  int v158; // [sp+4Ch] [bp-E38h]@13
  int v159; // [sp+50h] [bp-E34h]@13
  int v160; // [sp+54h] [bp-E30h]@13
  int v161; // [sp+58h] [bp-E2Ch]@13
  int v162; // [sp+5Ch] [bp-E28h]@13
  int v163; // [sp+60h] [bp-E24h]@13
  int v164; // [sp+64h] [bp-E20h]@13
  int v165; // [sp+68h] [bp-E1Ch]@13
  int v166; // [sp+6Ch] [bp-E18h]@13
  int v167; // [sp+70h] [bp-E14h]@13
  int v168; // [sp+74h] [bp-E10h]@13
  int v169; // [sp+78h] [bp-E0Ch]@13
  int v170; // [sp+7Ch] [bp-E08h]@13
  int v171; // [sp+80h] [bp-E04h]@13
  int v172; // [sp+84h] [bp-E00h]@13
  int v173; // [sp+88h] [bp-DFCh]@13
  int v174; // [sp+8Ch] [bp-DF8h]@13
  int v175; // [sp+90h] [bp-DF4h]@13
  int v176; // [sp+94h] [bp-DF0h]@13
  int v177; // [sp+98h] [bp-DECh]@13
  int v178; // [sp+9Ch] [bp-DE8h]@13
  int v179; // [sp+A0h] [bp-DE4h]@13
  int v180; // [sp+A4h] [bp-DE0h]@13
  int v181; // [sp+A8h] [bp-DDCh]@13
  int v182; // [sp+ACh] [bp-DD8h]@13
  int v183; // [sp+B0h] [bp-DD4h]@13
  int v184; // [sp+B4h] [bp-DD0h]@13
  int v185; // [sp+B8h] [bp-DCCh]@13
  int v186; // [sp+BCh] [bp-DC8h]@13
  int v187; // [sp+C0h] [bp-DC4h]@13
  int v188; // [sp+C4h] [bp-DC0h]@13
  int v189; // [sp+C8h] [bp-DBCh]@13
  int v190; // [sp+CCh] [bp-DB8h]@13
  int v191; // [sp+D0h] [bp-DB4h]@13
  int v192; // [sp+D4h] [bp-DB0h]@13
  int v193; // [sp+D8h] [bp-DACh]@13
  int v194; // [sp+DCh] [bp-DA8h]@13
  int v195; // [sp+E0h] [bp-DA4h]@13
  int v196; // [sp+E4h] [bp-DA0h]@13
  int v197; // [sp+E8h] [bp-D9Ch]@13
  int v198; // [sp+ECh] [bp-D98h]@13
  int v199; // [sp+F0h] [bp-D94h]@13
  int v200; // [sp+F4h] [bp-D90h]@13
  int v201; // [sp+F8h] [bp-D8Ch]@13
  int v202; // [sp+FCh] [bp-D88h]@13
  int v203; // [sp+558h] [bp-92Ch]@63
  int v204; // [sp+55Ch] [bp-928h]@3
  int v205; // [sp+560h] [bp-924h]@3
  int v206; // [sp+564h] [bp-920h]@3
  int v207; // [sp+568h] [bp-91Ch]@3
  signed int v208; // [sp+56Ch] [bp-918h]@3
  float v209; // [sp+570h] [bp-914h]@3
  float v210; // [sp+574h] [bp-910h]@3
  float v211; // [sp+578h] [bp-90Ch]@3
  float v212; // [sp+57Ch] [bp-908h]@3
  float v213; // [sp+580h] [bp-904h]@3
  float v214; // [sp+584h] [bp-900h]@3
  float v215; // [sp+588h] [bp-8FCh]@3
  char *v216; // [sp+59Ch] [bp-8E8h]@6
  int i; // [sp+5A0h] [bp-8E4h]@1
  _DWORD *v218; // [sp+5A4h] [bp-8E0h]@3
  float v219; // [sp+5A8h] [bp-8DCh]@3
  int v220; // [sp+5ACh] [bp-8D8h]@3
  float v221; // [sp+5B0h] [bp-8D4h]@3
  float v222; // [sp+5B4h] [bp-8D0h]@3
  float v223; // [sp+5B8h] [bp-8CCh]@3
  char v224[4]; // [sp+5BCh] [bp-8C8h]@3
  int v225; // [sp+5C0h] [bp-8C4h]@1
  int v226; // [sp+5C4h] [bp-8C0h]@1
  _DWORD *v227; // [sp+5C8h] [bp-8BCh]@9
  char *v228; // [sp+5CCh] [bp-8B8h]@9
  int v229; // [sp+5D0h] [bp-8B4h]@9
  int v230[2]; // [sp+5D4h] [bp-8B0h]@9
  int v231; // [sp+5DCh] [bp-8A8h]@13
  char v232; // [sp+8FCh] [bp-588h]@3

  v1 = this;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 56) + 12);
  v3 = 0;
  v226 = v1;
  v225 = v2;
  for ( i = 0; ; v3 = i )
  {
    v4 = *(_DWORD *)(v225 + 4 * v3 + 4);
    v5 = (_DWORD *)(1752 * v3);
    *(_WORD *)(v4 + 2) = 0;
    *(_WORD *)(v4 + 4) = 0;
    *(_BYTE *)v4 = 1;
    *(_BYTE *)(v4 + 1) = 0;
    v220 = v4;
    v224[0] = *((_BYTE *)v5 + dword_102D2B44 + 74);
    qmemcpy(&v232, (char *)v5 + dword_102D2B44 + 140, 0x57Cu);
    qmemcpy(&v204, (char *)v5 + dword_102D2B44 + 92, 0x30u);
    v218 = v5;
    result = (char *)sub_1000CD10(
                       &v222,
                       &v219,
                       &v223,
                       &v221,
                       v1,
                       *(float *)&v204,
                       *(float *)&v205,
                       *(float *)&v206,
                       *(float *)&v207,
                       *(float *)&v208,
                       v209,
                       v210,
                       v211,
                       v212,
                       v213,
                       v214,
                       v215);
    v7 = *(float *)&i;
    if ( (_BYTE)result )
    {
      v8 = v218;
      *(_BYTE *)(i + v225 + 404) = 3;
      v9 = sub_1000CB70((int)v8 + dword_102D2B44 + 1544);
      v10 = v225;
      *(_WORD *)(v225 + 4 * LODWORD(v7) + 540) = v9;
      v11 = v218;
      *(_BYTE *)(v10 + 4 * LODWORD(v7) + 542) = *((_BYTE *)v218 + dword_102D2B44 + 1575);
      result = (char *)*((_BYTE *)v11 + dword_102D2B44 + 72);
      switch ( result )
      {
        case 1u:
          *(float *)&v218 = COERCE_FLOAT(sub_10002860(v1, 4));
          v12 = sub_10002860(v1, 5596);
          v215 = v223;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          v13 = v12;
          *v218 = 126;
          sub_100359F0(v12, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          i = sub_1000DF20(v13, v1, SLODWORD(v7), v224[0]);
          result = (char *)v220;
          v7 = *(float *)&i;
          *(float *)(v220 + 8) = *(float *)&v218;
          *((_DWORD *)result + 3) = v13;
          break;
        case 2u:
          v216 = (char *)sub_10002860(v1, 4);
          v14 = sub_10002860(v1, 612);
          v215 = v223;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          v15 = v14;
          *(_DWORD *)v216 = 129;
          sub_1001EF80(v14, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v208 = *(signed int *)v224;
          v207 = 1;
          goto LABEL_7;
        case 3u:
          v216 = (char *)sub_10002860(v1, 4);
          v16 = sub_10002860(v1, 612);
          v215 = v223;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          v15 = v16;
          *(_DWORD *)v216 = 129;
          sub_1001EFC0(v16, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v208 = *(signed int *)v224;
          v207 = 2;
LABEL_7:
          i = sub_1000E650(v15, v1, SLODWORD(v7), v207, v208);
          result = (char *)v220;
          v7 = *(float *)&i;
          *(_DWORD *)(v220 + 8) = v216;
          *((_DWORD *)result + 3) = v15;
          break;
        case 4u:
          v227 = (_DWORD *)sub_10002860(v1, 4);
          v17 = sub_10002860(v1, 4796);
          v18 = (char *)v218;
          v19 = *(float *)&v17;
          *v227 = 133;
          v228 = (char *)((unsigned __int16)v216 | 0xC00);
          v20 = *(float *)&v18[dword_102D2B44 + 1720];
          v229 = v17;
          *(_QWORD *)v230 = (signed __int64)v20;
          v21 = (signed __int64)v20;
          v216 = (char *)(signed __int64)v20;
          if ( !v21 )
            sub_10015C20(".\\cdp_pg_eis_generic_eis.c", 2905, 1, "Gauge config error: graph column count not set");
          if ( v21 > 6 )
            sub_10015C20(
              ".\\cdp_pg_eis_generic_eis.c",
              2906,
              1,
              "Gauge config error: graph gauge supports a max of 6 columns");
          sub_1001AEE0(
            SLODWORD(v19),
            (int)byte_100879F8,
            164 * LODWORD(v7) + dword_102D2B4C + 3912,
            v219,
            v222,
            v221,
            v223,
            v21);
          v23 = sub_1000CE60(v22, *(_WORD *)((char *)v218 + dword_102D2B44 + 78));
          v24 = v218;
          v215 = *(float *)(LODWORD(v19) + 4);
          v25 = *(float *)LODWORD(v19);
          *(_WORD *)(LODWORD(v19) + 980) = v23;
          v214 = v25;
          sub_1000D6C0((int)v24 + dword_102D2B44, LODWORD(v19) + 120, v214, v215);
          v215 = v19;
          v214 = 0.0;
          v213 = 0.0;
          qmemcpy(&v140, &v232, 0x57Cu);
          v26 = sub_1000CED0(
                  &v231,
                  0x32u,
                  6.0,
                  v140,
                  v141,
                  v142,
                  v143,
                  v144,
                  v145,
                  v146,
                  v147,
                  v148,
                  v149,
                  v150,
                  v151,
                  v152,
                  v153,
                  v154,
                  v155,
                  v156,
                  v157,
                  v158,
                  v159,
                  v160,
                  v161,
                  v162,
                  v163,
                  v164,
                  v165,
                  v166,
                  v167,
                  v168,
                  v169,
                  v170,
                  v171,
                  v172,
                  v173,
                  v174,
                  v175,
                  v176,
                  v177,
                  v178,
                  v179,
                  v180,
                  v181,
                  v182,
                  v183,
                  v184,
                  v185,
                  v186,
                  v187,
                  v188,
                  v189,
                  v190,
                  v191,
                  v192,
                  v193,
                  v194,
                  v195,
                  v196,
                  v197,
                  v198,
                  v199);
          sub_1001AAF0((int)&v231, v26, v214, SLODWORD(v215));
          v27 = v229;
          v28 = *(_BYTE *)(v229 + 4788);
          v215 = 0.0;
          qmemcpy(&v142, &v232, 0x57Cu);
          sub_1000D5B0(
            v229 + 1588,
            v28,
            v142,
            v143,
            v144,
            v145,
            v146,
            v147,
            v148,
            v149,
            v150,
            v151,
            v152,
            v153,
            v154,
            v155,
            v156,
            v157,
            v158,
            v159,
            v160,
            v161,
            v162,
            v163,
            v164,
            v165,
            v166,
            v167,
            v168,
            v169,
            v170,
            v171,
            v172,
            v173,
            v174,
            v175,
            v176,
            v177,
            v178,
            v179,
            v180,
            v181,
            v182,
            v183,
            v184,
            v185,
            v186,
            v187,
            v188,
            v189,
            v190,
            v191,
            v192,
            v193,
            v194,
            v195,
            v196,
            v197,
            v198,
            v199,
            v200,
            v201,
            v202);
          v29 = 0;
          if ( *(_BYTE *)(v27 + 4788) )
          {
            v30 = (float *)(v27 + 1608);
            do
            {
              ++v29;
              v31 = *v30 - 10.0;
              v30 += 16;
              *(v30 - 16) = v31;
            }
            while ( v29 < *(_BYTE *)(v27 + 4788) );
          }
          v32 = v224[0];
          v33 = v216;
          v34 = v224[0] & 2;
          *(_BYTE *)(v27 + 972) = (v224[0] & 1u) >= 1;
          *(_BYTE *)(v27 + 974) = v34 >= 1u;
          v35 = v218;
          *(_BYTE *)(v27 + 975) = (v32 & 4u) >= 1;
          *(_BYTE *)(v27 + 978) = -1;
          v36 = *((_BYTE *)v35 + dword_102D2B44 + 1716) == 0;
          v37 = v225;
          if ( !v36 )
          {
            v38 = v225 + 28 * i;
            *(_DWORD *)(v38 + 2752) = v220;
            *(_DWORD *)(v38 + 2756) = sub_1000C800;
            *(_DWORD *)(v38 + 2748) = v33;
          }
          *(_DWORD *)(v27 + 44) = 0;
          *(_DWORD *)(v27 + 48) = 0;
          *(_DWORD *)(v27 + 52) = 0;
          *(_DWORD *)(v27 + 56) = 0;
          *(_DWORD *)(v27 + 60) = 0;
          *(_DWORD *)(v27 + 64) = 0;
          v39 = v27 + 68;
          *(_DWORD *)v39 = 0;
          *(_DWORD *)(v39 + 4) = 0;
          *(_DWORD *)(v39 + 8) = 0;
          *(_DWORD *)(v39 + 12) = 0;
          *(_DWORD *)(v39 + 16) = 0;
          *(_DWORD *)(v39 + 20) = 0;
          if ( (signed int)v33 > 0 )
          {
            v229 = v27 + 1096;
            v218 = (_DWORD *)(v27 + 704);
            v216 = (char *)(v27 + 68);
            v40 = v37 + 28 * (i + 98);
            v230[0] = -2744 - v37;
            v228 = v33;
            do
            {
              sub_1000D430(i, v226);
              sub_1000D540(v40 + v230[0] + dword_102D2B4C + 20480, (int)(v218 - 5), *(float *)v27, *(float *)(v27 + 4));
              v41 = (int *)v216;
              v42 = v218;
              v43 = v229;
              *((_DWORD *)v216 - 6) = v40;
              *v41 = v40;
              *v42 = v40;
              v216 = (char *)(v41 + 1);
              ++i;
              *(_DWORD *)(v40 + 20) = v43;
              v40 += 28;
              v36 = v228-- == (char *)1;
              v218 = v42 + 12;
              v229 = v43 + 28;
            }
            while ( !v36 );
          }
          result = (char *)v220;
          --i;
          v44 = v227;
          v7 = *(float *)&i;
          *(_DWORD *)(v220 + 12) = v27;
          v1 = v226;
          *((_DWORD *)result + 2) = v44;
          break;
        case 5u:
          v216 = (char *)sub_10002860(v1, 4);
          v45 = sub_10002860(v1, 4492);
          v46 = v223;
          v47 = 164 * LODWORD(v7);
          v48 = v218;
          v49 = v45;
          *(_DWORD *)v216 = 127;
          LODWORD(v215) = *((_BYTE *)v48 + dword_102D2B44 + 1716);
          v214 = v46;
          sub_10021B30(v45, (int)byte_100879F8, v47 + dword_102D2B4C + 3912, v219, v222, v221, v214, SLODWORD(v215));
          if ( *((_BYTE *)v48 + dword_102D2B44 + 1716) )
            v50 = *(float *)(v49 + 12);
          else
            v50 = *(float *)(v49 + 8);
          *(float *)&v218 = v50;
          sub_1000D4A0(v49 + 4212, (_BYTE *)(v47 + dword_102D2B4C + 3912), v49 + 4308, *(float *)&v218);
          sub_10020BA0(v47 + dword_102D2B4C + 3912, 0.40000001, 0.0, v49);
          i = sub_1000E370(v226, i, 1, v224[0]);
          if ( *(_BYTE *)(1752 * i + dword_102D2B44 + 1717) )
            sub_10020990(v49);
          result = (char *)v220;
          v1 = v226;
          v7 = *(float *)&i;
          *(_DWORD *)(v220 + 8) = v216;
          *((_DWORD *)result + 3) = v49;
          break;
        case 6u:
          v216 = (char *)sub_10002860(v1, 4);
          v51 = sub_10002860(v1, 4492);
          v52 = v223;
          v53 = 164 * LODWORD(v7);
          v54 = v218;
          v55 = v51;
          *(_DWORD *)v216 = 127;
          LODWORD(v215) = *((_BYTE *)v54 + dword_102D2B44 + 1716);
          v214 = v52;
          sub_10021B70(v51, (int)byte_100879F8, v53 + dword_102D2B4C + 3912, v219, v222, v221, v214, SLODWORD(v215));
          if ( *((_BYTE *)v54 + dword_102D2B44 + 1716) )
            v56 = *(float *)(v55 + 12);
          else
            v56 = *(float *)(v55 + 8);
          *(float *)&v218 = v56;
          sub_1000D4A0(v55 + 4212, (_BYTE *)(v53 + dword_102D2B4C + 3912), v55 + 4308, *(float *)&v218);
          sub_10020BA0(v53 + dword_102D2B4C + 3912, 0.2, 0.5, v55);
          v57 = sub_1000E370(v226, i, 2, v224[0]);
          v1 = v226;
          i = v57;
          result = (char *)v220;
          v7 = *(float *)&i;
          *(_DWORD *)(v220 + 8) = v216;
          *((_DWORD *)result + 3) = v55;
          break;
        case 7u:
          v216 = (char *)sub_10002860(v1, 4);
          v58 = sub_10002860(v1, 11656);
          v215 = v223;
          v59 = v58;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          *(_DWORD *)v216 = 131;
          sub_1001D240(v58, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          i = sub_1000E790(v1, SLODWORD(v7), 1, v224[0]);
          v60 = 0;
          if ( *(_BYTE *)(v59 + 10932) )
          {
            v61 = (float *)(v59 + 1376);
            do
            {
              *v61 = 0.0;
              ++v60;
              v61 += 16;
            }
            while ( v60 < *(_BYTE *)(v59 + 10932) );
          }
          result = (char *)v220;
          v7 = *(float *)&i;
          *(_DWORD *)(v220 + 8) = v216;
          *((_DWORD *)result + 3) = v59;
          break;
        case 8u:
          v216 = (char *)sub_10002860(v1, 4);
          v62 = sub_10002860(v1, 11656);
          v215 = v223;
          v63 = v62;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          *(_DWORD *)v216 = 131;
          sub_1001D2B0(v62, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v64 = sub_1000E790(v1, SLODWORD(v7), 1, v224[0]);
          v65 = 0;
          v36 = *(_BYTE *)(v63 + 10932) == 0;
          i = v64;
          if ( v36 )
          {
            v70 = 0.5;
          }
          else
          {
            v66 = (float *)(v63 + 1332);
            v67 = v221 * 0.5 + v219;
            do
            {
              ++v65;
              v68 = v67 - *v66;
              v66 += 16;
              *(float *)&v218 = v68;
              v69 = *(float *)&v218;
              *(v66 - 16) = *(float *)&v218 + *(v66 - 16);
              *(v66 - 15) = v69 + *(v66 - 15);
              *(v66 - 11) = *(v66 - 11) + 15.0;
            }
            while ( v65 < *(_BYTE *)(v63 + 10932) );
            v70 = 0.5;
          }
          v71 = 0;
          if ( *(_BYTE *)(v63 + 1328) )
          {
            v72 = v63 + 728;
            v73 = v221 * v70 + v219;
            do
            {
              ++v71;
              v74 = *(float *)(v72 + 8) * v70;
              v72 += 20;
              *(float *)(v72 - 20) = v73 - v74;
            }
            while ( v71 < *(_BYTE *)(v63 + 1328) );
          }
          goto LABEL_44;
        case 9u:
          v216 = (char *)sub_10002860(v1, 4);
          v75 = sub_10002860(v1, 11656);
          v215 = v223;
          v63 = v75;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          *(_DWORD *)v216 = 131;
          sub_1001D410(v75, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v76 = sub_1000E790(v1, SLODWORD(v7), 1, v224[0]);
          v77 = 0;
          v36 = *(_BYTE *)(v63 + 10932) == 0;
          i = v76;
          if ( v36 )
          {
            v82 = 0.5;
          }
          else
          {
            v78 = (float *)(v63 + 1332);
            v79 = v221 * 0.5 + v219;
            do
            {
              ++v77;
              v80 = v79 - *v78;
              v78 += 16;
              *(float *)&v218 = v80;
              v81 = *(float *)&v218;
              *(v78 - 16) = *(v78 - 16) + *(float *)&v218;
              *(v78 - 15) = v81 + *(v78 - 15);
              *(v78 - 11) = *(v78 - 11) + 15.0;
            }
            while ( v77 < *(_BYTE *)(v63 + 10932) );
            v82 = 0.5;
          }
          v83 = 0;
          if ( *(_BYTE *)(v63 + 1328) )
          {
            v84 = v63 + 728;
            v85 = v221 * v82 + v219;
            do
            {
              ++v83;
              v86 = *(float *)(v84 + 8) * v82;
              v84 += 20;
              *(float *)(v84 - 20) = v85 - v86;
            }
            while ( v83 < *(_BYTE *)(v63 + 1328) );
            result = (char *)v220;
            v7 = *(float *)&i;
            *(_DWORD *)(v220 + 8) = v216;
            *((_DWORD *)result + 3) = v63;
          }
          else
          {
LABEL_44:
            result = (char *)v220;
            v7 = *(float *)&i;
            *(_DWORD *)(v220 + 8) = v216;
            *((_DWORD *)result + 3) = v63;
          }
          break;
        case 0xAu:
          v216 = (char *)sub_10002860(v1, 4);
          v87 = sub_10002860(v1, 11656);
          v215 = v223;
          v88 = v87;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          *(_DWORD *)v216 = 131;
          sub_1001D570(v87, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v208 = *(signed int *)v224;
          v207 = 1;
          goto LABEL_55;
        case 0xBu:
          v216 = (char *)sub_10002860(v1, 4);
          v89 = sub_10002860(v1, 11656);
          v215 = v223;
          v88 = v89;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          *(_DWORD *)v216 = 131;
          sub_1001D5E0(v89, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v208 = *(signed int *)v224;
          v207 = 2;
          goto LABEL_55;
        case 0xCu:
          v216 = (char *)sub_10002860(v1, 4);
          v90 = sub_10002860(v1, 11656);
          v215 = v223;
          v88 = v90;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          *(_DWORD *)v216 = 131;
          sub_1001D650(v90, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v208 = *(signed int *)v224;
          v207 = 2;
          goto LABEL_55;
        case 0xDu:
          v216 = (char *)sub_10002860(v1, 4);
          v91 = sub_10002860(v1, 11656);
          v215 = v223;
          v88 = v91;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          *(_DWORD *)v216 = 131;
          sub_1001D6C0(v91, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v208 = *(signed int *)v224;
          v207 = 3;
          goto LABEL_55;
        case 0xEu:
          v216 = (char *)sub_10002860(v1, 4);
          v92 = sub_10002860(v1, 11656);
          v215 = v223;
          v88 = v92;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          *(_DWORD *)v216 = 131;
          sub_1001D730(v92, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v208 = *(signed int *)v224;
          v207 = 3;
LABEL_55:
          i = sub_1000E790(v1, SLODWORD(v7), v207, v208);
          result = (char *)v220;
          v7 = *(float *)&i;
          *(_DWORD *)(v220 + 8) = v216;
          *((_DWORD *)result + 3) = v88;
          break;
        case 0xFu:
          *(float *)&v218 = COERCE_FLOAT(sub_10002860(v1, 4));
          v93 = sub_10002860(v1, 5596);
          v215 = v223;
          v94 = v93;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          *v218 = 126;
          sub_100359F0(v93, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v95 = sub_1000DF20(v94, v1, SLODWORD(v7), v224[0]);
          *(_BYTE *)(v94 + 2072) = 1;
          v36 = *(_BYTE *)(1752 * v95 + dword_102D2B44 + 1718) == 0;
          i = v95;
          if ( v36 )
          {
            v98 = v220;
            result = (char *)v218;
            v7 = *(float *)&i;
            *(float *)(v220 + 8) = *(float *)&v218;
            *(_DWORD *)(v98 + 12) = v94;
          }
          else
          {
            v7 = *(float *)&i;
            v96 = v225 + 28 * v95;
            v97 = v220;
            *(_DWORD *)(v96 + 2752) = v220;
            *(_DWORD *)(v96 + 2756) = sub_1000C360;
            *(_DWORD *)(v96 + 2748) = 1;
            result = (char *)v218;
            *(float *)(v97 + 8) = *(float *)&v218;
            *(_DWORD *)(v97 + 12) = v94;
          }
          break;
        case 0x10u:
          v216 = (char *)sub_10002860(v1, 4);
          v99 = sub_10002860(v1, 612);
          v215 = v223;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          v100 = v99;
          *(_DWORD *)v216 = 129;
          sub_1001EF80(v99, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v101 = *(float *)(v100 + 4);
          v208 = *(signed int *)v224;
          v207 = 1;
          *(float *)&v206 = v7;
          v205 = v1;
          *(float *)(v100 + 180) = v101 - 20.0;
          v102 = sub_1000E650(v100, v205, v206, v207, v208);
          v103 = v102;
          v204 = 12;
          v203 = v1;
          i = v102;
          *(_BYTE *)(v100 + 174) = 1;
          v104 = sub_10002860(v203, v204);
          v103 *= 1752;
          *(_DWORD *)v104 = 0;
          *(_DWORD *)(v104 + 4) = 0;
          *(_DWORD *)(v104 + 8) = 0;
          *(_BYTE *)v104 = *(_BYTE *)(v103 + dword_102D2B44 + 1716);
          *(_BYTE *)(v104 + 1) = *(_BYTE *)(v103 + dword_102D2B44 + 1717);
          v105 = *(_BYTE *)(v103 + dword_102D2B44 + 1718);
          v106 = i;
          v107 = 164 * i;
          *(_BYTE *)(v104 + 2) = v105;
          *(_DWORD *)(v104 + 4) = -1;
          *(_DWORD *)(v104 + 8) = -16711936;
          v108 = *(_DWORD *)(v107 + dword_102D2B4C + 3964);
          if ( v108 )
            *(_DWORD *)(v104 + 4) = v108;
          v109 = *(_DWORD *)(v107 + dword_102D2B4C + 3968);
          if ( v109 )
            *(_DWORD *)(v104 + 8) = v109;
          v110 = 7 * v106;
          v7 = *(float *)&i;
          v111 = v225 + 4 * v110;
          v112 = v220;
          *(_DWORD *)(v111 + 2760) = v104;
          result = v216;
          *(_DWORD *)(v111 + 2752) = v112;
          *(_DWORD *)(v111 + 2756) = sub_1000C510;
          *(_DWORD *)(v111 + 2748) = 1;
          *(_DWORD *)(v112 + 8) = result;
          *(_DWORD *)(v112 + 12) = v100;
          break;
        case 0x11u:
          v216 = (char *)sub_10002860(v1, 4);
          v113 = sub_10002860(v1, 612);
          v215 = v223;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          v114 = v113;
          *(_DWORD *)v216 = 129;
          sub_1001EF80(v113, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          v115 = *(float *)(v114 + 4);
          v208 = *(signed int *)v224;
          v207 = 1;
          *(float *)&v206 = v7;
          v205 = v1;
          *(float *)(v114 + 180) = v115 - 20.0;
          v116 = sub_1000E650(v114, v205, v206, v207, v208);
          v204 = 16;
          v203 = v1;
          i = v116;
          *(_BYTE *)(v114 + 174) = 1;
          v117 = sub_10002860(v203, v204);
          *(_DWORD *)v117 = 0;
          *(_DWORD *)(v117 + 4) = 0;
          *(_DWORD *)(v117 + 8) = 0;
          *(float *)(v117 + 12) = 0.0;
          v230[0] = *(int *)(1752 * v116 + dword_102D2B44 + 1720);
          v118 = *(float *)v230;
          *(float *)(v117 + 8) = *(float *)v230;
          if ( v118 == 0.0 )
            *(float *)(v117 + 8) = 1.0;
          v119 = 7 * v116;
          v7 = *(float *)&i;
          v120 = v225 + 4 * v119;
          v121 = v220;
          *(_DWORD *)(v120 + 2752) = v220;
          *(_DWORD *)(v120 + 2756) = sub_1000C8A0;
          *(_DWORD *)(v120 + 2748) = 1;
          *(_DWORD *)(v120 + 2760) = v117;
          result = v216;
          *(_DWORD *)(v121 + 8) = v216;
          *(_DWORD *)(v121 + 12) = v114;
          break;
        case 0x12u:
          v227 = (_DWORD *)sub_10002860(v1, 4);
          v122 = sub_10002860(v1, 608);
          v215 = v223;
          v214 = v221;
          v213 = v222;
          v212 = v219;
          v123 = v122;
          *v227 = 134;
          v230[0] = v122;
          sub_1001DDC0(v122, (int)byte_100879F8, 164 * LODWORD(v7) + dword_102D2B4C + 3912, v212, v213, v214, v215);
          sub_1000D430(SLODWORD(v7), v1);
          v124 = v225 + 28 * LODWORD(v7);
          *(_DWORD *)(v124 + 2764) = v123 + 524;
          v208 = 4;
          v207 = v1;
          *(_DWORD *)(v123 + 56) = 0x7FFFFFFF;
          *(_WORD *)(v123 + 512) = 39;
          v125 = sub_10002860(v207, v208);
          v126 = v222;
          *(_DWORD *)(v123 + 156) = v125;
          v215 = v126;
          sub_1000D6C0((int)v218 + dword_102D2B44, v123 + 172, v219, v215);
          sub_1000D6C0((int)v218 + dword_102D2B44 + 36, v123 + 276, v219, v222);
          v127 = sub_10002860(v226, 84);
          memset((void *)v127, 0, 0x54u);
          *(_BYTE *)v127 = *((_BYTE *)v218 + dword_102D2B44 + 1716);
          v128 = sub_10023C30();
          *(_DWORD *)(v127 + 4) = v128;
          *(_DWORD *)(v127 + 8) = v128;
          *(_DWORD *)(v127 + 12) = v128;
          *(_DWORD *)(v127 + 16) = v128;
          *(_DWORD *)(v127 + 20) = v128;
          *(_DWORD *)(v127 + 24) = v128;
          *(_DWORD *)(v127 + 28) = v128;
          *(_DWORD *)(v127 + 32) = v128;
          v129 = v227;
          v130 = v230[0];
          *(_DWORD *)(v127 + 36) = v128;
          v1 = v226;
          *(_DWORD *)(v127 + 40) = v128;
          *(_DWORD *)(v127 + 44) = v128;
          *(_DWORD *)(v127 + 48) = v128;
          *(_DWORD *)(v127 + 52) = v128;
          *(_DWORD *)(v127 + 56) = v128;
          *(_DWORD *)(v127 + 60) = v128;
          *(_DWORD *)(v127 + 64) = v128;
          *(_DWORD *)(v127 + 68) = v128;
          *(_DWORD *)(v127 + 72) = v128;
          *(_DWORD *)(v127 + 76) = v128;
          *(_DWORD *)(v127 + 80) = v128;
          result = (char *)v220;
          *(_DWORD *)(v124 + 2752) = v220;
          *(_DWORD *)(v124 + 2756) = sub_1000C2F0;
          *(_DWORD *)(v124 + 2748) = 1;
          *(_DWORD *)(v124 + 2760) = v127;
          v7 = *(float *)&i;
          *((_DWORD *)result + 2) = v129;
          *((_DWORD *)result + 3) = v130;
          break;
        case 0x13u:
          v131 = sub_10002860(v1, 32);
          v132 = (_WORD *)sub_10002860(v1, 2);
          v133 = v225;
          *(float *)(v131 + 12) = 13.0;
          *(_DWORD *)v131 = 44;
          *(float *)(v131 + 24) = 0.5;
          *(_DWORD *)(v131 + 8) = 0;
          *(_DWORD *)(v131 + 4) = -16711681;
          *(float *)(v131 + 28) = 0.0;
          *(_DWORD *)(v131 + 20) = 4;
          *(float *)(v131 + 16) = 0.0;
          v134 = v219;
          *v132 = 6;
          v135 = v133 + 28 * LODWORD(v7);
          v136 = v220;
          *(_DWORD *)(v135 + 2752) = v220;
          *(_DWORD *)(v135 + 2756) = sub_1000C230;
          *(_DWORD *)(v135 + 2748) = 1;
          *(_DWORD *)(v135 + 2760) = 0;
          *(_DWORD *)(v136 + 8) = v131;
          *(_DWORD *)(v136 + 12) = v132;
          *(_BYTE *)v136 = 1;
          v137 = (signed int)v134;
          v138 = v222;
          v139 = v220;
          *(_WORD *)(v220 + 2) = v137;
          result = (char *)(signed int)v138;
          *(_WORD *)(v139 + 4) = (signed int)v138;
          break;
        default:
          break;
      }
    }
    i = LODWORD(v7) + 1;
    if ( LODWORD(v7) + 1 >= 100 )
      break;
  }
  return result;
}
// 1000C2F0: using guessed type int sub_1000C2F0();
// 102D2B44: using guessed type int dword_102D2B44;
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1000FFC0) --------------------------------------------------------
unsigned int __thiscall sub_1000FFC0(int this)
{
  int v1; // ebx@1
  char *v2; // eax@1
  int v3; // edi@1
  char *v4; // ebp@1
  __int16 v5; // ax@2
  int v6; // edx@2
  bool v7; // zf@2
  int v8; // eax@3
  int v9; // esi@3
  signed int v10; // ebp@3
  char *v11; // ecx@4
  int v12; // eax@7
  _BYTE *v13; // ebx@8
  int v14; // ecx@15
  signed int v15; // edx@18
  int v16; // ecx@19
  signed int v17; // ebp@20
  float *v18; // ebx@20
  int v19; // esi@20
  __int16 v20; // ax@21
  signed int v22; // [sp+10h] [bp-250h]@1
  signed int v23; // [sp+10h] [bp-250h]@7
  int v24; // [sp+14h] [bp-24Ch]@1
  char v25; // [sp+18h] [bp-248h]@1
  int v26; // [sp+1Ch] [bp-244h]@1
  int v27; // [sp+20h] [bp-240h]@1
  __int16 v28; // [sp+24h] [bp-23Ch]@1
  char v29; // [sp+26h] [bp-23Ah]@1
  int v30; // [sp+27h] [bp-239h]@1
  int v31; // [sp+2Bh] [bp-235h]@1
  int v32; // [sp+2Fh] [bp-231h]@1
  int v33; // [sp+33h] [bp-22Dh]@1
  int v34; // [sp+37h] [bp-229h]@1
  char v35; // [sp+3Bh] [bp-225h]@1
  int v36; // [sp+3Ch] [bp-224h]@1
  int v37; // [sp+40h] [bp-220h]@1
  __int16 v38; // [sp+44h] [bp-21Ch]@1
  char v39; // [sp+46h] [bp-21Ah]@1
  int v40; // [sp+47h] [bp-219h]@1
  int v41; // [sp+4Bh] [bp-215h]@1
  int v42; // [sp+4Fh] [bp-211h]@1
  int v43; // [sp+53h] [bp-20Dh]@1
  int v44; // [sp+57h] [bp-209h]@1
  char v45; // [sp+5Bh] [bp-205h]@1
  int v46; // [sp+5Ch] [bp-204h]@1
  int v47; // [sp+60h] [bp-200h]@1
  __int16 v48; // [sp+64h] [bp-1FCh]@1
  char v49; // [sp+66h] [bp-1FAh]@1
  int v50; // [sp+67h] [bp-1F9h]@1
  int v51; // [sp+6Bh] [bp-1F5h]@1
  int v52; // [sp+6Fh] [bp-1F1h]@1
  int v53; // [sp+73h] [bp-1EDh]@1
  int v54; // [sp+77h] [bp-1E9h]@1
  char v55; // [sp+7Bh] [bp-1E5h]@1
  int v56; // [sp+7Ch] [bp-1E4h]@1
  int v57; // [sp+80h] [bp-1E0h]@1
  __int16 v58; // [sp+84h] [bp-1DCh]@1
  char v59; // [sp+86h] [bp-1DAh]@1
  int v60; // [sp+87h] [bp-1D9h]@1
  int v61; // [sp+8Bh] [bp-1D5h]@1
  int v62; // [sp+8Fh] [bp-1D1h]@1
  int v63; // [sp+93h] [bp-1CDh]@1
  int v64; // [sp+97h] [bp-1C9h]@1
  char v65; // [sp+9Bh] [bp-1C5h]@1
  int v66; // [sp+9Ch] [bp-1C4h]@1
  int v67; // [sp+A0h] [bp-1C0h]@1
  __int16 v68; // [sp+A4h] [bp-1BCh]@1
  char v69; // [sp+A6h] [bp-1BAh]@1
  int v70; // [sp+A7h] [bp-1B9h]@1
  int v71; // [sp+ABh] [bp-1B5h]@1
  int v72; // [sp+AFh] [bp-1B1h]@1
  int v73; // [sp+B3h] [bp-1ADh]@1
  int v74; // [sp+B7h] [bp-1A9h]@1
  char v75; // [sp+BBh] [bp-1A5h]@1
  int v76; // [sp+BCh] [bp-1A4h]@1
  int v77; // [sp+C0h] [bp-1A0h]@1
  __int16 v78; // [sp+C4h] [bp-19Ch]@1
  char v79; // [sp+C6h] [bp-19Ah]@1
  int v80; // [sp+C7h] [bp-199h]@1
  int v81; // [sp+CBh] [bp-195h]@1
  int v82; // [sp+CFh] [bp-191h]@1
  int v83; // [sp+D3h] [bp-18Dh]@1
  int v84; // [sp+D7h] [bp-189h]@1
  char v85; // [sp+DBh] [bp-185h]@1
  int v86; // [sp+DCh] [bp-184h]@1
  int v87; // [sp+E0h] [bp-180h]@1
  __int16 v88; // [sp+E4h] [bp-17Ch]@1
  char v89; // [sp+E6h] [bp-17Ah]@1
  int v90; // [sp+E7h] [bp-179h]@1
  int v91; // [sp+EBh] [bp-175h]@1
  int v92; // [sp+EFh] [bp-171h]@1
  int v93; // [sp+F3h] [bp-16Dh]@1
  int v94; // [sp+F7h] [bp-169h]@1
  char v95; // [sp+FBh] [bp-165h]@1
  int v96; // [sp+FCh] [bp-164h]@1
  int v97; // [sp+100h] [bp-160h]@1
  __int16 v98; // [sp+104h] [bp-15Ch]@1
  char v99; // [sp+106h] [bp-15Ah]@1
  int v100; // [sp+107h] [bp-159h]@1
  int v101; // [sp+10Bh] [bp-155h]@1
  int v102; // [sp+10Fh] [bp-151h]@1
  int v103; // [sp+113h] [bp-14Dh]@1
  int v104; // [sp+117h] [bp-149h]@1
  char v105; // [sp+11Bh] [bp-145h]@1
  int v106; // [sp+11Ch] [bp-144h]@1
  int v107; // [sp+120h] [bp-140h]@1
  __int16 v108; // [sp+124h] [bp-13Ch]@1
  char v109; // [sp+126h] [bp-13Ah]@1
  int v110; // [sp+127h] [bp-139h]@1
  int v111; // [sp+12Bh] [bp-135h]@1
  int v112; // [sp+12Fh] [bp-131h]@1
  int v113; // [sp+133h] [bp-12Dh]@1
  int v114; // [sp+137h] [bp-129h]@1
  char v115; // [sp+13Bh] [bp-125h]@1
  int v116; // [sp+13Ch] [bp-124h]@1
  int v117; // [sp+140h] [bp-120h]@1
  __int16 v118; // [sp+144h] [bp-11Ch]@1
  char v119; // [sp+146h] [bp-11Ah]@1
  int v120; // [sp+147h] [bp-119h]@1
  int v121; // [sp+14Bh] [bp-115h]@1
  int v122; // [sp+14Fh] [bp-111h]@1
  int v123; // [sp+153h] [bp-10Dh]@1
  int v124; // [sp+157h] [bp-109h]@1
  char v125; // [sp+15Bh] [bp-105h]@1
  int v126; // [sp+15Ch] [bp-104h]@1
  int v127; // [sp+160h] [bp-100h]@1
  __int16 v128; // [sp+164h] [bp-FCh]@1
  char v129; // [sp+166h] [bp-FAh]@1
  int v130; // [sp+167h] [bp-F9h]@1
  int v131; // [sp+16Bh] [bp-F5h]@1
  int v132; // [sp+16Fh] [bp-F1h]@1
  int v133; // [sp+173h] [bp-EDh]@1
  int v134; // [sp+177h] [bp-E9h]@1
  char v135; // [sp+17Bh] [bp-E5h]@1
  int v136; // [sp+17Ch] [bp-E4h]@1
  int v137; // [sp+180h] [bp-E0h]@1
  __int16 v138; // [sp+184h] [bp-DCh]@1
  char v139; // [sp+186h] [bp-DAh]@1
  int v140; // [sp+187h] [bp-D9h]@1
  int v141; // [sp+18Bh] [bp-D5h]@1
  int v142; // [sp+18Fh] [bp-D1h]@1
  int v143; // [sp+193h] [bp-CDh]@1
  int v144; // [sp+197h] [bp-C9h]@1
  char v145; // [sp+19Bh] [bp-C5h]@1
  int v146; // [sp+19Ch] [bp-C4h]@1
  int v147; // [sp+1A0h] [bp-C0h]@1
  __int16 v148; // [sp+1A4h] [bp-BCh]@1
  char v149; // [sp+1A6h] [bp-BAh]@1
  int v150; // [sp+1A7h] [bp-B9h]@1
  int v151; // [sp+1ABh] [bp-B5h]@1
  int v152; // [sp+1AFh] [bp-B1h]@1
  int v153; // [sp+1B3h] [bp-ADh]@1
  int v154; // [sp+1B7h] [bp-A9h]@1
  char v155; // [sp+1BBh] [bp-A5h]@1
  int v156; // [sp+1BCh] [bp-A4h]@1
  int v157; // [sp+1C0h] [bp-A0h]@1
  __int16 v158; // [sp+1C4h] [bp-9Ch]@1
  char v159; // [sp+1C6h] [bp-9Ah]@1
  int v160; // [sp+1C7h] [bp-99h]@1
  int v161; // [sp+1CBh] [bp-95h]@1
  int v162; // [sp+1CFh] [bp-91h]@1
  int v163; // [sp+1D3h] [bp-8Dh]@1
  int v164; // [sp+1D7h] [bp-89h]@1
  char v165; // [sp+1DBh] [bp-85h]@1
  int v166; // [sp+1DCh] [bp-84h]@1
  int v167; // [sp+1E0h] [bp-80h]@1
  __int16 v168; // [sp+1E4h] [bp-7Ch]@1
  char v169; // [sp+1E6h] [bp-7Ah]@1
  int v170; // [sp+1E7h] [bp-79h]@1
  int v171; // [sp+1EBh] [bp-75h]@1
  int v172; // [sp+1EFh] [bp-71h]@1
  int v173; // [sp+1F3h] [bp-6Dh]@1
  int v174; // [sp+1F7h] [bp-69h]@1
  char v175; // [sp+1FBh] [bp-65h]@1
  int v176; // [sp+1FCh] [bp-64h]@1
  int v177; // [sp+200h] [bp-60h]@1
  __int16 v178; // [sp+204h] [bp-5Ch]@1
  char v179; // [sp+206h] [bp-5Ah]@1
  int v180; // [sp+207h] [bp-59h]@1
  int v181; // [sp+20Bh] [bp-55h]@1
  int v182; // [sp+20Fh] [bp-51h]@1
  int v183; // [sp+213h] [bp-4Dh]@1
  int v184; // [sp+217h] [bp-49h]@1
  char v185; // [sp+21Bh] [bp-45h]@1
  int v186; // [sp+21Ch] [bp-44h]@1
  int v187; // [sp+220h] [bp-40h]@1
  __int16 v188; // [sp+224h] [bp-3Ch]@1
  char v189; // [sp+226h] [bp-3Ah]@1
  int v190; // [sp+227h] [bp-39h]@1
  int v191; // [sp+22Bh] [bp-35h]@1
  int v192; // [sp+22Fh] [bp-31h]@1
  int v193; // [sp+233h] [bp-2Dh]@1
  int v194; // [sp+237h] [bp-29h]@1
  char v195; // [sp+23Bh] [bp-25h]@1
  int v196; // [sp+23Ch] [bp-24h]@1
  int v197; // [sp+240h] [bp-20h]@1
  __int16 v198; // [sp+244h] [bp-1Ch]@1
  char v199; // [sp+246h] [bp-1Ah]@1
  int v200; // [sp+247h] [bp-19h]@1
  int v201; // [sp+24Bh] [bp-15h]@1
  int v202; // [sp+24Fh] [bp-11h]@1
  int v203; // [sp+253h] [bp-Dh]@1
  int v204; // [sp+257h] [bp-9h]@1
  char v205; // [sp+25Bh] [bp-5h]@1

  v26 = 1734304607;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v38 = 28789;
  v1 = this;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v27 = 1601331557;
  v47 = 1601331557;
  v36 = 1734304607;
  v28 = 28260;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v37 = 1601331557;
  v39 = 0;
  v56 = 1734304607;
  v46 = 1734304607;
  v48 = 29559;
  v59 = 0;
  v49 = 0;
  v57 = 1601331557;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  v66 = 1734304607;
  v58 = 29561;
  v68 = 29554;
  v24 = this;
  v45 = 1;
  v55 = 2;
  v65 = 3;
  v67 = 1601331557;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 4;
  v77 = 1601331557;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  v86 = 1734306911;
  v89 = 0;
  v90 = 0;
  v91 = 0;
  v92 = 0;
  v93 = 0;
  v94 = 0;
  v76 = 1734304607;
  v98 = 28789;
  v79 = 0;
  v78 = 25458;
  v100 = 0;
  v101 = 0;
  v102 = 0;
  v103 = 0;
  v104 = 0;
  v87 = 1601331557;
  v88 = 28260;
  v107 = 1601331557;
  v96 = 1734306911;
  v97 = 1601331557;
  v110 = 0;
  v111 = 0;
  v112 = 0;
  v113 = 0;
  v114 = 0;
  v106 = 1734306911;
  v116 = 1734306911;
  v99 = 0;
  v109 = 0;
  v119 = 0;
  v108 = 29559;
  v120 = 0;
  v121 = 0;
  v122 = 0;
  v123 = 0;
  v124 = 0;
  v117 = 1601331557;
  v118 = 29561;
  v85 = 5;
  v95 = 6;
  v105 = 7;
  v115 = 8;
  v125 = 9;
  v126 = 1734306911;
  v127 = 1601331557;
  v128 = 29554;
  v130 = 0;
  v131 = 0;
  v132 = 0;
  v133 = 0;
  v134 = 0;
  v137 = 1601331557;
  v140 = 0;
  v141 = 0;
  v142 = 0;
  v143 = 0;
  v144 = 0;
  v146 = 1734308447;
  v149 = 0;
  v136 = 1734306911;
  v150 = 0;
  v151 = 0;
  v152 = 0;
  v153 = 0;
  v154 = 0;
  v129 = 0;
  v139 = 0;
  v158 = 28789;
  v138 = 25458;
  v160 = 0;
  v161 = 0;
  v162 = 0;
  v163 = 0;
  v164 = 0;
  v147 = 1601331557;
  v148 = 28260;
  v167 = 1601331557;
  v156 = 1734308447;
  v157 = 1601331557;
  v170 = 0;
  v171 = 0;
  v172 = 0;
  v173 = 0;
  v174 = 0;
  v166 = 1734308447;
  v159 = 0;
  v176 = 1734308447;
  v169 = 0;
  v168 = 29559;
  v179 = 0;
  v135 = 10;
  v145 = 11;
  v155 = 12;
  v165 = 13;
  v175 = 14;
  v177 = 1601331557;
  v178 = 29561;
  v180 = 0;
  v181 = 0;
  v182 = 0;
  v183 = 0;
  v184 = 0;
  v188 = 29554;
  v190 = 0;
  v191 = 0;
  v192 = 0;
  v193 = 0;
  v194 = 0;
  v186 = 1734308447;
  v197 = 1601331557;
  v187 = 1601331557;
  v200 = 0;
  v201 = 0;
  v202 = 0;
  v203 = 0;
  v204 = 0;
  v2 = *(char **)(this + 56);
  v189 = 0;
  v196 = 1734308447;
  v185 = 15;
  v195 = 16;
  v198 = 25458;
  v199 = 0;
  v205 = 17;
  v3 = sub_10001640(this, v2, 8364, 0);
  sub_10016BE0(37, &v25);
  v4 = &v35;
  v22 = 18;
  do
  {
    v5 = sub_1000CB70((int)(v4 - 31));
    v6 = (unsigned __int8)*v4;
    v4 += 32;
    v7 = v22-- == 1;
    *(_WORD *)(v3 + 2 * v6 + 504) = v5;
  }
  while ( !v7 );
  v8 = v3 + 1140;
  v9 = v3 + 540;
  v10 = 100;
  do
  {
    *(_BYTE *)(v9 + 2) = 0;
    *(_WORD *)v9 = -1;
    v11 = (char *)4;
    do
    {
      *(_WORD *)v8 = -1;
      *(_BYTE *)(v8 + 2) = 20;
      v8 += 4;
      --v11;
    }
    while ( v11 );
    v9 += 4;
    --v10;
  }
  while ( v10 );
  v12 = dword_102D2B44;
  v23 = 0;
  if ( *(_BYTE *)(dword_102D2B44 + 175200) )
  {
    v13 = (_BYTE *)(v3 + 942);
    do
    {
      *((_WORD *)v13 - 1) = sub_1000CB70(v12 + v10 + 175292);
      *v13 = *(_BYTE *)(dword_102D2B44 + v10 + 175323);
      v12 = dword_102D2B44;
      v11 = (char *)(v23 + 1);
      v10 += 120;
      v13 += 4;
      ++v23;
    }
    while ( v23 < *(_BYTE *)(dword_102D2B44 + 175200) );
    v1 = v24;
  }
  *(_BYTE *)(v3 + 6341) = 0;
  if ( sub_10025D10(v11) == 1 )
    *(_BYTE *)(v3 + 6341) = 2;
  if ( *(_DWORD *)(v1 + 64) == 9 )
  {
    *(_BYTE *)(v3 + 6341) = 1;
    sub_10025DA0(1);
  }
  sub_10016BE0(29, (_BYTE *)(v3 + 6342));
  if ( v25 & 1 )
  {
    *(_BYTE *)(v3 + 6760) = 1;
    *(_BYTE *)(v3 + 6360) = 1;
    sub_10013E80(v3 + 6360);
    *(_BYTE *)(v3 + 6556) = 1;
    v14 = dword_102D2B4C;
    if ( *(_BYTE *)(dword_102D2B4C + 24) == 2 )
    {
      *(_BYTE *)(v3 + 6560) = 2;
      sub_10013E80(v3 + 6560);
      *(_BYTE *)(v3 + 6756) = 1;
    }
  }
  sub_1000D070(v14, v1);
  sub_1000D110(v1);
  *(_DWORD *)(v3 + 4) = v3 + 6764;
  *(_DWORD *)(v3 + 8) = v3 + 6780;
  *(_DWORD *)(v3 + 12) = v3 + 6796;
  *(_DWORD *)(v3 + 16) = v3 + 6812;
  *(_DWORD *)(v3 + 20) = v3 + 6828;
  *(_DWORD *)(v3 + 24) = v3 + 6844;
  *(_DWORD *)(v3 + 28) = v3 + 6860;
  *(_DWORD *)(v3 + 32) = v3 + 6876;
  *(_DWORD *)(v3 + 36) = v3 + 6892;
  *(_DWORD *)(v3 + 40) = v3 + 6908;
  *(_DWORD *)(v3 + 44) = v3 + 6924;
  *(_DWORD *)(v3 + 48) = v3 + 6940;
  *(_DWORD *)(v3 + 52) = v3 + 6956;
  *(_DWORD *)(v3 + 56) = v3 + 6972;
  *(_DWORD *)(v3 + 60) = v3 + 6988;
  *(_DWORD *)(v3 + 64) = v3 + 7004;
  *(_DWORD *)(v3 + 68) = v3 + 7020;
  *(_DWORD *)(v3 + 72) = v3 + 7036;
  *(_DWORD *)(v3 + 76) = v3 + 7052;
  *(_DWORD *)(v3 + 80) = v3 + 7068;
  *(_DWORD *)(v3 + 84) = v3 + 7084;
  *(_DWORD *)(v3 + 88) = v3 + 7100;
  *(_DWORD *)(v3 + 92) = v3 + 7116;
  *(_DWORD *)(v3 + 96) = v3 + 7132;
  *(_DWORD *)(v3 + 100) = v3 + 7148;
  *(_DWORD *)(v3 + 104) = v3 + 7164;
  *(_DWORD *)(v3 + 108) = v3 + 7180;
  *(_DWORD *)(v3 + 112) = v3 + 7196;
  *(_DWORD *)(v3 + 116) = v3 + 7212;
  *(_DWORD *)(v3 + 120) = v3 + 7228;
  *(_DWORD *)(v3 + 124) = v3 + 7244;
  *(_DWORD *)(v3 + 128) = v3 + 7260;
  *(_DWORD *)(v3 + 132) = v3 + 7276;
  *(_DWORD *)(v3 + 136) = v3 + 7292;
  *(_DWORD *)(v3 + 140) = v3 + 7308;
  *(_DWORD *)(v3 + 144) = v3 + 7324;
  *(_DWORD *)(v3 + 148) = v3 + 7340;
  *(_DWORD *)(v3 + 152) = v3 + 7356;
  *(_DWORD *)(v3 + 156) = v3 + 7372;
  *(_DWORD *)(v3 + 160) = v3 + 7388;
  *(_DWORD *)(v3 + 164) = v3 + 7404;
  *(_DWORD *)(v3 + 168) = v3 + 7420;
  *(_DWORD *)(v3 + 172) = v3 + 7436;
  *(_DWORD *)(v3 + 176) = v3 + 7452;
  *(_DWORD *)(v3 + 180) = v3 + 7468;
  *(_DWORD *)(v3 + 184) = v3 + 7484;
  *(_DWORD *)(v3 + 188) = v3 + 7500;
  *(_DWORD *)(v3 + 192) = v3 + 7516;
  *(_DWORD *)(v3 + 196) = v3 + 7532;
  *(_DWORD *)(v3 + 200) = v3 + 7548;
  *(_DWORD *)(v3 + 204) = v3 + 7564;
  *(_DWORD *)(v3 + 208) = v3 + 7580;
  *(_DWORD *)(v3 + 212) = v3 + 7596;
  *(_DWORD *)(v3 + 216) = v3 + 7612;
  *(_DWORD *)(v3 + 220) = v3 + 7628;
  *(_DWORD *)(v3 + 224) = v3 + 7644;
  *(_DWORD *)(v3 + 228) = v3 + 7660;
  *(_DWORD *)(v3 + 232) = v3 + 7676;
  *(_DWORD *)(v3 + 236) = v3 + 7692;
  *(_DWORD *)(v3 + 240) = v3 + 7708;
  *(_DWORD *)(v3 + 244) = v3 + 7724;
  *(_DWORD *)(v3 + 248) = v3 + 7740;
  *(_DWORD *)(v3 + 252) = v3 + 7756;
  *(_DWORD *)(v3 + 256) = v3 + 7772;
  *(_DWORD *)(v3 + 260) = v3 + 7788;
  *(_DWORD *)(v3 + 264) = v3 + 7804;
  *(_DWORD *)(v3 + 268) = v3 + 7820;
  *(_DWORD *)(v3 + 272) = v3 + 7836;
  *(_DWORD *)(v3 + 276) = v3 + 7852;
  *(_DWORD *)(v3 + 280) = v3 + 7868;
  *(_DWORD *)(v3 + 284) = v3 + 7884;
  *(_DWORD *)(v3 + 288) = v3 + 7900;
  *(_DWORD *)(v3 + 292) = v3 + 7916;
  *(_DWORD *)(v3 + 296) = v3 + 7932;
  *(_DWORD *)(v3 + 300) = v3 + 7948;
  *(_DWORD *)(v3 + 304) = v3 + 7964;
  *(_DWORD *)(v3 + 308) = v3 + 7980;
  *(_DWORD *)(v3 + 312) = v3 + 7996;
  *(_DWORD *)(v3 + 316) = v3 + 8012;
  *(_DWORD *)(v3 + 320) = v3 + 8028;
  *(_DWORD *)(v3 + 324) = v3 + 8044;
  *(_DWORD *)(v3 + 328) = v3 + 8060;
  *(_DWORD *)(v3 + 332) = v3 + 8076;
  *(_DWORD *)(v3 + 336) = v3 + 8092;
  *(_DWORD *)(v3 + 340) = v3 + 8108;
  *(_DWORD *)(v3 + 344) = v3 + 8124;
  *(_DWORD *)(v3 + 348) = v3 + 8140;
  *(_DWORD *)(v3 + 352) = v3 + 8156;
  *(_DWORD *)(v3 + 356) = v3 + 8172;
  *(_DWORD *)(v3 + 360) = v3 + 8188;
  *(_DWORD *)(v3 + 364) = v3 + 8204;
  *(_DWORD *)(v3 + 368) = v3 + 8220;
  *(_DWORD *)(v3 + 372) = v3 + 8236;
  *(_DWORD *)(v3 + 376) = v3 + 8252;
  *(_DWORD *)(v3 + 380) = v3 + 8268;
  *(_DWORD *)(v3 + 384) = v3 + 8284;
  *(_DWORD *)(v3 + 388) = v3 + 8300;
  *(_DWORD *)(v3 + 392) = v3 + 8316;
  *(_DWORD *)(v3 + 396) = v3 + 8332;
  *(_DWORD *)(v3 + 400) = v3 + 8348;
  v15 = 0;
  do
  {
    *(_BYTE *)(v15 + v3 + 404) = 0;
    v16 = *(_DWORD *)(v3 + 4 * v15 + 4);
    *(_DWORD *)v16 = 0;
    *(_DWORD *)(v16 + 4) = 0;
    ++v15;
    *(_DWORD *)(v16 + 8) = 0;
    *(_DWORD *)(v16 + 12) = 0;
  }
  while ( v15 < 100 );
  v17 = 0;
  v18 = (float *)(v3 + 5544);
  v19 = v3 + 2744;
  do
  {
    v20 = *(_WORD *)(dword_102D2B44 + v17 + 76);
    *(_WORD *)(v19 - 4) = v20;
    *(float *)v19 = sub_1000CE90(v20);
    *(_DWORD *)(v19 + 4) = 0;
    *(_DWORD *)(v19 + 8) = 0;
    *(_DWORD *)(v19 + 12) = 0;
    *(_DWORD *)(v19 + 20) = 0;
    *v18 = 9.8999998e24;
    *((_WORD *)v18 - 2) = 0;
    v17 += 1752;
    v19 += 28;
    v18 += 2;
  }
  while ( v17 < 175200 );
  sub_1000EBA0(v24);
  sub_1000D750(v24);
  sub_1000D8C0(v24);
  return sub_100017F0(v24, *(_DWORD *)(v24 + 56), 125);
}
// 102D2B44: using guessed type int dword_102D2B44;
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10010D10) --------------------------------------------------------
int __cdecl sub_10010D10(int a1)
{
  int result; // eax@1
  float v2; // ST04_4@13

  result = a1;
  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8018:
      if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 6341) == 1 )
        result = sub_10025DA0(0);
      break;
    case 0x8041:
      result = sub_1000FFC0(a1);
      break;
    case 0x8022:
    case 0x8078:
      result = sub_1000DDA0(a1);
      break;
    case 0x8039:
      JUMPOUT(&loc_1000D200);
      return result;
    case 0x806E:
      result = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
      switch ( result )
      {
        case 64:
          sub_10023D40(*(float *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 12) + 6352));
          result = sub_10023CB0();
          break;
        case 65:
          sub_10023DD0();
          result = sub_10023CB0();
          break;
        case 66:
          sub_10023E60();
          result = sub_10023CB0();
          break;
        case 67:
          sub_10023CB0();
          v2 = *(float *)(dword_102D2B4C + 940) + *(float *)(dword_102D2B4C + 936) + *(float *)(dword_102D2B4C + 932);
          result = sub_10023D40(v2);
          break;
        default:
          return result;
      }
      break;
    default:
      return result;
  }
  return result;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10010DD0) --------------------------------------------------------
char __usercall sub_10010DD0@<al>(int a1@<esi>)
{
  char result; // al@4

  if ( *(_BYTE *)(a1 + 2) )
    sub_100011B0(a1, 0, 0, 279, 742, 1);
  else
    sub_100011B0(a1, 0, 0, 151, 686, 1);
  sub_100017F0(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001E70(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10010E20) --------------------------------------------------------
int __usercall sub_10010E20@<eax>(void *a1@<ecx>, int a2@<esi>)
{
  __int16 v2; // ax@3
  __int16 v3; // cx@3
  _WORD *v4; // ST04_4@5
  int result; // eax@5
  char *v6; // [sp-10h] [bp-1Ch]@3
  void *v7; // [sp-Ch] [bp-18h]@3
  __int16 v8; // [sp+0h] [bp-Ch]@5
  __int16 v9; // [sp+2h] [bp-Ah]@5
  int v10; // [sp+4h] [bp-8h]@1

  v10 = 0;
  if ( sub_10025D10(a1) != 1 && *(_BYTE *)(a2 + 2) )
  {
    v7 = &unk_1008ACD8;
    v2 = v10 + 279;
    v3 = HIWORD(v10) + 742;
    v6 = (char *)&unk_1008AC48;
  }
  else
  {
    v7 = &unk_1008ACEC;
    v2 = v10 + 151;
    v3 = HIWORD(v10) + 686;
    v6 = (char *)&unk_1008AC88;
  }
  v4 = *(_WORD **)(a2 + 52);
  v8 = v2;
  v9 = v3;
  sub_100221D0(a2, v4, v6, (int)v7, 0, 255);
  result = sub_10022A60(a2, (int)&v10, (int)&v8, 0);
  *(_BYTE *)(a2 + 6) = 2;
  return result;
}

//----- (10010EF0) --------------------------------------------------------
char __usercall sub_10010EF0@<al>(int a1@<esi>)
{
  int v1; // edi@1
  float v2; // ST1C_4@1
  int v3; // eax@7
  char result; // al@8
  int v5; // eax@10
  char v6; // [sp+Fh] [bp-25h]@5
  float v7; // [sp+10h] [bp-24h]@1
  float v8; // [sp+14h] [bp-20h]@1
  int v9; // [sp+18h] [bp-1Ch]@1
  float v10; // [sp+1Ch] [bp-18h]@1
  int v11; // [sp+20h] [bp-14h]@1
  int v12; // [sp+24h] [bp-10h]@1
  float v13; // [sp+28h] [bp-Ch]@1
  float v14; // [sp+2Ch] [bp-8h]@1
  float v15; // [sp+30h] [bp-4h]@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v13 = 0.5;
  v14 = 1.0;
  v10 = 7.0;
  v9 = sub_10038970(7.0);
  v11 = -14671840;
  v12 = -1;
  j_gdi_pvg_color_u32(-1);
  sub_10015770(1.0);
  j_gdi_pvg_begin(64);
  sub_10015960(279.0, 0.0);
  sub_10015960(279.0, 742.0);
  j_gdi_pvg_end(LODWORD(v2));
  v7 = 69.0;
  v8 = 98.0;
  v15 = sub_10016930(v9, (int)"X100", 7.0);
  sub_100393A0(a1, (int)"X100", (int)&v7);
  if ( !*(_BYTE *)(v1 + 244) )
  {
    v8 = 201.0;
    sub_100393A0(a1, (int)"X100", (int)&v7);
  }
  v8 = 304.0;
  sub_100393A0(a1, (int)"X100", (int)&v7);
  v8 = 510.0;
  sub_100393A0(a1, (int)"X100", (int)&v7);
  v7 = 208.0;
  v8 = 98.0;
  sub_100393A0(a1, (int)"X100", (int)&v7);
  if ( !*(_BYTE *)(v1 + 244) )
  {
    v8 = 201.0;
    sub_100393A0(a1, (int)"X100", (int)&v7);
  }
  v8 = 304.0;
  sub_100393A0(a1, (int)"X100", (int)&v7);
  v8 = 510.0;
  sub_100393A0(a1, (int)"X100", (int)&v7);
  if ( sub_10040380(600, &v6) && v6 )
  {
    v10 = 9.0;
    v3 = sub_10038970(9.0);
    v7 = 119.0;
    v8 = 128.0;
    v9 = v3;
    v12 = -16711936;
    sub_100393A0(a1, (int)&unk_1008B37C, (int)&v7);
  }
  result = sub_10040380(601, &v6);
  if ( result )
  {
    if ( v6 )
    {
      v10 = 9.0;
      v5 = sub_10038970(9.0);
      v7 = 258.0;
      v8 = 128.0;
      v9 = v5;
      v12 = -16711936;
      result = sub_100393A0(a1, (int)&unk_1008B37C, (int)&v7);
    }
  }
  return result;
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (10011170) --------------------------------------------------------
char __usercall sub_10011170@<al>(int a1@<esi>)
{
  int v1; // edi@1
  float v2; // ST18_4@1
  double v3; // st7@2
  int v4; // eax@6
  char result; // al@7
  int v6; // eax@9
  const char *v7; // [sp-Ch] [bp-50h]@2
  float *v8; // [sp-8h] [bp-4Ch]@2
  char v9; // [sp+Fh] [bp-35h]@4
  float v10; // [sp+10h] [bp-34h]@1
  float v11; // [sp+14h] [bp-30h]@1
  int v12; // [sp+18h] [bp-2Ch]@1
  float v13; // [sp+1Ch] [bp-28h]@1
  int v14; // [sp+20h] [bp-24h]@1
  int v15; // [sp+24h] [bp-20h]@1
  float v16; // [sp+28h] [bp-1Ch]@1
  float v17; // [sp+2Ch] [bp-18h]@1
  float v18; // [sp+30h] [bp-14h]@1
  int v19; // [sp+34h] [bp-10h]@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v16 = 0.5;
  v17 = 1.0;
  v13 = 9.0;
  v12 = sub_10038970(9.0);
  v14 = -14671840;
  v15 = -1;
  j_gdi_pvg_color_u32(-1);
  sub_10015770(1.0);
  j_gdi_pvg_begin(64);
  sub_10015960(151.0, 0.0);
  sub_10015960(151.0, 686.0);
  j_gdi_pvg_end(LODWORD(v2));
  v10 = 74.0;
  sub_10038450((int)&v19, (_BYTE *)(dword_102D2B4C + 4220), 12);
  sub_100385A0((const char *)&v19, &unk_1008B418, 12);
  v11 = 96.0;
  v18 = sub_10016930(v12, (int)&v19, 9.0);
  sub_100393A0(a1, (int)&v19, (int)&v10);
  v11 = 193.0;
  if ( *(_BYTE *)(v1 + 244) )
  {
    v3 = sub_10016930(v12, (int)"TORQUE %", v13);
    v8 = &v10;
    v7 = "TORQUE %";
  }
  else
  {
    v3 = sub_10016930(v12, (int)"TORQUE FT-LB", v13);
    v8 = &v10;
    v7 = "TORQUE FT-LB";
  }
  v18 = v3;
  sub_100393A0(a1, (int)v7, (int)v8);
  v11 = 290.0;
  v18 = sub_10016930(v12, (int)"PROP RPM", v13);
  sub_100393A0(a1, (int)"PROP RPM", (int)&v10);
  v11 = 387.0;
  v18 = sub_10016930(v12, (int)"TURBINE % RPM", v13);
  sub_100393A0(a1, (int)"TURBINE % RPM", (int)&v10);
  v11 = 484.0;
  v18 = sub_10016930(v12, (int)"FUEL FLOW PPH", v13);
  sub_100393A0(a1, (int)"FUEL FLOW PPH", (int)&v10);
  v11 = 581.0;
  v18 = sub_10016930(v12, (int)"OIL PSI", v13);
  sub_100393A0(a1, (int)"OIL PSI", (int)&v10);
  v11 = 678.0;
  v18 = sub_10016930(v12, (int)"OIL C", v13);
  sub_100393A0(a1, (int)"OIL C", (int)&v10);
  if ( sub_10040380(600, &v9) && v9 )
  {
    v16 = 0.0;
    v13 = 7.0;
    v4 = sub_10038970(7.0);
    v10 = 11.0;
    v11 = 112.0;
    v12 = v4;
    v15 = -16711936;
    sub_100393A0(a1, (int)&unk_1008B37C, (int)&v10);
  }
  result = sub_10040380(601, &v9);
  if ( result )
  {
    if ( v9 )
    {
      v16 = 0.0;
      v13 = 7.0;
      v6 = sub_10038970(7.0);
      v10 = 85.0;
      v11 = 112.0;
      v12 = v6;
      v15 = -16711936;
      result = sub_100393A0(a1, (int)&unk_1008B37C, (int)&v10);
    }
  }
  return result;
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (100114D0) --------------------------------------------------------
void __usercall sub_100114D0(int a1@<eax>, float a2@<esi>)
{
  int v2; // edx@1
  float v3; // ST28_4@3
  int v4; // edx@3
  double v5; // st7@3
  double v6; // st5@4
  float v7; // ST30_4@9
  signed int v8; // esi@8
  float v9; // ST2C_4@9
  float v10; // ST2C_4@9
  float v11; // ST34_4@9
  float v12; // [sp+8h] [bp-14h]@8
  float v13; // [sp+Ch] [bp-10h]@8
  float v14; // [sp+10h] [bp-Ch]@3

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  if ( 9.8999998e24 != *(float *)(v2 + 140) && 9.8999998e24 != *(float *)(v2 + 128) )
  {
    v3 = *(float *)(v2 + 140) - *(float *)(v2 + 128);
    sub_100252A0(50.0, -50.0);
    v5 = v3;
    v14 = v3 / 50.0 * 6.0 + *(float *)(v4 + 82268);
    *(float *)(v4 + 82268) = v14;
    if ( v14 < 12.0 )
    {
      v6 = 25.0;
    }
    else
    {
      v6 = 25.0;
      *(float *)(v4 + 82268) = v14 - 25.0;
    }
    if ( *(float *)(v4 + 82268) < -12.0 )
      *(float *)(v4 + 82268) = v6 + *(float *)(v4 + 82268);
    v12 = a2;
    v13 = *(float *)(v4 + 82268) + 114.0;
    j_gdi_pvg_enable(36);
    j_gdi_pvg_scissor(114, 226, 50, 14);
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_enable(38);
    sub_10015770(1.5);
    j_gdi_pvg_color_u32(-1);
    v8 = 4;
    do
    {
      j_gdi_pvg_begin(66);
      v9 = v13 - 8.0;
      sub_10015960(v9, 233.0);
      v7 = v5 * -8.0 / 50.0;
      v10 = v7 + v13;
      sub_10015960(v10, 226.0);
      v11 = v13 + 8.0;
      sub_10015960(v11, 233.0);
      sub_10015960(v10, 240.0);
      j_gdi_pvg_end(LODWORD(v12));
      --v8;
      v13 = v13 + 25.0;
    }
    while ( v8 );
    sub_10015770(1.0);
    j_gdi_pvg_disable(38);
    j_gdi_pvg_disable(35);
    j_gdi_pvg_disable(36);
  }
}
// 100114D0: could not find valid save-restore pair for esi
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10015880: using guessed type int __cdecl j_gdi_pvg_scissor(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100116F0) --------------------------------------------------------
void __usercall sub_100116F0(int a1@<ebx>, int a2@<esi>, int a3)
{
  int v3; // ebp@1
  void *v4; // ecx@1
  void *v5; // ecx@1
  double v6; // st7@3
  void *v7; // ecx@5
  double v8; // st7@5
  void *v9; // ecx@5
  char *v10; // eax@7
  char v11; // cl@8
  double v12; // st7@10
  void *v13; // ecx@12
  int v14; // edi@15
  void *v15; // ecx@16
  double v16; // st7@18
  bool v17; // zf@20
  double v18; // st7@20
  double v19; // st7@20
  signed int v20; // eax@22
  double v21; // st7@22
  float v22; // ST14_4@22
  void *v23; // ecx@22
  int v24; // [sp+1Ch] [bp-4h]@14
  float v25; // [sp+24h] [bp+4h]@5
  float v26; // [sp+24h] [bp+4h]@12
  float v27; // [sp+24h] [bp+4h]@20
  float v28; // [sp+24h] [bp+4h]@22

  v3 = a3;
  sub_100359F0(
    a2,
    a3 + 14,
    *(_DWORD *)(a3 + 4),
    *(float *)a1,
    *(float *)(a1 + 4),
    *(float *)(a1 + 8),
    *(float *)(a1 + 12));
  sub_10034DC0(*(_DWORD *)(a3 + 8), a2);
  *(_BYTE *)(a2 + 5564) = 1;
  if ( sub_10025D10(v4) == 1 || sub_10025CF0(v5) == 2 )
  {
    *(float *)(a2 + 220) = 170.0;
    v6 = 275.0;
  }
  else
  {
    *(float *)(a2 + 220) = 150.0;
    v6 = 360.0;
  }
  *(float *)(a2 + 224) = v6;
  *(float *)(a2 + 324) = *(float *)(a2 + 224) - *(float *)(a2 + 220);
  *(float *)(a2 + 2060) = *(float *)(a2 + 220);
  sub_10034CB0(*(_BYTE **)(a3 + 4), a2);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)a3 + 4;
  *(_DWORD *)(a2 + 48) = *(_DWORD *)a3 + 8;
  *(_WORD *)(a2 + 5558) = *(_WORD *)(a3 + 12);
  v7 = *(void **)a3;
  *(float *)(a2 + 2336) = 0.0;
  v7 = (char *)v7 + 8;
  *(float *)(a2 + 2332) = 1.0;
  v8 = *(float *)(a2 + 2044);
  *(_DWORD *)(a2 + 2320) = v7;
  *(float *)(a2 + 100) = v8;
  *(float *)(a2 + 148) = 9.0;
  v25 = *(float *)(a2 + 2048) - 8.0;
  *(float *)(a2 + 104) = v25;
  *(float *)(a2 + 140) = 0.5;
  *(float *)(a2 + 152) = *(float *)(a2 + 2044);
  *(float *)(a2 + 200) = 9.0;
  *(float *)(a2 + 156) = v25 + 14.0;
  *(float *)(a2 + 192) = 0.5;
  if ( sub_10025D10(v7) == 1 || sub_10025CF0(v9) == 2 )
  {
    *(float *)(a2 + 2300) = *(float *)(a2 + 8) * 0.5 + *(float *)a2 + 7.0;
    *(float *)(a2 + 2304) = *(float *)(a2 + 2048) - 6.0;
    *(float *)(a2 + 36) = *(float *)(a1 + 12) * 0.5899999737739563;
    v12 = *(float *)(a1 + 8);
    *(_BYTE *)(a2 + 116) = 0;
    *(float *)(a2 + 32) = v12 * 0.550000011920929;
  }
  else
  {
    v10 = (char *)(v3 + 30);
    do
    {
      v11 = *v10;
      v10[a2 + 168 - (v3 + 30)] = *v10;
      ++v10;
    }
    while ( v11 );
    *(float *)(a2 + 2300) = *(float *)(a2 + 8) + *(float *)a2 + 3.0;
    *(float *)(a2 + 2304) = *(float *)(a2 + 2048) + 10.0;
    *(float *)(a2 + 36) = *(float *)(a1 + 12) * 0.7400000095367432;
  }
  *(_DWORD *)(a2 + 2076) = 53;
  *(float *)(a2 + 2336) = 0.0;
  *(float *)(a2 + 2340) = 13.0;
  if ( *(float *)(a1 + 20) <= 0.0 )
  {
    sub_10035D90(a2);
  }
  else
  {
    sub_10035FB0(*(float *)(a1 + 20), *(float *)(a1 + 16), -0.15000001, a2);
    v26 = 1.0 / *(float *)(a1 + 24);
    sub_10035D00(*(float *)(a1 + 20), "%.0f", v26, 7.0, -0.17, a2);
  }
  v24 = 0;
  if ( *(_DWORD *)(v3 + 40) > 0 )
  {
    v14 = v3 + 52;
    do
    {
      *(_BYTE *)(v14 + 4) = 0;
      if ( sub_10025D10(v13) == 1 || sub_10025CF0(v15) == 2 )
        v16 = -0.25999999;
      else
        v16 = -0.2;
      v17 = *(_BYTE *)(v14 + 16) == 0;
      *(float *)v14 = v16;
      v18 = (*(float *)(a2 + 20) - *(float *)(a2 + 16))
          / ((*(float *)(a2 + 224) - *(float *)(a2 + 220))
           * 3.141592741012573
           * *(float *)(a1 + 8)
           / 360.0);
      v27 = v18 + v18;
      v19 = v27;
      if ( v17 )
        v19 = -v19;
      v28 = v19;
      *(float *)(v14 - 4) = *(float *)(v14 + 12) + v28;
      v20 = sub_100348B0(a2);
      v21 = *(float *)v14;
      *(_DWORD *)(v14 - 8) = v20;
      v22 = v21;
      sub_10035DF0(*(float *)(v14 - 4), v22, (unsigned __int8)v20, a2);
      *(_DWORD *)((*(_DWORD *)(v14 - 8) << 6) + a2 + 2412) = -65536;
      if ( sub_10025D10(v23) == 1 || sub_10025CF0(v13) == 2 )
      {
        *(float *)((*(_DWORD *)(v14 - 8) << 6) + a2 + 2372) = 5.0;
      }
      else
      {
        v13 = (void *)(*(_DWORD *)(v14 - 8) << 6);
        *(float *)((char *)v13 + a2 + 2372) = 4.0;
      }
      v14 += 28;
      ++v24;
    }
    while ( v24 < *(_DWORD *)(v3 + 40) );
  }
}

//----- (10011A80) --------------------------------------------------------
void __usercall sub_10011A80(int a1@<eax>)
{
  int v1; // ebp@1
  float *v2; // ecx@1
  int v3; // eax@1
  double v4; // st6@2
  double v5; // st6@5
  double v6; // st6@5
  double v7; // st6@5
  double v8; // st7@6
  double v9; // st7@8
  double v10; // st6@9
  double v11; // st7@11
  double v12; // st7@13

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  *(_BYTE *)(v1 + 244) = *(_BYTE *)(dword_102D2B44 + 1716);
  *(_BYTE *)(v1 + 82276) = 1;
  sub_10013E80(v1 + 82276);
  *(float *)(v1 + 82280) = 550.0;
  *(float *)(v1 + 82284) = 550.0;
  *(float *)(v1 + 82288) = 2000.0;
  *(_BYTE *)(v1 + 82272) = 2;
  *(_BYTE *)(v1 + 82476) = 2;
  sub_10013E80(v1 + 82476);
  *(float *)(v1 + 82480) = 550.0;
  *(float *)(v1 + 82484) = 550.0;
  *(_BYTE *)(v1 + 82273) = 2;
  v2 = (float *)"G@G@";
  *(float *)(v1 + 82488) = 2000.0;
  v3 = v1 + 80;
  do
  {
    v4 = *v2;
    ++v2;
    *(float *)(v3 - 4) = v4;
    v3 += 12;
    *(float *)(v3 - 12) = 1.0;
    *(float *)(v3 - 8) = 1.0;
  }
  while ( (signed int)v2 < (signed int)&unk_1008B2E0 );
  if ( *(_BYTE *)(v1 + 244) )
  {
    *(float *)(v1 + 76) = 0.2;
    *(float *)(v1 + 88) = 0.2;
  }
  *(float *)(v1 + 24176) = *(float *)(dword_102D2B4C + 4264);
  v5 = *(float *)(dword_102D2B4C + 5108);
  *(_BYTE *)(v1 + 82264) = 0;
  *(float *)(v1 + 82260) = v5;
  *(_BYTE *)(v1 + 6220) = 0;
  v6 = *(float *)(dword_102D2B4C + 3932);
  *(_BYTE *)(v1 + 12204) = 0;
  *(float *)(v1 + 6224) = v6;
  *(float *)(v1 + 6228) = 1.0;
  v7 = *(float *)(dword_102D2B4C + 3932);
  *(_DWORD *)(v1 + 17812) = v1 + 100;
  *(float *)(v1 + 12208) = v7;
  *(float *)(v1 + 12212) = 1.0;
  qmemcpy((void *)(v1 + 17968), (const void *)(dword_102D2B4C + 4076), 0xA4u);
  *(_DWORD *)(v1 + 17816) = v1 + 17968;
  *(_DWORD *)(v1 + 17820) = dword_102D2B4C + 20508;
  *(_WORD *)(v1 + 17824) = 17;
  sub_10038450(v1 + 17826, (_BYTE *)(v1 + 18112), 16);
  *(_WORD *)(v1 + 17842) = 17297;
  *(_BYTE *)(v1 + 17844) = 0;
  *(_BYTE *)(v1 + 17850) = 0;
  *(_DWORD *)(v1 + 17852) = 1;
  *(float *)(v1 + 17876) = *(float *)(dword_102D2B4C + 4092);
  *(_BYTE *)(v1 + 17880) = 1;
  *(float *)(v1 + 18132) = 10.0;
  *(_BYTE *)(v1 + 17908) = 1;
  *(float *)(v1 + 18136) = 15.0;
  *(float *)(v1 + 18140) = 117.0;
  *(float *)(v1 + 18144) = 117.0;
  *(float *)(v1 + 18152) = 200.0;
  *(float *)(v1 + 18148) = 50.0;
  *(float *)(v1 + 18156) = 100.0;
  *(float *)(v1 + 18160) = 5.0;
  *(float *)(v1 + 18164) = 13.0;
  *(float *)(v1 + 18168) = 117.0;
  *(float *)(v1 + 18172) = 117.0;
  *(float *)(v1 + 18180) = 0.0;
  *(float *)(v1 + 18176) = 0.0;
  *(float *)(v1 + 18184) = 1.0;
  sub_100116F0(v1 + 18132, v1 + 12216, v1 + 17812);
  *(float *)(v1 + 18192) = 0.0;
  *(_BYTE *)(v1 + 17780) = 1;
  *(_BYTE *)(v1 + 18188) = 0;
  *(_DWORD *)(v1 + 23792) = v1 + 112;
  qmemcpy((void *)(v1 + 23948), (const void *)(dword_102D2B4C + 4076), 0xA4u);
  *(_DWORD *)(v1 + 23796) = v1 + 23948;
  *(_DWORD *)(v1 + 23800) = dword_102D2B4C + 20508;
  *(_WORD *)(v1 + 23804) = 17;
  sub_10038450(v1 + 23806, (_BYTE *)(v1 + 24092), 16);
  *(_WORD *)(v1 + 23822) = 17297;
  *(_BYTE *)(v1 + 23824) = 0;
  *(_BYTE *)(v1 + 23830) = 0;
  *(_DWORD *)(v1 + 23832) = 1;
  *(float *)(v1 + 23856) = *(float *)(dword_102D2B4C + 4092);
  *(_BYTE *)(v1 + 23860) = 1;
  *(float *)(v1 + 24112) = 149.0;
  *(_BYTE *)(v1 + 23888) = 1;
  *(float *)(v1 + 24116) = 15.0;
  *(float *)(v1 + 24120) = 117.0;
  *(float *)(v1 + 24124) = 117.0;
  *(float *)(v1 + 24132) = 200.0;
  *(float *)(v1 + 24128) = 50.0;
  *(float *)(v1 + 24136) = 100.0;
  *(float *)(v1 + 24140) = 79.0;
  *(float *)(v1 + 24144) = 13.0;
  *(float *)(v1 + 24148) = 117.0;
  *(float *)(v1 + 24152) = 117.0;
  *(float *)(v1 + 24160) = 0.0;
  *(float *)(v1 + 24156) = 0.0;
  *(float *)(v1 + 24164) = 1.0;
  sub_100116F0(v1 + 24112, v1 + 18196, v1 + 23792);
  *(float *)(v1 + 24172) = 0.0;
  *(_BYTE *)(v1 + 24168) = 0;
  *(_DWORD *)(v1 + 5844) = v1 + 76;
  *(_BYTE *)(v1 + 23760) = 1;
  qmemcpy((void *)(v1 + 6000), (const void *)(dword_102D2B4C + 3912), 0xA4u);
  *(_DWORD *)(v1 + 5848) = v1 + 6000;
  *(_DWORD *)(v1 + 5852) = dword_102D2B4C + 20480;
  *(_DWORD *)(v1 + 5858) = 1364348756;
  *(_WORD *)(v1 + 5862) = 17749;
  *(float *)(v1 + 6164) = 10.0;
  *(_BYTE *)(v1 + 5864) = 0;
  *(float *)(v1 + 6168) = 118.0;
  *(_BYTE *)(v1 + 5882) = 0;
  *(float *)(v1 + 6172) = 117.0;
  *(_DWORD *)(v1 + 5884) = 1;
  *(float *)(v1 + 6176) = 117.0;
  *(_BYTE *)(v1 + 5912) = 1;
  *(float *)(v1 + 6192) = 5.0;
  *(float *)(v1 + 6196) = 110.0;
  *(float *)(v1 + 6200) = 117.0;
  *(float *)(v1 + 6204) = 117.0;
  *(float *)(v1 + 6212) = 0.0;
  *(float *)(v1 + 6208) = 0.0;
  *(float *)(v1 + 6216) = 1.0;
  if ( *(_BYTE *)(v1 + 244) )
  {
    *(_WORD *)(v1 + 5856) = 12;
    *(_WORD *)(v1 + 5874) = 37;
    *(float *)(v1 + 6184) = 20.0;
    v8 = 1.0;
    *(float *)(v1 + 6180) = 5.0;
  }
  else
  {
    *(_WORD *)(v1 + 5856) = 40;
    *(_DWORD *)(v1 + 5874) = 1278039110;
    *(_WORD *)(v1 + 5878) = 66;
    *(float *)(v1 + 6184) = 677.90863;
    *(float *)(v1 + 6180) = 135.58173;
    v8 = 100.0;
  }
  *(float *)(v1 + 6188) = v8;
  sub_100116F0(v1 + 6164, v1 + 248, v1 + 5844);
  *(_DWORD *)(v1 + 11828) = v1 + 88;
  qmemcpy((void *)(v1 + 11984), (const void *)(dword_102D2B4C + 3912), 0xA4u);
  *(_DWORD *)(v1 + 11832) = v1 + 11984;
  *(_DWORD *)(v1 + 11836) = dword_102D2B4C + 20480;
  *(_WORD *)(v1 + 11840) = 40;
  *(_DWORD *)(v1 + 11842) = 1364348756;
  *(_WORD *)(v1 + 11846) = 17749;
  *(_BYTE *)(v1 + 11848) = 0;
  *(_BYTE *)(v1 + 11866) = 0;
  *(_DWORD *)(v1 + 11868) = 1;
  *(_BYTE *)(v1 + 11896) = 1;
  *(float *)(v1 + 12148) = 149.0;
  *(float *)(v1 + 12152) = 118.0;
  *(float *)(v1 + 12156) = 117.0;
  *(float *)(v1 + 12160) = 117.0;
  *(float *)(v1 + 12168) = 677.90863;
  *(float *)(v1 + 12164) = 135.58173;
  *(float *)(v1 + 12172) = 100.0;
  *(float *)(v1 + 12176) = 79.0;
  *(float *)(v1 + 12180) = 110.0;
  v9 = 100.0;
  *(float *)(v1 + 12184) = 117.0;
  *(float *)(v1 + 12188) = 117.0;
  *(float *)(v1 + 12196) = 0.0;
  *(float *)(v1 + 12192) = 0.0;
  *(float *)(v1 + 12200) = 1.0;
  if ( *(_BYTE *)(v1 + 244) )
  {
    v9 = 1.0;
    *(_WORD *)(v1 + 11840) = 12;
    *(_WORD *)(v1 + 11858) = 37;
    *(float *)(v1 + 12168) = 20.0;
    v10 = 5.0;
  }
  else
  {
    *(_WORD *)(v1 + 5856) = 40;
    v10 = 135.58173;
    *(_DWORD *)(v1 + 11858) = 1278039110;
    *(_WORD *)(v1 + 11862) = 66;
    *(float *)(v1 + 12168) = 677.90863;
  }
  *(float *)(v1 + 12164) = v10;
  *(float *)(v1 + 12172) = v9;
  sub_100116F0(v1 + 12148, v1 + 6232, v1 + 11828);
  *(_DWORD *)(v1 + 29776) = v1 + 124;
  *(_DWORD *)(v1 + 29780) = dword_102D2B4C + 4404;
  *(_DWORD *)(v1 + 29784) = dword_102D2B4C + 20564;
  *(_WORD *)(v1 + 29788) = 6;
  *(_DWORD *)(v1 + 29790) = 1347375696;
  *(_BYTE *)(v1 + 29794) = 0;
  *(_DWORD *)(v1 + 29806) = 5066834;
  *(_BYTE *)(v1 + 29814) = 0;
  *(_DWORD *)(v1 + 29816) = 1;
  *(float *)(v1 + 29840) = *(float *)(dword_102D2B4C + 4424);
  *(_BYTE *)(v1 + 29844) = 1;
  *(float *)(v1 + 29932) = 10.0;
  *(float *)(v1 + 29936) = 221.0;
  *(float *)(v1 + 29940) = 117.0;
  *(float *)(v1 + 29944) = 117.0;
  *(float *)(v1 + 29952) = 500.0;
  *(float *)(v1 + 29948) = 100.0;
  *(float *)(v1 + 29956) = 100.0;
  *(float *)(v1 + 29960) = 5.0;
  *(float *)(v1 + 29964) = 207.0;
  *(float *)(v1 + 29968) = 117.0;
  *(float *)(v1 + 29972) = 117.0;
  *(float *)(v1 + 29980) = 0.0;
  *(float *)(v1 + 29976) = 0.0;
  *(float *)(v1 + 29984) = 1.0;
  sub_100116F0(v1 + 29932, v1 + 24180, v1 + 29776);
  *(_DWORD *)(v1 + 35584) = v1 + 136;
  *(_DWORD *)(v1 + 35588) = dword_102D2B4C + 4404;
  *(_DWORD *)(v1 + 35592) = dword_102D2B4C + 20564;
  *(_WORD *)(v1 + 35596) = 6;
  *(_DWORD *)(v1 + 35598) = 1347375696;
  *(_BYTE *)(v1 + 35602) = 0;
  *(_DWORD *)(v1 + 35614) = 5066834;
  *(_BYTE *)(v1 + 35622) = 0;
  *(_DWORD *)(v1 + 35624) = 1;
  *(float *)(v1 + 35648) = *(float *)(dword_102D2B4C + 4424);
  *(_BYTE *)(v1 + 35652) = 1;
  *(float *)(v1 + 35740) = 149.0;
  *(float *)(v1 + 35744) = 221.0;
  *(float *)(v1 + 35748) = 117.0;
  *(float *)(v1 + 35752) = 117.0;
  *(float *)(v1 + 35760) = 500.0;
  *(float *)(v1 + 35756) = 100.0;
  *(float *)(v1 + 35764) = 100.0;
  *(float *)(v1 + 35768) = 79.0;
  *(float *)(v1 + 35772) = 207.0;
  *(float *)(v1 + 35776) = 117.0;
  *(float *)(v1 + 35780) = 117.0;
  *(float *)(v1 + 35788) = 0.0;
  *(float *)(v1 + 35784) = 0.0;
  *(float *)(v1 + 35792) = 1.0;
  sub_100116F0(v1 + 35740, v1 + 29988, v1 + 35584);
  *(_DWORD *)(v1 + 41392) = v1 + 148;
  *(_DWORD *)(v1 + 41396) = dword_102D2B4C + 4568;
  *(_DWORD *)(v1 + 41400) = dword_102D2B4C + 20592;
  *(_WORD *)(v1 + 41404) = 12;
  *(_DWORD *)(v1 + 41406) = 1112692052;
  *(_BYTE *)(v1 + 41410) = 0;
  *(_DWORD *)(v1 + 41422) = 1347559461;
  *(_WORD *)(v1 + 41426) = 77;
  *(_BYTE *)(v1 + 41430) = 0;
  *(_DWORD *)(v1 + 41432) = 1;
  *(float *)(v1 + 41456) = *(float *)(dword_102D2B4C + 4584);
  *(_BYTE *)(v1 + 41460) = 1;
  *(float *)(v1 + 41548) = 10.0;
  *(float *)(v1 + 41552) = 324.0;
  *(float *)(v1 + 41556) = 117.0;
  *(float *)(v1 + 41560) = 117.0;
  *(float *)(v1 + 41568) = 20.0;
  *(float *)(v1 + 41564) = 5.0;
  *(float *)(v1 + 41572) = 1.0;
  *(float *)(v1 + 41576) = 5.0;
  *(float *)(v1 + 41580) = 304.0;
  *(float *)(v1 + 41584) = 117.0;
  *(float *)(v1 + 41588) = 117.0;
  *(float *)(v1 + 41596) = 0.0;
  *(float *)(v1 + 41592) = 0.0;
  *(float *)(v1 + 41600) = 1.0;
  sub_100116F0(v1 + 41548, v1 + 35796, v1 + 41392);
  *(_DWORD *)(v1 + 47200) = v1 + 160;
  *(_DWORD *)(v1 + 47204) = dword_102D2B4C + 4568;
  *(_DWORD *)(v1 + 47208) = dword_102D2B4C + 20592;
  *(_WORD *)(v1 + 47212) = 12;
  *(_DWORD *)(v1 + 47214) = 1112692052;
  *(_BYTE *)(v1 + 47218) = 0;
  *(_DWORD *)(v1 + 47230) = 1347559461;
  *(_WORD *)(v1 + 47234) = 77;
  *(_BYTE *)(v1 + 47238) = 0;
  *(_DWORD *)(v1 + 47240) = 1;
  *(float *)(v1 + 47264) = *(float *)(dword_102D2B4C + 4584);
  *(_BYTE *)(v1 + 47268) = 1;
  *(float *)(v1 + 47356) = 149.0;
  *(float *)(v1 + 47360) = 324.0;
  *(float *)(v1 + 47364) = 117.0;
  *(float *)(v1 + 47368) = 117.0;
  *(float *)(v1 + 47376) = 20.0;
  *(float *)(v1 + 47372) = 5.0;
  *(float *)(v1 + 47380) = 1.0;
  *(float *)(v1 + 47384) = 79.0;
  *(float *)(v1 + 47388) = 304.0;
  *(float *)(v1 + 47392) = 117.0;
  *(float *)(v1 + 47396) = 117.0;
  *(float *)(v1 + 47404) = 0.0;
  *(float *)(v1 + 47400) = 0.0;
  *(float *)(v1 + 47408) = 1.0;
  sub_100116F0(v1 + 47356, v1 + 41604, v1 + 47200);
  *(_DWORD *)(v1 + 53008) = v1 + 172;
  *(_DWORD *)(v1 + 53012) = dword_102D2B4C + 4732;
  *(_DWORD *)(v1 + 53016) = dword_102D2B4C + 20620;
  *(_WORD *)(v1 + 53020) = 32;
  *(_DWORD *)(v1 + 53022) = 1330398790;
  *(_WORD *)(v1 + 53026) = 87;
  *(_DWORD *)(v1 + 53038) = 4739152;
  *(_BYTE *)(v1 + 53046) = 0;
  *(_DWORD *)(v1 + 53048) = 0;
  *(float *)(v1 + 53164) = 10.0;
  *(float *)(v1 + 53168) = 427.0;
  *(float *)(v1 + 53172) = 117.0;
  *(float *)(v1 + 53176) = 117.0;
  *(float *)(v1 + 53184) = 0.015669972;
  *(float *)(v1 + 53180) = 0.0031339945;
  *(float *)(v1 + 53188) = 100.0;
  *(float *)(v1 + 53192) = 5.0;
  *(float *)(v1 + 53196) = 401.0;
  *(float *)(v1 + 53200) = 117.0;
  *(float *)(v1 + 53204) = 117.0;
  *(float *)(v1 + 53212) = 0.0;
  *(float *)(v1 + 53208) = 0.0;
  *(float *)(v1 + 53216) = 1.0;
  sub_100116F0(v1 + 53164, v1 + 47412, v1 + 53008);
  *(_DWORD *)(v1 + 58816) = v1 + 184;
  *(_DWORD *)(v1 + 58820) = dword_102D2B4C + 4732;
  *(_DWORD *)(v1 + 58824) = dword_102D2B4C + 20620;
  *(_WORD *)(v1 + 58828) = 32;
  *(_DWORD *)(v1 + 58830) = 1330398790;
  *(_WORD *)(v1 + 58834) = 87;
  *(_DWORD *)(v1 + 58846) = 4739152;
  *(_BYTE *)(v1 + 58854) = 0;
  *(_DWORD *)(v1 + 58856) = 0;
  *(float *)(v1 + 58972) = 149.0;
  *(float *)(v1 + 58976) = 427.0;
  *(float *)(v1 + 58980) = 117.0;
  *(float *)(v1 + 58984) = 117.0;
  *(float *)(v1 + 58992) = 0.015669972;
  *(float *)(v1 + 58988) = 0.0031339945;
  *(float *)(v1 + 58996) = 100.0;
  *(float *)(v1 + 59000) = 79.0;
  *(float *)(v1 + 59004) = 401.0;
  *(float *)(v1 + 59008) = 117.0;
  *(float *)(v1 + 59012) = 117.0;
  *(float *)(v1 + 59020) = 0.0;
  *(float *)(v1 + 59016) = 0.0;
  *(float *)(v1 + 59024) = 1.0;
  sub_100116F0(v1 + 58972, v1 + 53220, v1 + 58816);
  *(_DWORD *)(v1 + 76240) = v1 + 220;
  *(_DWORD *)(v1 + 76244) = dword_102D2B4C + 5060;
  *(_DWORD *)(v1 + 76248) = dword_102D2B4C + 20676;
  *(_WORD *)(v1 + 76252) = 14;
  *(_DWORD *)(v1 + 76254) = 4999503;
  *(_DWORD *)(v1 + 76270) = 4805456;
  *(_BYTE *)(v1 + 76278) = 0;
  *(_DWORD *)(v1 + 76280) = 2;
  *(float *)(v1 + 76304) = *(float *)(dword_102D2B4C + 5072);
  *(_BYTE *)(v1 + 76308) = 0;
  *(float *)(v1 + 76332) = *(float *)(dword_102D2B4C + 5084);
  *(_BYTE *)(v1 + 76336) = 1;
  *(float *)(v1 + 76396) = 10.0;
  *(float *)(v1 + 76400) = 530.0;
  *(float *)(v1 + 76404) = 117.0;
  *(float *)(v1 + 76408) = 117.0;
  *(float *)(v1 + 76416) = 344737.97;
  *(float *)(v1 + 76412) = 68947.594;
  *(float *)(v1 + 76420) = 1.0;
  *(float *)(v1 + 76424) = 5.0;
  *(float *)(v1 + 76428) = 498.0;
  *(float *)(v1 + 76432) = 117.0;
  *(float *)(v1 + 76436) = 117.0;
  *(float *)(v1 + 76444) = 0.0;
  *(float *)(v1 + 76440) = 0.0;
  *(float *)(v1 + 76448) = 1.0;
  sub_100116F0(v1 + 76396, v1 + 70644, v1 + 76240);
  v11 = 0.0;
  if ( 0.0 != *(float *)(v1 + 82260) )
  {
    sub_10034DE0(0.0, 4, v1 + 82260, v1 + 70644);
    *(float *)(v1 + 72736) = 10.0;
    *(_DWORD *)(v1 + 72748) = -65536;
    v11 = 0.0;
    *(_BYTE *)(v1 + 72940) = 1;
  }
  *(_DWORD *)(v1 + 82048) = v1 + 232;
  *(_DWORD *)(v1 + 82052) = dword_102D2B4C + 5060;
  *(_DWORD *)(v1 + 82056) = dword_102D2B4C + 20676;
  *(_WORD *)(v1 + 82060) = 14;
  *(_DWORD *)(v1 + 82062) = 4999503;
  *(_DWORD *)(v1 + 82078) = 4805456;
  *(_BYTE *)(v1 + 82086) = 0;
  *(_DWORD *)(v1 + 82088) = 2;
  *(float *)(v1 + 82112) = *(float *)(dword_102D2B4C + 5072);
  *(_BYTE *)(v1 + 82116) = 0;
  *(float *)(v1 + 82140) = *(float *)(dword_102D2B4C + 5084);
  *(_BYTE *)(v1 + 82144) = 1;
  *(float *)(v1 + 82204) = 149.0;
  *(float *)(v1 + 82208) = 530.0;
  *(float *)(v1 + 82212) = 117.0;
  *(float *)(v1 + 82216) = 117.0;
  *(float *)(v1 + 82224) = 344737.97;
  *(float *)(v1 + 82220) = 68947.594;
  *(float *)(v1 + 82228) = 1.0;
  *(float *)(v1 + 82232) = 79.0;
  *(float *)(v1 + 82236) = 498.0;
  *(float *)(v1 + 82240) = 117.0;
  *(float *)(v1 + 82244) = 117.0;
  *(float *)(v1 + 82252) = v11;
  *(float *)(v1 + 82248) = v11;
  *(float *)(v1 + 82256) = 1.0;
  sub_100116F0(v1 + 82204, v1 + 76452, v1 + 82048);
  v12 = 0.0;
  if ( 0.0 != *(float *)(v1 + 82260) )
  {
    sub_10034DE0(0.0, 4, v1 + 82260, v1 + 76452);
    *(float *)(v1 + 78544) = 10.0;
    v12 = 0.0;
    *(_DWORD *)(v1 + 78556) = -65536;
    *(_BYTE *)(v1 + 78748) = 1;
  }
  *(_DWORD *)(v1 + 64624) = v1 + 196;
  *(_DWORD *)(v1 + 64628) = dword_102D2B4C + 4896;
  *(_DWORD *)(v1 + 64632) = dword_102D2B4C + 20648;
  *(_WORD *)(v1 + 64636) = 17;
  *(_DWORD *)(v1 + 64638) = 4999503;
  *(_WORD *)(v1 + 64654) = 17297;
  *(_BYTE *)(v1 + 64656) = 0;
  *(_BYTE *)(v1 + 64662) = 0;
  *(_DWORD *)(v1 + 64664) = 1;
  *(float *)(v1 + 64688) = *(float *)(dword_102D2B4C + 4916);
  *(_BYTE *)(v1 + 64692) = 1;
  *(float *)(v1 + 64780) = 10.0;
  *(float *)(v1 + 64784) = 633.0;
  *(float *)(v1 + 64788) = 117.0;
  *(float *)(v1 + 64792) = 117.0;
  *(float *)(v1 + 64800) = 20.0;
  *(float *)(v1 + 64796) = 5.0;
  *(float *)(v1 + 64804) = 1.0;
  *(float *)(v1 + 64808) = 5.0;
  *(float *)(v1 + 64812) = 595.0;
  *(float *)(v1 + 64816) = 117.0;
  *(float *)(v1 + 64820) = 117.0;
  *(float *)(v1 + 64828) = v12;
  *(float *)(v1 + 64824) = v12;
  *(float *)(v1 + 64832) = 1.0;
  sub_100116F0(v1 + 64780, v1 + 59028, v1 + 64624);
  *(_DWORD *)(v1 + 70432) = v1 + 208;
  *(_DWORD *)(v1 + 70436) = dword_102D2B4C + 4896;
  *(_DWORD *)(v1 + 70440) = dword_102D2B4C + 20648;
  *(_WORD *)(v1 + 70444) = 17;
  *(_DWORD *)(v1 + 70446) = 4999503;
  *(_WORD *)(v1 + 70462) = 17297;
  *(_BYTE *)(v1 + 70464) = 0;
  *(_BYTE *)(v1 + 70470) = 0;
  *(_DWORD *)(v1 + 70472) = 1;
  *(float *)(v1 + 70496) = *(float *)(dword_102D2B4C + 4916);
  *(_BYTE *)(v1 + 70500) = 1;
  *(float *)(v1 + 70588) = 149.0;
  *(float *)(v1 + 70592) = 633.0;
  *(float *)(v1 + 70596) = 117.0;
  *(float *)(v1 + 70600) = 117.0;
  *(float *)(v1 + 70608) = 20.0;
  *(float *)(v1 + 70604) = 5.0;
  *(float *)(v1 + 70612) = 1.0;
  *(float *)(v1 + 70616) = 79.0;
  *(float *)(v1 + 70620) = 595.0;
  *(float *)(v1 + 70624) = 117.0;
  *(float *)(v1 + 70628) = 117.0;
  *(float *)(v1 + 70636) = 0.0;
  *(float *)(v1 + 70632) = 0.0;
  *(float *)(v1 + 70640) = 1.0;
  sub_100116F0(v1 + 70588, v1 + 64836, v1 + 70432);
  *(float *)(v1 + 82268) = 0.0;
}
// 10089924: using guessed type __int16 word_10089924;
// 102D2B44: using guessed type int dword_102D2B44;
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10012D00) --------------------------------------------------------
int __usercall sub_10012D00@<eax>(int a1@<esi>)
{
  int v1; // edi@1
  int result; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008B2F8, *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12), 0, 255);
  result = sub_10038CD0(a1, *(_WORD **)(a1 + 52), *(char **)(v1 + 60), *(_DWORD *)(v1 + 56), *(_DWORD *)(v1 + 72), 255);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10012D50) --------------------------------------------------------
char __usercall sub_10012D50@<al>(int a1@<edi>)
{
  int v1; // esi@1
  char result; // al@1

  v1 = sub_10001640(a1, *(char **)(a1 + 56), 82680, 0);
  sub_100011B0(a1, 0, 0, 279, 742, 3);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_BYTE *)(v1 + 82676) = 0;
  *(_DWORD *)(v1 + 56) = v1 + 32;
  *(_DWORD *)(v1 + 60) = &unk_1008B33C;
  sub_10011A80(a1);
  *(_DWORD *)(v1 + 4) = v1 + 6232;
  *(_DWORD *)v1 = v1 + 248;
  *(_DWORD *)(v1 + 16) = v1 + 24180;
  *(_DWORD *)(v1 + 8) = v1 + 12216;
  *(_DWORD *)(v1 + 12) = v1 + 18196;
  *(_DWORD *)(v1 + 28) = v1 + 41604;
  *(_DWORD *)(v1 + 20) = v1 + 29988;
  *(_DWORD *)(v1 + 24) = v1 + 35796;
  *(_DWORD *)(v1 + 40) = v1 + 70644;
  *(_DWORD *)(v1 + 48) = v1 + 59028;
  *(_DWORD *)(v1 + 52) = v1 + 64836;
  *(_DWORD *)(v1 + 36) = v1 + 53220;
  *(_DWORD *)(v1 + 72) = v1 + 64;
  *(_DWORD *)(v1 + 44) = v1 + 76452;
  *(_DWORD *)(v1 + 32) = v1 + 47412;
  *(_BYTE *)(v1 + 64) = 3;
  *(_BYTE *)(*(_DWORD *)(v1 + 72) + 1) = 3;
  *(_BYTE *)(*(_DWORD *)(v1 + 72) + 2) = 3;
  *(_BYTE *)(*(_DWORD *)(v1 + 72) + 3) = 3;
  *(_BYTE *)(*(_DWORD *)(v1 + 72) + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(v1 + 72) + 5) = 3;
  sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008B2F8, v1, 0, 255);
  sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008B33C, v1 + 32, 0, 255);
  sub_100017F0(a1, *(_DWORD *)(a1 + 56), 125);
  result = sub_10001E70(a1, *(_DWORD *)(a1 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}

//----- (10012EA0) --------------------------------------------------------
BOOL __cdecl sub_10012EA0(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1

  v3 = a1;
  if ( a1 >= (double)*v2 )
  {
    if ( a2 < v3 - *v2 )
    {
      *v2 = a2 + *v2;
      return *v2 == v3;
    }
LABEL_6:
    *v2 = a1;
    return *v2 == v3;
  }
  if ( a2 >= *v2 - v3 )
    goto LABEL_6;
  *v2 = *v2 - a2;
  return *v2 == v3;
}

//----- (10012F00) --------------------------------------------------------
void __usercall sub_10012F00(int a1@<eax>)
{
  int v1; // eax@1
  float *v2; // esi@1
  float *v3; // ecx@1
  signed int v4; // edx@1
  int v5; // eax@3

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = (float *)(v1 + 80);
  v3 = (float *)(v1 + 80);
  v4 = 14;
  do
  {
    *v3 = 9.8999998e24;
    v3 += 3;
    --v4;
  }
  while ( v4 );
  v5 = v1 + 76;
  *v2 = *(float *)(v5 + 82272);
  *(float *)(v5 + 28) = *(float *)(v5 + 82276);
  *(float *)(v5 + 52) = *(float *)(v5 + 82280);
  *(float *)(v5 + 76) = *(float *)(v5 + 82284);
  *(float *)(v5 + 124) = *(float *)(v5 + 82288);
  *(float *)(v5 + 148) = *(float *)(v5 + 82292);
  *(float *)(v5 + 100) = *(float *)(v5 + 82296);
  *(float *)(v5 + 16) = *(float *)(v5 + 82472);
  *(float *)(v5 + 40) = *(float *)(v5 + 82476);
  *(float *)(v5 + 64) = *(float *)(v5 + 82480);
  *(float *)(v5 + 88) = *(float *)(v5 + 82484);
  *(float *)(v5 + 136) = *(float *)(v5 + 82488);
  *(float *)(v5 + 160) = *(float *)(v5 + 82492);
  *(float *)(v5 + 112) = *(float *)(v5 + 82496);
  sub_10023690(v5, 0xEu);
}

//----- (10012FC0) --------------------------------------------------------
void __usercall sub_10012FC0(int a1@<eax>)
{
  int v1; // ecx@1
  int v2; // ebp@1
  void *v3; // ecx@2
  bool v4; // c3@4
  char v5; // al@6
  void *v6; // edi@8
  double v7; // st7@9
  double v8; // st7@12
  char v9; // al@14
  void *v10; // ecx@14
  double v11; // st7@14
  void *v12; // ecx@14
  int v13; // ebx@15
  char v14; // al@20
  void *v15; // ecx@20
  double v16; // st7@20
  void *v17; // ecx@20
  int v18; // ebx@21
  char v19; // al@25
  void *v20; // edi@27
  double v21; // st6@28
  float v22; // ST34_4@33
  char v23; // al@33
  void *v24; // ecx@33
  double v25; // st7@33
  void *v26; // ecx@33
  int v27; // ebx@34
  float v28; // ST34_4@39
  char v29; // al@39
  void *v30; // ecx@39
  double v31; // st7@39
  void *v32; // ecx@39
  int v33; // ebx@40
  int v34; // eax@51
  void *v35; // ecx@51
  int v36; // eax@53
  float v37; // ST4C_4@54
  void *v38; // ecx@54
  int v39; // ebx@55
  void *v40; // ecx@60
  float v41; // ST4C_4@63
  void *v42; // ecx@63
  int v43; // ebx@64
  int v44; // edx@69
  char v45; // [sp+1Bh] [bp-5h]@1

  v1 = *(_DWORD *)(a1 + 56);
  v2 = *(_DWORD *)(v1 + 12);
  v45 = 0;
  if ( !*(_BYTE *)(v2 + 82676) && (sub_10025D10((void *)v1) == 1 || sub_10025CF0(v3) == 2) )
  {
    sub_100116F0(v2 + 6192, v2 + 248, v2 + 5844);
    sub_100116F0(v2 + 12176, v2 + 6232, v2 + 11828);
    sub_100116F0(v2 + 18160, v2 + 12216, v2 + 17812);
    sub_100116F0(v2 + 24140, v2 + 18196, v2 + 23792);
    sub_100116F0(v2 + 29960, v2 + 24180, v2 + 29776);
    sub_100116F0(v2 + 35768, v2 + 29988, v2 + 35584);
    sub_100116F0(v2 + 41576, v2 + 35796, v2 + 41392);
    sub_100116F0(v2 + 47384, v2 + 41604, v2 + 47200);
    sub_100116F0(v2 + 53192, v2 + 47412, v2 + 53008);
    sub_100116F0(v2 + 59000, v2 + 53220, v2 + 58816);
    sub_100116F0(v2 + 76424, v2 + 70644, v2 + 76240);
    sub_100116F0(v2 + 82232, v2 + 76452, v2 + 82048);
    sub_100116F0(v2 + 64808, v2 + 59028, v2 + 64624);
    sub_100116F0(v2 + 70616, v2 + 64836, v2 + 70432);
    *(float *)(v2 + 6228) = 1.0;
    *(float *)(v2 + 12212) = 1.0;
    *(_BYTE *)(v2 + 82264) = 0;
    *(_BYTE *)(v2 + 6220) = 0;
    *(_BYTE *)(v2 + 12204) = 0;
    *(_BYTE *)(v2 + 18188) = 0;
    *(float *)(v2 + 18192) = 0.0;
    *(float *)(v2 + 24172) = 0.0;
    *(_BYTE *)(v2 + 24168) = 0;
    v4 = 0.0 == *(float *)(v2 + 82260);
    *(_BYTE *)(v2 + 82676) = 1;
    v45 = 1;
    if ( !v4 )
    {
      sub_10034DE0(0.0, 4, v2 + 82260, v2 + 70644);
      *(float *)(v2 + 72736) = 10.0;
      *(_DWORD *)(v2 + 72748) = -65536;
      *(_BYTE *)(v2 + 72940) = 1;
      sub_10034DE0(0.0, 4, v2 + 82260, v2 + 76452);
      *(float *)(v2 + 78544) = 10.0;
      *(_DWORD *)(v2 + 78556) = -65536;
      *(_BYTE *)(v2 + 78748) = 1;
    }
  }
  v5 = *(_BYTE *)(v2 + 82277);
  if ( v5 != *(_BYTE *)(v2 + 82272) || v45 )
  {
    v6 = (void *)(v2 + 17968);
    if ( v5 == 2 )
    {
      qmemcpy(v6, (const void *)(dword_102D2B4C + 4076), 0xA4u);
      *(_DWORD *)(v2 + 17820) = dword_102D2B4C + 20508;
      v7 = *(float *)(dword_102D2B4C + 4092);
    }
    else
    {
      qmemcpy(v6, (const void *)(dword_102D2B4C + 4240), 0xA4u);
      *(_DWORD *)(v2 + 17820) = dword_102D2B4C + 20536;
      v7 = *(float *)(dword_102D2B4C + 4256);
    }
    *(float *)(v2 + 17876) = v7;
    *(_DWORD *)(v2 + 17852) = 1;
    *(_BYTE *)(v2 + 82272) = v5;
  }
  v8 = 0.07;
  if ( v5 == 2 )
    goto LABEL_75;
  if ( *(_BYTE *)(v2 + 18188) != 2 )
  {
    v9 = sub_10012EA0(0.0, 0.07);
    v11 = 1.0 - *(float *)v10;
    *(_BYTE *)(v2 + 18188) = 3 - (v9 != 0);
    *(float *)(v2 + 17976) = v11 * *(float *)(dword_102D2B4C + 4248) + *(float *)(dword_102D2B4C + 4084) * *(float *)v10;
    if ( sub_10025D10(v10) == 1 || (v13 = v2 + 18132, sub_10025CF0(v12) == 2) )
      v13 = v2 + 18160;
    sub_100116F0(v13, v2 + 12216, v2 + 17812);
    sub_10034DE0(0.0, 4, v2 + 24176, v2 + 12216);
    *(float *)(v2 + 14308) = 10.0;
    *(_DWORD *)(v2 + 14320) = -65536;
    *(_BYTE *)(v2 + 14512) = 1;
LABEL_24:
    v8 = 0.07;
    goto LABEL_25;
  }
  if ( v5 == 2 )
  {
LABEL_75:
    if ( *(_BYTE *)(v2 + 18188) != 1 )
    {
      v14 = sub_10012EA0(1.0, 0.07);
      v16 = 1.0 - *(float *)v15;
      *(_BYTE *)(v2 + 18188) = 2 * (v14 == 0) + 1;
      *(float *)(v2 + 17976) = v16 * *(float *)(dword_102D2B4C + 4248)
                             + *(float *)(dword_102D2B4C + 4084) * *(float *)v15;
      if ( sub_10025D10(v15) == 1 || (v18 = v2 + 18132, sub_10025CF0(v17) == 2) )
        v18 = v2 + 18160;
      sub_100116F0(v18, v2 + 12216, v2 + 17812);
      goto LABEL_24;
    }
  }
LABEL_25:
  v19 = *(_BYTE *)(v2 + 82477);
  if ( v19 != *(_BYTE *)(v2 + 82273) || v45 )
  {
    v20 = (void *)(v2 + 23948);
    if ( v19 == 2 )
    {
      qmemcpy(v20, (const void *)(dword_102D2B4C + 4076), 0xA4u);
      *(_DWORD *)(v2 + 23800) = dword_102D2B4C + 20508;
      v21 = *(float *)(dword_102D2B4C + 4092);
    }
    else
    {
      qmemcpy(v20, (const void *)(dword_102D2B4C + 4240), 0xA4u);
      *(_DWORD *)(v2 + 23800) = dword_102D2B4C + 20536;
      v21 = *(float *)(dword_102D2B4C + 4256);
    }
    *(float *)(v2 + 23856) = v21;
    *(_DWORD *)(v2 + 23832) = 1;
    *(_BYTE *)(v2 + 82273) = v19;
  }
  if ( v19 != 2 )
  {
    if ( *(_BYTE *)(v2 + 24168) != 2 )
    {
      v22 = v8;
      v23 = sub_10012EA0(0.0, v22);
      v25 = 1.0 - *(float *)v24;
      *(_BYTE *)(v2 + 24168) = 3 - (v23 != 0);
      *(float *)(v2 + 23956) = v25 * *(float *)(dword_102D2B4C + 4248)
                             + *(float *)(dword_102D2B4C + 4084) * *(float *)v24;
      if ( sub_10025D10(v24) == 1 || (v27 = v2 + 24112, sub_10025CF0(v26) == 2) )
        v27 = v2 + 24140;
      sub_100116F0(v27, v2 + 18196, v2 + 23792);
      sub_10034DE0(0.0, 4, v2 + 24176, v2 + 18196);
      *(float *)(v2 + 20288) = 10.0;
      *(_DWORD *)(v2 + 20300) = -65536;
      *(_BYTE *)(v2 + 20492) = 1;
      goto LABEL_43;
    }
    if ( v19 != 2 )
      goto LABEL_43;
  }
  if ( *(_BYTE *)(v2 + 24168) != 1 )
  {
    v28 = v8;
    v29 = sub_10012EA0(1.0, v28);
    v31 = 1.0 - *(float *)v30;
    *(_BYTE *)(v2 + 24168) = 2 * (v29 == 0) + 1;
    *(float *)(v2 + 23956) = v31 * *(float *)(dword_102D2B4C + 4248) + *(float *)(dword_102D2B4C + 4084) * *(float *)v30;
    if ( sub_10025D10(v30) == 1 || (v33 = v2 + 24112, sub_10025CF0(v32) == 2) )
      v33 = v2 + 24140;
    sub_100116F0(v33, v2 + 18196, v2 + 23792);
  }
LABEL_43:
  if ( *(_BYTE *)(v2 + 82277) == 2 )
    *(_BYTE *)(v2 + 14200) = *(_BYTE *)(2 - (sub_1003E540((int)"ITT_1_TRANS") != 0) + dword_102D2B4C + 4168);
  else
    *(_BYTE *)(v2 + 14208) = *(_BYTE *)(dword_102D2B4C - (sub_1003E540((int)"ITT_1_ST_TRANS") != 0) + 4335);
  if ( *(_BYTE *)(v2 + 82477) == 2 )
    *(_BYTE *)(v2 + 20180) = *(_BYTE *)(2 - (sub_1003E540((int)"ITT_2_TRANS") != 0) + dword_102D2B4C + 4168);
  else
    *(_BYTE *)(v2 + 20188) = *(_BYTE *)(dword_102D2B4C - (sub_1003E540((int)"ITT_2_ST_TRANS") != 0) + 4335);
  *(_BYTE *)(v2 + 2240) = *(_BYTE *)(dword_102D2B4C - (sub_1003E540((int)"TRQ_1_TRANS") != 0) + 4007);
  *(_BYTE *)(v2 + 8224) = *(_BYTE *)(dword_102D2B4C - (sub_1003E540((int)"TRQ_2_TRANS") != 0) + 4007);
  if ( sub_1003E540((int)"NP_1_LO") )
  {
    if ( *(_BYTE *)(v2 + 6220) == 2 )
      goto LABEL_58;
    LOBYTE(v34) = 3 - ((unsigned __int8)sub_10012EA0(0.0, 0.07) != 0);
  }
  else
  {
    if ( *(_BYTE *)(v2 + 6220) == 1 )
      goto LABEL_58;
    v36 = sub_10012EA0(1.0, 0.07);
    LOBYTE(v36) = (_BYTE)v36 == 0;
    v34 = 2 * v36 + 1;
  }
  *(_BYTE *)(v2 + 6220) = v34;
  v37 = (*(float *)(dword_102D2B4C + 3932) - *(float *)(dword_102D2B4C + 3928)) * *(float *)v35
      + *(float *)(dword_102D2B4C + 3928);
  *(float *)(v2 + 6224) = v37;
  *(float *)(v2 + 5908) = v37;
  *(float *)(v2 + 6020) = *(float *)(v2 + 6224);
  if ( sub_10025D10(v35) == 1 || (v39 = v2 + 6164, sub_10025CF0(v38) == 2) )
    v39 = v2 + 6192;
  sub_100116F0(v39, v2 + 248, v2 + 5844);
LABEL_58:
  if ( sub_1003E540((int)"NP_2_LO") )
  {
    if ( *(_BYTE *)(v2 + 12204) == 2 )
      goto LABEL_67;
    *(_BYTE *)(v2 + 12204) = 3 - ((unsigned __int8)sub_10012EA0(0.0, 0.07) != 0);
  }
  else
  {
    if ( *(_BYTE *)(v2 + 12204) == 1 )
      goto LABEL_67;
    *(_BYTE *)(v2 + 12204) = 2 * ((unsigned __int8)sub_10012EA0(1.0, 0.07) == 0) + 1;
  }
  v41 = (*(float *)(dword_102D2B4C + 3932) - *(float *)(dword_102D2B4C + 3928)) * *(float *)v40
      + *(float *)(dword_102D2B4C + 3928);
  *(float *)(v2 + 12208) = v41;
  *(float *)(v2 + 11892) = v41;
  *(float *)(v2 + 12004) = *(float *)(v2 + 12208);
  if ( sub_10025D10(v40) == 1 || (v43 = v2 + 12148, sub_10025CF0(v42) == 2) )
    v43 = v2 + 12176;
  sub_100116F0(v43, v2 + 6232, v2 + 11828);
LABEL_67:
  *(_BYTE *)(v2 + 37780) = *(_BYTE *)(2 - (sub_1003E540((int)"NG_1_TRANS") != 0) + dword_102D2B4C + 4660);
  *(_BYTE *)(v2 + 43588) = *(_BYTE *)(2 - (sub_1003E540((int)"NG_2_TRANS") != 0) + dword_102D2B4C + 4660);
  *(_BYTE *)(v2 + 26172) = *(_BYTE *)(dword_102D2B4C - (sub_1003E540((int)"NP_1_TRANS") != 0) + 4499);
  *(_BYTE *)(v2 + 31980) = *(_BYTE *)(dword_102D2B4C - (sub_1003E540((int)"NP_2_TRANS") != 0) + 4499);
  *(_BYTE *)(v2 + 61028) = *(_BYTE *)(dword_102D2B4C - (sub_1003E540((int)"OT_1_TRANS") != 0) + 4992);
  *(_BYTE *)(v2 + 66836) = *(_BYTE *)(dword_102D2B4C - (sub_1003E540((int)"OT_2_TRANS") != 0) + 4992);
  if ( sub_1003E540((int)"HI_ALT") )
  {
    if ( *(_BYTE *)(v2 + 82264) == 2 )
      return;
    *(_BYTE *)(v2 + 82264) = 2;
    *(_BYTE *)(v2 + 72628) = *(_BYTE *)(dword_102D2B4C + 5155);
    *(_DWORD *)(v2 + 70892) = *(_DWORD *)(dword_102D2B4C + 5124);
    sub_1003C3C0(v2 + 70848);
    *(_BYTE *)(v2 + 78436) = *(_BYTE *)(dword_102D2B4C + 5155);
    v44 = *(_DWORD *)(dword_102D2B4C + 5124);
  }
  else
  {
    if ( *(_BYTE *)(v2 + 82264) == 1 )
      return;
    *(_BYTE *)(v2 + 82264) = 1;
    *(_BYTE *)(v2 + 72628) = *(_BYTE *)(dword_102D2B4C + 5154);
    *(_DWORD *)(v2 + 70892) = *(_DWORD *)(dword_102D2B4C + 5120);
    sub_1003C3C0(v2 + 70848);
    *(_BYTE *)(v2 + 78436) = *(_BYTE *)(dword_102D2B4C + 5154);
    v44 = *(_DWORD *)(dword_102D2B4C + 5120);
  }
  *(_DWORD *)(v2 + 76700) = v44;
  sub_1003C3C0(v2 + 76656);
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10013B50) --------------------------------------------------------
void __cdecl sub_10013B50(int a1)
{
  int v1; // edi@5
  void *v2; // ecx@5
  void *v3; // ecx@5
  void *v4; // ecx@9
  void *v5; // ecx@9

  switch ( **(_WORD **)(a1 + 52) )
  {
    case 0x8015:
    case 0x8016:
      sub_10012D00(a1);
      break;
    default:
      return;
    case 0x8041:
      sub_10012D50(a1);
      break;
    case 0x8022:
    case 0x8078:
      v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
      sub_10013F90(v1 + 82276);
      sub_10013F90(v1 + 82476);
      sub_10012F00(a1);
      sub_10012FC0(a1);
      sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008B2E0, (int)&unk_1008B370, 0, 255);
      if ( sub_10025D10(v2) == 1 || sub_10025CF0(v3) == 2 )
        sub_10011170(a1);
      else
        sub_10010EF0(a1);
      sub_10038CD0(a1, *(_WORD **)(a1 + 52), (char *)&unk_1008B2F8, v1, 0, 255);
      sub_10038CD0(a1, *(_WORD **)(a1 + 52), *(char **)(v1 + 60), *(_DWORD *)(v1 + 56), *(_DWORD *)(v1 + 72), 255);
      if ( sub_10025D10(v4) != 1 && sub_10025CF0(v5) != 2 )
        sub_100114D0(a1, *(float *)&a1);
      *(_BYTE *)(a1 + 6) = 2;
      break;
    case 0x8039:
      sub_10001E70(a1, *(_DWORD *)(a1 + 56), -32734);
      break;
  }
}

//----- (10013C10) --------------------------------------------------------
char __cdecl sub_10013C10(int a1, char a2)
{
  char result; // al@4

  if ( a2 )
  {
    if ( !*(_DWORD *)a1 )
    {
      *(_DWORD *)a1 = sub_100160A0();
      return 0;
    }
    if ( (unsigned int)(sub_100160A0() - *(_DWORD *)a1) <= *(_DWORD *)(a1 + 4) )
      return 0;
    result = 1;
  }
  else
  {
    *(_DWORD *)a1 = 0;
    result = 0;
  }
  return result;
}

//----- (10013C50) --------------------------------------------------------
int __cdecl sub_10013C50(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (10013C70) --------------------------------------------------------
double __usercall sub_10013C70@<st0>(unsigned int a1@<esi>)
{
  float v1; // ST04_4@1
  double result; // st7@1
  float v3; // ST04_4@3

  v1 = sub_100236F0(a1);
  result = v1;
  if ( v1 == 9.8999998e24 )
  {
    if ( a1 >> 16 )
    {
      v3 = sub_100236F0(HIWORD(a1));
      result = v3;
    }
  }
  return result;
}

//----- (10013CB0) --------------------------------------------------------
char __usercall sub_10013CB0@<al>(int a1@<edi>)
{
  double v1; // st7@1
  unsigned __int16 v2; // cx@1
  double v3; // st7@1
  unsigned __int16 v4; // dx@1
  double v5; // st7@1
  bool v6; // zf@1
  char result; // al@2
  double v8; // st7@3
  double v9; // st7@6
  float v10; // [sp+Ch] [bp-8h]@2
  float v11; // [sp+10h] [bp-4h]@3

  *(float *)(a1 + 72) = sub_10013C70(*(_DWORD *)(a1 + 104));
  *(float *)(a1 + 76) = sub_10013C70(*(_DWORD *)(a1 + 108));
  *(float *)(a1 + 80) = sub_10013C70(*(_DWORD *)(a1 + 112));
  *(float *)(a1 + 84) = sub_10013C70(*(_DWORD *)(a1 + 116));
  v1 = sub_100236F0(*(_WORD *)(a1 + 120));
  v2 = *(_WORD *)(a1 + 122);
  *(float *)(a1 + 88) = v1;
  v3 = sub_100236F0(v2);
  v4 = *(_WORD *)(a1 + 124);
  *(float *)(a1 + 92) = v3;
  v5 = sub_100236F0(v4);
  v6 = *(_BYTE *)a1 == 1;
  *(float *)(a1 + 100) = v5;
  if ( v6 )
  {
    result = sub_1003FCD0(&v10);
    if ( result )
    {
      v11 = v10;
      v8 = v10;
    }
    else
    {
      v11 = 9.8999998e24;
      v8 = (float)9.8999998e24;
    }
  }
  else
  {
    result = sub_1003FCF0(&v10);
    if ( result )
      v9 = v10;
    else
      v9 = 9.8999998e24;
    v11 = v9;
    v8 = v11;
  }
  v6 = *(_BYTE *)(a1 + 196) == 0;
  *(float *)(a1 + 96) = v8;
  if ( !v6 )
  {
    if ( !sub_10042760(5, (void *)(a1 + 76)) && !sub_10042760(6, (void *)(a1 + 76)) )
      *(float *)(a1 + 76) = 9.8999998e24;
    result = sub_10042760(665, (void *)(a1 + 84));
    if ( !result )
    {
      result = sub_10042760(666, (void *)(a1 + 84));
      if ( !result )
        *(float *)(a1 + 84) = 9.8999998e24;
    }
  }
  return result;
}

//----- (10013DD0) --------------------------------------------------------
int __cdecl sub_10013DD0(float a1)
{
  int v1; // ecx@0
  int v2; // eax@1
  signed int v3; // esi@1
  int v4; // eax@2
  int v5; // edx@3
  int result; // eax@4
  bool v7; // zf@4

  v2 = *(_DWORD *)(v1 + 8);
  v3 = *(_DWORD *)(v1 + 16);
  if ( v2 == v3 )
  {
    v4 = *(_DWORD *)(v1 + 20);
    *(float *)(v1 + 4) = *(float *)(v1 + 4) - *(float *)(*(_DWORD *)(v1 + 12) + 4 * v4);
    *(_DWORD *)(v1 + 20) = (v4 + 1) % v3;
LABEL_3:
    v5 = (*(_DWORD *)(v1 + 24) + 1) % v3;
    goto LABEL_4;
  }
  v5 = 0;
  if ( v2 )
    goto LABEL_3;
  *(_DWORD *)(v1 + 20) = 0;
LABEL_4:
  *(_DWORD *)(v1 + 24) = v5;
  *(float *)(*(_DWORD *)(v1 + 12) + 4 * v5) = a1;
  result = *(_DWORD *)(v1 + 8);
  v7 = result == *(_DWORD *)(v1 + 16);
  *(float *)(v1 + 4) = a1 + *(float *)(v1 + 4);
  if ( !v7 )
    *(_DWORD *)(v1 + 8) = ++result;
  return result;
}

//----- (10013E30) --------------------------------------------------------
double __usercall sub_10013E30@<st0>(int a1@<eax>)
{
  return (float)((*(float *)(*(_DWORD *)(a1 + 12) + 4 * *(_DWORD *)(a1 + 24))
                - *(float *)(*(_DWORD *)(a1 + 12) + 4 * *(_DWORD *)(a1 + 20)))
               / *(float *)a1);
}

//----- (10013E50) --------------------------------------------------------
int __usercall sub_10013E50@<eax>(int result@<eax>, int a2@<ecx>, signed int a3)
{
  *(_DWORD *)(result + 12) = a2;
  *(_DWORD *)(result + 16) = a3;
  *(_DWORD *)(result + 8) = 0;
  *(float *)result = (double)a3 * 0.125;
  *(float *)(result + 4) = 0.0;
  return result;
}

//----- (10013E80) --------------------------------------------------------
char __cdecl sub_10013E80(int a1)
{
  char v1; // al@1
  bool v2; // zf@1
  char v4; // [sp+7h] [bp-1h]@1

  v1 = *(_BYTE *)a1;
  v2 = *(_BYTE *)a1 == 1;
  v4 = 0;
  *(_BYTE *)(a1 + 196) = 0;
  if ( v2 )
  {
    *(_DWORD *)(a1 + 104) = 171;
    *(_DWORD *)(a1 + 108) = 23;
    *(_DWORD *)(a1 + 112) = 169;
    *(_DWORD *)(a1 + 116) = 170;
LABEL_6:
    *(_WORD *)(a1 + 124) = 22;
    *(_WORD *)(a1 + 122) = 28;
    *(_WORD *)(a1 + 120) = 29;
    goto LABEL_7;
  }
  if ( v1 != 2 )
  {
    *(_DWORD *)(a1 + 104) = 11403435;
    *(_DWORD *)(a1 + 108) = 3145751;
    *(_DWORD *)(a1 + 112) = 11272361;
    *(_DWORD *)(a1 + 116) = 11337898;
    *(_BYTE *)a1 = 1;
    goto LABEL_6;
  }
  *(_DWORD *)(a1 + 104) = 174;
  *(_DWORD *)(a1 + 108) = 48;
  *(_DWORD *)(a1 + 112) = 172;
  *(_DWORD *)(a1 + 116) = 173;
  *(_WORD *)(a1 + 120) = 54;
  *(_WORD *)(a1 + 122) = 53;
  *(_WORD *)(a1 + 124) = 47;
  sub_10016450(9140, (int)&v4, 1);
LABEL_7:
  *(float *)(a1 + 60) = 0.0;
  *(float *)(a1 + 64) = 0.0;
  *(float *)(a1 + 68) = 0.0;
  *(_BYTE *)(a1 + 1) = 0;
  *(float *)(a1 + 56) = 9.8999998e24;
  sub_10013E50(a1 + 160, a1 + 128, 8);
  sub_10013C50(a1 + 188, 2000);
  sub_10016450(9139, (int)&v4, 1);
  return sub_10013CB0(a1);
}

//----- (10013F90) --------------------------------------------------------
void __cdecl sub_10013F90(int a1)
{
  int v1; // edi@1
  int v2; // ecx@2
  char v3; // bl@3
  char v4; // al@4
  double v5; // st7@13
  bool v6; // dl@17
  bool v7; // cl@23
  char v8; // bl@25
  bool v9; // zf@37
  double v10; // st7@43
  double v11; // st6@43
  char v12; // [sp+Eh] [bp-1Ah]@5
  char v13; // [sp+Fh] [bp-19h]@37
  float v14; // [sp+10h] [bp-18h]@2
  float v15; // [sp+14h] [bp-14h]@11
  float v16; // [sp+18h] [bp-10h]@11
  float v17; // [sp+1Ch] [bp-Ch]@11
  float v18; // [sp+20h] [bp-8h]@11
  float v19; // [sp+24h] [bp-4h]@11

  v1 = a1;
  sub_10013CB0(a1);
  if ( 9.8999998e24 == *(float *)(v1 + 84) )
  {
    v3 = 0;
    v12 = 0;
    goto LABEL_9;
  }
  sub_10013DD0(*(float *)(v1 + 84));
  v14 = sub_10013E30(v2);
  if ( v14 <= 0.5 )
  {
    v3 = 0;
    if ( v14 >= -0.5 )
    {
      v4 = 1;
      goto LABEL_5;
    }
  }
  else
  {
    v3 = 1;
  }
  v4 = 0;
LABEL_5:
  v12 = sub_10013C10(v1 + 188, v4);
LABEL_9:
  if ( 9.8999998e24 == *(float *)(v1 + 84) || 9.8999998e24 == *(float *)(v1 + 76) )
    goto LABEL_40;
  sub_10016BE0(55, &v15);
  sub_10016BE0(56, &v17);
  sub_10016BE0(57, &v18);
  sub_10016BE0(58, &v19);
  sub_10016BE0(59, &v16);
  if ( !sub_10040380(215, &a1) )
    LOBYTE(a1) = v3;
  v5 = v16;
  v6 = (v15 < (double)*(float *)(v1 + 84) && v12 || v17 < (double)*(float *)(v1 + 84)) && *(float *)(v1 + 76) > v5;
  v7 = (v18 > (double)*(float *)(v1 + 84) && *(float *)(v1 + 76) < v5 || v19 > (double)*(float *)(v1 + 76))
    && !(_BYTE)a1;
  v8 = *(_BYTE *)(v1 + 1);
  if ( !v8 )
  {
    if ( v6 )
    {
      *(_BYTE *)(v1 + 1) = 2;
    }
    else if ( (_BYTE)a1 )
    {
      *(_BYTE *)(v1 + 1) = 1;
    }
    goto LABEL_36;
  }
  if ( v8 == 1 )
  {
    if ( !v6 )
    {
LABEL_28:
      if ( v7 )
        *(_BYTE *)(v1 + 1) = 0;
      goto LABEL_36;
    }
    *(_BYTE *)(v1 + 1) = 2;
  }
  else if ( v8 == 2 )
  {
    goto LABEL_28;
  }
LABEL_36:
  if ( v8 != *(_BYTE *)(v1 + 1) )
  {
    v9 = *(_BYTE *)v1 == 2;
    v13 = *(_BYTE *)(v1 + 1);
    if ( v9 )
      sub_10016450(9140, (int)&v13, 1);
    else
      sub_10016450(9139, (int)&v13, 1);
  }
LABEL_40:
  if ( !*(_BYTE *)(v1 + 196) )
  {
    if ( 9.8999998e24 == *(float *)(v1 + 80) || *(float *)(v1 + 12) >= (double)*(float *)(v1 + 80) )
    {
      v10 = 1.355817317962646;
      *(float *)(v1 + 44) = *(float *)(v1 + 8) * 5252.0 / *(float *)(v1 + 12) * 1.355817317962646;
      v11 = 5252.0 * *(float *)(v1 + 4) / *(float *)(v1 + 12);
    }
    else
    {
      v10 = 1.355817317962646;
      *(float *)(v1 + 44) = *(float *)(v1 + 8) * 5252.0 / *(float *)(v1 + 80) * 1.355817317962646;
      v11 = 5252.0 * *(float *)(v1 + 4) / *(float *)(v1 + 80);
    }
    *(float *)(v1 + 40) = v10 * v11;
  }
  if ( 9.8999998e24 != *(float *)(v1 + 76) )
  {
    if ( *(_BYTE *)(v1 + 1) == 2 )
    {
      *(float *)(v1 + 52) = *(float *)(v1 + 32);
      *(float *)(v1 + 48) = *(float *)(v1 + 28);
      *(float *)(v1 + 56) = *(float *)(v1 + 36);
    }
    else
    {
      *(float *)(v1 + 52) = *(float *)(v1 + 20);
      *(float *)(v1 + 48) = *(float *)(v1 + 16);
      *(float *)(v1 + 56) = *(float *)(v1 + 24);
    }
  }
}

//----- (10014250) --------------------------------------------------------
int __cdecl sub_10014250(char a1, char a2, char a3)
{
  void *v3; // ecx@1
  int v4; // esi@1
  void *v5; // ecx@1
  __int16 v7; // [sp+4h] [bp-D0h]@1
  char v8; // [sp+Ch] [bp-C8h]@1
  char v9; // [sp+Dh] [bp-C7h]@1
  char v10; // [sp+Eh] [bp-C6h]@1
  char v11; // [sp+Fh] [bp-C5h]@1

  memset(&v7, 0, 0xCCu);
  LOBYTE(v3) = a1;
  v7 = -32659;
  v8 = a1;
  v9 = a2;
  v10 = a3;
  v11 = -1;
  v4 = 9;
  if ( sub_100405D0(v3) & 3 || sub_10025D10(v5) == 1 )
    v4 = 14;
  return sub_100161A0(v4, (int)&v7, 5000, 1);
}

//----- (100142F0) --------------------------------------------------------
int __cdecl sub_100142F0(char a1)
{
  void *v1; // ecx@1
  int v2; // esi@1
  void *v3; // ecx@1
  __int16 v5; // [sp+4h] [bp-D0h]@1
  char v6; // [sp+Ch] [bp-C8h]@1
  char v7; // [sp+Fh] [bp-C5h]@1

  memset(&v5, 0, 0xCCu);
  LOBYTE(v1) = a1;
  v5 = -32659;
  v6 = -1;
  v7 = a1;
  v2 = 9;
  if ( sub_100405D0(v1) & 3 || sub_10025D10(v3) == 1 )
    v2 = 14;
  return sub_100161A0(v2, (int)&v5, 60000, 1);
}

//----- (10014390) --------------------------------------------------------
char __cdecl sub_10014390(char a1)
{
  return sub_1006D940(a1, -122);
}

//----- (100143B0) --------------------------------------------------------
char sub_100143B0()
{
  sub_1006D8F0();
  return sub_10014390(0);
}

//----- (100143C0) --------------------------------------------------------
_WORD *__cdecl sub_100143C0(int a1)
{
  _WORD *result; // eax@1

  result = *(_WORD **)(a1 + 52);
  if ( *result == -32711 )
  {
    result = (_WORD *)sub_100015D0(a1, (int)sub_10002BF0);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = result;
  }
  return result;
}

//----- (10014460) --------------------------------------------------------
char __cdecl sub_10014460(unsigned int a1)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == 32918 )
  {
    sub_10025E40();
    sub_100428F0();
    sub_10023670(a1, 1, sub_10002BF0, 0);
    result = 1;
  }
  else if ( **(_WORD **)(a1 + 52) == 32920 )
  {
    sub_10016100(4, 1, 0, 0);
    result = 1;
  }
  return result;
}

//----- (100144B0) --------------------------------------------------------
_WORD *__usercall sub_100144B0@<eax>(int a1@<edi>, int a2)
{
  char v2; // al@1
  _WORD *result; // eax@2

  v2 = *(_BYTE *)(a2 + 2);
  if ( v2 )
  {
    dword_1017E5A4 = 18285286;
    dword_1017E5A8 = 33554440;
    dword_1017E5A0 = (int)&unk_101219A0;
    *(_WORD *)(a2 + 16) = 279;
    if ( v2 == 1 )
    {
      *(_WORD *)(a2 + 14) = 686;
      sub_10002A20(18285286, a1, a2);
      result = sub_10002B80(a2);
    }
    else
    {
      *(_WORD *)(a2 + 14) = 742;
      sub_10002A20(18285286, a1, a2);
      result = sub_10002B80(a2);
    }
  }
  else
  {
    dword_1017E5A0 = (int)&unk_101219A0;
    dword_1017E5A4 = 13763246;
    dword_1017E5A8 = 16777224;
    *(_WORD *)(a2 + 14) = 686;
    *(_WORD *)(a2 + 16) = 210;
    sub_10002A20(13763246, a1, a2);
    result = sub_10002B80(a2);
  }
  return result;
}
// 1017E5A0: using guessed type int dword_1017E5A0;
// 1017E5A4: using guessed type int dword_1017E5A4;
// 1017E5A8: using guessed type int dword_1017E5A8;

//----- (10014560) --------------------------------------------------------
char __cdecl sub_10014560(int a1)
{
  int v1; // eax@1
  __int16 v2; // cx@2
  __int16 v4; // [sp+4h] [bp-D0h]@3
  int v5; // [sp+8h] [bp-CCh]@6

  v1 = sub_100015D0(a1, (int)sub_10002BF0);
  if ( v1 )
  {
    v2 = **(_WORD **)(a1 + 52);
    if ( v2 == -32749 )
    {
      v4 = -32747;
    }
    else if ( v2 == -32748 )
    {
      v4 = -32746;
    }
    v5 = v1;
    LOBYTE(v1) = sub_10001740(a1, (int)&v4, 204);
  }
  return v1;
}

//----- (100145E0) --------------------------------------------------------
char sub_100145E0()
{
  char result; // al@1

  result = 0;
  byte_1026D91C = 0;
  byte_1026D91D = 0;
  return result;
}
// 1026D91C: using guessed type char byte_1026D91C;
// 1026D91D: using guessed type char byte_1026D91D;

//----- (100145F0) --------------------------------------------------------
void __cdecl sub_100145F0(unsigned int a1)
{
  sub_10023670(a1, -1, sub_10002BF0, 0);
}

//----- (10014620) --------------------------------------------------------
int __cdecl sub_10014620(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@1
  int v4; // ecx@2

  result = *(_DWORD *)(a1 + 56);
  if ( result == *(_DWORD *)(a1 + 48) )
  {
    v4 = *(_DWORD *)(result + 264);
    if ( v4 )
    {
      result = 10 * a2;
      if ( *(_BYTE *)(result + v4 + 4) != a3 )
      {
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + result + 4) = a3;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 330) = 1;
      }
    }
  }
  return result;
}

//----- (10014670) --------------------------------------------------------
char __cdecl sub_10014670(int a1, unsigned __int8 a2, __int16 a3)
{
  int v3; // esi@1
  char result; // al@1
  int v5; // ecx@2

  v3 = *(_DWORD *)(a1 + 56);
  result = 0;
  if ( v3 == *(_DWORD *)(a1 + 48) )
  {
    v5 = 10 * a2;
    if ( *(_WORD *)(v5 + *(_DWORD *)(v3 + 264)) != a3 )
    {
      *(_WORD *)(v5 + *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264)) = a3;
      result = 1;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 330) = 1;
    }
  }
  return result;
}

//----- (100146C0) --------------------------------------------------------
int __cdecl sub_100146C0(int a1, unsigned __int8 a2)
{
  int v2; // ebp@1
  int v3; // ecx@1
  int v4; // edi@1
  char v5; // bl@1
  char v6; // cl@1
  int result; // eax@1
  bool v8; // zf@1
  unsigned __int8 v9; // dl@4
  int v10; // esi@5
  int v11; // ecx@5
  char v12; // [sp+10h] [bp+4h]@1

  v2 = a1;
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264);
  v4 = 10 * a2;
  v5 = *(_BYTE *)(v3 + v4 + 7);
  v6 = *(_BYTE *)(v3 + v4 + 6);
  result = *(_DWORD *)(a1 + 56);
  v8 = result == *(_DWORD *)(a1 + 48);
  v12 = v6;
  if ( v8 )
  {
    if ( v6 == -1 )
    {
      result = *(_DWORD *)(result + 264) + v4 + 2;
      *(_BYTE *)result = *(_BYTE *)result == 0;
      *(_BYTE *)(*(_DWORD *)(v2 + 56) + 330) = 1;
    }
    else
    {
      v9 = 0;
      if ( *(_BYTE *)(result + 257) )
      {
        do
        {
          v10 = *(_DWORD *)(result + 264);
          v11 = v10 + 10 * v9;
          if ( *(_BYTE *)(v10 + 10 * v9 + 7) == v5 && *(_BYTE *)(v11 + 6) == v12 )
          {
            if ( v9 == a2 )
            {
              if ( !*(_BYTE *)(v10 + v4 + 2) )
                *(_BYTE *)(v11 + 2) = 1;
            }
            else
            {
              *(_BYTE *)(v11 + 2) = 0;
            }
          }
          result = *(_DWORD *)(v2 + 56);
          ++v9;
        }
        while ( v9 < *(_BYTE *)(result + 257) );
      }
      *(_BYTE *)(*(_DWORD *)(v2 + 56) + 330) = 1;
    }
  }
  return result;
}

//----- (10014790) --------------------------------------------------------
char __usercall sub_10014790@<al>(int a1@<eax>, int a2@<ecx>, char a3)
{
  _BYTE *v3; // edx@2
  signed int v4; // esi@2
  unsigned __int8 v5; // bl@4
  int v6; // edx@5

  if ( a2 == *(_DWORD *)(a1 + 48) )
  {
    v3 = (_BYTE *)(a2 + 316);
    a1 = a2 + 268;
    v4 = 12;
    do
    {
      *(_DWORD *)a1 = 0;
      *v3 = -1;
      a1 += 4;
      ++v3;
      --v4;
    }
    while ( v4 );
    v5 = 0;
    if ( *(_BYTE *)(a2 + 257) )
    {
      do
      {
        v6 = *(_DWORD *)(a2 + 264) + 10 * v5;
        LOBYTE(a1) = a3;
        if ( *(_BYTE *)(v6 + 7) == a3 )
        {
          a1 = (unsigned __int8)(*(_BYTE *)(v6 + 5) - 1);
          *(_DWORD *)(a2 + 4 * a1 + 268) = v6;
          *(_BYTE *)(a1 + a2 + 316) = v5;
        }
        ++v5;
      }
      while ( v5 < *(_BYTE *)(a2 + 257) );
    }
    *(_BYTE *)(a2 + 330) = 1;
  }
  return a1;
}

//----- (10014820) --------------------------------------------------------
char __cdecl sub_10014820(int a1, unsigned __int8 a2)
{
  char result; // al@1

  result = a1;
  if ( *(_DWORD *)(a1 + 56) == *(_DWORD *)(a1 + 48) )
  {
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 7) = -1;
    result = sub_10014790(a1, *(_DWORD *)(a1 + 56), 0);
  }
  return result;
}

//----- (10014850) --------------------------------------------------------
char __cdecl sub_10014850(int a1, unsigned __int8 a2, char a3)
{
  char result; // al@1

  result = 0;
  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 10 * a2 + 2) != a3 )
  {
    sub_100146C0(a1, a2);
    result = 1;
  }
  return result;
}

//----- (10014890) --------------------------------------------------------
int __usercall sub_10014890@<eax>(int a1@<eax>, char a2@<bl>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-4h]@0

  sub_10014790(a1, *(_DWORD *)(a1 + 56), v4);
  result = a3;
  *(_BYTE *)(a3 + 260) = a2;
  return result;
}

//----- (100148B0) --------------------------------------------------------
int __cdecl sub_100148B0(int a1, char a2)
{
  return sub_10014890(a1, a2, *(_DWORD *)(a1 + 56));
}

//----- (100148D0) --------------------------------------------------------
int __cdecl sub_100148D0(int a1)
{
  void *v1; // ecx@1
  int result; // eax@3
  int v3; // ebp@3
  int v4; // edi@11
  int v5; // ecx@15
  int v6; // ecx@17
  char v7; // [sp+1h] [bp-7h]@1
  char v8; // [sp+2h] [bp-6h]@9
  char v9; // [sp+3h] [bp-5h]@11
  char v10; // [sp+4h] [bp-4h]@7

  sub_10016BE0(9, &v7);
  if ( v7 == 8 )
    v7 = sub_10025D10(v1) != 1 ? 6 : 0;
  result = *(_DWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 56) = result;
  if ( result )
  {
    if ( *(_BYTE *)(result + 328) )
    {
      result = sub_10016030();
      if ( result != 1 )
      {
        if ( v7 == 7 )
        {
          if ( sub_10040DE0(0, &v10) )
          {
            sub_10014620(a1, 0x1Au, 0);
            sub_10016380(10016, (int)&v8, 1);
            sub_10014850(a1, 0x1Au, v8 != 0);
          }
          else
          {
            sub_10014620(a1, 0x1Au, 1);
          }
        }
        if ( sub_10043450(16) )
        {
          v4 = sub_100430B0(&v7, 1u, (int)&unk_1008F6D0, 2, 3, 0);
          if ( sub_10040380(188, &v9) && v9 )
            sub_10014620(a1, byte_1008F6D1[2 * v4], 0);
          else
            sub_10014620(a1, byte_1008F6D1[2 * v4], 1);
        }
        sub_10014620(a1, 1u, 1);
        sub_10014620(a1, 2u, 1);
        sub_10014620(a1, 4u, 1);
        sub_10014620(a1, 9u, 1);
        sub_10014620(a1, 3u, 1);
        sub_10014620(a1, 8u, 1);
        if ( byte_1017E5AC )
        {
          v5 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_DWORD *)(v5 + 264) + 247) = 0;
        }
        if ( sub_10025C10((void *)v5) )
        {
          sub_10014620(a1, 1u, 0);
          sub_10014620(a1, 2u, 0);
          sub_10014620(a1, 4u, 0);
          sub_10014620(a1, 9u, 0);
          if ( byte_1017E5AC )
          {
            v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264);
            *(_BYTE *)(v6 + 247) = -1;
          }
        }
        if ( sub_10025C30((void *)v6) )
        {
          sub_10014620(a1, 1u, 0);
          sub_10014620(a1, 2u, 0);
          sub_10014620(a1, 3u, 0);
          sub_10014620(a1, 8u, 0);
          if ( byte_1017E5AC )
            *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 247) = -1;
        }
        if ( sub_10043010(1u) )
        {
          sub_10014670(a1, 0x11u, 5253);
          sub_10014670(a1, 0x12u, 1910);
        }
        else
        {
          sub_10014670(a1, 0x11u, 4718);
          sub_10014670(a1, 0x12u, 7152);
        }
        result = sub_10014890(a1, *(_BYTE *)(*(_DWORD *)(a1 + 56) + 260), *(_DWORD *)(a1 + 56));
      }
    }
  }
  *(_DWORD *)(a1 + 56) = v3;
  return result;
}
// 1017E5AC: using guessed type char byte_1017E5AC;

//----- (10014B40) --------------------------------------------------------
int __cdecl sub_10014B40(int a1, void *a2, unsigned __int8 a3, char a4, unsigned __int8 a5)
{
  void *v5; // ecx@3
  signed int v6; // ecx@10
  signed int v7; // edx@10
  signed int v8; // ecx@13
  signed int v9; // edx@13
  signed int v10; // ecx@16
  signed int v11; // edx@16
  signed int v12; // ecx@19
  signed int v13; // edx@19
  signed int v14; // ecx@22
  signed int v15; // edx@22
  signed int v16; // ecx@25
  signed int v17; // edx@25
  signed int v18; // ecx@30
  signed int v19; // edx@30
  signed int v20; // ecx@39
  signed int v21; // edx@39
  signed int v22; // ecx@42
  signed int v23; // edx@42
  int v24; // eax@45
  signed int v25; // ecx@45
  signed int v26; // edx@45
  signed int v27; // ecx@48
  signed int v28; // edx@48
  signed int v29; // ecx@52
  signed int v30; // edx@52
  signed int v31; // ecx@55
  signed int v32; // edx@55
  int v33; // eax@59
  signed int v34; // ecx@59
  signed int v35; // edx@59
  signed int v36; // ecx@62
  signed int v37; // edx@62
  signed int v38; // ecx@65
  signed int v39; // edx@65
  char v40; // al@84
  void *v41; // ecx@85
  void *v42; // ecx@90
  void *v43; // ecx@94
  void *v44; // ecx@97
  void *v45; // ecx@98
  void *v46; // ecx@99
  int result; // eax@108
  int v48; // [sp+0h] [bp-1560h]@0
  char v49; // [sp+Dh] [bp-1553h]@3
  char v50; // [sp+Eh] [bp-1552h]@1
  char v51; // [sp+Fh] [bp-1551h]@72
  void *v52; // [sp+10h] [bp-1550h]@84
  void *v53; // [sp+14h] [bp-154Ch]@1
  int v54; // [sp+18h] [bp-1548h]@1
  char v55; // [sp+1Ch] [bp-1544h]@27
  char v56; // [sp+ABCh] [bp-AA4h]@27
  char v57; // [sp+AF9h] [bp-A67h]@28

  v53 = a2;
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 257) = a3 + (a5 << 6);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 328) = a5;
  v50 = 0;
  v54 = a3;
  if ( 10 * (a3 + (unsigned __int8)(a5 << 6)) > 0 )
    *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) = sub_10002860(a1, 10 * (a3 + (unsigned __int8)(a5 << 6)));
  sub_10016BE0(9, &v49);
  if ( sub_10025D10(v5) == 1 )
  {
    switch ( v49 )
    {
      case 8:
        v49 = 0;
        break;
      case 0xD:
        v49 = 14;
        break;
      case 0x13:
      case 0x15:
      case 0x16:
        v49 = 2;
        break;
      default:
        break;
    }
  }
  if ( a5 << 6 )
  {
    memcpy_0(*(void **)(*(_DWORD *)(a1 + 56) + 264), &unk_1008EE60, 0xF0u);
    switch ( v49 )
    {
      case 0:
      case 1:
      case 2:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008EF50, 0xBEu);
        v6 = 430;
        v7 = 21;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v6 + 7) = -1;
          v6 += 10;
          --v7;
        }
        while ( v7 );
        break;
      case 0xE:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F010, 0x28u);
        v8 = 280;
        v9 = 36;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v8 + 7) = -1;
          v8 += 10;
          --v9;
        }
        while ( v9 );
        break;
      case 3:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F038, 0xBEu);
        v10 = 430;
        v11 = 21;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v10 + 7) = -1;
          v10 += 10;
          --v11;
        }
        while ( v11 );
        break;
      case 4:
      case 5:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F260, 0x122u);
        v12 = 530;
        v13 = 11;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v12 + 7) = -1;
          v12 += 10;
          --v13;
        }
        while ( v13 );
        break;
      case 0xF:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F388, 0xA0u);
        v14 = 400;
        v15 = 24;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v14 + 7) = -1;
          v14 += 10;
          --v15;
        }
        while ( v15 );
        break;
      case 0xB:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F0F8, 0xB4u);
        v16 = 420;
        v17 = 22;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v16 + 7) = -1;
          v16 += 10;
          --v17;
        }
        while ( v17 );
        memset(&v55, 0, 0xAA0u);
        sub_100163E0(6767, &v56, 2720, &v55);
        if ( *(_BYTE *)(dword_102D2B44 + 1716) && v57 != 47 )
        {
          sub_10014620(a1, 0x1Bu, 2);
          sub_10014620(a1, 0x1Cu, 2);
        }
        break;
      case 0x14:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F1B0, 0xAAu);
        v18 = 410;
        v19 = 23;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v18 + 7) = -1;
          v18 += 10;
          --v19;
        }
        while ( v19 );
        break;
      case 6:
      case 8:
      case 0xD:
      case 0x13:
      case 0x15:
      case 0x16:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F428, 0x1Eu);
        if ( v49 == 8 || v49 == 13 || v49 == 19 || v49 == 21 || v49 == 22 )
        {
          sub_10014670(a1, 0x18u, 2405);
          sub_10014670(a1, 0x19u, 2405);
        }
        v20 = 270;
        v21 = 37;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v20 + 7) = -1;
          v20 += 10;
          --v21;
        }
        while ( v21 );
        break;
      case 7:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F448, 0x28u);
        v22 = 280;
        v23 = 36;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v22 + 7) = -1;
          v22 += 10;
          --v23;
        }
        while ( v23 );
        break;
      case 9:
        v24 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240;
        *(_DWORD *)v24 = 886;
        *(_DWORD *)(v24 + 4) = 16711938;
        *(_WORD *)(v24 + 8) = 255;
        v25 = 250;
        v26 = 39;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v25 + 7) = -1;
          v25 += 10;
          --v26;
        }
        while ( v26 );
        break;
      case 0xA:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F480, 0x104u);
        v27 = 500;
        v28 = 14;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v27 + 7) = -1;
          v27 += 10;
          --v28;
        }
        while ( v28 );
        if ( sub_10025D10((void *)v27) == 1 )
        {
          sub_10014620(a1, 0x1Cu, 2);
          sub_10014620(a1, 0x1Du, 2);
          sub_10014620(a1, 0x1Eu, 2);
          sub_10014620(a1, 0x1Fu, 2);
          sub_10014620(a1, 0x20u, 2);
          sub_10014620(a1, 0x21u, 2);
        }
        break;
      case 0x11:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F584, 0x3Cu);
        v29 = 300;
        v30 = 34;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v29 + 7) = -1;
          v29 += 10;
          --v30;
        }
        while ( v30 );
        break;
      case 0xC:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F5C0, 0x64u);
        v31 = 340;
        v32 = 30;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v31 + 7) = -1;
          v31 += 10;
          --v32;
        }
        while ( v32 );
        if ( sub_10025D10((void *)v31) == 1 )
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 248) = 3;
        break;
      case 0x10:
        v33 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240;
        *(_DWORD *)v33 = 6274;
        *(_DWORD *)(v33 + 4) = 16711938;
        *(_WORD *)(v33 + 8) = 255;
        v34 = 250;
        v35 = 39;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v34 + 7) = -1;
          v34 += 10;
          --v35;
        }
        while ( v35 );
        break;
      case 0x12:
        qmemcpy((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 240), &unk_1008F630, 0xA0u);
        v36 = 400;
        v37 = 24;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v36 + 7) = -1;
          v36 += 10;
          --v37;
        }
        while ( v37 );
        break;
      default:
        v38 = 240;
        v39 = 40;
        do
        {
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + v38 + 7) = -1;
          v38 += 10;
          --v39;
        }
        while ( v39 );
        break;
    }
  }
  if ( a3 )
    memcpy_0((void *)(*(_DWORD *)(*(_DWORD *)(a1 + 56) + 264) + 640 * a5), v53, 10 * v54);
  if ( a5 )
  {
    nullsub_1(a1, v48);
    if ( v49 == 1 )
    {
      sub_10014670(a1, 0x1Au, 6274);
      sub_10014670(a1, 0x20u, 6274);
      sub_10014670(a1, 0x25u, 6274);
      sub_10014670(a1, 0x1Bu, 2801);
      sub_10014670(a1, 0x21u, 2801);
      sub_10014670(a1, 0x26u, 2801);
    }
    sub_10016BE0(133, &v51);
    if ( sub_10043450(16) != 1 || v51 != 1 )
    {
      if ( v49 == 6 || v49 == 8 || v49 == 13 || v49 == 19 || v49 == 21 || v49 == 22 )
      {
        sub_10014620(a1, 0x1Au, 2);
      }
      else if ( v49 == 7 )
      {
        sub_10014620(a1, 0x1Bu, 2);
      }
      else
      {
        sub_10014620(a1, 0x17u, 2);
      }
    }
    sub_10016BE0(39, &v52);
    v40 = (char)v52;
    if ( !((unsigned __int8)v52 & 4) )
      goto LABEL_96;
    v41 = v52;
    LOBYTE(v41) = (unsigned __int8)v52 & 3;
    if ( ((unsigned __int8)v52 & 3) == 1 )
    {
      if ( sub_10025D10(v41) != 1 && sub_100405D0(v41) & 3 )
        goto LABEL_96;
      v40 = (char)v52;
    }
    if ( v40 & 3 )
      goto LABEL_93;
    if ( sub_10025D10(v41) == 1 || sub_100405D0(v42) & 3 )
    {
      v40 = (char)v52;
LABEL_93:
      if ( v40 < 0 )
      {
        sub_10014820(a1, 3u);
        sub_10014820(a1, 4u);
        v50 = 1;
      }
      else
      {
        sub_10014820(a1, 1u);
        sub_10014820(a1, 2u);
        sub_10014820(a1, 0x18u);
      }
      goto LABEL_97;
    }
LABEL_96:
    sub_10014820(a1, 1u);
    sub_10014820(a1, 2u);
    sub_10014820(a1, 3u);
    sub_10014820(a1, 4u);
LABEL_97:
    if ( !sub_100434E0(v43) || sub_100405D0(v44) & 3 || sub_10025CF0(v45) & 2 || sub_10025D10(v46) == 1 )
    {
      sub_10014820(a1, 6u);
      if ( v49 == 10 )
        sub_10014820(a1, 0x1Au);
    }
    else if ( v50 )
    {
      if ( (unsigned __int16)v52 & 0x200 )
        sub_10014820(a1, 0x18u);
      else
        byte_1017E5AC = 1;
    }
    sub_100148D0(a1);
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 259) = 0;
  result = sub_100148B0(a1, a4);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 329) = 1;
  return result;
}
// 1017E5AC: using guessed type char byte_1017E5AC;
// 102D2B44: using guessed type int dword_102D2B44;

//----- (10015480) --------------------------------------------------------
#error "10015485: call analysis failed (funcsize=28)"

//----- (100154B0) --------------------------------------------------------
#error "100154CE: call analysis failed (funcsize=33)"

//----- (10015570) --------------------------------------------------------
int __cdecl sub_10015570(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 10070D36: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015610) --------------------------------------------------------
int __cdecl sub_10015610(float a1, float a2, float a3, float a4)
{
  return gdi_pvg_color4f(LODWORD(a1), LODWORD(a2), LODWORD(a3), LODWORD(a4));
}
// 10070D5A: using guessed type int __cdecl gdi_pvg_color4f(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015640) --------------------------------------------------------
int __cdecl sub_10015640(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1

  return gdi_pvg_color_pointer(&v6, a1, a2, a3, a4, a5);
}
// 10070D60: using guessed type int __cdecl gdi_pvg_color_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100156C0) --------------------------------------------------------
int __cdecl sub_100156C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 10070D7E: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015760) --------------------------------------------------------
int sub_10015760()
{
  gdi_pvg_init();
  return sub_10015CD0();
}
// 10070DA2: using guessed type int gdi_pvg_init(void);

//----- (10015770) --------------------------------------------------------
int __cdecl sub_10015770(float a1)
{
  return gdi_pvg_line_width(LODWORD(a1));
}
// 10070DA8: using guessed type int __cdecl gdi_pvg_line_width(_DWORD);

//----- (100157C0) --------------------------------------------------------
int __cdecl sub_100157C0(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 10070DC6: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015850) --------------------------------------------------------
int __cdecl sub_10015850(float a1, float a2, float a3, float a4)
{
  return gdi_pvg_rotatef(LODWORD(a1), LODWORD(a2), LODWORD(a3), LODWORD(a4));
}
// 10070DEA: using guessed type int __cdecl gdi_pvg_rotatef(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015890) --------------------------------------------------------
int __cdecl sub_10015890(float a1, float a2)
{
  return gdi_pvg_tex_coord2f(LODWORD(a1), LODWORD(a2));
}
// 10070DF6: using guessed type int __cdecl gdi_pvg_tex_coord2f(_DWORD, _DWORD);

//----- (100158B0) --------------------------------------------------------
int __cdecl sub_100158B0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1

  return gdi_pvg_tex_coord_pointer(&v6, a1, a2, a3, a4, a5);
}
// 10070DFC: using guessed type int __cdecl gdi_pvg_tex_coord_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100158F0) --------------------------------------------------------
int __cdecl sub_100158F0(int a1, int a2, float a3)
{
  return gdi_pvg_tex_envf(a1, a2, LODWORD(a3));
}
// 10070E02: using guessed type int __cdecl gdi_pvg_tex_envf(_DWORD, _DWORD, _DWORD);

//----- (10015920) --------------------------------------------------------
int __cdecl sub_10015920(float a1, float a2, float a3)
{
  return gdi_pvg_translatef(LODWORD(a1), LODWORD(a2), LODWORD(a3));
}
// 10070E0E: using guessed type int __cdecl gdi_pvg_translatef(_DWORD, _DWORD, _DWORD);

//----- (10015960) --------------------------------------------------------
int __cdecl sub_10015960(float a1, float a2)
{
  return gdi_pvg_vertex2f(LODWORD(a1), LODWORD(a2));
}
// 10070E1A: using guessed type int __cdecl gdi_pvg_vertex2f(_DWORD, _DWORD);

//----- (10015980) --------------------------------------------------------
int __cdecl sub_10015980(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-14h]@1

  return gdi_pvg_vertex_pointer(&v6, a1, a2, a3, a4, a5);
}
// 10070E20: using guessed type int __cdecl gdi_pvg_vertex_pointer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100159E0) --------------------------------------------------------
char *__cdecl sub_100159E0(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10016030();
  *(_DWORD *)(a5 + 596) = sub_100160A0();
  sub_100160C0((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_10038450(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_100256B0((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10015B10) --------------------------------------------------------
char sub_10015B10()
{
  char result; // al@1

  result = 0;
  byte_10183450 = 0;
  byte_10183451 = 0;
  return result;
}
// 10183450: using guessed type char byte_10183450;
// 10183451: using guessed type char byte_10183451;

//----- (10015B20) --------------------------------------------------------
char __cdecl sub_10015B20(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_100159E0(-5, a1, a2, a4, a5);
  else
    sub_100159E0(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_100385A0((const char *)(a5 + 485), " DBGA", 100);
  sub_100160C0((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_10183450 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_10183451 )
LABEL_15:
      result = sub_10016100(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 10016C60: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 10183450: using guessed type char byte_10183450;
// 10183451: using guessed type char byte_10183451;

//----- (10015C20) --------------------------------------------------------
char __cdecl sub_10015C20(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10015B20(a1, a2, a3, a4, (int)&v5);
}

//----- (10015C90) --------------------------------------------------------
int __cdecl sub_10015C90(int a1, int a2, int a3)
{
  dword_10183468 = a1;
  dword_1018345C = a2;
  dword_10183460 = a3;
  return gdi_pvg_create_window(&dword_10183454);
}
// 10070E2C: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 10183454: using guessed type int dword_10183454;
// 1018345C: using guessed type int dword_1018345C;
// 10183460: using guessed type int dword_10183460;
// 10183468: using guessed type int dword_10183468;

//----- (10015CD0) --------------------------------------------------------
int sub_10015CD0()
{
  int result; // eax@1

  result = 0;
  dword_10183468 = 0;
  dword_1018345C = 0;
  dword_10183460 = 59;
  dword_10183454 = 1;
  dword_10183458 = 0;
  dword_10183464 = 0;
  return result;
}
// 10183454: using guessed type int dword_10183454;
// 10183458: using guessed type int dword_10183458;
// 1018345C: using guessed type int dword_1018345C;
// 10183460: using guessed type int dword_10183460;
// 10183464: using guessed type int dword_10183464;
// 10183468: using guessed type int dword_10183468;

//----- (10015D20) --------------------------------------------------------
int __cdecl sub_10015D20(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10183454 = a1;
  return result;
}
// 10183454: using guessed type int dword_10183454;

//----- (10015D40) --------------------------------------------------------
signed int __cdecl sub_10015D40(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10046BD0(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit(v4);
      sub_1005B210(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_10194BA0 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_10194BA8[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_10194BA0 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_10016C80(
      v2,
      *(_DWORD *)(dword_10194BA8[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_10015D40(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 10070E3E: using guessed type int FIL_vfs_close(void);
// 10194BA0: using guessed type int dword_10194BA0;
// 10194BA8: using guessed type int dword_10194BA8[];

//----- (10015DA0) --------------------------------------------------------
int __cdecl sub_10015DA0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 10070E50: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015E10) --------------------------------------------------------
signed int __cdecl sub_10015E10(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10046BD0(a1);
    return sub_10047A90(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_10015FD0(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10017020(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 10070E62: using guessed type int FIL_vfs_read(void);

//----- (10015E50) --------------------------------------------------------
signed int __cdecl sub_10015E50(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10046B50(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10017020(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 10070E68: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015EE0) --------------------------------------------------------
signed int __cdecl sub_10015EE0(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_10046BB0(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 10070E74: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015F30) --------------------------------------------------------
__int64 __cdecl sub_10015F30(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 10070E7A: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (10015F50) --------------------------------------------------------
int __cdecl sub_10015F50(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 10070E80: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (10015F80) --------------------------------------------------------
int __cdecl sub_10015F80(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 10070E8C: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10015FA0) --------------------------------------------------------
char __cdecl sub_10015FA0(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10015D40(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10015E00: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10015FD0) --------------------------------------------------------
signed int __cdecl sub_10015FD0(unsigned int a1, int a2, int a3)
{
  return sub_10015EE0(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10015FF0) --------------------------------------------------------
int __cdecl sub_10015FF0(int a1, int a2, int a3)
{
  return sub_10015F50(a1, a2, a3);
}

//----- (10016010) --------------------------------------------------------
int __cdecl sub_10016010(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070E9E: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10016030) --------------------------------------------------------
int sub_10016030()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EA4: using guessed type int TSK_pvg_get_id(void);

//----- (10016050) --------------------------------------------------------
int __cdecl sub_10016050(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EAA: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (10016080) --------------------------------------------------------
__int16 __cdecl sub_10016080(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EB0: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (100160A0) --------------------------------------------------------
int sub_100160A0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EB6: using guessed type int TSK_pvg_get_timer(void);

//----- (100160C0) --------------------------------------------------------
int __cdecl sub_100160C0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EBC: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10016100) --------------------------------------------------------
int __cdecl sub_10016100(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EC8: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10016130) --------------------------------------------------------
int __cdecl sub_10016130(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070ECE: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (10016150) --------------------------------------------------------
int __cdecl sub_10016150(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070ED4: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (10016170) --------------------------------------------------------
int __cdecl sub_10016170(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EDA: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (100161A0) --------------------------------------------------------
int __cdecl sub_100161A0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EE0: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100161D0) --------------------------------------------------------
int __cdecl sub_100161D0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EE6: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10016200) --------------------------------------------------------
int __cdecl sub_10016200(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EEC: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10016220) --------------------------------------------------------
int __cdecl sub_10016220(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EF2: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10016240) --------------------------------------------------------
char __cdecl sub_10016240(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_100160A0();
  if ( sub_10016130(a1) == 5 )
    goto LABEL_4;
  while ( sub_100160A0() < v2 )
  {
    sub_10016220(20);
    if ( sub_10016130(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_10016130(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10015C20("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (100162B0) --------------------------------------------------------
int __cdecl sub_100162B0(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10016030();
    sub_100160C0((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070EF8: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (100162F0) --------------------------------------------------------
int __cdecl sub_100162F0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10016150(a2);
  return result;
}
// 10090CD0: using guessed type void *tsk_app_hdr_ptr;

//----- (10016320) --------------------------------------------------------
int __cdecl sub_10016320(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_10016170(a1, a2);
  return result;
}
// 10090CD0: using guessed type void *tsk_app_hdr_ptr;

//----- (10016340) --------------------------------------------------------
int __cdecl sub_10016340(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_10093EF8[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_10093EFC[2 * v1];
}
// 10093EF8: using guessed type int dword_10093EF8[];
// 10093EFC: using guessed type int dword_10093EFC[];

//----- (10016380) --------------------------------------------------------
int __cdecl sub_10016380(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 10070EFE: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100163A0) --------------------------------------------------------
char __cdecl sub_100163A0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10016380(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10015C20("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (100163E0) --------------------------------------------------------
int __cdecl sub_100163E0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_10016380(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10016420) --------------------------------------------------------
int __cdecl sub_10016420(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10016380(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10016450) --------------------------------------------------------
int __cdecl sub_10016450(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 10070F04: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10016470) --------------------------------------------------------
int __cdecl sub_10016470(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_10016450(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_10017170() )
  {
    v4 = sub_10016340(a1);
    if ( v4 != 42066 )
      v3 = sub_10016450(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 10017170: using guessed type int sub_10017170(void);

//----- (100164D0) --------------------------------------------------------
int __cdecl sub_100164D0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_10016470(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10015C20("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10016510) --------------------------------------------------------
char __cdecl sub_10016510(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10016450(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10015C20("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (10016550) --------------------------------------------------------
int __cdecl sub_10016550(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_10016380(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    sub_10016450(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (100165A0) --------------------------------------------------------
int __cdecl sub_100165A0(unsigned int a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 0x8A )
  {
    if ( a1 < 0x8A && (unsigned __int8)sub_10017190() )
      result = dword_101A1BCC + 24 * a1;
    else
      result = 0;
  }
  return result;
}
// 101A1BCC: using guessed type int dword_101A1BCC;

//----- (100165C0) --------------------------------------------------------
int __cdecl sub_100165C0(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  int result; // eax@1

  result = a7;
  *(float *)a7 = a1;
  *(_DWORD *)(a7 + 12) = a6;
  *(float *)(a7 + 4) = a2;
  *(float *)(a7 + 8) = a3;
  *(float *)(a7 + 16) = a4;
  *(float *)(a7 + 20) = a5;
  return result;
}

//----- (100165F0) --------------------------------------------------------
void sub_100165F0()
{
  dword_10188CF0 = 0;
  dword_101A1BCC = -15;
}
// 10188CF0: using guessed type int dword_10188CF0;
// 101A1BCC: using guessed type int dword_101A1BCC;

//----- (10016600) --------------------------------------------------------
int __cdecl sub_10016600(int a1)
{
  j_gdi_pvg_bind_buffer(53, *(_DWORD *)a1);
  j_gdi_pvg_enable_client_state(11);
  j_gdi_pvg_enable_client_state(12);
  j_gdi_pvg_enable_client_state(13);
  sub_10015980(3, 18, 24, *(_DWORD *)(a1 + 8), 0);
  sub_10015640(4, 15, 24, *(_DWORD *)(a1 + 8), 12);
  return sub_100158B0(2, 18, 24, *(_DWORD *)(a1 + 8), 16);
}
// 10015550: using guessed type int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD);
// 10015720: using guessed type int __cdecl j_gdi_pvg_enable_client_state(_DWORD);

//----- (10016660) --------------------------------------------------------
char __cdecl sub_10016660(_DWORD *a1, int a2, int a3, _DWORD *a4, unsigned int a5)
{
  _DWORD *v5; // esi@1
  char v6; // bl@2
  unsigned int v7; // edi@4
  unsigned int v8; // ebp@4
  _DWORD *v9; // ebx@6

  v5 = a1;
  if ( *a1 )
  {
    v6 = 0;
  }
  else
  {
    j_gdi_pvg_gen_buffers(1, a1);
    v6 = 1;
  }
  v7 = sub_100160A0();
  j_gdi_pvg_bind_buffer(53, *v5);
  v8 = a5;
  if ( v6 )
  {
    v9 = (_DWORD *)a5;
  }
  else
  {
    if ( v7 <= a2 + v5[1] )
      goto LABEL_11;
    v9 = a4;
  }
  a1 = v9;
  j_gdi_pvg_buffer_data(53, &a1, a3, 56);
  if ( a1 != v9 )
    return 0;
  v5[1] = v7;
LABEL_11:
  v5[2] = v8 / 0x18;
  j_gdi_pvg_bind_buffer(53, 0);
  return 1;
}
// 10015550: using guessed type int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD);
// 100155D0: using guessed type int __cdecl j_gdi_pvg_buffer_data(_DWORD, _DWORD, _DWORD, _DWORD);
// 10015750: using guessed type int __cdecl j_gdi_pvg_gen_buffers(_DWORD, _DWORD);

//----- (10016700) --------------------------------------------------------
int sub_10016700()
{
  j_gdi_pvg_bind_buffer(53, 0);
  j_gdi_pvg_disable_client_state(11);
  j_gdi_pvg_disable_client_state(12);
  return j_gdi_pvg_disable_client_state(13);
}
// 10015550: using guessed type int __cdecl j_gdi_pvg_bind_buffer(_DWORD, _DWORD);
// 100156A0: using guessed type int __cdecl j_gdi_pvg_disable_client_state(_DWORD);

//----- (10016730) --------------------------------------------------------
signed int __fastcall sub_10016730(char *a1)
{
  unsigned __int8 v1; // al@1
  char v2; // dl@1
  char v3; // bl@1
  signed int result; // eax@13

  v1 = *a1;
  v2 = 0;
  v3 = 0;
  if ( !*a1 )
    goto LABEL_17;
  do
  {
    if ( v1 < 0x30u || v1 > 0x39u )
    {
      if ( v1 >= 0x61u && v1 <= 0x7Au || v1 >= 0x41u && v1 <= 0x5Au )
        v2 = 1;
    }
    else
    {
      v3 = 1;
    }
    v1 = (a1++)[1];
  }
  while ( v1 );
  if ( v2 && v3 )
    result = 1;
  else
LABEL_17:
    result = 0;
  return result;
}

//----- (10016780) --------------------------------------------------------
int __usercall sub_10016780@<eax>(unsigned int a1@<eax>)
{
  return sub_100171A0(a1);
}

//----- (10016790) --------------------------------------------------------
double __cdecl sub_10016790(int a1, int a2, float a3, float a4, float a5)
{
  char *v5; // ebp@1
  int v6; // edi@1
  void *v7; // esi@1
  bool v8; // bl@3
  int v9; // eax@6
  int v10; // edi@6
  double v11; // st7@7
  char v12; // al@7
  double v13; // st7@8
  double v14; // st5@8
  int v15; // eax@13
  double v16; // st4@13
  double v17; // st3@13
  double v18; // rt2@13
  double v19; // st3@13
  bool v20; // zf@13
  float v22; // [sp+0h] [bp-8h]@7
  unsigned int v23; // [sp+4h] [bp-4h]@1

  v5 = (char *)a2;
  a4 = a4 + a5;
  v23 = strlen((const char *)a2);
  v6 = a1;
  v7 = &unk_1017E5B0;
  if ( a1 & 0xC0000000 )
  {
    if ( (a1 & 0xC0000000) == 0x80000000 )
      v8 = (unsigned __int8)sub_10016730((char *)a2) == 0;
    else
      v8 = 0;
  }
  else
  {
    v8 = 1;
  }
  v9 = sub_10016780(v6 & 0x3FFFFFFF);
  v10 = v9;
  if ( v9 )
  {
    v11 = a4;
    a4 = a4 - *(float *)(v9 + 8200) * a5;
    v22 = v11 + a5 * *(float *)(v9 + 8204);
    sub_10016380(6610, (int)&a1, 1);
    v12 = *v5;
    if ( *v5 )
    {
      v13 = a4;
      v14 = a5;
      do
      {
        if ( (_BYTE)a1 && v8 && v12 == 48 )
          v12 = -122;
        v15 = v10 + 32 * (unsigned __int8)v12;
        ++v5;
        v7 = (char *)v7 + 64;
        a4 = *(float *)(v15 + 16) * v14;
        a3 = *(float *)(v15 + 24) + a3;
        *((float *)v7 - 14) = *(float *)v15;
        *((float *)v7 - 13) = *(float *)(v15 + 8);
        v16 = a3;
        *((float *)v7 - 16) = a3;
        *((float *)v7 - 15) = v13;
        *((float *)v7 - 10) = *(float *)(v15 + 4);
        *((float *)v7 - 9) = *(float *)(v15 + 8);
        a4 = a4 + v16;
        v17 = a4;
        *((float *)v7 - 12) = a4;
        v18 = v17;
        *((float *)v7 - 11) = v13;
        *((float *)v7 - 6) = *(float *)(v15 + 4);
        *((float *)v7 - 5) = *(float *)(v15 + 12);
        *((float *)v7 - 8) = v17;
        *((float *)v7 - 7) = v22;
        *((float *)v7 - 2) = *(float *)v15;
        *((float *)v7 - 1) = *(float *)(v15 + 12);
        *((float *)v7 - 4) = v16;
        *((float *)v7 - 3) = v22;
        v19 = *(float *)(v15 + 28);
        v12 = *v5;
        v20 = *v5 == 0;
        a3 = v18 + v19;
      }
      while ( !v20 );
    }
    j_gdi_pvg_text_out_verts(&unk_1017E5B0, v23, *(_DWORD *)(v10 + 8212));
  }
  return a3;
}
// 10015910: using guessed type int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD);

//----- (10016930) --------------------------------------------------------
double __cdecl sub_10016930(int a1, int a2, float a3)
{
  int v3; // eax@1
  double result; // st7@1
  char *v5; // edx@2
  unsigned __int8 i; // cl@2
  int v7; // ecx@3
  float v8; // ST00_4@3
  float v9; // ST00_4@3
  double v10; // st6@3
  float v11; // [sp+0h] [bp-4h]@2

  v3 = sub_10016780(a1);
  result = 0.0;
  if ( v3 )
  {
    v5 = (char *)a2;
    v11 = 0.0;
    for ( i = *(_BYTE *)a2; *v5; v11 = v10 )
    {
      v7 = v3 + 32 * i;
      ++v5;
      v8 = *(float *)(v7 + 16) * a3 + v11;
      v9 = v8 + *(float *)(v7 + 24);
      v10 = v9 + *(float *)(v7 + 28);
      i = *v5;
    }
    result = v11;
  }
  return result;
}

//----- (10016990) --------------------------------------------------------
double __cdecl sub_10016990(int a1, int a2, float a3)
{
  int v3; // eax@1
  double result; // st7@2
  float v5; // ST04_4@3

  v3 = sub_10016780(a1);
  if ( v3 )
  {
    v5 = (*(float *)(v3 + 8204) + *(float *)(v3 + 8200)) * a3 * (double)strlen((const char *)a2);
    result = v5;
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (100169F0) --------------------------------------------------------
double __cdecl sub_100169F0(int a1, int a2, float a3, float a4, float a5)
{
  char *v5; // ebp@1
  void *v6; // esi@1
  bool v7; // bl@3
  int v8; // edi@6
  char v9; // al@7
  double v10; // st7@8
  double v11; // st6@8
  int v12; // eax@13
  double v13; // st5@13
  double v14; // rt0@13
  double v15; // st5@13
  double v16; // st7@13
  double v17; // st4@13
  double v18; // st3@13
  double v19; // rt0@13
  double v20; // st5@13
  char v22; // [sp+13h] [bp-5h]@1
  unsigned int v23; // [sp+14h] [bp-4h]@1
  int v24; // [sp+1Ch] [bp+4h]@13
  float v25; // [sp+28h] [bp+10h]@1
  float v26; // [sp+28h] [bp+10h]@13
  float v27; // [sp+28h] [bp+10h]@13
  float v28; // [sp+2Ch] [bp+14h]@13

  v5 = (char *)a2;
  v23 = strlen((const char *)a2);
  v6 = &unk_1017E5B0;
  v25 = a4 + a5;
  v22 = 0;
  if ( a1 & 0xC0000000 )
  {
    if ( (a1 & 0xC0000000) == 0x80000000 )
      v7 = (unsigned __int8)sub_10016730((char *)a2) == 0;
    else
      v7 = 0;
  }
  else
  {
    v7 = 1;
  }
  v8 = sub_10016780(a1 & 0x3FFFFFFF);
  if ( v8 )
  {
    sub_10016380(6610, (int)&v22, 1);
    v9 = *(_BYTE *)a2;
    if ( *(_BYTE *)a2 )
    {
      v10 = a3;
      v11 = a5;
      do
      {
        if ( v22 && v7 && v9 == 48 )
          v9 = -122;
        v12 = v8 + 32 * (unsigned __int8)v9;
        ++v5;
        v6 = (char *)v6 + 64;
        v28 = *(float *)(v12 + 16) * v11;
        v13 = v25;
        v26 = v25 - *(float *)(v8 + 8200) * v11;
        *(float *)&v24 = v11 * *(float *)(v8 + 8204) + v13;
        *((float *)v6 - 14) = *(float *)v12;
        *((float *)v6 - 13) = *(float *)(v12 + 8);
        v14 = v13;
        v15 = v10;
        v16 = v14;
        *((float *)v6 - 16) = v15;
        v17 = v26;
        *((float *)v6 - 15) = v26;
        *((float *)v6 - 10) = *(float *)(v12 + 4);
        *((float *)v6 - 9) = *(float *)(v12 + 8);
        v27 = v28 + v15;
        *((float *)v6 - 12) = v27;
        *((float *)v6 - 11) = v17;
        *((float *)v6 - 6) = *(float *)(v12 + 4);
        *((float *)v6 - 5) = *(float *)(v12 + 12);
        *((float *)v6 - 8) = v27;
        v18 = *(float *)&v24;
        *((float *)v6 - 7) = *(float *)&v24;
        *((float *)v6 - 2) = *(float *)v12;
        *((float *)v6 - 1) = *(float *)(v12 + 12);
        *((float *)v6 - 4) = v15;
        v19 = v15;
        *((float *)v6 - 3) = *(float *)&v18;
        v9 = *v5;
        v20 = v16 + *(float *)&v24 - v17;
        v10 = v19;
        v25 = v20;
      }
      while ( *v5 );
    }
    j_gdi_pvg_text_out_verts(&unk_1017E5B0, v23, *(_DWORD *)(v8 + 8212));
  }
  return v25;
}
// 10015910: using guessed type int __cdecl j_gdi_pvg_text_out_verts(_DWORD, _DWORD, _DWORD);

//----- (10016B80) --------------------------------------------------------
double __cdecl sub_10016B80(int a1, int a2, float a3)
{
  double result; // st7@1
  int v4; // edx@1
  int v5; // ecx@2
  unsigned __int8 i; // al@2
  float v7; // ST04_4@3
  float v8; // [sp+0h] [bp-8h]@2

  result = 0.0;
  v4 = sub_10016780(a1);
  if ( v4 )
  {
    v5 = a2;
    v8 = 0.0;
    for ( i = *(_BYTE *)a2; i; ++v5 )
    {
      v7 = *(float *)(32 * i + v4 + 16) * a3;
      if ( v8 < (double)v7 )
        v8 = *(float *)(32 * i + v4 + 16) * a3;
      i = *(_BYTE *)(v5 + 1);
    }
    result = v8;
  }
  return result;
}

//----- (10016BE0) --------------------------------------------------------
void __cdecl sub_10016BE0(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10017200(a1, a2);
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070F0A: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (10016C10) --------------------------------------------------------
int __cdecl sub_10016C10(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070F10: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (10016C80) --------------------------------------------------------
unsigned int __cdecl sub_10016C80(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_10194BA8[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_10194B60[a1];
  dword_10194B60[a1] = a3 + v9;
  dword_10194B20[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_10194B20[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 10194B60: using guessed type int dword_10194B60[];
// 10194BA8: using guessed type int dword_10194BA8[];

//----- (10016E30) --------------------------------------------------------
int __usercall sub_10016E30@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_10194BA8[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_10194BA8[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 10194BA8: using guessed type int dword_10194BA8[];

//----- (10016EE0) --------------------------------------------------------
int __cdecl sub_10016EE0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10016E30(a1);
  v3 = &dword_10194BA8[a1];
  v4 = sub_10015E50(
         *(_DWORD *)dword_10194BA8[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_10194BA8[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_10194B60[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 10194B60: using guessed type int dword_10194B60[];
// 10194BA8: using guessed type int dword_10194BA8[];

//----- (10016F90) --------------------------------------------------------
int __usercall sub_10016F90@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_10194BA8[a1];
  v3 = (int *)(dword_10194B60[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_10194BA8[a1] + 32)) % *(_WORD *)(dword_10194BA8[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_10016EE0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 10194B60: using guessed type int dword_10194B60[];
// 10194BA8: using guessed type int dword_10194BA8[];

//----- (10017020) --------------------------------------------------------
unsigned int __cdecl sub_10017020(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_10194BA0 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_10194BA8[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_10194BA0 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_10016170(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_10194BA8[v6] + 28);
        v12 = sub_10016F90(v6, (unsigned int)v7 & *(_DWORD *)(dword_10194BA8[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy_0(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_10194BA8[v6] + 4) != 138 )
        sub_10016150(*(_DWORD *)(dword_10194BA8[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_10194BA8[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10016150(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 10194BA0: using guessed type int dword_10194BA0;
// 10194BA8: using guessed type int dword_10194BA8[];

//----- (10017190) --------------------------------------------------------
signed int sub_10017190()
{
  return sub_100175B0((int)&off_10094568);
}
// 10094568: using guessed type char *off_10094568;

//----- (100171A0) --------------------------------------------------------
int __cdecl sub_100171A0(unsigned int a1)
{
  int result; // eax@3

  if ( a1 < 0xC && (unsigned __int8)sub_10017190() )
    result = 8216 * a1 + dword_101A1BCC + 3312;
  else
    result = 0;
  return result;
}
// 101A1BCC: using guessed type int dword_101A1BCC;

//----- (10017200) --------------------------------------------------------
void __cdecl sub_10017200(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_10025CB0(v2) && sub_10025D10(v3) != 1 )
    *a2 = 0;
}

//----- (10017230) --------------------------------------------------------
int __cdecl sub_10017230(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 10017680: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10017290) --------------------------------------------------------
int __usercall sub_10017290@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_10015FD0(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10015FF0(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_10017230((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_100160A0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_10015E10(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_10015F80(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10015D40(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10015D40(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10015DF0: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10015E00: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10015ED0: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (10017590) --------------------------------------------------------
int __usercall sub_10017590@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 10017680: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (100175B0) --------------------------------------------------------
signed int __cdecl sub_100175B0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10015C20("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10016320(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_100162F0(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_10017590(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_10017290((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_100162F0(v6, 81);
  return (unsigned __int8)v2;
}

//----- (10017690) --------------------------------------------------------
char __cdecl sub_10017690(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  char *v6; // edi@4
  signed int v7; // eax@4
  unsigned int v8; // ST1C_4@4
  int v9; // eax@4
  unsigned int v10; // ST18_4@4
  char *v11; // eax@4
  __int16 v12; // dx@4
  int v13; // ST10_4@4
  signed int v14; // eax@4
  __int16 v15; // dx@4
  int v16; // edx@4
  int v17; // eax@6
  int v18; // edi@7
  int v19; // ebx@7
  char *v20; // eax@7
  int v21; // [sp+8h] [bp-18h]@4
  int v22; // [sp+Ch] [bp-14h]@4
  int v23; // [sp+10h] [bp-10h]@4
  __int16 v24; // [sp+14h] [bp-Ch]@4
  int v25; // [sp+16h] [bp-Ah]@4
  int v26; // [sp+1Ch] [bp-4h]@4

  result = 1;
  if ( *a5 == 32802 )
  {
LABEL_4:
    v6 = sub_10040510(*a4);
    v7 = sub_10022340(*(_DWORD *)(a2 + 4));
    v8 = *(_DWORD *)(a2 + 4);
    v22 = v7;
    v9 = sub_10022C20(v8, 0);
    v10 = *(_DWORD *)(a2 + 4);
    v23 = v9;
    v25 = sub_100222D0(v10);
    v11 = sub_10022300(*(_DWORD *)(a2 + 4));
    v12 = *(_WORD *)(a2 + 8);
    v13 = *(_DWORD *)(a2 + 4);
    v21 = *(_DWORD *)v11;
    v24 = v12;
    v14 = sub_10022370(v13);
    v15 = *(_WORD *)a3;
    v26 = v14;
    *(_WORD *)(a1 + 438) = v15;
    v16 = v21;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_10022C80(a1, v6, &v21, *(_WORD *)(v16 + 30));
    return 2;
  }
  if ( *a5 != 32832 )
  {
    if ( *a5 != 32888 )
      return result;
    goto LABEL_4;
  }
  LOWORD(v17) = *(_WORD *)(a2 + 8);
  if ( (_WORD)v17 )
  {
    v17 = (signed __int16)v17;
  }
  else
  {
    v18 = sub_10022340(*(_DWORD *)(a2 + 4));
    v19 = *(_DWORD *)sub_10022300(*(_DWORD *)(a2 + 4));
    v20 = sub_10040510(*a4);
    v17 = sub_1006D900(v19, v20, v18);
  }
  sub_10022E90(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v17);
  return 2;
}

//----- (100177C0) --------------------------------------------------------
void *__cdecl sub_100177C0(int a1, __int16 a2)
{
  void *result; // eax@1

  result = memset((void *)(*(_DWORD *)(a1 + 56) + 69), 95, a2);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + a2 + 69) = 0;
  return result;
}

//----- (100177F0) --------------------------------------------------------
char __cdecl sub_100177F0(int a1, int a2, char *a3)
{
  char *v3; // edx@1
  _BYTE *v4; // eax@1
  char v5; // cl@2

  v3 = a3;
  v4 = (_BYTE *)(*(_DWORD *)(a1 + 56) + 69);
  do
  {
    v5 = *v3;
    *v4++ = *v3++;
  }
  while ( v5 );
  sub_10038400((const char *)(*(_DWORD *)(a1 + 56) + 69), 32, 95);
  sub_100383B0((const char *)(*(_DWORD *)(a1 + 56) + 69), *(_WORD *)(a2 + 10), 95);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
  return 4;
}

//----- (10017850) --------------------------------------------------------
int __cdecl sub_10017850(int a1, int a2, int a3, signed int a4, int a5)
{
  int v5; // edi@1
  unsigned int v6; // ecx@1
  char v7; // al@6
  int v8; // eax@8
  __int16 v9; // dx@8
  __int64 v10; // rax@9
  float v11; // ST10_4@9

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a1 + 4) & 0xC000 )
  {
    if ( (*(_DWORD *)(a1 + 4) & 0xC000) == 0x4000 )
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8);
    else
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8) / 2;
  }
  else
  {
    LOWORD(a1) = *(_WORD *)a2;
  }
  v7 = *(_BYTE *)(v5 + 15);
  if ( *(_BYTE *)(v5 + 15) & 6 )
  {
    if ( (*(_BYTE *)(v5 + 15) & 6) == 2 )
    {
      v10 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
      v11 = 0.5 * (double)(a5 + 1);
      HIWORD(a1) = (signed int)((double)(*(_WORD *)(v5 + 12) / 2
                                       + (((signed int)v10 - HIDWORD(v10)) >> 1)
                                       + *(_WORD *)(a2 + 2)
                                       - 1)
                              + 0.5
                              + (1.0 - v11) * (double)a4);
      return a1;
    }
    v8 = sub_10022C20(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) + *(_WORD *)(v5 + 12) - a4 * a5 - *(_WORD *)(a3 + 26);
  }
  else
  {
    v8 = sub_10022C20(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
  }
  HIWORD(a1) = BYTE2(v8) + *(_WORD *)(a2 + 2) + v9 - 1;
  return a1;
}

//----- (100179A0) --------------------------------------------------------
char __usercall sub_100179A0@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // eax@3
  int v5; // ecx@3
  char result; // al@4
  int v7; // eax@5
  int v8; // eax@7

  if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) == -128 )
  {
    sub_100177F0(a4, a3, a1);
    sub_100177C0(a4, *(_WORD *)(a3 + 10));
  }
  v4 = *(_DWORD *)(a4 + 56);
  v5 = *(_WORD *)(v4 + 240);
  if ( *(_WORD *)(a2 + 10) == 0x2000 )
  {
    *(_BYTE *)(v5 + v4 + 69) = *(_BYTE *)(a2 + 14);
    v7 = *(_DWORD *)(a4 + 56);
    if ( *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) == 32 )
      *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) = 95;
    ++*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    v8 = *(_WORD *)(a3 + 10) - 1;
    if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) < v8 )
      LOWORD(v8) = *(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) = v8;
    result = 2;
  }
  else
  {
    *(_BYTE *)(v5 + v4 + 69) = 95;
    --*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a4 + 56) + 240) <= 0) - 1;
    result = 2;
  }
  return result;
}

//----- (10017A60) --------------------------------------------------------
char __usercall sub_10017A60@<al>(unsigned __int16 a1@<di>, int a2)
{
  char v2; // bl@1
  char v3; // al@1
  int v4; // esi@1
  int v5; // eax@1
  char result; // al@2

  v2 = 0;
  v3 = sub_10038380(0, a1, 1);
  v4 = (unsigned __int8)v3;
  v5 = (unsigned __int8)sub_10038380(v3, a1, 1);
  if ( v4 == a2 )
  {
    result = 1;
  }
  else
  {
    if ( v5 != v4 )
    {
      do
      {
        if ( v5 == a2 )
          v2 = 1;
        v5 = (unsigned __int8)sub_10038380(v5, a1, 1);
      }
      while ( (unsigned __int8)v5 != v4 );
    }
    result = v2;
  }
  return result;
}

//----- (10017AC0) --------------------------------------------------------
signed int __usercall sub_10017AC0@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3)
{
  char v3; // bl@8
  signed int result; // eax@8
  char v5; // [sp+4h] [bp-4h]@0

  if ( (signed int)a2 <= 177 )
  {
    if ( a2 != 177 )
    {
      switch ( a2 )
      {
        case 0x51u:
        case 0x91u:
          goto LABEL_8;
        case 0x10u:
        case 0x14u:
          goto LABEL_9;
        case 0x92u:
          goto LABEL_11;
        default:
          goto LABEL_12;
      }
      goto LABEL_12;
    }
LABEL_8:
    v3 = 65;
    LOBYTE(result) = sub_10038380(65, a2, -1);
    goto LABEL_13;
  }
  if ( (signed int)a2 > 528 )
  {
    if ( a2 != 1043 )
      goto LABEL_12;
LABEL_11:
    v3 = 97;
    LOBYTE(result) = sub_10038380(97, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 528 )
  {
LABEL_9:
    v3 = 48;
    LOBYTE(result) = sub_10038380(48, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 178 )
    goto LABEL_11;
  if ( a2 == 273 )
    goto LABEL_8;
LABEL_12:
  v3 = v5;
  LOBYTE(result) = sub_10038380(v5, a2, -1);
LABEL_13:
  if ( a3 == 95 )
  {
    if ( a1 > 0 )
      return (unsigned __int8)v3;
  }
  else
  {
    if ( a3 == (unsigned __int8)v3 && a1 < 0 || a3 == (unsigned __int8)result && a1 > 0 )
      return 95;
    do
    {
      LOBYTE(result) = sub_10038380(a3, a2, a1);
      LOBYTE(a3) = result;
    }
    while ( (_BYTE)result == 95 );
  }
  return (unsigned __int8)result;
}

//----- (10017C20) --------------------------------------------------------
signed int __cdecl sub_10017C20(int a1, int a2, signed int a3)
{
  __int16 v3; // si@1
  signed int result; // eax@1
  int v5; // edi@1
  int v6; // ebx@2
  bool v7; // zf@2

  v3 = sub_100378D0(*(_DWORD *)(a2 + 4));
  result = a3;
  v5 = 2 * (a3 >= 0) - 1;
  if ( a3 )
  {
    do
    {
      v6 = *(_DWORD *)(a1 + 56);
      result = sub_10017AC0(v5, v3, *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69));
      v7 = a3 == v5;
      a3 -= v5;
      *(_BYTE *)(*(_WORD *)(v6 + 240) + v6 + 69) = result;
    }
    while ( !v7 );
  }
  return result;
}

//----- (10017C80) --------------------------------------------------------
char __cdecl sub_10017C80(int a1, int a2, int a3, char *a4)
{
  int v4; // esi@1
  char v5; // bl@1
  bool v6; // zf@1
  signed int v7; // eax@3
  unsigned int v8; // ST24_4@3
  int v9; // eax@3
  int v10; // ST1C_4@3
  __int16 v11; // ax@3
  int v12; // eax@6
  int v13; // eax@6
  char *v14; // ebx@6
  bool v15; // al@9
  int v16; // eax@11
  int v17; // eax@13
  int v18; // eax@13
  int v19; // ST1C_4@18
  int v21; // [sp+10h] [bp-28h]@1
  int v22; // [sp+14h] [bp-24h]@1
  int v23; // [sp+18h] [bp-20h]@1
  int v24; // [sp+1Ch] [bp-1Ch]@6
  int v25; // [sp+20h] [bp-18h]@3
  int v26; // [sp+24h] [bp-14h]@3
  int v27; // [sp+28h] [bp-10h]@3
  __int16 v28; // [sp+2Ch] [bp-Ch]@5
  int v29; // [sp+2Eh] [bp-Ah]@3
  int v30; // [sp+34h] [bp-4h]@3
  int v31; // [sp+40h] [bp+8h]@13

  v4 = a2;
  v5 = 0;
  v6 = *(_BYTE *)a2 == 124;
  LOBYTE(v23) = 0;
  v21 = 0;
  v22 = 0;
  if ( v6 )
  {
    v5 = *(_BYTE *)(a2 + 14);
    LOBYTE(v23) = (*(_BYTE *)(a2 + 15) & 1) == 1;
  }
  v25 = sub_10022320(*(_DWORD *)(a2 + 4));
  v7 = sub_10022340(*(_DWORD *)(a2 + 4));
  v8 = *(_DWORD *)(a2 + 4);
  v26 = v7;
  v27 = sub_10022C20(v8, v23);
  v9 = sub_100222D0(*(_DWORD *)(a2 + 4));
  v10 = *(_DWORD *)(a2 + 4);
  v29 = v9;
  v30 = sub_10022370(v10);
  v11 = *(_WORD *)(a2 + 8);
  if ( !v11 )
    v11 = sub_1006D900(v25, a4, v26);
  v6 = *(_BYTE *)a2 == 124;
  v28 = v11;
  if ( v6 )
  {
    sub_10022F60(a4, *(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 14), (int)&v24, (int)&v22);
    v23 = v5;
    v12 = sub_10024080(a4, v25, v27, *(_WORD *)(a2 + 12), v5, &v21);
    v13 = sub_10002860(a1, v12);
    v14 = (char *)v13;
    if ( v21 > 0 )
    {
      v15 = !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128;
      v16 = sub_100240F0((int)a4, v25, 0, *(_WORD *)(a2 + 8), v21, v15, v14);
      v22 = v16;
      if ( v16 == -1 )
      {
        v16 = v21;
        v22 = v21;
      }
      v17 = sub_10017850(a2, a3, v25, v24, v16);
      v6 = *(_BYTE *)(a1 + 3) == 0;
      v31 = v17;
      v18 = v29;
      *(_WORD *)(a1 + 396) = 3;
      if ( !v6 && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_1026D91E || byte_102D1B20) )
      {
        *(_WORD *)(a1 + 428) = HIWORD(v18);
        *(_WORD *)(a1 + 430) = v29;
        v18 = *(_DWORD *)(a1 + 428);
      }
      *(_WORD *)(a1 + 440) = v18;
      *(_WORD *)(a1 + 442) = v18;
      sub_1006E440(a1 + 392, *(_WORD *)a3 - 1, *(_WORD *)(a3 + 2), *(_WORD *)(v4 + 8) + 2, *(_WORD *)(v4 + 12));
      v19 = v23;
      *(_WORD *)(a1 + 438) = v31;
      *(_WORD *)(a1 + 436) = HIWORD(v31);
      LOBYTE(v13) = sub_10022C80(a1, v14, &v25, v19);
    }
    if ( v14 )
      LOBYTE(v13) = sub_100024C0(a1, (unsigned int)v14);
  }
  else
  {
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    LOBYTE(v13) = sub_10022BE0(a1, a4, &v25);
  }
  return v13;
}
// 1026D91E: using guessed type char byte_1026D91E;
// 102D1B20: using guessed type char byte_102D1B20;

//----- (10017EE0) --------------------------------------------------------
char __cdecl sub_10017EE0(int a1, int a2, int a3, char *a4)
{
  int v4; // ebp@1
  signed __int16 v5; // di@1
  int v6; // ecx@1
  int v7; // eax@1
  int v8; // ecx@4
  char v9; // bl@4
  char result; // al@10
  char v11; // bl@11
  char v12; // al@13
  int v13; // eax@18
  int v14; // eax@19
  int v15; // eax@24
  int v16; // [sp+18h] [bp+8h]@1

  v4 = a2;
  LOWORD(v7) = sub_100378D0(*(_DWORD *)(a2 + 4));
  v5 = *(_WORD *)(a3 + 14);
  v6 = (unsigned __int16)v7;
  LOWORD(v7) = *(_WORD *)(a3 + 10);
  v16 = v6;
  if ( (_WORD)v7 == 0x2000 && v5 == 32 )
    v5 = 95;
  v8 = *(_DWORD *)(a1 + 56);
  v9 = 1;
  if ( *(_WORD *)(v8 + 240) == -128 )
  {
    if ( !(*(_DWORD *)(v4 + 4) & 0x200000) )
    {
      v7 = (unsigned __int16)v7;
      if ( (signed int)(unsigned __int16)v7 <= 73 )
      {
        if ( (unsigned __int16)v7 != 73 )
        {
          if ( v7 == 32 )
          {
            v11 = sub_100177F0(a1, v4, a4);
            sub_100177C0(a1, *(_WORD *)(v4 + 10));
            return v11;
          }
          if ( v7 == 56 )
            return sub_100177F0(a1, v4, a4);
          return v9;
        }
        return sub_100179A0(a4, a3, v4, a1);
      }
      if ( v7 == 0x2000 )
      {
        v12 = sub_10017A60(v16, (unsigned __int16)v5);
        goto LABEL_14;
      }
    }
    return v9;
  }
  v7 = (unsigned __int16)v7;
  if ( (signed int)(unsigned __int16)v7 > 57 )
  {
    if ( v7 == 73 )
      return sub_100179A0(a4, a3, v4, a1);
    if ( v7 == 0x2000 )
    {
      v12 = sub_10017A60(v16, (unsigned __int16)v5);
LABEL_14:
      if ( v12 )
        return sub_100179A0(a4, a3, v4, a1);
    }
    return v9;
  }
  if ( (unsigned __int16)v7 != 57 )
  {
    v13 = v7 - 32;
    if ( !v13 )
    {
      result = 6;
      *(_WORD *)(v8 + 240) = -128;
      return result;
    }
    v14 = v13 - 1;
    if ( !v14 )
    {
      *(_WORD *)(v8 + 240) = -128;
      sub_10038400((const char *)(*(_DWORD *)(a1 + 56) + 69), 95, 32);
      sub_100385E0(*(_DWORD *)(a1 + 56) + 69, 0);
      return 3;
    }
    if ( v14 == 23 )
    {
      sub_10017C20(a1, v4, *(_BYTE *)(a3 + 8));
      return 2;
    }
    return v9;
  }
  *(_WORD *)(v8 + 240) += *(_BYTE *)(a3 + 8);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) <= 0) - 1;
  v15 = *(_WORD *)(v4 + 10) - 1;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v15 )
    LOWORD(v15) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = v15;
  return 2;
}

//----- (100180D0) --------------------------------------------------------
char __cdecl sub_100180D0(int a1, int a2, int a3, char *a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  char *v7; // edi@1
  __int16 v8; // bx@3
  int v9; // ebp@3
  __int16 v10; // di@5
  int v11; // eax@5
  char result; // al@5
  char *v13; // eax@10
  char *v14; // edx@10
  char v15; // cl@11
  int v16; // ecx@14
  char v17; // [sp+13h] [bp-5h]@1
  int v18; // [sp+14h] [bp-4h]@5

  v5 = a2;
  v6 = *(_WORD *)(a2 + 8);
  v7 = a4;
  v17 = 1;
  if ( !v6 )
    v6 = sub_10022930(a4, *(_DWORD *)(a2 + 4));
  v8 = v6;
  v9 = *(_DWORD *)sub_10022300(*(_DWORD *)(v5 + 4));
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      if ( *(_BYTE *)v5 == 124 )
      {
        v10 = sub_10022F60(v7, *(_DWORD *)(v5 + 4), *(_BYTE *)(v5 + 14), (int)&v18, (int)&a2);
        v11 = sub_10017850(v5, a3, v9, v18, a2);
        sub_10022E90(a1 + 276, v11, *(_DWORD *)(v5 + 4), v8);
        *(_WORD *)(a1 + 282) = v10 + *(_WORD *)(a1 + 278);
        result = 2;
      }
      else
      {
        sub_10022E90(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(v5 + 4), v8);
        result = 2;
      }
      break;
    case 0x8048:
      v17 = sub_10017EE0(a1, v5, a5, v7);
      switch ( v17 )
      {
        case 2:
        case 4:
          sub_10017C80(a1, v5, a3, (char *)(*(_DWORD *)(a1 + 56) + 69));
          result = v17;
          break;
        case 6:
          sub_10017C80(a1, v5, a3, v7);
          result = v17;
          break;
        case 3:
          v13 = (char *)(*(_DWORD *)(a1 + 56) + 69);
          v14 = v7;
          do
          {
            v15 = *v13;
            *v14++ = *v13++;
          }
          while ( v15 );
          sub_10017C80(a1, v5, a3, v7);
          result = v17;
          break;
        default:
          goto LABEL_18;
      }
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v16 = *(_DWORD *)(a1 + 56), *(_WORD *)(v16 + 240) != -128) )
        sub_10017C80(a1, v5, a3, (char *)(v16 + 69));
      else
        sub_10017C80(a1, v5, a3, v7);
      v17 = 2;
      goto LABEL_18;
    default:
LABEL_18:
      result = v17;
      break;
  }
  return result;
}

//----- (10018330) --------------------------------------------------------
char __cdecl sub_10018330(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // cx@4
  unsigned int v7; // eax@4
  __int16 v8; // cx@4
  int v9; // eax@4
  int v10; // ecx@8
  __int16 v11; // bp@8
  __int16 *v12; // ebx@9
  char v13; // dl@10
  __int16 v14; // ax@14
  __int16 v15; // cx@16
  int v16; // [sp+4h] [bp-14h]@9
  __int16 v17; // [sp+8h] [bp-10h]@4
  __int16 v18; // [sp+Ch] [bp-Ch]@4
  __int16 v19; // [sp+Eh] [bp-Ah]@4
  __int16 v20; // [sp+10h] [bp-8h]@4
  __int16 v21; // [sp+12h] [bp-6h]@4
  __int16 v22; // [sp+14h] [bp-4h]@4
  __int16 v23; // [sp+16h] [bp-2h]@4
  int v24; // [sp+2Ch] [bp+14h]@9

  result = 1;
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return result;
  }
  v18 = word_101A1BD8[1];
  v19 = word_101A1BD8[0];
  v20 = word_101A1BD8[0];
  v21 = word_101A1BD8[0];
  v22 = word_101A1BD8[0];
  v6 = word_101A1BD8[(unsigned __int8)sub_10047CF0(15)];
  v7 = *(_WORD *)(a2 + 8);
  v23 = v6;
  v8 = v7;
  v9 = ((v7 >> 12) & 3) + 1;
  *(_WORD *)(a1 + 426) = v9;
  *(_WORD *)(a1 + 424) = v9;
  v17 = v8 & 0xC00;
  if ( (*(_WORD *)(a2 + 8) & 0xC000) == -32768 )
  {
    *(_WORD *)(a1 + 398) = 1;
    *(_DWORD *)(a1 + 452) = &unk_1008C1B0;
    *(_WORD *)(a1 + 440) = 0;
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 398) = 3;
  }
  v10 = 3 - v9;
  v11 = 0;
  if ( 3 - v9 < 3 )
  {
    v24 = v10 + 1;
    v12 = &v18 + 2 * v10;
    v16 = 3 - v10;
    do
    {
      v13 = 2;
      if ( v24 >= 3 && (*(_WORD *)(a2 + 8) & 0xC000) != 0x4000 )
        v13 = 3;
      if ( v17 == 2048 )
      {
        *(_WORD *)(a1 + 428) = *(_WORD *)a4;
        v14 = *(_WORD *)a4;
      }
      else
      {
        if ( v17 )
        {
          v15 = v12[1];
          v14 = *v12;
        }
        else
        {
          v15 = *v12;
          v14 = v12[1];
        }
        *(_WORD *)(a1 + 428) = v15;
      }
      *(_WORD *)(a1 + 430) = v14;
      sub_1006E530(
        a1 + 392,
        v11 + *(_WORD *)a3,
        v11 + *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 4) - 2 * v11,
        *(_WORD *)(a2 + 6) - 2 * v11,
        v13);
      ++v24;
      v12 += 2;
      ++v11;
      --v16;
    }
    while ( v16 );
  }
  return 2;
}
// 101A1BD8: using guessed type __int16 word_101A1BD8[];

//----- (10018560) --------------------------------------------------------
char __cdecl sub_10018560(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // ST10_1@2
  __int16 v8; // cx@2
  __int16 v9; // ax@2
  __int16 v11; // [sp+10h] [bp-14h]@4
  __int16 v12; // [sp+12h] [bp-12h]@4
  int v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+18h] [bp-Ch]@1
  int v15; // [sp+1Ch] [bp-8h]@1

  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v14 = v6;
  v15 = v5;
  if ( (_WORD)v5 == -1 )
  {
    v7 = *a4 & 0x1F;
    LOWORD(v15) = *(_WORD *)a4;
    v8 = word_101A1BD8[(unsigned __int8)sub_10047CF0(v7)];
    v9 = word_101A1BD8[((unsigned int)*(_WORD *)a4 >> 5) & 0x1F];
  }
  else
  {
    v8 = word_101A1BD8[(unsigned __int8)sub_10047CF0(v5 & 0x1F)];
    v9 = word_101A1BD8[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  }
  v11 = v8;
  v12 = v9;
  return sub_10018330(a1, (int)&v13, a3, (int)&v11, a5);
}
// 101A1BD8: using guessed type __int16 word_101A1BD8[];

//----- (10018640) --------------------------------------------------------
int __cdecl sub_10018640(unsigned int a1, char a2, int a3, int a4)
{
  int result; // eax@1

  result = a3 * byte_102D21F1[20 * ((a1 >> 10) & 0xF)]
         + (a3 - 1) * *(_WORD *)(dword_102D21E4[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a2 & 0x80 )
      result += *((_BYTE *)&unk_102D21E0 + 20 * ((a1 >> 10) & 0xF) + 15) - byte_102D21F1[20 * ((a1 >> 10) & 0xF)];
  }
  return result;
}
// 102D21E4: using guessed type int dword_102D21E4[];

//----- (100186A0) --------------------------------------------------------
char __cdecl sub_100186A0(int a1, int a2, int a3, double *a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  unsigned int v6; // ecx@1
  int v7; // eax@1
  __int16 v8; // bx@1
  double v9; // st7@3
  __int16 v10; // cx@5
  __int16 v11; // cx@5
  int v12; // ebx@8
  size_t v13; // edi@9
  int v14; // eax@9
  int v15; // edx@14
  __int16 v16; // ax@14
  float v17; // ST4C_4@20
  char *v18; // edi@27
  char v19; // al@28
  char *v20; // edi@30
  char v21; // al@31
  char v22; // al@33
  char *v23; // eax@35
  char v24; // cl@36
  signed int v25; // ecx@37
  char v26; // cl@38
  int v27; // ecx@40
  int v28; // edi@43
  int i; // eax@47
  char v30; // dl@50
  signed int v31; // ecx@52
  char v32; // al@53
  int v33; // eax@63
  signed int v34; // ebx@69
  signed int v35; // eax@69
  unsigned int v36; // ST18_4@71
  char *v37; // eax@71
  int v38; // edi@80
  unsigned int v39; // ebx@80
  __int16 v40; // ax@80
  bool v42; // [sp+2Fh] [bp-59h]@21
  int v43; // [sp+30h] [bp-58h]@1
  int v44; // [sp+30h] [bp-58h]@14
  int v45; // [sp+34h] [bp-54h]@1
  char *v46; // [sp+38h] [bp-50h]@14
  char v47; // [sp+3Ch] [bp-4Ch]@71
  char v48; // [sp+3Dh] [bp-4Bh]@71
  char v49; // [sp+3Eh] [bp-4Ah]@71
  int v50; // [sp+40h] [bp-48h]@3
  int v51; // [sp+44h] [bp-44h]@1
  int v52; // [sp+48h] [bp-40h]@1
  int v53; // [sp+4Ch] [bp-3Ch]@1
  double v54; // [sp+50h] [bp-38h]@5
  char v55[2]; // [sp+58h] [bp-30h]@21
  char v56; // [sp+63h] [bp-25h]@12
  char v57; // [sp+64h] [bp-24h]@9
  char v58; // [sp+65h] [bp-23h]@64

  v4 = a2;
  v5 = *(_BYTE *)a2 == 89;
  v45 = *(_BYTE *)(a2 + 10);
  v6 = *(_WORD *)(a2 + 8);
  v53 = a1;
  v7 = *(_BYTE *)(a2 + 11);
  v8 = v6;
  v52 = a2;
  v51 = (unsigned __int16)v6;
  v43 = v7;
  if ( v5 && 9.899999762399947e24 != *a4 )
  {
    *(float *)&v50 = *a4;
    v9 = sub_100419A0(v50, v6);
  }
  else
  {
    *(float *)&v50 = 9.8999998e24;
    v9 = *a4;
  }
  v10 = *(_WORD *)(a2 + 8);
  v54 = v9;
  v11 = v10 & 0x3F;
  if ( v11 == 28 )
  {
    if ( v9 > 1.0 || v9 < 0.0 )
    {
LABEL_8:
      v12 = v53;
LABEL_9:
      v13 = *(_BYTE *)(v4 + 10);
      memset(&v57, 95, v13);
      v14 = v43;
      if ( v43 > 0 )
      {
        if ( (signed int)(v13 - v43) <= 1 )
          v14 = v13 - 2;
        *(&v56 + v13 - v14) = 46;
      }
      *(&v57 + v13) = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( v9 >= 1.0e25 )
      goto LABEL_8;
    if ( v9 <= -1.0e25 )
      goto LABEL_8;
    if ( 9.899999762399947e24 == v9 )
      goto LABEL_8;
    v17 = v9;
    if ( v17 == 9.8999998e24 )
      goto LABEL_8;
  }
  v42 = 1;
  strcpy(v55, "%");
  if ( v8 & 0x800 || v8 & 0x40 || v11 == 27 || v11 == 28 )
  {
    ++v45;
    v18 = (char *)&v54 + 7;
    do
      v19 = (v18++)[1];
    while ( v19 );
    *(_WORD *)v18 = 43;
  }
  else if ( v11 == 7 )
  {
    ++v45;
  }
  v20 = (char *)&v54 + 7;
  if ( v8 & 0x100 )
  {
    do
      v21 = (v20++)[1];
    while ( v21 );
    *(_WORD *)v20 = 48;
  }
  else
  {
    do
      v22 = (v20++)[1];
    while ( v22 );
    *(_WORD *)v20 = 45;
  }
  v23 = (char *)&v54 + 7;
  if ( v11 == 7 )
  {
    do
      v24 = (v23++)[1];
    while ( v24 );
    v25 = 1697263146;
  }
  else
  {
    do
      v26 = (v23++)[1];
    while ( v26 );
    v25 = 1714040362;
  }
  *(_DWORD *)v23 = v25;
  v27 = *(_BYTE *)(a2 + 10);
  v23[4] = 0;
  v12 = _snprintf(&v57, 0x1Eu, v55, v27, *(_BYTE *)(a2 + 11), LODWORD(v9), (_DWORD)(*(unsigned __int64 *)&v9 >> 32));
  if ( v12 > v45 )
  {
    v42 = 0;
    if ( !(v51 & 0x80) && v43 > 0 )
    {
      v28 = v43;
      do
      {
        if ( v42 )
          break;
        v12 = sprintf(&v57, v55, *(_BYTE *)(a2 + 10), --v28, v54);
        v42 = v12 <= v45;
      }
      while ( v28 > 0 );
      v43 = v28;
    }
  }
  for ( i = v12 - 1; i >= 0; --i )
  {
    if ( *(&v57 + i) != 32 )
      break;
    *(&v57 + i) = 0;
    --v12;
  }
  v30 = 1;
  if ( v57 == 45 || v57 == 43 )
  {
    v31 = 1;
    if ( v12 <= 1 )
      goto LABEL_89;
    do
    {
      v32 = *(&v57 + v31);
      if ( v32 != 46 && v32 != 48 && v32 != 101 && v32 != 43 )
      {
        v30 = 0;
        v31 = v12;
      }
      ++v31;
    }
    while ( v31 < v12 );
    if ( v30 )
    {
LABEL_89:
      if ( (*(_WORD *)(a2 + 8) & 0x3F) == 17 && *(_WORD *)(a2 + 8) & 0x40 )
      {
        v57 = 43;
      }
      else
      {
        --v12;
        v33 = 0;
        if ( v12 > 0 )
        {
          qmemcpy(&v57, &v58, v12);
          v4 = v52;
          v33 = v12;
        }
        *(&v57 + v33) = 0;
      }
    }
  }
  if ( !v42 )
    goto LABEL_9;
LABEL_14:
  v46 = (char *)sub_1003E420(*(_WORD *)(v4 + 8), (float *)&v50);
  v15 = (signed __int16)sub_10022990(*(_DWORD *)(v4 + 4), *(_WORD *)(v4 + 8), (float *)&v50);
  v16 = *(_WORD *)(v4 + 8) & 0x3F;
  v44 = v15;
  if ( v16 == 27 )
  {
    if ( v57 == 45 )
    {
      v57 = -100;
    }
    else if ( v57 == 43 )
    {
      --v45;
      v34 = v12 - 1;
      v35 = 0;
      if ( v34 > 0 )
      {
        qmemcpy(&v57, &v58, v34);
        v4 = v52;
        v35 = v34;
      }
      *(&v57 + v35) = 0;
      v36 = *(_DWORD *)(v4 + 4);
      v47 = *v46;
      v48 = -99;
      v49 = 0;
      v46 = &v47;
      v37 = sub_10022300(v36);
      v44 += sub_1006D900(*((_DWORD *)v37 + 1), "", 0);
    }
  }
  else if ( v16 == 28 && !strncmp(&v57, "+0.", 3u) )
  {
    strncpy(&v57, "M ", 2u);
  }
  if ( v51 & 0x800 )
  {
    if ( v57 == 45 )
    {
      v57 = -92;
    }
    else if ( v57 == 43 )
    {
      v57 = -93;
    }
  }
  v38 = v53;
  *(_WORD *)(v53 + 438) = *(_WORD *)a3;
  *(_WORD *)(v38 + 436) = *(_WORD *)(a3 + 2);
  v39 = *(_DWORD *)(v4 + 4);
  v40 = *(_WORD *)(v4 + 12);
  if ( (*(_DWORD *)(v4 + 4) & 0xC000) != 0x4000 )
  {
    if ( ~(unsigned __int8)(*(_WORD *)(v4 + 8) >> 9) & 1 )
    {
      v40 -= v44;
      if ( v44 > 0 )
        v40 -= *(_WORD *)(dword_102D21E4[5 * ((v39 >> 10) & 0xF)] + 28);
    }
  }
  if ( !*(_WORD *)(v4 + 12) )
    v40 = sub_10018640(v39, *(_WORD *)(v4 + 8), v45, *(_BYTE *)(v4 + 11));
  return sub_10022FF0(v38, &v57, v46, v40, v44, v39, v51);
}
// 100897F0: using guessed type __int16 word_100897F0;
// 102D21E4: using guessed type int dword_102D21E4[];

//----- (10018BA0) --------------------------------------------------------
char __usercall sub_10018BA0@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4)
{
  int v4; // ebp@1
  double v5; // st7@4
  double v6; // st7@6
  __int16 v7; // ax@6
  const char *v8; // esi@8
  int v10; // [sp+14h] [bp+4h]@6
  float v11; // [sp+14h] [bp+4h]@12

  v4 = a4;
  if ( *a1 >= 1.0e25 || *a1 <= -1.0e25 || 9.8999998e24 == *a1 )
    v5 = 0.0;
  else
    v5 = *a1;
  *(float *)&v10 = v5;
  v6 = sub_100419A0(v10, *(_WORD *)(a2 + 8));
  v7 = *(_WORD *)(a2 + 8);
  if ( v7 & 0x40 )
  {
    if ( (v7 & 0x3F) == 7 )
      v8 = "%+0*.*e";
    else
      v8 = "%+0*.*f";
  }
  else
  {
    v8 = "%0*.*e";
    if ( (v7 & 0x3F) != 7 )
      v8 = "%0*.*f";
  }
  v11 = v6;
  if ( sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), v11) > a3 )
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), 0.0);
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = 0;
  return 4;
}

//----- (10018C80) --------------------------------------------------------
char __usercall sub_10018C80@<al>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi@1
  __int16 v5; // ax@1
  int v6; // edi@1
  __int16 v7; // ax@2
  int v8; // ecx@8
  const char *v9; // ecx@11
  char v10; // bl@11
  char *v11; // eax@11
  char v12; // dl@11
  char v13; // cl@12
  const char *v14; // edx@14
  char *v15; // eax@14
  char v16; // di@14
  char v17; // cl@15
  char v18; // bl@16
  char *v19; // eax@16
  char v20; // dl@16
  char v21; // cl@17
  unsigned __int16 v22; // ax@20
  int v23; // ecx@22
  signed __int16 v24; // di@22
  char *v25; // eax@25
  char v26; // dl@26
  char v27; // bl@27
  char *v28; // eax@27
  char v29; // dl@27
  char v30; // cl@28
  int v31; // ecx@32
  unsigned __int8 v32; // al@32
  char *v33; // eax@36
  char v34; // dl@37
  char v35; // bl@38
  char *v36; // eax@38
  char v37; // dl@38
  char v38; // cl@39
  const char *v39; // ecx@42
  char v40; // bl@42
  char *v41; // eax@42
  char v42; // dl@42
  char v43; // cl@43
  int v44; // eax@47
  unsigned __int16 v45; // ax@53
  const char *v46; // ecx@59
  char v47; // bl@59
  char *v48; // eax@59
  char v49; // dl@59
  char v50; // cl@60
  int v51; // edx@62
  char v52; // al@64
  int v53; // ebp@64
  bool v54; // zf@71
  bool v55; // sf@71
  char *v56; // eax@72
  int v57; // edi@72
  char v58; // dl@73
  char v59; // bl@74
  char *v60; // eax@74
  char v61; // dl@74
  char v62; // cl@75
  int v63; // ecx@81
  unsigned __int8 v64; // al@81
  char *v65; // eax@85
  char v66; // dl@86
  char v67; // bl@87
  char *v68; // eax@87
  char v69; // dl@87
  char v70; // cl@88
  const char *v71; // ecx@93
  char v72; // kr00_1@93
  char *v73; // eax@93
  char v74; // dl@93
  char v75; // cl@94
  signed int v76; // eax@96
  char *v77; // eax@104
  int v78; // edi@104
  char v79; // dl@105
  char v80; // bl@106
  char *v81; // eax@106
  char v82; // dl@106
  char v83; // cl@107
  char *v84; // eax@116
  int v85; // edi@116
  char v86; // dl@117
  char v87; // bl@118
  char *v88; // eax@118
  char v89; // dl@118
  char v90; // cl@119
  char *v91; // eax@122
  int v92; // edi@122
  char v93; // dl@123
  char v94; // bl@124
  char *v95; // eax@124
  char v96; // dl@124
  char v97; // cl@125
  int v98; // ecx@126
  const char *v99; // edx@127
  char *v100; // eax@127
  char v101; // di@127
  char v102; // cl@128
  char v103; // bl@129
  char *v104; // eax@129
  char v105; // di@129
  char v106; // cl@130
  char *v107; // eax@131
  int v108; // ecx@131
  char v109; // dl@132
  char v110; // bl@133
  char *v111; // eax@133
  char v112; // dl@133
  char v113; // cl@134
  int v114; // ebp@142
  int v115; // ecx@147
  const char *v116; // edx@152
  char *v117; // eax@152
  char v118; // di@152
  char v119; // cl@153
  char v120; // bl@154
  char *v121; // eax@154
  char v122; // dl@154
  char v123; // cl@155
  int v124; // edx@158
  signed int v125; // eax@158
  char *v126; // eax@165
  int v127; // edi@165
  char v128; // dl@166
  char v129; // bl@167
  char *v130; // eax@167
  char v131; // dl@167
  char v132; // cl@168
  int v133; // eax@170
  char v135; // [sp+1Bh] [bp-Dh]@1
  float v136; // [sp+1Ch] [bp-Ch]@1
  char *v137; // [sp+20h] [bp-8h]@3
  int v138; // [sp+24h] [bp-4h]@1
  __int32 v139; // [sp+2Ch] [bp+4h]@71
  float v140; // [sp+2Ch] [bp+4h]@76

  v4 = a1;
  v136 = 0.0;
  v5 = *(_WORD *)(a2 + 8);
  v6 = a4;
  v135 = 1;
  v138 = 1;
  if ( v5 & 0x40 )
  {
    v7 = v5 & 0x3F;
    if ( v7 == 7 )
      v137 = "%+0*.*e";
    else
      v137 = "%+0*.*f";
  }
  else
  {
    v7 = v5 & 0x3F;
    v137 = "%0*.*e";
    if ( v7 != 7 )
      v137 = "%0*.*f";
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
  {
    v8 = *(_DWORD *)(v4 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
    {
      *(_WORD *)(a4 + 14) = 45;
    }
    else
    {
      if ( v7 != 7 )
        goto LABEL_176;
      v9 = (const char *)(v8 + 69);
      v10 = strlen(v9);
      v11 = strchr(v9, 101);
      v12 = (_BYTE)v11 + 1;
      do
        v13 = *v11++;
      while ( v13 );
      v8 = *(_DWORD *)(v4 + 56);
      if ( *(_WORD *)(v8 + 240) <= (signed __int16)(char)(v10 - ((_BYTE)v11 - v12)) )
      {
LABEL_176:
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
      }
      else
      {
        v14 = (const char *)(v8 + 69);
        v15 = (char *)(v8 + 69);
        v16 = v8 + 70;
        do
          v17 = *v15++;
        while ( v17 );
        v18 = (_BYTE)v15 - v16;
        v19 = strchr(v14, 101);
        v20 = (_BYTE)v19 + 1;
        do
          v21 = *v19++;
        while ( v21 );
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)((char)(v18 - ((_BYTE)v19 - v20)) + *(_DWORD *)(v4 + 56) + 70) == 43) + 43;
      }
    }
  }
  v22 = *(_WORD *)(v6 + 14);
  if ( v22 < 0x30u || v22 > 0x39u )
  {
    if ( (*(_WORD *)(a2 + 8) & 0x3F) != 7 || v22 != 69 )
    {
      if ( (v22 == 43 || v22 == 45) && (sub_1003E3E0(*(_WORD *)(a2 + 8)) || *(_BYTE *)(a2 + 8) & 0x40) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        {
          sub_10018BA0(&v136, a2, a3, v4);
          if ( *(_BYTE *)(a2 + 11) )
          {
            v84 = (char *)(*(_DWORD *)(v4 + 56) + 69);
            v85 = *(_DWORD *)(v4 + 56) + 70;
            do
              v86 = *v84++;
            while ( v86 );
            v87 = (_BYTE)v84 - v85;
            v88 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
            v89 = (_BYTE)v88 + 1;
            do
              v90 = *v88++;
            while ( v90 );
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v87 - ((_BYTE)v88 - v89)) - 1;
          }
          else
          {
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
          }
        }
        if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 )
          goto LABEL_177;
        v91 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v92 = *(_DWORD *)(v4 + 56) + 70;
        do
          v93 = *v91++;
        while ( v93 );
        v94 = (_BYTE)v91 - v92;
        v95 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
        v96 = (_BYTE)v95 + 1;
        do
          v97 = *v95++;
        while ( v97 );
        v98 = *(_DWORD *)(v4 + 56);
        if ( *(_WORD *)(v98 + 240) <= (signed __int16)(char)(v94 - ((_BYTE)v95 - v96)) )
        {
LABEL_177:
          if ( (*(_WORD *)(a4 + 14) != 45 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) < 0.0)
            && (*(_WORD *)(a4 + 14) != 43 || atof((const char *)(*(_DWORD *)(v4 + 56) + 69)) > 0.0) )
          {
            v114 = a2;
          }
          else
          {
            v114 = a2;
            if ( *(_BYTE *)(a2 + 8) & 0x40 || *(_WORD *)(a4 + 14) == 45 )
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
            }
            else
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 48;
              v135 = 2;
            }
          }
          v115 = *(_DWORD *)(v4 + 56);
          if ( !*(_WORD *)(v115 + 240)
            && (*(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 43
             || *(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 45
             || (*(_BYTE *)(v114 + 8) & 0x3F) == 7) )
          {
            if ( (*(_BYTE *)(v114 + 8) & 0x3F) == 7 )
            {
              v116 = (const char *)(v115 + 69);
              v117 = (char *)(v115 + 69);
              v118 = v115 + 70;
              do
                v119 = *v117++;
              while ( v119 );
              v120 = (_BYTE)v117 - v118;
              v121 = strchr(v116, 46);
              v122 = (_BYTE)v121 + 1;
              do
                v123 = *v121++;
              while ( v123 );
              *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v120 - ((_BYTE)v121 - v122)) - 1;
            }
            else
            {
              ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
            }
            v124 = *(_DWORD *)(v4 + 56);
            v125 = a3 - (((unsigned int)*(_WORD *)(v114 + 8) >> 13) & 3) - 1;
            if ( *(_WORD *)(v124 + 240) < v125 )
              LOWORD(v125) = *(_WORD *)(v124 + 240);
            *(_WORD *)(v124 + 240) = (char)v125;
          }
        }
        else
        {
          v99 = (const char *)(v98 + 69);
          v100 = (char *)(v98 + 69);
          v101 = v98 + 70;
          do
            v102 = *v100++;
          while ( v102 );
          v103 = (_BYTE)v100 - v101;
          v104 = strchr(v99, 101);
          v105 = (_BYTE)v104 + 1;
          do
            v106 = *v104++;
          while ( v106 );
          *(_BYTE *)((char)(v103 - ((_BYTE)v104 - v105)) + *(_DWORD *)(v4 + 56) + 70) = *(_BYTE *)(a4 + 14);
          v107 = (char *)(*(_DWORD *)(v4 + 56) + 69);
          v108 = *(_DWORD *)(v4 + 56) + 70;
          do
            v109 = *v107++;
          while ( v109 );
          v110 = (_BYTE)v107 - v108;
          v111 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
          v112 = (_BYTE)v111 + 1;
          do
            v113 = *v111++;
          while ( v113 );
          if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == (char)(v110 - ((_BYTE)v111 - v112)) + 1 )
            ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
          v135 = 2;
        }
      }
      else if ( *(_WORD *)(v6 + 14) == 46 && *(_BYTE *)(a2 + 11) > 0 )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
          sub_10018BA0(&v136, a2, a3, v4);
        v126 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v127 = *(_DWORD *)(v4 + 56) + 70;
        do
          v128 = *v126++;
        while ( v128 );
        v129 = (_BYTE)v126 - v127;
        v130 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v131 = (_BYTE)v130 + 1;
        do
          v132 = *v130++;
        while ( v132 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v129 - ((_BYTE)v130 - v131)) + 1;
      }
    }
    else
    {
      if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        sub_10018BA0(&v136, a2, a3, v4);
      v77 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v78 = *(_DWORD *)(v4 + 56) + 70;
      do
        v79 = *v77++;
      while ( v79 );
      v80 = (_BYTE)v77 - v78;
      v81 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
      v82 = (_BYTE)v81 + 1;
      do
        v83 = *v81++;
      while ( v83 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v80 - ((_BYTE)v81 - v82)) + 1;
      v135 = 2;
    }
    goto LABEL_170;
  }
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( v24 == -128 )
  {
    sub_10018BA0(&v136, a2, a3, v4);
    if ( *(_BYTE *)(a2 + 11) )
    {
      v25 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      do
        v26 = *v25++;
      while ( v26 );
      v27 = (_BYTE)v25 - (*(_BYTE *)(v4 + 56) + 70);
      v28 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v29 = (_BYTE)v28 + 1;
      do
        v30 = *v28++;
      while ( v30 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v27 - ((_BYTE)v28 - v29)) - 1;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
    }
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_BYTE *)(a2 + 11) > 0 )
    {
      if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7
        || (v31 = *(_DWORD *)(v4 + 56), v32 = *(_BYTE *)(v31 + 69), v32 > 0x30u)
        || (v32 == 43 || v32 == 45) && *(_BYTE *)(v31 + 70) != 48 )
      {
        v33 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        do
          v34 = *v33++;
        while ( v34 );
        v35 = (_BYTE)v33 - (*(_BYTE *)(v4 + 56) + 70);
        v36 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v37 = (_BYTE)v36 + 1;
        do
          v38 = *v36++;
        while ( v38 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v35 - ((_BYTE)v36 - v37)) + 1;
        v135 = 2;
        goto LABEL_170;
      }
    }
LABEL_99:
    v135 = 2;
    goto LABEL_170;
  }
  if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
  {
    v39 = (const char *)(v23 + 69);
    v40 = strlen(v39);
    v41 = strchr(v39, 101);
    v42 = (_BYTE)v41 + 1;
    do
      v43 = *v41++;
    while ( v43 );
    v23 = *(_DWORD *)(v4 + 56);
    v24 = *(_WORD *)(v23 + 240);
    if ( v24 > (char)(v40 - ((_BYTE)v41 - v42)) )
    {
      if ( a3 - v24 != 2 )
      {
        if ( a3 - v24 != 3 )
        {
          v44 = *(_DWORD *)(v4 + 56);
          if ( a3 - v24 != 4 )
          {
            if ( *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 68) < 0x33u || *(_WORD *)(a4 + 14) < 0x38u )
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
              goto LABEL_170;
            }
            goto LABEL_99;
          }
          ++*(_WORD *)(v44 + 240);
        }
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
      }
      v45 = *(_WORD *)(a4 + 14);
      if ( v45 >= 0x30u
        && v45 <= 0x33u
        && (*(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 70) < 0x38u || v45 < 0x33u) )
      {
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
        v135 = 2;
        goto LABEL_170;
      }
      goto LABEL_99;
    }
  }
  if ( *(_BYTE *)(a2 + 11) <= 0 )
    goto LABEL_178;
  v46 = (const char *)(v23 + 69);
  v47 = strlen(v46);
  v48 = strchr(v46, 46);
  v49 = (_BYTE)v48 + 1;
  do
    v50 = *v48++;
  while ( v50 );
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( *(_WORD *)(v23 + 240) != (char)(v47 - ((_BYTE)v48 - v49)) - 1 )
  {
LABEL_178:
    v51 = a2;
    if ( !*(_BYTE *)(a2 + 11) )
    {
      if ( v24 == a3 - (((unsigned int)*(_WORD *)(a2 + 8) >> 13) & 3) - 1 )
        goto LABEL_64;
      v51 = a2;
    }
    if ( (*(_BYTE *)(v51 + 8) & 0x3F) == 7 && !v24 )
    {
      v71 = (const char *)(v23 + 69);
      v72 = strlen(v71);
      v73 = strchr(v71, 46);
      v74 = (_BYTE)v73 + 1;
      do
        v75 = *v73++;
      while ( v75 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v72 - ((_BYTE)v73 - v74)) - 1;
      v51 = a2;
    }
    *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    v76 = a3 - (((unsigned int)*(_WORD *)(v51 + 8) >> 13) & 3) - 1;
    if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) < v76 )
      LOWORD(v76) = *(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)v76;
    goto LABEL_99;
  }
LABEL_64:
  v52 = *(_BYTE *)(v23 + 69);
  v53 = a2;
  if ( v52 == 48 && (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || (v52 == 43 || v52 == 45) && *(_BYTE *)(v23 + 70) == 48 )
  {
    if ( v52 == 45 )
    {
      *(_BYTE *)(v23 + 69) = 48;
      v138 = -1;
    }
    v139 = j__atol((const char *)(*(_DWORD *)(v4 + 56) + 69));
    v54 = *(_BYTE *)(v53 + 11) == 0;
    v55 = *(_BYTE *)(v53 + 11) < 0;
    v136 = (double)v139 * 10.0;
    if ( !v55 && !v54 )
    {
      v56 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v57 = *(_DWORD *)(v4 + 56) + 70;
      do
        v58 = *v56++;
      while ( v58 );
      v59 = (_BYTE)v56 - v57;
      v60 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v61 = (_BYTE)v60 + 1;
      do
        v62 = *v60++;
      while ( v62 );
      v140 = atof((const char *)((char)(v59 - ((_BYTE)v60 - v61)) + *(_DWORD *)(v4 + 56) + 69));
      v136 = v140 + v136;
    }
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v137, a3, *(_BYTE *)(v53 + 11), v136);
    if ( v138 == -1 )
      *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 45;
  }
  *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
  if ( *(_BYTE *)(v53 + 11) <= 0 )
    goto LABEL_99;
  if ( (*(_BYTE *)(v53 + 8) & 0x3F) != 7 )
  {
    v63 = *(_DWORD *)(v4 + 56);
    v64 = *(_BYTE *)(v63 + 69);
    if ( v64 <= 0x30u && (v64 != 43 && v64 != 45 || *(_BYTE *)(v63 + 70) == 48) )
      goto LABEL_99;
  }
  v65 = (char *)(*(_DWORD *)(v4 + 56) + 69);
  do
    v66 = *v65++;
  while ( v66 );
  v67 = (_BYTE)v65 - (*(_BYTE *)(v4 + 56) + 70);
  v68 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) + 1;
  v135 = 2;
LABEL_170:
  v133 = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 101 || *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return v135;
}

//----- (10019750) --------------------------------------------------------
char __usercall sub_10019750@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5)
{
  float *v5; // edi@1
  __int16 v6; // ax@1
  unsigned int v7; // edi@1
  int v8; // ebp@1
  __int16 v9; // ax@1
  const char *v11; // [sp+8h] [bp-4h]@1

  v5 = a2;
  *(_WORD *)(a3 + 438) = *(_WORD *)a1;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a1 + 2);
  v11 = (const char *)sub_1003E420(*(_WORD *)(a4 + 8), a2);
  v6 = sub_10022990(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8), v5);
  v7 = *(_DWORD *)(a4 + 4);
  v8 = v6;
  v9 = *(_WORD *)(a4 + 12);
  if ( (*(_DWORD *)(a4 + 4) & 0xC000) != 0x4000 )
  {
    v9 -= v8;
    if ( v8 > 0 )
      v9 -= *(_WORD *)(dword_102D21E4[5 * ((v7 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a4 + 12) )
    v9 = sub_10018640(v7, *(_WORD *)(a4 + 8), a5, *(_BYTE *)(a4 + 11));
  return sub_10022FF0(a3, (char *)(*(_DWORD *)(a3 + 56) + 69), v11, v9, v8, v7, *(_WORD *)(a4 + 8));
}
// 102D21E4: using guessed type int dword_102D21E4[];

//----- (10019810) --------------------------------------------------------
char __usercall sub_10019810@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4)
{
  double v4; // st7@2
  double v6; // [sp+0h] [bp-8h]@4

  if ( 9.8999998e24 == *a2 )
    v4 = 9.899999762399947e24;
  else
    v4 = *a2;
  v6 = v4;
  return sub_100186A0(a3, a1, a4, &v6);
}

//----- (10019850) --------------------------------------------------------
char __cdecl sub_10019850(int a1, int a2, int *a3, float *a4, int a5)
{
  __int16 v5; // cx@2
  __int16 v6; // cx@4
  __int16 v7; // ax@9
  _WORD *v8; // esi@9
  unsigned int v9; // ebp@10
  int v10; // eax@10
  int v11; // edx@12
  __int16 v12; // ax@16
  int v13; // eax@17
  __int16 v14; // cx@17
  int v16; // eax@19
  signed __int16 v17; // si@19
  signed int v18; // eax@20
  char v19; // al@27
  char v20; // al@33
  __int16 v21; // ax@36
  signed int v22; // ecx@40
  int v23; // ecx@42
  int v24; // ecx@43
  int v25; // ecx@45
  int v26; // ecx@47
  int v27; // edi@49
  const char *v28; // eax@50
  char v29; // ST38_1@50
  bool v30; // zf@58
  bool v31; // sf@58
  int v32; // esi@65
  char v33; // dl@68
  bool v34; // zf@73
  bool v35; // sf@73
  bool v36; // zf@80
  bool v37; // sf@80
  char v38; // al@87
  int v39; // esi@94
  double v40; // st7@96
  int v41; // esi@101
  unsigned int v42; // edx@101
  __int16 v43; // bx@101
  unsigned __int8 v44; // cl@103
  int v45; // ecx@109
  _WORD *v46; // eax@109
  char v47; // dl@109
  char *v48; // eax@114
  int v49; // esi@114
  char v50; // dl@115
  char v51; // bl@116
  char *v52; // eax@116
  char v53; // dl@116
  char v54; // cl@117
  char v55; // cl@118
  int v56; // eax@118
  int v57; // edx@118
  char *v58; // eax@120
  int v59; // esi@120
  char v60; // dl@121
  char v61; // bl@122
  char *v62; // eax@122
  char v63; // dl@122
  char v64; // cl@123
  char v65; // cl@124
  int v66; // eax@124
  int v67; // edx@124
  char v68; // [sp-4h] [bp-2Ch]@64
  unsigned __int16 v69; // [sp+0h] [bp-28h]@64
  char v70; // [sp+4h] [bp-24h]@64
  char v71; // [sp+1Bh] [bp-Dh]@1
  size_t v72; // [sp+1Ch] [bp-Ch]@2
  unsigned int v73; // [sp+3Ch] [bp+14h]@50
  int v74; // [sp+3Ch] [bp+14h]@99

  v71 = 1;
  if ( *(_WORD *)a5 == -32703 )
  {
    v72 = 0;
  }
  else
  {
    v72 = *(_BYTE *)(a2 + 10);
    v5 = *(_WORD *)(a2 + 8);
    if ( v5 & 0x40 || *(_WORD *)(a2 + 8) & 0x800 || (v6 = v5 & 0x3F, v6 == 7) || v6 == 28 )
      ++v72;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v7 = *(_WORD *)(a2 + 12);
      v8 = (_WORD *)(a1 + 276);
      if ( v7 )
      {
        sub_10022E90(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v7);
      }
      else
      {
        v9 = *(_DWORD *)(a2 + 4);
        v10 = sub_10018640(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
        sub_10022E90((int)v8, *a3, v9, v10);
      }
      v11 = (signed __int16)sub_10022990(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v11 > 0 )
      {
        v12 = *(_WORD *)(dword_102D21E4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v11 + v12;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v13 = (v12 + v11 + 1) / 2;
          v14 = *(_WORD *)(a1 + 280) - v13;
          *v8 -= v13;
          *(_WORD *)(a1 + 280) = v14;
        }
      }
      return 2;
    case 0x8048:
      v16 = *(_DWORD *)(a1 + 56);
      v17 = *(_WORD *)(v16 + 240);
      if ( v17 == -128 )
      {
        v18 = *(_WORD *)(a5 + 10);
        if ( v18 > 84 )
        {
          if ( v18 != 0x2000 )
            return v71;
        }
        else if ( v18 != 84 )
        {
          if ( v18 == 32 )
          {
            if ( *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
              return v71;
            v71 = sub_10018BA0(a4, a2, v72, a1);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, v72);
            if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
            {
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 71) = 46;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 64) = 101;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 65) = 43;
            }
            else
            {
              v20 = *(_BYTE *)(a2 + 11);
              if ( v20 > 0 )
                *(_BYTE *)(*(_DWORD *)(a1 + 56) - v20 + v72 + 68) = 46;
            }
            goto LABEL_132;
          }
          if ( v18 != 56
            || *(_WORD *)(a2 + 8) & 0x400
            || (*(_WORD *)(a2 + 8) & 0x3F) == 27
            || *(_WORD *)(a2 + 8) & 0x800 )
          {
            return v71;
          }
          v19 = sub_10018BA0(a4, a2, v72, a1);
LABEL_131:
          v71 = v19;
LABEL_132:
          if ( v71 != 4 && v71 != 2 )
            return v71;
          goto LABEL_134;
        }
        v21 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v21 & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
          return v71;
        v19 = sub_10018C80(a1, a2, v72, a5);
        goto LABEL_131;
      }
      v22 = *(_WORD *)(a5 + 10);
      if ( v22 > 57 )
      {
        if ( v22 != 84 && v22 != 0x2000 )
          return v71;
        v19 = sub_10018C80(a1, a2, v72, a5);
        goto LABEL_131;
      }
      if ( v22 == 57 )
      {
        *(_WORD *)(v16 + 240) += *(_BYTE *)(a5 + 8);
        v41 = *(_DWORD *)(a1 + 56);
        v42 = *(_WORD *)(a2 + 8);
        v43 = *(_WORD *)(v41 + 240);
        v71 = 2;
        if ( v43 >= 0 )
        {
          v44 = *(_BYTE *)(a2 + 10);
          if ( v43 <= (signed int)(v44 - ((v42 >> 13) & 3) - 1) || v42 & 0x40 || (v42 & 0x3F) == 7 )
          {
            if ( v43 <= (signed int)v44 )
            {
              while ( 1 )
              {
                v45 = *(_DWORD *)(a1 + 56);
                v46 = (_WORD *)(v45 + 240);
                v47 = *(_BYTE *)(*(_WORD *)(v45 + 240) + v45 + 69);
                if ( v47 != 46 && v47 != 101 )
                {
                  if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || *(_WORD *)(v45 + 240) <= 0 )
                    break;
                  if ( !strchr((const char *)(v45 + 69), 46) )
                    goto LABEL_142;
                  v48 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                  v49 = *(_DWORD *)(a1 + 56) + 70;
                  do
                    v50 = *v48++;
                  while ( v50 );
                  v51 = (_BYTE)v48 - v49;
                  v52 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46);
                  v53 = (_BYTE)v52 + 1;
                  do
                    v54 = *v52++;
                  while ( v54 );
                  v55 = (_BYTE)v52 - v53;
                  v56 = *(_DWORD *)(a1 + 56);
                  v57 = *(_WORD *)(v56 + 240);
                  v46 = (_WORD *)(v56 + 240);
                  if ( v57 >= (char)(v51 - v55) - 1 )
                  {
LABEL_142:
                    if ( strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46) )
                      break;
                    v58 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                    v59 = *(_DWORD *)(a1 + 56) + 70;
                    do
                      v60 = *v58++;
                    while ( v60 );
                    v61 = (_BYTE)v58 - v59;
                    v62 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 101);
                    v63 = (_BYTE)v62 + 1;
                    do
                      v64 = *v62++;
                    while ( v64 );
                    v65 = (_BYTE)v62 - v63;
                    v66 = *(_DWORD *)(a1 + 56);
                    v67 = *(_WORD *)(v66 + 240);
                    v46 = (_WORD *)(v66 + 240);
                    if ( v67 >= (char)(v61 - v65) - 1 )
                      break;
                  }
                }
                if ( *(_BYTE *)(a5 + 8) <= 0 )
                  --*v46;
                else
                  ++*v46;
              }
            }
            else
            {
              *(_WORD *)(v41 + 240) = (char)v44;
            }
          }
          else
          {
            *(_WORD *)(v41 + 240) = (char)(v44 - ((v42 >> 13) & 3) - 1);
          }
        }
        else
        {
          *(_WORD *)(v41 + 240) = 0;
        }
        goto LABEL_134;
      }
      v23 = v22 - 32;
      if ( !v23 )
      {
        *(_WORD *)(v16 + 240) = -128;
        sub_10019810(a2, a4, a1, (int)a3);
        return 6;
      }
      v24 = v23 - 1;
      if ( v24 )
      {
        if ( v24 != 23 )
          return v71;
        v25 = *(_WORD *)(a2 + 8);
        if ( v25 & 0x40 && !v17 )
        {
          LOBYTE(v25) = *(_BYTE *)(v16 + 69) != 45;
          v26 = 2 * v25 + 43;
LABEL_48:
          *(_BYTE *)(v16 + 69) = v26;
          v71 = 2;
LABEL_134:
          sub_10019750((int)a3, a4, a1, a2, v72);
          return v71;
        }
        v27 = 2 * (*(_BYTE *)(a5 + 8) >= 0) - 1;
        if ( (v25 & 0x3F) != 7
          || (v28 = (const char *)(v16 + 69),
              v73 = strlen(v28),
              v29 = strlen(strchr(v28, 101)),
              v16 = *(_DWORD *)(a1 + 56),
              v17 = *(_WORD *)(v16 + 240),
              v17 <= (char)(v73 - v29))
          && v17 )
        {
          v38 = *(_BYTE *)(v17 + v16 + 69);
          if ( (v38 == 48 && v27 < 0 || v38 == 57 && v27 > 0) && !v17 && sub_1003E3E0(*(_WORD *)(a2 + 8)) )
          {
            *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
          v39 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69) = sub_10038380(
                                                           *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69),
                                                           0x10u,
                                                           v27);
        }
        else
        {
          if ( !v17 )
          {
            v71 = 2;
            *(_BYTE *)(v16 + 69) = *(_BYTE *)(v16 + 69) != 45 ? 45 : 48;
            goto LABEL_134;
          }
          if ( v72 - v17 == 2 )
          {
            v16 += v17;
            if ( *(_BYTE *)(v16 + 70) > 0x37u )
            {
              v34 = v27 == 0;
              v35 = v27 < 0;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 50;
                  v71 = 2;
                  goto LABEL_134;
                }
                v34 = v27 == 0;
                v35 = v27 < 0;
              }
              if ( !v35 && !v34 && *(_BYTE *)(v16 + 69) >= 0x32u )
              {
                *(_BYTE *)(v16 + 69) = 48;
                v71 = 2;
                goto LABEL_134;
              }
LABEL_64:
              v70 = v27;
              v69 = 16;
              v68 = *(_BYTE *)(v16 + 69);
LABEL_65:
              v32 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v32 + 240) + v32 + 69) = sub_10038380(v68, v69, v70);
              v71 = 2;
              goto LABEL_134;
            }
            v36 = v27 == 0;
            v37 = v27 < 0;
            if ( v27 < 0 )
            {
              if ( *(_BYTE *)(v16 + 69) == 48 )
              {
                *(_BYTE *)(v16 + 69) = 51;
                v71 = 2;
                goto LABEL_134;
              }
              v36 = v27 == 0;
              v37 = v27 < 0;
            }
            if ( !v37 && !v36 && *(_BYTE *)(v16 + 69) >= 0x33u )
            {
              *(_BYTE *)(v16 + 69) = 48;
              v71 = 2;
              goto LABEL_134;
            }
LABEL_66:
            v70 = v27;
            v69 = 16;
            v68 = *(_BYTE *)(v16 + 69);
            goto LABEL_65;
          }
          if ( v72 - v17 != 3 )
          {
            if ( v72 - v17 == 4 )
            {
              v71 = 2;
              *(_BYTE *)(v17 + v16 + 69) = 2 * (*(_BYTE *)(v17 + v16 + 69) != 45) + 43;
              goto LABEL_134;
            }
            v16 += v17;
            if ( *(_BYTE *)(v16 + 68) >= 0x33u )
            {
              v30 = v27 == 0;
              v31 = v27 < 0;
              LOBYTE(v26) = 48;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 55;
                  v71 = 2;
                  goto LABEL_134;
                }
                v30 = v27 == 0;
                v31 = v27 < 0;
              }
              if ( !v31 && !v30 && *(_BYTE *)(v16 + 69) >= 0x37u )
                goto LABEL_48;
              goto LABEL_64;
            }
            goto LABEL_66;
          }
          v33 = *(_BYTE *)(v17 + v16 + 69);
          if ( v33 == 45 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 43;
            v71 = 2;
            goto LABEL_134;
          }
          if ( v33 == 43 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
        }
        v71 = 2;
        goto LABEL_134;
      }
      *(_WORD *)(v16 + 240) = -128;
      v40 = atof((const char *)(*(_DWORD *)(a1 + 56) + 69));
      if ( v40 > 1.0e25 || v40 < -1.0e25 )
        v40 = 9.899999762399947e24;
      *(float *)&v74 = v40;
      *a4 = sub_10041FD0(v74, *(_WORD *)(a2 + 8));
      sub_10019810(a2, a4, a1, (int)a3);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_10019810(a2, a4, a1, (int)a3);
        return v71;
      }
      sub_10019750((int)a3, a4, a1, a2, v72);
      return 1;
    default:
      return v71;
  }
}
// 102D21E4: using guessed type int dword_102D21E4[];

//----- (1001A140) --------------------------------------------------------
char __cdecl sub_1001A140(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ecx@1
  char result; // al@1
  bool v7; // zf@2
  __int16 v8; // dx@3

  v5 = a4;
  result = 1;
  if ( *(_DWORD *)(a4 + 8) )
  {
    v7 = *(_BYTE *)a4 == 0;
    a4 = *a3;
    if ( !v7 )
    {
      v8 = *(_WORD *)(v5 + 4);
      if ( *(_BYTE *)(v5 + 1) )
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2) + a4;
        HIWORD(a4) += v8;
      }
      else
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2);
        HIWORD(a4) = v8;
      }
    }
    result = ((int (__cdecl *)(int, _DWORD, int *, _DWORD, int))dword_102D1B40[2 * (**(_DWORD **)(v5 + 8) & 0xFF)])(
               a1,
               *(_DWORD *)(v5 + 8),
               &a4,
               *(_DWORD *)(v5 + 12),
               a5);
  }
  return result;
}
// 102D1B40: using guessed type int dword_102D1B40[];

//----- (1001A1B0) --------------------------------------------------------
int __usercall sub_1001A1B0@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( a3 )
  {
    do
    {
      sub_1006E530(
        v5 + 392,
        v3,
        v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * v3,
        0);
      ++v3;
    }
    while ( v3 < a3 );
  }
  *(_WORD *)(v5 + 428) = word_101A1BD8[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 430) = word_101A1BD8[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 440) = word_101A1BD8[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 442) = word_101A1BD8[*(_BYTE *)(v4 + 4) & 0x1F];
  return sub_1006E530(
           v5 + 392,
           a3,
           a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * a3,
           1);
}
// 101A1BD8: using guessed type __int16 word_101A1BD8[];

//----- (1001A290) --------------------------------------------------------
char __cdecl sub_1001A290(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // bx@5
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // ebp@8
  int v10; // eax@10
  int v11; // eax@15
  int v12; // eax@15
  int v13; // eax@15
  int v14; // eax@17
  char v15; // al@19
  bool v16; // zf@19
  int v17; // eax@23
  int v18; // eax@28
  int v19; // esi@28

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( *(_DWORD *)(a1 + 64) == 9 )
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 248) = 1;
    v6 = word_101A1BD8[(unsigned __int8)sub_10047CF0(*(_BYTE *)(a2 + 4) & 0x1F)];
    v7 = *(_BYTE *)(a2 + 4) & 0xE0;
    if ( !(*(_BYTE *)(a2 + 4) & 0xE0) )
    {
      v17 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 428) = v6;
      *(_WORD *)(a1 + 430) = v6;
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v17 + 25)
        && (*(_WORD *)(v17 + 40) || *(_WORD *)(v17 + 42) || *(_WORD *)(v17 + 44) || *(_WORD *)(v17 + 46)) )
      {
        sub_1006E530(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 42), 1);
        sub_1006E530(
          a1 + 392,
          0,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v18 = *(_DWORD *)(a1 + 56);
        sub_1006E530(
          a1 + 392,
          *(_WORD *)(v18 + 44) + *(_WORD *)(v18 + 40),
          *(_WORD *)(v18 + 42),
          *(_WORD *)(v18 + 32) - *(_WORD *)(v18 + 40) - *(_WORD *)(v18 + 44),
          *(_WORD *)(v18 + 46),
          1);
        v19 = *(_DWORD *)(a1 + 56);
        sub_1006E530(
          a1 + 392,
          0,
          *(_WORD *)(v19 + 46) + *(_WORD *)(v19 + 42),
          *(_WORD *)(v19 + 32),
          *(_WORD *)(v19 + 34) - *(_WORD *)(v19 + 42) - *(_WORD *)(v19 + 46),
          1);
        return 2;
      }
      sub_1006E530(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 34), 1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      return 2;
    }
    if ( v7 == 32 )
    {
      *(_WORD *)(a1 + 428) = word_101A1BD8[(unsigned __int8)sub_10047CF0(15)];
      *(_WORD *)(a1 + 430) = word_101A1BD8[(unsigned __int8)sub_10047CF0(15)];
      *(_WORD *)(a1 + 440) = word_101A1BD8[(unsigned __int8)sub_10047CF0(15)];
      *(_WORD *)(a1 + 442) = word_101A1BD8[(unsigned __int8)sub_10047CF0(15)];
      sub_1001A1B0(a2, a1, 2u);
      return 2;
    }
    if ( v7 != 96 )
    {
      *(_WORD *)(a1 + 428) = word_101A1BD8[1];
      *(_WORD *)(a1 + 430) = word_101A1BD8[1];
      *(_WORD *)(a1 + 440) = word_101A1BD8[1];
      v8 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 442) = word_101A1BD8[1];
      sub_1006E530(a1 + 392, 0, 0, *(_WORD *)(v8 + 32), *(_WORD *)(v8 + 34), 1);
      *(_WORD *)(a1 + 428) = word_101A1BD8[15];
      *(_WORD *)(a1 + 430) = word_101A1BD8[14];
      sub_1006E530(a1 + 392, 0, 3, *(_WORD *)(*(_DWORD *)(a1 + 56) + 32), *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 6, 2);
      *(_WORD *)(a1 + 428) = word_101A1BD8[13];
      *(_WORD *)(a1 + 430) = word_101A1BD8[1];
      sub_1006E530(
        a1 + 392,
        1,
        4,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 8,
        2);
      *(_WORD *)(a1 + 428) = word_101A1BD8[14];
      *(_WORD *)(a1 + 430) = word_101A1BD8[12];
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      v9 = 2;
      do
      {
        sub_1006E530(
          a1 + 392,
          v9,
          v9 + 3,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2 * v9,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 2 * (v9 + 3),
          2);
        ++v9;
      }
      while ( v9 < 6 );
      v10 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v10 + 25)
        && (*(_WORD *)(v10 + 40) || *(_WORD *)(v10 + 42) || *(_WORD *)(v10 + 44) || *(_WORD *)(v10 + 46)) )
      {
        sub_1006E530(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 2);
        v11 = *(_DWORD *)(a1 + 56);
        *(_WORD *)(a1 + 428) = v6;
        *(_WORD *)(a1 + 430) = v6;
        sub_1006E530(a1 + 392, 6, 9, *(_WORD *)(v11 + 32) - 12, *(_WORD *)(v11 + 42) - 9, 1);
        sub_1006E530(
          a1 + 392,
          6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) - 6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v12 = *(_DWORD *)(a1 + 56);
        sub_1006E530(
          a1 + 392,
          *(_WORD *)(v12 + 44) + *(_WORD *)(v12 + 40),
          *(_WORD *)(v12 + 42),
          *(_WORD *)(v12 + 32) - *(_WORD *)(v12 + 40) - *(_WORD *)(v12 + 44) - 6,
          *(_WORD *)(v12 + 46),
          1);
        v13 = *(_DWORD *)(a1 + 56);
        sub_1006E530(
          a1 + 392,
          6,
          *(_WORD *)(v13 + 46) + *(_WORD *)(v13 + 42),
          *(_WORD *)(v13 + 32) - 12,
          *(_WORD *)(v13 + 34) - *(_WORD *)(v13 + 42) - *(_WORD *)(v13 + 46) - 9,
          1);
      }
      else
      {
        sub_1006E530(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 3);
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      }
      v14 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v14 + 247) )
      {
        *(_WORD *)(a1 + 428) = word_101A1BD8[15];
        *(_WORD *)(a1 + 430) = word_101A1BD8[15];
        *(_WORD *)(a1 + 440) = word_101A1BD8[1];
        *(_WORD *)(a1 + 442) = word_101A1BD8[1];
        sub_1006E530(a1 + 392, 10, 13, *(_WORD *)(v14 + 32) - 20, *(_WORD *)(v14 + 34) - 26, 3);
        return 2;
      }
      return 2;
    }
    *(_WORD *)(a1 + 428) = word_101A1BD8[(unsigned __int8)sub_10047CF0(15)];
    *(_WORD *)(a1 + 430) = word_101A1BD8[(unsigned __int8)sub_10047CF0(15)];
    *(_WORD *)(a1 + 440) = word_101A1BD8[(unsigned __int8)sub_10047CF0(15)];
    v15 = sub_10047CF0(15);
    v16 = (*(_BYTE *)(a1 + 22) & 0x1E) == 0;
    *(_WORD *)(a1 + 442) = word_101A1BD8[(unsigned __int8)v15];
    if ( v16 )
    {
      sub_1001A1B0(a2, a1, 2u);
      result = 2;
    }
    else
    {
      sub_1001A1B0(a2, a1, 5u);
      result = 2;
    }
  }
  return result;
}
// 101A1BD8: using guessed type __int16 word_101A1BD8[];

//----- (1001A840) --------------------------------------------------------
unsigned int __usercall sub_1001A840@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3)
{
  int v3; // edi@1
  int v4; // ST38_4@1
  int v5; // eax@1
  __int16 v6; // cx@1
  unsigned int result; // eax@1
  char v8; // [sp+Ch] [bp-204h]@1

  v3 = BMP_get_bm_def(*a3);
  v4 = *(_DWORD *)(a2 + 460);
  v5 = sub_10023F30(*a3, *(_BYTE *)(a2 + 3), (int)&v8);
  v6 = *(_WORD *)(a2 + 432);
  *(_DWORD *)(a2 + 460) = v5;
  result = sub_1006CC00(
             a2 + 392,
             v3,
             0,
             0,
             *(_WORD *)a1 + *(_WORD *)(a2 + 434),
             *(_WORD *)(a1 + 2) + v6,
             *(_WORD *)(v3 + 6),
             *(_WORD *)(v3 + 4));
  *(_DWORD *)(a2 + 460) = v4;
  return result;
}
// 1006CAD6: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (1001A8F0) --------------------------------------------------------
char __cdecl sub_1001A8F0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  int v6; // eax@8
  __int16 v7; // dx@8
  __int16 v8; // si@8

  result = 1;
  if ( *a5 == 32802 )
    goto LABEL_11;
  if ( *a5 == 32832 )
  {
    v6 = BMP_get_bm_def(*a4);
    v7 = *(_WORD *)(v6 + 6);
    v8 = *(_WORD *)(v6 + 4);
    *(_WORD *)(a1 + 276) = *(_WORD *)a3;
    *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 280) = v7 + *(_WORD *)a3 - 1;
    *(_WORD *)(a1 + 282) = v8 + *(_WORD *)(a3 + 2) - 1;
    return 2;
  }
  if ( *a5 == 32888 )
  {
LABEL_11:
    if ( *a4 != -1 )
      sub_1001A840(a3, a1, a4);
    result = 2;
  }
  return result;
}
// 1006CAD6: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (1001A990) --------------------------------------------------------
char __cdecl sub_1001A990(int a1, float a2, int a3)
{
  double v3; // st7@1
  signed int v4; // ebp@1
  int v5; // edi@1
  signed int v6; // eax@2
  int v7; // ebx@2
  int v8; // esi@2
  float v9; // ST20_4@4
  double v10; // st6@7
  int v11; // eax@7
  int v12; // edx@7
  int v13; // ecx@7
  float v15; // [sp+1Ch] [bp-8h]@1
  float *v16; // [sp+30h] [bp+Ch]@2

  v3 = 0.0;
  v15 = 0.0;
  v4 = 0;
  v5 = a3;
  if ( *(_BYTE *)a1 )
  {
    LOBYTE(v6) = a3 + 96;
    v16 = (float *)(a3 + 608);
    v7 = a1 + 12;
    v8 = v5 + 1264;
    do
    {
      if ( v4 >= 10 )
      {
        *(_BYTE *)(v5 + 1464) = *(_BYTE *)a1;
        return v6;
      }
      *(float *)(v8 + 8) = *(float *)(v5 + 1476) * a2;
      *(float *)v8 = *(float *)(v5 + 1468);
      *(float *)(v8 + 4) = *(float *)(v5 + 1472) - v15;
      v9 = sub_10038A30(*(float *)v7, v5 + 1488, *(_BYTE *)(v5 + 1584));
      ++v4;
      v7 += 4;
      v8 += 20;
      *(float *)(v8 - 8) = -(v9 - v15);
      *(_DWORD *)(v8 - 4) = *(_DWORD *)(v7 + 36);
      *(v16 - 1) = *(float *)(v7 - 4);
      *(_BYTE *)v16 = *(_BYTE *)(a1 + v4 + 91);
      v15 = v9;
      v16 += 2;
      v6 = *(_BYTE *)a1;
    }
    while ( v4 < v6 );
    if ( v4 < 10 )
    {
      v3 = 0.0;
      goto LABEL_7;
    }
    LOBYTE(v6) = *(_BYTE *)a1;
    *(_BYTE *)(v5 + 1464) = *(_BYTE *)a1;
  }
  else
  {
LABEL_7:
    v10 = 9.8999998e24;
    v11 = v5 + 20 * v4 + 1268;
    v12 = 10 - v4;
    v13 = v5 + 8 * v4 + 604;
    do
    {
      *(_DWORD *)(v11 + 12) = 0;
      *(float *)(v11 - 4) = v3;
      v11 += 20;
      *(float *)(v11 - 20) = v3;
      v13 += 8;
      --v12;
      *(float *)(v11 - 16) = v3;
      *(float *)(v11 - 12) = v3;
      *(_BYTE *)(v13 - 4) = 10;
      *(float *)(v13 - 8) = *(float *)&v10;
    }
    while ( v12 );
    LOBYTE(v6) = a1;
    *(_BYTE *)(v5 + 1464) = *(_BYTE *)a1;
  }
  return v6;
}

//----- (1001AAF0) --------------------------------------------------------
int __cdecl sub_1001AAF0(int a1, char a2, float a3, int a4)
{
  int result; // eax@1
  double v5; // st7@1
  double v6; // st6@1
  unsigned __int8 v7; // bl@1
  float *v8; // ebp@2
  int v9; // esi@4
  double v10; // ST2C_8@4
  double v11; // st6@4
  double v12; // st5@6
  int v13; // ecx@6
  int v14; // [sp+1Ch] [bp-Ch]@1
  float v15; // [sp+34h] [bp+Ch]@4

  result = (unsigned __int8)a2;
  v5 = 1.0;
  v6 = 0.5;
  v7 = LOBYTE(a3);
  v14 = 0;
  if ( (signed int)(unsigned __int8)a2 > 0 )
  {
    v8 = (float *)(a1 + 8);
    do
    {
      if ( v7 >= 0x32u )
        break;
      v9 = (v7 << 6) + a4;
      *(float *)(v9 + 1588) = *(float *)(a4 + 1468);
      v10 = *(float *)(a4 + 1472);
      v15 = v10 - sub_10038A30(*(v8 - 2), a4 + 1488, *(_BYTE *)(a4 + 1584));
      *(float *)(v9 + 1596) = v15;
      v11 = *(v8 - 1) * *(float *)(a4 + 1476);
      *(_DWORD *)(v9 + 1644) = -1;
      *(_BYTE *)(v9 + 1648) = 0;
      *(float *)(v9 + 1592) = v11 + *(float *)(v9 + 1588);
      *(float *)(((v7 + 25) << 6) + a4) = v15;
      *(float *)(v9 + 1604) = 1.0;
      sub_10038450(v9 + 1624, v8, 7);
      *(float *)(v9 + 1608) = *(float *)(v9 + 1588);
      *(float *)(v9 + 1612) = *(float *)(v9 + 1596);
      result = v14 + 1;
      *(_DWORD *)(v9 + 1616) = 0;
      *(float *)(v9 + 1640) = 12.0;
      *(_DWORD *)(v9 + 1620) = -1;
      *(float *)(v9 + 1636) = 0.5;
      v8 += 4;
      ++v7;
      *(float *)(v9 + 1632) = 1.0;
      v6 = 0.5;
      v5 = 1.0;
      v14 = result;
    }
    while ( result < (unsigned __int8)a2 );
  }
  *(_BYTE *)(a4 + 4788) = v7;
  if ( v7 < 0x32u )
  {
    v12 = 0.0;
    result = (v7 << 6) + a4 + 1596;
    v13 = (unsigned __int8)(50 - v7);
    do
    {
      *(float *)(result - 8) = 0.0;
      *(_DWORD *)(result + 48) = 0;
      *(float *)result = 0.0;
      *(_BYTE *)(result + 52) = 1;
      *(float *)(result - 4) = 0.0;
      *(_BYTE *)(result + 28) = 0;
      *(float *)(result + 4) = 0.0;
      *(_DWORD *)(result + 20) = 0;
      *(_DWORD *)(result + 24) = -1;
      *(float *)(result + 8) = v5;
      result += 64;
      --v13;
      *(float *)(result - 52) = 0.0;
      *(float *)(result - 48) = 0.0;
      *(float *)(result - 24) = v6;
      *(float *)(result - 28) = v6;
      *(float *)(result - 20) = *(float *)&v12;
    }
    while ( v13 );
  }
  return result;
}

//----- (1001ACB0) --------------------------------------------------------
int __usercall sub_1001ACB0@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 4789) != 1 )
    result = sub_1003E190(result + 1264, *(_BYTE *)(result + 1464));
  return result;
}

//----- (1001ACD0) --------------------------------------------------------
char __usercall sub_1001ACD0@<al>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4, int a5)
{
  if ( *(_BYTE *)(a1 + 4790) != 1 )
    LOBYTE(a1) = sub_10020430(a4, a5, a2, a1 + 16, a3);
  return a1;
}

//----- (1001AD00) --------------------------------------------------------
void __usercall sub_1001AD00(int a1@<esi>, int a2, _WORD *a3)
{
  signed int v3; // ebp@2
  int *v4; // ebx@2
  float **v5; // edi@2
  float *v6; // ecx@3
  char v7; // ST34_1@5
  float v8; // ST38_4@10
  float *v9; // [sp+28h] [bp-Ch]@2

  if ( *(_BYTE *)(a1 + 4791) != 1 )
  {
    v3 = 0;
    v9 = (float *)(a1 + 488);
    v4 = (int *)(a1 + 1104);
    v5 = (float **)(a1 + 704);
    do
    {
      v6 = *v5;
      if ( *v5 )
      {
        if ( 9.8999998e24 == *v6 )
        {
          if ( *(_BYTE *)(a1 + 4790) == 1 || *(_BYTE *)(a1 + 973) == 1 )
            sub_1003C630((int)(v5 - 5));
        }
        else
        {
          v7 = sub_10047DE0(*v6, a1 + 604, 10, (int)(v4 - 2));
          sub_10047F10(v7, v5 - 2, (int *)v5 - 3, *(_BYTE *)(a1 + 4791), *v4);
          if ( *(_BYTE *)(a1 + 978) == v3 )
            sub_1003B570(a2, (int)(v5 - 5), *(_WORD *)(a1 + 980), *(_DWORD *)(a1 + 984), *(_BYTE *)(a1 + 988));
          else
            sub_1003AD10(a2, (int)(v5 - 5), *(_WORD *)(a1 + 980), *(_DWORD *)(a1 + 984), *(_BYTE *)(a1 + 988));
          if ( *a3 == -32648 || *a3 == -32734 )
          {
            v8 = (*(float *)(a2 + 300) - *(float *)(a2 + 292)) * 0.5 + *(float *)(a2 + 292);
            sub_1003A550(v8, *v9, v8, *(float *)(a2 + 304), -1, 3.0, 113);
          }
        }
      }
      v9 += 5;
      ++v3;
      v4 += 7;
      v5 += 12;
    }
    while ( v3 < 6 );
  }
}

//----- (1001AE90) --------------------------------------------------------
int __usercall sub_1001AE90@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 4792) != 1 )
    result = sub_1003B4C0(result + 1468);
  return result;
}

//----- (1001AEB0) --------------------------------------------------------
int __usercall sub_1001AEB0@<eax>(int result@<eax>, int a2@<edx>, int a3@<edi>)
{
  if ( *(_BYTE *)(result + 4793) != 1 )
    result = sub_1003BEB0(a3, a2, result + 1588, *(_BYTE *)(result + 4788), 0);
  return result;
}

//----- (1001AEE0) --------------------------------------------------------
int __cdecl sub_1001AEE0(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8)
{
  double v8; // st7@1
  double v9; // st6@1
  double v10; // st3@1
  int v11; // ST1C_4@3
  float v12; // ST10_4@3
  double v13; // st4@3
  double v14; // st4@3
  double v15; // st4@3
  double v16; // st4@3
  double v17; // st4@3
  double v18; // st4@3
  double v19; // st4@3
  double v20; // st4@3
  double v21; // st4@3
  double v22; // st6@3
  float v24; // [sp+30h] [bp+10h]@1
  float v25; // [sp+30h] [bp+10h]@3
  int v26; // [sp+40h] [bp+20h]@3
  int v27; // [sp+40h] [bp+20h]@3
  float v28; // [sp+40h] [bp+20h]@3

  v8 = a4;
  *(float *)a1 = a4;
  v9 = a5;
  *(float *)(a1 + 4) = a5;
  *(float *)(a1 + 8) = a6;
  *(float *)(a1 + 12) = a7;
  v24 = a6 / ((double)a8 + 4.0);
  v10 = v24;
  if ( v24 < 10.0 )
    v10 = (float)10.0;
  *(_BYTE *)(a1 + 1484) = 1;
  v25 = a6 - v10;
  v11 = a8;
  *(float *)(a1 + 1468) = v8;
  *(float *)(a1 + 1472) = v9 + a7;
  *(float *)(a1 + 1476) = v10;
  *(float *)(a1 + 1480) = a7;
  *(float *)(a1 + 1488) = 0.0;
  *(float *)(a1 + 1492) = 0.0;
  *(float *)(a1 + 1496) = 1.0;
  *(float *)(a1 + 1508) = 1.0;
  *(float *)(a1 + 1520) = 1.0;
  *(float *)(a1 + 1532) = 1.0;
  *(float *)(a1 + 1544) = 1.0;
  *(float *)(a1 + 1556) = 1.0;
  *(float *)(a1 + 1568) = 1.0;
  *(float *)(a1 + 1580) = 1.0;
  *(float *)(a1 + 1500) = 0.0;
  *(float *)(a1 + 1504) = 0.0;
  *(float *)(a1 + 1512) = 0.0;
  *(float *)(a1 + 1516) = 0.0;
  *(float *)(a1 + 1524) = 0.0;
  *(float *)(a1 + 1528) = 0.0;
  *(float *)(a1 + 1536) = 0.0;
  *(float *)(a1 + 1540) = 0.0;
  *(float *)(a1 + 1548) = 0.0;
  *(float *)(a1 + 1552) = 0.0;
  *(float *)(a1 + 1560) = 0.0;
  *(float *)(a1 + 1564) = 0.0;
  *(float *)(a1 + 1572) = 0.0;
  *(float *)(a1 + 1576) = 0.0;
  *(_BYTE *)(a1 + 1584) = 2;
  *(float *)(a1 + 1488) = *(float *)(a3 + 4);
  *(float *)(a1 + 1500) = *(float *)(a3 + 8);
  *(float *)(a1 + 1492) = 0.0;
  *(float *)(a1 + 1504) = a7;
  v12 = v9;
  *(float *)&v26 = v10 + v8;
  sub_10020510(a1 + 16, a2, a3, *(float *)&v26, v12, v25, a7, v11);
  *(float *)(a1 + 684) = *(float *)(a1 + 172);
  *(_DWORD *)(a1 + 692) = 0;
  *(_DWORD *)(a1 + 696) = -1;
  *(_DWORD *)(a1 + 700) = -1;
  *(float *)(a1 + 708) = *(float *)(a3 + 4);
  *(float *)(a1 + 712) = *(float *)(a3 + 8);
  *(float *)(a1 + 716) = 0.5;
  *(float *)(a1 + 720) = 1.0;
  *(_DWORD *)(a1 + 704) = 0;
  *(float *)(a1 + 724) = 15.0;
  v13 = *(float *)(a1 + 224);
  *(_DWORD *)(a1 + 740) = 0;
  *(float *)(a1 + 732) = v13;
  *(_DWORD *)(a1 + 744) = -1;
  *(_DWORD *)(a1 + 748) = -1;
  *(float *)(a1 + 756) = *(float *)(a3 + 4);
  v14 = *(float *)(a3 + 8);
  *(_DWORD *)(a1 + 752) = 0;
  *(float *)(a1 + 760) = v14;
  *(float *)(a1 + 764) = 0.5;
  *(float *)(a1 + 768) = 1.0;
  *(float *)(a1 + 772) = 15.0;
  v15 = *(float *)(a1 + 276);
  *(_DWORD *)(a1 + 788) = 0;
  *(float *)(a1 + 780) = v15;
  *(_DWORD *)(a1 + 792) = -1;
  *(_DWORD *)(a1 + 796) = -1;
  *(float *)(a1 + 804) = *(float *)(a3 + 4);
  v16 = *(float *)(a3 + 8);
  *(_DWORD *)(a1 + 800) = 0;
  *(float *)(a1 + 808) = v16;
  *(float *)(a1 + 812) = 0.5;
  *(float *)(a1 + 816) = 1.0;
  *(float *)(a1 + 820) = 15.0;
  v17 = *(float *)(a1 + 328);
  *(_DWORD *)(a1 + 836) = 0;
  *(float *)(a1 + 828) = v17;
  *(_DWORD *)(a1 + 840) = -1;
  *(_DWORD *)(a1 + 844) = -1;
  *(float *)(a1 + 852) = *(float *)(a3 + 4);
  v18 = *(float *)(a3 + 8);
  *(_DWORD *)(a1 + 848) = 0;
  *(float *)(a1 + 856) = v18;
  *(float *)(a1 + 860) = 0.5;
  *(float *)(a1 + 864) = 1.0;
  *(float *)(a1 + 868) = 15.0;
  v19 = *(float *)(a1 + 380);
  *(_DWORD *)(a1 + 884) = 0;
  *(float *)(a1 + 876) = v19;
  *(_DWORD *)(a1 + 888) = -1;
  *(_DWORD *)(a1 + 892) = -1;
  *(float *)(a1 + 900) = *(float *)(a3 + 4);
  v20 = *(float *)(a3 + 8);
  *(_DWORD *)(a1 + 896) = 0;
  *(float *)(a1 + 904) = v20;
  *(float *)(a1 + 908) = 0.5;
  *(float *)(a1 + 912) = 1.0;
  *(float *)(a1 + 916) = 15.0;
  v21 = *(float *)(a1 + 432);
  *(_DWORD *)(a1 + 932) = 0;
  *(float *)(a1 + 924) = v21;
  *(_DWORD *)(a1 + 936) = -1;
  *(_DWORD *)(a1 + 940) = -1;
  *(float *)(a1 + 948) = *(float *)(a3 + 4);
  *(float *)(a1 + 952) = *(float *)(a3 + 8);
  *(float *)(a1 + 956) = 0.5;
  *(float *)(a1 + 960) = 1.0;
  *(_DWORD *)(a1 + 944) = 0;
  *(float *)(a1 + 964) = 15.0;
  *(float *)&v27 = a5 - 4.0;
  *(float *)(a1 + 688) = *(float *)&v27;
  v22 = *(float *)&v27;
  v28 = a5 - 30.0;
  *(float *)(a1 + 736) = v28;
  *(float *)(a1 + 832) = v28;
  *(float *)(a1 + 928) = v28;
  *(float *)(a1 + 784) = *(float *)&v22;
  *(float *)(a1 + 880) = *(float *)&v22;
  *(_DWORD *)(a1 + 4789) = 0;
  *(_BYTE *)(a1 + 4793) = 0;
  *(_BYTE *)(a1 + 976) = 1;
  sub_1001A990(a3, 0.5, a1);
  return sub_1001AAF0(0, 0, 0.0, a1);
}

//----- (1001B2C0) --------------------------------------------------------
char __cdecl sub_1001B2C0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_1001ACB0(a4);
      sub_1001AE90(a4);
      sub_1001AEB0(a4, a1, (int)a5);
      sub_1001AD00(a4, a1, a5);
      sub_1001ACD0(a4, a3, a5, a1, a2);
      break;
    case 0x8015:
    case 0x8016:
      sub_1001AD00(a4, a1, a5);
      sub_1001ACD0(a4, a3, a5, a1, a2);
      break;
    default:
      return 1;
  }
  return 1;
}

//----- (1001B3B0) --------------------------------------------------------
char __usercall sub_1001B3B0@<al>(int a1@<eax>, int a2@<edx>, _WORD *a3@<ecx>, int a4, int a5)
{
  if ( *(_BYTE *)(a1 + 5616) != 1 )
    LOBYTE(a1) = sub_10035EC0(a4, a5, a2, a1 + 16, a3);
  return a1;
}

//----- (1001B3E0) --------------------------------------------------------
int __usercall sub_1001B3E0@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 5617) != 1 )
    result = sub_1003A310(
               *(float *)result,
               *(float *)(result + 4),
               *(float *)(result + 8),
               *(float *)(result + 12),
               *(_DWORD *)(result + 5612));
  return result;
}

//----- (1001B420) --------------------------------------------------------
char __cdecl sub_1001B420(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_1001B3E0(a4);
      sub_1001B3B0(a4, a3, a5, a1, a2);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_1001B3B0(a4, a3, a5, a1, a2);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (1001B500) --------------------------------------------------------
double __cdecl sub_1001B500(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 >= (double)a1 )
    result = a2;
  return result;
}

//----- (1001B520) --------------------------------------------------------
double __cdecl sub_1001B520(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 <= (double)a1 )
    result = a2;
  return result;
}

//----- (1001B540) --------------------------------------------------------
int __usercall sub_1001B540@<eax>(int a1@<esi>)
{
  unsigned __int8 v1; // bl@2
  int result; // eax@4

  if ( *(_BYTE *)(a1 + 11440) != 1 )
  {
    v1 = 0;
    if ( *(_BYTE *)(a1 + 52) )
    {
      do
      {
        if ( v1 >= 3u )
          break;
        result = sub_1003E190(200 * v1 + a1 + 728, *(_BYTE *)(v1 + a1 + 1328));
        ++v1;
      }
      while ( v1 < *(_BYTE *)(a1 + 52) );
    }
  }
  return result;
}

//----- (1001B590) --------------------------------------------------------
void __usercall sub_1001B590(int a1@<esi>, int a2@<edi>)
{
  signed int v2; // ebp@2
  float *v3; // ecx@5
  int v4; // edi@7
  float *v5; // ebx@7
  double v6; // st7@8
  float v7; // ST2C_4@10
  double v8; // st7@10
  double v9; // st6@10
  double v10; // st7@12
  float v11; // ST2C_4@14
  float v12; // ST2C_4@16
  char v13; // ST38_1@16
  int v14; // edi@16
  float v15; // ST30_4@24
  float v16; // ST14_4@24
  float v17; // ST30_4@24
  int v18; // ecx@26
  float v19; // ST30_4@30
  float v20; // ST30_4@35
  float v21; // ST30_4@35
  float v22; // ST30_4@35
  float v23; // ST1C_4@35
  float v24; // ST30_4@35
  float v25; // ST1C_4@35
  float v26; // ST30_4@35
  float v27; // ST30_4@35
  float v28; // ST30_4@35
  float v29; // ST30_4@35
  double v30; // st7@35
  float v31; // ST30_4@36
  float v32; // ST30_4@36
  float v33; // ST30_4@36
  float v34; // ST1C_4@36
  float v35; // ST30_4@36
  float v36; // ST1C_4@36
  float v37; // ST30_4@36
  float v38; // ST30_4@36
  float v39; // ST30_4@36
  float v40; // ST30_4@36
  float v41; // ST18_4@37
  float *v42; // eax@41
  double v43; // ST30_8@43
  float v44; // ST2C_4@43
  int v45; // ST40_4@43
  float v46; // ST18_4@43
  double v47; // st6@44
  int v48; // ST40_4@45
  float v49; // [sp+Ch] [bp-34h]@34
  float v50; // [sp+10h] [bp-30h]@34
  int v51; // [sp+14h] [bp-2Ch]@21
  int v52; // [sp+14h] [bp-2Ch]@30
  float v53; // [sp+14h] [bp-2Ch]@34
  float v54; // [sp+14h] [bp-2Ch]@35
  int v55; // [sp+18h] [bp-28h]@3
  float v56; // [sp+24h] [bp-1Ch]@7
  float v57; // [sp+24h] [bp-1Ch]@26
  float v58; // [sp+24h] [bp-1Ch]@43
  float v59; // [sp+28h] [bp-18h]@8
  float v60; // [sp+28h] [bp-18h]@12
  float v61; // [sp+28h] [bp-18h]@26
  float v62; // [sp+28h] [bp-18h]@28
  int v63; // [sp+38h] [bp-8h]@7
  char v64; // [sp+3Ch] [bp-4h]@16

  if ( *(_BYTE *)(a1 + 11441) != 1 )
  {
    v2 = 0;
    if ( *(_BYTE *)(a1 + 52) )
    {
      v55 = a2;
      while ( 1 )
      {
        if ( v2 >= 3 )
          return;
        v3 = *(float **)(a1 + 4 * v2 + 28);
        if ( v3 )
        {
          if ( 9.8999998e24 != *v3 )
            break;
        }
LABEL_46:
        if ( ++v2 >= *(_BYTE *)(a1 + 52) )
          return;
      }
      v4 = a1 + 120 * v2;
      v63 = v4 + 10956;
      v56 = sub_10038A30(*v3, v4 + 10956, *(_BYTE *)(a1 + 120 * v2 + 11052));
      v5 = (float *)(a1 + 4 * (5 * v2 + 110));
      *v5 = v56;
      if ( *(_BYTE *)(a1 + 11644) )
      {
        v60 = v56 * -1.0;
        *v5 = v60;
        v10 = 0.0;
        if ( v60 < 0.0 )
          v10 = v60;
        v11 = v10;
        v8 = v11;
        *v5 = v11;
        v9 = *(float *)(v4 + 10948);
        if ( v9 < v11 )
          goto LABEL_16;
      }
      else
      {
        v59 = *(float *)(v4 + 10948);
        v6 = v56;
        if ( v59 <= (double)v56 )
          v6 = v59;
        v7 = v6;
        v8 = v7;
        *v5 = v7;
        v9 = 0.0;
        if ( v7 > 0.0 )
          goto LABEL_16;
      }
      v8 = v9;
LABEL_16:
      v12 = v8;
      *v5 = v12;
      v13 = sub_10047DE0(**(float **)(a1 + 4 * v2 + 40), 80 * v2 + a1 + 488, 10, a1 + 28 * v2 + 11460);
      v14 = a1 + 20 * v2;
      sub_10047ED0(v13, &v64, (_DWORD *)(v14 + 444), *(_BYTE *)(a1 + 11441));
      switch ( *(_BYTE *)(a1 + 11544) )
      {
        case 1:
          if ( *(_BYTE *)(a1 + 11449) == 1 )
            sub_10039900(v14 + 428);
          else
            sub_1003BE00(v14 + 428);
          break;
        case 2:
          sub_10039B30(v14 + 428);
          break;
        case 4:
          v51 = v14 + 428;
          if ( *(_BYTE *)(a1 + 11449) == 1 )
            sub_10039900(v51);
          else
            sub_1003BE00(v51);
          v15 = *(float *)(v14 + 432) - *v5;
          v16 = v15;
          v17 = *(float *)(v14 + 436) + *(float *)(v14 + 428) + 1.0;
          sub_1003A420(
            *(float *)(v14 + 428),
            *(float *)(v14 + 432),
            v17,
            v16,
            *(_DWORD *)(a1 + 11648),
            *(float *)(a1 + 11652));
          break;
        case 3:
          if ( *v5 < 0.0 )
          {
            *(float *)(32 * v2 + a1 + 11572) = 90.0;
            v18 = a1 + 32 * v2;
            v62 = *(float *)(v18 + 11556) + 1.0 + *v5;
            *v5 = v62;
            v57 = 1.0;
            if ( v62 > 0.0 )
            {
              v57 = v62;
              *v5 = 0.0;
            }
          }
          else
          {
            *(float *)(32 * v2 + a1 + 11572) = 270.0;
            v18 = 32 * v2 + a1;
            v61 = *v5 - (*(float *)(v18 + 11556) - 1.0);
            *v5 = v61;
            v57 = -1.0;
            if ( v61 < 0.0 )
            {
              v57 = v61;
              *v5 = 0.0;
            }
          }
          v19 = *(float *)(v14 + 432) - *v5 - v57;
          *(float *)(32 * (v2 + 361) + a1) = v19;
          sub_100395F0(v18 + 11548);
          v52 = v14 + 428;
          if ( *(_BYTE *)(a1 + 11449) == 1 )
            sub_10039900(v52);
          else
            sub_1003BE00(v52);
          if ( 0.0 != *v5 )
          {
            j_gdi_pvg_enable(35);
            j_gdi_pvg_color_u32(-16777216);
            j_gdi_pvg_begin(64);
            v53 = *(float *)(v14 + 432);
            v50 = 1.0;
            v49 = *(float *)(v14 + 428);
            if ( *(_BYTE *)(a1 + 11644) )
            {
              v31 = sub_100706D0(v49, v50) + 1.0;
              sub_10015960(v31, v53);
              v32 = *(float *)(v14 + 432) - *v5;
              v33 = sub_100705F0(v32, 1.0) - 1.0;
              v34 = v33;
              v35 = sub_100706D0(*(float *)(v14 + 428), 1.0) + 1.0;
              sub_10015960(v35, v34);
              v36 = *(float *)(v14 + 432);
              v37 = sub_100706D0(*(float *)(v14 + 428), 1.0) + *(float *)(v14 + 436);
              sub_10015960(v37, v36);
              v38 = *(float *)(v14 + 432) - *v5;
              v39 = sub_100705F0(v38, 1.0) - 1.0;
              v54 = v39;
              v40 = sub_100706D0(*(float *)(v14 + 428), 1.0) + *(float *)(v14 + 436);
              v30 = v40;
            }
            else
            {
              v20 = sub_100706D0(v49, v50) + 1.0;
              sub_10015960(v20, v53);
              v21 = *(float *)(v14 + 432) - *v5;
              v22 = sub_100706D0(v21, 1.0) + 1.0;
              v23 = v22;
              v24 = sub_100706D0(*(float *)(v14 + 428), 1.0) + 1.0;
              sub_10015960(v24, v23);
              v25 = *(float *)(v14 + 432);
              v26 = sub_100706D0(*(float *)(v14 + 428), 1.0) + *(float *)(v14 + 436);
              sub_10015960(v26, v25);
              v27 = *(float *)(v14 + 432) - *v5;
              v28 = sub_100706D0(v27, 1.0) + 1.0;
              v54 = v28;
              v29 = sub_100706D0(*(float *)(v14 + 428), 1.0) + *(float *)(v14 + 436);
              v30 = v29;
            }
            v41 = v30;
            sub_10015960(v41, v54);
            j_gdi_pvg_end(v55);
            j_gdi_pvg_disable(35);
          }
          break;
        default:
          if ( v2 == 2 )
            sub_10039B30(a1 + 468);
          else
            sub_1003BB00(v14 + 428);
          break;
      }
      v42 = *(float **)(a1 + 4 * v2 + 56);
      if ( v42 && *(_BYTE *)(a1 + 11443) != 1 )
      {
        v43 = *(float *)(v14 + 432);
        v44 = v43 - sub_10038A30(*v42, v63, *(_BYTE *)(a1 + 120 * v2 + 11052));
        *(float *)&v45 = *(float *)(v14 + 432) - *(float *)(a1 + 12);
        v46 = sub_1001B520(*(float *)(v14 + 432), v44);
        v58 = sub_1001B500(v46, *(float *)&v45);
        if ( *(_BYTE *)(a1 + 11644) == 1 )
        {
          v47 = *(float *)(v14 + 432) - v58;
          v58 = v58 + v47 + v47;
        }
        *(float *)&v48 = *(float *)(v14 + 436) + *(float *)(v14 + 436);
        sub_1003ABF0(*(float *)(v14 + 428), v58, *(float *)&v48, -16711681);
      }
      goto LABEL_46;
    }
  }
}
// 1001B590: could not find valid save-restore pair for edi
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1001BC80) --------------------------------------------------------
void __cdecl sub_1001BC80(int a1, int a2)
{
  int v2; // esi@1
  int *v3; // edi@1
  float **v4; // ebx@1
  int v5; // ebp@1
  char v6; // ST40_1@3
  signed int v7; // [sp+20h] [bp-8h]@1

  v2 = a2 + 280;
  v3 = (int *)(a2 + 11468);
  v4 = (float **)(a2 + 40);
  v5 = a2 + 488;
  v7 = 3;
  do
  {
    if ( *(_BYTE *)(v2 + 8) )
    {
      v6 = sub_10047DE0(**v4, v5, 10, (int)(v3 - 2));
      sub_10047FA0(v6, (_DWORD *)(v2 + 4), (int *)v2, *(_BYTE *)(a2 + 11442), *v3);
      sub_1003E0F0(a1, v2 - 8);
    }
    ++v4;
    v5 += 80;
    v3 += 7;
    v2 += 52;
    --v7;
  }
  while ( v7 );
}

//----- (1001BD10) --------------------------------------------------------
void __usercall sub_1001BD10(int a1@<edi>, int a2)
{
  int *v2; // ebp@1
  float **v3; // ebx@1
  int v4; // esi@1
  char v5; // ST4C_1@6
  int v6; // [sp+1Ch] [bp-Ch]@1
  signed int v7; // [sp+20h] [bp-8h]@1

  v2 = (int *)(a1 + 11468);
  v3 = (float **)(a1 + 40);
  v6 = a1 + 488;
  v4 = a1 + 11316;
  v7 = 3;
  do
  {
    if ( *(_DWORD *)v4 && (9.8999998e24 != **(float **)v4 || *(_BYTE *)(v4 + 26)) && *(_BYTE *)(a1 + 11444) != 1 )
    {
      v5 = sub_10047DE0(**v3, v6, 10, (int)(v2 - 2));
      sub_10047F10(v5, (_DWORD *)(v4 - 8), (int *)(v4 - 12), *(_BYTE *)(a1 + 11444), *v2);
      sub_1003AD10(a2, v4 - 20, *(_WORD *)(a1 + 11450), *(_DWORD *)(a1 + 11452), *(_BYTE *)(a1 + 11456));
    }
    v6 += 80;
    ++v3;
    v2 += 7;
    v4 += 48;
    --v7;
  }
  while ( v7 );
}

//----- (1001BDF0) --------------------------------------------------------
signed int __usercall sub_1001BDF0@<eax>(int a1@<ebx>)
{
  signed int v1; // esi@2
  int v2; // edi@3
  signed int result; // eax@5

  if ( *(_BYTE *)(a1 + 11445) != 1 )
  {
    v1 = 0;
    if ( *(_BYTE *)(a1 + 52) )
    {
      v2 = a1 + 10936;
      do
      {
        if ( v1 >= 3 )
          break;
        sub_1003B4C0(v2);
        result = *(_BYTE *)(a1 + 52);
        ++v1;
        v2 += 120;
      }
      while ( v1 < result );
    }
  }
  return result;
}

//----- (1001BE30) --------------------------------------------------------
void __cdecl sub_1001BE30(int a1)
{
  int v1; // ebp@1
  signed int v2; // ebx@2
  int v3; // edi@2
  int v4; // esi@2
  float *v5; // ecx@3
  double v6; // st7@5
  char v7; // al@5
  float v8; // ST30_4@6
  float v9; // ST08_4@6
  float v10; // ST08_4@8
  float v11; // ST30_4@9
  float *v12; // [sp+2Ch] [bp-Ch]@2
  double v13; // [sp+30h] [bp-8h]@5
  float v14; // [sp+3Ch] [bp+4h]@5
  float v15; // [sp+3Ch] [bp+4h]@6
  float v16; // [sp+3Ch] [bp+4h]@8

  v1 = a1;
  if ( *(_BYTE *)(a1 + 11446) != 1 )
  {
    v2 = 0;
    v3 = a1 + 10936;
    v4 = a1 + 76;
    v12 = (float *)(a1 + 432);
    do
    {
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 && 9.8999998e24 != *v5 )
      {
        v13 = *v12;
        v6 = sub_10038A30(*v5, v3 + 20, *(_BYTE *)(v3 + 116));
        v7 = *(_BYTE *)(v4 + 4);
        v14 = v13 - v6;
        if ( v7 == 1 )
        {
          *(float *)(v4 - 8) = *(float *)(v1 + 436);
          v8 = *(float *)(v1 + 436) + *(float *)(v1 + 436);
          *(float *)(v4 - 4) = v8;
          v9 = v14;
          v15 = *(float *)v3 - 1.0;
          sub_10039A80(v15, v9, *(float *)(v4 - 8), v8, byte_100984B4[v2], -16711681);
        }
        else if ( v7 == 2 )
        {
          v10 = v13 - v6;
          v16 = *(float *)v3 - 1.0;
          sub_10039A80(v16, v10, *(float *)(v4 - 8), *(float *)(v4 - 4), byte_100984B4[v2], -16711681);
        }
        else
        {
          *(float *)(v4 - 8) = *(float *)(v1 + 436);
          v11 = *(float *)(v1 + 436);
          *(float *)(v4 - 4) = v11;
          sub_1003C070(
            *(float *)v3,
            v14,
            *(float *)(v4 - 8),
            v11,
            COERCE_FLOAT(byte_100984B4[v2]),
            -16711681,
            -16777216);
        }
      }
      v12 += 5;
      ++v2;
      v4 += 16;
      v3 += 120;
    }
    while ( v2 < 3 );
  }
}

//----- (1001BFD0) --------------------------------------------------------
int __usercall sub_1001BFD0@<eax>(int a1@<edi>, int a2@<esi>)
{
  unsigned __int8 v2; // bl@2
  int result; // eax@4

  if ( *(_BYTE *)(a2 + 11447) != 1 )
  {
    v2 = 0;
    if ( *(_BYTE *)(a2 + 52) )
    {
      do
      {
        if ( v2 >= 3u )
          break;
        result = sub_1003BEB0(a1, a1, 3200 * v2 + a2 + 1332, *(_BYTE *)(v2 + a2 + 10932), 0);
        ++v2;
      }
      while ( v2 < *(_BYTE *)(a2 + 52) );
    }
  }
  return result;
}

//----- (1001C020) --------------------------------------------------------
void __usercall sub_1001C020(int a1@<eax>, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // bl@1
  int v4; // ebp@1
  int v5; // edi@1
  char v6; // al@4
  unsigned __int8 v7; // [sp+23h] [bp-9h]@1
  int v8; // [sp+24h] [bp-8h]@1
  char v9; // [sp+28h] [bp-4h]@1

  v2 = a1;
  v9 = 0;
  v7 = 0;
  v3 = 0;
  v8 = a1 + 488;
  v4 = a1 + 11460;
  v5 = a1 + 28;
  do
  {
    if ( *(_DWORD *)v5 )
    {
      if ( 9.8999998e24 != **(float **)v5 )
      {
        v6 = sub_10047DE0(**(float **)(v5 + 12), v8, 10, v4);
        if ( (unsigned __int8)v9 < (unsigned __int8)v6 )
        {
          v9 = v6;
          v7 = v3;
        }
      }
    }
    v8 += 80;
    ++v3;
    v5 += 4;
    v4 += 28;
  }
  while ( v3 < 3u );
  sub_10047FA0(v9, (_DWORD *)(v2 + 128), (int *)(v2 + 124), *(_BYTE *)(v2 + 11448), *(_DWORD *)(v2 + 28 * v7 + 11468));
  sub_10047FA0(v9, (_DWORD *)(v2 + 180), (int *)(v2 + 176), *(_BYTE *)(v2 + 11448), *(_DWORD *)(v2 + 28 * v7 + 11468));
  sub_1003E0F0(a2, v2 + 116);
  sub_1003E0F0(a2, v2 + 168);
}

//----- (1001C120) --------------------------------------------------------
int __usercall sub_1001C120@<eax>(int result@<eax>)
{
  float v1; // ST00_4@1
  double v2; // st3@1
  float v3; // ST04_4@1
  double v4; // st3@1
  float v5; // ST04_4@1

  *(float *)(result + 11572) = 270.0;
  *(_DWORD *)(result + 11576) = -1;
  *(float *)(result + 11560) = 0.0;
  *(float *)(result + 11564) = 0.0;
  v1 = *(float *)(result + 436) * 1.799999952316284;
  *(float *)(result + 11568) = v1;
  *(float *)(result + 11556) = COERCE_FLOAT(LODWORD(v1) & 0x7FFFFFFF) * 0.5;
  *(float *)(result + 11548) = *(float *)(result + 436) * 0.5 + *(float *)(result + 428);
  v2 = *(float *)(result + 12) + *(float *)(result + 4);
  *(_DWORD *)(result + 11608) = -1;
  *(float *)(result + 11552) = v2;
  *(float *)(result + 11604) = 270.0;
  *(float *)(result + 11592) = 0.0;
  *(float *)(result + 11596) = 0.0;
  v3 = *(float *)(result + 456) * 1.799999952316284;
  *(float *)(result + 11600) = v3;
  *(float *)(result + 11588) = COERCE_FLOAT(LODWORD(v3) & 0x7FFFFFFF) * 0.5;
  *(float *)(result + 11580) = *(float *)(result + 456) * 0.5 + *(float *)(result + 448);
  v4 = *(float *)(result + 12) + *(float *)(result + 4);
  *(_DWORD *)(result + 11640) = -1;
  *(float *)(result + 11584) = v4;
  *(float *)(result + 11636) = 270.0;
  *(float *)(result + 11624) = 0.0;
  *(float *)(result + 11628) = 0.0;
  v5 = 1.799999952316284 * *(float *)(result + 476);
  *(float *)(result + 11632) = v5;
  *(float *)(result + 11620) = COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) * 0.5;
  *(float *)(result + 11612) = 0.5 * *(float *)(result + 476) + *(float *)(result + 468);
  *(float *)(result + 11616) = *(float *)(result + 12) + *(float *)(result + 4);
  return result;
}

//----- (1001C270) --------------------------------------------------------
void __usercall sub_1001C270(int a1@<ebx>)
{
  int v1; // edi@2
  int v2; // esi@2
  float **v3; // ebp@2
  int v4; // esi@9
  signed int v5; // edi@9
  signed int v6; // [sp+28h] [bp-4h]@2

  if ( *(_BYTE *)(a1 + 11441) == 1 )
  {
    if ( *(_BYTE *)(a1 + 11444) != 1 )
    {
      v4 = a1 + 11316;
      v5 = 3;
      do
      {
        if ( *(_DWORD *)v4 && 9.8999998e24 == **(float **)v4 && !*(_BYTE *)(v4 + 26) )
          sub_1003C630(v4 - 20);
        v4 += 48;
        --v5;
      }
      while ( v5 );
    }
  }
  else
  {
    v1 = a1 + 428;
    v2 = a1 + 10940;
    v3 = (float **)(a1 + 28);
    v6 = 3;
    do
    {
      if ( *v3 )
      {
        if ( 9.8999998e24 == **v3 )
          sub_10039220(
            *(float *)v1,
            *(float *)v2,
            *(float *)(v1 + 8),
            *(float *)(v2 + 8),
            0.0,
            1.0,
            *(_BYTE *)(a1 + 16));
      }
      ++v3;
      v2 += 120;
      v1 += 20;
      --v6;
    }
    while ( v6 );
  }
}

//----- (1001C340) --------------------------------------------------------
char __usercall sub_1001C340@<al>(int a1@<ebx>, int a2@<edi>, int a3, float a4)
{
  double v4; // st7@1
  signed int v5; // esi@1
  char result; // al@2
  int v7; // eax@4
  int v8; // ebp@4
  float v9; // ST20_4@4
  int v10; // ecx@4
  double v11; // st7@4
  double v12; // st7@5
  int v13; // eax@7
  double v14; // st7@8
  float v15; // ST20_4@8
  float v16; // ST20_4@9
  double v17; // st6@15
  int v18; // eax@15
  int v19; // ecx@15
  int v20; // eax@15
  int v21; // edx@15
  float v22; // [sp+14h] [bp-1Ch]@1
  int v23; // [sp+18h] [bp-18h]@2
  int v24; // [sp+1Ch] [bp-14h]@2
  float v25; // [sp+20h] [bp-10h]@7
  float v26; // [sp+24h] [bp-Ch]@1

  v26 = flt_10098490[a1];
  v4 = 0.0;
  v5 = 0;
  v22 = 0.0;
  if ( *(_BYTE *)a3 )
  {
    v23 = a3 + 12;
    result = a2 + 104;
    v24 = a2 + 1128;
    do
    {
      if ( v5 >= 10 )
      {
        *(_BYTE *)(a2 + a1 + 1328) = *(_BYTE *)a3;
        return result;
      }
      v7 = a2 + 120 * a1;
      v8 = 10 * a1;
      v9 = v26 * a4 * *(float *)(v7 + 10944);
      v10 = a2 + 20 * (v5 + 10 * a1);
      *(float *)(v10 + 736) = v9;
      *(float *)(v10 + 728) = *(float *)(v7 + 10936) - v9;
      v11 = *(float *)(v7 + 10940);
      if ( *(_BYTE *)(a2 + 11644) )
        v12 = v11 + v22;
      else
        v12 = v11 - v22;
      *(float *)(v10 + 732) = v12;
      v25 = sub_10038A30(*(float *)v23, v7 + 10956, *(_BYTE *)(v7 + 11052));
      v13 = v5 + v8 + 37;
      if ( *(_BYTE *)(a2 + 11644) )
      {
        v14 = v25;
        v16 = v25 - v22;
        *(float *)(a2 + 20 * v13) = v16;
      }
      else
      {
        v14 = v25;
        v15 = v22 - v25;
        *(float *)(a2 + 20 * v13) = v15;
      }
      *(_DWORD *)(a2 + 20 * (v5 + 10 * a1) + 744) = *(_DWORD *)(v23 + 40);
      *(float *)(a2 + 8 * (v5 + v8) + 488) = *(float *)v23;
      *(_BYTE *)(a2 + 8 * (v5 + 10 * a1) + 492) = *(_BYTE *)(v5 + a3 + 92);
      if ( a1 == 2 )
        *(float *)v24 = *(float *)(v24 + 8) * 0.5 + *(float *)v24;
      v22 = v14;
      ++v5;
      result = v23 + 4;
      v23 += 4;
      v24 += 20;
    }
    while ( v5 < *(_BYTE *)a3 );
    if ( v5 < 10 )
    {
      v4 = 0.0;
      goto LABEL_15;
    }
    result = *(_BYTE *)a3;
    *(_BYTE *)(a2 + a1 + 1328) = *(_BYTE *)a3;
  }
  else
  {
LABEL_15:
    v17 = 9.8999998e24;
    v18 = v5 + 10 * a1;
    v19 = a2 + 8 * v18 + 488;
    v20 = a2 + 20 * v18 + 732;
    v21 = 10 - v5;
    do
    {
      *(_DWORD *)(v20 + 12) = 0;
      *(float *)(v20 - 4) = v4;
      v20 += 20;
      *(float *)(v20 - 20) = v4;
      v19 += 8;
      --v21;
      *(float *)(v20 - 16) = v4;
      *(float *)(v20 - 12) = v4;
      *(_BYTE *)(v19 - 4) = 10;
      *(float *)(v19 - 8) = *(float *)&v17;
    }
    while ( v21 );
    result = a3;
    *(_BYTE *)(a2 + a1 + 1328) = *(_BYTE *)a3;
  }
  return result;
}
// 10098490: using guessed type float flt_10098490[];

//----- (1001C550) --------------------------------------------------------
int __usercall sub_1001C550@<eax>(int a1@<edx>, unsigned __int8 a2@<cl>, int a3@<ebx>, unsigned __int8 a4, int a5)
{
  int result; // eax@1
  int v6; // edi@1
  double v7; // st7@1
  int v8; // edx@2
  int v9; // ebp@5
  int v10; // esi@5
  double v11; // ST2C_8@6
  double v12; // st7@6
  double v13; // st7@8
  bool v14; // sf@10
  unsigned __int8 v15; // of@10
  double v16; // st6@12
  int v17; // ecx@12
  int v18; // [sp+4h] [bp-30h]@5
  int v19; // [sp+8h] [bp-2Ch]@5
  int i; // [sp+18h] [bp-1Ch]@2
  int v21; // [sp+1Ch] [bp-18h]@1
  float v22; // [sp+20h] [bp-14h]@1
  int v23; // [sp+24h] [bp-10h]@5
  int v24; // [sp+28h] [bp-Ch]@5
  unsigned __int8 v25; // [sp+3Ch] [bp+8h]@1

  result = a4;
  v6 = a5;
  v21 = 0;
  v22 = flt_1009849C[a5];
  v25 = a2;
  v7 = 0.5;
  if ( (signed int)a4 > 0 )
  {
    v8 = a1 + 4;
    for ( i = v8; a2 < 0x32u; v8 = i )
    {
      v9 = a3 + 120 * v6;
      v24 = a2;
      v23 = 50 * v6 + a2;
      v10 = (v23 << 6) + a3;
      *(float *)(v10 + 1332) = *(float *)(a3 + 120 * v6 + 10936);
      v19 = *(_BYTE *)(v9 + 11052);
      v18 = v9 + 10956;
      if ( *(_BYTE *)(a3 + 11644) )
      {
        v12 = sub_10038A30(*(float *)(v8 - 4), v18, v19) + *(float *)(v9 + 10940);
      }
      else
      {
        v11 = *(float *)(v9 + 10940);
        v12 = v11 - sub_10038A30(*(float *)(v8 - 4), v18, v19);
      }
      *(float *)(v10 + 1340) = v12;
      v13 = *(float *)i * v22 * *(float *)(v9 + 10944);
      *(_DWORD *)(v10 + 1388) = -1;
      *(float *)(v10 + 1336) = v13 + *(float *)(v10 + 1332);
      *(float *)(((v23 + 21) << 6) + a3) = *(float *)(v10 + 1340);
      *(float *)(v10 + 1348) = 1.0;
      if ( v6 == 2 )
        *(float *)((v24 << 6) + a3 + 7732) = *(float *)(a3 + 11184) * -v22 * *(float *)i
                                           + *(float *)((v24 << 6) + a3 + 7732);
      sub_10038450(v10 + 1368, (_BYTE *)(i + 4), 7);
      *(float *)(v10 + 1356) = *(float *)(v10 + 1340);
      ++v25;
      *(float *)(v10 + 1384) = 9.0;
      v7 = 0.5;
      i += 16;
      result = v21 + 1;
      *(float *)(v10 + 1380) = 0.5;
      *(_DWORD *)(v10 + 1360) = 0;
      *(_DWORD *)(v10 + 1364) = -1;
      v15 = __OFSUB__(v21 + 1, a4);
      v14 = v21 + 1 - a4 < 0;
      a2 = v25;
      ++v21;
      if ( !(v14 ^ v15) )
        break;
    }
  }
  *(_BYTE *)(a3 + v6 + 10932) = a2;
  if ( a2 < 0x32u )
  {
    v16 = 0.0;
    result = ((a2 + 50 * v6) << 6) + a3 + 1340;
    v17 = (unsigned __int8)(50 - a2);
    do
    {
      *(float *)(result - 8) = 0.0;
      *(_DWORD *)(result + 48) = 0;
      *(float *)result = 0.0;
      *(_BYTE *)(result + 28) = 0;
      *(float *)(result - 4) = 0.0;
      *(_DWORD *)(result + 20) = 0;
      *(float *)(result + 4) = 0.0;
      *(_DWORD *)(result + 24) = -1;
      result += 64;
      --v17;
      *(float *)(result - 56) = 1.0;
      *(float *)(result - 52) = 0.0;
      *(float *)(result - 48) = 0.0;
      *(float *)(result - 24) = v7;
      *(float *)(result - 28) = v7;
      *(float *)(result - 20) = *(float *)&v16;
    }
    while ( v17 );
  }
  return result;
}
// 1009849C: using guessed type float flt_1009849C[];

//----- (1001C770) --------------------------------------------------------
char __cdecl sub_1001C770(int a1, float a2, int a3)
{
  return sub_1001C340(2, a3, a1, a2);
}

//----- (1001C7A0) --------------------------------------------------------
char __cdecl sub_1001C7A0(int a1, float a2, int a3)
{
  return sub_1001C340(0, a3, a1, a2);
}

//----- (1001C7C0) --------------------------------------------------------
char __cdecl sub_1001C7C0(int a1, float a2, int a3)
{
  return sub_1001C340(1, a3, a1, a2);
}

//----- (1001C7F0) --------------------------------------------------------
int __cdecl sub_1001C7F0(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  return sub_1001C550(a1, a3, a4, a2, 2);
}

//----- (1001C810) --------------------------------------------------------
int __cdecl sub_1001C810(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  return sub_1001C550(a1, a3, a4, a2, 0);
}

//----- (1001C830) --------------------------------------------------------
int __cdecl sub_1001C830(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  return sub_1001C550(a1, a3, a4, a2, 1);
}

//----- (1001C850) --------------------------------------------------------
char __cdecl sub_1001C850(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_1001B540(a4);
      sub_1001BDF0(a4);
      sub_1001BFD0(a1, a4);
      sub_1001BE30(a4);
      sub_1001B590(a4, a1);
      sub_1001C020(a4, a1);
      sub_1001BC80(a1, a4);
      sub_1001BD10(a4, a1);
      sub_1001C270(a4);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_1001C020(a4, a1);
      sub_1001BC80(a1, a4);
      sub_1001BD10(a4, a1);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (1001C950) --------------------------------------------------------
char __cdecl sub_1001C950(int a1, float a2, int a3)
{
  sub_1001C7A0(a1, a2, a3);
  sub_1001C7C0(a1, a2, a3);
  return sub_1001C770(a1, a2, a3);
}

//----- (1001C9A0) --------------------------------------------------------
int __cdecl sub_1001C9A0(int a1, unsigned __int8 a2, unsigned __int8 a3, int a4)
{
  sub_1001C810(a1, a2, a3, a4);
  sub_1001C830(a1, a2, a3, a4);
  return sub_1001C7F0(a1, a2, a3, a4);
}

//----- (1001C9E0) --------------------------------------------------------
char __usercall sub_1001C9E0@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5)
{
  int v5; // ecx@1
  signed int v6; // edx@1
  double v7; // st5@3
  int v8; // eax@3
  float v10; // [sp+Ch] [bp+4h]@3

  v5 = a1 + 1376;
  v6 = 50;
  *(float *)(a1 + 10936) = a3 + a5;
  *(float *)(a1 + 428) = *(float *)a1;
  *(float *)(a1 + 436) = a5 * 0.4000000059604645;
  do
  {
    v5 += 64;
    --v6;
    *(float *)(v5 - 88) = *(float *)(a1 + 10936) + 4.0;
    *(float *)(v5 - 64) = 0.0;
  }
  while ( v6 );
  *(_DWORD *)(a1 + 11304) = 0;
  *(float *)(a1 + 11296) = a3;
  *(_DWORD *)(a1 + 11308) = -1;
  v10 = a4 - 4.0;
  *(float *)(a1 + 11300) = v10;
  *(float *)(a1 + 11320) = *(float *)(a2 + 4);
  v7 = *(float *)(a2 + 8);
  *(_BYTE *)(a1 + 52) = 1;
  *(float *)(a1 + 11324) = v7;
  *(float *)(a1 + 11328) = 0.0;
  *(float *)(a1 + 11332) = 1.0;
  *(float *)(a1 + 11336) = 15.0;
  *(float *)(a1 + 120) = v10 - 15.0 - 3.0;
  *(float *)(a1 + 312) = 1.0;
  *(float *)(a1 + 428) = *(float *)a1;
  v8 = sub_1001C120(a1);
  return sub_1001C950(a2, 0.2, v8);
}

//----- (1001CAD0) --------------------------------------------------------
char __usercall sub_1001CAD0@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5)
{
  double v5; // st7@1
  float *v6; // ecx@1
  signed int v7; // edi@1
  signed int v8; // edx@2
  double v9; // st5@5
  double v10; // st4@5
  double v11; // st2@5
  double v12; // st6@5
  int v13; // eax@5
  float v15; // [sp+18h] [bp+Ch]@1
  float v16; // [sp+18h] [bp+Ch]@3
  float v17; // [sp+18h] [bp+Ch]@5
  float v18; // [sp+18h] [bp+Ch]@5

  v5 = a5;
  v6 = (float *)(a1 + 1352);
  v7 = 3;
  *(float *)(a1 + 10936) = 0.25 * a5 + a3;
  *(float *)(a1 + 11056) = a5 * 0.75 + a3;
  v15 = a5 * 0.1500000059604645;
  *(float *)(a1 + 10944) = v15;
  *(float *)(a1 + 11064) = v15;
  do
  {
    v8 = 50;
    do
    {
      v16 = v5 * 0.5 + a3;
      *v6 = v16;
      v6 += 16;
      --v8;
    }
    while ( v8 );
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a1 + 11304) = 0;
  *(float *)(a1 + 11296) = a3;
  *(_DWORD *)(a1 + 11308) = -1;
  v17 = a4 - 4.0;
  v9 = v17;
  *(float *)(a1 + 11300) = v17;
  *(float *)(a1 + 11320) = *(float *)(a2 + 4);
  v10 = *(float *)(a2 + 8);
  *(_DWORD *)(a1 + 11352) = 0;
  *(float *)(a1 + 11324) = v10;
  *(_DWORD *)(a1 + 11356) = -1;
  *(float *)(a1 + 11328) = 0.0;
  *(float *)(a1 + 11332) = 1.0;
  *(float *)(a1 + 11336) = 15.0;
  v18 = v5 + a3;
  *(float *)(a1 + 11344) = v18;
  *(float *)(a1 + 11348) = v9;
  *(float *)(a1 + 11368) = *(float *)(a2 + 4);
  v11 = *(float *)(a2 + 8);
  *(_BYTE *)(a1 + 52) = 2;
  *(float *)(a1 + 11372) = v11;
  *(float *)(a1 + 11376) = 1.0;
  *(float *)(a1 + 11380) = 1.0;
  *(float *)(a1 + 11384) = 15.0;
  *(float *)(a1 + 120) = v9 - 15.0 - 3.0;
  v12 = v18;
  *(float *)(a1 + 312) = 1.0;
  *(float *)(a1 + 324) = *(float *)&v12;
  *(float *)(a1 + 364) = 0.0;
  *(float *)(a1 + 428) = *(float *)a1;
  *(float *)(a1 + 448) = *(float *)(a1 + 8) + *(float *)a1;
  *(float *)(a1 + 456) = *(float *)(a1 + 456) * -1.0;
  v13 = sub_1001C120(a1);
  return sub_1001C950(a2, 0.40000001, v13);
}

//----- (1001CC60) --------------------------------------------------------
char __usercall sub_1001CC60@<al>(int a1@<eax>, int a2@<esi>, float a3, float a4, float a5)
{
  double v5; // st7@1
  float *v6; // ecx@1
  signed int v7; // edx@1
  double v8; // st6@1
  double v9; // st5@1
  float *v10; // ecx@3
  signed int v11; // edx@3
  float *v12; // ecx@5
  signed int v13; // edx@5
  double v14; // st4@7
  double v15; // st3@7
  double v16; // st0@7
  double v17; // st6@7
  int v18; // eax@7
  float v20; // [sp+14h] [bp+Ch]@1
  float v21; // [sp+14h] [bp+Ch]@1
  float v22; // [sp+14h] [bp+Ch]@2
  float v23; // [sp+14h] [bp+Ch]@4
  float v24; // [sp+14h] [bp+Ch]@7
  float v25; // [sp+14h] [bp+Ch]@7
  float v26; // [sp+14h] [bp+Ch]@7

  v5 = a5;
  v6 = (float *)(a1 + 1352);
  v7 = 50;
  v8 = a3;
  *(float *)(a1 + 10936) = 0.1500000059604645 * a5 + a3;
  *(float *)(a1 + 11056) = a5 * 0.8500000238418579 + a3;
  v20 = a5 * 0.5 + a3;
  v9 = v20;
  *(float *)(a1 + 11176) = v20;
  v21 = v5 * 0.119999997317791;
  *(float *)(a1 + 10944) = v21;
  *(float *)(a1 + 11064) = v21;
  *(float *)(a1 + 11184) = v21;
  do
  {
    v22 = v5 * 0.3199999928474426 + a3;
    *v6 = v22;
    v6 += 16;
    --v7;
  }
  while ( v7 );
  v10 = (float *)(a1 + 4552);
  v11 = 50;
  do
  {
    v23 = v5 * 0.6800000071525574 + v8;
    *v10 = v23;
    v10 += 16;
    --v11;
  }
  while ( v11 );
  v12 = (float *)(a1 + 7752);
  v13 = 50;
  do
  {
    *v12 = v9;
    v12 += 16;
    --v13;
  }
  while ( v13 );
  *(_DWORD *)(a1 + 11304) = 0;
  *(float *)(a1 + 11296) = a3;
  *(_DWORD *)(a1 + 11308) = -1;
  v24 = a4 - 5.0;
  v14 = v24;
  *(float *)(a1 + 11300) = v24;
  *(float *)(a1 + 11320) = *(float *)(a2 + 4);
  v15 = *(float *)(a2 + 8);
  *(_DWORD *)(a1 + 11352) = 0;
  *(float *)(a1 + 11324) = v15;
  *(_DWORD *)(a1 + 11356) = -1;
  *(float *)(a1 + 11328) = 0.0;
  *(float *)(a1 + 11332) = 1.0;
  *(float *)(a1 + 11336) = 15.0;
  v25 = v8 + v5;
  *(float *)(a1 + 11344) = v25;
  *(float *)(a1 + 11348) = v14;
  *(float *)(a1 + 11368) = *(float *)(a2 + 4);
  v16 = *(float *)(a2 + 8);
  *(_DWORD *)(a1 + 11400) = 0;
  *(float *)(a1 + 11372) = v16;
  *(_DWORD *)(a1 + 11404) = -1;
  *(float *)(a1 + 11376) = 1.0;
  *(float *)(a1 + 11380) = 1.0;
  *(float *)(a1 + 11384) = 15.0;
  *(float *)(a1 + 11392) = v9;
  *(float *)(a1 + 11396) = v14;
  *(float *)(a1 + 11416) = *(float *)(a2 + 4);
  *(float *)(a1 + 11420) = *(float *)(a2 + 8);
  *(float *)(a1 + 11424) = 0.5;
  *(float *)(a1 + 11428) = 1.0;
  *(float *)(a1 + 11432) = 15.0;
  *(float *)(a1 + 120) = v14 - 15.0 - 3.0;
  *(float *)(a1 + 312) = 1.0;
  *(float *)(a1 + 324) = v25;
  *(float *)(a1 + 364) = 0.0;
  *(float *)(a1 + 376) = v9;
  *(float *)(a1 + 416) = 0.5;
  v26 = v5 * 0.05799999833106995;
  *(float *)(a1 + 436) = v26;
  *(float *)(a1 + 456) = -1.0 * v26;
  *(float *)(a1 + 476) = v26;
  *(float *)(a1 + 428) = *(float *)a1;
  *(float *)(a1 + 448) = *(float *)a1 + *(float *)(a1 + 8);
  v17 = *(float *)(a1 + 8);
  *(_BYTE *)(a1 + 52) = 3;
  *(float *)(a1 + 468) = v17 * 0.5 + *(float *)a1 - v26 * 0.5;
  v18 = sub_1001C120(a1);
  return sub_1001C950(a2, 0.40000001, v18);
}

//----- (1001CED0) --------------------------------------------------------
int __usercall sub_1001CED0@<eax>(int a1@<esi>, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st7@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ebp@1
  double v11; // st6@1
  double v12; // st7@6
  int v13; // eax@6
  double v14; // st6@6
  signed int v15; // edx@6
  double v16; // st5@6
  double v17; // st4@6
  double v18; // rt1@7
  double v19; // st4@7
  double v20; // rt2@7
  double v21; // st4@7
  double v22; // rtt@7
  double v23; // rt0@8
  double v24; // st4@8
  double v25; // st5@8
  double v26; // rt1@8
  double v27; // st4@8
  double v28; // st7@8
  double v29; // rt2@8
  double v30; // st4@8
  double v31; // st6@8
  int v32; // eax@9
  double v33; // st4@9
  signed int v34; // edi@9
  double v35; // st3@9
  double v36; // st2@9
  double v37; // rtt@10
  double v38; // st2@10
  double v39; // rt0@10
  double v40; // st2@10
  double v41; // rt1@10
  double v42; // rt2@11
  double v43; // st2@11
  double v44; // st5@11
  double v45; // rtt@12
  double v46; // st2@12
  double v47; // st3@12
  double v48; // rt0@13
  double v49; // rtt@14
  double v50; // st2@14
  double v51; // st4@14
  int v52; // ecx@14
  signed int v53; // edx@14
  double v54; // rt0@15
  double v55; // st2@15
  double v56; // rt1@15
  double v57; // rt2@16
  double v58; // st2@16
  double v59; // st5@16
  double v60; // rtt@16
  double v61; // st2@16
  double v62; // st6@16
  double v63; // rt0@17
  double v64; // st2@17
  double v65; // rt1@17
  double v66; // st2@17
  double v67; // st4@17
  double v68; // st3@18
  double v69; // st7@18
  double v70; // st6@18
  double v71; // st5@18
  int v72; // eax@18
  double v73; // st4@18
  signed int v74; // ecx@18
  double v75; // st3@18
  double v76; // rt2@19
  double v77; // st3@19
  double v78; // st4@19
  double v79; // rtt@19
  double v80; // st3@19
  double v81; // rt0@19
  double v82; // st3@19
  double v83; // rt1@19
  double v84; // st3@19
  double v85; // rt2@19
  double v86; // rtt@20
  double v87; // st3@20
  double v88; // st6@20
  double v89; // rt0@20
  double v90; // st3@20
  double v91; // st7@20
  double v92; // rt1@20
  double v93; // st3@20
  double v94; // st4@20
  double v95; // rt2@20
  double v96; // st3@20
  double v97; // st5@20
  double v98; // rtt@20
  double v99; // st3@20
  double v100; // st6@20
  int v102; // [sp+0h] [bp-10h]@1
  float v103; // [sp+4h] [bp-Ch]@1
  signed int v104; // [sp+8h] [bp-8h]@1
  float v105; // [sp+Ch] [bp-4h]@1
  float v106; // [sp+28h] [bp+18h]@18

  *(float *)(a1 + 11652) = 2.0;
  *(_DWORD *)(a1 + 11648) = -1;
  *(_BYTE *)(a1 + 16) = 0;
  *(float *)a1 = a4;
  v7 = a5;
  *(float *)(a1 + 4) = a5;
  v8 = a1 + 432;
  *(float *)(a1 + 8) = a6;
  v9 = a1 + 68;
  v10 = a1 + 40;
  *(float *)(a1 + 12) = a7;
  v104 = 3;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  *(float *)(a1 + 24) = *(float *)(a3 + 8);
  *(_WORD *)(a1 + 11450) = 12;
  *(_DWORD *)(a1 + 11452) = &unk_100984F8;
  *(_BYTE *)(a1 + 11456) = 1;
  *(_BYTE *)(a1 + 11544) = 0;
  v102 = a1 + 11460;
  v103 = a6 * 0.1000000014901161;
  v11 = v103;
  v105 = v11 + v11;
  while ( 1 )
  {
    *(_DWORD *)(v10 - 12) = 0;
    *(_DWORD *)v10 = 0;
    *(_DWORD *)(v10 + 16) = 0;
    *(float *)v9 = v11;
    *(_DWORD *)(v9 + 8) = 0;
    *(float *)(v9 + 4) = v105;
    *(float *)(v8 - 4) = a4;
    if ( !*(_BYTE *)(a1 + 11644) )
      v7 = v7 + a7;
    *(float *)v8 = v7;
    *(float *)(v8 + 4) = v11;
    *(float *)(v8 + 8) = 0.0;
    sub_10048030(v102);
    v102 += 28;
    v10 += 4;
    v9 += 16;
    v8 += 20;
    if ( !--v104 )
      break;
    v7 = a5;
    v11 = v103;
  }
  v12 = 1.0;
  v13 = a1 + 11296;
  v14 = 15.0;
  v15 = 3;
  v16 = a5;
  v17 = a4;
  while ( 1 )
  {
    *(float *)v13 = v17;
    *(_DWORD *)(v13 + 20) = 0;
    v23 = v17;
    v24 = v16;
    v25 = v23;
    *(_DWORD *)(v13 + 8) = 0;
    *(float *)(v13 + 4) = v24;
    *(_DWORD *)(v13 + 12) = -1;
    *(_DWORD *)(v13 + 16) = -1;
    *(_BYTE *)(v13 + 46) = 0;
    *(_BYTE *)(v13 + 44) = 0;
    *(_BYTE *)(v13 + 45) = 0;
    *(float *)(v13 + 24) = *(float *)(a3 + 4);
    v13 += 48;
    --v15;
    *(float *)(v13 - 20) = *(float *)(a3 + 8);
    v26 = v24;
    v27 = v12;
    v28 = v26;
    *(float *)(v13 - 16) = v27;
    *(float *)(v13 - 12) = v27;
    v29 = v27;
    v30 = v14;
    v31 = v29;
    *(float *)(v13 - 8) = v30;
    if ( !v15 )
      break;
    v18 = v30;
    v19 = v31;
    v14 = v18;
    v20 = v19;
    v21 = v28;
    v12 = v20;
    v22 = v21;
    v17 = v25;
    v16 = v22;
  }
  v32 = a1 + 10940;
  v33 = a6;
  v34 = 3;
  v35 = a7;
  v36 = 0.0;
  while ( 1 )
  {
    v42 = v36;
    v43 = v25;
    v44 = v42;
    *(float *)(v32 - 4) = v43;
    if ( *(_BYTE *)(a1 + 11644) )
    {
      v48 = v43;
      *(float *)v32 = v28;
      *(float *)(v32 + 8) = v35 * -1.0;
      v46 = v35;
      v47 = v48;
    }
    else
    {
      *(float *)v32 = v28 + v35;
      v45 = v43;
      v46 = v35;
      v47 = v45;
      *(float *)(v32 + 8) = v46;
    }
    v49 = v46;
    v50 = v33;
    v51 = v49;
    *(_BYTE *)(v32 + 12) = 1;
    *(float *)(v32 + 4) = v50;
    v52 = v32 + 24;
    v53 = 8;
    while ( 1 )
    {
      v57 = v50;
      v58 = v44;
      v59 = v57;
      v52 += 12;
      --v53;
      *(float *)(v52 - 20) = v58;
      *(float *)(v52 - 16) = v58;
      v60 = v58;
      v61 = v31;
      v62 = v60;
      *(float *)(v52 - 12) = v61;
      if ( !v53 )
        break;
      v54 = v61;
      v55 = v62;
      v31 = v54;
      v56 = v55;
      v50 = v59;
      v44 = v56;
    }
    *(_BYTE *)(v32 + 112) = 2;
    *(float *)(v32 + 16) = *(float *)(a3 + 4);
    v32 += 120;
    --v34;
    *(float *)(v32 - 92) = *(float *)(a3 + 8);
    v63 = v61;
    v64 = v62;
    v31 = v63;
    *(float *)(v32 - 100) = v64;
    v65 = v64;
    v66 = v51;
    v67 = v65;
    *(float *)(v32 - 88) = v66;
    if ( !v34 )
      break;
    v37 = v66;
    v38 = v47;
    v35 = v37;
    v39 = v38;
    v40 = v59;
    v25 = v39;
    v41 = v40;
    v36 = v67;
    v33 = v41;
  }
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 128) = -1;
  v106 = v47 + v59 * 0.5;
  *(_DWORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = -1;
  *(float *)(a1 + 116) = v106;
  *(_DWORD *)(a1 + 228) = 0;
  *(_DWORD *)(a1 + 232) = -1;
  *(float *)(a1 + 120) = v28;
  *(float *)(a1 + 156) = 0.5;
  *(float *)(a1 + 160) = v31;
  *(float *)(a1 + 164) = 12.0;
  *(float *)(a1 + 168) = v106;
  *(float *)(a1 + 172) = v28;
  *(float *)(a1 + 208) = 0.5;
  *(float *)(a1 + 212) = v31;
  *(float *)(a1 + 216) = 12.0;
  v68 = v106;
  *(float *)(a1 + 220) = *(float *)&v68;
  *(float *)(a1 + 224) = v28;
  *(float *)(a1 + 260) = 0.5;
  *(float *)(a1 + 264) = v31;
  *(float *)(a1 + 268) = 12.0;
  sub_10038450(a1 + 132, (_BYTE *)a2, 21);
  v69 = a5;
  v70 = a4;
  *(_BYTE *)(a1 + 184) = 0;
  v71 = 0.0;
  v72 = a1 + 276;
  v73 = 0.5;
  v74 = 3;
  v75 = 12.0;
  while ( 1 )
  {
    v86 = v75;
    v87 = v70;
    v88 = v86;
    *(_DWORD *)(v72 + 4) = 0;
    *(float *)(v72 - 4) = v87;
    *(_DWORD *)(v72 + 8) = -1;
    v89 = v87;
    v90 = v69;
    v91 = v89;
    *(_BYTE *)(v72 + 12) = 0;
    *(float *)v72 = v90;
    v72 += 52;
    --v74;
    v92 = v90;
    v93 = v73;
    v94 = v92;
    *(float *)(v72 - 16) = v93;
    v95 = v93;
    v96 = v71;
    v97 = v95;
    *(float *)(v72 - 12) = v96;
    v98 = v96;
    v99 = v88;
    v100 = v98;
    *(float *)(v72 - 8) = v99;
    if ( !v74 )
      break;
    v76 = v99;
    v77 = v94;
    v78 = v76;
    v79 = v77;
    v80 = v91;
    v69 = v79;
    v81 = v80;
    v82 = v100;
    v70 = v81;
    v83 = v82;
    v84 = v97;
    v71 = v83;
    v85 = v84;
    v75 = v78;
    v73 = v85;
  }
  *(_DWORD *)(a1 + 11440) = 0;
  *(_DWORD *)(a1 + 11444) = 0;
  *(_WORD *)(a1 + 11448) = 0;
  *(_BYTE *)(a1 + 11449) = 1;
  return sub_1001C9A0(0, 0, 0, a1);
}

//----- (1001D240) --------------------------------------------------------
char __cdecl sub_1001D240(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  *(_BYTE *)(a1 + 11644) = 0;
  sub_1001CED0(a1, a2, a3, a4, a5, a6, a7);
  return sub_1001C9E0(a1, a3, a4, a5, a6);
}

//----- (1001D2B0) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001D2B0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st7@1
  int v8; // eax@1
  signed int v9; // ecx@1
  unsigned __int8 result; // al@3
  int v11; // ecx@4
  float v12; // [sp+2Ch] [bp+10h]@1
  float v13; // [sp+34h] [bp+18h]@1

  *(_BYTE *)(a1 + 11644) = 0;
  sub_1001CED0(a1, a2, a3, a4, a5, a6, a7);
  sub_1001C9E0(a1, a3, a4, a5, a6);
  v7 = a6;
  *(_BYTE *)(a1 + 11445) = 1;
  *(_BYTE *)(a1 + 11544) = 2;
  v8 = a1 + 1376;
  v9 = 50;
  v13 = a6 * 0.5 + a4;
  v12 = v7 * 0.4000000059604645;
  *(float *)(a1 + 10936) = v13;
  *(float *)(a1 + 428) = v13 - 0.5 * v12;
  *(float *)(a1 + 436) = v12;
  do
  {
    v8 += 64;
    --v9;
    *(float *)(v8 - 88) = *(float *)(a1 + 10936) + 4.0;
    *(float *)(v8 - 64) = 0.0;
  }
  while ( v9 );
  *(float *)(a1 + 11296) = v13;
  *(float *)(a1 + 11328) = 0.5;
  sub_1001C950(a3, 0.40000001, a1);
  result = 0;
  if ( *(_BYTE *)(a1 + 1328) )
  {
    do
    {
      v11 = a1 + 20 * result++;
      *(float *)(v11 + 728) = v13 - *(float *)(v11 + 736) * 0.5;
    }
    while ( result < *(_BYTE *)(a1 + 1328) );
  }
  return result;
}

//----- (1001D410) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001D410(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st7@1
  int v8; // eax@1
  signed int v9; // ecx@1
  unsigned __int8 result; // al@3
  int v11; // ecx@4
  float v12; // [sp+2Ch] [bp+10h]@1
  float v13; // [sp+34h] [bp+18h]@1

  *(_BYTE *)(a1 + 11644) = 1;
  sub_1001CED0(a1, a2, a3, a4, a5, a6, a7);
  sub_1001C9E0(a1, a3, a4, a5, a6);
  v7 = a6;
  *(_BYTE *)(a1 + 11445) = 1;
  *(_BYTE *)(a1 + 11544) = 2;
  v8 = a1 + 1376;
  v9 = 50;
  v13 = a6 * 0.5 + a4;
  v12 = v7 * 0.4000000059604645;
  *(float *)(a1 + 10936) = v13;
  *(float *)(a1 + 428) = v13 - 0.5 * v12;
  *(float *)(a1 + 436) = v12;
  do
  {
    v8 += 64;
    --v9;
    *(float *)(v8 - 88) = *(float *)(a1 + 10936) + 4.0;
    *(float *)(v8 - 64) = 0.0;
  }
  while ( v9 );
  *(float *)(a1 + 11296) = v13;
  *(float *)(a1 + 11328) = 0.5;
  sub_1001C950(a3, 0.40000001, a1);
  result = 0;
  if ( *(_BYTE *)(a1 + 1328) )
  {
    do
    {
      v11 = a1 + 20 * result++;
      *(float *)(v11 + 728) = v13 - *(float *)(v11 + 736) * 0.5;
    }
    while ( result < *(_BYTE *)(a1 + 1328) );
  }
  return result;
}

//----- (1001D570) --------------------------------------------------------
char __cdecl sub_1001D570(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  *(_BYTE *)(a1 + 11644) = 1;
  sub_1001CED0(a1, a2, a3, a4, a5, a6, a7);
  return sub_1001C9E0(a1, a3, a4, a5, a6);
}

//----- (1001D5E0) --------------------------------------------------------
char __cdecl sub_1001D5E0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  *(_BYTE *)(a1 + 11644) = 0;
  sub_1001CED0(a1, a2, a3, a4, a5, a6, a7);
  return sub_1001CAD0(a1, a3, a4, a5, a6);
}

//----- (1001D650) --------------------------------------------------------
char __cdecl sub_1001D650(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  *(_BYTE *)(a1 + 11644) = 1;
  sub_1001CED0(a1, a2, a3, a4, a5, a6, a7);
  return sub_1001CAD0(a1, a3, a4, a5, a6);
}

//----- (1001D6C0) --------------------------------------------------------
char __cdecl sub_1001D6C0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  *(_BYTE *)(a1 + 11644) = 0;
  sub_1001CED0(a1, a2, a3, a4, a5, a6, a7);
  return sub_1001CC60(a1, a3, a4, a5, a6);
}

//----- (1001D730) --------------------------------------------------------
char __cdecl sub_1001D730(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  *(_BYTE *)(a1 + 11644) = 1;
  sub_1001CED0(a1, a2, a3, a4, a5, a6, a7);
  return sub_1001CC60(a1, a3, a4, a5, a6);
}

//----- (1001D7A0) --------------------------------------------------------
signed int __cdecl sub_1001D7A0(_BYTE *a1, int a2)
{
  signed int result; // eax@1
  float *v3; // ecx@2
  float *v4; // edi@2
  float *v5; // ecx@6
  int v6; // edx@6

  result = 0;
  if ( *a1 )
  {
    v3 = (float *)(a2 + 436);
    v4 = (float *)(a1 + 12);
    while ( result < 10 )
    {
      ++result;
      *(v3 - 1) = *v4;
      *(_BYTE *)v3 = a1[result + 91];
      ++v4;
      v3 += 2;
      if ( result >= *a1 )
      {
        if ( result >= 10 )
          return result;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    v5 = (float *)(a2 + 8 * result + 436);
    v6 = 10 - result;
    do
    {
      *(v5 - 1) = 9.8999998e24;
      *(_BYTE *)v5 = 10;
      v5 += 2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (1001D810) --------------------------------------------------------
void __usercall sub_1001D810(int a1@<ebx>, int a2)
{
  int v2; // esi@1
  int *v3; // edi@1
  unsigned int **v4; // ebp@1
  unsigned int v5; // eax@4
  float v6; // ST1C_4@5
  char v7; // ST3C_1@5
  signed int v8; // [sp+1Ch] [bp-Ch]@1

  v2 = a1 + 284;
  v3 = (int *)(a1 + 532);
  v4 = (unsigned int **)(a1 + 156);
  v8 = 3;
  do
  {
    if ( *(_BYTE *)(v2 + 8) && *v4 )
    {
      v5 = **v4;
      if ( v5 != 0x7FFFFFFF )
      {
        v6 = (double)v5;
        v7 = sub_10047DE0(v6, a1 + 432, 10, (int)(v3 - 2));
        sub_10047FA0(v7, (_DWORD *)(v2 + 4), (int *)v2, *(_BYTE *)(a1 + 169), *v3);
        sub_1003E0F0(a2, v2 - 8);
      }
    }
    ++v4;
    v3 += 7;
    v2 += 52;
    --v8;
  }
  while ( v8 );
}

//----- (1001D8C0) --------------------------------------------------------
void __usercall sub_1001D8C0(int a1@<esi>, int a2, int a3, int a4, _WORD *a5)
{
  signed int v5; // ebx@1
  unsigned int **v6; // ecx@2
  int *v7; // ebp@2
  unsigned int *v8; // edi@2
  unsigned int v9; // eax@5
  unsigned int v10; // eax@9
  float v11; // ST14_4@10
  char v12; // ST34_1@10
  int v13; // [sp+1Ch] [bp-Ch]@2

  v5 = 0;
  if ( *(_BYTE *)(a1 + 168) )
  {
    v6 = (unsigned int **)(a1 + 156);
    v7 = (int *)(a1 + 532);
    v13 = a1 + 156;
    v8 = (unsigned int *)(a1 + 56);
    do
    {
      if ( v5 >= 3 )
        break;
      if ( *v6 )
      {
        v9 = **v6;
        if ( v9 > *(_DWORD *)(a1 + 20) || v9 < *(_DWORD *)(a1 + 16) )
          *v8 = 0x7FFFFFFF;
        else
          *v8 = v9;
        v10 = **v6;
        if ( v10 != 0x7FFFFFFF )
        {
          v11 = (double)v10;
          v12 = sub_10047DE0(v11, a1 + 432, 10, (int)(v7 - 2));
          sub_10047F10(v12, v8 - 7, (int *)v8 - 6, *(_BYTE *)(a1 + 170), *v7);
        }
        sub_1001DF40(a2, a3, a4, (int)(v8 - 8), a5);
        v6 = (unsigned int **)v13;
      }
      ++v5;
      ++v6;
      v7 += 7;
      v8 += 11;
      v13 = (int)v6;
    }
    while ( v5 < *(_BYTE *)(a1 + 168) );
  }
}

//----- (1001D9C0) --------------------------------------------------------
void __usercall sub_1001D9C0(int a1@<edi>, int a2)
{
  unsigned __int8 v2; // bl@1
  unsigned int **v3; // ebp@1
  int v4; // esi@1
  unsigned int v5; // eax@3
  float v6; // ST0C_4@4
  char v7; // al@4
  _DWORD *v8; // esi@7
  signed int v9; // ebx@7
  unsigned __int8 v10; // [sp+1Fh] [bp-9h]@1
  char v11; // [sp+20h] [bp-8h]@1

  v11 = 0;
  v10 = 0;
  v2 = 0;
  v3 = (unsigned int **)(a1 + 156);
  v4 = a1 + 524;
  do
  {
    if ( *v3 )
    {
      v5 = **v3;
      if ( v5 != 0x7FFFFFFF )
      {
        v6 = (double)v5;
        v7 = sub_10047DE0(v6, a1 + 432, 10, v4);
        if ( (unsigned __int8)v11 < (unsigned __int8)v7 )
        {
          v11 = v7;
          v10 = v2;
        }
      }
    }
    ++v2;
    ++v3;
    v4 += 28;
  }
  while ( v2 < 3u );
  v8 = (_DWORD *)(a1 + 184);
  v9 = 2;
  do
  {
    sub_10047FA0(v11, v8, v8 - 1, *(_BYTE *)(a1 + 171), *(_DWORD *)(a1 + 28 * (v10 + 19)));
    sub_1003E0F0(a2, (int)(v8 - 3));
    v8 += 13;
    --v9;
  }
  while ( v9 );
}

//----- (1001DA90) --------------------------------------------------------
int __usercall sub_1001DA90@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st6@1
  _DWORD *v8; // ebp@1
  int v9; // ebx@1
  float *v10; // esi@1
  double v11; // st5@1
  int v12; // eax@2
  double v13; // st7@3
  double v14; // st6@3
  double v15; // st5@3
  double v16; // st4@3
  double v17; // st3@3
  int v18; // eax@3
  signed int v19; // ecx@3
  double v20; // rt0@4
  double v21; // st3@4
  double v22; // rt1@4
  double v23; // st3@4
  double v24; // rtt@4
  double v25; // st3@4
  double v26; // rt0@4
  double v27; // rt1@5
  double v28; // st3@5
  double v29; // st6@5
  double v30; // rtt@5
  double v31; // st3@5
  double v32; // st4@5
  double v33; // st5@5
  double v34; // st3@5
  double v35; // st7@5
  double v36; // st7@6
  double v37; // st6@6
  double v38; // st5@6
  int v39; // eax@6
  double v40; // st4@6
  signed int v41; // ecx@6
  double v42; // st3@6
  double v43; // rt2@7
  double v44; // st3@7
  double v45; // st5@7
  double v46; // rtt@7
  double v47; // st3@7
  double v48; // rt0@7
  double v49; // st3@7
  double v50; // rt1@7
  double v51; // st3@7
  double v52; // rt2@7
  double v53; // rtt@8
  double v54; // st3@8
  double v55; // st6@8
  double v56; // rt0@8
  double v57; // st3@8
  double v58; // st7@8
  double v59; // rt1@8
  double v60; // st3@8
  double v61; // st5@8
  double v62; // rt2@8
  double v63; // st3@8
  double v64; // st4@8
  double v65; // rtt@8
  double v66; // st3@8
  double v67; // st6@8
  float v69; // [sp+2Ch] [bp+14h]@1
  float v70; // [sp+30h] [bp+18h]@2

  *(float *)a1 = a4;
  *(float *)(a1 + 4) = a5;
  v7 = a6;
  v8 = (_DWORD *)(a1 + 156);
  v9 = a1 + 524;
  *(float *)(a1 + 8) = a6;
  *(float *)(a1 + 12) = a7;
  v10 = (float *)(a1 + 64);
  *(_DWORD *)(a1 + 16) = (signed __int64)*(float *)(a3 + 4);
  v11 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 168) = 1;
  *(_DWORD *)(a1 + 20) = (signed __int64)v11;
  LODWORD(v69) = 3;
  do
  {
    *((_WORD *)v10 - 20) = 4142;
    v70 = a4 + v7;
    *(v10 - 1) = v70;
    *((_DWORD *)v10 - 9) = -1;
    *((_DWORD *)v10 - 8) = 0;
    *v10 = a5;
    *(v10 - 7) = 15.0;
    *(v10 - 6) = 0.0;
    v12 = sub_10038970(15.0);
    *(v10 - 4) = 1.0;
    *((_DWORD *)v10 - 5) = v12;
    *(v10 - 3) = 1.0;
    *((_DWORD *)v10 - 2) = 0x7FFFFFFF;
    sub_10048030(v9);
    *v8 = 0;
    ++v8;
    v10 += 11;
    v9 += 28;
    --LODWORD(v69);
  }
  while ( v69 != 0.0 );
  v13 = 12.0;
  v14 = a5;
  v15 = a4;
  *(_WORD *)(a1 + 512) = 39;
  v16 = 0.0;
  *(_DWORD *)(a1 + 516) = &unk_100984F8;
  v17 = 1.0;
  *(_BYTE *)(a1 + 520) = 1;
  v18 = a1 + 176;
  v19 = 3;
  while ( 1 )
  {
    v27 = v17;
    *(_DWORD *)(v18 + 4) = 0;
    *(float *)(v18 - 4) = v15;
    *(_DWORD *)(v18 + 8) = -1;
    v28 = v14;
    v29 = v15;
    *(_BYTE *)(v18 + 12) = 0;
    *(float *)v18 = v28;
    v18 += 52;
    --v19;
    v30 = v28;
    v31 = v16;
    v32 = v30;
    *(float *)(v18 - 16) = v31;
    v33 = v31;
    *(float *)(v18 - 12) = v27;
    v34 = v13;
    v35 = v27;
    *(float *)(v18 - 8) = v34;
    if ( !v19 )
      break;
    v20 = v34;
    v21 = v35;
    v13 = v20;
    v22 = v21;
    v23 = v29;
    v14 = v32;
    v24 = v23;
    v25 = v33;
    v15 = v24;
    v26 = v25;
    v17 = v22;
    v16 = v26;
  }
  sub_10038450(a1 + 188, (_BYTE *)a2, 21);
  v36 = a5;
  v37 = a4;
  v38 = 0.0;
  v39 = a1 + 280;
  v40 = 1.0;
  v41 = 3;
  v42 = 12.0;
  while ( 1 )
  {
    v53 = v42;
    v54 = v37;
    v55 = v53;
    *(_DWORD *)(v39 + 4) = 0;
    *(float *)(v39 - 4) = v54;
    *(_DWORD *)(v39 + 8) = -1;
    v56 = v54;
    v57 = v36;
    v58 = v56;
    *(_BYTE *)(v39 + 12) = 0;
    *(float *)v39 = v57;
    v39 += 52;
    --v41;
    v59 = v57;
    v60 = v38;
    v61 = v59;
    *(float *)(v39 - 16) = v60;
    v62 = v60;
    v63 = v40;
    v64 = v62;
    *(float *)(v39 - 12) = v63;
    v65 = v63;
    v66 = v55;
    v67 = v65;
    *(float *)(v39 - 8) = v66;
    if ( !v41 )
      break;
    v43 = v66;
    v44 = v61;
    v45 = v43;
    v46 = v44;
    v47 = v58;
    v36 = v46;
    v48 = v47;
    v49 = v67;
    v37 = v48;
    v50 = v49;
    v51 = v64;
    v40 = v50;
    v52 = v51;
    v42 = v45;
    v38 = v52;
  }
  *(_WORD *)(a1 + 169) = 0;
  *(_BYTE *)(a1 + 171) = 0;
  return sub_1001D7A0((_BYTE *)a3, a1);
}

//----- (1001DCC0) --------------------------------------------------------
char __cdecl sub_1001DCC0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_1001D9C0(a4, a1);
      sub_1001D810(a4, a1);
      sub_1001D8C0(a4, a1, a2, a3, a5);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_1001D9C0(a4, a1);
      sub_1001D810(a4, a1);
      sub_1001D8C0(a4, a1, a2, a3, a5);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (1001DDC0) --------------------------------------------------------
int __cdecl sub_1001DDC0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  return sub_1001DA90(a1, a2, a3, a4, a5, a6, a7);
}

//----- (1001DE00) --------------------------------------------------------
__int16 __usercall sub_1001DE00@<ax>(int a1@<eax>, int a2@<esi>)
{
  unsigned int v2; // ecx@1
  unsigned int v3; // ecx@1
  __int16 result; // ax@1

  v2 = *(_DWORD *)(a1 + 32);
  *(_WORD *)a2 = v2 / 0xE10;
  v3 = -3600 * (signed __int16)(v2 / 0xE10) + v2;
  *(_BYTE *)(a2 + 2) = v3 / 0x3C;
  result = 60 * (char)(v3 / 0x3C);
  *(_BYTE *)(a2 + 3) = v3 % 0x3C;
  return result;
}

//----- (1001DE40) --------------------------------------------------------
const char *__usercall sub_1001DE40@<eax>(const char *result@<eax>, unsigned __int8 a2@<bl>, char *a3)
{
  int v3; // edi@1
  char v4; // cl@11
  int v5; // [sp+8h] [bp-4h]@4

  v3 = *result & 0x3F;
  if ( v3 < 46 || v3 > 49 )
  {
    *a3 = 0;
  }
  else if ( *((_DWORD *)result + 8) >= 0x7FFFFFFFu )
  {
    result = "__:__:__";
    do
    {
      v4 = *result;
      result[a3 - "__:__:__"] = *result;
      ++result;
    }
    while ( v4 );
    if ( v3 == 46 || v3 == 47 )
      a3[5] = 0;
  }
  else
  {
    sub_1001DE00((int)result, (int)&v5);
    if ( v3 == 47 )
    {
      if ( !(_WORD)v5 )
        return (const char *)sub_10038570(
                               a3,
                               a2,
                               "%02u:%c%c",
                               BYTE2(v5),
                               (unsigned __int8)(BYTE3(v5) / 10 + 48),
                               (unsigned __int8)((unsigned __int16)(BYTE3(v5) % 10) + 48));
    }
    else if ( v3 != 46 )
    {
      return (const char *)_snprintf(a3, a2, "%01u:%02u:%02u", (signed __int16)v5, BYTE2(v5), BYTE3(v5));
    }
    result = (const char *)_snprintf(a3, a2, "%01u:%02u", (signed __int16)v5, BYTE2(v5));
  }
  return result;
}

//----- (1001DF40) --------------------------------------------------------
char __cdecl sub_1001DF40(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // ecx@3
  int v6; // edx@3
  double v7; // st7@3
  double v8; // st7@3
  int v9; // edx@3
  float v11; // [sp+4h] [bp-34h]@3
  float v12; // [sp+8h] [bp-30h]@3
  int v13; // [sp+Ch] [bp-2Ch]@3
  float v14; // [sp+10h] [bp-28h]@3
  int v15; // [sp+14h] [bp-24h]@3
  int v16; // [sp+18h] [bp-20h]@3
  float v17; // [sp+1Ch] [bp-1Ch]@3
  float v18; // [sp+20h] [bp-18h]@3
  float v19; // [sp+24h] [bp-14h]@3
  char v20; // [sp+28h] [bp-10h]@3

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v5 = *(_DWORD *)(a4 + 4);
    v6 = *(_DWORD *)(a4 + 8);
    v14 = *(float *)(a4 + 12);
    v7 = *(float *)(a4 + 24);
    v16 = v5;
    v17 = v7;
    v8 = *(float *)(a4 + 28);
    v15 = v6;
    v9 = *(_DWORD *)(a4 + 20);
    v18 = v8;
    v19 = *(float *)(a4 + 16);
    v11 = *(float *)(a4 + 36);
    v13 = v9;
    v12 = *(float *)(a4 + 40);
    sub_1001DE40((const char *)a4, 0xCu, &v20);
    sub_100393C0(a1, (int)&v20, (int)&v11);
    *(_BYTE *)(a1 + 6) = 2;
  }
  return 1;
}

//----- (1001DFF0) --------------------------------------------------------
char __usercall sub_1001DFF0@<al>(int ebx0@<ebx>, int a1, int a2, int a3, int *a4, _WORD *a5)
{
  char result; // al@4
  void *v7; // eax@7
  int v8; // edi@7
  float v9; // ST58_4@7
  double v10; // st7@7
  double v11; // st7@7
  double v12; // st7@7
  double v13; // st7@7
  double v14; // st7@7
  int v15; // edi@7
  unsigned int v16; // esi@7
  float v17; // ST58_4@14
  int v18; // ebx@14
  unsigned int v19; // esi@14
  float v20; // ST58_4@16
  float v21; // ST40_4@16
  float v22; // ST58_4@16
  float v23; // ST58_4@16
  float v24; // ST40_4@16
  float v25; // ST58_4@16
  float v26; // ST58_4@16
  float v27; // ST58_4@16
  float v28; // ST40_4@16
  float v29; // ST58_4@16
  float v30; // ST58_4@16
  float v31; // ST40_4@16
  float v32; // ST58_4@16
  float v33; // ST3C_4@16
  float v34; // ST58_4@16
  float v35; // ST58_4@16
  float v36; // ST40_4@16
  float v37; // ST58_4@16
  float v38; // ST58_4@16
  float v39; // ST40_4@16
  float v40; // ST58_4@16
  float v41; // ST58_4@16
  float v42; // ST40_4@16
  float v43; // ST58_4@16
  float v44; // ST58_4@16
  float v45; // ST40_4@16
  float v46; // ST58_4@16
  float v47; // ST3C_4@16
  float v48; // ST58_4@16
  float v49; // ST58_4@16
  float v50; // ST40_4@16
  float v51; // ST58_4@16
  float v52; // ST58_4@16
  float v53; // ST40_4@16
  float v54; // ST58_4@16
  float v55; // ST58_4@16
  float v56; // ST40_4@16
  float v57; // ST58_4@16
  float v58; // ST58_4@16
  float v59; // ST40_4@16
  float v60; // ST58_4@16
  unsigned int v61; // esi@16
  float v62; // ST5C_4@18
  float v63; // ST44_4@18
  float v64; // ST5C_4@18
  float v65; // ST5C_4@18
  float v66; // ST44_4@18
  float v67; // ST5C_4@18
  float v68; // ST5C_4@18
  float v69; // ST5C_4@18
  float v70; // ST44_4@18
  float v71; // ST5C_4@18
  float v72; // ST5C_4@18
  float v73; // ST44_4@18
  float v74; // ST5C_4@18
  float v75; // ST40_4@18
  float v76; // ST60_4@18
  float v77; // ST60_4@18
  float v78; // ST48_4@18
  float v79; // ST60_4@18
  float v80; // ST60_4@18
  float v81; // ST48_4@18
  float v82; // ST60_4@18
  float v83; // ST60_4@18
  float v84; // ST48_4@18
  float v85; // ST60_4@18
  float v86; // ST60_4@18
  float v87; // ST48_4@18
  float v88; // ST60_4@18
  float v89; // ST44_4@18
  float v90; // ST60_4@18
  float v91; // ST60_4@18
  float v92; // ST48_4@18
  float v93; // ST60_4@18
  float v94; // ST60_4@18
  float v95; // ST48_4@18
  float v96; // ST60_4@18
  float v97; // ST60_4@18
  float v98; // ST48_4@18
  float v99; // ST60_4@18
  float v100; // ST60_4@18
  float v101; // ST60_4@18
  double v102; // st7@18
  char *v103; // eax@19
  char v104; // cl@20
  float v105; // ST5C_4@22
  float v106; // ST60_4@22
  float v107; // ST58_4@22
  signed int v108; // ST58_4@22
  float v109; // ST58_4@22
  signed int v110; // eax@25
  float v111; // ST48_4@26
  float v112; // ST44_4@26
  float v113; // ST60_4@26
  float v114; // ST60_4@26
  float v115; // ST44_4@27
  float v116; // [sp+10h] [bp-88h]@0
  float v117; // [sp+14h] [bp-84h]@18
  int v118; // [sp+18h] [bp-80h]@0
  char v119; // [sp+23h] [bp-75h]@0
  float v120; // [sp+28h] [bp-70h]@14
  float v121; // [sp+2Ch] [bp-6Ch]@14
  int v122; // [sp+30h] [bp-68h]@7
  float v123; // [sp+34h] [bp-64h]@7
  int v124; // [sp+38h] [bp-60h]@7
  float v125; // [sp+3Ch] [bp-5Ch]@16
  float v126; // [sp+40h] [bp-58h]@7
  float v127; // [sp+44h] [bp-54h]@7
  float v128; // [sp+48h] [bp-50h]@7
  float v129; // [sp+4Ch] [bp-4Ch]@7
  float v130; // [sp+50h] [bp-48h]@7
  float v131; // [sp+54h] [bp-44h]@16
  float v132; // [sp+58h] [bp-40h]@7
  float v133; // [sp+5Ch] [bp-3Ch]@16
  float v134; // [sp+60h] [bp-38h]@7
  float v135; // [sp+64h] [bp-34h]@7
  float v136; // [sp+68h] [bp-30h]@7
  float v137; // [sp+6Ch] [bp-2Ch]@7
  float v138; // [sp+70h] [bp-28h]@7
  float v139; // [sp+74h] [bp-24h]@16
  float v140; // [sp+78h] [bp-20h]@7
  float v141; // [sp+7Ch] [bp-1Ch]@16
  float v142; // [sp+80h] [bp-18h]@7
  float v143; // [sp+84h] [bp-14h]@7
  float v144; // [sp+88h] [bp-10h]@7
  float v145; // [sp+8Ch] [bp-Ch]@16
  float v146; // [sp+90h] [bp-8h]@7
  float v147; // [sp+94h] [bp-4h]@16
  float vars0; // [sp+98h] [bp+0h]@18

  j_gdi_pvg_push_attrib(0x2000);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32833 )
    {
      if ( *(_BYTE *)(a2 + 20) && a4 )
      {
        v7 = (void *)sub_10002860(a1, 96);
        *a4 = (int)v7;
        memset(v7, 0, 0x60u);
        v8 = *a4;
        v122 = *(int *)(a2 + 12);
        v123 = *(float *)(a2 + 8);
        sub_10070A20((int)&v122, (int)&v122);
        v9 = *(float *)(a2 + 16) * 0.5;
        sub_100709C0(v9, (int)&v122, (int)&v122);
        sub_10070A00((int)&v122, (int)&v140);
        v10 = *(float *)(a2 + 24) * 0.5;
        v142 = *(float *)(a2 + 8) * v10 + *(float *)&v122;
        v143 = v10 * *(float *)(a2 + 12) + v123;
        sub_100709E0((int)&v140, (int)&v122, (int)&v146);
        sub_100709E0((int)&v142, (int)&v122, (int)&v144);
        sub_10070A00((int)&v142, (int)&v124);
        sub_10070A00((int)&v124, (int)&v126);
        v11 = 1.0 - *(float *)(a2 + 24);
        v126 = *(float *)(a2 + 8) * v11 + v126;
        v127 = v11 * *(float *)(a2 + 12) + v127;
        sub_10070A00((int)&v144, (int)&v130);
        sub_10070A00((int)&v130, (int)&v128);
        v12 = 1.0 - *(float *)(a2 + 24);
        v128 = *(float *)(a2 + 8) * v12 + v128;
        v129 = v12 * *(float *)(a2 + 12) + v129;
        sub_10070A00((int)&v126, (int)&v132);
        sub_10070A00((int)&v132, (int)&v134);
        v13 = *(float *)(a2 + 24) * 0.5;
        v134 = *(float *)(a2 + 8) * v13 + v134;
        v135 = v13 * *(float *)(a2 + 12) + v135;
        sub_10070A00((int)&v128, (int)&v138);
        sub_10070A00((int)&v138, (int)&v136);
        v14 = *(float *)(a2 + 24) * 0.5;
        v15 = v8 + 64;
        v136 = *(float *)(a2 + 8) * v14 + v136;
        v16 = 0;
        v137 = v14 * *(float *)(a2 + 12) + v137;
        do
        {
          sub_10070A00((int)&v140 + v16, v15 - 64);
          sub_10070A00((int)&v124 + v16, v15 - 32);
          sub_10070A00((int)&v132 + v16, v15);
          v16 += 8;
          v15 += 8;
        }
        while ( v16 < 0x20 );
        j_gdi_pvg_pop_attrib();
        result = 2;
      }
      else
      {
        j_gdi_pvg_pop_attrib();
        result = v119;
      }
      return result;
    }
    if ( *a5 != 32888 )
    {
      j_gdi_pvg_pop_attrib();
      return 1;
    }
  }
  if ( *(_BYTE *)(a2 + 20) && *(float *)(a2 + 16) >= 2.0 && a4 && (ebx0 = *a4) != 0 )
  {
    v120 = (double)*(_WORD *)a3;
    v121 = (double)*(_WORD *)(a3 + 2);
    v122 = *(int *)(a2 + 12);
    v123 = *(float *)(a2 + 8);
    sub_10070A20((int)&v122, (int)&v122);
    v17 = *(float *)(a2 + 16) * 0.5;
    sub_100709C0(v17, (int)&v122, (int)&v122);
    v18 = ebx0 + 64;
    v19 = 0;
    do
    {
      sub_10070A00(v18 - 64, (int)&v140 + v19);
      sub_10070A00(v18 - 32, (int)&v124 + v19);
      sub_10070A00(v18, (int)&v132 + v19);
      v19 += 8;
      v18 += 8;
    }
    while ( v19 < 0x20 );
    j_gdi_pvg_begin(72);
    sub_10015610(1.0, 1.0, 1.0, 0.0);
    v20 = v141 + v121;
    v21 = v20;
    v22 = v140 + v120;
    sub_10015960(v22, v21);
    v23 = v147 + v121;
    v24 = v23;
    v25 = v146 + v120;
    sub_10015960(v25, v24);
    v26 = (double)*(_BYTE *)(a2 + 7) * 0.300000011920929 / 255.0;
    sub_10015610(1.0, 1.0, 1.0, v26);
    v27 = v145 + v121;
    v28 = v27;
    v29 = v144 + v120;
    sub_10015960(v29, v28);
    v30 = v121 + v143;
    v31 = v30;
    v32 = v120 + v142;
    sub_10015960(v32, v31);
    j_gdi_pvg_end(LODWORD(v33));
    v34 = (double)*(_BYTE *)(a2 + 7) * 0.300000011920929 / 255.0;
    sub_10015610(1.0, 1.0, 1.0, v34);
    j_gdi_pvg_begin(72);
    v35 = v125 + v121;
    v36 = v35;
    v37 = *(float *)&v124 + v120;
    sub_10015960(v37, v36);
    v38 = v131 + v121;
    v39 = v38;
    v40 = v130 + v120;
    sub_10015960(v40, v39);
    v41 = v121 + v129;
    v42 = v41;
    v43 = v120 + v128;
    sub_10015960(v43, v42);
    v44 = v121 + v127;
    v45 = v44;
    v46 = v120 + v126;
    sub_10015960(v46, v45);
    j_gdi_pvg_end(LODWORD(v47));
    j_gdi_pvg_begin(72);
    v48 = (double)*(_BYTE *)(a2 + 7) * 0.300000011920929 / 255.0;
    sub_10015610(1.0, 1.0, 1.0, v48);
    v49 = v133 + v121;
    v50 = v49;
    v51 = v132 + v120;
    sub_10015960(v51, v50);
    v52 = v139 + v121;
    v53 = v52;
    v54 = v138 + v120;
    sub_10015960(v54, v53);
    sub_10015610(1.0, 1.0, 1.0, 0.0);
    v55 = v121 + v137;
    v56 = v55;
    v57 = v120 + v136;
    sub_10015960(v57, v56);
    v58 = v121 + v135;
    v59 = v58;
    v60 = v120 + v134;
    sub_10015960(v60, v59);
    j_gdi_pvg_end(LODWORD(v116));
    v61 = 0;
    do
    {
      sub_100709E0((int)&v140 + v61, (int)&v122, (int)&v140 + v61);
      sub_100709E0((int)&v124 + v61, (int)&v122, (int)&v124 + v61);
      sub_100709E0((int)&v132 + v61, (int)&v122, (int)&v132 + v61);
      v61 += 8;
    }
    while ( v61 < 0x20 );
    j_gdi_pvg_begin(72);
    sub_10015610(0.0, 0.0, 0.0, 0.0);
    v62 = v142 + *(float *)&v122;
    v63 = v62;
    v64 = v141 + v121;
    sub_10015960(v64, v63);
    v65 = vars0 + *(float *)&v122;
    v66 = v65;
    v67 = v147 + v121;
    sub_10015960(v67, v66);
    v68 = (double)*(_BYTE *)(a2 + 7) / 255.0;
    sub_10015610(0.0, 0.0, 0.0, v68);
    v69 = v146 + *(float *)&v122;
    v70 = v69;
    v71 = v145 + v121;
    sub_10015960(v71, v70);
    v72 = *(float *)&v122 + v144;
    v73 = v72;
    v74 = v121 + v143;
    sub_10015960(v74, v73);
    j_gdi_pvg_end(LODWORD(v75));
    v76 = (double)*(_BYTE *)(a2 + 7) / 255.0;
    sub_10015610(0.0, 0.0, 0.0, v76);
    j_gdi_pvg_begin(72);
    v77 = v127 + v123;
    v78 = v77;
    v79 = v126 + *(float *)&v122;
    sub_10015960(v79, v78);
    v80 = v133 + v123;
    v81 = v80;
    v82 = v132 + *(float *)&v122;
    sub_10015960(v82, v81);
    v83 = v123 + v131;
    v84 = v83;
    v85 = *(float *)&v122 + v130;
    sub_10015960(v85, v84);
    v86 = v123 + v129;
    v87 = v86;
    v88 = *(float *)&v122 + v128;
    sub_10015960(v88, v87);
    j_gdi_pvg_end(LODWORD(v89));
    j_gdi_pvg_begin(72);
    v90 = (double)*(_BYTE *)(a2 + 7) / 255.0;
    sub_10015610(0.0, 0.0, 0.0, v90);
    v91 = v135 + v123;
    v92 = v91;
    v93 = v134 + *(float *)&v122;
    sub_10015960(v93, v92);
    v94 = v141 + v123;
    v95 = v94;
    v96 = v140 + *(float *)&v122;
    sub_10015960(v96, v95);
    sub_10015610(0.0, 0.0, 0.0, 0.0);
    v97 = v123 + v139;
    v98 = v97;
    v99 = *(float *)&v122 + v138;
    sub_10015960(v99, v98);
    v100 = v123 + v137;
    v117 = v100;
    v101 = *(float *)&v122 + v136;
    v102 = v101;
  }
  else
  {
    v103 = (char *)(a2 + 28);
    do
      v104 = *v103++;
    while ( v104 );
    if ( v103 != (char *)(a2 + 29) )
    {
      v105 = (double)*(_WORD *)a3;
      v106 = (double)*(_WORD *)(a3 + 2);
      v122 = *(int *)(a2 + 12);
      v123 = -*(float *)(a2 + 8);
      sub_10070A20((int)&v122, (int)&v122);
      v107 = *(float *)(a2 + 16) * 0.5;
      sub_100709C0(v107, (int)&v122, (int)&v122);
      v124 = v122;
      v125 = v123;
      v126 = *(float *)&v122 + *(float *)(a2 + 8);
      v127 = v123 + *(float *)(a2 + 12);
      sub_100709C0(-2.0, (int)&v122, (int)&v122);
      v108 = *(_BYTE *)(a2 + 7);
      v130 = *(float *)&v124 + *(float *)&v122;
      v131 = v125 + v123;
      v128 = *(float *)&v122 + v126;
      v129 = v123 + v127;
      v109 = (double)v108 / 255.0;
      sub_100480D0(ebx0, v105, v106, *(_DWORD *)(a1 + 80), (int)&v124, a2 + 28, v109, 0);
      j_gdi_pvg_pop_attrib();
      return 2;
    }
    if ( *(_BYTE *)(a2 + 78) & 1 )
    {
      j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 4));
    }
    else
    {
      v110 = sub_10047D20(*(_DWORD *)(a2 + 4));
      j_gdi_pvg_color_u32(v110);
    }
    sub_10015770(*(float *)(a2 + 16));
    j_gdi_pvg_begin(64);
    v111 = (double)*(_WORD *)(a3 + 2);
    v112 = (double)*(_WORD *)a3;
    sub_10015960(v112, v111);
    v113 = *(float *)(a2 + 12) + (double)*(_WORD *)(a3 + 2);
    v117 = v113;
    v114 = *(float *)(a2 + 8) + (double)*(_WORD *)a3;
    v102 = v114;
  }
  v115 = v102;
  sub_10015960(v115, v117);
  j_gdi_pvg_end(v118);
  j_gdi_pvg_pop_attrib();
  return 2;
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10015800: using guessed type int j_gdi_pvg_pop_attrib(void);
// 10015820: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);

//----- (1001EBE0) --------------------------------------------------------
signed int __cdecl sub_1001EBE0(_BYTE *a1, int a2)
{
  signed int result; // eax@1
  float *v3; // ecx@2
  float *v4; // edi@2
  float *v5; // ecx@6
  int v6; // edx@6

  result = 0;
  if ( *a1 )
  {
    v3 = (float *)(a2 + 440);
    v4 = (float *)(a1 + 12);
    while ( result < 10 )
    {
      ++result;
      *(v3 - 1) = *v4;
      *(_BYTE *)v3 = a1[result + 91];
      ++v4;
      v3 += 2;
      if ( result >= *a1 )
      {
        if ( result >= 10 )
          return result;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    v5 = (float *)(a2 + 8 * result + 440);
    v6 = 10 - result;
    do
    {
      *(v5 - 1) = 9.8999998e24;
      *(_BYTE *)v5 = 10;
      v5 += 2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (1001EC50) --------------------------------------------------------
signed int __cdecl sub_1001EC50(int a1, signed int a2, int a3)
{
  signed int result; // eax@1
  int *v4; // edx@2
  int v5; // ecx@2

  result = 0;
  if ( a2 > 0 )
  {
    v4 = (int *)(a3 + 48);
    v5 = a1 + 8;
    do
    {
      if ( result >= 3 )
        break;
      *v4 = v5;
      ++result;
      v5 += 12;
      v4 += 12;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (1001EC90) --------------------------------------------------------
int __cdecl sub_1001EC90(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)(a2 + 52) = *(float *)a1;
  *(float *)(a2 + 56) = *(float *)(a1 + 4);
  *(float *)(a2 + 100) = *(float *)a1;
  *(float *)(a2 + 104) = *(float *)(a1 + 4);
  *(float *)(a2 + 148) = *(float *)a1;
  *(float *)(a2 + 152) = *(float *)(a1 + 4);
  return result;
}

//----- (1001ECC0) --------------------------------------------------------
void __usercall sub_1001ECC0(int a1@<eax>, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // bl@1
  float **v4; // ebp@1
  int v5; // edi@1
  float *v6; // ecx@2
  char v7; // al@4
  unsigned __int8 v8; // [sp+23h] [bp-5h]@1
  char v9; // [sp+24h] [bp-4h]@1

  v2 = a1;
  v9 = 0;
  v8 = 0;
  v3 = 0;
  v4 = (float **)(a1 + 48);
  v5 = a1 + 528;
  do
  {
    v6 = *v4;
    if ( *v4 )
    {
      if ( 9.8999998e24 != *v6 )
      {
        v7 = sub_10047DE0(*v6, v2 + 436, 10, v5);
        if ( (unsigned __int8)v9 < (unsigned __int8)v7 )
        {
          v9 = v7;
          v8 = v3;
        }
      }
    }
    ++v3;
    v5 += 28;
    v4 += 12;
  }
  while ( v3 < 3u );
  sub_10047FA0(v9, (_DWORD *)(v2 + 188), (int *)(v2 + 184), *(_BYTE *)(v2 + 175), *(_DWORD *)(v2 + 28 * v8 + 536));
  sub_10047FA0(v9, (_DWORD *)(v2 + 240), (int *)(v2 + 236), *(_BYTE *)(v2 + 175), *(_DWORD *)(v2 + 28 * v8 + 536));
  sub_1003E0F0(a2, v2 + 176);
  sub_1003E0F0(a2, v2 + 228);
}

//----- (1001EDB0) --------------------------------------------------------
int __usercall sub_1001EDB0@<eax>(int a1@<edi>, int a2, int a3, float a4, float a5, float a6, float a7)
{
  int v7; // eax@1
  double v8; // st6@1
  int v9; // ebp@1
  int v10; // esi@1
  double v11; // st5@1
  char *v12; // eax@4
  char v13; // cl@5
  int v14; // eax@6
  signed int v15; // ecx@6
  double v16; // st6@6
  double v17; // st5@6
  double v18; // st4@6
  double v19; // st3@6
  double v20; // st7@6
  double v21; // rt1@7
  double v22; // st3@7
  double v23; // rtt@7
  double v24; // rt0@8
  double v25; // st3@8
  double v26; // st6@8
  double v27; // rt1@8
  double v28; // st3@8
  double v29; // st5@8
  double v30; // rt2@8
  double v31; // st3@8
  double v32; // st4@8
  double v33; // rtt@8
  double v34; // st3@8
  double v35; // st7@8
  double v36; // rt0@8
  double v37; // st3@8
  double v38; // st6@8
  float v40; // [sp+14h] [bp+14h]@1
  float v41; // [sp+18h] [bp+18h]@3

  v7 = a3;
  *(float *)a1 = a4;
  *(float *)(a1 + 4) = a5;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = a6;
  *(float *)(a1 + 8) = a6;
  v9 = a1 + 528;
  *(float *)(a1 + 12) = a7;
  v10 = a1 + 32;
  LODWORD(v40) = 3;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  v11 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 172) = 1;
  *(float *)(a1 + 24) = v11;
  while ( 1 )
  {
    *(_DWORD *)(v10 + 4) = 0;
    v41 = a4 + v8;
    *(float *)(v10 - 4) = v41;
    *(_DWORD *)(v10 + 8) = -1;
    *(_DWORD *)(v10 + 12) = -1;
    *(float *)v10 = a5;
    *(_BYTE *)(v10 + 42) = 0;
    *(float *)(v10 + 20) = *(float *)(v7 + 4);
    *(float *)(v10 + 24) = *(float *)(v7 + 8);
    *(_DWORD *)(v10 + 16) = 0;
    *(_BYTE *)(v10 + 41) = 0;
    *(_BYTE *)(v10 + 40) = 0;
    *(float *)(v10 + 28) = 1.0;
    *(float *)(v10 + 32) = 1.0;
    *(float *)(v10 + 36) = 15.0;
    sub_10048030(v9);
    v10 += 48;
    v9 += 28;
    --LODWORD(v40);
    if ( v40 == 0.0 )
      break;
    v7 = a3;
  }
  v12 = (char *)a2;
  *(float *)(a1 + 176) = a4;
  *(float *)(a1 + 180) = a5;
  *(_WORD *)(a1 + 516) = 12;
  *(_DWORD *)(a1 + 520) = &unk_100984F8;
  *(_BYTE *)(a1 + 524) = 1;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = -1;
  do
  {
    v13 = *v12;
    v12[a1 - a2 + 192] = *v12;
    ++v12;
  }
  while ( v13 );
  *(_DWORD *)(a1 + 236) = 0;
  *(float *)(a1 + 216) = 0.0;
  *(_DWORD *)(a1 + 240) = -1;
  *(_BYTE *)(a1 + 244) = 0;
  *(float *)(a1 + 220) = 1.0;
  v14 = a1 + 284;
  v15 = 3;
  *(float *)(a1 + 224) = 12.0;
  *(float *)(a1 + 228) = a4;
  v16 = a4;
  *(float *)(a1 + 232) = a5;
  v17 = a5;
  *(float *)(a1 + 268) = 0.0;
  v18 = 0.0;
  *(float *)(a1 + 272) = 1.0;
  v19 = 12.0;
  v20 = 1.0;
  *(float *)(a1 + 276) = 12.0;
  while ( 1 )
  {
    v24 = v19;
    v25 = v16;
    v26 = v24;
    *(_DWORD *)(v14 + 4) = 0;
    *(float *)(v14 - 4) = v25;
    *(_DWORD *)(v14 + 8) = -1;
    v27 = v25;
    v28 = v17;
    v29 = v27;
    *(_BYTE *)(v14 + 12) = 0;
    *(float *)v14 = v28;
    v14 += 52;
    --v15;
    v30 = v28;
    v31 = v18;
    v32 = v30;
    *(float *)(v14 - 16) = v31;
    v33 = v31;
    v34 = v20;
    v35 = v33;
    *(float *)(v14 - 12) = v34;
    v36 = v34;
    v37 = v26;
    v38 = v36;
    *(float *)(v14 - 8) = v37;
    if ( !v15 )
      break;
    v21 = v37;
    v22 = v35;
    v20 = v38;
    v23 = v22;
    v16 = v29;
    v17 = v32;
    v19 = v21;
    v18 = v23;
  }
  *(_WORD *)(a1 + 173) = 0;
  *(_BYTE *)(a1 + 175) = 0;
  return sub_1001EBE0((_BYTE *)a3, a1);
}

//----- (1001EF80) --------------------------------------------------------
int __cdecl sub_1001EF80(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  return sub_1001EDB0(a1, a2, a3, a4, a5, a6, a7);
}

//----- (1001EFC0) --------------------------------------------------------
char __cdecl sub_1001EFC0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  double v7; // st7@1
  double v8; // st6@1
  char result; // al@1
  double v10; // st5@1
  double v11; // rt1@1
  double v12; // st5@1
  float v13; // [sp+24h] [bp+10h]@1
  float v14; // [sp+24h] [bp+10h]@1
  float v15; // [sp+24h] [bp+10h]@1
  float v16; // [sp+28h] [bp+14h]@1

  sub_1001EDB0(a1, a2, a3, a4, a5, a6, a7);
  v7 = a4;
  *(float *)(a1 + 28) = a4;
  v8 = a5;
  result = 0;
  *(_BYTE *)(a1 + 172) = 2;
  *(_BYTE *)(a1 + 296) = 0;
  v13 = a5 + a7;
  v10 = v13;
  *(float *)(a1 + 32) = v13;
  *(float *)(a1 + 60) = 0.0;
  *(float *)(a1 + 64) = 1.0;
  *(float *)(a1 + 68) = 15.0;
  v14 = v7 + a6;
  *(float *)(a1 + 76) = v14;
  v11 = v14;
  *(float *)(a1 + 80) = v10;
  *(float *)(a1 + 108) = 1.0;
  *(float *)(a1 + 112) = 1.0;
  *(float *)(a1 + 116) = 15.0;
  v15 = a6 * 0.5 + v7;
  *(float *)(a1 + 176) = v15;
  v16 = a5 - 3.0;
  *(float *)(a1 + 180) = v16;
  *(float *)(a1 + 216) = 0.5;
  *(float *)(a1 + 220) = 1.0;
  *(float *)(a1 + 224) = 12.0;
  *(float *)(a1 + 228) = v15;
  *(float *)(a1 + 232) = v8;
  *(float *)(a1 + 268) = 0.5;
  *(float *)(a1 + 272) = 0.0;
  *(float *)(a1 + 276) = 12.0;
  *(float *)(a1 + 280) = v7;
  *(float *)(a1 + 284) = v16;
  *(float *)(a1 + 320) = 0.0;
  *(float *)(a1 + 324) = 1.0;
  *(_BYTE *)(a1 + 348) = 0;
  *(float *)(a1 + 328) = 12.0;
  *(float *)(a1 + 332) = v11;
  v12 = v16;
  *(float *)(a1 + 336) = *(float *)&v12;
  *(float *)(a1 + 372) = 1.0;
  *(float *)(a1 + 376) = 1.0;
  *(float *)(a1 + 380) = 12.0;
  return result;
}

//----- (1001F130) --------------------------------------------------------
void __cdecl sub_1001F130(int a1, int a2)
{
  int v2; // esi@1
  int *v3; // ebx@1
  int v4; // edi@1
  float *v5; // ecx@3
  char v6; // ST40_1@9
  signed int v7; // [sp+20h] [bp-8h]@1

  v2 = a2 + 288;
  v3 = (int *)(a2 + 536);
  v4 = a2 + 48;
  v7 = 3;
  do
  {
    if ( *(_BYTE *)(v2 + 8) )
    {
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 )
      {
        if ( *(_BYTE *)(v4 + 26)
          || 9.8999998e24 != *v5
          && (!*(_BYTE *)(v4 + 24) || *(float *)(v4 + 4) <= (double)*v5 && *(float *)(v4 + 8) >= (double)*v5) )
        {
          v6 = sub_10047DE0(*v5, a2 + 436, 10, (int)(v3 - 2));
          sub_10047FA0(v6, (_DWORD *)(v2 + 4), (int *)v2, *(_BYTE *)(a2 + 173), *v3);
          sub_1003E0F0(a1, v2 - 8);
        }
      }
    }
    v4 += 48;
    v3 += 7;
    v2 += 52;
    --v7;
  }
  while ( v7 );
}

//----- (1001F200) --------------------------------------------------------
void __usercall sub_1001F200(int a1@<esi>, int a2)
{
  signed int v2; // ebx@1
  int *v3; // ebp@2
  int v4; // edi@2
  float *v5; // ecx@4
  char v6; // ST44_1@11

  v2 = 0;
  if ( *(_BYTE *)(a1 + 172) )
  {
    v3 = (int *)(a1 + 536);
    v4 = a1 + 48;
    do
    {
      if ( v2 >= 3 )
        break;
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4 && *(_BYTE *)(a1 + 174) != 1 )
      {
        if ( !*(_BYTE *)(v4 + 26)
          && (9.8999998e24 == *v5
           || *(_BYTE *)(v4 + 24) && (*(float *)(v4 + 4) > (double)*v5 || *(float *)(v4 + 8) < (double)*v5)) )
        {
          sub_1003C630(v4 - 20);
        }
        else
        {
          v6 = sub_10047DE0(*v5, a1 + 436, 10, (int)(v3 - 2));
          sub_10047F10(v6, (_DWORD *)(v4 - 8), (int *)(v4 - 12), *(_BYTE *)(a1 + 174), *v3);
          sub_1003AD10(a2, v4 - 20, *(_WORD *)(a1 + 516), *(_DWORD *)(a1 + 520), *(_BYTE *)(a1 + 524));
        }
      }
      ++v2;
      v3 += 7;
      v4 += 48;
    }
    while ( v2 < *(_BYTE *)(a1 + 172) );
  }
}

//----- (1001F310) --------------------------------------------------------
char __cdecl sub_1001F310(int a1, int a2, int a3, int a4, _WORD *a5)
{
  switch ( *a5 )
  {
    case 0x8015:
    case 0x8016:
    case 0x8022:
    case 0x8078:
      sub_1001ECC0(a4, a1);
      sub_1001F130(a1, a4);
      sub_1001F200(a4, a1);
      break;
    default:
      return 1;
  }
  return 1;
}

//----- (1001F3D0) --------------------------------------------------------
int __usercall sub_1001F3D0@<eax>(int a1@<eax>)
{
  int result; // eax@2
  float v2; // ST18_4@3
  float v3; // ST0C_4@3
  float v4; // ST18_4@3

  if ( *(_BYTE *)(a1 + 49) )
  {
    result = sub_1003B300(*(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 8), *(float *)(a1 + 12), -1);
  }
  else
  {
    v2 = *(float *)(a1 + 12) + *(float *)(a1 + 4);
    v3 = v2;
    v4 = *(float *)(a1 + 8) + *(float *)a1;
    result = sub_1003A420(*(float *)a1, *(float *)(a1 + 4), v4, v3, -1, 1.0);
  }
  return result;
}

//----- (1001F450) --------------------------------------------------------
void __usercall sub_1001F450(int a1@<edi>, int a2@<esi>)
{
  int v2; // eax@3
  int v3; // ecx@3
  float v4; // [sp+1Ch] [bp-28h]@3
  float v5; // [sp+20h] [bp-24h]@3
  int v6; // [sp+24h] [bp-20h]@3
  int v7; // [sp+28h] [bp-1Ch]@3
  char v8; // [sp+2Ch] [bp-18h]@3
  float v9; // [sp+34h] [bp-10h]@3
  float v10; // [sp+38h] [bp-Ch]@3
  float v11; // [sp+3Ch] [bp-8h]@3

  if ( *(float *)(a2 + 40) < (double)*(float *)(a2 + 44) || *(float *)(a2 + 36) > (double)*(float *)(a2 + 44) )
  {
    sub_10039220(
      *(float *)(a2 + 16),
      *(float *)(a2 + 20),
      *(float *)(a2 + 24),
      *(float *)(a2 + 28),
      0.0,
      0.0,
      *(_BYTE *)(a2 + 32));
  }
  else
  {
    v2 = *(_DWORD *)(a2 + 164);
    v3 = *(_DWORD *)(a2 + 168);
    v11 = *(float *)(a2 + 176);
    v9 = 0.5;
    v6 = v2;
    v10 = 0.5;
    v7 = v3;
    sub_10038450((int)&v8, (_BYTE *)(a2 + 172), 7);
    v4 = *(float *)(a2 + 156);
    v5 = *(float *)(a2 + 160);
    sub_1003E2A0(a1, (int)&v4);
  }
}

//----- (1001F530) --------------------------------------------------------
void __usercall sub_1001F530(int a1@<eax>, int a2@<ecx>)
{
  sub_1003E0F0(a2, a1 + 52);
}

//----- (1001F540) --------------------------------------------------------
int __thiscall sub_1001F540(int this)
{
  int result; // eax@2

  if ( *(float *)(this + 200) <= (double)*(float *)(this + 44) )
  {
    if ( *(float *)(this + 208) <= (double)*(float *)(this + 44) )
    {
      if ( *(float *)(this + 216) <= (double)*(float *)(this + 44) )
      {
        if ( *(float *)(this + 224) <= (double)*(float *)(this + 44) )
          result = sub_10038450(this + 172, (_BYTE *)(this + 196), 4);
        else
          result = sub_10038450(this + 172, (_BYTE *)(this + 192), 4);
      }
      else
      {
        result = sub_10038450(this + 172, (_BYTE *)(this + 188), 4);
      }
    }
    else
    {
      result = sub_10038450(this + 172, (_BYTE *)(this + 184), 4);
    }
  }
  else
  {
    result = sub_10038450(this + 172, (_BYTE *)(this + 180), 4);
  }
  return result;
}

//----- (1001F610) --------------------------------------------------------
char __cdecl sub_1001F610(int a1, int a2, int a3, int a4, _WORD *a5)
{
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    sub_1001F540(a4);
    if ( *(_BYTE *)(a4 + 48) )
      sub_1001F3D0(a4);
    sub_1001F530(a4, a1);
    sub_1001F450(a1, a4);
  }
  return 1;
}

//----- (1001F660) --------------------------------------------------------
char __usercall sub_1001F660@<al>(int a1@<edi>, int a2, int a3, int a4, int a5, _WORD *a6)
{
  int v7; // eax@4
  float v8; // ST38_4@5
  float v9; // ST38_4@5
  float v10; // ST08_4@5
  float v11; // ST24_4@5
  float v12; // ST38_4@5
  float v13; // ST20_4@5
  float v14; // ST38_4@5
  float v15; // ST08_4@5
  float v16; // ST28_4@5
  float v17; // ST2C_4@5
  float v18; // ST08_4@5
  float v19; // ST1C_4@5
  float v20; // ST30_4@5
  float v21; // ST08_4@5
  float v22; // ST24_4@5
  float v23; // ST20_4@5
  float v24; // ST08_4@5
  float v25; // ST30_4@5
  float v26; // ST2C_4@5
  float v27; // ST38_4@5
  float v28; // ST28_4@5
  float v29; // ST34_4@5
  float v30; // ST08_4@5
  float v31; // ST38_4@6
  float v32; // ST30_4@6
  float v33; // ST34_4@6
  float v34; // ST38_4@6
  float v35; // ST38_4@6
  float v36; // ST34_4@6
  float v37; // ST38_4@6
  double v38; // st7@6
  float v39; // ST08_4@8
  float v40; // [sp+4h] [bp-30h]@6
  int v41; // [sp+8h] [bp-2Ch]@4
  float v42; // [sp+10h] [bp-24h]@4
  float v43; // [sp+48h] [bp+14h]@4
  float v44; // [sp+48h] [bp+14h]@6

  if ( *a6 != 32802 && *a6 != 32888 )
    return 1;
  v41 = a1;
  v7 = *(_DWORD *)(a2 + 56);
  v42 = (double)*(_WORD *)(v7 + 34);
  v43 = (double)*(_WORD *)(v7 + 32);
  if ( !(*(_BYTE *)(a3 + 4) & 1) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(*(_DWORD *)(a3 + 8));
    sub_10015960(0.0, 0.0);
    sub_10015960(v43, 0.0);
    sub_10015960(v43, v42);
    v40 = v42;
    v38 = 0.0;
    goto LABEL_8;
  }
  j_gdi_pvg_begin(72);
  j_gdi_pvg_color_u32(*(_DWORD *)(a3 + 8));
  sub_10015960(0.0, 0.0);
  sub_10015960(v43, 0.0);
  sub_10015960(v43, v42);
  sub_10015960(0.0, v42);
  j_gdi_pvg_color_u32(-16777216);
  sub_10015960(0.0, 0.0);
  sub_10015960(v43, 0.0);
  v8 = 0.0 + 3.0;
  sub_10015960(v43, v8);
  sub_10015960(0.0, v8);
  v9 = v42 - 3.0;
  sub_10015960(0.0, v9);
  sub_10015960(v43, v9);
  sub_10015960(v43, v42);
  sub_10015960(0.0, v42);
  j_gdi_pvg_end(LODWORD(v10));
  sub_10015770(1.0);
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-1);
  v11 = v42 - 3.5;
  v12 = 0.0 + 0.5;
  sub_10015960(v12, v11);
  v13 = 0.0 + 3.5;
  sub_10015960(v12, v13);
  v14 = v43 - 0.0;
  sub_10015960(v14, v13);
  j_gdi_pvg_end(LODWORD(v15));
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-8355712);
  v16 = 0.0 + 1.5;
  sub_10015960(v16, v11);
  v17 = v43 - 0.5;
  sub_10015960(v17, v11);
  sub_10015960(v17, v13);
  j_gdi_pvg_end(LODWORD(v18));
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-4144960);
  v19 = v42 - 4.5;
  sub_10015960(v16, v19);
  v20 = 0.0 + 4.5;
  sub_10015960(v16, v20);
  sub_10015960(v17, v20);
  j_gdi_pvg_end(LODWORD(v21));
  j_gdi_pvg_begin(67);
  j_gdi_pvg_color_u32(-16777216);
  v22 = 0.0 + 2.5;
  sub_10015960(v22, v19);
  v23 = v43 - 1.5;
  sub_10015960(v23, v19);
  sub_10015960(v23, v20);
  j_gdi_pvg_end(LODWORD(v24));
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-14671840);
  sub_10015960(v22, v19);
  v25 = v42 - 9.5;
  v26 = 0.0 + 7.5;
  sub_10015960(v26, v25);
  sub_10015960(v23, v19);
  v27 = v43 - 6.5;
  sub_10015960(v27, v25);
  v28 = 0.0 + 5.5;
  sub_10015960(v23, v28);
  v29 = 0.0 + 10.5;
  sub_10015960(v27, v29);
  j_gdi_pvg_end(LODWORD(v30));
  j_gdi_pvg_begin(73);
  j_gdi_pvg_color_u32(-8355712);
  sub_10015960(v22, v19);
  sub_10015960(v26, v25);
  sub_10015960(v22, v28);
  sub_10015960(v26, v29);
  sub_10015960(v23, v28);
  sub_10015960(v27, v29);
  j_gdi_pvg_end(a1);
  if ( *(_BYTE *)(*(_DWORD *)(a2 + 56) + 247) )
  {
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-1);
    v31 = 0.0 + 14.0;
    v32 = 0.0 + 11.0;
    sub_10015960(v32, v31);
    v33 = v43 - 11.0;
    sub_10015960(v33, v31);
    v34 = v42 - 14.0;
    sub_10015960(v33, v34);
    sub_10015960(v32, v34);
    j_gdi_pvg_color_u32(*(_DWORD *)(a3 + 8));
    v35 = 0.0 + 15.0;
    v36 = 0.0 + 12.0;
    sub_10015960(v36, v35);
    v44 = v43 - 12.0;
    sub_10015960(v44, v35);
    v37 = v42 - 15.0;
    sub_10015960(v44, v37);
    v40 = v37;
    v38 = v36;
LABEL_8:
    v39 = v38;
    sub_10015960(v39, v40);
    j_gdi_pvg_end(v41);
  }
  return 2;
}
// 1001F660: could not find valid save-restore pair for edi
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1001FCA0) --------------------------------------------------------
signed int __cdecl sub_1001FCA0(_BYTE *a1, int a2)
{
  signed int result; // eax@1
  float *v3; // ecx@2
  float *v4; // edi@2
  float *v5; // ecx@6
  int v6; // edx@6

  result = 0;
  if ( *a1 )
  {
    v3 = (float *)(a2 + 592);
    v4 = (float *)(a1 + 12);
    while ( result < 10 )
    {
      ++result;
      *(v3 - 1) = *v4;
      *(_BYTE *)v3 = a1[result + 91];
      ++v4;
      v3 += 2;
      if ( result >= *a1 )
      {
        if ( result >= 10 )
          return result;
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    v5 = (float *)(a2 + 8 * result + 592);
    v6 = 10 - result;
    do
    {
      *(v5 - 1) = 9.8999998e24;
      *(_BYTE *)v5 = 10;
      v5 += 2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (1001FD10) --------------------------------------------------------
void __usercall sub_1001FD10(int a1@<esi>)
{
  char *v1; // edi@2
  signed int v2; // ebx@2
  double v3; // ST28_8@4
  double v4; // st7@5
  float v5; // ST0C_4@9
  float v6; // ST28_4@9
  float v7; // ST04_4@9
  float v8; // [sp+24h] [bp-14h]@4
  float v9; // [sp+28h] [bp-10h]@4
  float v10; // [sp+28h] [bp-10h]@7
  int v11; // [sp+30h] [bp-8h]@4
  char v12; // [sp+34h] [bp-4h]@4

  if ( *(_BYTE *)(a1 + 956) != 1 )
  {
    v1 = (char *)(a1 + 600);
    v2 = 9;
    do
    {
      if ( (unsigned __int8)*v1 > 0xAu )
      {
        sub_10047ED0(*v1, &v12, &v11, *(_BYTE *)(a1 + 956));
        v3 = *(float *)(a1 + 12) + *(float *)(a1 + 4);
        v8 = v3 - sub_10038A30(*((float *)v1 - 3), a1 + 980, *(_BYTE *)(a1 + 1076));
        v9 = *(float *)(a1 + 4);
        if ( v8 >= (double)v9 )
          v4 = v8;
        else
          v4 = v9;
        v10 = *(float *)(a1 + 12) + *(float *)(a1 + 4);
        if ( v10 <= v4 )
          v4 = v10;
        v5 = v4;
        v6 = *(float *)(a1 + 8) + *(float *)a1;
        v7 = v4;
        sub_1003A4D0(*(float *)a1, v7, v6, v5, v11, 1.0);
      }
      v1 += 8;
      --v2;
    }
    while ( v2 );
  }
}

//----- (1001FE20) --------------------------------------------------------
void __usercall sub_1001FE20(int a1@<esi>)
{
  int v1; // ebx@2
  int v2; // edi@2
  int v3; // ebp@2
  float *v4; // ecx@3
  float v5; // ST30_4@6
  float v6; // ST30_4@6
  float v7; // ST30_4@7
  double v8; // st7@7
  float v9; // ST30_4@9
  double v10; // st7@9
  float v11; // ST30_4@11
  char v12; // ST3C_1@11
  signed int v13; // edi@13
  float v14; // ST3C_4@14
  double v15; // st7@14
  float v16; // ST18_4@14
  float v17; // ST3C_4@14
  float v18; // ST10_4@14
  int v19; // edi@16
  float **v20; // ebx@16
  signed int v21; // ebp@16
  float *v22; // eax@17
  float *v23; // ecx@19
  double v24; // ST3C_8@21
  float v25; // ST3C_4@23
  int v26; // edi@28
  float **v27; // ebp@28
  signed int v28; // ebx@28
  float v29; // [sp+28h] [bp-18h]@5
  float v30; // [sp+28h] [bp-18h]@21
  signed int v31; // [sp+2Ch] [bp-14h]@2
  signed int v32; // [sp+2Ch] [bp-14h]@13
  float v33; // [sp+30h] [bp-10h]@7
  float v34; // [sp+34h] [bp-Ch]@21
  char v35; // [sp+3Ch] [bp-4h]@11

  if ( *(_BYTE *)(a1 + 957) != 1 )
  {
    v1 = a1 + 1080;
    v2 = a1 + 480;
    v3 = a1 + 28;
    v31 = 6;
    do
    {
      v4 = *(float **)v3;
      if ( *(_DWORD *)v3 && 9.8999998e24 != *v4 )
      {
        v29 = *v4;
        if ( *(float *)(a1 + 976) > 0.0 )
        {
          v5 = *v4 - *(float *)(a1 + 20);
          v6 = sub_100707A0(v5, *(float *)(a1 + 976));
          v29 = *(float *)(a1 + 20) + v6;
        }
        v7 = sub_10038A30(v29, a1 + 980, *(_BYTE *)(a1 + 1076));
        *(float *)v2 = v7;
        v33 = *(float *)(a1 + 12);
        v8 = v7;
        if ( v33 <= (double)v7 )
          v8 = v33;
        v9 = v8;
        v10 = v9;
        *(float *)v2 = v9;
        if ( v9 <= 0.0 )
          v10 = 0.0;
        v11 = v10;
        *(float *)v2 = v11;
        v12 = sub_10047DE0(**(float **)(v3 + 24), a1 + 588, 10, v1);
        sub_10047ED0(v12, &v35, (_DWORD *)(v2 + 4), *(_BYTE *)(a1 + 957));
        sub_10039900(v2 - 12);
      }
      v3 += 4;
      v1 += 28;
      v2 += 20;
      --v31;
    }
    while ( v31 );
    v13 = 0;
    v32 = 0;
    if ( *(_BYTE *)(a1 + 100) )
    {
      do
      {
        v14 = *(float *)(a1 + 12) / (double)*(_BYTE *)(a1 + 100) * (double)v32 + *(float *)(a1 + 4);
        v15 = v14;
        v16 = v14;
        v17 = *(float *)(a1 + 8) + *(float *)a1;
        v18 = v15;
        sub_1003A4D0(*(float *)a1, v18, v17, v16, -14671840, 1.0);
        v32 = ++v13;
      }
      while ( v13 < *(_BYTE *)(a1 + 100) );
    }
  }
  if ( *(_BYTE *)(a1 + 959) != 1 )
  {
    v19 = a1 + 472;
    v20 = (float **)(a1 + 76);
    v21 = 6;
    do
    {
      v22 = *(v20 - 12);
      if ( v22 )
      {
        if ( 9.8999998e24 != *v22 )
        {
          v23 = *v20;
          if ( *v20 )
          {
            if ( 9.8999998e24 != *v23 )
            {
              v24 = *(float *)v19;
              v30 = v24 - sub_10038A30(*v23, a1 + 980, *(_BYTE *)(a1 + 1076));
              v34 = *(float *)v19;
              if ( v30 > (double)v34 )
                v30 = v34;
              v25 = *(float *)v19 - *(float *)(a1 + 12);
              if ( v25 >= (double)v30 )
                v30 = *(float *)v19 - *(float *)(a1 + 12);
              sub_1003ABF0(*(float *)(v19 - 4), v30, *(float *)(v19 + 4), -16711681);
            }
          }
        }
      }
      ++v20;
      v19 += 20;
      --v21;
    }
    while ( v21 );
  }
  if ( *(_BYTE *)(a1 + 957) != 1 )
  {
    v26 = a1 + 472;
    v27 = (float **)(a1 + 28);
    v28 = 6;
    do
    {
      if ( *v27 )
      {
        if ( 9.8999998e24 == **v27 )
          sub_10039220(
            *(float *)(v26 - 4),
            *(float *)v26,
            *(float *)(v26 + 4),
            *(float *)(a1 + 12),
            0.0,
            1.0,
            *(_BYTE *)(a1 + 16));
      }
      ++v27;
      v26 += 20;
      --v28;
    }
    while ( v28 );
  }
}

//----- (10020160) --------------------------------------------------------
void __cdecl sub_10020160(int a1, int a2)
{
  signed int v2; // ebx@2
  int v3; // eax@3
  const void *v4; // [sp+4h] [bp-40h]@2
  char v5; // [sp+Ch] [bp-38h]@3
  int v6; // [sp+14h] [bp-30h]@5
  int v7; // [sp+18h] [bp-2Ch]@5

  if ( *(_BYTE *)(a2 + 958) != 1 )
  {
    v2 = 0;
    v4 = (const void *)(a2 + 156);
    do
    {
      v3 = *(_BYTE *)(a2 + 962);
      qmemcpy(&v5, v4, 0x34u);
      if ( v3 == v2 )
      {
        if ( *(_DWORD *)(a2 + 4 * v3 + 28) )
        {
          v7 = -16777216;
          v6 = -16711681;
        }
      }
      sub_1003E0F0(a1, (int)&v5);
      v4 = (char *)v4 + 52;
      ++v2;
    }
    while ( v2 < 6 );
  }
}

//----- (10020200) --------------------------------------------------------
void __usercall sub_10020200(int a1@<esi>, int a2)
{
  unsigned __int8 v2; // al@1
  int v3; // ecx@2
  float *v4; // eax@2
  char v5; // ST38_1@8

  v2 = *(_BYTE *)(a1 + 962);
  if ( v2 < 6u )
  {
    v3 = 48 * v2 + a1;
    v4 = *(float **)(v3 + 688);
    if ( v4 )
    {
      if ( *(_BYTE *)(a1 + 960) != 1 )
      {
        if ( 9.8999998e24 != *v4 || *(_BYTE *)(v3 + 714) == 1 )
        {
          v5 = sub_10047DE0(
                 **(float **)(a1 + 4 * *(_BYTE *)(a1 + 962) + 52),
                 a1 + 588,
                 10,
                 a1 + 28 * *(_BYTE *)(a1 + 962) + 1080);
          sub_10047F10(
            v5,
            (_DWORD *)(a1 + 48 * *(_BYTE *)(a1 + 962) + 680),
            (int *)(a1 + 48 * *(_BYTE *)(a1 + 962) + 676),
            *(_BYTE *)(a1 + 960),
            *(_DWORD *)(a1 + 28 * *(_BYTE *)(a1 + 962) + 1088));
          sub_1003AD10(
            a2,
            48 * *(_BYTE *)(a1 + 962) + a1 + 668,
            *(_WORD *)(a1 + 964),
            *(_DWORD *)(a1 + 968),
            *(_BYTE *)(a1 + 972));
        }
        else if ( *(_BYTE *)(a1 + 957) == 1 )
        {
          sub_1003C630(v3 + 668);
        }
      }
    }
  }
}

//----- (10020320) --------------------------------------------------------
void __usercall sub_10020320(int a1@<eax>, int a2)
{
  int v2; // esi@1
  unsigned __int8 v3; // cl@1
  float **v4; // eax@2
  char v5; // ST24_1@4
  char v6; // al@6
  float **v7; // ebp@6
  int v8; // edi@6
  signed int v9; // ebx@6
  char v10; // [sp+23h] [bp-5h]@0
  char v11; // [sp+24h] [bp-4h]@1

  v2 = a1;
  v3 = *(_BYTE *)(a1 + 962);
  v11 = 0;
  if ( v3 < 6u && (v4 = (float **)(a1 + 4 * v3 + 28), *(_DWORD *)(v2 + 4 * v3 + 28)) && 9.8999998e24 != **v4 )
  {
    v5 = sub_10047DE0(**(float **)(v2 + 4 * v3 + 52), v2 + 588, 10, v2 + 28 * v3 + 1080);
    sub_10047FA0(
      v5,
      (_DWORD *)(v2 + 116),
      (int *)(v2 + 112),
      *(_BYTE *)(v2 + 961),
      *(_DWORD *)(v2 + 28 * *(_BYTE *)(v2 + 962) + 1088));
  }
  else
  {
    if ( v3 == -1 )
    {
      v6 = v10;
      v7 = (float **)(v2 + 52);
      v8 = v2 + 1080;
      v9 = 6;
      do
      {
        if ( *v7 )
          v6 = sub_10047DE0(**v7, v2 + 588, 10, v8);
        if ( (unsigned __int8)v6 > (unsigned __int8)v11 )
          v11 = v6;
        ++v7;
        v8 += 28;
        --v9;
      }
      while ( v9 );
    }
    sub_10047FA0(
      v11,
      (_DWORD *)(v2 + 116),
      (int *)(v2 + 112),
      *(_BYTE *)(v2 + 961),
      *(_DWORD *)(v2 + 28 * *(_BYTE *)(v2 + 962) + 1088));
  }
  sub_1003E0F0(a2, v2 + 104);
}

//----- (10020430) --------------------------------------------------------
char __cdecl sub_10020430(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_1001FD10(a4);
      sub_1001FE20(a4);
      sub_10020320(a4, a1);
      sub_10020160(a1, a4);
      sub_10020200(a4, a1);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_10020320(a4, a1);
      sub_10020200(a4, a1);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (10020510) --------------------------------------------------------
int __cdecl sub_10020510(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8)
{
  int v8; // esi@1
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st4@1
  int v12; // eax@1
  double v13; // st4@1
  double v14; // st5@1
  int v15; // ecx@2
  int v16; // ebp@2
  int v17; // edi@2
  double v18; // st7@2
  double v19; // st6@2
  float v20; // ST28_4@4
  float v21; // ST2C_4@4
  double v22; // st7@4
  double v23; // rt0@4
  double v24; // st6@4
  double v25; // rt0@7
  double v26; // st5@7
  double v27; // st7@7
  float v28; // ST28_4@9
  double v29; // st6@7
  int v30; // ebp@7
  int v31; // ecx@7
  int v32; // edi@7
  double v33; // st6@9
  double v34; // st6@9
  int v35; // eax@10
  double v36; // st7@10
  signed int v37; // edi@10
  double v38; // st6@10
  double v39; // st5@10
  double v40; // rt2@11
  double v41; // st5@11
  double v42; // rtt@11
  double v43; // st4@12
  double v44; // rt0@12
  double v45; // st5@12
  double v46; // st7@12
  double v47; // rt1@12
  double v48; // st5@12
  double v49; // st6@12
  int result; // eax@14
  int v51; // [sp+0h] [bp-28h]@2
  int v52; // [sp+4h] [bp-24h]@2
  float v53; // [sp+Ch] [bp-1Ch]@7
  double v54; // [sp+10h] [bp-18h]@2
  double v55; // [sp+10h] [bp-18h]@7
  double v56; // [sp+18h] [bp-10h]@2
  int v57; // [sp+2Ch] [bp+4h]@1
  float v58; // [sp+38h] [bp+10h]@10
  float v59; // [sp+3Ch] [bp+14h]@7
  int v60; // [sp+44h] [bp+1Ch]@7

  v8 = a1;
  *(float *)a1 = a4;
  v9 = a5;
  *(_BYTE *)(a1 + 16) = 0;
  *(float *)(a1 + 4) = a5;
  v10 = a6;
  *(float *)(a1 + 8) = a6;
  *(float *)(a1 + 12) = a7;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  v11 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 100) = 0;
  *(float *)(a1 + 24) = v11;
  *(float *)(a1 + 976) = 0.0;
  *(float *)(a1 + 980) = 0.0;
  *(float *)(a1 + 984) = 0.0;
  *(float *)(a1 + 988) = 1.0;
  *(float *)(a1 + 1000) = 1.0;
  *(float *)(a1 + 1012) = 1.0;
  *(float *)(a1 + 1024) = 1.0;
  *(float *)(a1 + 1036) = 1.0;
  *(float *)(a1 + 1048) = 1.0;
  *(float *)(a1 + 1060) = 1.0;
  *(float *)(a1 + 1072) = 1.0;
  *(float *)(a1 + 992) = 0.0;
  *(float *)(a1 + 996) = 0.0;
  *(float *)(a1 + 1004) = 0.0;
  *(float *)(a1 + 1008) = 0.0;
  *(float *)(a1 + 1016) = 0.0;
  *(float *)(a1 + 1020) = 0.0;
  *(float *)(a1 + 1028) = 0.0;
  *(float *)(a1 + 1032) = 0.0;
  *(float *)(a1 + 1040) = 0.0;
  *(float *)(a1 + 1044) = 0.0;
  *(float *)(a1 + 1052) = 0.0;
  *(float *)(a1 + 1056) = 0.0;
  *(float *)(a1 + 1064) = 0.0;
  *(float *)(a1 + 1068) = 0.0;
  *(_BYTE *)(a1 + 1076) = 2;
  *(float *)(a1 + 980) = *(float *)(a3 + 4);
  v12 = 0;
  *(float *)(a1 + 992) = *(float *)(a3 + 8);
  v57 = 0;
  *(float *)(v8 + 984) = 0.0;
  v13 = a7;
  v14 = 0.0;
  *(float *)(v8 + 996) = a7;
  if ( a8 <= 0 )
    goto LABEL_7;
  v52 = v8 + 1080;
  v15 = v8 + 52;
  v16 = v8 + 160;
  v17 = v8 + 476;
  v51 = v8 + 52;
  v54 = v10 / (double)a8;
  v18 = v54;
  v19 = 0.0;
  v56 = a7 + a5;
  while ( 1 )
  {
    *(_DWORD *)(v15 - 24) = 0;
    *(_DWORD *)v15 = 0;
    v22 = v18 * (double)v57;
    *(_DWORD *)(v17 + 8) = -1;
    v23 = v19;
    v57 = v12 + 1;
    *(float *)(v17 - 8) = v22 + a4 + 0.2000000029802322 * v54;
    v20 = v56;
    *(float *)(v17 - 4) = v20;
    v21 = v54 * 0.800000011920929;
    *(float *)v17 = v21;
    *(float *)(v17 + 4) = v19;
    *(_DWORD *)(v15 + 24) = 0;
    *(float *)(v16 - 4) = *(float *)v17 * 0.5 + *(float *)(v17 - 8);
    v24 = *(float *)(v17 - 4);
    *(_DWORD *)(v16 + 8) = -1;
    *(_DWORD *)(v16 + 4) = 0;
    *(float *)v16 = v24 + 4.0;
    *(float *)(v16 + 36) = 0.5;
    *(float *)(v16 + 40) = v23;
    *(float *)(v16 + 44) = 9.0;
    sprintf((char *)(v16 + 12), "%d", v12 + 1);
    sub_10048030(v52);
    v12 = v57;
    v51 += 4;
    v52 += 28;
    v17 += 20;
    v16 += 52;
    if ( v57 >= a8 )
      break;
    v18 = v54;
    v15 = v51;
    v19 = 0.0;
  }
  if ( v57 < 6 )
  {
    v10 = a6;
    v9 = a5;
    v13 = a7;
    v14 = 0.0;
LABEL_7:
    v25 = v14;
    v26 = v9 + v13;
    v27 = v25;
    v56 = v26;
    v29 = v10 / (double)a8;
    v60 = v8 + 28 * v12 + 1080;
    v30 = 52 * v12 + v8 + 160;
    v31 = v8 + 4 * v12 + 52;
    v32 = v8 + 20 * v12 + 476;
    LODWORD(v59) = v8 + 4 * v12 + 52;
    v55 = v29;
    v53 = 0.8999999761581421 * v29;
    while ( 1 )
    {
      v33 = v29 * (double)v57;
      *(_DWORD *)(v31 - 24) = 0;
      *(_DWORD *)v31 = 0;
      *(_DWORD *)(v32 + 8) = -1;
      v57 = v12 + 1;
      *(float *)(v32 - 8) = v33 + a4;
      v28 = v26;
      *(float *)(v32 - 4) = v28;
      *(float *)v32 = v53;
      *(float *)(v32 + 4) = v27;
      *(_DWORD *)(v31 + 24) = 0;
      *(float *)(v30 - 4) = *(float *)v32 * 0.5 + *(float *)(v32 - 8);
      v34 = *(float *)(v32 - 4);
      *(_DWORD *)(v30 + 4) = 0;
      *(_DWORD *)(v30 + 8) = 0;
      *(float *)v30 = v34 + 4.0;
      *(float *)(v30 + 36) = 0.5;
      *(float *)(v30 + 40) = v27;
      *(float *)(v30 + 44) = 9.0;
      sprintf((char *)(v30 + 12), "%d", v12 + 1);
      sub_10048030(v60);
      v12 = v57;
      LODWORD(v59) += 4;
      v60 += 28;
      v32 += 20;
      v30 += 52;
      if ( v57 >= 6 )
        break;
      v31 = LODWORD(v59);
      v29 = v55;
      v27 = 0.0;
    }
  }
  *(float *)(v8 + 104) = a4;
  *(_DWORD *)(v8 + 112) = 0;
  *(_DWORD *)(v8 + 116) = -1;
  *(float *)(v8 + 108) = v56 + 9.0 + 15.0 + 8.0;
  sub_10038450(v8 + 120, (_BYTE *)a2, 21);
  *(float *)(v8 + 144) = 0.0;
  v35 = v8 + 672;
  v36 = 1.0;
  v37 = 6;
  *(float *)(v8 + 148) = 1.0;
  *(float *)(v8 + 152) = 12.0;
  v58 = a4 + a6;
  v38 = 15.0;
  v39 = v58;
  while ( 1 )
  {
    *(float *)(v35 - 4) = v39;
    v43 = *(float *)(v8 + 108);
    *(_BYTE *)(v35 + 40) = 0;
    *(float *)v35 = v43;
    *(_BYTE *)(v35 + 41) = 0;
    *(_DWORD *)(v35 + 4) = 0;
    *(_DWORD *)(v35 + 8) = -1;
    *(_DWORD *)(v35 + 12) = -1;
    *(_BYTE *)(v35 + 42) = 0;
    *(float *)(v35 + 20) = *(float *)(a3 + 4);
    v35 += 48;
    --v37;
    *(float *)(v35 - 24) = *(float *)(a3 + 8);
    *(_DWORD *)(v35 - 32) = 0;
    v44 = v39;
    v45 = v36;
    v46 = v44;
    *(float *)(v35 - 20) = v45;
    *(float *)(v35 - 16) = v45;
    v47 = v45;
    v48 = v38;
    v49 = v47;
    *(float *)(v35 - 12) = v48;
    if ( !v37 )
      break;
    v40 = v48;
    v41 = v49;
    v38 = v40;
    v42 = v41;
    v39 = v46;
    v36 = v42;
  }
  *(_BYTE *)(v8 + 962) = 0;
  *(_WORD *)(v8 + 964) = 12;
  *(_DWORD *)(v8 + 968) = &unk_100984F8;
  *(_BYTE *)(v8 + 972) = 1;
  *(_DWORD *)(v8 + 956) = 0;
  *(_WORD *)(v8 + 960) = 0;
  if ( a8 == 1 )
  {
    *(_BYTE *)(v8 + 172) = 0;
    *(_BYTE *)(v8 + 973) = 0;
    result = sub_1001FCA0((_BYTE *)a3, v8);
  }
  else
  {
    *(_BYTE *)(v8 + 973) = 2;
    result = sub_1001FCA0((_BYTE *)a3, v8);
  }
  return result;
}

//----- (10020990) --------------------------------------------------------
int __cdecl sub_10020990(int a1)
{
  int v1; // esi@1
  signed int v2; // eax@2
  unsigned __int8 v3; // cl@2
  bool v4; // zf@2
  double v5; // st6@2
  int v6; // eax@3
  unsigned __int8 v7; // cl@4
  int v8; // eax@5
  int result; // eax@6
  signed int v10; // ecx@6
  signed int v11; // eax@9
  unsigned __int8 v12; // cl@9
  double v13; // st6@9
  int v14; // eax@10
  unsigned __int8 v15; // cl@11
  float *v16; // edx@12
  float *v17; // eax@12
  signed int v18; // ecx@13
  float v19; // [sp+Ch] [bp+4h]@2
  float v20; // [sp+Ch] [bp+4h]@2
  float v21; // [sp+Ch] [bp+4h]@9
  float v22; // [sp+Ch] [bp+4h]@9

  v1 = a1;
  if ( *(_BYTE *)(a1 + 4208) == 1 )
  {
    v19 = *(float *)a1 + *(float *)a1 + *(float *)(a1 + 8);
    v2 = sub_10070770(v19);
    v3 = 0;
    v4 = *(_BYTE *)(v1 + 4036) == 0;
    v20 = (double)v2 - 1.0;
    v5 = v20;
    *(float *)(v1 + 4192) = v20 - *(float *)(v1 + 4192);
    if ( !v4 )
    {
      do
      {
        v6 = v1 + (v3++ << 6);
        *(float *)(v6 + 836) = v5 - *(float *)(v6 + 836);
        *(float *)(v6 + 840) = v5 - *(float *)(v6 + 840);
        *(float *)(v6 + 856) = v5 - *(float *)(v6 + 856);
        *(float *)(v6 + 880) = 1.0 - *(float *)(v6 + 880);
      }
      while ( v3 < *(_BYTE *)(v1 + 4036) );
    }
    v7 = 0;
    if ( *(_BYTE *)(v1 + 368) )
    {
      do
      {
        v8 = v1 + 20 * v7++;
        *(float *)(v8 + 168) = v5 - *(float *)(v8 + 168);
        *(float *)(v8 + 176) = *(float *)(v8 + 176) * -1.0;
      }
      while ( v7 < *(_BYTE *)(v1 + 368) );
    }
    result = v1 + 460;
    v10 = 6;
    do
    {
      result += 64;
      --v10;
      *(float *)(result - 72) = v5 - *(float *)(result - 72);
      *(float *)(result - 64) = *(float *)(result - 64) * -1.0;
    }
    while ( v10 );
  }
  else
  {
    v21 = *(float *)(a1 + 4) + *(float *)(a1 + 4) + *(float *)(a1 + 12);
    v11 = sub_10070770(v21);
    v12 = 0;
    v4 = *(_BYTE *)(v1 + 4036) == 0;
    v22 = (double)v11 - 1.0;
    v13 = v22;
    *(float *)(v1 + 4196) = v22 - *(float *)(v1 + 4196);
    if ( !v4 )
    {
      do
      {
        v14 = v1 + (v12++ << 6);
        *(float *)(v14 + 844) = v13 - *(float *)(v14 + 844);
        *(float *)(v14 + 848) = v13 - *(float *)(v14 + 848);
        *(float *)(v14 + 860) = v13 - *(float *)(v14 + 860);
        *(float *)(v14 + 884) = 1.0 - *(float *)(v14 + 884);
      }
      while ( v12 < *(_BYTE *)(v1 + 4036) );
    }
    v15 = 0;
    if ( *(_BYTE *)(v1 + 368) )
    {
      do
      {
        v16 = (float *)(v1 + 20 * v15 + 172);
        v17 = (float *)(v1 + 4 * (5 * v15++ + 45));
        *v16 = v13 - *v16;
        *v17 = *v17 * -1.0;
      }
      while ( v15 < *(_BYTE *)(v1 + 368) );
    }
    result = v1 + 464;
    v18 = 6;
    do
    {
      result += 64;
      --v18;
      *(float *)(result - 72) = v13 - *(float *)(result - 72);
      *(float *)(result - 64) = *(float *)(result - 64) * -1.0;
    }
    while ( v18 );
  }
  return result;
}

//----- (10020BA0) --------------------------------------------------------
void __cdecl sub_10020BA0(int a1, float a2, float a3, int a4)
{
  double v4; // st7@1
  int v5; // edi@1
  signed int v6; // esi@1
  int v7; // ebx@3
  int v8; // ebp@3
  double v9; // st6@5
  double v10; // st5@6
  float v11; // ST24_4@8
  int v12; // ebx@11
  int v13; // ebp@11
  double v14; // st6@13
  double v15; // st5@16
  float v16; // ST24_4@18
  double v17; // st6@21
  int v18; // eax@21
  int v19; // ecx@21
  int v20; // edx@21
  float v21; // [sp+1Ch] [bp-Ch]@1
  float *v22; // [sp+20h] [bp-8h]@3
  int v23; // [sp+20h] [bp-8h]@11
  int v24; // [sp+38h] [bp+10h]@6
  int v25; // [sp+38h] [bp+10h]@6
  int v26; // [sp+38h] [bp+10h]@6
  int v27; // [sp+38h] [bp+10h]@8
  int v28; // [sp+38h] [bp+10h]@16
  int v29; // [sp+38h] [bp+10h]@16
  int v30; // [sp+38h] [bp+10h]@16
  int v31; // [sp+38h] [bp+10h]@18

  v4 = 0.0;
  v21 = 0.0;
  v5 = a4;
  v6 = 0;
  if ( *(_BYTE *)(a4 + 4208) == 1 )
  {
    if ( *(_BYTE *)a1 )
    {
      v22 = (float *)(a4 + 376);
      v7 = a1 + 12;
      v8 = a4 + 168;
      while ( 1 )
      {
        v9 = a3;
        if ( v6 >= 10 )
          goto LABEL_23;
        *(float *)&v24 = *(float *)(v5 + 4200) * a2;
        *(float *)(v8 + 8) = *(float *)&v24;
        *(float *)&v25 = *(float *)(v5 + 4192) - *(float *)&v24 + *(float *)&v24 * v9;
        v10 = *(float *)&v25;
        v26 = 1;
        *(float *)v8 = v10;
        if ( v9 != v4 )
          v26 = 0;
        v11 = v10;
        *(float *)v8 = v11 - (double)v26;
        *(float *)(v8 + 4) = *(float *)(v5 + 4196) - v21;
        *(float *)&v27 = sub_10038A30(*(float *)v7, v5 + 4212, *(_BYTE *)(v5 + 4308));
        ++v6;
        v7 += 4;
        v8 += 20;
        *(float *)(v8 - 8) = -(*(float *)&v27 - v21);
        *(_DWORD *)(v8 - 4) = *(_DWORD *)(v7 + 36);
        *(v22 - 1) = *(float *)(v7 - 4);
        *(_BYTE *)v22 = *(_BYTE *)(v6 + a1 + 91);
        v21 = *(float *)&v27;
        v22 += 2;
        if ( v6 >= *(_BYTE *)a1 )
          goto LABEL_19;
        v4 = 0.0;
      }
    }
LABEL_21:
    v17 = 9.8999998e24;
    v18 = v5 + 20 * v6 + 172;
    v19 = v5 + 8 * v6 + 372;
    v20 = 10 - v6;
    do
    {
      *(_DWORD *)(v18 + 12) = 0;
      *(float *)(v18 - 4) = v4;
      v18 += 20;
      *(float *)(v18 - 20) = v4;
      v19 += 8;
      --v20;
      *(float *)(v18 - 16) = v4;
      *(float *)(v18 - 12) = v4;
      *(_BYTE *)(v19 - 4) = 10;
      *(float *)(v19 - 8) = *(float *)&v17;
    }
    while ( v20 );
LABEL_23:
    *(_BYTE *)(v5 + 368) = *(_BYTE *)a1;
    return;
  }
  *(float *)(a4 + 168) = *(float *)(a4 + 4192);
  if ( !*(_BYTE *)a1 )
    goto LABEL_21;
  v23 = a4 + 376;
  v12 = a1 + 12;
  v13 = a4 + 148;
  while ( 1 )
  {
    v14 = a3;
    if ( v6 >= 10 )
    {
      *(_BYTE *)(v5 + 368) = *(_BYTE *)a1;
      return;
    }
    if ( v6 > 0 )
      *(float *)(v13 + 20) = *(float *)(v13 + 8) + *(float *)v13;
    *(float *)&v28 = *(float *)(v5 + 4204) * a2;
    *(float *)(v13 + 32) = *(float *)&v28;
    *(float *)&v29 = *(float *)(v5 + 4196) - *(float *)&v28 + *(float *)&v28 * v14;
    v15 = *(float *)&v29;
    v30 = 1;
    *(float *)(v13 + 24) = v15;
    if ( v14 != v4 )
      v30 = 0;
    v16 = v15;
    *(float *)(v13 + 24) = v16 - (double)v30;
    *(float *)&v31 = sub_10038A30(*(float *)v12, v5 + 4212, *(_BYTE *)(v5 + 4308));
    v23 += 8;
    ++v6;
    *(float *)(v13 + 28) = *(float *)&v31 - v21;
    *(_DWORD *)(v13 + 36) = *(_DWORD *)(v12 + 40);
    *(float *)(v23 - 12) = *(float *)v12;
    *(_BYTE *)(v23 - 8) = *(_BYTE *)(v6 + a1 + 91);
    v21 = *(float *)&v31;
    v12 += 4;
    v13 += 20;
    if ( v6 >= *(_BYTE *)a1 )
      break;
    v4 = 0.0;
  }
LABEL_19:
  if ( v6 < 10 )
  {
    v4 = 0.0;
    goto LABEL_21;
  }
  *(_BYTE *)(v5 + 368) = *(_BYTE *)a1;
}

//----- (10020E60) --------------------------------------------------------
void __cdecl sub_10020E60(int a1, signed int a2, char a3, int a4)
{
  signed int v4; // esi@1
  int *v5; // edi@2
  int v6; // eax@2
  int *v7; // ecx@2

  v4 = 0;
  if ( a2 > 0 )
  {
    v5 = (int *)(a4 + 4060);
    v6 = a1 + 8;
    v7 = (int *)(a4 + 52);
    do
    {
      if ( v4 >= 3 )
        break;
      *(v7 - 6) = v6 - 4;
      *v7 = v6;
      if ( a3 )
        *v5 = v6;
      ++v4;
      ++v7;
      v6 += 12;
      v5 += 12;
    }
    while ( v4 < a2 );
  }
}

//----- (10020EB0) --------------------------------------------------------
void __cdecl sub_10020EB0(int a1, unsigned __int8 a2, char a3, int a4)
{
  double v4; // st7@1
  double v5; // st6@1
  char v6; // bl@1
  int v7; // esi@1
  bool v8; // zf@1
  int v9; // edi@4
  double v10; // ST20_8@4
  int v11; // ebp@4
  bool v12; // cf@4
  double v13; // st7@4
  int v14; // ebp@8
  int v15; // edi@8
  float v16; // ST20_4@8
  double v17; // st7@8
  double v18; // st7@8
  int v19; // eax@10
  int v20; // ecx@10
  unsigned __int8 v21; // [sp+34h] [bp+10h]@1

  v4 = 0.5;
  v5 = 0.0;
  v6 = a3;
  v7 = a4;
  v8 = *(_BYTE *)(a4 + 4208) == 1;
  v21 = 0;
  if ( v8 )
  {
    if ( a2 )
    {
      do
      {
        if ( (unsigned __int8)v6 >= 0x32u )
          break;
        v9 = ((unsigned __int8)v6 << 6) + v7;
        *(float *)(v9 + 836) = *(float *)(v7 + 4192);
        v10 = *(float *)(v7 + 4196);
        v11 = 16 * v21 + a1;
        *(float *)(v9 + 844) = v10 - sub_10038A30(*(float *)v11, v7 + 4212, *(_BYTE *)(v7 + 4308));
        *(float *)&v10 = *(float *)(v11 + 4) * *(float *)(v7 + 4200);
        *(float *)(v9 + 840) = (double)sub_10070770(*(float *)&v10) + *(float *)(v9 + 836);
        *(float *)(v9 + 848) = *(float *)(v9 + 844);
        *(_DWORD *)(v9 + 892) = -1;
        *(_BYTE *)((((unsigned __int8)v6 + 14) << 6) + v7) = 0;
        *(float *)(v9 + 852) = 1.0;
        strncpy((char *)(v9 + 872), (const char *)(v11 + 8), 7u);
        ++v6;
        v12 = (unsigned __int8)(v21 + 1) < a2;
        v13 = *(float *)(v7 + 8) + *(float *)v7 + 4.0;
        *(_DWORD *)(v9 + 864) = 0;
        *(_DWORD *)(v9 + 868) = -1;
        ++v21;
        *(float *)(v9 + 856) = v13;
        *(float *)(v9 + 860) = *(float *)(v9 + 844);
        *(float *)(v9 + 888) = 9.0;
        v4 = 0.5;
        *(float *)(v9 + 884) = 0.5;
        v5 = 0.0;
        *(float *)(v9 + 880) = 0.0;
      }
      while ( v12 );
    }
  }
  else if ( a2 )
  {
    do
    {
      if ( (unsigned __int8)v6 >= 0x32u )
        break;
      v14 = 16 * v21 + a1;
      v15 = ((unsigned __int8)v6 << 6) + v7;
      *(float *)(v15 + 836) = sub_10038A30(*(float *)v14, v7 + 4212, *(_BYTE *)(v7 + 4308)) + *(float *)(v7 + 4192);
      *(float *)(v15 + 844) = *(float *)(v7 + 4196);
      *(float *)(v15 + 840) = *(float *)(v15 + 836);
      v16 = *(float *)(v14 + 4) * *(float *)(v7 + 4204);
      v17 = (double)sub_10070770(v16) + *(float *)(v15 + 844);
      *(_BYTE *)((((unsigned __int8)v6 + 14) << 6) + v7) = 0;
      *(float *)(v15 + 848) = v17;
      *(float *)(v15 + 852) = 1.0;
      *(_DWORD *)(v15 + 892) = -1;
      strncpy((char *)(v15 + 872), (const char *)(v14 + 8), 7u);
      *(float *)(v15 + 856) = *(float *)(v15 + 836);
      ++v6;
      v12 = (unsigned __int8)(v21 + 1) < a2;
      v18 = *(float *)(v7 + 12) + *(float *)(v7 + 4);
      *(_DWORD *)(v15 + 864) = 0;
      *(_DWORD *)(v15 + 868) = -1;
      ++v21;
      *(float *)(v15 + 860) = v18 + 4.0;
      *(float *)(v15 + 888) = 9.0;
      *(float *)(v15 + 884) = 0.0;
      *(float *)(v15 + 880) = 0.5;
      v5 = 0.0;
      v4 = 0.5;
    }
    while ( v12 );
  }
  *(_BYTE *)(v7 + 4036) = v6;
  if ( (unsigned __int8)v6 < 0x32u )
  {
    v19 = ((unsigned __int8)v6 << 6) + v7 + 844;
    v20 = (unsigned __int8)(50 - v6);
    do
    {
      *(float *)(v19 - 8) = v5;
      *(float *)v19 = v5;
      *(_DWORD *)(v19 + 48) = 0;
      *(float *)(v19 - 4) = v5;
      *(_BYTE *)(v19 + 52) = 1;
      *(float *)(v19 + 4) = v5;
      *(_BYTE *)(v19 + 28) = 0;
      *(_DWORD *)(v19 + 20) = 0;
      *(float *)(v19 + 8) = 1.0;
      *(_DWORD *)(v19 + 24) = -1;
      v19 += 64;
      --v20;
      *(float *)(v19 - 52) = v5;
      *(float *)(v19 - 48) = v5;
      *(float *)(v19 - 24) = v4;
      *(float *)(v19 - 28) = v4;
      *(float *)(v19 - 20) = *(float *)&v5;
    }
    while ( v20 );
  }
}

//----- (100211D0) --------------------------------------------------------
int __usercall sub_100211D0@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 4185) != 1 )
  {
    if ( *(_BYTE *)(result + 4208) == 1 )
      result = sub_1003E190(result + 168, *(_BYTE *)(result + 368));
    else
      result = sub_1003CCC0(result + 168, *(_BYTE *)(result + 368));
  }
  return result;
}

//----- (10021210) --------------------------------------------------------
void __usercall sub_10021210(int a1@<esi>, int a2)
{
  signed int v2; // ebp@2
  int v3; // ebx@2
  int v4; // edi@2
  float *v5; // ecx@3
  float v6; // ST2C_4@6
  double v7; // st7@6
  float v8; // ST34_4@15
  char v9; // ST38_1@17
  float v10; // [sp+4h] [bp-28h]@5
  int v11; // [sp+8h] [bp-24h]@5
  int v12; // [sp+Ch] [bp-20h]@5
  float v13; // [sp+1Ch] [bp-10h]@8
  float v14; // [sp+1Ch] [bp-10h]@11
  int v15; // [sp+20h] [bp-Ch]@2
  float v16; // [sp+24h] [bp-8h]@13

  if ( *(_BYTE *)(a1 + 4186) != 1 )
  {
    v2 = 5;
    v15 = a1 + 4464;
    v3 = a1 + 48;
    v4 = a1 + 792;
    do
    {
      v5 = *(float **)v3;
      if ( *(_DWORD *)v3 && 9.8999998e24 != *v5 )
      {
        v12 = *(_BYTE *)(a1 + 4308);
        v11 = a1 + 4212;
        v10 = *v5;
        if ( *(_BYTE *)(a1 + 4208) == 1 )
        {
          v6 = sub_10038A30(v10, v11, v12);
          v7 = v6;
          if ( v6 < 0.0 )
            v7 = (float)0.0;
          v13 = *(float *)(a1 + 4204);
          if ( v13 <= v7 )
            v7 = v13;
          *(float *)(v4 - 16) = *(float *)(a1 + 4196) - v7;
          *(float *)v4 = *(float *)(a1 + 4196) - v7;
        }
        else
        {
          v14 = sub_10038A30(v10, v11, v12);
          if ( v14 < 0.0 )
            v14 = 0.0;
          v16 = *(float *)(a1 + 4200);
          if ( v16 <= (double)v14 )
            v14 = v16;
          v8 = *(float *)(a1 + 4192) + v14;
          *(float *)(v4 - 20) = v8;
          *(float *)(v4 - 4) = v8;
        }
        if ( v2 < 3 )
        {
          v9 = sub_10047DE0(**(float **)(v3 + 24), a1 + 372, 10, v15);
          sub_10047ED0(v9, (_DWORD *)(v4 + 8), (_DWORD *)(v4 + 36), *(_BYTE *)(a1 + 4186));
        }
        sub_1003E2C0(a2, v4 - 20);
      }
      v15 -= 28;
      --v2;
      v3 -= 4;
      v4 -= 64;
    }
    while ( v2 >= 0 );
  }
}

//----- (100213B0) --------------------------------------------------------
int __usercall sub_100213B0@<eax>(int result@<eax>)
{
  if ( *(_BYTE *)(result + 4188) != 1 )
    result = sub_1003B4C0(result + 4192);
  return result;
}

//----- (100213D0) --------------------------------------------------------
int __usercall sub_100213D0@<eax>(int result@<eax>, int a2@<edx>, int a3@<edi>)
{
  if ( *(_BYTE *)(result + 4189) != 1 )
    result = sub_1003BEB0(a3, a2, result + 836, *(_BYTE *)(result + 4036), 0);
  return result;
}

//----- (10021400) --------------------------------------------------------
void __usercall sub_10021400(int a1@<edi>, int a2)
{
  unsigned __int8 v2; // bl@1
  int v3; // ebp@1
  int v4; // esi@1
  char v5; // al@4
  _DWORD *v6; // esi@7
  signed int v7; // ebx@7
  unsigned __int8 v8; // [sp+1Fh] [bp-5h]@1
  char v9; // [sp+20h] [bp-4h]@1

  v9 = 0;
  v8 = 0;
  v2 = 0;
  v3 = a1 + 4324;
  v4 = a1 + 28;
  do
  {
    if ( *(_DWORD *)v4 )
    {
      if ( 9.8999998e24 != **(float **)v4 )
      {
        v5 = sub_10047DE0(**(float **)(v4 + 24), a1 + 372, 10, v3);
        if ( (unsigned __int8)v9 < (unsigned __int8)v5 )
        {
          v9 = v5;
          v8 = v2;
        }
      }
    }
    ++v2;
    v4 += 4;
    v3 += 28;
  }
  while ( v2 < 3u );
  v6 = (_DWORD *)(a1 + 76);
  v7 = 2;
  do
  {
    sub_10047FA0(v9, v6, v6 - 1, *(_BYTE *)(a1 + 4190), *(_DWORD *)(a1 + 28 * v8 + 4332));
    sub_1003E0F0(a2, (int)(v6 - 3));
    v6 += 13;
    --v7;
  }
  while ( v7 );
}

//----- (100214D0) --------------------------------------------------------
void __usercall sub_100214D0(int a1@<esi>, _BYTE *a2, int a3, float a4, float a5, float a6, float a7, char a8)
{
  int v8; // ebp@1
  _DWORD *v9; // edi@1
  double v10; // st7@1
  double v11; // st5@3
  double v12; // st6@3
  double v13; // st4@4
  double v14; // rt2@4
  double v15; // st3@4
  double v16; // st7@4
  double v17; // st3@5
  double v18; // rt1@5
  double v19; // st4@5
  int v20; // eax@6
  signed int v21; // ecx@6
  int v22; // edi@8
  signed int v23; // ebp@8
  signed int v24; // [sp+18h] [bp-4h]@1
  float v25; // [sp+38h] [bp+1Ch]@4
  float v26; // [sp+38h] [bp+1Ch]@4
  float v27; // [sp+38h] [bp+1Ch]@4
  float v28; // [sp+38h] [bp+1Ch]@4
  float v29; // [sp+38h] [bp+1Ch]@5
  float v30; // [sp+38h] [bp+1Ch]@5
  float v31; // [sp+38h] [bp+1Ch]@5
  float v32; // [sp+38h] [bp+1Ch]@9

  *(float *)a1 = a4;
  *(float *)(a1 + 4) = a5;
  *(_BYTE *)(a1 + 16) = 0;
  *(float *)(a1 + 8) = a6;
  v8 = a1 + 4324;
  *(float *)(a1 + 12) = a7;
  v9 = (_DWORD *)(a1 + 28);
  v24 = 6;
  *(float *)(a1 + 20) = *(float *)(a3 + 4);
  v10 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 4184) = 0;
  *(float *)(a1 + 24) = v10;
  do
  {
    *v9 = 0;
    sub_10048030(v8);
    ++v9;
    v8 += 28;
    --v24;
  }
  while ( v24 );
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 4060) = 0;
  v11 = a7;
  *(_DWORD *)(a1 + 4056) = -1;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 4108) = 0;
  *(_DWORD *)(a1 + 4104) = -1;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 4156) = 0;
  *(_DWORD *)(a1 + 4152) = -1;
  *(float *)(a1 + 4196) = a5 + a7;
  *(float *)(a1 + 4200) = a6;
  v12 = a6;
  *(float *)(a1 + 4204) = *(float *)&v11;
  *(float *)(a1 + 4212) = 0.0;
  *(float *)(a1 + 4216) = 0.0;
  *(float *)(a1 + 4220) = 1.0;
  *(float *)(a1 + 4232) = 1.0;
  *(float *)(a1 + 4244) = 1.0;
  *(float *)(a1 + 4256) = 1.0;
  *(float *)(a1 + 4268) = 1.0;
  *(float *)(a1 + 4280) = 1.0;
  *(float *)(a1 + 4292) = 1.0;
  *(float *)(a1 + 4304) = 1.0;
  *(float *)(a1 + 4224) = 0.0;
  *(float *)(a1 + 4228) = 0.0;
  *(float *)(a1 + 4236) = 0.0;
  *(float *)(a1 + 4240) = 0.0;
  *(float *)(a1 + 4248) = 0.0;
  *(float *)(a1 + 4252) = 0.0;
  *(float *)(a1 + 4260) = 0.0;
  *(float *)(a1 + 4264) = 0.0;
  *(float *)(a1 + 4272) = 0.0;
  *(float *)(a1 + 4276) = 0.0;
  *(float *)(a1 + 4284) = 0.0;
  *(float *)(a1 + 4288) = 0.0;
  *(float *)(a1 + 4296) = 0.0;
  *(float *)(a1 + 4300) = 0.0;
  *(_BYTE *)(a1 + 4308) = 2;
  *(float *)(a1 + 4212) = *(float *)(a3 + 4);
  *(float *)(a1 + 4224) = *(float *)(a3 + 8);
  if ( a8 )
  {
    *(_BYTE *)(a1 + 4208) = 1;
    *(_BYTE *)(a1 + 504) = 3;
    v25 = a4 + v12;
    *(float *)(a1 + 4192) = v25;
    v13 = v25;
    *(float *)(a1 + 4216) = 0.0;
    *(float *)(a1 + 4228) = a7;
    v26 = v12 * 0.8999999761581421;
    *(float *)(a1 + 460) = v26;
    v14 = v26;
    *(float *)(a1 + 464) = v11 * 0.1000000014901161;
    v27 = v13 - 1.0;
    v15 = v27;
    *(float *)(a1 + 452) = v27;
    v28 = *(float *)(a1 + 4196);
    *(float *)(a1 + 456) = v28;
    *(float *)(a1 + 468) = (double)(signed int)(v15 - v14 * 0.8500000238418579) + 0.5;
    *(float *)(a1 + 472) = v28;
    *(float *)(a1 + 492) = 0.0;
    *(float *)(a1 + 496) = 0.5;
    v16 = 0.0;
    *(float *)(a1 + 68) = a5 - 4.0;
    *(float *)(a1 + 120) = *(float *)(a1 + 68) - 16.0;
    *(float *)(a1 + 4040) = a4;
  }
  else
  {
    *(_BYTE *)(a1 + 4208) = 0;
    *(float *)(a1 + 4192) = a4;
    *(_BYTE *)(a1 + 504) = 1;
    v17 = 0.0;
    *(float *)(a1 + 4216) = *(float *)&v17;
    *(float *)(a1 + 4228) = a6;
    *(float *)(a1 + 460) = v12 * 0.1000000014901161;
    v29 = v11 * 0.8999999761581421;
    *(float *)(a1 + 464) = v29;
    v18 = v29;
    *(float *)(a1 + 452) = a4;
    v30 = *(float *)(a1 + 4196) - 1.0;
    *(float *)(a1 + 456) = v30;
    v19 = a4;
    *(float *)(a1 + 468) = *(float *)&v19;
    v31 = v30 - v18 * 0.8500000238418579;
    *(float *)(a1 + 472) = sub_100707A0(v31, 1.0);
    *(float *)(a1 + 492) = 0.5;
    *(float *)(a1 + 496) = 0.0;
    *(float *)(a1 + 68) = a5 - 2.0;
    *(float *)(a1 + 120) = *(float *)(a1 + 68) - 12.0 - 2.0;
    *(float *)(a1 + 4040) = a4 + a6;
    v16 = 1.0;
  }
  *(float *)(a1 + 4076) = v16;
  *(float *)(a1 + 500) = 9.0;
  *(_DWORD *)(a1 + 508) = -1;
  *(_BYTE *)(a1 + 512) = 1;
  *(_BYTE *)(a1 + 513) = 0;
  *(_BYTE *)(a1 + 514) = 2;
  *(_DWORD *)(a1 + 476) = 0;
  *(_DWORD *)(a1 + 480) = -16777216;
  strncpy((char *)(a1 + 484), byte_100879F8, 7u);
  *(_DWORD *)(a1 + 4048) = 0;
  *(_DWORD *)(a1 + 4052) = -1;
  *(float *)(a1 + 4044) = a5 - 3.0;
  v20 = a1 + 4085;
  v21 = 3;
  *(float *)(a1 + 4072) = 1.0;
  *(float *)(a1 + 4064) = *(float *)(a3 + 4);
  *(float *)(a1 + 4068) = *(float *)(a3 + 8);
  *(float *)(a1 + 4080) = 15.0;
  do
  {
    *(_BYTE *)(v20 - 1) = 0;
    *(_BYTE *)v20 = 0;
    *(_BYTE *)(v20 + 1) = 0;
    v20 += 48;
    --v21;
  }
  while ( v21 );
  *(_BYTE *)(a1 + 4184) = 1;
  *(_WORD *)(a1 + 4312) = 12;
  *(_DWORD *)(a1 + 4316) = &unk_100984F8;
  *(_BYTE *)(a1 + 4320) = 1;
  v22 = a1 + 104;
  v23 = 2;
  do
  {
    v32 = a6 * 0.5 + a4;
    *(float *)(v22 - 40) = v32;
    *(float *)v22 = 0.5;
    *(_DWORD *)(v22 - 32) = 0;
    *(float *)(v22 + 4) = 1.0;
    *(_DWORD *)(v22 - 28) = -1;
    *(float *)(v22 + 8) = 12.0;
    strncpy((char *)(v22 - 24), byte_100879F8, 1u);
    v22 += 52;
    --v23;
  }
  while ( v23 );
  sub_10038450(a1 + 80, a2, 21);
  sub_10020BA0(a3, 0.40000001, 0.0, a1);
  sub_10020EB0(0, 0, 0, a1);
  *(_DWORD *)(a1 + 4185) = 0;
  *(_WORD *)(a1 + 4189) = 0;
}

//----- (10021990) --------------------------------------------------------
void __usercall sub_10021990(int a1@<eax>)
{
  int v1; // edi@1
  int v2; // esi@2
  int v3; // ebx@2
  float **v4; // ebp@2
  double v5; // st7@9
  double v6; // st7@13
  float v7; // ST00_4@15
  int v8; // esi@19
  signed int v9; // edi@19
  float *v10; // ecx@20
  float v11; // [sp+4h] [bp-30h]@13
  float v12; // [sp+8h] [bp-2Ch]@13
  float v13; // [sp+Ch] [bp-28h]@13
  float v14; // [sp+10h] [bp-24h]@13
  float v15; // [sp+14h] [bp-20h]@13
  char v16; // [sp+18h] [bp-1Ch]@13
  float v17; // [sp+2Ch] [bp-8h]@1
  signed int v18; // [sp+30h] [bp-4h]@2

  v17 = 1.0;
  v1 = a1;
  if ( *(_BYTE *)(a1 + 4186) == 1 )
  {
    if ( *(_BYTE *)(a1 + 4187) != 1 )
    {
      v8 = a1 + 4060;
      v9 = 3;
      do
      {
        v10 = *(float **)v8;
        if ( *(_DWORD *)v8
          && !*(_BYTE *)(v8 + 26)
          && (9.8999998e24 == *v10
           || *(_BYTE *)(v8 + 24) && (*(float *)(v8 + 4) > (double)*v10 || *(float *)(v8 + 8) < (double)*v10)) )
        {
          sub_1003C630(v8 - 20);
        }
        v8 += 48;
        --v9;
      }
      while ( v9 );
    }
  }
  else
  {
    v2 = a1 + 504;
    v3 = a1 + 4040;
    v4 = (float **)(a1 + 28);
    v18 = 3;
    do
    {
      if ( *(_BYTE *)(v2 + 8)
        && (*v4 && 9.8999998e24 == **v4 || *(_DWORD *)(v3 + 20) && !(unsigned __int8)sub_10035900(v3)) )
      {
        switch ( *(_BYTE *)v2 )
        {
          case 1:
          case 3:
            v5 = 1.0;
            goto LABEL_11;
          case 0:
          case 2:
            v5 = 0.0;
LABEL_11:
            v17 = v5;
            break;
          default:
            break;
        }
        if ( *(_BYTE *)(v1 + 4208) == 1 )
        {
          v16 = *(_BYTE *)(v1 + 16);
          v15 = 1.0;
          v14 = v17;
          v13 = *(float *)(v1 + 4204);
          v12 = *(float *)(v2 - 44);
          v11 = *(float *)(v1 + 4196);
          v6 = *(float *)(v2 - 52);
        }
        else
        {
          v16 = *(_BYTE *)(v1 + 16);
          v15 = v17;
          v14 = 0.0;
          v13 = *(float *)(v2 - 40);
          v12 = *(float *)(v1 + 4200);
          v11 = *(float *)(v2 - 48);
          v6 = *(float *)(v1 + 4192);
        }
        v7 = v6;
        sub_10039220(v7, v11, v12, v13, v14, v15, v16);
      }
      ++v4;
      v3 += 48;
      v2 += 64;
      --v18;
    }
    while ( v18 );
  }
}

//----- (10021B30) --------------------------------------------------------
void __cdecl sub_10021B30(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8)
{
  sub_100214D0(a1, (_BYTE *)a2, a3, a4, a5, a6, a7, a8);
}

//----- (10021B70) --------------------------------------------------------
void __cdecl sub_10021B70(int a1, int a2, int a3, float a4, float a5, float a6, float a7, int a8)
{
  int v8; // esi@1
  int v9; // edi@1
  double v10; // st5@2
  double v11; // st4@2
  double v12; // st7@2
  double v13; // st3@2
  double v14; // st2@2
  double v15; // st6@2
  double v16; // st7@2
  double v17; // st6@3
  double v18; // rt2@3
  double v19; // ST2C_8@3
  double v20; // st7@3
  double v21; // st7@4
  double v22; // st5@4
  double v23; // st4@4
  float v24; // [sp+30h] [bp+4h]@3
  float v25; // [sp+38h] [bp+Ch]@2
  float v26; // [sp+38h] [bp+Ch]@3
  float v27; // [sp+3Ch] [bp+10h]@4
  int v28; // [sp+4Ch] [bp+20h]@2
  int v29; // [sp+4Ch] [bp+20h]@2
  int v30; // [sp+4Ch] [bp+20h]@2
  int v31; // [sp+4Ch] [bp+20h]@2
  int v32; // [sp+4Ch] [bp+20h]@2
  float v33; // [sp+4Ch] [bp+20h]@2
  int v34; // [sp+4Ch] [bp+20h]@3
  int v35; // [sp+4Ch] [bp+20h]@3
  int v36; // [sp+4Ch] [bp+20h]@3
  int v37; // [sp+4Ch] [bp+20h]@3
  int v38; // [sp+4Ch] [bp+20h]@3
  int v39; // [sp+4Ch] [bp+20h]@3
  int v40; // [sp+4Ch] [bp+20h]@3

  v8 = a1;
  v9 = a3;
  sub_100214D0(a1, (_BYTE *)a2, a3, a4, a5, a6, a7, a8);
  if ( (_BYTE)a8 )
  {
    *(_BYTE *)(a1 + 504) = 3;
    *(float *)&v28 = a6 * 0.5 + a4;
    v10 = *(float *)&v28;
    *(float *)(a1 + 4192) = *(float *)&v28;
    *(float *)&v29 = *(float *)&v28 - 1.0;
    v11 = *(float *)&v29;
    *(float *)(a1 + 452) = *(float *)&v29;
    v30 = *(int *)(a1 + 4196);
    *(float *)(a1 + 456) = *(float *)&v30;
    v12 = *(float *)&v30;
    *(float *)&v31 = a6 * 0.449999988079071;
    v13 = *(float *)&v31;
    *(float *)(a1 + 460) = *(float *)&v31;
    v25 = a7 * 0.1000000014901161;
    *(float *)(a1 + 464) = v25;
    *(_BYTE *)(a1 + 568) = 2;
    *(float *)(a1 + 468) = (double)(signed int)(v11 - 0.8500000238418579 * *(float *)&v31) + 0.5;
    *(float *)(a1 + 472) = v12;
    *(float *)(a1 + 492) = 0.0;
    *(float *)(a1 + 496) = 0.5;
    *(float *)&v32 = v10 + 1.0;
    v14 = *(float *)&v32;
    *(float *)(a1 + 516) = *(float *)&v32;
    v33 = *(float *)(a1 + 4196);
    *(float *)(a1 + 520) = v33;
    *(float *)(a1 + 524) = v13;
    *(float *)(a1 + 528) = v25;
    *(float *)(a1 + 532) = (double)(signed int)(0.8500000238418579 * v13 + v14) + 0.5;
    *(float *)(a1 + 536) = v33;
    *(float *)(a1 + 556) = 1.0;
    *(float *)(a1 + 4072) = 1.0;
    v15 = 0.5;
    v16 = 0.0;
    *(float *)(a1 + 560) = *(float *)&v15;
  }
  else
  {
    *(_BYTE *)(a1 + 504) = 1;
    *(float *)&v34 = 0.5 * a7 + a5;
    v17 = *(float *)&v34;
    *(float *)(a1 + 4196) = *(float *)&v34;
    v35 = *(int *)(a1 + 4192);
    *(float *)(a1 + 452) = *(float *)&v35;
    v18 = *(float *)&v35;
    *(float *)&v36 = v17 - 1.0;
    *(float *)(a1 + 456) = *(float *)&v36;
    v26 = a6 * 0.1000000014901161;
    *(float *)(a1 + 460) = v26;
    v24 = a7 * 0.449999988079071;
    *(float *)(v8 + 464) = v24;
    *(float *)(v8 + 468) = v18;
    v19 = v24 * 0.8500000238418579;
    *(float *)&v37 = *(float *)&v36 - v19;
    *(float *)(v8 + 472) = sub_100706D0(*(float *)&v37, 1.0);
    *(_BYTE *)(v8 + 568) = 0;
    *(float *)(v8 + 492) = 0.5;
    *(float *)(v8 + 496) = 0.0;
    v38 = *(int *)(v8 + 4192);
    v20 = *(float *)&v38;
    *(float *)(v8 + 516) = *(float *)&v38;
    *(float *)&v39 = *(float *)(v8 + 4196) + 1.0;
    *(float *)(v8 + 520) = *(float *)&v39;
    *(float *)(v8 + 524) = v26;
    *(float *)(v8 + 528) = v24;
    *(float *)(v8 + 532) = v20;
    *(float *)&v40 = *(float *)&v39 + v19;
    *(float *)(v8 + 536) = sub_100705F0(*(float *)&v40, 1.0);
    *(float *)(v8 + 556) = 0.5;
    v16 = 1.0;
    *(float *)(v8 + 560) = 1.0;
    *(float *)(v8 + 4072) = 0.0;
  }
  *(float *)(v8 + 4076) = v16;
  *(float *)(v8 + 4120) = v16;
  *(float *)(v8 + 4124) = v16;
  *(float *)(v8 + 500) = 9.0;
  *(_DWORD *)(v8 + 508) = -1;
  *(_BYTE *)(v8 + 514) = 2;
  *(_DWORD *)(v8 + 476) = 0;
  *(_DWORD *)(v8 + 480) = -16777216;
  strncpy((char *)(v8 + 484), "L", 7u);
  *(float *)(v8 + 564) = 9.0;
  *(_DWORD *)(v8 + 572) = -1;
  *(_BYTE *)(v8 + 576) = 1;
  *(_BYTE *)(v8 + 577) = 0;
  *(_BYTE *)(v8 + 578) = 2;
  *(_DWORD *)(v8 + 540) = 0;
  *(_DWORD *)(v8 + 544) = -16777216;
  strncpy((char *)(v8 + 548), "R", 7u);
  v21 = a4;
  *(float *)(v8 + 4040) = a4;
  *(_DWORD *)(v8 + 4048) = 0;
  *(_DWORD *)(v8 + 4052) = -1;
  v27 = a5 - 3.0;
  *(float *)(v8 + 4044) = v27;
  *(float *)(v8 + 4064) = *(float *)(v9 + 4);
  v22 = *(float *)(v9 + 8);
  *(_DWORD *)(v8 + 4096) = 0;
  *(float *)(v8 + 4068) = v22;
  *(_DWORD *)(v8 + 4100) = -1;
  *(float *)(v8 + 4080) = 15.0;
  *(float *)(v8 + 4088) = v21 + a6;
  *(float *)(v8 + 4092) = v27;
  *(float *)(v8 + 4112) = *(float *)(v9 + 4);
  v23 = *(float *)(v9 + 8);
  *(_BYTE *)(v8 + 4184) = 2;
  *(float *)(v8 + 4116) = v23;
  *(float *)(v8 + 4128) = 15.0;
  *(float *)(v8 + 64) = v21 + a6 * 0.5;
  *(float *)(v8 + 104) = 0.5;
  sub_10020BA0(v9, 0.2, 0.5, v8);
}

//----- (10021FC0) --------------------------------------------------------
void __usercall sub_10021FC0(int a1@<esi>, int a2)
{
  signed int v2; // ebx@1
  int *v3; // ebp@2
  int v4; // edi@2
  float *v5; // ecx@4
  char v6; // ST48_1@11
  float **v7; // [sp+1Ch] [bp-8h]@2

  v2 = 0;
  if ( *(_BYTE *)(a1 + 4184) )
  {
    v3 = (int *)(a1 + 4332);
    v7 = (float **)(a1 + 52);
    v4 = a1 + 4060;
    do
    {
      if ( v2 >= 3 )
        break;
      v5 = *(float **)v4;
      if ( *(_DWORD *)v4
        && (*(_BYTE *)(v4 + 26)
         || 9.8999998e24 != *v5
         && (!*(_BYTE *)(v4 + 24) || *(float *)(v4 + 4) <= (double)*v5 && *(float *)(v4 + 8) >= (double)*v5))
        && *(_BYTE *)(a1 + 4187) != 1 )
      {
        v6 = sub_10047DE0(**v7, a1 + 372, 10, (int)(v3 - 2));
        sub_10047F10(v6, (_DWORD *)(v4 - 8), (int *)(v4 - 12), *(_BYTE *)(a1 + 4187), *v3);
        sub_1003AD10(a2, v4 - 20, *(_WORD *)(a1 + 4312), *(_DWORD *)(a1 + 4316), *(_BYTE *)(a1 + 4320));
      }
      ++v7;
      ++v2;
      v3 += 7;
      v4 += 48;
    }
    while ( v2 < *(_BYTE *)(a1 + 4184) );
  }
}

//----- (100220D0) --------------------------------------------------------
char __usercall sub_100220D0@<al>(int a1@<edi>, int a2, int a3, int a4, int a5, _WORD *a6)
{
  char result; // al@2

  switch ( *a6 )
  {
    case 0x8022:
    case 0x8078:
      sub_100213B0(a5);
      sub_100211D0(a5);
      sub_100213D0(a5, a2, a1);
      sub_10021210(a5, a2);
      sub_10021400(a5, a2);
      sub_10021FC0(a5, a2);
      sub_10021990(a5);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_10021210(a5, a2);
      sub_10021400(a5, a2);
      sub_10021FC0(a5, a2);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (100221D0) --------------------------------------------------------
bool __cdecl sub_100221D0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  char *v7; // ebp@1
  int v8; // edi@1
  bool result; // al@1
  _WORD *v10; // ebx@2
  int v11; // eax@4
  bool v12; // al@6
  bool v13; // zf@8
  bool v14; // al@10
  char *v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a1;
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v7 = a3;
  v8 = 0;
  result = sub_100378F0(a3, &v16, &v15);
  if ( result )
  {
    v10 = a2;
    do
    {
      if ( sub_10037870(v6, a5, v8) )
      {
        v11 = *(_DWORD *)(v6 + 56);
        LOWORD(a1) = *(_WORD *)v16 + *(_WORD *)(v11 + 36);
        HIWORD(a1) = *(_WORD *)(v16 + 2) + *(_WORD *)(v11 + 38);
        v12 = v8 == a6 && sub_100378A0(v6, v10, v11);
        v13 = v8 == a6;
        *(_BYTE *)(v6 + 3) = v12;
        v14 = v13 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
        *(_BYTE *)(v6 + 9) = v14;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_102D1B40[2 * (*(_DWORD *)v7 & 0xFF)])(
          v6,
          v7,
          &a1,
          *(_DWORD *)(a4 + 4 * v8),
          v10);
      }
      v7 = v15;
      ++v8;
      result = sub_100378F0(v15, &v16, &v15);
    }
    while ( result );
  }
  *(_BYTE *)(v6 + 3) = 0;
  return result;
}
// 102D1B40: using guessed type int dword_102D1B40[];

//----- (100222D0) --------------------------------------------------------
int __cdecl sub_100222D0(unsigned int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+4h] [bp+4h]@1

  v1 = word_101A1BD8[(a1 >> 5) & 0x1F];
  HIWORD(v3) = word_101A1BD8[a1 & 0x1F];
  LOWORD(v3) = v1;
  return v3;
}
// 101A1BD8: using guessed type __int16 word_101A1BD8[];

//----- (10022300) --------------------------------------------------------
char *__cdecl sub_10022300(unsigned int a1)
{
  return (char *)&unk_102D21E0 + 20 * ((a1 >> 10) & 0xF);
}

//----- (10022320) --------------------------------------------------------
int __cdecl sub_10022320(unsigned int a1)
{
  char *v1; // eax@1
  char v2; // cl@1
  int result; // eax@2

  v1 = sub_10022300(a1);
  if ( v2 & 1 )
    result = *((_DWORD *)v1 + 2);
  else
    result = *((_DWORD *)v1 + 1);
  return result;
}

//----- (10022340) --------------------------------------------------------
signed int __cdecl sub_10022340(__int16 a1)
{
  signed int result; // eax@1

  result = 1073741828;
  if ( a1 & 0xC000 )
  {
    if ( (a1 & 0xC000) == 0x8000 )
      result = 1073741829;
  }
  else
  {
    result = 1073741830;
  }
  return result;
}

//----- (10022370) --------------------------------------------------------
signed int __cdecl sub_10022370(int a1)
{
  int v1; // eax@1
  signed int result; // eax@3

  v1 = a1 & 0xC00000;
  if ( a1 & 0xC00000 )
  {
    if ( v1 == 0x400000 )
      result = 1;
    else
      result = v1 != 0x800000 ? 0 : 2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100223A0) --------------------------------------------------------
void *sub_100223A0()
{
  void *result; // eax@1

  result = (void *)dword_101B2054;
  if ( !dword_101B2054 )
    result = &unk_1009B8C0;
  return result;
}
// 101B2054: using guessed type int dword_101B2054;

//----- (100223B0) --------------------------------------------------------
int __usercall sub_100223B0@<eax>(_BYTE *a1@<eax>)
{
  int result; // eax@5

  if ( !*a1 )
    goto LABEL_9;
  do
  {
    if ( *a1 == 10 )
      break;
    ++a1;
  }
  while ( *a1 );
  if ( *a1 )
  {
    *a1 = 0;
    result = (int)(a1 + 1);
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (100223E0) --------------------------------------------------------
char __usercall sub_100223E0@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3)
{
  signed int v3; // ebx@1
  char result; // al@1
  char v5; // al@2
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2
  char v8; // [sp+Dh] [bp-3h]@1

  v3 = a1;
  result = 0;
  v6 = 0;
  v8 = 0;
  if ( a1 <= (signed int)a3 )
  {
    do
    {
      v7 = v3;
      v5 = sub_1006D900(a2, &v7, 0);
      if ( v5 > v6 )
        v6 = v5;
      ++v3;
    }
    while ( v3 <= a3 );
    result = v6;
  }
  return result;
}

//----- (10022430) --------------------------------------------------------
char __usercall sub_10022430@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7)
{
  unsigned int v7; // ecx@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ecx@1
  char *v11; // eax@4
  char v12; // cl@6
  signed __int16 v13; // dx@9
  int v14; // eax@25
  unsigned int v15; // ebx@29
  unsigned __int8 v16; // al@29
  __int16 v17; // dx@37
  __int16 v18; // cx@37
  unsigned int v19; // edi@42
  signed int v20; // ecx@44
  int v21; // edi@46
  unsigned int v22; // edi@52
  __int16 v23; // ax@52
  __int16 v24; // dx@55
  __int16 v25; // cx@55
  int v26; // eax@58
  char result; // al@63
  int v28; // [sp+0h] [bp-6Ch]@0
  int v29; // [sp+Ch] [bp-60h]@1
  char *v30; // [sp+10h] [bp-5Ch]@6
  signed int v31; // [sp+14h] [bp-58h]@1
  int v32; // [sp+18h] [bp-54h]@1
  int v33; // [sp+1Ch] [bp-50h]@1
  int v34; // [sp+20h] [bp-4Ch]@1
  int v35; // [sp+24h] [bp-48h]@1
  int v36; // [sp+28h] [bp-44h]@1
  int v37; // [sp+2Ch] [bp-40h]@1
  int v38; // [sp+30h] [bp-3Ch]@1
  __int16 v39; // [sp+30h] [bp-3Ch]@29
  __int16 v40; // [sp+32h] [bp-3Ah]@29
  int v41; // [sp+34h] [bp-38h]@1
  size_t v42; // [sp+3Ch] [bp-30h]@1
  signed int v43; // [sp+40h] [bp-2Ch]@9
  int v44; // [sp+44h] [bp-28h]@21
  int v45; // [sp+48h] [bp-24h]@15
  unsigned int v46; // [sp+4Ch] [bp-20h]@29
  signed int v47; // [sp+50h] [bp-1Ch]@1
  char v48; // [sp+54h] [bp-18h]@4

  v31 = a2;
  v42 = a1;
  v7 = strlen(a4);
  v34 = a5[2];
  v8 = a5[1];
  v35 = a5[3];
  v9 = v7;
  v36 = a5[4];
  v47 = v7;
  v32 = *a5;
  v33 = v8;
  v37 = a5[5];
  v29 = 0;
  v41 = *(_WORD *)(*a5 + 28);
  v10 = sub_1006D900(*a5, a4, v8);
  v38 = v10;
  if ( (signed __int16)v35 <= 0 )
    LOWORD(v35) = v10;
  if ( (unsigned int)v9 >= 0x14 )
    v11 = (char *)sub_10002860(a3, v9 + 1);
  else
    v11 = &v48;
  v12 = *(_BYTE *)(a3 + 3);
  v30 = v11;
  if ( v12 && a6 && v31 > 0 )
  {
    v13 = 1;
    v43 = 1;
  }
  else
  {
    v43 = 0;
    v13 = 1;
  }
  v45 = v12 && (!a6 || v31 >= 0 && v31 + 1 <= v9);
  v44 = *(_BYTE *)(a3 + 3) && a6 && (v31 < 0 || (signed int)(v31 + v42) < v9);
  if ( (v8 & 3) != 2 )
  {
    if ( v8 & 3 )
    {
      *(_WORD *)(a3 + 438) += (signed __int16)v35 / -2;
      v14 = ((signed __int16)v35 - v38) / 2;
    }
    else
    {
      *(_WORD *)(a3 + 438) += v13 - v35;
      v14 = (signed __int16)v35 - v38;
    }
    v8 = v8 & 0xFFFFFFFE | 2;
    v33 = v8;
    if ( v14 > 0 )
      v29 = v14;
  }
  v15 = v8 & 0xFFFFFFF7 | 4;
  v39 = v35 + v41 + *(_WORD *)(a3 + 438);
  v16 = v34;
  v40 = *(_WORD *)(a3 + 436);
  v46 = v8 & 0xFFFFFFF7 | 4;
  if ( !v43 && !v45 && v44 )
    v16 = 0;
  if ( *(_BYTE *)(a3 + 3) && !a6 && (byte_1026D91E || byte_102D1B20) )
  {
    v17 = v36;
    v18 = HIWORD(v35);
  }
  else
  {
    v17 = HIWORD(v35);
    v18 = v36;
  }
  *(_WORD *)(a3 + 428) = v17;
  *(_WORD *)(a3 + 430) = v18;
  sub_1006D960(a3 + 392, v32, byte_100879F8, v35, v8 & 0xFFFFFFF7 | 4, v16, v28);
  *(_WORD *)(a3 + 438) += v29;
  if ( *(_BYTE *)(a3 + 3) )
  {
    if ( v43 )
    {
      v19 = v8 & 0xFFFFFFF3;
      if ( a7 )
        --*(_WORD *)(a3 + 438);
      strncpy(v30, a4, v31);
      v20 = v31;
      if ( v31 >= v47 )
        v20 = v47;
      v30[v20] = 0;
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      v21 = sub_1006D960(a3 + 392, v32, v30, v35 - v29, v19 | 0x80000000, 0, v37) + v29;
      if ( a7 )
        *(_WORD *)(a3 + 438) += v41 + 1;
      else
        *(_WORD *)(a3 + 438) += v41;
      v15 = v46;
      v29 = v41 + v21;
      v8 = v33;
    }
    if ( v45 )
    {
      if ( a6 )
      {
        v22 = v34 & 0xFFFF0001 | 1;
        strncpy(v30, &a4[v31], v42);
        v30[v42] = 0;
        v23 = 0;
      }
      else
      {
        LOWORD(v22) = (unsigned __int8)v34;
        strcpy(v30, a4);
        v23 = v35 - v29;
      }
      if ( byte_1026D91E || byte_102D1B20 )
      {
        v24 = v36;
        v25 = HIWORD(v35);
      }
      else
      {
        v24 = HIWORD(v35);
        v25 = v36;
      }
      *(_WORD *)(a3 + 428) = v24;
      *(_WORD *)(a3 + 430) = v25;
      v26 = sub_1006D960(a3 + 392, v32, v30, v23, v15 | 0x80000000, v22, v37);
      v8 = v33;
      *(_WORD *)(a3 + 438) += v41;
      v29 += v41 + v26;
    }
    if ( v44 )
    {
      if ( a7 )
        ++*(_WORD *)(a3 + 438);
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      sub_1006D960(
        a3 + 392,
        v32,
        &a4[((v42 + v31) & 0x80000000) != 0 ? 0 : v42 + v31],
        v35 - v29,
        v8 & 0xFFFFFFF3 | 0x80000000,
        0,
        v37);
    }
  }
  else
  {
    *(_WORD *)(a3 + 428) = HIWORD(v35);
    *(_WORD *)(a3 + 430) = v36;
    sub_1006D960(a3 + 392, v32, a4, v35 - v29, v8 | 0x80000000, v34, v37);
  }
  *(_WORD *)(a3 + 436) = v40;
  result = (char)v30;
  *(_WORD *)(a3 + 438) = v39;
  if ( v30 != &v48 )
    result = sub_100024C0(a3, (unsigned int)v30);
  return result;
}
// 1026D91E: using guessed type char byte_1026D91E;
// 102D1B20: using guessed type char byte_102D1B20;

//----- (10022930) --------------------------------------------------------
__int16 __cdecl sub_10022930(_BYTE *a1, unsigned int a2)
{
  int v2; // edi@1
  __int16 result; // ax@2
  int v4; // ebx@3
  _BYTE *v5; // edx@3
  int v6; // ebp@3
  int v7; // esi@4
  _BYTE *v8; // edx@4
  int v9; // eax@4

  v2 = 0;
  if ( *a1 )
  {
    v4 = sub_10022340(a2);
    v6 = *((_DWORD *)sub_10022300(a2) + 1);
    do
    {
      v7 = sub_100223B0(v5);
      v9 = sub_1006D900(v6, v8, v4);
      if ( v2 <= v9 )
        v2 = v9;
      v5 = (_BYTE *)v7;
    }
    while ( v7 );
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10022990) --------------------------------------------------------
int __cdecl sub_10022990(unsigned int a1, unsigned int a2, float *a3)
{
  int v3; // esi@1
  _BYTE *v4; // eax@1

  v3 = *((_DWORD *)sub_10022300(a1) + 1);
  v4 = (_BYTE *)sub_1003E420(a2, a3);
  return sub_1006D900(v3, v4, 0);
}

//----- (100229C0) --------------------------------------------------------
int sub_100229C0()
{
  void *v0; // ebx@1
  unsigned __int8 v1; // al@2
  char *v2; // esi@2
  char v3; // al@2
  int v4; // eax@2
  char v5; // al@2
  int v6; // edi@2
  char v7; // al@2
  int v8; // edi@2
  char v9; // al@2
  int result; // eax@2

  v0 = &unk_1009B8CC;
  do
  {
    v1 = *(_BYTE *)v0;
    v2 = (char *)&unk_102D21E0 + 20 * ((*((_DWORD *)v0 - 1) >> 10) & 0xF);
    v2[12] = *(_BYTE *)v0;
    *(_DWORD *)v2 = FNT_get_fnt_hdr(v1);
    v3 = *((_BYTE *)v0 + 1);
    v2[13] = v3;
    v4 = FNT_get_fnt_hdr((unsigned __int8)v3);
    *((_DWORD *)v2 + 1) = v4;
    v5 = sub_1006D900(v4, ".", 0);
    v6 = *((_DWORD *)v2 + 1);
    v2[15] = v5;
    v7 = sub_100223E0(0x20u, v6, 0x5Fu);
    v8 = *((_DWORD *)v2 + 1);
    v2[16] = v7;
    v2[17] = sub_100223E0(0x30u, v8, 0x39u);
    v9 = *((_BYTE *)v0 + 2);
    v2[14] = v9;
    result = FNT_get_fnt_hdr((unsigned __int8)v9);
    v0 = (char *)v0 + 8;
    *((_DWORD *)v2 + 2) = result;
  }
  while ( (signed int)v0 < (signed int)"ib\\adl\\cdp_fld_2d_utl.c" );
  return result;
}
// 1006CAD0: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);

//----- (10022A60) --------------------------------------------------------
int __cdecl sub_10022A60(int a1, int a2, int a3, unsigned __int8 a4)
{
  _WORD *v4; // eax@1
  int v5; // esi@1
  __int16 v6; // cx@1
  __int16 v7; // dx@1
  _WORD *v8; // edi@1
  int v9; // edx@1
  int result; // eax@3
  int v11; // [sp+10h] [bp-8h]@1
  __int16 v12; // [sp+14h] [bp-4h]@1
  __int16 v13; // [sp+1Ch] [bp+4h]@1
  __int16 v14; // [sp+1Eh] [bp+6h]@1

  v4 = sub_100223A0();
  v5 = a1;
  v6 = *(_WORD *)(a1 + 426);
  v7 = *(_WORD *)(a1 + 424);
  v8 = v4;
  LOWORD(v4) = *(_WORD *)(a1 + 396);
  *(_WORD *)(a1 + 396) = 2;
  v12 = (signed __int16)v4;
  v13 = v6;
  *(_WORD *)(v5 + 426) = v8[3];
  v14 = v7;
  v9 = *(_DWORD *)(v5 + 428);
  *(_WORD *)(v5 + 424) = v8[3];
  v11 = v9;
  if ( a4 >= 2u )
    sub_10015C20("..\\lib\\adl\\cdp_fld_2d_utl.c", 982, 1, 0);
  *(_WORD *)(v5 + 428) = word_101A1BD8[*((_BYTE *)v8 + a4)];
  *(_WORD *)(v5 + 430) = word_101A1BD8[*((_BYTE *)v8 + a4 + 2)];
  *(_WORD *)(v5 + 438) = *(_WORD *)a2 + v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_1006E790(v5 + 392, *(_WORD *)a3 - v8[3], *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 438) = *(_WORD *)a3 - v8[3];
  *(_WORD *)(v5 + 436) = *(_WORD *)(a2 + 2) + v8[3];
  sub_1006E790(v5 + 392, v8[3] + *(_WORD *)a2, *(_WORD *)(a3 + 2) - v8[3], 0);
  *(_WORD *)(v5 + 426) = v13;
  *(_WORD *)(v5 + 424) = v14;
  result = HIWORD(v11);
  *(_WORD *)(v5 + 396) = v12;
  *(_WORD *)(v5 + 428) = v11;
  *(_WORD *)(v5 + 430) = HIWORD(v11);
  return result;
}
// 101A1BD8: using guessed type __int16 word_101A1BD8[];

//----- (10022BE0) --------------------------------------------------------
char __cdecl sub_10022BE0(int a1, const char *a2, int *a3)
{
  return sub_10022430(
           *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240),
           a1,
           a2,
           a3,
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
           1);
}

//----- (10022C20) --------------------------------------------------------
int __cdecl sub_10022C20(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // edx@1
  char v4; // si@1
  signed int v5; // eax@4

  v2 = *((_DWORD *)sub_10022300(a1) + 1);
  v3 = 1;
  v4 = 1;
  if ( !a2 )
  {
    if ( *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24) > 1 )
      v3 = *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24);
    v5 = *(_WORD *)(v2 + 26);
    if ( v5 > 1 )
      v4 = v5;
  }
  return (((v3 << 8) | (unsigned __int8)v4) << 16) | 0x101;
}

//----- (10022C80) --------------------------------------------------------
char __cdecl sub_10022C80(int a1, const char *a2, int *a3, int a4)
{
  int v4; // eax@1
  unsigned int v5; // edi@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@1
  char *v9; // edi@1
  int v10; // ecx@2
  int v11; // ebp@2
  int v12; // ecx@6
  char v14; // [sp+13h] [bp-11h]@1
  char *v15; // [sp+14h] [bp-10h]@1
  unsigned int v16; // [sp+18h] [bp-Ch]@1
  unsigned int v17; // [sp+1Ch] [bp-8h]@1
  __int16 v18; // [sp+20h] [bp-4h]@1
  signed int v19; // [sp+28h] [bp+4h]@1
  __int16 v20; // [sp+2Ch] [bp+8h]@1
  __int16 v21; // [sp+2Eh] [bp+Ah]@1

  v4 = a3[2];
  v5 = (unsigned int)a3[2] >> 24;
  v6 = ((unsigned int)a3[2] >> 16) & 0xFF;
  v16 = v4 & 0xFFFF0001 | 1;
  v14 = 1;
  v17 = (v4 & 0xFFFFFF ^ ((v5 + a4) << 24)) & 0xFFFF0001 | 1;
  v7 = a1;
  v15 = (char *)sub_10002860(a1, strlen(a2) + 1);
  strcpy(v15, a2);
  v21 = *(_WORD *)(a1 + 436);
  v19 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  v20 = *(_WORD *)(v7 + 438);
  v8 = v5 + v6 + *(_WORD *)(*a3 + 24) - *(_WORD *)(*a3 + 26);
  v9 = v15;
  v18 = a4 + v8;
  do
  {
    v11 = sub_100223B0(v9);
    *(_WORD *)(v7 + 438) = v20;
    *(_WORD *)(v7 + 436) = v21;
    if ( v11 )
      *(_DWORD *)(v10 + 8) = v17;
    else
      *(_DWORD *)(v10 + 8) = v16;
    if ( *(_BYTE *)(v7 + 3) && (v12 = *(_DWORD *)(v7 + 56), *(_WORD *)(v12 + 240) != -128) )
    {
      if ( v19 >= (signed int)strlen(v9) || v19 < 0 )
      {
        *(_BYTE *)(v7 + 3) = 0;
        sub_10022430(*(_BYTE *)(v12 + 242), -128, v7, v9, a3, 0, 0);
        *(_BYTE *)(v7 + 3) = 1;
      }
      else
      {
        sub_10022430(*(_BYTE *)(v12 + 242), v19, v7, v9, a3, 1, 0);
      }
      v19 -= strlen(v9);
    }
    else
    {
      if ( !v14 )
      {
        LOBYTE(a4) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v7 + 3) = 0;
      }
      sub_10022430(
        *(_BYTE *)(*(_DWORD *)(v7 + 56) + 242),
        v19,
        v7,
        v9,
        a3,
        *(_WORD *)(*(_DWORD *)(v7 + 56) + 240) != -128,
        1);
      if ( !v14 )
        *(_BYTE *)(v7 + 3) = a4;
    }
    v21 += v18;
    v9 = (char *)v11;
    v14 = 0;
  }
  while ( v11 );
  return sub_100024C0(v7, (unsigned int)v15);
}

//----- (10022E90) --------------------------------------------------------
int __cdecl sub_10022E90(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // edi@1
  int v5; // eax@1
  unsigned int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@3
  int result; // eax@3
  int v10; // [sp+18h] [bp+Ch]@1

  v4 = a3;
  v10 = sub_10022C20(a3, 0);
  v5 = *((_DWORD *)sub_10022300(v4) + 1);
  *(_WORD *)(a1 + 2) = HIWORD(a2) + *(_WORD *)(v5 + 26) - BYTE2(v10) - *(_WORD *)(v5 + 24) + 1;
  v7 = v4 & 0xC000;
  *(_WORD *)(a1 + 6) = HIWORD(a2) + *(_WORD *)(v5 + 22) + (v6 >> 24) - *(_WORD *)(v5 + 24) - 1;
  if ( v7 )
  {
    if ( v7 == 0x4000 )
    {
      *(_WORD *)(a1 + 4) = a2 + 1;
      result = a2 + 1 - a4 - 1;
      *(_WORD *)a1 = result;
    }
    else
    {
      v8 = a2 - (a4 + 2) / 2 - 1;
      *(_WORD *)a1 = v8;
      result = v8 + a4 + 2 - 1;
      *(_WORD *)(a1 + 4) = result;
    }
  }
  else
  {
    result = a2 - 1;
    *(_WORD *)(a1 + 4) = a2 - 1 + a4 + 1;
    *(_WORD *)a1 = a2 - 1;
  }
  return result;
}

//----- (10022F60) --------------------------------------------------------
__int16 __cdecl sub_10022F60(char *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // eax@1
  unsigned int v6; // edi@1
  int v7; // ebp@1
  int v8; // ebx@1
  char *v9; // eax@1
  int v10; // edx@3

  v5 = sub_10022C20(a2, 0);
  v6 = v5 >> 24;
  v7 = (v5 >> 16) & 0xFF;
  v8 = *((_DWORD *)sub_10022300(a2) + 1);
  v9 = strchr(a1, 10);
  for ( *(_DWORD *)a5 = 1; v9; ++*(_DWORD *)a5 )
    v9 = strchr(v9 + 1, 10);
  v10 = a3 + v6 + v7 + *(_WORD *)(v8 + 24) - *(_WORD *)(v8 + 26);
  *(_DWORD *)a4 = v10;
  return *(_WORD *)a5 * v10 - a3;
}

//----- (10022FF0) --------------------------------------------------------
char __cdecl sub_10022FF0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7)
{
  char *v7; // eax@1
  int v8; // ebx@1
  signed int v9; // edi@1
  signed int v10; // eax@4
  int v11; // ebp@4
  unsigned int v12; // ebx@4
  int v13; // eax@4
  __int16 v14; // cx@4
  int v15; // edx@4
  int v16; // edi@9
  signed int v17; // ecx@12
  __int64 v18; // rax@12
  __int16 v19; // dx@15
  __int16 v20; // dx@15
  int v21; // eax@17
  signed int v22; // edi@17
  int v24; // [sp+10h] [bp-30h]@1
  unsigned int v25; // [sp+14h] [bp-2Ch]@1
  unsigned int v26; // [sp+18h] [bp-28h]@1
  __int16 v27; // [sp+1Ch] [bp-24h]@2
  int v28; // [sp+1Eh] [bp-22h]@1
  int v29; // [sp+24h] [bp-1Ch]@4
  int v30; // [sp+28h] [bp-18h]@4
  unsigned int v31; // [sp+2Ch] [bp-14h]@4
  int v32; // [sp+30h] [bp-10h]@4
  char v33[6]; // [sp+34h] [bp-Ch]@4
  int v34; // [sp+3Ch] [bp-4h]@4

  v28 = sub_100222D0(a6);
  v7 = sub_10022300(a6);
  v8 = *((_DWORD *)v7 + 1);
  v24 = *((_DWORD *)v7 + 1);
  v26 = sub_10022C20(a6, 0) & 0xFFFFFF00;
  v9 = sub_10022340(a6);
  v25 = v9 & 0xFFFFFFFE | 2;
  if ( a7 & 0x200 )
  {
    v27 = 0;
    a3 = byte_100879F8;
  }
  else
  {
    v27 = a5;
  }
  v10 = sub_10022370(a6);
  v11 = v10;
  v29 = v10;
  *(_DWORD *)&v33[2] = sub_100222D0(a6);
  v30 = v8;
  v12 = v9 & 0xFFFFFFFC;
  v34 = v11;
  v32 = sub_10022C20(a6, 0);
  v31 = v9 & 0xFFFFFFFC;
  *(_WORD *)v33 = a4;
  v13 = sub_1006D900(v30, a2, v9 & 0xFFFFFFFC);
  v14 = v27;
  v15 = 0;
  if ( v27 > 0 && a4 > 0 )
    v15 = *(_WORD *)(v30 + 28);
  if ( a6 & 0xC000 )
  {
    if ( (a6 & 0xC000) == 0x8000 )
    {
      if ( v27 && a4 )
      {
        v17 = v15 + v27 + a4;
        v18 = v13 - *(_WORD *)(v30 + 28) - v27 + 1;
        v16 = (((signed int)v18 - HIDWORD(v18)) >> 1) - 1;
        LODWORD(v18) = v17 / 2 + v16 + 1;
        LOWORD(v17) = v17 - *(_WORD *)(v30 + 28);
        *(_WORD *)v33 = v18;
        v14 = v17 - v18;
        v27 = v14;
      }
      else
      {
        LOWORD(v16) = 0;
        v31 = v12 & 0xFFFFFFFD | 1;
        v25 = v25 & 0xFFFFFFFD | 1;
      }
    }
    else
    {
      v16 = -v27;
    }
  }
  else
  {
    if ( a4 > v13 )
    {
      v19 = v15 - *(_WORD *)(v30 + 28);
      *(_WORD *)v33 = v13;
      v20 = a4 + v19 - v13;
      v14 = v20 + v27;
      v27 += v20;
    }
    LOWORD(v16) = *(_WORD *)v33 - 1;
  }
  *(_WORD *)(a1 + 438) += v16;
  v21 = *(_DWORD *)(a1 + 56);
  v22 = *(_WORD *)(v21 + 240);
  if ( *(_WORD *)v33 > 0 )
  {
    LOBYTE(v21) = sub_10022430(*(_BYTE *)(v21 + 242), v22, a1, a2, &v30, *(_WORD *)(v21 + 240) != -128, 1);
    v14 = v27;
  }
  if ( v14 > 0 )
  {
    if ( v22 != -128 )
      v22 -= strlen(a2);
    LOBYTE(v21) = sub_10022430(
                    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
                    v22,
                    a1,
                    a3,
                    &v24,
                    *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
                    1);
  }
  return v21;
}

//----- (10023210) --------------------------------------------------------
void __cdecl sub_10023210(int a1, int (__cdecl *a2)(int))
{
  char v2; // bl@2

  if ( !*(_DWORD *)(a1 + 72) )
  {
    v2 = sub_10002940(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 32) + 8));
    if ( sub_10002940(a2) != v2 )
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_DWORD *)(a1 + 32) + 8);
  }
}

//----- (10023250) --------------------------------------------------------
unsigned int __usercall sub_10023250@<eax>(unsigned int result@<eax>)
{
  int *v1; // ecx@2
  unsigned int v2; // ecx@3

  if ( !dword_102D1FA8 )
  {
    dword_102D1FA8 = *(_DWORD *)(result + 32);
    v1 = *(int **)(result + 32);
    if ( v1 )
    {
      v2 = *v1;
      *(_DWORD *)(result + 32) = v2;
      if ( !v2 || *(_DWORD *)(result + 48) < v2 )
        *(_DWORD *)(result + 48) = v2;
      result = v2;
      if ( v2 )
        *(_DWORD *)(v2 + 4) = 0;
    }
  }
  return result;
}
// 102D1FA8: using guessed type int dword_102D1FA8;

//----- (10023290) --------------------------------------------------------
int __usercall sub_10023290@<eax>(int result@<eax>)
{
  if ( dword_102D1FA8 )
  {
    *(_DWORD *)(*(_DWORD *)(result + 32) + 4) = dword_102D1FA8;
    *(_DWORD *)dword_102D1FA8 = *(_DWORD *)(result + 32);
    *(_DWORD *)(result + 32) = dword_102D1FA8;
    dword_102D1FA8 = 0;
  }
  return result;
}
// 102D1FA8: using guessed type int dword_102D1FA8;

//----- (100232C0) --------------------------------------------------------
void __cdecl sub_100232C0(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4, int a5)
{
  void *v5; // ecx@0
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // eax@2
  char v10; // bl@13
  int v11; // eax@22
  int v12; // edx@26
  int v13; // ecx@26
  int v14; // edx@26
  int v15; // ecx@26
  int v16; // edx@26
  int v17; // eax@29
  unsigned int v18; // eax@32
  unsigned int v19; // ebx@34
  int v20; // eax@46
  int v21; // eax@59
  bool v22; // al@63
  int v23; // edx@63
  int (__cdecl *v24)(int); // [sp+10h] [bp-D8h]@1
  unsigned int v25; // [sp+14h] [bp-D4h]@32
  __int16 i; // [sp+18h] [bp-D0h]@25
  unsigned int v27; // [sp+1Ch] [bp-CCh]@25
  int v28; // [sp+20h] [bp-C8h]@25
  int v29; // [sp+24h] [bp-C4h]@25
  int v30; // [sp+28h] [bp-C0h]@26
  int v31; // [sp+2Ch] [bp-BCh]@26
  int v32; // [sp+30h] [bp-B8h]@26
  int v33; // [sp+34h] [bp-B4h]@26
  int v34; // [sp+38h] [bp-B0h]@26
  int v35; // [sp+3Ch] [bp-ACh]@26

  v6 = (int)a3;
  v7 = *(_DWORD *)(a1 + 48);
  v8 = 0;
  v24 = a3;
  if ( v7 )
  {
    v9 = a2;
    switch ( a2 )
    {
      case -1:
        sub_10023290(a1);
        goto LABEL_4;
      case -5:
LABEL_4:
        v8 = *(_DWORD *)(a1 + 32);
        v7 = 0;
        goto LABEL_20;
      case -2:
        v8 = 0;
        do
        {
          if ( sub_10002980(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v8 = v7;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        goto LABEL_20;
      case -3:
        do
        {
          if ( sub_10002980(*(int (__cdecl **)(int))(v7 + 8)) != -1 )
            break;
          v7 = *(_DWORD *)(v7 + 4);
        }
        while ( v7 );
        v8 = v7;
        if ( v7 )
          v7 = *(_DWORD *)(v7 + 4);
        goto LABEL_20;
      case -6:
        v8 = *(_DWORD *)(a1 + 48);
        v10 = sub_10002980(a3);
        if ( !v7 )
          goto LABEL_16;
        break;
      case -7:
        if ( (unsigned __int8)sub_10025860(v5) )
        {
          sub_10023250(a1);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        else
        {
          sub_10023210(a1, a3);
          v8 = *(_DWORD *)(a1 + 32);
          v7 = 0;
        }
        goto LABEL_20;
      case -8:
        if ( (unsigned __int8)sub_10025860(v5) )
        {
          sub_10023290(a1);
LABEL_45:
          v7 = *(_DWORD *)(a1 + 32);
          v8 = *(_DWORD *)v7;
        }
        else
        {
          v20 = *(_DWORD *)(a1 + 72);
          if ( v20 )
          {
            v8 = *(_DWORD *)(a1 + 32);
            v7 = 0;
            v24 = *(int (__cdecl **)(int))(a1 + 72);
            *(_DWORD *)(a1 + 72) = 0;
            v6 = v20;
          }
        }
        goto LABEL_20;
      case -4:
        goto LABEL_45;
      default:
        if ( a2 > 0 )
        {
          do
          {
            if ( !v7 )
              break;
            --v9;
            v8 = v7;
            v7 = *(_DWORD *)(v7 + 4);
          }
          while ( v9 > 0 );
        }
        goto LABEL_20;
    }
    do
    {
      if ( sub_10002980(*(int (__cdecl **)(int))(v8 + 8)) == v10 )
      {
        if ( *(int (__cdecl **)(int))(v8 + 8) == a3 )
        {
          v8 = *(_DWORD *)v8;
          v24 = 0;
        }
        v7 = *(_DWORD *)(v8 + 4);
        goto LABEL_19;
      }
      v8 = *(_DWORD *)(v8 + 4);
    }
    while ( v8 );
LABEL_16:
    v7 = *(_DWORD *)(a1 + 48);
    v8 = 0;
    if ( v7 )
    {
      while ( sub_10002980(*(int (__cdecl **)(int))(v7 + 8)) == -1 )
      {
        v7 = *(_DWORD *)(v7 + 4);
        if ( !v7 )
          goto LABEL_19;
      }
      v8 = *(_DWORD *)v7;
    }
LABEL_19:
    v6 = (int)v24;
  }
LABEL_20:
  if ( v6 )
  {
    if ( a4 || (v11 = v7) == 0 )
    {
LABEL_25:
      ++*(_BYTE *)(a1 + 4);
      i = -32703;
      v27 = 0;
      v28 = v6;
      LOBYTE(v29) = 0;
      if ( a5 )
      {
        v12 = *(_DWORD *)(a5 + 4);
        v30 = *(_DWORD *)a5;
        v13 = *(_DWORD *)(a5 + 8);
        v31 = v12;
        v14 = *(_DWORD *)(a5 + 12);
        v32 = v13;
        v15 = *(_DWORD *)(a5 + 16);
        v33 = v14;
        v16 = *(_DWORD *)(a5 + 20);
        v34 = v15;
        v35 = v16;
        LOBYTE(v29) = 1;
      }
      sub_10001740(a1, (int)&i, 204);
    }
    else
    {
      while ( *(_DWORD *)(v11 + 8) != v6 )
      {
        v11 = *(_DWORD *)(v11 + 4);
        if ( !v11 )
          goto LABEL_25;
      }
      v7 = *(_DWORD *)(v11 + 4);
      v8 = v11;
      v24 = 0;
      v6 = 0;
    }
  }
  if ( v8 )
  {
    v17 = sub_100015D0(a1, v6);
    if ( !v6 || !v17 || !sub_100010B0(a1, v17) )
    {
      v18 = sub_10001180(a1, v7);
      v25 = v18;
      if ( v18 )
        *(_BYTE *)(v18 + 26) = 0;
      v19 = v7;
      if ( v7 )
      {
        while ( v19 >= v18 )
        {
          i = -32734;
          v27 = v19;
          sub_10001740(a1, (int)&i, 204);
          v19 = *(_DWORD *)(v19 + 4);
          if ( !v19 )
            break;
          v18 = v25;
        }
      }
      v6 = (int)v24;
    }
  }
  if ( !v6 || v8 )
  {
    if ( v7 && v8 )
    {
      i = -32665;
      v27 = v7;
      v22 = sub_100010B0(a1, *(_DWORD *)v7);
      v23 = *(_DWORD *)(a1 + 56);
      LOBYTE(v28) = v22;
      v29 = *(_DWORD *)(v8 + 8);
      *(_BYTE *)(v23 + 25) = v22;
      sub_10001740(a1, (int)&i, 204);
    }
  }
  else
  {
    v21 = *(_DWORD *)(a1 + 48);
    if ( v21 )
    {
      i = -32695;
      v27 = v21;
      sub_10001740(a1, (int)&i, 204);
    }
  }
  for ( i = -32744; v8; v8 = *(_DWORD *)v8 )
  {
    v27 = v8;
    sub_10001740(a1, (int)&i, 204);
  }
}

//----- (10023670) --------------------------------------------------------
void __cdecl sub_10023670(unsigned int a1, int a2, int (__cdecl *a3)(int), char a4)
{
  sub_100232C0(a1, a2, a3, a4, 0);
}

//----- (10023690) --------------------------------------------------------
void __cdecl sub_10023690(int a1, unsigned __int8 a2)
{
  int v2; // edi@1
  double v3; // st7@2
  float *v4; // esi@2

  v2 = a2;
  if ( (signed int)a2 > 0 )
  {
    v3 = 9.8999998e24;
    v4 = (float *)(a1 + 8);
    do
    {
      if ( v3 == *(v4 - 1) )
      {
        *v4 = v3;
      }
      else
      {
        *v4 = sub_10048270(*(v4 - 1), *v4, 40, *(v4 - 2));
        v3 = 9.8999998e24;
      }
      v4 += 3;
      --v2;
    }
    while ( v2 );
  }
}

//----- (100236F0) --------------------------------------------------------
double __cdecl sub_100236F0(unsigned __int16 a1)
{
  float v1; // ecx@0
  float v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  if ( !sub_10040700(a1, &v3) )
    v3 = 9.8999998e24;
  return v3;
}

//----- (10023720) --------------------------------------------------------
unsigned __int8 __cdecl sub_10023720(unsigned int a1)
{
  unsigned __int8 result; // al@1

  result = 0;
  do
  {
    if ( a1 < *(_DWORD *)(dword_102D2B10 + 4 * result + 20816) )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}
// 102D2B10: using guessed type int dword_102D2B10;

//----- (10023750) --------------------------------------------------------
int __cdecl sub_10023750(unsigned int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // esi@2
  char v4; // bl@4
  int result; // eax@5

  if ( a2 >= 4u )
  {
    result = 0xFFFFFF;
  }
  else
  {
    v3 = a1;
    if ( a3 )
      v3 = a1 - *(_DWORD *)(dword_102D2B10 + 4 * a2 + 20812);
    v4 = byte_1009C48C[12 * a2];
    if ( sub_100488E0(v3, (unsigned __int8)byte_1009C48C[12 * a2]) )
      result = dword_102D22C0[3 * (unsigned __int8)v4] + v3 * (unsigned __int16)word_102D22C4[6 * (unsigned __int8)v4];
    else
      result = 0xFFFFFF;
  }
  return result;
}
// 102D22C0: using guessed type int dword_102D22C0[];
// 102D22C4: using guessed type __int16 word_102D22C4[];
// 102D2B10: using guessed type int dword_102D2B10;

//----- (100237D0) --------------------------------------------------------
int __cdecl sub_100237D0(unsigned int a1)
{
  unsigned __int8 v1; // ST14_1@1

  v1 = sub_10023720(a1);
  return sub_10023750(a1, v1, 1);
}

//----- (10023800) --------------------------------------------------------
char __cdecl sub_10023800(__int64 a1)
{
  char v1; // bl@1
  char result; // al@3
  unsigned __int16 v3; // ax@7

  v1 = 9;
  if ( (unsigned int)a1 < 0x3E8 )
  {
LABEL_13:
    result = v1;
  }
  else
  {
    switch ( sub_10023720(a1) )
    {
      case 0u:
        result = 0;
        break;
      case 1u:
        result = 1;
        break;
      case 2u:
        result = 2;
        break;
      case 3u:
        result = 3;
        break;
      default:
        v3 = WORD1(a1) >> 10;
        if ( (unsigned __int16)(WORD1(a1) >> 10) >= 0xBu && v3 < 0xDu
          || v3 >= 5u && v3 <= 8u && (unsigned __int16)(a1 - 1000) < (unsigned int)sub_10048920(8u) )
        {
          v1 = (*(_DWORD *)((char *)&a1 + 2) >> 10) & 0x3F;
        }
        goto LABEL_13;
    }
  }
  return result;
}

//----- (100238A0) --------------------------------------------------------
double __cdecl sub_100238A0(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-28h]@0
  float v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@2
  int v6; // [sp+12h] [bp-12h]@2

  v4 = 9.9999996e24;
  LODWORD(v3) = a1;
  if ( !sub_10023800(v3) )
  {
    v1 = sub_100237D0(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_102D21D4)(v1, 28, &v5);
    v4 = (double)((v6 & 0x7FFF) - 5000) * 0.3048000037670135;
  }
  return v4;
}
// 102D21D4: using guessed type int dword_102D21D4;

//----- (10023910) --------------------------------------------------------
char __cdecl sub_10023910(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  char result; // al@1

  result = 0;
  if ( a2 != 0x3FFFF && a1 != -1 && a1 >= a3 && a1 <= a4 )
    result = 1;
  return result;
}

//----- (10023940) --------------------------------------------------------
char __usercall sub_10023940@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6)
{
  signed int v6; // esi@3
  int v7; // ebx@6
  int v8; // edi@6
  signed int v9; // esi@7
  __int64 v11; // [sp-Ch] [bp-14h]@6
  __int64 v12; // [sp-4h] [bp-Ch]@0

  *a5 = 0x3FFFF;
  *a6 = -1;
  if ( (_BYTE)a1 == -1 || a2 )
  {
    HIDWORD(v11) = a3;
    v7 = a2;
    v8 = (unsigned __int8)a1;
    if ( a2 >= (signed int)(unsigned __int8)a1 )
    {
      while ( 1 )
      {
        a1 = sub_10024A30(a4, v7);
        v9 = a1;
        if ( a1 != 0x3FFFF )
        {
          LODWORD(v11) = a1;
          LOBYTE(a1) = sub_10023800(v11);
          if ( !(_BYTE)a1 )
            break;
        }
        if ( --v7 < v8 )
          return a1;
      }
      LOBYTE(a1) = (_BYTE)a5;
      *a6 = v7;
      *a5 = v9;
    }
  }
  else
  {
    a1 = sub_10024A30(a4, 0);
    v6 = a1;
    if ( a1 != 0x3FFFF )
    {
      LODWORD(v12) = a1;
      LOBYTE(a1) = sub_10023800(v12);
      if ( !(_BYTE)a1 )
      {
        LOBYTE(a1) = (_BYTE)a6;
        *a6 = 0;
        *a5 = v6;
      }
    }
  }
  return a1;
}
// 10023940: could not find valid save-restore pair for edi

//----- (100239E0) --------------------------------------------------------
char __usercall sub_100239E0@<al>(int a1@<ebx>, _BYTE *a2, int *a3)
{
  int v3; // ebp@1
  signed int v4; // esi@1
  int *v5; // esi@4
  _BYTE *v6; // edi@4
  signed int v7; // eax@4
  char v8; // bl@5
  unsigned __int8 v9; // dl@15
  char v10; // cl@20
  unsigned __int8 v11; // cl@26
  unsigned __int8 v13; // [sp-10h] [bp-38h]@23
  signed int *v14; // [sp-Ch] [bp-34h]@23
  __int64 v15; // [sp-8h] [bp-30h]@5
  _BYTE *v16; // [sp-8h] [bp-30h]@23
  char v17; // [sp+Ch] [bp-1Ch]@1
  char v18; // [sp+Dh] [bp-1Bh]@1
  char v19; // [sp+Eh] [bp-1Ah]@2
  char v20; // [sp+Fh] [bp-19h]@15
  int v21; // [sp+10h] [bp-18h]@1
  unsigned __int8 v22; // [sp+14h] [bp-14h]@1
  int v23; // [sp+18h] [bp-10h]@5
  unsigned __int8 v24; // [sp+1Ch] [bp-Ch]@1
  unsigned __int8 v25; // [sp+20h] [bp-8h]@1
  unsigned __int8 v26; // [sp+24h] [bp-4h]@1
  char v27; // [sp+2Ch] [bp+4h]@5
  unsigned __int8 v28; // [sp+30h] [bp+8h]@5
  char v29; // [sp+30h] [bp+8h]@15

  v18 = sub_100249F0(0);
  v25 = sub_10024C10(0);
  v26 = sub_10024C90(0);
  v3 = sub_100249B0(0);
  v24 = sub_10024C50(0);
  v22 = sub_10024CD0(0);
  v4 = sub_10024A90(0);
  v21 = v4;
  v17 = sub_10024D10(0);
  if ( v3 != 0x3FFFF || (v19 = 0, v4 != 0x3FFFF) )
    v19 = 1;
  v5 = a3;
  v6 = a2;
  *a3 = 0x3FFFF;
  *a2 = -1;
  LOBYTE(v7) = sub_100463F0();
  if ( (_BYTE)v7 )
  {
    HIDWORD(v15) = a1;
    sub_10048960();
    v8 = *(_BYTE *)(dword_102D2B2C + 812);
    v27 = *(_BYTE *)(dword_102D2B2C + 816);
    v23 = *(_DWORD *)(dword_102D2B2C + 840);
    v28 = v8;
    if ( (unsigned __int8)v8 >= 0x66u && v8 != -1 )
    {
      v8 = -1;
      v28 = -1;
    }
    if ( ((unsigned __int8)v8 > (unsigned __int8)v18
       || *(_BYTE *)(dword_102D2B20 + 4) != v18
       || *(_DWORD *)(dword_102D2B20 + 264) != v3
       || *(_DWORD *)(dword_102D2B20 + 604) != v21)
      && *(_BYTE *)(dword_102D2B2C + 816) != 3 )
    {
      v8 = -1;
      v28 = -1;
    }
    LOBYTE(v7) = sub_10048950();
    if ( v8 != -1 )
    {
      v29 = sub_10023910(v28, v3, v25, v26);
      LOBYTE(v7) = sub_10023910(v9, v21, v24, v22);
      v20 = v7;
      if ( v27 == 3 )
      {
        LODWORD(v15) = v23;
        if ( !sub_10023800(v15) )
        {
          LOBYTE(v7) = v23;
          *v5 = v23;
          *v6 = v8;
          return v7;
        }
        LOBYTE(v7) = v20;
LABEL_29:
        if ( v29 == 1 )
        {
          LOBYTE(v7) = v17;
          if ( (unsigned __int8)v8 > (unsigned __int8)v17 )
          {
            v11 = v26;
LABEL_37:
            v16 = v6;
            v14 = v5;
            LOBYTE(v7) = v8;
            v13 = 0;
            goto LABEL_38;
          }
          *v5 = v3;
          *v6 = v17;
          goto LABEL_39;
        }
LABEL_33:
        if ( (_BYTE)v7 == 1 )
        {
          if ( v3 == 0x3FFFF )
          {
            v11 = v22;
            goto LABEL_37;
          }
          *v5 = v3;
          *v6 = v17;
        }
LABEL_39:
        if ( v27 != 3 && *v5 == 0x3FFFF && *v6 == -1 )
        {
          if ( v3 == 0x3FFFF )
          {
            LOBYTE(v7) = v21;
            if ( v21 != 0x3FFFF )
            {
              *v5 = v21;
              LOBYTE(v7) = v22;
              *v6 = v22;
            }
          }
          else
          {
            *v5 = v3;
            *v6 = v17;
          }
        }
        return v7;
      }
      if ( v27 != 2 && v27 != 1 )
        goto LABEL_29;
      v10 = v18;
      if ( !v18 || v29 )
        goto LABEL_29;
      if ( (_BYTE)v7 )
        goto LABEL_33;
      v16 = v6;
      v14 = v5;
      LOBYTE(v7) = v8;
      v13 = 0;
      if ( v19 == 1 )
      {
        if ( v21 == 0x3FFFF )
        {
          v11 = v25 - 1;
          goto LABEL_38;
        }
        v10 = v24;
      }
      v11 = v10 - 1;
LABEL_38:
      LOBYTE(v7) = sub_10023940(v7, v11, (int)v6, v13, v14, v16);
      goto LABEL_39;
    }
  }
  return v7;
}
// 100239E0: could not find valid save-restore pair for ebx
// 102D2B20: using guessed type int dword_102D2B20;
// 102D2B2C: using guessed type int dword_102D2B2C;

//----- (10023C30) --------------------------------------------------------
signed int sub_10023C30()
{
  char v0; // bl@1
  double v1; // st7@2
  signed int result; // eax@4
  float v3; // [sp+8h] [bp-10h]@1
  float v4; // [sp+Ch] [bp-Ch]@1
  __int64 v5; // [sp+10h] [bp-8h]@4

  v0 = sub_1003FD10(&v4);
  v3 = sub_10040190();
  if ( v0 && (v1 = v3, v3 < 3785.411865234375) && v4 > 0.0001051503277267329 )
  {
    v5 = (signed __int64)(v1 / v4);
    result = v5;
  }
  else
  {
    result = 0x7FFFFFFF;
  }
  return result;
}

//----- (10023CB0) --------------------------------------------------------
int sub_10023CB0()
{
  char v1; // [sp+3h] [bp-5h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v2 = 0.0;
  v1 = 1;
  sub_10016450(10002, (int)&v2, 4);
  sub_10016450(10003, (int)&v2, 4);
  sub_10016450(10004, (int)&v2, 4);
  sub_10016450(10005, (int)&v2, 4);
  return sub_10016450(10006, (int)&v1, 1);
}

//----- (10023D20) --------------------------------------------------------
char __cdecl sub_10023D20(char a1)
{
  return sub_10016510(2022, (int)&a1, 1);
}

//----- (10023D40) --------------------------------------------------------
int __cdecl sub_10023D40(float a1)
{
  double v1; // st6@1
  int result; // eax@2

  v1 = *(float *)(dword_102D2B4C + 940) + *(float *)(dword_102D2B4C + 936) + *(float *)(dword_102D2B4C + 932);
  if ( v1 >= a1 )
  {
    if ( a1 >= 0.0 )
    {
      result = sub_10016450(10009, (int)&a1, 4);
    }
    else
    {
      a1 = 0.0;
      result = sub_10016450(10009, (int)&a1, 4);
    }
  }
  else
  {
    a1 = v1;
    result = sub_10016450(10009, (int)&a1, 4);
  }
  return result;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10023DD0) --------------------------------------------------------
int sub_10023DD0()
{
  double v0; // st7@3
  int result; // eax@4
  char v2; // [sp+Bh] [bp-Dh]@1
  double v3; // [sp+Ch] [bp-Ch]@1
  int v4; // [sp+14h] [bp-4h]@1

  *(float *)&v3 = sub_10040190();
  *(float *)&v4 = 1.0;
  sub_10016BE0(15, &v2);
  if ( v2 == 24 )
    *(float *)&v4 = 10.0;
  v3 = *(float *)&v3;
  v0 = sub_10041FD0(v4, 0x1015u);
  *(float *)&v3 = v3 - v0;
  if ( *(float *)&v3 >= 0.0 )
  {
    result = sub_10023D40(*(float *)&v3);
  }
  else
  {
    *(float *)&v3 = 0.0;
    result = sub_10023D40(0.0);
  }
  return result;
}

//----- (10023E60) --------------------------------------------------------
int sub_10023E60()
{
  double v0; // st7@3
  double v1; // st7@3
  int result; // eax@4
  char v3; // [sp+Bh] [bp-9h]@1
  float v4; // [sp+Ch] [bp-8h]@1
  int v5; // [sp+10h] [bp-4h]@1

  v4 = sub_10040190();
  *(float *)&v5 = 1.0;
  sub_10016BE0(15, &v3);
  if ( v3 == 24 )
    *(float *)&v5 = 10.0;
  v0 = sub_10041FD0(v5, 0x1015u);
  v4 = v0 + v4;
  v1 = *(float *)(dword_102D2B4C + 940) + *(float *)(dword_102D2B4C + 936) + *(float *)(dword_102D2B4C + 932);
  if ( v4 <= v1 )
  {
    result = sub_10023D40(v4);
  }
  else
  {
    v4 = v1;
    result = sub_10023D40(v4);
  }
  return result;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10023F30) --------------------------------------------------------
int __cdecl sub_10023F30(unsigned __int16 a1, char a2, int a3)
{
  int result; // eax@1
  int v4; // ebp@1
  char v5; // cl@2
  signed int v6; // edi@2
  unsigned __int16 v7; // si@3
  int v8; // ecx@4
  char v9; // dl@5
  int v10; // esi@10
  int v11; // ecx@11
  __int16 v12; // dx@12
  char v13; // bl@13

  result = BMP_get_xfrm(a1);
  v4 = result;
  if ( a2 )
  {
    v5 = *(_BYTE *)(BMP_get_bm_def(a1) + 8);
    result = a3;
    v6 = 1 << v5;
    if ( v4 )
    {
      v10 = 0;
      if ( v6 > 0 )
      {
        v11 = 0;
        do
        {
          v12 = *(_WORD *)(v4 + 2 * v11);
          if ( (unsigned __int16)v12 < 0x100u )
          {
            v13 = byte_101A1C00[(unsigned __int16)v12];
            if ( v13 != 127 )
              v12 = word_101A1BD8[(unsigned __int8)byte_1009D010[(unsigned __int8)v13]];
          }
          ++v10;
          *(_WORD *)(a3 + 2 * v11) = v12;
          v11 = (unsigned __int16)v10;
        }
        while ( (unsigned __int16)v10 < v6 );
      }
    }
    else
    {
      v7 = 0;
      if ( v6 > 0 )
      {
        v8 = 0;
        do
        {
          v9 = byte_101A1C00[v8];
          if ( v9 == 127 )
            *(_WORD *)(a3 + 2 * v8) = v7;
          else
            *(_WORD *)(a3 + 2 * v8) = word_101A1BD8[(unsigned __int8)byte_1009D010[(unsigned __int8)v9]];
          v8 = ++v7;
        }
        while ( v7 < v6 );
      }
    }
  }
  return result;
}
// 1006CAD6: using guessed type int __cdecl BMP_get_bm_def(_DWORD);
// 1006CADC: using guessed type int __cdecl BMP_get_xfrm(_DWORD);
// 101A1BD8: using guessed type __int16 word_101A1BD8[];

//----- (10024000) --------------------------------------------------------
int sub_10024000()
{
  int v0; // ebx@1
  void *v1; // esi@1
  int result; // eax@2

  memset(byte_101A1C00, 127, 0x100u);
  v0 = 0;
  v1 = &unk_1009CFD5;
  do
  {
    LOBYTE(result) = j_HWM_pvg_get_color(*((char *)v1 - 1), *(_BYTE *)v1, *((_BYTE *)v1 + 1));
    word_101A1BD8[v0] = (unsigned __int8)result;
    result = (unsigned __int8)result;
    byte_101A1C00[(unsigned __int8)result] = v0;
    v1 = (char *)v1 + 3;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&unk_1009D00E );
  return result;
}
// 10016C40: using guessed type int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD);
// 101A1BD8: using guessed type __int16 word_101A1BD8[];

//----- (10024060) --------------------------------------------------------
void sub_10024060()
{
  dword_102D21C0 = -15;
}
// 102D21C0: using guessed type int dword_102D21C0;

//----- (10024070) --------------------------------------------------------
signed int sub_10024070()
{
  return sub_100175B0((int)&off_1009D040);
}
// 1009D040: using guessed type char *off_1009D040;

//----- (10024080) --------------------------------------------------------
unsigned int __cdecl sub_10024080(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // esi@2

  v6 = (a3 >> 24) + *(_WORD *)(a2 + 24) + ((a3 >> 16) & 0xFF) - *(_WORD *)(a2 + 26);
  v7 = 0;
  if ( v6 <= a4 )
  {
    v8 = v6 + a5;
    do
    {
      v6 += v8;
      ++v7;
    }
    while ( v6 <= a4 );
  }
  *a6 = v7;
  return strlen(a1) + 2 * (v7 - 1 <= 0 ? 0 : v7 - 1) + 1;
}

//----- (100240F0) --------------------------------------------------------
int __cdecl sub_100240F0(int a1, int a2, int a3, int a4, int a5, char a6, char *a7)
{
  char *v7; // eax@1
  char *v8; // esi@1
  char *v9; // edx@2
  char v10; // cl@3
  int v11; // ebx@7
  signed int v12; // edi@7
  signed int i; // edx@9
  int v14; // ebp@13
  int v15; // eax@13
  int v16; // ebp@13
  int v17; // edi@13
  char *v18; // eax@14
  char *v19; // ebp@14
  unsigned int v20; // eax@15
  int v21; // ebx@17
  int v22; // eax@17
  int v23; // edi@21
  int j; // ebp@21
  int v25; // ST14_4@22
  int v26; // ST0C_4@22
  char v27; // al@26
  int v28; // edi@29
  char v29; // al@32
  char v30; // al@40
  int v31; // edx@45
  int v32; // ecx@45
  int v33; // edi@55
  char *v34; // eax@58
  char v35; // dl@59
  int v36; // eax@61
  int v37; // edi@61
  int v38; // ecx@67
  char v39; // al@67
  char *v40; // edi@67
  char *v41; // eax@72
  int v42; // edx@72
  char v43; // cl@73
  _BYTE *v44; // ebp@74
  char *v45; // ST2C_4@78
  char v47; // [sp+13h] [bp-25h]@1
  int v48; // [sp+14h] [bp-24h]@14
  char *v49; // [sp+18h] [bp-20h]@26
  int v50; // [sp+1Ch] [bp-1Ch]@1
  signed int v51; // [sp+20h] [bp-18h]@7
  int v52; // [sp+24h] [bp-14h]@21
  int v53; // [sp+24h] [bp-14h]@26
  int v54; // [sp+28h] [bp-10h]@13
  int v55; // [sp+2Ch] [bp-Ch]@1
  signed int v56; // [sp+2Ch] [bp-Ch]@21
  int v57; // [sp+2Ch] [bp-Ch]@26
  int v58; // [sp+30h] [bp-8h]@29
  int v59; // [sp+34h] [bp-4h]@28

  v7 = (char *)a1;
  v8 = a7;
  v47 = 0;
  v55 = 0;
  v50 = 1;
  if ( a7 != (char *)a1 )
  {
    v9 = &a7[-a1];
    do
    {
      v10 = *v7;
      v7[(_DWORD)v9] = *v7;
      ++v7;
    }
    while ( v10 );
  }
  if ( a4 < 1 || a5 < 1 )
  {
    v47 = 1;
    v50 = 0;
    *v8 = 0;
  }
  v11 = a3;
  v12 = (((unsigned int)a3 >> 16) & 0x3F) - 1;
  v51 = v12;
  if ( v12 < 0 )
  {
    v12 = *(_WORD *)(a2 + 28);
    v51 = *(_WORD *)(a2 + 28);
  }
  for ( i = 0; i < (signed int)strlen(v8); ++i )
  {
    if ( v8[i] == 10 )
      ++v55;
  }
  LOWORD(a1) = 10;
  v14 = v12 + sub_1006D900(a2, &a1, a3);
  v15 = sub_1006D900(a2, v8, v11);
  v16 = v55 * v14;
  v17 = a5 * a4 - v16 - v15;
  v54 = a5 * a4 - v16 - v15;
  if ( v47 )
    return -1;
  while ( 1 )
  {
    v18 = strchr(v8, 10);
    v19 = v18;
    v48 = (int)v18;
    if ( v18 )
    {
      LOBYTE(a7) = 1;
      *v18 = 0;
    }
    else
    {
      LOBYTE(a7) = 0;
      v20 = strlen(v8);
      v19 = &v8[v20];
      v48 = (int)&v8[v20];
    }
    v21 = sub_1006D900(a2, v8, a3);
    v22 = a4;
    if ( v21 > a4 )
    {
      if ( v50 >= a5 )
        goto LABEL_79;
      v52 = 0;
      v23 = a4;
      v56 = strlen(v8) - 1;
      for ( j = v56 / 2; ; j = (v56 + j + 1) / 2 )
      {
        while ( 1 )
        {
          v25 = a3;
          LOBYTE(a1) = v8[j + 1];
          v26 = a2;
          v8[j + 1] = 0;
          v21 = sub_1006D900(v26, v8, v25);
          v8[j + 1] = a1;
          if ( v21 <= v23 )
            break;
          v56 = j;
          j = (v52 + j) / 2;
        }
        if ( v51 + v21 + sub_1006D900(a2, &a1, a3) > v23 )
          break;
        v52 = j + 1;
      }
      v57 = v23 - v21;
      v49 = &v8[j];
      v27 = v8[j + 1];
      v53 = j;
      if ( v27 == 32 )
        goto LABEL_67;
      if ( !v27 )
        goto LABEL_67;
      v59 = v54 - v57;
      if ( v54 - v57 <= 0 )
        goto LABEL_67;
      v58 = 0;
      v28 = j;
      if ( j >= 0 )
      {
        while ( 1 )
        {
          if ( !isalnum((unsigned __int8)v8[v28]) || v8[v28] == 45 )
          {
            v29 = v8[v28];
            if ( v29 != 39 && v29 != 40 && v29 != 41 && v29 != 34 )
            {
              if ( v28 <= 0 )
                break;
              if ( v8[v28 - 1] != 32 )
              {
                if ( !isdigit((unsigned __int8)v8[v28 + 1]) || !isdigit((unsigned __int8)v8[v28 - 1]) )
                  break;
                v30 = v8[v28];
                if ( (v30 != 32 || v8[v28 + 2] != 47) && v30 != 47 )
                  break;
              }
            }
          }
          if ( --v28 < 0 )
            goto LABEL_48;
        }
        v31 = a3;
        LOBYTE(a1) = v49[1];
        v32 = a2;
        v49[1] = 0;
        v58 = v51 + sub_1006D900(v32, &v8[v28 + 1], v31);
        v49[1] = a1;
        if ( v8[v28] == 32 && v28 > 0 )
          --v28;
      }
LABEL_48:
      if ( v28 == -1 || v28 == j || v58 > v59 )
      {
        if ( !isalpha((unsigned __int8)*v49) || !isalpha((unsigned __int8)v49[1]) || !a6 )
          goto LABEL_67;
        LOBYTE(a1) = 45;
        v33 = v51 + sub_1006D900(a2, &a1, a3);
        if ( v33 + v21 <= a4 )
        {
          if ( (_BYTE)a7 )
            *(_BYTE *)v48 = 10;
          v34 = v49 + 1;
          do
            v35 = *v34++;
          while ( v35 );
          memcpy(v49 + 2, v49 + 1, v34 - (v49 + 2) + 1);
          v21 += v33;
          *(_BYTE *)(v48++ + 1) = 0;
          v49[1] = 45;
          v53 = j + 1;
          goto LABEL_67;
        }
        LOBYTE(a1) = *v49;
        v36 = v51 + sub_1006D900(a2, &a1, a3);
        v37 = v21 + v33 - v36;
        if ( v37 > a4 || v59 < v36 )
        {
LABEL_67:
          v38 = v53;
          v54 -= v57;
          v39 = v8[v53 + 1];
          v40 = &v8[v53 + 1];
          if ( v39 )
          {
            if ( v39 == 32 )
              v38 = v53++ + 1;
            if ( (_BYTE)a7 )
              *(_BYTE *)v48 = 10;
            v40 = &v8[v38 + 1];
            v41 = &v8[v38 + 1];
            v42 = (int)&v8[v38 + 2];
            do
              v43 = *v41++;
            while ( v43 );
            memcpy(&v8[v53 + 2], v40, (size_t)&v41[-v42 + 1]);
            v44 = (_BYTE *)(v48 + 1);
            *v40 = 10;
            *(_BYTE *)(v48 + 1) = 0;
          }
          else
          {
            v44 = (_BYTE *)v48;
          }
          if ( (_BYTE)a7 )
          {
            LOBYTE(a7) = 0;
            *v44 = 10;
          }
          v22 = a4;
          v45 = v40;
          v17 = v54;
          v19 = v45;
          goto LABEL_79;
        }
        if ( (_BYTE)a7 )
          *(_BYTE *)v48 = 10;
        strcpy(v49 + 1, v49);
        *(_BYTE *)(v48++ + 1) = 0;
        *v49 = 45;
        v21 = v37;
      }
      else
      {
        v53 = v28;
        v21 -= v58;
      }
      v57 = a4 - v21;
      goto LABEL_67;
    }
    if ( !(_BYTE)a7 )
      return v50;
    v17 += v21 - a4;
    v54 = v17;
LABEL_79:
    if ( (_BYTE)a7 )
      *v19 = 10;
    if ( v50 >= a5 )
      break;
    if ( !*v19 )
      goto LABEL_85;
    ++v50;
    v8 = v19 + 1;
  }
  if ( *v19 )
  {
LABEL_86:
    *v19 = 0;
    return -1;
  }
LABEL_85:
  if ( v21 > v22 )
    goto LABEL_86;
  return v50;
}

//----- (10024680) --------------------------------------------------------
char *__cdecl sub_10024680(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_102D22C0[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_102D22C8];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_102D22C4];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_102D22C8];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_102D21D4)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;
// 102D22C0: using guessed type int dword_102D22C0[];
// 102D22C4: using guessed type __int16 word_102D22C4[];
// 102D22C8: using guessed type int dword_102D22C8[];
// 10024680: using guessed type char var_20[28];

//----- (10024740) --------------------------------------------------------
signed int sub_10024740()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_102D21D8 = 0;
  dword_102D21DC = 0xFFFFFF;
  byte_102D21C8 = 0;
  dword_102D21CC = 0xFFFFFF;
  return result;
}
// 102D21C8: using guessed type char byte_102D21C8;
// 102D21CC: using guessed type int dword_102D21CC;
// 102D21D8: using guessed type char byte_102D21D8;
// 102D21DC: using guessed type int dword_102D21DC;

//----- (10024760) --------------------------------------------------------
int sub_10024760()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_102D21D4 + 16))();
  byte_102D21D0 = (_BYTE)result == 0;
  return result;
}
// 102D21D0: using guessed type char byte_102D21D0;
// 102D21D4: using guessed type int dword_102D21D4;

//----- (100247C0) --------------------------------------------------------
int sub_100247C0()
{
  int result; // eax@1

  *(_DWORD *)(dword_102D2B10 + 20812) = 1000;
  *(_DWORD *)(dword_102D2B10 + 20816) = dword_102D2328 + *(_DWORD *)(dword_102D2B10 + 20812);
  *(_DWORD *)(dword_102D2B10 + 20820) = dword_102D2388 + *(_DWORD *)(dword_102D2B10 + 20816);
  *(_DWORD *)(dword_102D2B10 + 20824) = dword_102D23B8 + *(_DWORD *)(dword_102D2B10 + 20820);
  result = dword_102D2B10;
  *(_DWORD *)(dword_102D2B10 + 20828) = dword_102D2400 + *(_DWORD *)(dword_102D2B10 + 20824);
  return result;
}
// 102D2328: using guessed type int dword_102D2328;
// 102D2388: using guessed type int dword_102D2388;
// 102D23B8: using guessed type int dword_102D23B8;
// 102D2400: using guessed type int dword_102D2400;
// 102D2B10: using guessed type int dword_102D2B10;

//----- (10024830) --------------------------------------------------------
char *sub_10024830()
{
  sub_10024680(0x40u);
  sub_10024680(0x39u);
  sub_10024680(0x33u);
  sub_10024680(0x31u);
  sub_10024680(0x32u);
  sub_10024680(0x4Eu);
  sub_10024680(0x4Fu);
  sub_10024680(0x3Du);
  sub_10024680(0x3Eu);
  sub_10024680(0x45u);
  return sub_10024680(0x38u);
}
// 102D2B10: using guessed type int dword_102D2B10;

//----- (10024900) --------------------------------------------------------
int __cdecl sub_10024900(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_101A1D00, a1, 0x1Cu);
  dword_102D21D4 = (int)dword_101A1D00;
  dword_102D2B10 = (int)&unk_101A1D20;
  memset(&unk_101A1D20, 0, 0x516Cu);
  dword_101A1D00[5](dword_102D2B10 + 20832, dword_102D2B10 + 20833, dword_102D2B10 + 20836);
  (*(void (__cdecl **)(int))(dword_102D21D4 + 24))(dword_102D2B10 + 20840);
  sub_10048790();
  sub_10048420();
  sub_100485D0();
  sub_100484F0();
  sub_10024830();
  sub_10024740();
  sub_10025140();
  sub_10024D90();
  sub_10024760();
  sub_100247C0();
  *(_DWORD *)(dword_102D2B10 + 20800) = 0;
  *(_DWORD *)(dword_102D2B10 + 20804) = dword_102D24A8;
  result = dword_102D2B10;
  *(_DWORD *)(dword_102D2B10 + 20808) = dword_102D24B4 + *(_DWORD *)(dword_102D2B10 + 20804);
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;
// 102D24A8: using guessed type int dword_102D24A8;
// 102D24B4: using guessed type int dword_102D24B4;
// 102D2B10: using guessed type int dword_102D2B10;

//----- (100249B0) --------------------------------------------------------
signed int __cdecl sub_100249B0(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  v1 = 0x3FFFF;
  sub_10016170(54, 60000);
  v2 = sub_10024D50(a1);
  if ( v2 && *(_BYTE *)(v2 + 90) != -1 )
    v1 = *(_DWORD *)(v2 + 104);
  sub_10016150(54);
  return v1;
}

//----- (100249F0) --------------------------------------------------------
char __cdecl sub_100249F0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10016170(54, 60000);
  v1 = 0;
  v2 = sub_10024D50(a1);
  if ( v2 )
    v1 = *(_BYTE *)(v2 + 1);
  sub_10016150(54);
  return v1;
}

//----- (10024A30) --------------------------------------------------------
signed int __cdecl sub_10024A30(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  sub_10016170(54, 60000);
  v2 = 0x3FFFF;
  v3 = sub_10024D50(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_100488C0(84 * a2 + v3 + 148);
  sub_10016150(54);
  return v2;
}

//----- (10024A90) --------------------------------------------------------
signed int __cdecl sub_10024A90(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  sub_10016170(54, 60000);
  v1 = 0x3FFFF;
  v2 = sub_10024D50(a1);
  if ( v2 && *(_BYTE *)(v2 + 60) != 3 && *(_BYTE *)(v2 + 61) != 3 )
    v1 = *(_DWORD *)(v2 + 64);
  sub_10016150(54);
  return v1;
}

//----- (10024AD0) --------------------------------------------------------
char __cdecl sub_10024AD0(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 1) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10024B10) --------------------------------------------------------
char __cdecl sub_10024B10(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 4) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10024B50) --------------------------------------------------------
char __cdecl sub_10024B50(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 1) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (10024B90) --------------------------------------------------------
char __cdecl sub_10024B90(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 4) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (10024BD0) --------------------------------------------------------
char __cdecl sub_10024BD0(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( *(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 154) != 3 )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10024C10) --------------------------------------------------------
char __cdecl sub_10024C10(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10016170(54, 60000);
  v1 = -1;
  v2 = sub_10024D50(a1);
  if ( v2 )
    v1 = sub_10024AD0(v2);
  sub_10016150(54);
  return v1;
}

//----- (10024C50) --------------------------------------------------------
char __cdecl sub_10024C50(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10016170(54, 60000);
  v1 = -1;
  v2 = sub_10024D50(a1);
  if ( v2 )
    v1 = sub_10024B10(v2);
  sub_10016150(54);
  return v1;
}

//----- (10024C90) --------------------------------------------------------
char __cdecl sub_10024C90(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10016170(54, 60000);
  v1 = -1;
  v2 = sub_10024D50(a1);
  if ( v2 )
    v1 = sub_10024B50(v2);
  sub_10016150(54);
  return v1;
}

//----- (10024CD0) --------------------------------------------------------
char __cdecl sub_10024CD0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10016170(54, 60000);
  v1 = -1;
  v2 = sub_10024D50(a1);
  if ( v2 )
    v1 = sub_10024B90(v2);
  sub_10016150(54);
  return v1;
}

//----- (10024D10) --------------------------------------------------------
char __cdecl sub_10024D10(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10016170(54, 60000);
  v1 = -1;
  v2 = sub_10024D50(a1);
  if ( v2 )
    v1 = sub_10024BD0(v2);
  sub_10016150(54);
  return v1;
}

//----- (10024D50) --------------------------------------------------------
int __cdecl sub_10024D50(unsigned __int8 a1)
{
  int v1; // eax@3
  bool v2; // zf@3
  int result; // eax@3

  if ( a1 >= 0x67u
    || !(unsigned __int8)sub_10024070()
    || (v1 = 8524 * a1, v2 = a1 == *(_BYTE *)(v1 + dword_102D21C0 + 2004), result = v1 + dword_102D21C0 + 2004, !v2) )
  {
    result = 0;
  }
  return result;
}
// 102D21C0: using guessed type int dword_102D21C0;

//----- (10024D90) --------------------------------------------------------
int sub_10024D90()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_100488E0(0x4Du, 1u) )
  {
    result = dword_102D265C;
    dword_101A6E98 = dword_102D265C;
    if ( dword_102D265C )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_102D21D4)(dword_102D265C, 8, &v1);
      word_101A6E90 = v1;
      result = v3 & 0x1FF;
      dword_101A6E98 += (unsigned __int16)word_102D2660;
      word_101A6E94 = v2 & 0x1FF;
      word_101A6E8C = v3 & 0x1FF;
    }
  }
  else
  {
    word_101A6E90 = 6;
    word_101A6E94 = 6;
    result = dword_102D24DC;
    word_101A6E8C = 60;
    dword_101A6E98 = dword_102D24DC;
  }
  return result;
}
// 101A6E8C: using guessed type __int16 word_101A6E8C;
// 101A6E90: using guessed type __int16 word_101A6E90;
// 101A6E94: using guessed type __int16 word_101A6E94;
// 101A6E98: using guessed type int dword_101A6E98;
// 102D21D4: using guessed type int dword_102D21D4;
// 102D24DC: using guessed type int dword_102D24DC;
// 102D265C: using guessed type int dword_102D265C;
// 102D2660: using guessed type __int16 word_102D2660;

//----- (10024E30) --------------------------------------------------------
int __cdecl sub_10024E30(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_10048920(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (10024E60) --------------------------------------------------------
int sub_10024E60()
{
  return (*(int (**)(void))(dword_102D21D4 + 8))();
}
// 102D21D4: using guessed type int dword_102D21D4;

//----- (10024E70) --------------------------------------------------------
int __fastcall sub_10024E70(unsigned __int8 a1)
{
  return dword_102D24C4 + a1 * (unsigned __int16)word_102D24C8;
}
// 102D24C4: using guessed type int dword_102D24C4;
// 102D24C8: using guessed type __int16 word_102D24C8;

//----- (10024E90) --------------------------------------------------------
int __fastcall sub_10024E90(unsigned __int8 a1)
{
  return dword_102D24D0 + a1 * (unsigned __int16)word_102D24D4;
}
// 102D24D0: using guessed type int dword_102D24D0;
// 102D24D4: using guessed type __int16 word_102D24D4;

//----- (10024EB0) --------------------------------------------------------
void *__cdecl sub_10024EB0(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_10024E30(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_10024E70(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_102D21D4)(v3, 22, &v7);
      result = (void *)sub_10048550(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;

//----- (10024F80) --------------------------------------------------------
int __cdecl sub_10024F80(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_10024E70(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_102D21D4)(v2, 22, &v22);
    sub_10048550((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_10024E90(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_102D21D4)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_10048550((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_102D21D4 + 12))(a1);
}
// 102D21D4: using guessed type int dword_102D21D4;

//----- (10025140) --------------------------------------------------------
char sub_10025140()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_10024E60();
  sub_10024E30(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_10024EB0(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_10048920(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_10024EB0(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_10024F80((int)&v8);
  }
  return v0;
}

//----- (100252A0) --------------------------------------------------------
int __cdecl sub_100252A0(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (100252F0) --------------------------------------------------------
bool __cdecl sub_100252F0(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  char v6; // al@3
  bool result; // al@6
  int v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_10025CD0(v1);
  v10 = 0;
  v5 = &unk_1009E058;
  do
  {
    if ( v8 & *v5 )
    {
      v6 = sub_10048A60(v10, 0);
      if ( sub_10046650(3, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (10025390) --------------------------------------------------------
int sub_10025390()
{
  int result; // eax@1

  sub_10016420(6361, (int)&flt_101A6E9C, 4);
  result = sub_10016420(6362, (int)&flt_101A6EA0, 4);
  dword_101A6EA4 = 1379255385;
  return result;
}
// 101A6E9C: using guessed type float flt_101A6E9C;
// 101A6EA0: using guessed type float flt_101A6EA0;
// 101A6EA4: using guessed type int dword_101A6EA4;

//----- (100253C0) --------------------------------------------------------
char __cdecl sub_100253C0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_100466D0(7, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39950.746
     || *(float *)a1 < -39950.746) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10025420) --------------------------------------------------------
char __cdecl sub_10025420(float *a1)
{
  char v1; // bl@1
  double v2; // st7@2
  double v3; // st7@6
  char result; // al@9
  float v5; // [sp+Ch] [bp-Ch]@1
  float v6; // [sp+10h] [bp-8h]@5
  float v7; // [sp+14h] [bp-4h]@2

  v1 = sub_100466D0(53, &v5);
  if ( v1 )
  {
    v2 = v5;
    v7 = v5;
    if ( (LODWORD(v5) & 0x7F800000) == 2139095040 || v2 > 526.79114 || v2 < -526.79114 )
      return 0;
    if ( sub_100466D0(59, &v6) )
    {
      v3 = v6;
      v7 = v6;
      if ( (LODWORD(v6) & 0x7F800000) != 2139095040 && v3 <= 526.79114 && v3 >= -526.79114 )
      {
        sub_100252A0(flt_101A6E9C, 0.0);
        result = v1;
        v5 = flt_101A6EA0 * v6 + v5;
        *a1 = v5;
        return result;
      }
    }
    *a1 = v5;
  }
  return v1;
}
// 101A6E9C: using guessed type float flt_101A6E9C;
// 101A6EA0: using guessed type float flt_101A6EA0;

//----- (10025520) --------------------------------------------------------
char __cdecl sub_10025520(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_100466D0(2, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 512.0 || *(float *)a1 < -512.0) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10025580) --------------------------------------------------------
char __cdecl sub_10025580(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_100466D0(9, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 216728.75
     || *(float *)a1 < -216728.75) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (100255E0) --------------------------------------------------------
char __cdecl sub_100255E0(float *a1)
{
  float *v1; // esi@1
  char v2; // bl@1

  v1 = a1;
  *a1 = 0.0;
  v2 = sub_100253C0(&a1);
  if ( v2 )
    *v1 = sub_100256E0() + *(float *)&a1;
  return v2;
}
// 100256E0: using guessed type double sub_100256E0(void);

//----- (10025610) --------------------------------------------------------
char __cdecl sub_10025610(float *a1)
{
  float *v1; // esi@1
  char result; // al@4
  float v3; // [sp+8h] [bp-4h]@1

  v1 = a1;
  *a1 = 9.8999998e24;
  if ( sub_10025520(&v3) && sub_100255E0((float *)&a1) )
  {
    *(float *)&a1 = *(float *)&a1 * 3.280839920043945;
    if ( *(float *)&a1 < 36089.0 )
    {
      result = 1;
      *v1 = v3 - (15.0 - *(float *)&a1 / 1000.0 * 1.981199979782104);
    }
    else
    {
      result = 1;
      *v1 = v3 - -56.5;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100256B0) --------------------------------------------------------
char __cdecl sub_100256B0(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10025BB0(13, (char *)&v3 + 3);
  sub_10025BB0(12, a1);
  return BYTE3(v3);
}

//----- (100256E0) --------------------------------------------------------
void sub_100256E0()
{
  float v0; // ST00_4@1

  v0 = sub_100404E0();
  sub_10083A00(v0);
}
// 100404E0: using guessed type double sub_100404E0(void);

//----- (10025700) --------------------------------------------------------
char __thiscall sub_10025700(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 12;
  sub_10016550(3000, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10025730) --------------------------------------------------------
char __thiscall sub_10025730(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 30;
  sub_10016550(3001, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10025760) --------------------------------------------------------
char __fastcall sub_10025760(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10016BE0(3, (_BYTE *)&v2 + 2);
  BYTE2(v2) = byte_1009EC25[2 * sub_100430B0((int *)((char *)&v2 + 2), 1u, (int)&unk_1009EC24, 2, 5, -1)];
  if ( sub_10016380(3002, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10016510(3002, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (100257D0) --------------------------------------------------------
char __thiscall sub_100257D0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_10016550(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10025800) --------------------------------------------------------
char __fastcall sub_10025800(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10016BE0(3, (_BYTE *)&v2 + 2);
  if ( sub_10016380(3003, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10016510(3003, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10025850) --------------------------------------------------------
char sub_10025850()
{
  return 18;
}

//----- (10025860) --------------------------------------------------------
BOOL __thiscall sub_10025860(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10016BE0(97, (_BYTE *)&v2 + 3);
  return BYTE3(v2) == 1;
}

//----- (10025880) --------------------------------------------------------
int __thiscall sub_10025880(void *this)
{
  int result; // eax@1
  signed int v2; // esi@1
  int v3; // [sp-Ch] [bp-14h]@3
  char *v4; // [sp-8h] [bp-10h]@3
  char v5; // [sp+7h] [bp-1h]@1

  v5 = 8;
  result = sub_100405D0(this);
  v2 = 0;
  if ( !(result & 0xF) )
  {
    switch ( result )
    {
      case 64:
        v4 = &v5;
        v3 = 9956;
        goto LABEL_7;
      case 128:
        v4 = &v5;
        v3 = 9957;
        goto LABEL_7;
      case 16:
        v4 = &v5;
        v3 = 9958;
        goto LABEL_7;
      case 32:
        v4 = &v5;
        v3 = 9959;
LABEL_7:
        sub_10016380(v3, (int)v4, 1);
        break;
      default:
        break;
    }
    switch ( v5 )
    {
      case 0:
      case 1:
        result = 1;
        break;
      case 2:
      case 3:
        result = 4;
        break;
      case 4:
      case 5:
        result = 8;
        break;
      case 6:
      case 7:
        v2 = 2;
        goto LABEL_13;
      default:
LABEL_13:
        result = v2;
        break;
    }
  }
  return result;
}

//----- (100259D0) --------------------------------------------------------
char __thiscall sub_100259D0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 18;
  sub_10016550(3005, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10025A00) --------------------------------------------------------
char __thiscall sub_10025A00(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 23;
  sub_10016550(3006, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10025A30) --------------------------------------------------------
char __fastcall sub_10025A30(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10016BE0(5, (_BYTE *)&v2 + 2);
  if ( sub_10016380(3007, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10016510(3007, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10025A80) --------------------------------------------------------
char __thiscall sub_10025A80(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_10016550(3011, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10025AB0) --------------------------------------------------------
char __thiscall sub_10025AB0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_10016550(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10025AE0) --------------------------------------------------------
int sub_10025AE0()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_10016550(3012, &v2, 4, &v1);
  return v2;
}

//----- (10025B10) --------------------------------------------------------
char __thiscall sub_10025B10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 11;
  sub_10016550(3009, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10025B40) --------------------------------------------------------
char __fastcall sub_10025B40(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10016BE0(42, (_BYTE *)&v2 + 2);
  if ( sub_10016380(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10016510(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10025B90) --------------------------------------------------------
char __cdecl sub_10025B90(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070F34: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);

//----- (10025BB0) --------------------------------------------------------
int __cdecl sub_10025BB0(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10015C20("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10015C20("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070F3A: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10025C10) --------------------------------------------------------
char __thiscall sub_10025C10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(10, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10025C30) --------------------------------------------------------
char __thiscall sub_10025C30(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(11, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10025C50) --------------------------------------------------------
char __thiscall sub_10025C50(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10025C70) --------------------------------------------------------
int __thiscall sub_10025C70(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(15, (char *)&v2);
  return (int)v2;
}

//----- (10025C90) --------------------------------------------------------
int __thiscall sub_10025C90(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(16, (char *)&v2);
  return (int)v2;
}

//----- (10025CB0) --------------------------------------------------------
char __thiscall sub_10025CB0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10025CD0) --------------------------------------------------------
int __thiscall sub_10025CD0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(29, (char *)&v2);
  return (int)v2;
}

//----- (10025CF0) --------------------------------------------------------
char __thiscall sub_10025CF0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10025D10) --------------------------------------------------------
char __thiscall sub_10025D10(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10025D30) --------------------------------------------------------
char sub_10025D30()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_10025BB0(48, &v1);
  return v1;
}

//----- (10025D50) --------------------------------------------------------
BOOL sub_10025D50()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 1;
  sub_10025BB0(49, &v1);
  return v1 == 0;
}

//----- (10025D70) --------------------------------------------------------
int __cdecl sub_10025D70(char a1)
{
  return sub_10025BB0(59, &a1);
}

//----- (10025D80) --------------------------------------------------------
int __cdecl sub_10025D80(char a1)
{
  return sub_10025BB0(60, &a1);
}

//----- (10025D90) --------------------------------------------------------
int __cdecl sub_10025D90(char a1)
{
  return sub_10025BB0(56, &a1);
}

//----- (10025DA0) --------------------------------------------------------
int __cdecl sub_10025DA0(char a1)
{
  return sub_10025BB0(76, &a1);
}

//----- (10025DB0) --------------------------------------------------------
int __cdecl sub_10025DB0(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (10025DF0) --------------------------------------------------------
void *__usercall sub_10025DF0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_10016380(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_100164D0(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10025E40) --------------------------------------------------------
signed int sub_10025E40()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_102D2B4C = 0;
  v4 = 0;
  sub_10016BE0(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_10016450(3201, (int)&v4, 1);
    sub_10016C10(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_10016450(3201, (int)&v4, 1);
    sub_10016C10(94, (int)&v4);
  }
  sub_10025DF0(1u, 6011, &unk_101A6EA8);
  sub_10025DF0(0x16u, 6194, &unk_101A6EA9);
  sub_10025DF0(1u, 6012, &unk_101A6EBF);
  sub_10025DF0(1u, 6013, &unk_101A6EC0);
  sub_10025DF0(1u, 6014, &unk_101A6EC1);
  sub_10025DF0(1u, 6015, &unk_101A6EC2);
  sub_10025DF0(4u, 6078, &unk_101A6EC4);
  sub_10025DF0(4u, 6104, &unk_101A6EC8);
  sub_10025DF0(0x20u, 6016, &unk_101A6ECC);
  sub_10025DF0(0x20u, 6017, &unk_101A6EEC);
  sub_10025DF0(0x20u, 6018, &unk_101A6F0C);
  sub_10025DF0(0x20u, 6019, &unk_101A6F2C);
  sub_10025DF0(0x20u, 6020, &unk_101A6F4C);
  sub_10025DF0(0x20u, 6021, &unk_101A6F6C);
  sub_10025DF0(0x20u, 6022, &unk_101A6F8C);
  sub_10025DF0(0x20u, 6023, &unk_101A6FAC);
  sub_10025DF0(0x20u, 6024, &unk_101A6FCC);
  sub_10025DF0(0x20u, 6025, &unk_101A6FEC);
  sub_10025DF0(0x20u, 6026, &unk_101A700C);
  sub_10025DF0(0x20u, 6027, &unk_101A702C);
  sub_10025DF0(0x20u, 6028, &unk_101A704C);
  sub_10025DF0(0x20u, 6029, &unk_101A706C);
  sub_10025DF0(0x20u, 6030, &unk_101A708C);
  sub_10025DF0(0x20u, 6031, &unk_101A70AC);
  sub_10025DF0(0x20u, 6032, &unk_101A70CC);
  sub_10025DF0(0x20u, 6033, &unk_101A70EC);
  sub_10025DF0(0x20u, 6034, &unk_101A710C);
  sub_10025DF0(0x20u, 6035, &unk_101A712C);
  sub_10025DF0(0x20u, 6036, &unk_101A714C);
  sub_10025DF0(0x20u, 6037, &unk_101A716C);
  sub_10025DF0(0x20u, 6038, &unk_101A718C);
  sub_10025DF0(0x20u, 6039, &unk_101A71AC);
  sub_10025DF0(0x20u, 6040, &unk_101A71CC);
  sub_10025DF0(0x20u, 6041, &unk_101A71EC);
  sub_10025DF0(0x20u, 6042, &unk_101A720C);
  sub_10025DF0(0x20u, 6043, &unk_101A722C);
  sub_10025DF0(4u, 6044, &unk_101A724C);
  sub_10025DF0(4u, 6045, &unk_101A7250);
  sub_10025DF0(4u, 6046, &unk_101A7254);
  sub_10025DF0(4u, 6357, &unk_101A7258);
  sub_10025DF0(4u, 6358, &unk_101A725C);
  sub_10025DF0(4u, 6359, &unk_101A7260);
  sub_10025DF0(0x20u, 6047, &unk_101A7264);
  sub_10025DF0(0x20u, 6048, &unk_101A7284);
  sub_10025DF0(0x20u, 6049, &unk_101A72A4);
  sub_10025DF0(0x20u, 6050, &unk_101A72C4);
  sub_10025DF0(0x20u, 6051, &unk_101A72E4);
  sub_10025DF0(0x20u, 6052, &unk_101A7304);
  sub_10025DF0(0x20u, 6053, &unk_101A7324);
  sub_10025DF0(0x20u, 6054, &unk_101A7344);
  sub_10025DF0(1u, 6511, &unk_101A7364);
  sub_10025DF0(1u, 6522, &unk_101A7365);
  sub_10025DF0(1u, 6057, &unk_101A7366);
  sub_10025DF0(0x20u, 6075, &unk_101A73B8);
  sub_10025DF0(0x20u, 6076, &unk_101A73D8);
  sub_10025DF0(1u, 6077, &unk_101A73F8);
  sub_10025DF0(4u, 6079, &unk_101A73FC);
  sub_10025DF0(4u, 6080, &unk_101A7400);
  sub_10025DF0(0x20u, 6082, &unk_101A7404);
  sub_10025DF0(0x20u, 6083, &unk_101A7424);
  sub_10025DF0(0x20u, 6084, &unk_101A7444);
  sub_10025DF0(0x20u, 6085, &unk_101A7464);
  sub_10025DF0(0x20u, 6086, &unk_101A7484);
  sub_10025DF0(0x20u, 6087, &unk_101A74A4);
  sub_10025DF0(0x20u, 6088, &unk_101A74C4);
  sub_10025DF0(0x20u, 6089, &unk_101A74E4);
  sub_10025DF0(0x20u, 6123, &unk_101A7504);
  sub_10025DF0(0x48u, 6906, &unk_101A7524);
  sub_10025DF0(0x48u, 6907, &unk_101A756C);
  sub_10025DF0(0x48u, 6908, &unk_101A75B4);
  sub_10025DF0(0x48u, 6909, &unk_101A75FC);
  sub_10025DF0(0x48u, 6910, &unk_101A7644);
  sub_10025DF0(0x48u, 6911, &unk_101A768C);
  sub_10025DF0(0x48u, 6912, &unk_101A76D4);
  sub_10025DF0(0x48u, 6913, &unk_101A771C);
  sub_10025DF0(0x48u, 6914, &unk_101A7764);
  sub_10025DF0(0x48u, 6915, &unk_101A77AC);
  sub_10025DF0(0x48u, 6916, &unk_101A77F4);
  sub_10025DF0(0x48u, 6917, &unk_101A783C);
  sub_10025DF0(0x48u, 6918, &unk_101A7884);
  sub_10025DF0(0x48u, 6919, &unk_101A78CC);
  sub_10025DF0(0x48u, 6920, &unk_101A7914);
  sub_10025DF0(0x48u, 6921, &unk_101A795C);
  sub_10025DF0(0x48u, 6922, &unk_101A79A4);
  sub_10025DF0(0x48u, 6923, &unk_101A79EC);
  sub_10025DF0(0x48u, 6924, &unk_101A7A34);
  sub_10025DF0(0x48u, 6925, &unk_101A7A7C);
  sub_10025DF0(0x48u, 6926, &unk_101A7AC4);
  sub_10025DF0(0x48u, 6927, &unk_101A7B0C);
  sub_10025DF0(0x48u, 6928, &unk_101A7B54);
  sub_10025DF0(0x48u, 6929, &unk_101A7B9C);
  sub_10025DF0(0x48u, 6930, &unk_101A7BE4);
  sub_10025DF0(0x48u, 6931, &unk_101A7C2C);
  sub_10025DF0(0x48u, 6932, &unk_101A7C74);
  sub_10025DF0(0x48u, 6933, &unk_101A7CBC);
  sub_10025DF0(0x48u, 6934, &unk_101A7D04);
  sub_10025DF0(0x48u, 6935, &unk_101A7D4C);
  sub_10025DF0(0x18u, 6163, &unk_101A7D94);
  sub_10025DF0(0x20u, 6164, &unk_101A7DAC);
  sub_10025DF0(0x20u, 6165, &unk_101A7DCC);
  sub_10025DF0(2u, 6166, &unk_101A7DEC);
  sub_10025DF0(0xA4u, 40100, &unk_101A7DF0);
  sub_10025DF0(0xA4u, 40101, &unk_101A7E94);
  sub_10025DF0(0xA4u, 40102, &unk_101A7F38);
  sub_10025DF0(0xA4u, 40103, &unk_101A7FDC);
  sub_10025DF0(0xA4u, 40104, &unk_101A8080);
  sub_10025DF0(0xA4u, 40105, &unk_101A8124);
  sub_10025DF0(0xA4u, 40106, &unk_101A81C8);
  sub_10025DF0(0xA4u, 40107, &unk_101A826C);
  sub_10025DF0(0xA4u, 40108, &unk_101A8310);
  sub_10025DF0(0xA4u, 40109, &unk_101A83B4);
  sub_10025DF0(0xA4u, 40110, &unk_101A8458);
  sub_10025DF0(0xA4u, 40111, &unk_101A84FC);
  sub_10025DF0(0xA4u, 40112, &unk_101A85A0);
  sub_10025DF0(0xA4u, 40113, &unk_101A8644);
  sub_10025DF0(0xA4u, 40114, &unk_101A86E8);
  sub_10025DF0(0xA4u, 40115, &unk_101A878C);
  sub_10025DF0(0xA4u, 40116, &unk_101A8830);
  sub_10025DF0(0xA4u, 40117, &unk_101A88D4);
  sub_10025DF0(0xA4u, 40118, &unk_101A8978);
  sub_10025DF0(0xA4u, 40119, &unk_101A8A1C);
  sub_10025DF0(0xA4u, 40120, &unk_101A8AC0);
  sub_10025DF0(0xA4u, 40121, &unk_101A8B64);
  sub_10025DF0(0xA4u, 40122, &unk_101A8C08);
  sub_10025DF0(0xA4u, 40123, &unk_101A8CAC);
  sub_10025DF0(0xA4u, 40124, &unk_101A8D50);
  sub_10025DF0(0xA4u, 40125, &unk_101A8DF4);
  sub_10025DF0(0xA4u, 40126, &unk_101A8E98);
  sub_10025DF0(0xA4u, 40127, &unk_101A8F3C);
  sub_10025DF0(0xA4u, 40128, &unk_101A8FE0);
  sub_10025DF0(0xA4u, 40129, &unk_101A9084);
  sub_10025DF0(0xA4u, 40130, &unk_101A9128);
  sub_10025DF0(0xA4u, 40131, &unk_101A91CC);
  sub_10025DF0(0xA4u, 40132, &unk_101A9270);
  sub_10025DF0(0xA4u, 40133, &unk_101A9314);
  sub_10025DF0(0xA4u, 40134, &unk_101A93B8);
  sub_10025DF0(0xA4u, 40135, &unk_101A945C);
  sub_10025DF0(0xA4u, 40136, &unk_101A9500);
  sub_10025DF0(0xA4u, 40137, &unk_101A95A4);
  sub_10025DF0(0xA4u, 40138, &unk_101A9648);
  sub_10025DF0(0xA4u, 40139, &unk_101A96EC);
  sub_10025DF0(0xA4u, 40140, &unk_101A9790);
  sub_10025DF0(0xA4u, 40141, &unk_101A9834);
  sub_10025DF0(0xA4u, 40142, &unk_101A98D8);
  sub_10025DF0(0xA4u, 40143, &unk_101A997C);
  sub_10025DF0(0xA4u, 40144, &unk_101A9A20);
  sub_10025DF0(0xA4u, 40145, &unk_101A9AC4);
  sub_10025DF0(0xA4u, 40146, &unk_101A9B68);
  sub_10025DF0(0xA4u, 40147, &unk_101A9C0C);
  sub_10025DF0(0xA4u, 40148, &unk_101A9CB0);
  sub_10025DF0(0xA4u, 40149, &unk_101A9D54);
  sub_10025DF0(0xA4u, 40150, &unk_101A9DF8);
  sub_10025DF0(0xA4u, 40151, &unk_101A9E9C);
  sub_10025DF0(0xA4u, 40152, &unk_101A9F40);
  sub_10025DF0(0xA4u, 40153, &unk_101A9FE4);
  sub_10025DF0(0xA4u, 40154, &unk_101AA088);
  sub_10025DF0(0xA4u, 40155, &unk_101AA12C);
  sub_10025DF0(0xA4u, 40156, &unk_101AA1D0);
  sub_10025DF0(0xA4u, 40157, &unk_101AA274);
  sub_10025DF0(0xA4u, 40158, &unk_101AA318);
  sub_10025DF0(0xA4u, 40159, &unk_101AA3BC);
  sub_10025DF0(0xA4u, 40160, &unk_101AA460);
  sub_10025DF0(0xA4u, 40161, &unk_101AA504);
  sub_10025DF0(0xA4u, 40162, &unk_101AA5A8);
  sub_10025DF0(0xA4u, 40163, &unk_101AA64C);
  sub_10025DF0(0xA4u, 40164, &unk_101AA6F0);
  sub_10025DF0(0xA4u, 40165, &unk_101AA794);
  sub_10025DF0(0xA4u, 40166, &unk_101AA838);
  sub_10025DF0(0xA4u, 40167, &unk_101AA8DC);
  sub_10025DF0(0xA4u, 40168, &unk_101AA980);
  sub_10025DF0(0xA4u, 40169, &unk_101AAA24);
  sub_10025DF0(0xA4u, 40170, &unk_101AAAC8);
  sub_10025DF0(0xA4u, 40171, &unk_101AAB6C);
  sub_10025DF0(0xA4u, 40172, &unk_101AAC10);
  sub_10025DF0(0xA4u, 40173, &unk_101AACB4);
  sub_10025DF0(0xA4u, 40174, &unk_101AAD58);
  sub_10025DF0(0xA4u, 40175, &unk_101AADFC);
  sub_10025DF0(0xA4u, 40176, &unk_101AAEA0);
  sub_10025DF0(0xA4u, 40177, &unk_101AAF44);
  sub_10025DF0(0xA4u, 40178, &unk_101AAFE8);
  sub_10025DF0(0xA4u, 40179, &unk_101AB08C);
  sub_10025DF0(0xA4u, 40180, &unk_101AB130);
  sub_10025DF0(0xA4u, 40181, &unk_101AB1D4);
  sub_10025DF0(0xA4u, 40182, &unk_101AB278);
  sub_10025DF0(0xA4u, 40183, &unk_101AB31C);
  sub_10025DF0(0xA4u, 40184, &unk_101AB3C0);
  sub_10025DF0(0xA4u, 40185, &unk_101AB464);
  sub_10025DF0(0xA4u, 40186, &unk_101AB508);
  sub_10025DF0(0xA4u, 40187, &unk_101AB5AC);
  sub_10025DF0(0xA4u, 40188, &unk_101AB650);
  sub_10025DF0(0xA4u, 40189, &unk_101AB6F4);
  sub_10025DF0(0xA4u, 40190, &unk_101AB798);
  sub_10025DF0(0xA4u, 40191, &unk_101AB83C);
  sub_10025DF0(0xA4u, 40192, &unk_101AB8E0);
  sub_10025DF0(0xA4u, 40193, &unk_101AB984);
  sub_10025DF0(0xA4u, 40194, &unk_101ABA28);
  sub_10025DF0(0xA4u, 40195, &unk_101ABACC);
  sub_10025DF0(0xA4u, 40196, &unk_101ABB70);
  sub_10025DF0(0xA4u, 40197, &unk_101ABC14);
  sub_10025DF0(0xA4u, 40198, &unk_101ABCB8);
  sub_10025DF0(0xA4u, 40199, &unk_101ABD5C);
  sub_10025DF0(0x20u, 6190, &unk_101ABE00);
  sub_10025DF0(0x20u, 6191, &unk_101ABE20);
  sub_10025DF0(0x20u, 6192, &unk_101ABE40);
  sub_10025DF0(0x20u, 6199, &unk_101ABE60);
  sub_10025DF0(0x28u, 6207, &unk_101ABE80);
  sub_10025DF0(4u, 6231, &unk_101AC998);
  sub_10025DF0(4u, 6232, &unk_101AC99C);
  sub_10025DF0(4u, 6233, &unk_101AC9A0);
  sub_10025DF0(4u, 6234, &unk_101AC9A4);
  sub_10025DF0(0x1Cu, 40000, &unk_101ABEA8);
  sub_10025DF0(0x1Cu, 40001, &unk_101ABEC4);
  sub_10025DF0(0x1Cu, 40002, &unk_101ABEE0);
  sub_10025DF0(0x1Cu, 40003, &unk_101ABEFC);
  sub_10025DF0(0x1Cu, 40004, &unk_101ABF18);
  sub_10025DF0(0x1Cu, 40005, &unk_101ABF34);
  sub_10025DF0(0x1Cu, 40006, &unk_101ABF50);
  sub_10025DF0(0x1Cu, 40007, &unk_101ABF6C);
  sub_10025DF0(0x1Cu, 40008, &unk_101ABF88);
  sub_10025DF0(0x1Cu, 40009, &unk_101ABFA4);
  sub_10025DF0(0x1Cu, 40010, &unk_101ABFC0);
  sub_10025DF0(0x1Cu, 40011, &unk_101ABFDC);
  sub_10025DF0(0x1Cu, 40012, &unk_101ABFF8);
  sub_10025DF0(0x1Cu, 40013, &unk_101AC014);
  sub_10025DF0(0x1Cu, 40014, &unk_101AC030);
  sub_10025DF0(0x1Cu, 40015, &unk_101AC04C);
  sub_10025DF0(0x1Cu, 40016, &unk_101AC068);
  sub_10025DF0(0x1Cu, 40017, &unk_101AC084);
  sub_10025DF0(0x1Cu, 40018, &unk_101AC0A0);
  sub_10025DF0(0x1Cu, 40019, &unk_101AC0BC);
  sub_10025DF0(0x1Cu, 40020, &unk_101AC0D8);
  sub_10025DF0(0x1Cu, 40021, &unk_101AC0F4);
  sub_10025DF0(0x1Cu, 40022, &unk_101AC110);
  sub_10025DF0(0x1Cu, 40023, &unk_101AC12C);
  sub_10025DF0(0x1Cu, 40024, &unk_101AC148);
  sub_10025DF0(0x1Cu, 40025, &unk_101AC164);
  sub_10025DF0(0x1Cu, 40026, &unk_101AC180);
  sub_10025DF0(0x1Cu, 40027, &unk_101AC19C);
  sub_10025DF0(0x1Cu, 40028, &unk_101AC1B8);
  sub_10025DF0(0x1Cu, 40029, &unk_101AC1D4);
  sub_10025DF0(0x1Cu, 40030, &unk_101AC1F0);
  sub_10025DF0(0x1Cu, 40031, &unk_101AC20C);
  sub_10025DF0(0x1Cu, 40032, &unk_101AC228);
  sub_10025DF0(0x1Cu, 40033, &unk_101AC244);
  sub_10025DF0(0x1Cu, 40034, &unk_101AC260);
  sub_10025DF0(0x1Cu, 40035, &unk_101AC27C);
  sub_10025DF0(0x1Cu, 40036, &unk_101AC298);
  sub_10025DF0(0x1Cu, 40037, &unk_101AC2B4);
  sub_10025DF0(0x1Cu, 40038, &unk_101AC2D0);
  sub_10025DF0(0x1Cu, 40039, &unk_101AC2EC);
  sub_10025DF0(0x1Cu, 40040, &unk_101AC308);
  sub_10025DF0(0x1Cu, 40041, &unk_101AC324);
  sub_10025DF0(0x1Cu, 40042, &unk_101AC340);
  sub_10025DF0(0x1Cu, 40043, &unk_101AC35C);
  sub_10025DF0(0x1Cu, 40044, &unk_101AC378);
  sub_10025DF0(0x1Cu, 40045, &unk_101AC394);
  sub_10025DF0(0x1Cu, 40046, &unk_101AC3B0);
  sub_10025DF0(0x1Cu, 40047, &unk_101AC3CC);
  sub_10025DF0(0x1Cu, 40048, &unk_101AC3E8);
  sub_10025DF0(0x1Cu, 40049, &unk_101AC404);
  sub_10025DF0(0x1Cu, 40050, &unk_101AC420);
  sub_10025DF0(0x1Cu, 40051, &unk_101AC43C);
  sub_10025DF0(0x1Cu, 40052, &unk_101AC458);
  sub_10025DF0(0x1Cu, 40053, &unk_101AC474);
  sub_10025DF0(0x1Cu, 40054, &unk_101AC490);
  sub_10025DF0(0x1Cu, 40055, &unk_101AC4AC);
  sub_10025DF0(0x1Cu, 40056, &unk_101AC4C8);
  sub_10025DF0(0x1Cu, 40057, &unk_101AC4E4);
  sub_10025DF0(0x1Cu, 40058, &unk_101AC500);
  sub_10025DF0(0x1Cu, 40059, &unk_101AC51C);
  sub_10025DF0(0x1Cu, 40060, &unk_101AC538);
  sub_10025DF0(0x1Cu, 40061, &unk_101AC554);
  sub_10025DF0(0x1Cu, 40062, &unk_101AC570);
  sub_10025DF0(0x1Cu, 40063, &unk_101AC58C);
  sub_10025DF0(0x1Cu, 40064, &unk_101AC5A8);
  sub_10025DF0(0x1Cu, 40065, &unk_101AC5C4);
  sub_10025DF0(0x1Cu, 40066, &unk_101AC5E0);
  sub_10025DF0(0x1Cu, 40067, &unk_101AC5FC);
  sub_10025DF0(0x1Cu, 40068, &unk_101AC618);
  sub_10025DF0(0x1Cu, 40069, &unk_101AC634);
  sub_10025DF0(0x1Cu, 40070, &unk_101AC650);
  sub_10025DF0(0x1Cu, 40071, &unk_101AC66C);
  sub_10025DF0(0x1Cu, 40072, &unk_101AC688);
  sub_10025DF0(0x1Cu, 40073, &unk_101AC6A4);
  sub_10025DF0(0x1Cu, 40074, &unk_101AC6C0);
  sub_10025DF0(0x1Cu, 40075, &unk_101AC6DC);
  sub_10025DF0(0x1Cu, 40076, &unk_101AC6F8);
  sub_10025DF0(0x1Cu, 40077, &unk_101AC714);
  sub_10025DF0(0x1Cu, 40078, &unk_101AC730);
  sub_10025DF0(0x1Cu, 40079, &unk_101AC74C);
  sub_10025DF0(0x1Cu, 40080, &unk_101AC768);
  sub_10025DF0(0x1Cu, 40081, &unk_101AC784);
  sub_10025DF0(0x1Cu, 40082, &unk_101AC7A0);
  sub_10025DF0(0x1Cu, 40083, &unk_101AC7BC);
  sub_10025DF0(0x1Cu, 40084, &unk_101AC7D8);
  sub_10025DF0(0x1Cu, 40085, &unk_101AC7F4);
  sub_10025DF0(0x1Cu, 40086, &unk_101AC810);
  sub_10025DF0(0x1Cu, 40087, &unk_101AC82C);
  sub_10025DF0(0x1Cu, 40088, &unk_101AC848);
  sub_10025DF0(0x1Cu, 40089, &unk_101AC864);
  sub_10025DF0(0x1Cu, 40090, &unk_101AC880);
  sub_10025DF0(0x1Cu, 40091, &unk_101AC89C);
  sub_10025DF0(0x1Cu, 40092, &unk_101AC8B8);
  sub_10025DF0(0x1Cu, 40093, &unk_101AC8D4);
  sub_10025DF0(0x1Cu, 40094, &unk_101AC8F0);
  sub_10025DF0(0x1Cu, 40095, &unk_101AC90C);
  sub_10025DF0(0x1Cu, 40096, &unk_101AC928);
  sub_10025DF0(0x1Cu, 40097, &unk_101AC944);
  sub_10025DF0(0x1Cu, 40098, &unk_101AC960);
  sub_10025DF0(0x1Cu, 40099, &unk_101AC97C);
  sub_10025DF0(4u, 6238, &unk_101AC9A8);
  sub_10025DF0(4u, 6239, &unk_101AC9AC);
  sub_10025DF0(4u, 6240, &unk_101AC9B0);
  sub_10025DF0(4u, 6242, &unk_101AC9B4);
  sub_10025DF0(4u, 6244, &unk_101AC9B8);
  sub_10025DF0(4u, 6245, &unk_101AC9BC);
  sub_10025DF0(4u, 6246, &unk_101AC9C0);
  sub_10025DF0(4u, 6251, &unk_101AC9C4);
  sub_10025DF0(4u, 6252, &unk_101AC9C8);
  sub_10025DF0(4u, 6253, &unk_101AC9CC);
  sub_10025DF0(4u, 6254, &unk_101AC9D0);
  sub_10025DF0(1u, 6255, &unk_101AC9D4);
  sub_10025DF0(4u, 6256, &unk_101AC9D8);
  sub_10025DF0(4u, 6257, &unk_101AC9DC);
  sub_10025DF0(0xE2u, 6286, &unk_101AC9E0);
  v0 = 18000;
  v1 = &unk_101ACAC4;
  v2 = 16;
  do
  {
    sub_10025DF0(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10025DF0(4u, 6262, &unk_101ADC84);
  sub_10025DF0(0x28u, 6263, &unk_101ADC88);
  sub_10025DF0(0x28u, 6264, &unk_101ADCB0);
  sub_10025DF0(0x40u, 6268, &unk_101ADCD8);
  sub_10025DF0(4u, 6272, &unk_101ADD98);
  sub_10025DF0(4u, 6273, &unk_101ADD9C);
  sub_10025DF0(1u, 6274, &unk_101ADDA0);
  sub_10025DF0(2u, 6275, &unk_101ADDA2);
  sub_10025DF0(1u, 6276, &unk_101ADDA4);
  sub_10025DF0(1u, 6277, &unk_101ADDA5);
  sub_10025DF0(1u, 6278, &unk_101ADDA6);
  sub_10025DF0(0x40u, 6279, &unk_101ADDA8);
  sub_10025DF0(0x28u, 6753, &unk_101AEC5D);
  sub_10025DF0(0x30u, 6754, &unk_101AEC88);
  sub_10025DF0(0x28u, 6958, &unk_101AECB8);
  sub_10025DF0(0x80u, 6802, &unk_101ADD18);
  sub_10025DF0(1u, 6760, &unk_101AECE0);
  sub_10025DF0(0x10u, 6312, &unk_101AE12C);
  sub_10025DF0(0x10u, 6313, &unk_101AE13C);
  sub_10025DF0(0x10u, 6314, &unk_101AE14C);
  sub_10025DF0(1u, 6307, &unk_101AE15C);
  sub_10025DF0(1u, 6308, &unk_101AE15D);
  sub_10025DF0(1u, 6309, &unk_101AE15E);
  sub_10025DF0(4u, 6285, &unk_101AE160);
  sub_10025DF0(0xA8u, 6318, &unk_101AE164);
  sub_10025DF0(4u, 6319, &unk_101AE20C);
  sub_10025DF0(1u, 6350, &unk_101AE210);
  sub_10025DF0(0x50u, 6351, &unk_101AE214);
  sub_10025DF0(4u, 6352, &unk_101AE264);
  sub_10025DF0(4u, 6353, &unk_101AE268);
  sub_10025DF0(0x54u, 6448, &unk_101AE4B4);
  sub_10025DF0(0x54u, 6449, &unk_101AE508);
  sub_10025DF0(8u, 6287, &unk_101ADE0C);
  sub_10025DF0(8u, 6288, &unk_101ADE14);
  sub_10025DF0(8u, 6289, &unk_101ADE1C);
  sub_10025DF0(8u, 6290, &unk_101ADE24);
  sub_10025DF0(8u, 6291, &unk_101ADE2C);
  sub_10025DF0(8u, 6292, &unk_101ADE34);
  sub_10025DF0(8u, 6293, &unk_101ADE3C);
  sub_10025DF0(8u, 6294, &unk_101ADE44);
  sub_10025DF0(8u, 6295, &unk_101ADE4C);
  sub_10025DF0(8u, 6296, &unk_101ADE54);
  sub_10025DF0(8u, 6297, &unk_101ADE5C);
  sub_10025DF0(8u, 6298, &unk_101ADE64);
  sub_10025DF0(8u, 6299, &unk_101ADE6C);
  sub_10025DF0(8u, 6300, &unk_101ADE74);
  sub_10025DF0(8u, 6301, &unk_101ADE7C);
  sub_10025DF0(8u, 6302, &unk_101ADE84);
  sub_10025DF0(8u, 6303, &unk_101ADE8C);
  sub_10025DF0(8u, 6304, &unk_101ADE94);
  sub_10025DF0(8u, 6305, &unk_101ADE9C);
  sub_10025DF0(8u, 6306, &unk_101ADEA4);
  sub_10025DF0(8u, 6409, &unk_101ADEAC);
  sub_10025DF0(8u, 6410, &unk_101ADEB4);
  sub_10025DF0(8u, 6411, &unk_101ADEBC);
  sub_10025DF0(8u, 6412, &unk_101ADEC4);
  sub_10025DF0(8u, 6413, &unk_101ADECC);
  sub_10025DF0(8u, 6414, &unk_101ADED4);
  sub_10025DF0(8u, 6415, &unk_101ADEDC);
  sub_10025DF0(8u, 6416, &unk_101ADEE4);
  sub_10025DF0(8u, 6417, &unk_101ADEEC);
  sub_10025DF0(8u, 6418, &unk_101ADEF4);
  sub_10025DF0(8u, 6419, &unk_101ADEFC);
  sub_10025DF0(8u, 6420, &unk_101ADF04);
  sub_10025DF0(8u, 6421, &unk_101ADF0C);
  sub_10025DF0(8u, 6422, &unk_101ADF14);
  sub_10025DF0(8u, 6423, &unk_101ADF1C);
  sub_10025DF0(8u, 6424, &unk_101ADF24);
  sub_10025DF0(8u, 6425, &unk_101ADF2C);
  sub_10025DF0(8u, 6426, &unk_101ADF34);
  sub_10025DF0(8u, 6427, &unk_101ADF3C);
  sub_10025DF0(8u, 6428, &unk_101ADF44);
  sub_10025DF0(4u, 6429, &unk_101AE44C);
  sub_10025DF0(8u, 6430, &unk_101AE450);
  sub_10025DF0(8u, 6431, &unk_101AE458);
  sub_10025DF0(8u, 6432, &unk_101AE460);
  sub_10025DF0(8u, 6433, &unk_101AE468);
  sub_10025DF0(8u, 6434, &unk_101AE470);
  sub_10025DF0(8u, 6435, &unk_101AE478);
  sub_10025DF0(8u, 6436, &unk_101AE480);
  sub_10025DF0(8u, 6437, &unk_101AE488);
  sub_10025DF0(8u, 6438, &unk_101AE490);
  sub_10025DF0(8u, 6439, &unk_101AE498);
  sub_10025DF0(8u, 6440, &unk_101AE4A0);
  sub_10025DF0(0xAu, 6519, &unk_101AE90C);
  sub_10025DF0(4u, 6442, &unk_101AE4A8);
  sub_10025DF0(4u, 6443, &unk_101AE4AC);
  sub_10025DF0(0xF0u, 6367, &unk_101AE26C);
  sub_10025DF0(0xF0u, 6368, &unk_101AE35C);
  sub_10025DF0(1u, 6446, &unk_101AE4B0);
  sub_10025DF0(6u, 6452, &unk_101AE55C);
  sub_10025DF0(4u, 6457, &unk_101AE564);
  sub_10025DF0(4u, 6458, &unk_101AE568);
  sub_10025DF0(4u, 6459, &unk_101AE56C);
  sub_10025DF0(4u, 6460, &unk_101AE570);
  sub_10025DF0(0x208u, 6515, &unk_101AE574);
  sub_10025DF0(0x160u, 6516, &unk_101AE77C);
  sub_10025DF0(0x18u, 6517, &unk_101AE8DC);
  sub_10025DF0(0x18u, 6518, &unk_101AE8F4);
  sub_10025DF0(1u, 6520, &unk_101AE916);
  sub_10025DF0(0x10u, 6521, &unk_101AE918);
  sub_10025DF0(4u, 6523, &unk_101AE928);
  sub_10025DF0(4u, 6524, &unk_101AE92C);
  sub_10025DF0(4u, 6525, &unk_101AE930);
  sub_10025DF0(1u, 6526, &unk_101AE934);
  sub_10025DF0(1u, 6527, &unk_101AE935);
  sub_10025DF0(0x50u, 6528, &unk_101AE938);
  sub_10025DF0(4u, 6529, &unk_101AE988);
  sub_10025DF0(1u, 6530, &unk_101AE98C);
  sub_10025DF0(1u, 6531, &unk_101AE98D);
  sub_10025DF0(1u, 6532, &unk_101AE98E);
  sub_10025DF0(0x14u, 6533, &unk_101AE98F);
  sub_10025DF0(0xAu, 6883, &unk_101AF0A8);
  sub_10025DF0(0xAu, 6884, &unk_101AF0B2);
  sub_10025DF0(0xAu, 6885, &unk_101AF0BC);
  sub_10025DF0(1u, 6664, &unk_101AE9A3);
  sub_10025DF0(1u, 6666, &unk_101AE9A4);
  sub_10025DF0(1u, 6667, &unk_101AE9A5);
  sub_10025DF0(1u, 6668, &unk_101AE9A6);
  sub_10025DF0(0xA0u, 6669, &unk_101AE9A8);
  sub_10025DF0(2u, 6670, &unk_101AEA98);
  sub_10025DF0(4u, 6671, &unk_101AEA9C);
  sub_10025DF0(4u, 6672, &unk_101AEAA0);
  sub_10025DF0(4u, 6673, &unk_101AEAA4);
  sub_10025DF0(4u, 6674, &unk_101AEAA8);
  sub_10025DF0(4u, 6675, &unk_101AEAAC);
  sub_10025DF0(4u, 6676, &unk_101AEAB4);
  sub_10025DF0(4u, 6677, &unk_101AEABC);
  sub_10025DF0(4u, 6678, &unk_101AEAC0);
  sub_10025DF0(1u, 6679, &unk_101AEAC4);
  sub_10025DF0(0x140u, 6680, &unk_101AEAC8);
  sub_10025DF0(4u, 6882, &unk_101AF0A4);
  sub_10025DF0(0xCu, 6652, &unk_101AEC08);
  sub_10025DF0(0x48u, 6653, &unk_101AEC14);
  sub_10025DF0(1u, 6688, &unk_101AEC5C);
  sub_10025DF0(4u, 6771, &unk_101AECE4);
  sub_10025DF0(4u, 6772, &unk_101AECE8);
  sub_10025DF0(8u, 6787, &unk_101AECEC);
  sub_10025DF0(1u, 6832, &unk_101AED1C);
  sub_10025DF0(1u, 6833, &unk_101AED1D);
  sub_10025DF0(1u, 6834, &unk_101AED1E);
  sub_10025DF0(4u, 6835, &unk_101AED20);
  sub_10025DF0(4u, 6836, &unk_101AED24);
  sub_10025DF0(4u, 6837, &unk_101AED28);
  sub_10025DF0(4u, 6838, &unk_101AED2C);
  sub_10025DF0(1u, 6839, &unk_101AED30);
  sub_10025DF0(0x50u, 6840, &unk_101AEA48);
  sub_10025DF0(4u, 6841, &unk_101AED34);
  sub_10025DF0(4u, 6842, &unk_101AED38);
  sub_10025DF0(4u, 6843, &unk_101AED3C);
  sub_10025DF0(1u, 6844, &unk_101AED40);
  sub_10025DF0(0x360u, 6845, &unk_101AED44);
  sub_10025DF0(4u, 6846, &unk_101AEAB0);
  sub_10025DF0(4u, 6847, &unk_101AEAB8);
  result = 1;
  dword_102D2B4C = (int)&unk_101A6EA8;
  return result;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10027C40) --------------------------------------------------------
char __cdecl sub_10027C40(int a1, int a2, int a3, int a4, _WORD *a5)
{
  bool v5; // zf@3
  signed int v6; // edx@6
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  void *v9; // ecx@8
  signed int v10; // ecx@18
  signed int v11; // edx@18
  double v12; // st7@18
  double v13; // st6@18
  double v14; // st5@18
  float v15; // ST10_4@18
  float v16; // ST08_4@18
  float v17; // ST04_4@18
  int v19; // [sp+1Ch] [bp-40h]@8
  unsigned int v20; // [sp+20h] [bp-3Ch]@6
  float v21; // [sp+24h] [bp-38h]@18
  float v22; // [sp+28h] [bp-34h]@6
  float v23; // [sp+2Ch] [bp-30h]@6
  int v24; // [sp+30h] [bp-2Ch]@3
  float v25; // [sp+34h] [bp-28h]@3
  int v26; // [sp+38h] [bp-24h]@3
  int v27; // [sp+3Ch] [bp-20h]@6
  float v28; // [sp+40h] [bp-1Ch]@6
  float v29; // [sp+44h] [bp-18h]@6
  float v30; // [sp+48h] [bp-14h]@17
  char v31; // [sp+4Ch] [bp-10h]@10

  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v5 = *(_BYTE *)(a4 + 8) == 0;
    v25 = 15.0;
    v26 = -16777216;
    v24 = 4;
    if ( !v5 )
      v26 = *(_DWORD *)(a4 + 12);
    if ( *(_BYTE *)a4 )
    {
      v6 = *(_WORD *)(a3 + 2);
      v28 = *(float *)(a2 + 16);
      v27 = -1;
      v7 = *(_WORD *)a3;
      v29 = *(float *)(a2 + 20);
      v20 = v7;
      v8 = *(_DWORD *)(a4 + 4);
      v22 = (double)(signed int)v20;
      v20 = v8;
      v23 = (double)v6;
      if ( sub_10025AB0((void *)a4) == 1 )
        sub_10048C40((int *)&v20, v20);
      sub_10048B70((int)&v19, v20);
      if ( sub_10025A80(v9) == 1 )
      {
        if ( (_WORD)v19 )
        {
          if ( (signed __int16)v19 >= 12 )
          {
            if ( (_WORD)v19 == 12 )
              sprintf(&v31, "%02d:%02d:%02d%c", 12, BYTE2(v19), BYTE3(v19), 149);
            else
              sprintf(&v31, "%d:%02d:%02d%c", (signed __int16)v19 % 12, BYTE2(v19), BYTE3(v19), 149);
          }
          else
          {
            sprintf(&v31, "%d:%02d:%02d%c", (signed __int16)v19, BYTE2(v19), BYTE3(v19), 148);
          }
        }
        else
        {
          sprintf(&v31, "%02d:%02d:%02d%c", 12, BYTE2(v19), BYTE3(v19), 148);
        }
      }
      else
      {
        sprintf(&v31, "%02d:%02d:%02d", (signed __int16)v19, BYTE2(v19), BYTE3(v19));
      }
      v30 = 0.0;
      sub_10038F80((int)&v31, (int)&v22);
    }
    else
    {
      v10 = *(_WORD *)(a2 + 4);
      v28 = 0.5;
      v11 = *(_WORD *)(a2 + 6);
      v29 = 0.5;
      v19 = v10;
      v20 = v11;
      v12 = (double)v10;
      v13 = *(float *)(a2 + 8);
      v27 = -256;
      v22 = v13 * 0.5 + v12;
      v14 = (double)v11;
      v23 = 0.5 * *(float *)(a2 + 12) + v14;
      v21 = v14 + *(float *)(a2 + 12);
      v15 = v21;
      v21 = v12 + *(float *)(a2 + 8);
      v16 = v14;
      v17 = v12;
      sub_10038FD0(v17, v16, v21, v15, 0);
    }
    *(_BYTE *)(a1 + 6) = 2;
  }
  return 1;
}

//----- (10027EB0) --------------------------------------------------------
char __cdecl sub_10027EB0(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char *v5; // eax@1

  v5 = sub_10040510(*a4);
  return sub_10027F20(a1, a2, a3, (int)v5, a5);
}

//----- (10027ED0) --------------------------------------------------------
int __usercall sub_10027ED0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  *(_DWORD *)(result + 16) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(result + 20) = *(_DWORD *)(a3 + 4);
  *(float *)(result + 12) = *(float *)(a3 + 12);
  *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 20);
  *(float *)(result + 24) = *(float *)(a3 + 24);
  *(float *)(result + 28) = *(float *)(a3 + 28);
  *(float *)(result + 32) = *(float *)(a3 + 16);
  *(float *)result = (double)*(_WORD *)a2;
  *(float *)(result + 4) = (double)*(_WORD *)(a2 + 2);
  return result;
}

//----- (10027F20) --------------------------------------------------------
char __cdecl sub_10027F20(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v6; // eax@5
  int v7; // eax@6
  char v8; // [sp+0h] [bp-24h]@5

  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      v6 = sub_10027ED0((int)&v8, a3, a2);
      sub_10038F40(a1, a4, v6);
      return 2;
    }
    if ( *a5 != 32888 )
      return 1;
  }
  v7 = sub_10027ED0((int)&v8, a3, a2);
  sub_100393C0(a1, a4, v7);
  return 2;
}

//----- (10027FA0) --------------------------------------------------------
__int16 __cdecl sub_10027FA0(char a1)
{
  return word_100A3CF2[2 * sub_100430B0(&a1, 1u, (int)&unk_100A3CF0, 4, 5, 0)];
}
// 100A3CF2: using guessed type __int16 word_100A3CF2[];

//----- (10027FD0) --------------------------------------------------------
_BYTE *__usercall sub_10027FD0@<eax>(int a1@<edi>, int a2@<esi>)
{
  int v2; // eax@1
  signed int v3; // ecx@1
  signed int v4; // eax@1
  double v5; // st7@1
  double v6; // st7@1
  signed int v7; // ST14_4@1
  signed int v8; // ST18_4@1
  float v9; // ST1C_4@1
  float v10; // ST0C_4@1
  float v11; // ST1C_4@1
  float v12; // ST04_4@1
  float v13; // ST00_4@1
  __int16 v14; // ax@1
  char *v15; // eax@1
  float v17; // [sp+20h] [bp-24h]@1
  float v18; // [sp+24h] [bp-20h]@1
  int v19; // [sp+28h] [bp-1Ch]@1
  float v20; // [sp+2Ch] [bp-18h]@1
  int v21; // [sp+30h] [bp-14h]@1
  int v22; // [sp+34h] [bp-10h]@1
  float v23; // [sp+38h] [bp-Ch]@1
  float v24; // [sp+3Ch] [bp-8h]@1
  float v25; // [sp+40h] [bp-4h]@1

  v21 = -16777216;
  v2 = sub_10038FA0(0);
  v20 = 15.0;
  v3 = *(_WORD *)(a2 + 6);
  v22 = v2;
  v4 = *(_WORD *)(a2 + 4);
  v23 = 0.5;
  v24 = 0.5;
  v5 = *(float *)(a2 + 8);
  v19 = 4;
  v17 = v5 * 0.5 + (double)v4;
  v6 = 0.5 * *(float *)(a2 + 12);
  *(_BYTE *)a1 = 0;
  v7 = *(_WORD *)(a2 + 6);
  v8 = *(_WORD *)(a2 + 4);
  v18 = v6 + (double)v3;
  v25 = 0.0;
  v9 = *(float *)(a2 + 12) + (double)v7;
  v10 = v9;
  v11 = (double)v8 + *(float *)(a2 + 8);
  v12 = (double)v7;
  v13 = (double)v8;
  sub_10038FD0(v13, v12, v11, v10, 0);
  v14 = sub_10027FA0(*(_BYTE *)(a1 + 1));
  v15 = sub_10040510(v14);
  return sub_10039430((int)v15, (int)&v17, 1);
}

//----- (100280C0) --------------------------------------------------------
char __cdecl sub_100280C0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  int v5; // ecx@1
  bool v6; // zf@3
  signed int v7; // edx@4
  signed int v8; // eax@4
  signed int v9; // ST24_4@4
  int v10; // eax@4
  double v11; // st7@7
  void *v12; // ebp@7
  char *v14; // [sp-Ch] [bp-5Ch]@13
  char *v15; // [sp-4h] [bp-54h]@13
  float v16; // [sp+18h] [bp-38h]@10
  float v17; // [sp+18h] [bp-38h]@12
  float v18; // [sp+20h] [bp-30h]@4
  float v19; // [sp+24h] [bp-2Ch]@4
  int v20; // [sp+28h] [bp-28h]@3
  float v21; // [sp+2Ch] [bp-24h]@3
  int v22; // [sp+30h] [bp-20h]@3
  int v23; // [sp+34h] [bp-1Ch]@4
  float v24; // [sp+38h] [bp-18h]@4
  float v25; // [sp+3Ch] [bp-14h]@4
  float v26; // [sp+40h] [bp-10h]@3
  char v27; // [sp+44h] [bp-Ch]@13

  v5 = *a5 - 32802;
  if ( *a5 == 32802 || (v5 = *a5 - 32888, *a5 == 32888) )
  {
    v6 = *(_BYTE *)a4 == 0;
    v21 = 15.0;
    v22 = -16777216;
    v26 = 0.0;
    v20 = 4;
    if ( v6 )
      goto LABEL_21;
    v7 = *(_WORD *)a3;
    v8 = *(_WORD *)(a3 + 2);
    v24 = *(float *)(a2 + 16);
    v25 = *(float *)(a2 + 20);
    v23 = -1;
    v9 = v8;
    v10 = *(_BYTE *)(a2 + 24) - 1;
    v18 = (double)v7;
    v19 = (double)v9;
    if ( v10 && (v10 == 1 || sub_10025A30(v5) == 4) )
    {
      v11 = *(float *)(a4 + 4);
      v12 = &unk_100A3D2C;
    }
    else
    {
      v11 = *(float *)(a4 + 4) * 1.799999952316284;
      v12 = &unk_100A3D28;
      if ( *(_BYTE *)(a4 + 1) != 3 )
        v11 = v11 + 32.0;
    }
    v16 = v11;
    if ( v16 > 999.0 || v16 < -999.0 )
    {
LABEL_21:
      sub_10027FD0(a4, a2);
    }
    else
    {
      v17 = sub_100707A0(v16, 1.0);
      if ( *(_BYTE *)(a4 + 1) == 3 )
      {
        v15 = "%+.0f%s";
        v14 = &v27;
      }
      else
      {
        v15 = "%.0f%s";
        v14 = &v27;
      }
      sub_10038570(v14, 6u, v15, v17, v12);
      sub_10038F80((int)&v27, (int)&v18);
    }
    *(_BYTE *)(a1 + 6) = 2;
  }
  return 1;
}

//----- (10028240) --------------------------------------------------------
int __usercall sub_10028240@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>, int a4@<ebp>)
{
  unsigned __int16 v4; // si@1
  unsigned __int16 v5; // di@1
  signed int v6; // ebp@2
  signed int v7; // ebx@2
  float v8; // ST58_4@2
  __int16 v9; // ax@2
  bool v10; // dl@2
  float v11; // ST50_4@2
  double v12; // st6@2
  double v13; // st4@7
  double v14; // st5@9
  double v15; // st4@10
  double v16; // st6@10
  float v17; // ST60_4@10
  float v18; // ST60_4@14
  float v19; // ST24_4@16
  float v20; // ST24_4@16
  float v21; // ST4C_4@16
  float v22; // ST50_4@16
  float v23; // ST24_4@16
  float v24; // ST48_4@16
  float v25; // ST50_4@16
  float v26; // ST24_4@16
  float v27; // ST60_4@16
  float v28; // ST60_4@16
  float v29; // ST24_4@16
  int v30; // [sp+14h] [bp-54h]@2
  float v31; // [sp+24h] [bp-44h]@2
  float v32; // [sp+28h] [bp-40h]@2
  float v33; // [sp+2Ch] [bp-3Ch]@2
  float v34; // [sp+2Ch] [bp-3Ch]@9
  float v35; // [sp+30h] [bp-38h]@6
  float v36; // [sp+30h] [bp-38h]@13
  float v37; // [sp+34h] [bp-34h]@2
  float v38; // [sp+38h] [bp-30h]@2
  float v39; // [sp+3Ch] [bp-2Ch]@2
  float v40; // [sp+40h] [bp-28h]@2
  signed int v41; // [sp+44h] [bp-24h]@2
  char v42; // [sp+4Ch] [bp-1Ch]@16
  float v43; // [sp+50h] [bp-18h]@16
  float v44; // [sp+54h] [bp-14h]@16
  float v45; // [sp+58h] [bp-10h]@16
  float v46; // [sp+5Ch] [bp-Ch]@16
  float v47; // [sp+60h] [bp-8h]@16
  float v48; // [sp+64h] [bp-4h]@16

  v4 = *(_WORD *)a2;
  v5 = *(_WORD *)(a2 + 2);
  if ( *(_WORD *)a2 > v5 )
  {
    v30 = a4;
    v6 = -8355712;
    v7 = -8355712;
    v31 = (double)*(_WORD *)result;
    v32 = *(float *)(a3 + 4) + v31;
    v39 = (double)*(_WORD *)(result + 2);
    v8 = *(float *)(a3 + 8) + v39;
    v9 = *(_WORD *)(a2 + 4);
    v40 = v8 - 7.0;
    v41 = *(_WORD *)(a2 + 4);
    v10 = v41 == (signed __int16)(v4 - v5 + 1) - 1;
    v11 = v39 + 7.0;
    v38 = v11 + 3.0;
    v37 = v40 - 3.0;
    v12 = v38;
    v33 = v37 - v38;
    if ( !v9 )
      v6 = -12566464;
    if ( v10 )
      v7 = -12566464;
    v35 = (double)v5 / (double)v4 * v33;
    if ( v35 > 3.0 )
      v13 = v35;
    else
      v13 = (float)3.0;
    v14 = v13;
    v34 = (v33 - v13) * (double)v41 / (double)((signed __int16)(v4 - v5 + 1) - 1) + v12;
    if ( v9 == 0 )
    {
      v16 = 1.0;
    }
    else
    {
      v15 = v12 + 1.0;
      v16 = 1.0;
      v17 = v15;
      if ( v17 >= (double)v34 )
        v34 = v15;
    }
    v36 = v14 + v34;
    if ( !v10 )
    {
      v18 = v37 - v16;
      if ( v18 <= (double)v36 )
        v36 = v37 - v16;
    }
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    j_gdi_pvg_color_u32(v6);
    v43 = v31;
    v44 = v39;
    v42 = 0;
    v45 = v32 - v31;
    v46 = 7.0;
    v47 = 0.0;
    v48 = 0.0;
    sub_10038760(5u, (int)&v42);
    j_gdi_pvg_color_u32(v7);
    v44 = v40;
    v42 = 2;
    sub_10038760(5u, (int)&v42);
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-1);
    sub_10015960(v31, v38);
    sub_10015960(v32, v38);
    sub_10015960(v32, v37);
    sub_10015960(v31, v37);
    j_gdi_pvg_end(v30);
    sub_10038660(9, v31, v38, v32, v37, -8355712);
    j_gdi_pvg_begin(72);
    j_gdi_pvg_color_u32(-8355712);
    sub_10015960(v31, v34);
    sub_10015960(v32, v34);
    sub_10015960(v32, v36);
    sub_10015960(v31, v36);
    j_gdi_pvg_end(LODWORD(v19));
    sub_10015770(1.0);
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-12566464);
    sub_10015960(v31, v36);
    sub_10015960(v31, v34);
    sub_10015960(v32, v34);
    j_gdi_pvg_end(LODWORD(v20));
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-14671840);
    v21 = v34 + 1.0;
    sub_10015960(v32, v21);
    sub_10015960(v32, v36);
    v22 = v31 + 1.0;
    sub_10015960(v22, v36);
    j_gdi_pvg_end(LODWORD(v23));
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-1);
    v24 = v36 - 1.0;
    sub_10015960(v22, v24);
    sub_10015960(v22, v21);
    v25 = v32 - 1.0;
    sub_10015960(v25, v21);
    j_gdi_pvg_end(LODWORD(v26));
    j_gdi_pvg_begin(67);
    j_gdi_pvg_color_u32(-12566464);
    v27 = v34 + 2.0;
    sub_10015960(v25, v27);
    sub_10015960(v25, v24);
    v28 = v31 + 2.0;
    sub_10015960(v28, v24);
    j_gdi_pvg_end(LODWORD(v29));
    result = j_gdi_pvg_disable(35);
  }
  return result;
}
// 10028240: could not find valid save-restore pair for ebp
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (10028710) --------------------------------------------------------
char __usercall sub_10028710@<al>(int a1@<ebp>, int a2, int a3, int a4, int a5, _WORD *a6)
{
  char result; // al@1

  result = 1;
  if ( *a6 == -32648 )
  {
    sub_10028240(a4, a5, a3, a1);
    result = 2;
  }
  return result;
}

//----- (10028740) --------------------------------------------------------
char __usercall sub_10028740@<al>(int a1@<esi>, int a2, int a3, int a4, int a5, _WORD *a6)
{
  char result; // al@3
  signed int v7; // ecx@4
  signed int v8; // edx@4
  signed int v9; // eax@4
  float v10; // ST1C_4@5
  float v11; // ST20_4@5
  double v12; // st7@5
  float v13; // ST0C_4@7
  float v14; // [sp+4h] [bp-24h]@5
  int v15; // [sp+8h] [bp-20h]@7
  float v16; // [sp+Ch] [bp-1Ch]@4
  float v17; // [sp+10h] [bp-18h]@4
  float v18; // [sp+14h] [bp-14h]@4
  float v19; // [sp+18h] [bp-10h]@4
  float v20; // [sp+1Ch] [bp-Ch]@4
  float v21; // [sp+20h] [bp-8h]@4
  float v22; // [sp+24h] [bp-4h]@4
  float v23; // [sp+3Ch] [bp+14h]@4

  if ( *a6 == 32802 || *a6 == 32888 )
  {
    v7 = *(_WORD *)(a4 + 2);
    v8 = *(_WORD *)a4;
    v16 = *(float *)(a3 + 20) + (double)v7;
    v18 = (double)v8;
    v23 = *(float *)(a3 + 16) + (double)v8;
    v17 = (double)v7;
    v22 = v16 - *(float *)(a3 + 24);
    v20 = *(float *)(a3 + 24) + v18;
    v21 = v23 - *(float *)(a3 + 24);
    v19 = *(float *)(a3 + 24) + v17;
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    v9 = sub_10047D20(*(_DWORD *)(a3 + 8));
    j_gdi_pvg_color_u32(v9);
    if ( 1.0 == *(float *)(a3 + 24) )
    {
      j_gdi_pvg_begin(66);
      v10 = v17 + 0.5;
      v11 = v18 + 0.5;
      sub_10015960(v11, v10);
      sub_10015960(v23, v10);
      sub_10015960(v23, v16);
      v14 = v16;
      v12 = v11;
    }
    else
    {
      j_gdi_pvg_begin(73);
      sub_10015960(v18, v17);
      sub_10015960(v20, v19);
      sub_10015960(v23, v17);
      sub_10015960(v21, v19);
      sub_10015960(v23, v16);
      sub_10015960(v21, v22);
      sub_10015960(v18, v16);
      sub_10015960(v20, v22);
      sub_10015960(v18, v17);
      v14 = v19;
      v12 = v20;
    }
    v13 = v12;
    sub_10015960(v13, v14);
    j_gdi_pvg_end(a1);
    if ( !(*(_BYTE *)(a3 + 4) & 0x10) )
    {
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(*(_DWORD *)(a3 + 12));
      sub_10015960(v20, v19);
      sub_10015960(v21, v19);
      sub_10015960(v21, v22);
      sub_10015960(v20, v22);
      j_gdi_pvg_end(v15);
    }
    j_gdi_pvg_disable(35);
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 10028740: could not find valid save-restore pair for esi
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (100289C0) --------------------------------------------------------
BOOL __usercall sub_100289C0@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edi@1

  v2 = a1 + 24 * *(_DWORD *)(a2 + 32) + 28;
  return strncmp((const char *)a2, (const char *)(a2 + 8), 8u) || *(_DWORD *)(v2 + 12) != *(_DWORD *)(a2 + 16);
}

//----- (10028A00) --------------------------------------------------------
int __usercall sub_10028A00@<eax>(int result@<eax>)
{
  float *v1; // ecx@1

  v1 = (float *)(dword_102D2B4C + 9008);
  *(float *)(result + 49844) = *(float *)(dword_102D2B4C + 9008);
  *(float *)(result + 49880) = *v1;
  *(float *)(result + 49916) = *(float *)(dword_102D2B4C + 9012);
  *(float *)(result + 49952) = *(float *)(dword_102D2B4C + 9016);
  *(float *)(result + 49988) = *(float *)(dword_102D2B4C + 9020);
  *(float *)(result + 50024) = *(float *)(dword_102D2B4C + 9024);
  *(float *)(result + 50060) = *(float *)(dword_102D2B4C + 9028);
  *(float *)(result + 50096) = *(float *)(dword_102D2B4C + 9032);
  *(float *)(result + 50132) = *(float *)(dword_102D2B4C + 9036);
  *(float *)(result + 50168) = *(float *)(dword_102D2B4C + 9040);
  *(float *)(result + 50204) = *(float *)(dword_102D2B4C + 9044);
  *(float *)(result + 50240) = *(float *)(dword_102D2B4C + 9172);
  *(float *)(result + 50276) = *(float *)(dword_102D2B4C + 9176);
  *(float *)(result + 50312) = *(float *)(dword_102D2B4C + 9180);
  return result;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10028B00) --------------------------------------------------------
int __usercall sub_10028B00@<eax>(int result@<eax>)
{
  float *v1; // ecx@1

  v1 = (float *)(dword_102D2B4C + 7204);
  *(float *)(result + 49844) = *(float *)(dword_102D2B4C + 7204);
  *(float *)(result + 49880) = *v1;
  *(float *)(result + 49916) = *(float *)(dword_102D2B4C + 7208);
  *(float *)(result + 49952) = *(float *)(dword_102D2B4C + 7212);
  *(float *)(result + 49988) = *(float *)(dword_102D2B4C + 7216);
  *(float *)(result + 50024) = *(float *)(dword_102D2B4C + 7220);
  *(float *)(result + 50060) = *(float *)(dword_102D2B4C + 7224);
  *(float *)(result + 50096) = *(float *)(dword_102D2B4C + 7228);
  *(float *)(result + 50132) = *(float *)(dword_102D2B4C + 7232);
  *(float *)(result + 50168) = *(float *)(dword_102D2B4C + 7236);
  *(float *)(result + 50204) = *(float *)(dword_102D2B4C + 7240);
  *(float *)(result + 50240) = *(float *)(dword_102D2B4C + 7368);
  *(float *)(result + 50276) = *(float *)(dword_102D2B4C + 7372);
  *(float *)(result + 50312) = *(float *)(dword_102D2B4C + 7376);
  return result;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10028C00) --------------------------------------------------------
#error "10028C00: function frame is wrong (funcsize=0)"

//----- (10029950) --------------------------------------------------------
int __usercall sub_10029950@<eax>(int a1@<ebx>, int a2@<edi>, int *a3)
{
  double v3; // st7@1
  int v4; // esi@1
  int v5; // ST24_4@1
  double v6; // ST5C_8@1
  float v7; // ST2C_4@1
  double v8; // ST64_8@1
  float v9; // ST28_4@1
  float v10; // ST44_4@1
  double v11; // st7@1
  float v12; // ST3C_4@1
  float v13; // ST54_4@1
  float v14; // ST50_4@1
  double v15; // st7@1
  float v16; // ST54_4@1
  double v17; // st7@1
  double v18; // st6@1
  double v19; // st7@1
  double v20; // st6@1
  float v21; // ST5C_4@4
  float v22; // ST44_4@1
  float v23; // ST44_4@1
  float v24; // ST3C_4@1
  int v25; // esi@1
  int v26; // ST24_4@3
  float v27; // ST54_4@3
  float v28; // ST54_4@3
  int v29; // esi@4
  float v30; // ST54_4@4
  float v31; // ST54_4@4
  float v32; // ST54_4@4
  float v33; // ST04_4@4
  float v34; // ST54_4@4
  int v35; // esi@4
  float v36; // ST54_4@4
  float v37; // ST54_4@4
  int v38; // ST24_4@6
  float v39; // ST5C_4@6
  float v40; // ST5C_4@6
  int v41; // esi@7
  float v42; // ST5C_4@7
  float v43; // ST5C_4@7
  float v44; // ST04_4@7
  float v45; // ST5C_4@7
  float v46; // ST5C_4@7
  float v47; // ST5C_4@7
  float v48; // ST5C_4@7
  float v49; // ST5C_4@7
  float v50; // ST5C_4@7
  float v51; // ST5C_4@7
  float v52; // ST5C_4@7
  float v53; // ST5C_4@7
  float v54; // ST04_4@7
  float v55; // ST5C_4@7
  float v56; // ST5C_4@7
  float v57; // ST04_4@7
  float v58; // ST5C_4@7
  int v59; // esi@7
  long double v60; // st7@7
  float v61; // ST5C_4@9
  float v62; // ST5C_4@9
  float v63; // ST04_4@9
  float v64; // ST5C_4@9
  float v65; // ST5C_4@9
  float v66; // ST5C_4@10
  float v67; // ST5C_4@10
  float v68; // ST04_4@10
  float v69; // ST5C_4@10
  float v70; // ST5C_4@10
  int v71; // esi@10
  long double v72; // st7@10
  float v73; // ST5C_4@12
  float v74; // ST5C_4@12
  float v75; // ST04_4@12
  float v76; // ST5C_4@12
  float v77; // ST5C_4@12
  float v78; // ST5C_4@13
  float v79; // ST04_4@13
  float v80; // ST5C_4@13
  int result; // eax@13
  int v82; // esi@13
  int v83; // [sp+24h] [bp-50h]@2
  int v84; // [sp+24h] [bp-50h]@5
  float v85; // [sp+28h] [bp-4Ch]@1
  float v86; // [sp+28h] [bp-4Ch]@4
  float v87; // [sp+2Ch] [bp-48h]@1
  float v88; // [sp+2Ch] [bp-48h]@4
  float v89; // [sp+34h] [bp-40h]@1
  float v90; // [sp+38h] [bp-3Ch]@1
  int v91; // [sp+3Ch] [bp-38h]@8
  int v92; // [sp+3Ch] [bp-38h]@11
  long double v93; // [sp+44h] [bp-30h]@1
  double v94; // [sp+44h] [bp-30h]@4
  double v95; // [sp+44h] [bp-30h]@7
  long double v96; // [sp+44h] [bp-30h]@10
  float v97; // [sp+50h] [bp-24h]@1
  double v98; // [sp+54h] [bp-20h]@4
  double v99; // [sp+64h] [bp-10h]@4
  double v100; // [sp+6Ch] [bp-8h]@4

  v3 = *(float *)(a2 + 51652) - 1.0;
  v4 = *a3;
  *(_DWORD *)(a2 + 49188) = 68;
  *(float *)&v5 = v3;
  *(_DWORD *)(a2 + 49192) = v4;
  v6 = *(float *)(a2 + 20) - *(float *)(a2 + 8);
  v7 = v6;
  v8 = *(float *)(a2 + 24) - *(float *)(a2 + 12);
  v9 = v8;
  v90 = *(float *)(a2 + 12);
  v89 = v90 - *(float *)(a2 + 4) + *(float *)(a2 + 16);
  v10 = sqrt(v9 * v9 + v7 * v7);
  v11 = v90 * v90;
  v12 = (v11 - v89 * v89 + v10 * v10) / (v10 + v10);
  v13 = sqrt(v11 - v12 * v12);
  v14 = v12 * v7 / v10 + *(float *)(a2 + 8);
  v87 = v14 - v8 * v13 / v10;
  v15 = v13;
  v16 = v12 * v9 / v10 + v90;
  v85 = v16 + v15 * v6 / v10;
  v17 = v85 - v90;
  v18 = v87 - *(float *)(a2 + 8);
  sub_10072A6A(v17);
  v97 = v17 * 180.0 / 3.1415926535898 - 90.0;
  v19 = v85 - *(float *)(a2 + 24);
  v20 = v87 - *(float *)(a2 + 20);
  sub_10072A6A(v19);
  sub_100165C0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 8), 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, *(float *)(a2 + 51656), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 20), *(float *)(a2 + 51656), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, *(float *)(a2 + 51656), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(v87, v85, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, 41.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  v22 = *(float *)&v5 + 1.0;
  sub_100165C0(v22, 31.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(v22, 31.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  v23 = *(float *)&v5 + 3.0;
  sub_100165C0(v23, 24.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(v23, 24.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  v24 = *(float *)&v5 + 4.0;
  sub_100165C0(v24, 14.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(*(float *)&v5, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(v24, 14.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4++);
  sub_100165C0(v24, 0.0, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v4);
  v25 = v4 + 1;
  v93 = (v97 + 90.0) * 0.01745329251994333;
  if ( v93 < 4.7123889803847 )
  {
    v83 = a1 + 24 * v25;
    do
    {
      sub_100165C0(v87, v85, 0.0, 0.0, 0.0, -14671840, v83);
      v26 = v83 + 24;
      sub_100165C0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, v26);
      v26 += 24;
      v27 = cos(v93);
      v87 = v27 * v90 + *(float *)(a2 + 8);
      v28 = sin(v93);
      v85 = v28 * v90 + *(float *)(a2 + 12);
      sub_100165C0(v87, v85, 0.0, 0.0, 0.0, -14671840, v26);
      v83 = v26 + 24;
      v25 += 3;
      v93 = v93 + 0.08726646259971667;
    }
    while ( v93 < 4.7123889803847 );
  }
  sub_100165C0(v87, v85, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v25);
  v29 = v25 + 1;
  sub_100165C0(*(float *)(a2 + 8), *(float *)(a2 + 12), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v29++);
  v30 = sin(4.7123889803847);
  v99 = v30 * v90;
  v31 = cos(4.7123889803847);
  v100 = v31 * v90;
  v32 = *(float *)(a2 + 12) + v99;
  v33 = v32;
  v34 = v100 + *(float *)(a2 + 8);
  sub_100165C0(v34, v33, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v29);
  v94 = 1.5707963267949;
  v35 = v29 + 1;
  v36 = cos(1.5707963267949);
  v88 = v36 * v89 + *(float *)(a2 + 20);
  v37 = sin(1.5707963267949);
  v86 = v37 * v89 + *(float *)(a2 + 24);
  v21 = v19 * 180.0 / 3.1415926535898 - 90.0;
  v98 = (v21 + 90.0) * 0.01745329251994333;
  if ( v98 > 1.5707963267949 )
  {
    v84 = a1 + 24 * v35;
    do
    {
      sub_100165C0(v88, v86, 0.0, 0.0, 0.0, -14671840, v84);
      v38 = v84 + 24;
      sub_100165C0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, v38);
      v38 += 24;
      v39 = cos(v94);
      v88 = v39 * v89 + *(float *)(a2 + 20);
      v40 = sin(v94);
      v86 = v40 * v89 + *(float *)(a2 + 24);
      sub_100165C0(v88, v86, 0.0, 0.0, 0.0, -14671840, v38);
      v84 = v38 + 24;
      v35 += 3;
      v94 = v94 + 0.08726646259971667;
    }
    while ( v94 < v98 );
  }
  sub_100165C0(v88, v86, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v35);
  v41 = v35 + 1;
  sub_100165C0(*(float *)(a2 + 20), *(float *)(a2 + 24), 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v42 = sin(v98);
  v43 = v42 * v89 + *(float *)(a2 + 24);
  v44 = v43;
  v45 = cos(v98);
  v46 = v45 * v89 + *(float *)(a2 + 20);
  sub_100165C0(v46, v44, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  *(_DWORD *)(a2 + 49196) = v41 - *(_DWORD *)(a2 + 49192);
  *(_DWORD *)(a2 + 49200) = 67;
  *(_DWORD *)(a2 + 49204) = v41;
  v47 = *(float *)(a2 + 8) - 1.5;
  sub_100165C0(v47, -0.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v48 = *(float *)(a2 + 51652) + 4.0 - 1.5;
  sub_100165C0(v48, -0.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v49 = *(float *)(a2 + 51652) + 4.0 - 1.5;
  sub_100165C0(v49, 13.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v50 = *(float *)(a2 + 51652) + 3.0 - 1.5;
  sub_100165C0(v50, 23.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v51 = *(float *)(a2 + 51652) + 1.0 - 1.5;
  sub_100165C0(v51, 30.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v52 = *(float *)(a2 + 51652) - 1.5;
  sub_100165C0(v52, 40.5, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v53 = *(float *)(a2 + 51656) - 0.5;
  v54 = v53;
  v55 = *(float *)(a2 + 51652) - 1.5;
  sub_100165C0(v55, v54, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41++);
  v56 = *(float *)(a2 + 51656) - 0.5;
  v57 = v56;
  v58 = *(float *)(a2 + 20) - 1.5;
  sub_100165C0(v58, v57, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v41);
  v59 = v41 + 1;
  v95 = 1.658062789394617;
  v60 = 1.658062789394617;
  if ( v98 > 1.658062789394617 )
  {
    v91 = a1 + 24 * v59;
    do
    {
      v61 = sin(v60);
      v62 = v61 * v89 + *(float *)(a2 + 24);
      v63 = v62;
      v64 = cos(v95);
      v65 = v64 * v89 + *(float *)(a2 + 20);
      sub_100165C0(v65, v63, 0.0, 0.0, 0.0, -14671840, v91);
      v91 += 24;
      v60 = v95 + 0.08726646259971667;
      ++v59;
      v95 = v60;
    }
    while ( v98 > v60 );
  }
  v66 = sin(v98);
  v67 = v66 * v89 + *(float *)(a2 + 24);
  v68 = v67;
  v69 = cos(v98);
  v70 = v69 * v89 + *(float *)(a2 + 20);
  sub_100165C0(v70, v68, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v59);
  v71 = v59 + 1;
  v72 = (v97 + 5.0 + 90.0) * 0.01745329251994333;
  v96 = v72;
  if ( v72 < 4.7123889803847 )
  {
    v92 = a1 + 24 * v71;
    do
    {
      v73 = sin(v72);
      v74 = v73 * v90 + *(float *)(a2 + 12);
      v75 = v74;
      v76 = cos(v96);
      v77 = v76 * v90 + *(float *)(a2 + 8);
      sub_100165C0(v77, v75, 0.0, 0.0, 0.0, -14671840, v92);
      v92 += 24;
      v72 = v96 + 0.08726646259971667;
      ++v71;
      v96 = v72;
    }
    while ( v72 < 4.7123889803847 );
  }
  v78 = *(float *)(a2 + 12) + v99;
  v79 = v78;
  v80 = *(float *)(a2 + 8) + v100;
  result = sub_100165C0(v80, v79, 0.0, 0.0, 0.0, -14671840, a1 + 24 * v71);
  v82 = v71 + 1;
  *(_DWORD *)(a2 + 49208) = v82 - *(_DWORD *)(a2 + 49204);
  *a3 = v82;
  return result;
}
// 10072A6A: using guessed type double __usercall sub_10072A6A@<st0>(double@<st0>);

//----- (1002AAB0) --------------------------------------------------------
int __usercall sub_1002AAB0@<eax>(int a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, _DWORD *a8)
{
  _DWORD *v8; // ebp@1
  int v9; // esi@1
  int v10; // eax@1
  float v11; // ST2C_4@1
  float v12; // ST24_4@1
  float v13; // ST28_4@1
  float v14; // ST38_4@1
  double v15; // ST48_8@1
  float v16; // ST34_4@1
  float v17; // ST38_4@1
  double v18; // ST58_8@1
  float v19; // ST30_4@1
  float v20; // ST3C_4@1
  double v21; // ST50_8@1
  float v22; // ST38_4@1
  float v23; // ST3C_4@1
  double v24; // ST3C_8@1
  float v25; // ST30_4@1
  int result; // eax@1
  float v27; // [sp+6Ch] [bp+Ch]@1
  float v28; // [sp+6Ch] [bp+Ch]@1
  float v29; // [sp+74h] [bp+14h]@1
  float v30; // [sp+74h] [bp+14h]@1
  float v31; // [sp+78h] [bp+18h]@1

  v8 = a8;
  v9 = *a8;
  v10 = a2 + 24 * *a8;
  v31 = a3 + a7;
  v11 = a4 + a7;
  v12 = a5 - a7;
  v13 = a6 - a7;
  sub_100165C0(v31, a4, 0.0, 0.0, 0.0, a1, v10);
  sub_100165C0(v12, a4, 0.0, 0.0, 0.0, a1, a2 + 24 * ++v9);
  ++v9;
  v14 = sin(1.0472);
  v15 = v14 * a7;
  v16 = v11 - v15;
  v17 = cos(1.0472);
  v18 = v17 * a7;
  v19 = v18 + v12;
  sub_100165C0(v19, v16, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v20 = sin(0.5236);
  v21 = v20 * a7;
  v22 = v11 - v21;
  v23 = cos(0.5236);
  v24 = v23 * a7;
  v29 = v24 + v12;
  sub_100165C0(v29, v22, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_100165C0(a5, v11, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_100165C0(a5, v13, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v27 = v13 + v15;
  sub_100165C0(v19, v27, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v25 = v13 + v21;
  sub_100165C0(v29, v25, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_100165C0(v12, a6, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_100165C0(v31, a6, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v30 = v31 - v18;
  sub_100165C0(v30, v27, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  v28 = v31 - v24;
  sub_100165C0(v28, v25, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_100165C0(a3, v13, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_100165C0(a3, v11, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_100165C0(v30, v16, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  sub_100165C0(v28, v22, 0.0, 0.0, 0.0, a1, a2 + 24 * v9++);
  result = sub_100165C0(v31, a4, 0.0, 0.0, 0.0, a1, a2 + 24 * v9);
  *v8 = v9 + 1;
  return result;
}

//----- (1002AF30) --------------------------------------------------------
int __usercall sub_1002AF30@<eax>(int a1@<ebx>, int a2, float a3, float a4, float a5, float a6, float a7, int *a8, int a9)
{
  int v9; // esi@1
  double v10; // st7@2
  int v11; // edi@2
  long double v12; // ST34_8@3
  float v13; // ST24_4@3
  float v14; // ST28_4@3
  float v15; // ST04_4@3
  int v16; // edi@3
  float v17; // ST04_4@3
  long double v18; // ST34_8@4
  float v19; // ST24_4@4
  float v20; // ST28_4@4
  float v21; // ST04_4@4
  int v22; // esi@4
  float v23; // ST04_4@4
  int result; // eax@4
  float v25; // [sp+2Ch] [bp-18h]@1
  float v26; // [sp+30h] [bp-14h]@1

  v9 = *a8;
  v26 = a5 - 5.0;
  *(_DWORD *)a2 = 69;
  *(_DWORD *)(a2 + 4) = v9;
  v25 = a6;
  if ( a7 > (double)a6 )
  {
    v10 = a6;
    v11 = a9 + 24 * v9;
    do
    {
      v12 = (v10 + 90.0) * 0.01745329251994333;
      v13 = sin(v12);
      v14 = cos(v12);
      *(float *)&v12 = v13 * a5 + a4;
      v15 = *(float *)&v12;
      *(float *)&v12 = a5 * v14 + a3;
      sub_100165C0(*(float *)&v12, v15, 0.0, 0.0, 0.0, a1, v11);
      v16 = v11 + 24;
      *(float *)&v12 = v13 * v26 + a4;
      v17 = *(float *)&v12;
      *(float *)&v12 = v26 * v14 + a3;
      sub_100165C0(*(float *)&v12, v17, 0.0, 0.0, 0.0, a1, v16);
      v9 += 2;
      v11 = v16 + 24;
      v25 = v25 + 5.0;
      v10 = v25;
    }
    while ( v25 < (double)a7 );
  }
  v18 = (a7 + 90.0) * 0.01745329251994333;
  v19 = sin(v18);
  v20 = cos(v18);
  *(float *)&v18 = v19 * a5 + a4;
  v21 = *(float *)&v18;
  *(float *)&v18 = a5 * v20 + a3;
  sub_100165C0(*(float *)&v18, v21, 0.0, 0.0, 0.0, a1, a9 + 24 * v9);
  v22 = v9 + 1;
  *(float *)&v18 = v19 * v26 + a4;
  v23 = *(float *)&v18;
  *(float *)&v18 = v26 * v20 + a3;
  sub_100165C0(*(float *)&v18, v23, 0.0, 0.0, 0.0, a1, a9 + 24 * v22);
  result = a2;
  *(_DWORD *)(a2 + 8) = ++v22 - *(_DWORD *)(a2 + 4);
  *a8 = v22;
  return result;
}

//----- (1002B160) --------------------------------------------------------
int __usercall sub_1002B160@<eax>(int a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, int a7)
{
  _DWORD *v7; // ebp@1
  int v8; // esi@1
  double v9; // ST24_8@1
  int v10; // ST18_4@1
  double v11; // ST2C_8@1
  int v12; // ecx@1
  int result; // eax@1
  float v14; // [sp+38h] [bp+4h]@1
  float v15; // [sp+3Ch] [bp+8h]@1
  float v16; // [sp+44h] [bp+10h]@1
  int v17; // [sp+48h] [bp+14h]@1

  v7 = (_DWORD *)a7;
  v8 = *(_DWORD *)a7;
  v9 = a6 * 0.5;
  v10 = a2 + 24 * *(_DWORD *)a7;
  *(float *)&v17 = a4 - v9;
  *(_DWORD *)a1 = 64;
  *(_DWORD *)(a1 + 4) = v8;
  v11 = 0.5 * a5;
  v16 = a3 - v11;
  sub_100165C0(v16, *(float *)&v17, 0.0, 0.0, 0.0, -65536, v10);
  ++v8;
  v15 = a4 + v9;
  v14 = a3 + v11;
  sub_100165C0(v14, v15, 0.0, 0.0, 0.0, -65536, a2 + 24 * v8++);
  sub_100165C0(v16, v15, 0.0, 0.0, 0.0, -65536, a2 + 24 * v8++);
  sub_100165C0(v14, *(float *)&v17, 0.0, 0.0, 0.0, -65536, a2 + 24 * v8++);
  v12 = v8 - *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 12) = 68;
  *(_DWORD *)(a1 + 8) = v12;
  *(_DWORD *)(a1 + 16) = v8;
  sub_100165C0(v16, *(float *)&v17, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  sub_100165C0(v16, v15, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  sub_100165C0(v14, *(float *)&v17, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  sub_100165C0(v14, *(float *)&v17, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  sub_100165C0(v16, v15, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  result = sub_100165C0(v14, v15, 0.0, 0.0, 0.0, 1090453504, a2 + 24 * v8++);
  *(_DWORD *)(a1 + 20) = v8 - *(_DWORD *)(a1 + 16);
  *v7 = v8;
  return result;
}

//----- (1002B400) --------------------------------------------------------
unsigned __int8 __usercall sub_1002B400@<al>(int a1@<ebx>, _DWORD *a2@<edi>, int a3, int a4, int a5, float a6, float a7, float a8, float a9)
{
  double v9; // st7@1
  int v10; // esi@1
  double v11; // st6@1
  double v12; // st5@1
  double v13; // st6@1
  char *v14; // esi@1
  double v15; // st6@1
  unsigned __int8 v16; // al@2
  bool v17; // zf@2
  char *v18; // ecx@2
  double v19; // st4@3
  unsigned __int8 result; // al@5
  int v21; // esi@8
  float v22; // ST08_4@8
  char *v23; // eax@8
  float v24; // [sp+24h] [bp-4h]@1
  int v25; // [sp+2Ch] [bp+4h]@2
  int v26; // [sp+2Ch] [bp+4h]@8
  int v27; // [sp+2Ch] [bp+4h]@8
  float v28; // [sp+38h] [bp+10h]@5
  float v29; // [sp+3Ch] [bp+14h]@1
  float v30; // [sp+40h] [bp+18h]@5
  float v31; // [sp+44h] [bp+1Ch]@1

  v24 = *(float *)a5;
  v9 = v24;
  v10 = *(_DWORD *)(a5 + 8);
  v11 = v24 * a9;
  v12 = a7;
  v29 = (double)(signed int)(a7 - *(float *)(v10 + 8200) * v24 + v11);
  v13 = v11 + v12 + *(float *)(v10 + 8204) * v24;
  v14 = (char *)a3;
  v31 = (double)(signed int)v13;
  v15 = 0.0;
  if ( a8 != 0.0 )
  {
    v16 = *(_BYTE *)a3;
    v17 = *(_BYTE *)a3 == 0;
    *(float *)&v25 = 0.0;
    v18 = v14;
    if ( !v17 )
    {
      do
      {
        ++v18;
        v19 = *(float *)(32 * v16 + *(_DWORD *)(a5 + 8) + 16);
        v16 = *v18;
        *(float *)&v25 = v19 * v9 + *(float *)&v25;
      }
      while ( *v18 );
    }
    a6 = a6 - a8 * *(float *)&v25;
  }
  v30 = *(float *)&v14;
  result = *v14;
  v28 = (double)(signed int)a6 + 0.5;
  if ( *v14 )
  {
    while ( 1 )
    {
      v21 = *(_DWORD *)(a5 + 8) + 32 * result;
      *(float *)&v26 = v9 * *(float *)(v21 + 16);
      v22 = v15;
      sub_100165C0(v28, v31, v22, *(float *)v21, *(float *)(v21 + 12), a4, a1 + 24 * *a2);
      sub_100165C0(v28, v29, 0.0, *(float *)v21, *(float *)(v21 + 8), a4, a1 + 24 * (*a2 + 1));
      *(float *)&v27 = *(float *)&v26 + v28;
      sub_100165C0(*(float *)&v27, v31, 0.0, *(float *)(v21 + 4), *(float *)(v21 + 12), a4, a1 + 24 * (*a2 + 2));
      sub_100165C0(*(float *)&v27, v31, 0.0, *(float *)(v21 + 4), *(float *)(v21 + 12), a4, a1 + 24 * (*a2 + 3));
      sub_100165C0(v28, v29, 0.0, *(float *)v21, *(float *)(v21 + 8), a4, a1 + 24 * (*a2 + 4));
      sub_100165C0(*(float *)&v27, v29, 0.0, *(float *)(v21 + 4), *(float *)(v21 + 8), a4, a1 + 24 * (*a2 + 5));
      v28 = *(float *)&v27;
      *a2 += 6;
      v23 = (char *)(LODWORD(v30) + 1);
      v30 = *(float *)&v23;
      result = *v23;
      if ( !result )
        break;
      v9 = v24;
      v15 = 0.0;
    }
  }
  return result;
}

//----- (1002B6A0) --------------------------------------------------------
bool __usercall sub_1002B6A0@<al>(int a1@<esi>)
{
  bool v1; // bl@1
  double v2; // st7@2
  float v4; // [sp+4h] [bp-10h]@1
  float v5; // [sp+8h] [bp-Ch]@1
  float v6; // [sp+Ch] [bp-8h]@1
  float v7; // [sp+10h] [bp-4h]@4

  v5 = 9.8999998e24;
  v4 = 9.8999998e24;
  v1 = 0;
  if ( sub_10025520(&v6) )
  {
    v2 = -40.0;
    if ( v6 > -40.0 )
      v2 = v6;
    v5 = v2;
    v5 = sqrt((v5 + 273.0) / 288.0);
    v7 = *(float *)(a1 + 51836);
    if ( v7 != 9.8999998e24 )
    {
      v4 = v7 / v5;
      v1 = *(float *)(dword_102D2B4C + 7404) < (double)v4 && *(float *)(dword_102D2B4C + 7396) > (double)v6;
    }
  }
  sub_10016450(9010, (int)&v4, 4);
  *(float *)(a1 + 51716) = v5;
  return v1;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1002B790) --------------------------------------------------------
double __usercall sub_1002B790@<st0>(int a1@<eax>, float a2@<ecx>)
{
  bool v2; // zf@1
  float v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  v2 = *(_BYTE *)(a1 + 51615) == 0;
  v4 = *(float *)(dword_102D2B4C + 7368);
  if ( !v2 )
    v4 = *(float *)(a1 + 51716) * *(float *)(dword_102D2B4C + 7400);
  sub_10016450(41110, (int)&v4, 4);
  return v4;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1002B7E0) --------------------------------------------------------
int __usercall sub_1002B7E0@<eax>(int a1@<edx>, float *a2@<ecx>, int a3@<ebx>, float a4, int a5)
{
  double v5; // st7@1
  float *v6; // ebp@1
  float *v7; // esi@1
  int v8; // edi@1
  double v9; // st7@2
  float *v10; // ecx@5
  double v11; // st5@6
  float v13; // [sp+4h] [bp+4h]@10

  v5 = a4;
  v6 = &a2[9 * a3 - 9];
  v7 = a2;
  v8 = 1;
  if ( a2[a1 + 4] < (double)a4 )
  {
    if ( v6[a1 + 4] > v5 )
    {
      v10 = a2 + 9;
      if ( v10[a1 + 4] < v5 )
      {
        do
        {
          v11 = v10[a1 + 13];
          v7 = v10;
          v10 += 9;
          ++v8;
        }
        while ( v11 < v5 );
      }
      if ( !a5 )
        return v8;
      v9 = (v5 - v7[a1 + 4]) / (v10[a1 + 4] - v7[a1 + 4]) * (*v10 - *v7) + *v7;
    }
    else
    {
      v8 = a3 - 1;
      v9 = *v6;
    }
  }
  else
  {
    v8 = 0;
    v9 = *a2;
  }
  if ( a5 )
  {
    v13 = v9;
    *(float *)a5 = v13;
    return v8;
  }
  return v8;
}

//----- (1002B890) --------------------------------------------------------
char __usercall sub_1002B890@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  char result; // al@1
  bool v4; // zf@1
  bool v5; // sf@1
  signed int v6; // ecx@2
  int v7; // [sp+4h] [bp-4h]@2

  v2 = *(_DWORD *)(a1 + 16);
  result = **(_WORD **)(a2 + 52) == -32747;
  v4 = *(_DWORD *)(v2 + 51596) == 0;
  v5 = *(_DWORD *)(v2 + 51596) < 0;
  *(_BYTE *)(v2 + 51601) = result;
  if ( !v5 && !v4 )
  {
    *(_DWORD *)(v2 + 51448) = -256;
    v6 = *(_DWORD *)(v2 + 51596) - sub_100160A0();
    v7 = v6;
    if ( v6 < 0 )
    {
      sub_10038570((char *)(v2 + 51432), 8u, "00:00");
      *(_BYTE *)(v2 + 51600) = 1;
      *(_DWORD *)(v2 + 51448) = -65536;
      v7 = -1;
      result = sub_10016450(9212, (int)&v7, 4);
      *(_BYTE *)(v2 + 49825) = 1;
    }
    else
    {
      sub_10038570((char *)(v2 + 51432), 8u, "%02d:%02d", v6 / 60000, v6 / 1000 % 60);
      if ( v7 < 30000 )
        *(_BYTE *)(v2 + 51600) = 1;
      result = sub_10016450(9212, (int)&v7, 4);
      *(_BYTE *)(v2 + 49825) = 1;
    }
  }
  return result;
}

//----- (1002B990) --------------------------------------------------------
signed int __usercall sub_1002B990@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>)
{
  int v3; // esi@1
  unsigned __int16 v4; // cx@1
  double v5; // st7@2
  double v6; // st7@2
  double v7; // st6@2
  bool v8; // c0@4
  double v9; // st7@4
  char v10; // al@7
  double v11; // st7@7
  bool v12; // c3@7
  bool v13; // al@11
  bool v14; // zf@13
  signed int result; // eax@15
  float v16; // [sp+14h] [bp-10h]@1
  float v17; // [sp+18h] [bp-Ch]@2
  float v18; // [sp+1Ch] [bp-8h]@1
  float v19; // [sp+20h] [bp-4h]@1

  *(float *)(a3 + 56 * a2 + 51720) = 9.8999998e24;
  v3 = a3 + 56 * a2 + 51720;
  *(_BYTE *)(a3 + 56 * a2 + 51742) = 0;
  v4 = *(_WORD *)(a3 + 56 * a2 + 51740);
  v19 = *(float *)(dword_102D2B4C + 28 * a1 + 20484);
  v18 = *(float *)(dword_102D2B4C + 28 * a1 + 20480);
  if ( sub_10040700(v4, &v16) )
  {
    v5 = v16;
    *(float *)(v3 + 12) = v16;
    v17 = v5 * *(float *)(v3 + 16);
    v6 = v17;
    *(float *)v3 = v17;
    v7 = v18;
    if ( v18 <= v6 )
    {
      v8 = v19 < v6;
      v9 = v19;
      if ( v8 )
      {
        *(float *)v3 = v19;
        *(float *)(v3 + 12) = v9;
      }
    }
    else
    {
      *(float *)v3 = v18;
      *(float *)(v3 + 12) = v7;
    }
  }
  else
  {
    *(float *)(v3 + 12) = 9.8999998e24;
  }
  *(_BYTE *)(v3 + 22) = sub_1003E540(v3 + 24);
  v10 = sub_1003E540(v3 + 40);
  v11 = 9.8999998e24;
  v12 = 9.8999998e24 == *(float *)v3;
  *(_BYTE *)(v3 + 23) = v10;
  if ( !v12 )
    v11 = sub_10048270(*(float *)v3, *(float *)(v3 + 4), 0, *(float *)(v3 + 8));
  *(float *)(v3 + 4) = v11;
  v13 = *(_BYTE *)(a3 + 51607) || *(_BYTE *)(v3 + 22);
  v14 = *(_BYTE *)(a3 + 51608) == 0;
  *(_BYTE *)(a3 + 51607) = v13;
  if ( v14 || *(_BYTE *)(v3 + 23) )
  {
    result = 0;
    *(_BYTE *)(a3 + 51608) = 0;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a3 + 51608) = 1;
  }
  return result;
}
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (1002BAE0) --------------------------------------------------------
unsigned int __usercall sub_1002BAE0@<eax>(int a1@<edx>, int a2@<edi>, int a3@<esi>)
{
  unsigned int result; // eax@1
  _DWORD *v4; // ecx@1

  result = a2 + 24 * *(_DWORD *)(a1 + 4) + 28;
  v4 = (_DWORD *)(a2 + 24 * *(_DWORD *)(a1 + 4) + 40);
  if ( *v4 != a3 )
  {
    result = 0;
    if ( *(_DWORD *)(a1 + 8) )
    {
      do
      {
        *v4 = a3;
        ++result;
        v4 += 6;
      }
      while ( result < *(_DWORD *)(a1 + 8) );
    }
    *(_BYTE *)(a2 + 49824) = 1;
  }
  return result;
}

//----- (1002BB20) --------------------------------------------------------
void __usercall sub_1002BB20(void *a1@<ecx>, int a2@<esi>)
{
  void *v2; // ecx@1
  float v3; // ST00_4@8
  double v4; // st7@8
  int v5; // [sp+10h] [bp-8h]@8
  int v6; // [sp+14h] [bp-4h]@8

  *(_BYTE *)(a2 + 51604) = 0;
  if ( !(sub_100405D0(a1) & 0xC) || sub_10025D10(v2) == 1 )
    *(_BYTE *)(a2 + 51572) = 0;
  if ( *(_BYTE *)(a2 + 51572)
    && 9.8999998e24 != *(float *)(a2 + 51584)
    && 9.8999998e24 != *(float *)(a2 + 51576)
    && 9.8999998e24 != *(float *)(a2 + 51580) )
  {
    v3 = *(float *)(a2 + 51584);
    *(_BYTE *)(a2 + 51604) = 1;
    sub_1002B7E0(1, (float *)(a2 + 49828), 14, v3, (int)&v6);
    sub_1002B7E0(2, (float *)(a2 + 49828), 14, *(float *)(a2 + 51576), (int)&v5);
    v4 = *(float *)&v6;
    if ( *(float *)&v5 >= (double)*(float *)&v6 )
      v4 = *(float *)&v5;
    *(float *)&v6 = v4;
    sub_1002B7E0(0, (float *)(a2 + 49828), 14, *(float *)(a2 + 51580), (int)&v5);
    if ( *(float *)&v5 >= (double)*(float *)&v6 )
      *(float *)(a2 + 51592) = *(float *)&v5;
    else
      *(float *)(a2 + 51592) = *(float *)&v6;
  }
}

//----- (1002BC50) --------------------------------------------------------
unsigned int __usercall sub_1002BC50@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // edi@1
  int v3; // eax@1

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 16);
  if ( v3 == -256 )
  {
    *(_DWORD *)(a2 + 20) = -16777216;
    *(_DWORD *)(a2 + 24) = -256;
  }
  else if ( v3 == -65536 )
  {
    *(_DWORD *)(a2 + 20) = -1;
    *(_DWORD *)(a2 + 24) = -65536;
  }
  else
  {
    *(_DWORD *)(a2 + 20) = v3;
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(v2 + 51488);
  }
  sub_1002BAE0(a2 + 28, v2, *(_DWORD *)(a2 + 20));
  return sub_1002BAE0(a2 + 40, v2, *(_DWORD *)(a2 + 24));
}

//----- (1002BCB0) --------------------------------------------------------
int *__cdecl sub_1002BCB0(int a1, int *a2)
{
  int v2; // ebp@1
  int v3; // ebx@1
  int v4; // edi@3
  float v5; // ST38_4@4
  float v6; // ST1C_4@4
  float v7; // ST38_4@4
  int v8; // edi@7
  float v9; // ST38_4@8
  float v10; // ST1C_4@8
  float v11; // ST38_4@8
  int v12; // edi@11
  float v13; // ST38_4@12
  float v14; // ST1C_4@12
  float v15; // ST38_4@12
  int v16; // edi@15
  float v17; // ST38_4@16
  int v18; // edi@19
  float v19; // ST38_4@20
  int *result; // eax@21

  v2 = a1;
  v3 = a1 + 28;
  if ( a2 )
    *(_DWORD *)(a1 + 51256) = *a2;
  v4 = *(_DWORD *)(v2 + 51256);
  a1 = *(_DWORD *)(v2 + 51256);
  if ( (unsigned __int8)sub_100289C0(v2, v2 + 51224) )
  {
    v5 = 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       - (*(float *)(v2 + 51668)
        + 6.0);
    v6 = v5;
    v7 = *(float *)(v2 + 51652) - 8.5;
    sub_1002B400(v3, &a1, v2 + 51224, *(_DWORD *)(v2 + 51244), v2 + 51640, v7, v6, 1.0, 0.5);
    v4 = a1;
    *(_DWORD *)(v2 + 51260) = a1 - *(_DWORD *)(v2 + 51256);
    sub_10038450(v2 + 51232, (_BYTE *)(v2 + 51224), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  if ( a2 )
    *(_DWORD *)(v2 + 51308) = v4;
  v8 = *(_DWORD *)(v2 + 51308);
  a1 = *(_DWORD *)(v2 + 51308);
  if ( (unsigned __int8)sub_100289C0(v2, v2 + 51276) )
  {
    v9 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2));
    v10 = v9;
    v11 = *(float *)(v2 + 51652) - 8.5;
    sub_1002B400(v3, &a1, v2 + 51276, *(_DWORD *)(v2 + 51296), v2 + 51640, v11, v10, 1.0, 0.5);
    v8 = a1;
    *(_DWORD *)(v2 + 51312) = a1 - *(_DWORD *)(v2 + 51308);
    sub_10038450(v2 + 51284, (_BYTE *)(v2 + 51276), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  if ( a2 )
    *(_DWORD *)(v2 + 51360) = v8;
  v12 = *(_DWORD *)(v2 + 51360);
  a1 = *(_DWORD *)(v2 + 51360);
  if ( (unsigned __int8)sub_100289C0(v2, v2 + 51328) )
  {
    v13 = *(float *)(v2 + 51668)
        + 6.0
        + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                                * ((signed int)(*(float *)(v2 + 51664)
                                                                                              + 4.0)
                                                                                 / 2))
                                                                       * 0.5
                                                                       + 2.0)
                                                  + 0.5
                                                  + *(float *)(v2 + 51664) * 1.5)
                             + 0.5
                             + *(float *)(v2 + 51664)
                             - 1.0)
        + 0.5
        + 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2));
    v14 = v13;
    v15 = *(float *)(v2 + 51652) - 8.5;
    sub_1002B400(v3, &a1, v2 + 51328, *(_DWORD *)(v2 + 51348), v2 + 51640, v15, v14, 1.0, 0.5);
    v12 = a1;
    *(_DWORD *)(v2 + 51364) = a1 - *(_DWORD *)(v2 + 51360);
    sub_10038450(v2 + 51336, (_BYTE *)(v2 + 51328), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  if ( a2 )
    *(_DWORD *)(v2 + 51412) = v12;
  v16 = *(_DWORD *)(v2 + 51412);
  a1 = *(_DWORD *)(v2 + 51412);
  if ( (unsigned __int8)sub_100289C0(v2, v2 + 51380) )
  {
    v17 = *(float *)(v2 + 51652) - 4.5 - (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) * 0.5;
    sub_1002B400(v3, &a1, v2 + 51380, *(_DWORD *)(v2 + 51400), v2 + 51640, v17, *(float *)(v2 + 24), 0.5, 0.5);
    v16 = a1;
    *(_DWORD *)(v2 + 51416) = a1 - *(_DWORD *)(v2 + 51412);
    sub_10038450(v2 + 51388, (_BYTE *)(v2 + 51380), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  if ( a2 )
    *(_DWORD *)(v2 + 51464) = v16;
  v18 = *(_DWORD *)(v2 + 51464);
  a1 = *(_DWORD *)(v2 + 51464);
  if ( (unsigned __int8)sub_100289C0(v2, v2 + 51432) )
  {
    v19 = *(float *)(v2 + 8) - *(float *)(v2 + 4) * 0.4000000059604645;
    sub_1002B400(v3, &a1, v2 + 51432, *(_DWORD *)(v2 + 51448), v2 + 51640, v19, *(float *)(v2 + 12), 0.5, 0.5);
    v18 = a1;
    *(_DWORD *)(v2 + 51468) = a1 - *(_DWORD *)(v2 + 51464);
    sub_10038450(v2 + 51440, (_BYTE *)(v2 + 51432), 8);
    *(_BYTE *)(v2 + 49824) = 1;
  }
  result = a2;
  if ( a2 )
    *a2 = v18;
  return result;
}

//----- (1002C250) --------------------------------------------------------
int __usercall sub_1002C250@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, float *a4@<edi>, int a5, int a6, _DWORD *a7)
{
  int v7; // ebx@1
  int v8; // eax@1
  int v9; // edx@1
  int v10; // esi@1
  int v11; // eax@1

  v7 = a3;
  v8 = sub_1002B7E0(a2, a4, a3, *(float *)(a5 + 4), a1);
  v10 = v8;
  v11 = (int)&a4[9 * v8];
  if ( *(_BYTE *)(v11 + 32) & 1 )
    *a7 = -65536;
  else
    *a7 = *(_DWORD *)(v11 + 8);
  sub_1002B7E0(v9, a4, v7, *(float *)a5, a6);
  return v10;
}

//----- (1002C2B0) --------------------------------------------------------
char __usercall sub_1002C2B0@<al>(int a1@<eax>, int a2)
{
  int v2; // ebp@1
  double v3; // st7@1
  double v4; // st7@2
  double v5; // st7@5
  double v6; // st7@10
  double v7; // st6@10
  double v8; // st4@10
  double v9; // st6@10
  double v10; // st4@10
  double v11; // st6@10
  double v12; // st5@10
  double v13; // st5@10
  double v14; // st7@10
  float v15; // ST44_4@10
  int v16; // eax@10
  double v17; // st7@10
  float v18; // ST44_4@10
  int v19; // eax@10
  double v20; // st7@10
  float v21; // ST44_4@10
  int v22; // eax@10
  int v23; // esi@10
  double v24; // st7@10
  double v25; // st7@12
  int v26; // edi@12
  double v27; // st5@13
  double v28; // st4@13
  float v29; // ST3C_4@13
  float v30; // ST38_4@13
  float v31; // ST34_4@13
  int v32; // ST44_4@14
  double v33; // st6@14
  int v34; // edi@14
  float v35; // ST30_4@14
  int v36; // ST44_4@14
  float v37; // ST30_4@14
  int v38; // ST44_4@14
  float v39; // ST30_4@14
  int v40; // ST44_4@14
  float v41; // ST30_4@14
  int v42; // ST44_4@14
  float v43; // ST30_4@14
  double v44; // st5@14
  float v45; // ST3C_4@14
  float v46; // ST38_4@14
  double v47; // st5@14
  float v48; // ST3C_4@14
  float v49; // ST38_4@14
  double v50; // st5@14
  float v51; // ST3C_4@14
  float v52; // ST38_4@14
  double v53; // st7@14
  float v54; // ST3C_4@14
  int v55; // edx@14
  float v56; // ST3C_4@14
  int v57; // eax@14
  float *v58; // edi@14
  float v59; // ST3C_4@16
  bool v60; // zf@17
  int v61; // eax@18
  float v62; // ST3C_4@18
  int v63; // eax@18
  float v64; // ST3C_4@18
  int v65; // eax@18
  float v66; // ST3C_4@18
  int v67; // eax@18
  float v68; // ST3C_4@18
  int v69; // eax@18
  int v70; // edi@18
  int v71; // ecx@18
  double v72; // st7@18
  int v73; // ST44_4@18
  int v74; // ST44_4@18
  int v75; // ST44_4@18
  int v76; // ST44_4@18
  int v77; // edi@18
  int v78; // edx@18
  double v79; // st7@18
  int v80; // ST44_4@18
  int v81; // ST44_4@18
  int v82; // ST44_4@18
  int v83; // ST44_4@18
  int v84; // edi@18
  int v85; // ST44_4@18
  double v86; // st6@18
  int v87; // ST44_4@18
  int v88; // ST44_4@18
  int v89; // ST44_4@18
  int v90; // ST44_4@18
  int v91; // ST44_4@18
  float v92; // ST3C_4@18
  int v93; // edi@18
  int v94; // ST44_4@18
  int v95; // ST44_4@18
  int v96; // ST44_4@18
  int v97; // ST44_4@18
  int v98; // ST44_4@18
  int v99; // ST44_4@18
  int v100; // ST44_4@18
  int v101; // ST44_4@18
  int v102; // ST44_4@18
  int v103; // ST44_4@18
  int v104; // ST44_4@18
  int v105; // ST44_4@18
  int v106; // ST44_4@18
  int v107; // ST44_4@18
  int v108; // ST44_4@18
  int v109; // ST44_4@18
  int v110; // ST44_4@18
  int v111; // ST44_4@18
  int v112; // ST44_4@18
  int v113; // ST44_4@18
  int v114; // ST44_4@18
  int v115; // ST44_4@18
  int v116; // ST44_4@18
  int v117; // ST44_4@18
  int v118; // ST44_4@18
  int v119; // ST44_4@18
  int v120; // ST44_4@18
  int v121; // ST44_4@18
  int v122; // ST44_4@18
  int v123; // ST44_4@18
  int v124; // ST44_4@18
  int v125; // ST44_4@18
  int v126; // ST44_4@18
  int v127; // ST44_4@18
  int v128; // ST44_4@18
  int v129; // ST44_4@18
  int v130; // ST44_4@18
  float v131; // ST30_4@18
  int v132; // ST44_4@18
  int v133; // edi@18
  float v134; // ST30_4@18
  int v135; // ST44_4@19
  int v136; // ST44_4@19
  float v137; // ST30_4@19
  bool v138; // sf@19
  unsigned __int8 v139; // of@19
  int v140; // ST44_4@20
  int v141; // edi@20
  int v142; // ST44_4@20
  int v143; // ST44_4@20
  int v144; // ST44_4@20
  int v145; // ST44_4@20
  int v146; // ST44_4@20
  float v147; // ST30_4@20
  int v148; // ST44_4@20
  int v149; // edi@20
  float v150; // ST30_4@20
  int v151; // ST44_4@21
  int v152; // ST44_4@21
  float v153; // ST30_4@21
  int v154; // ST44_4@22
  int v155; // edi@22
  float v156; // ST30_4@22
  int v157; // ST44_4@22
  int v158; // edi@22
  float v159; // ST30_4@22
  int v160; // ST44_4@23
  float v161; // ST30_4@23
  int v162; // ST44_4@23
  float v163; // ST30_4@23
  int v164; // ST44_4@24
  int v165; // edi@24
  int v166; // ST44_4@24
  int v167; // ST44_4@24
  int v168; // ST44_4@24
  double v169; // st7@24
  float v170; // ST3C_4@24
  float v171; // ST3C_4@24
  float v172; // ST3C_4@24
  int v173; // edi@24
  int v174; // ST44_4@24
  int v175; // ST44_4@24
  int v176; // ST44_4@24
  int v177; // ST44_4@24
  int v178; // ST44_4@24
  int v179; // ST44_4@24
  int v180; // ST44_4@24
  int v181; // ST44_4@24
  int v182; // ST44_4@24
  int v183; // ST44_4@24
  int v184; // ST44_4@24
  int v185; // ST44_4@24
  double v186; // st7@24
  int v187; // ST44_4@24
  int v188; // ST44_4@24
  int v189; // ST44_4@24
  int v190; // ST44_4@24
  int v191; // ST44_4@24
  int v192; // ST44_4@24
  int v193; // ST44_4@24
  int v194; // ST44_4@24
  int v195; // ST44_4@24
  double v196; // st7@24
  float v197; // ST30_4@24
  double v198; // st7@24
  float v199; // ST2C_4@24
  int v200; // ST44_4@24
  int v201; // ST44_4@24
  int v202; // ST44_4@24
  int v203; // ST44_4@24
  int v204; // ST44_4@24
  int v205; // ST44_4@24
  double v206; // st7@24
  int v207; // ST44_4@24
  int v208; // ST44_4@24
  int v209; // ST44_4@24
  int v210; // ST44_4@24
  int v211; // ST44_4@24
  int v212; // ST44_4@24
  int v213; // ST44_4@24
  int v214; // ST44_4@24
  int v215; // ST44_4@24
  double v216; // st7@24
  float v217; // ST30_4@24
  double v218; // st7@24
  float v219; // ST2C_4@24
  int v220; // ST44_4@24
  int v221; // ST44_4@24
  int v222; // ST44_4@24
  int v223; // ST44_4@24
  int v224; // ST44_4@24
  int v225; // ST44_4@24
  int v226; // eax@24
  int v227; // edi@24
  double v228; // st6@24
  int v229; // ST44_4@24
  int v230; // ST40_4@24
  float v231; // ST30_4@24
  int v232; // ST44_4@24
  int v233; // ST40_4@24
  float v234; // ST30_4@24
  int v235; // ecx@24
  int v236; // ST44_4@24
  int v237; // ST44_4@24
  int v238; // ST40_4@24
  int v239; // ST44_4@24
  int v240; // ST40_4@24
  int v241; // ST44_4@24
  int v242; // ST40_4@24
  float v243; // ST30_4@24
  int v244; // ST44_4@24
  int v245; // ST40_4@24
  float v246; // ST30_4@24
  int v247; // ST44_4@24
  int v248; // ST40_4@24
  float v249; // ST30_4@24
  int v250; // eax@24
  int v251; // ST40_4@24
  float v252; // ST30_4@24
  int v253; // ST44_4@24
  int v254; // ST40_4@24
  float v255; // ST30_4@24
  int v256; // ST44_4@24
  int v257; // ST40_4@24
  float v258; // ST30_4@24
  int v259; // ecx@24
  int v260; // ST44_4@24
  int v261; // ST44_4@24
  int v262; // ST40_4@24
  int v263; // ST44_4@24
  int v264; // ST40_4@24
  float v265; // ST30_4@24
  int v266; // ST44_4@24
  int v267; // ST40_4@24
  int v268; // ST44_4@24
  int v269; // ST40_4@24
  int v270; // ST44_4@24
  int v271; // ST40_4@24
  int v272; // ST44_4@24
  int v273; // ST44_4@24
  int v274; // ST40_4@24
  int v275; // ST44_4@24
  int v276; // ST40_4@24
  float v277; // ST30_4@24
  int v278; // ST44_4@24
  int v279; // ST40_4@24
  int v280; // ST44_4@24
  int v281; // ST40_4@24
  int v282; // ST44_4@24
  int v283; // ST40_4@24
  float v284; // ST30_4@24
  int v285; // ST44_4@24
  int v286; // ST40_4@24
  float v287; // ST30_4@24
  int v288; // ST44_4@24
  int v289; // ST40_4@24
  int v290; // ST44_4@24
  int v291; // ST40_4@24
  float v292; // ST30_4@24
  int v293; // ST44_4@24
  int v294; // ST40_4@24
  int v295; // ST44_4@24
  int v296; // ST40_4@24
  int v297; // ST44_4@24
  int v298; // ST40_4@24
  float v299; // ST30_4@24
  int v300; // ST44_4@24
  int v301; // ST40_4@24
  float v302; // ST30_4@24
  int v303; // ST44_4@24
  int v304; // ST40_4@24
  float v305; // ST30_4@24
  int v306; // ST44_4@24
  int v307; // ST40_4@24
  float v308; // ST30_4@24
  int v309; // ST44_4@24
  int v310; // ST40_4@24
  float v311; // ST30_4@24
  int v312; // ST44_4@24
  int v313; // ST40_4@24
  float v314; // ST30_4@24
  int v315; // ST44_4@24
  int v316; // ST40_4@24
  float v317; // ST30_4@24
  int v318; // eax@24
  int v319; // ST40_4@24
  int v320; // ST44_4@24
  int v321; // ST40_4@24
  int v322; // ST44_4@24
  int v323; // ST40_4@24
  float v324; // ST30_4@24
  int v325; // ST44_4@24
  int v326; // ST40_4@24
  int v327; // ST44_4@24
  int v328; // ST40_4@24
  int v329; // ST44_4@24
  int v330; // ST40_4@24
  int v331; // ST44_4@24
  int v332; // ST40_4@24
  double v333; // st7@24
  int v334; // ST44_4@24
  float v335; // ST30_4@24
  int v336; // ST44_4@24
  float v337; // ST30_4@24
  int v338; // ST44_4@24
  float v339; // ST30_4@24
  int v340; // ST44_4@24
  float v341; // ST30_4@24
  int v342; // ST44_4@24
  float v343; // ST30_4@24
  int v344; // ST44_4@24
  float v345; // ST30_4@24
  int v347; // [sp+30h] [bp-24h]@10
  float v348; // [sp+34h] [bp-20h]@14
  int v349; // [sp+38h] [bp-1Ch]@18
  int v350; // [sp+3Ch] [bp-18h]@18
  float v351; // [sp+40h] [bp-14h]@18
  long double v352; // [sp+44h] [bp-10h]@16
  float v353; // [sp+4Ch] [bp-8h]@16
  int v354; // [sp+50h] [bp-4h]@10
  float v355; // [sp+58h] [bp+4h]@13
  float v356; // [sp+58h] [bp+4h]@13
  float v357; // [sp+58h] [bp+4h]@13
  float v358; // [sp+58h] [bp+4h]@13
  float v359; // [sp+58h] [bp+4h]@14
  float v360; // [sp+58h] [bp+4h]@14
  float v361; // [sp+58h] [bp+4h]@14
  float v362; // [sp+58h] [bp+4h]@14
  float v363; // [sp+58h] [bp+4h]@14
  float v364; // [sp+58h] [bp+4h]@14
  float v365; // [sp+58h] [bp+4h]@14
  float v366; // [sp+58h] [bp+4h]@14
  float v367; // [sp+58h] [bp+4h]@14
  float v368; // [sp+58h] [bp+4h]@14
  float v369; // [sp+58h] [bp+4h]@14
  float v370; // [sp+58h] [bp+4h]@14
  float v371; // [sp+58h] [bp+4h]@14
  float v372; // [sp+58h] [bp+4h]@14
  float v373; // [sp+58h] [bp+4h]@14
  float v374; // [sp+58h] [bp+4h]@14
  float v375; // [sp+58h] [bp+4h]@14
  float v376; // [sp+58h] [bp+4h]@14
  float v377; // [sp+58h] [bp+4h]@14
  float v378; // [sp+58h] [bp+4h]@14
  int v379; // [sp+58h] [bp+4h]@14
  float v380; // [sp+58h] [bp+4h]@18
  float v381; // [sp+58h] [bp+4h]@18
  float v382; // [sp+58h] [bp+4h]@18
  float v383; // [sp+58h] [bp+4h]@18
  float v384; // [sp+58h] [bp+4h]@18
  float v385; // [sp+58h] [bp+4h]@18
  float v386; // [sp+58h] [bp+4h]@18
  float v387; // [sp+58h] [bp+4h]@18
  float v388; // [sp+58h] [bp+4h]@18
  float v389; // [sp+58h] [bp+4h]@18
  float v390; // [sp+58h] [bp+4h]@18
  float v391; // [sp+58h] [bp+4h]@18
  float v392; // [sp+58h] [bp+4h]@18
  float v393; // [sp+58h] [bp+4h]@18
  float v394; // [sp+58h] [bp+4h]@18
  float v395; // [sp+58h] [bp+4h]@18
  float v396; // [sp+58h] [bp+4h]@18
  float v397; // [sp+58h] [bp+4h]@18
  float v398; // [sp+58h] [bp+4h]@18
  float v399; // [sp+58h] [bp+4h]@18
  float v400; // [sp+58h] [bp+4h]@18
  float v401; // [sp+58h] [bp+4h]@18
  float v402; // [sp+58h] [bp+4h]@18
  float v403; // [sp+58h] [bp+4h]@18
  float v404; // [sp+58h] [bp+4h]@18
  float v405; // [sp+58h] [bp+4h]@18
  float v406; // [sp+58h] [bp+4h]@18
  float v407; // [sp+58h] [bp+4h]@18
  float v408; // [sp+58h] [bp+4h]@18
  float v409; // [sp+58h] [bp+4h]@18
  float v410; // [sp+58h] [bp+4h]@18
  float v411; // [sp+58h] [bp+4h]@18
  float v412; // [sp+58h] [bp+4h]@18
  float v413; // [sp+58h] [bp+4h]@18
  float v414; // [sp+58h] [bp+4h]@18
  float v415; // [sp+58h] [bp+4h]@18
  float v416; // [sp+58h] [bp+4h]@18
  float v417; // [sp+58h] [bp+4h]@18
  float v418; // [sp+58h] [bp+4h]@18
  float v419; // [sp+58h] [bp+4h]@18
  float v420; // [sp+58h] [bp+4h]@18
  float v421; // [sp+58h] [bp+4h]@18
  float v422; // [sp+58h] [bp+4h]@18
  float v423; // [sp+58h] [bp+4h]@18
  float v424; // [sp+58h] [bp+4h]@18
  float v425; // [sp+58h] [bp+4h]@18
  float v426; // [sp+58h] [bp+4h]@18
  float v427; // [sp+58h] [bp+4h]@18
  signed int v428; // [sp+58h] [bp+4h]@18
  float v429; // [sp+58h] [bp+4h]@20
  float v430; // [sp+58h] [bp+4h]@20
  float v431; // [sp+58h] [bp+4h]@20
  float v432; // [sp+58h] [bp+4h]@20
  float v433; // [sp+58h] [bp+4h]@20
  float v434; // [sp+58h] [bp+4h]@20
  float v435; // [sp+58h] [bp+4h]@20
  signed int v436; // [sp+58h] [bp+4h]@20
  float v437; // [sp+58h] [bp+4h]@22
  float v438; // [sp+58h] [bp+4h]@22
  float v439; // [sp+58h] [bp+4h]@22
  float v440; // [sp+58h] [bp+4h]@22
  signed int v441; // [sp+58h] [bp+4h]@22
  float v442; // [sp+58h] [bp+4h]@24
  float v443; // [sp+58h] [bp+4h]@24
  float v444; // [sp+58h] [bp+4h]@24
  float v445; // [sp+58h] [bp+4h]@24
  float v446; // [sp+58h] [bp+4h]@24
  float v447; // [sp+58h] [bp+4h]@24
  float v448; // [sp+58h] [bp+4h]@24
  float v449; // [sp+58h] [bp+4h]@24
  float v450; // [sp+58h] [bp+4h]@24
  float v451; // [sp+58h] [bp+4h]@24
  float v452; // [sp+58h] [bp+4h]@24
  float v453; // [sp+58h] [bp+4h]@24
  float v454; // [sp+58h] [bp+4h]@24
  float v455; // [sp+58h] [bp+4h]@24
  float v456; // [sp+58h] [bp+4h]@24
  float v457; // [sp+58h] [bp+4h]@24
  float v458; // [sp+58h] [bp+4h]@24
  float v459; // [sp+58h] [bp+4h]@24
  float v460; // [sp+58h] [bp+4h]@24
  float v461; // [sp+58h] [bp+4h]@24
  float v462; // [sp+58h] [bp+4h]@24
  float v463; // [sp+58h] [bp+4h]@24
  float v464; // [sp+58h] [bp+4h]@24
  float v465; // [sp+58h] [bp+4h]@24
  float v466; // [sp+58h] [bp+4h]@24
  float v467; // [sp+58h] [bp+4h]@24

  v2 = sub_10002860(a1, 52008);
  v3 = *(float *)(a2 + 8);
  *(_DWORD *)(a2 + 16) = v2;
  *(float *)(v2 + 51656) = v3;
  *(float *)(v2 + 51652) = *(float *)(a2 + 12);
  if ( *(_BYTE *)(a2 + 3) )
  {
    *(float *)(v2 + 51660) = 9.0;
    *(float *)(v2 + 51664) = 15.0;
    *(float *)(v2 + 51668) = 23.0;
    *(float *)(v2 + 51672) = 5.0;
    *(float *)(v2 + 51676) = 6.0;
    *(float *)(v2 + 51680) = 7.0;
    *(float *)(v2 + 51684) = 7.0;
    *(float *)(v2 + 51688) = 11.0;
    *(float *)(v2 + 51692) = 11.0;
    *(float *)(v2 + 51696) = 9.0;
    *(float *)(v2 + 51700) = 10.0;
    v4 = 17.0;
  }
  else
  {
    *(float *)(v2 + 51660) = 7.0;
    *(float *)(v2 + 51664) = 12.0;
    *(float *)(v2 + 51668) = 15.0;
    *(float *)(v2 + 51672) = 4.0;
    *(float *)(v2 + 51676) = 5.0;
    *(float *)(v2 + 51680) = 5.0;
    *(float *)(v2 + 51684) = 6.0;
    *(float *)(v2 + 51688) = 7.0;
    *(float *)(v2 + 51692) = 7.0;
    *(float *)(v2 + 51696) = 8.0;
    *(float *)(v2 + 51700) = 9.0;
    v4 = 10.0;
  }
  *(float *)(v2 + 51704) = v4;
  if ( *(_BYTE *)(a2 + 4) )
  {
    *(float *)(v2 + 51708) = 0.75;
    v5 = 3.0;
  }
  else
  {
    *(float *)(v2 + 51708) = 0.30000001;
    v5 = 1.2;
  }
  *(float *)(v2 + 51712) = v5;
  if ( *(_BYTE *)(a2 + 1) )
    *(_DWORD *)(v2 + 51488) = -16777216;
  else
    *(_DWORD *)(v2 + 51488) = -14671840;
  sub_10038450(v2 + 51224, "199.9", 8);
  *(_BYTE *)(v2 + 51232) = 0;
  *(_DWORD *)(v2 + 51240) = -16728064;
  *(_DWORD *)(v2 + 51244) = -16728064;
  *(_DWORD *)(v2 + 51248) = -16777216;
  *(_DWORD *)(v2 + 51252) = 68;
  sub_10038450(v2 + 51276, "1999", 8);
  *(_BYTE *)(v2 + 51284) = 0;
  *(_DWORD *)(v2 + 51292) = -16728064;
  *(_DWORD *)(v2 + 51296) = -16728064;
  *(_DWORD *)(v2 + 51300) = -16777216;
  *(_DWORD *)(v2 + 51304) = 68;
  sub_10038450(v2 + 51328, "199.9", 8);
  *(_BYTE *)(v2 + 51336) = 0;
  *(_DWORD *)(v2 + 51344) = -16728064;
  *(_DWORD *)(v2 + 51348) = -16728064;
  *(_DWORD *)(v2 + 51352) = -16777216;
  *(_DWORD *)(v2 + 51356) = 68;
  sub_10038450(v2 + 51380, "199", 8);
  *(_DWORD *)(v2 + 51396) = -16728064;
  *(_DWORD *)(v2 + 51400) = -16728064;
  *(_BYTE *)(v2 + 51388) = 0;
  *(_DWORD *)(v2 + 51404) = -16777216;
  *(_DWORD *)(v2 + 51408) = 68;
  sub_10038450(v2 + 51432, "XX:XX", 8);
  *(_BYTE *)(v2 + 51440) = 0;
  *(_DWORD *)(v2 + 51456) = -16777216;
  *(_DWORD *)(v2 + 51460) = 68;
  *(_DWORD *)(v2 + 51448) = -256;
  *(_DWORD *)(v2 + 51452) = -256;
  *(_BYTE *)a2 = 0;
  *(_BYTE *)v2 = 0;
  *(_DWORD *)(v2 + 52000) = 0;
  *(_DWORD *)(v2 + 52004) = 0;
  *(_BYTE *)(v2 + 51484) = 0;
  *(_DWORD *)(v2 + 51596) = 0;
  *(_BYTE *)(v2 + 51601) = 0;
  *(_BYTE *)(v2 + 51600) = 0;
  *(_BYTE *)(v2 + 49825) = 1;
  *(_BYTE *)(v2 + 49824) = 0;
  *(_BYTE *)(v2 + 51611) = 0;
  *(_BYTE *)(v2 + 51612) = 0;
  *(float *)(v2 + 51720) = 9.8999998e24;
  *(float *)(v2 + 51724) = 9.8999998e24;
  *(float *)(v2 + 51776) = 9.8999998e24;
  *(float *)(v2 + 51780) = 9.8999998e24;
  *(float *)(v2 + 51832) = 9.8999998e24;
  *(float *)(v2 + 51836) = 9.8999998e24;
  *(float *)(v2 + 51888) = 9.8999998e24;
  *(float *)(v2 + 51892) = 9.8999998e24;
  *(float *)(v2 + 51944) = 9.8999998e24;
  *(float *)(v2 + 51948) = 9.8999998e24;
  *(_WORD *)(v2 + 51740) = 373;
  *(float *)(v2 + 51728) = 0.1;
  *(float *)(v2 + 51736) = 100.0;
  sub_10038450(v2 + 51744, "_trq_prim", 16);
  sub_10038450(v2 + 51760, "_trq_bkup", 16);
  *(float *)(v2 + 51784) = 1.0;
  *(float *)(v2 + 51792) = 1.0;
  *(_WORD *)(v2 + 51796) = 372;
  sub_10038450(v2 + 51800, "_mgt_prim", 16);
  sub_10038450(v2 + 51816, "_mgt_bkup", 16);
  *(float *)(v2 + 51840) = 0.1;
  *(float *)(v2 + 51848) = 100.0;
  *(_WORD *)(v2 + 51852) = 370;
  sub_10038450(v2 + 51856, "_ng_prim", 16);
  sub_10038450(v2 + 51872, "_ng_bkup", 16);
  *(float *)(v2 + 51896) = 0.1;
  *(float *)(v2 + 51904) = 100.0;
  *(_WORD *)(v2 + 51908) = 371;
  sub_10038450(v2 + 51912, "_np_prim", 16);
  sub_10038450(v2 + 51928, "_np_bkup", 16);
  *(float *)(v2 + 51952) = 1.0;
  *(float *)(v2 + 51960) = 100.0;
  *(_WORD *)(v2 + 51964) = 374;
  sub_10038450(v2 + 51968, "_nr_prim", 16);
  sub_10038450(v2 + 51984, "_nr_bkup", 16);
  v6 = *(float *)(v2 + 51668) + 6.0;
  v354 = (signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                       * ((signed int)(*(float *)(v2 + 51664) + 4.0)
                                                                        / 2))
                                                              * 0.5
                                                              + 2.0)
                                         + 0.5
                                         + *(float *)(v2 + 51664) * 1.5)
                    + 0.5
                    + *(float *)(v2 + 51664)
                    - 1.0);
  v7 = (double)v354 + 0.5;
  v354 = 2 * ((signed int)(2.0 * v6 + *(float *)(v2 + 51668) + 10.0) / 2);
  *(_BYTE *)(v2 + 51602) = 0;
  v8 = (double)v354;
  *(_BYTE *)(v2 + 51610) = 0;
  *(_BYTE *)(v2 + 51603) = 0;
  *(_BYTE *)(v2 + 51604) = 0;
  *(_BYTE *)(v2 + 51605) = 0;
  *(_BYTE *)(v2 + 51606) = 0;
  *(_BYTE *)(v2 + 51607) = 0;
  v9 = v7 + v8 * 0.5;
  *(_BYTE *)(v2 + 51608) = 0;
  *(_BYTE *)(v2 + 51609) = 0;
  *(_BYTE *)(v2 + 51613) = 0;
  *(_BYTE *)(v2 + 51614) = 0;
  *(_BYTE *)(v2 + 51615) = 0;
  *(float *)&v354 = v9 - v6;
  v10 = *(float *)&v354;
  *(float *)(v2 + 51504) = *(float *)&v354;
  *(float *)(v2 + 51508) = v9;
  *(float *)(v2 + 51512) = v6 + v9;
  *(float *)(v2 + 51516) = v10;
  *(float *)(v2 + 51548) = 9.8999998e24;
  *(float *)(v2 + 51552) = 9.8999998e24;
  *(float *)(v2 + 51564) = 9.8999998e24;
  *(float *)(v2 + 51568) = 9.8999998e24;
  *(float *)(v2 + 51716) = 9.8999998e24;
  *(float *)&v354 = *(float *)(v2 + 51652) * 0.4199999868869781;
  v11 = *(float *)&v354;
  *(float *)(v2 + 4) = *(float *)&v354;
  *(float *)&v354 = (double)(signed int)(v11 + 5.0) + 0.5;
  v12 = *(float *)&v354;
  *(float *)(v2 + 8) = *(float *)&v354;
  *(float *)(v2 + 12) = v12;
  *(float *)&v354 = *(float *)(v2 + 51652) * 0.3600000143051147;
  v13 = *(float *)&v354;
  *(float *)(v2 + 16) = *(float *)&v354;
  v354 = (signed int)(*(float *)(v2 + 51652) - 22.0);
  *(float *)(v2 + 20) = (double)v354 + 0.5;
  v354 = (signed int)(*(float *)(v2 + 51656) - v13 - 5.0);
  *(float *)(v2 + 24) = (double)v354 + 0.5;
  *(float *)(v2 + 51520) = 0.0;
  *(float *)(v2 + 51528) = 0.0;
  *(float *)(v2 + 51524) = 0.0;
  *(float *)(v2 + 51532) = 0.0;
  *(float *)(v2 + 51540) = 0.0;
  *(float *)(v2 + 51536) = 0.0;
  v354 = *(int *)(v2 + 51660);
  v14 = *(float *)&v354;
  *(float *)(v2 + 51616) = *(float *)&v354;
  v15 = v14;
  v16 = sub_10038970(v15);
  *(_DWORD *)(v2 + 51620) = v16;
  *(_DWORD *)(v2 + 51624) = sub_100171A0(v16 & 0x3FFFFFFF);
  v354 = *(int *)(v2 + 51664);
  v17 = *(float *)&v354;
  *(float *)(v2 + 51628) = *(float *)&v354;
  v18 = v17;
  v19 = sub_10038970(v18);
  *(_DWORD *)(v2 + 51632) = v19;
  *(_DWORD *)(v2 + 51636) = sub_100171A0(v19 & 0x3FFFFFFF);
  v354 = *(int *)(v2 + 51668);
  v20 = *(float *)&v354;
  *(float *)(v2 + 51640) = *(float *)&v354;
  v21 = v20;
  v22 = sub_10038970(v21);
  *(_DWORD *)(v2 + 51644) = v22;
  *(_DWORD *)(v2 + 51648) = sub_100171A0(v22 & 0x3FFFFFFF);
  qmemcpy((void *)(v2 + 50332), &unk_100A4E28, 0x18Cu);
  *(float *)(v2 + 50348) = *(float *)(dword_102D2B4C + 8188);
  *(float *)(v2 + 50384) = *(float *)(dword_102D2B4C + 0x2000);
  *(float *)(v2 + 50420) = *(float *)(dword_102D2B4C + 8196);
  *(float *)(v2 + 50456) = *(float *)(dword_102D2B4C + 8200);
  *(float *)(v2 + 50492) = *(float *)(dword_102D2B4C + 8204);
  *(float *)(v2 + 50528) = *(float *)(dword_102D2B4C + 8208);
  *(float *)(v2 + 50564) = *(float *)(dword_102D2B4C + 8212);
  *(float *)(v2 + 50600) = *(float *)(dword_102D2B4C + 8216);
  *(float *)(v2 + 50636) = *(float *)(dword_102D2B4C + 8220);
  *(float *)(v2 + 50672) = *(float *)(dword_102D2B4C + 8224);
  *(float *)(v2 + 50708) = *(float *)(dword_102D2B4C + 8352);
  qmemcpy((void *)(v2 + 50728), &unk_100A4FB8, 0x18Cu);
  *(float *)(v2 + 50744) = *(float *)(dword_102D2B4C + 8516);
  *(float *)(v2 + 50780) = *(float *)(dword_102D2B4C + 8520);
  *(float *)(v2 + 50816) = *(float *)(dword_102D2B4C + 8524);
  *(float *)(v2 + 50852) = *(float *)(dword_102D2B4C + 8528);
  *(float *)(v2 + 50888) = *(float *)(dword_102D2B4C + 8532);
  *(float *)(v2 + 50924) = *(float *)(dword_102D2B4C + 8536);
  *(float *)(v2 + 50960) = *(float *)(dword_102D2B4C + 8540);
  *(float *)(v2 + 50996) = *(float *)(dword_102D2B4C + 8544);
  *(float *)(v2 + 51032) = *(float *)(dword_102D2B4C + 8548);
  *(float *)(v2 + 51068) = *(float *)(dword_102D2B4C + 8552);
  *(float *)(v2 + 51104) = *(float *)(dword_102D2B4C + 8680);
  *(_DWORD *)(v2 + 51124) = v2 + 50332;
  qmemcpy((void *)(v2 + 49828), &unk_100A5148, 0x1F8u);
  sub_10028B00(v2);
  *(float *)(v2 + 49848) = *(float *)(dword_102D2B4C + 7532);
  *(float *)(v2 + 49884) = *(float *)(dword_102D2B4C + 7532);
  *(float *)(v2 + 49920) = *(float *)(dword_102D2B4C + 7536);
  *(float *)(v2 + 49956) = *(float *)(dword_102D2B4C + 7540);
  *(float *)(v2 + 49992) = *(float *)(dword_102D2B4C + 7544);
  v23 = v2 + 12320;
  *(float *)(v2 + 50028) = *(float *)(dword_102D2B4C + 7548);
  v24 = *(float *)(dword_102D2B4C + 7552);
  *(float *)&v347 = 0.0;
  *(float *)(v2 + 50064) = v24;
  *(float *)(v2 + 50100) = *(float *)(dword_102D2B4C + 7556);
  *(float *)(v2 + 50136) = *(float *)(dword_102D2B4C + 7560);
  *(float *)(v2 + 50172) = *(float *)(dword_102D2B4C + 7564);
  *(float *)(v2 + 50208) = *(float *)(dword_102D2B4C + 7568);
  *(float *)(v2 + 50244) = *(float *)(dword_102D2B4C + 7696);
  *(float *)(v2 + 50280) = *(float *)(dword_102D2B4C + 7700);
  *(float *)(v2 + 50316) = *(float *)(dword_102D2B4C + 7704);
  *(float *)(v2 + 51556) = *(float *)(dword_102D2B4C + 7728);
  *(float *)(v2 + 51560) = *(float *)(dword_102D2B4C + 7732);
  *(float *)(v2 + 49852) = *(float *)(dword_102D2B4C + 7860);
  *(float *)(v2 + 49888) = *(float *)(dword_102D2B4C + 7860);
  *(float *)(v2 + 49924) = *(float *)(dword_102D2B4C + 7864);
  *(float *)(v2 + 49960) = *(float *)(dword_102D2B4C + 7868);
  *(float *)(v2 + 49996) = *(float *)(dword_102D2B4C + 7872);
  *(float *)(v2 + 50032) = *(float *)(dword_102D2B4C + 7876);
  *(float *)(v2 + 50068) = *(float *)(dword_102D2B4C + 7880);
  *(float *)(v2 + 50104) = *(float *)(dword_102D2B4C + 7884);
  *(float *)(v2 + 50140) = *(float *)(dword_102D2B4C + 7888);
  *(float *)(v2 + 50176) = *(float *)(dword_102D2B4C + 7892);
  *(float *)(v2 + 50212) = *(float *)(dword_102D2B4C + 7896);
  *(float *)(v2 + 50248) = *(float *)(dword_102D2B4C + 8024);
  *(float *)(v2 + 50284) = *(float *)(dword_102D2B4C + 8028);
  *(float *)(v2 + 50320) = *(float *)(dword_102D2B4C + 8032);
  *(_DWORD *)(v2 + 49184) = 0;
  if ( *(_BYTE *)(a2 + 1) )
    sub_10029950(v2 + 12320, v2, &v347);
  sub_10028C00(
    v2 + 49828,
    v2 + 49212,
    *(float *)(v2 + 8),
    *(float *)(v2 + 12),
    *(float *)(v2 + 4),
    0,
    13,
    &v347,
    v2 + 12320,
    0);
  sub_1002AF30(
    -8355712,
    v2 + 49464,
    *(float *)(v2 + 8),
    *(float *)(v2 + 12),
    *(float *)(v2 + 4),
    180.0,
    216.0,
    &v347,
    v2 + 12320);
  sub_1002AF30(
    -65536,
    v2 + 49476,
    *(float *)(v2 + 8),
    *(float *)(v2 + 12),
    *(float *)(v2 + 4),
    180.0,
    216.0,
    &v347,
    v2 + 12320);
  sub_1002AF30(-256, v2 + 49488, 0.0, 0.0, *(float *)(v2 + 4), 180.0, 198.0, &v347, v2 + 12320);
  sub_10028C00(
    v2 + 50332,
    v2 + 49260,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    0,
    10,
    &v347,
    v2 + 12320,
    0);
  sub_10028C00(
    v2 + 50728,
    v2 + 49284,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    0,
    10,
    &v347,
    v2 + 12320,
    0);
  sub_1002AF30(
    -8355712,
    v2 + 49500,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    115.0,
    125.0,
    &v347,
    v2 + 12320);
  sub_1002AF30(
    -65536,
    v2 + 49512,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    115.0,
    125.0,
    &v347,
    v2 + 12320);
  sub_1002AF30(
    -65536,
    v2 + 49524,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    95.0,
    115.0,
    &v347,
    v2 + 12320);
  sub_1002AF30(
    -8355712,
    v2 + 49536,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    0.0,
    30.0,
    &v347,
    v2 + 12320);
  sub_1002AF30(
    -256,
    v2 + 49548,
    *(float *)(v2 + 20),
    *(float *)(v2 + 24),
    *(float *)(v2 + 16),
    0.0,
    30.0,
    &v347,
    v2 + 12320);
  v25 = 4.5;
  v26 = v347;
  *(_DWORD *)(v2 + 49320) = 67;
  *(_DWORD *)(v2 + 49324) = v26;
  if ( *(_BYTE *)(a2 + 1) == 1 )
  {
    v27 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                                * ((signed int)(*(float *)(v2 + 51664)
                                                                                              + 4.0)
                                                                                 / 2))
                                                                       * 0.5
                                                                       + 2.0)
                                                  + 0.5
                                                  + *(float *)(v2 + 51664) * 1.5)
                             + 0.5
                             + *(float *)(v2 + 51664)
                             - 1.0)
        + 0.5;
    v28 = *(float *)(v2 + 51652) - 4.5;
    v355 = (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) + v27;
    v29 = v355;
    v356 = v28;
    v30 = v356;
    v357 = v27;
    v31 = v357;
    v358 = v28 - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2));
    sub_1002AAB0(-4144960, v2 + 12320, v358, v31, v30, v29, 5.0, &v347);
    v25 = 4.5;
    v26 = v347;
  }
  *(_DWORD *)(v2 + 49328) = v26 - *(_DWORD *)(v2 + 49324);
  *(_DWORD *)(v2 + 49308) = 67;
  *(_DWORD *)(v2 + 49312) = v26;
  v32 = v23 + 24 * v26;
  v33 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) * 0.5;
  v34 = v26 + 1;
  v348 = *(float *)(v2 + 51652) - v25 - v33;
  v359 = *(float *)(v2 + 24);
  *(float *)&v354 = v359 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2));
  v35 = *(float *)&v354;
  *(float *)&v354 = v348 - v33;
  sub_100165C0(*(float *)&v354, v35, 0.0, 0.0, 0.0, -4144960, v32);
  v36 = v23 + 24 * v34++;
  *(float *)&v354 = v359 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5;
  v37 = *(float *)&v354;
  *(float *)&v354 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v37, 0.0, 0.0, 0.0, -4144960, v36);
  v38 = v23 + 24 * v34++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v359;
  v39 = *(float *)&v354;
  *(float *)&v354 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v39, 0.0, 0.0, 0.0, -4144960, v38);
  v40 = v23 + 24 * v34++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v359;
  v41 = *(float *)&v354;
  *(float *)&v354 = v348 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2));
  sub_100165C0(*(float *)&v354, v41, 0.0, 0.0, 0.0, -4144960, v40);
  v42 = v23 + 24 * v34++;
  v347 = v34;
  v360 = v359 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5;
  v43 = v360;
  v361 = v348 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2));
  sub_100165C0(v361, v43, 0.0, 0.0, 0.0, -4144960, v42);
  *(_DWORD *)(v2 + 49316) = v34 - *(_DWORD *)(v2 + 49312);
  v362 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2));
  v44 = v362;
  v363 = v362 - 9.0;
  v45 = v363;
  v364 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5
       - (*(float *)(v2 + 51668)
        + 6.0);
  v46 = v364;
  v365 = 0.5 - (double)(signed int)(v44 * 0.5 + 4.5) + *(float *)(v2 + 51652);
  sub_1002B160(v2 + 49728, v2 + 12320, v365, v46, v45, *(float *)(v2 + 51668), (int)&v347);
  v366 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2));
  v47 = v366;
  v367 = v366 - 9.0;
  v48 = v367;
  v368 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5;
  v49 = v368;
  v369 = 0.5 - (double)(signed int)(v47 * 0.5 + 4.5) + *(float *)(v2 + 51652);
  sub_1002B160(v2 + 49752, v2 + 12320, v369, v49, v48, *(float *)(v2 + 51668), (int)&v347);
  v370 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2));
  v50 = v370;
  v371 = v370 - 9.0;
  v51 = v371;
  v372 = *(float *)(v2 + 51668)
       + 6.0
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5;
  v52 = v372;
  v373 = 0.5 - (double)(signed int)(v50 * 0.5 + 4.5) + *(float *)(v2 + 51652);
  sub_1002B160(v2 + 49776, v2 + 12320, v373, v52, v51, *(float *)(v2 + 51668), (int)&v347);
  v374 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2));
  v53 = v374;
  v375 = v374 - 9.0;
  v54 = v375;
  v376 = *(float *)(v2 + 51652) - 4.5 - v53 * 0.5;
  sub_1002B160(v2 + 49800, v2 + 12320, v376, *(float *)(v2 + 24), v54, *(float *)(v2 + 51668), (int)&v347);
  v55 = v347;
  *(_DWORD *)(v2 + 49356) = 68;
  *(_DWORD *)(v2 + 49360) = v55;
  v377 = *(float *)(v2 + 24) - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 - 4.0;
  v56 = v377;
  v378 = *(float *)(v2 + 51652) - 4.5 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2));
  sub_1002B400(v2 + 12320, &v347, (int)"NR", -1, v2 + 51628, v378, v56, 0.5, 0.0);
  v57 = v347;
  v58 = (float *)(v2 + 49856);
  *(_DWORD *)(v2 + 49364) = v347 - *(_DWORD *)(v2 + 49360);
  *(_DWORD *)(v2 + 49332) = 68;
  *(_DWORD *)(v2 + 49336) = v57;
  v379 = v2 + 49856;
  v354 = 14;
  do
  {
    if ( *(_BYTE *)v58 )
    {
      v348 = *(float *)(v2 + 4) - *(float *)(v2 + 51668) * 1.5;
      v352 = (*(v58 - 7) + 90.0) * 0.01745329251994333;
      v353 = sin(v352);
      v353 = v353 * v348 + *(float *)(v2 + 12);
      v59 = v353;
      v353 = cos(v352);
      v353 = v353 * v348 + *(float *)(v2 + 8);
      sub_1002B400(v2 + 12320, &v347, (int)v58, -4144960, v2 + 51628, v353, v59, 0.5, 0.5);
      v58 = (float *)v379;
    }
    v58 += 9;
    v60 = v354-- == 1;
    v379 = (int)v58;
  }
  while ( !v60 );
  v61 = v347;
  *(_DWORD *)(v2 + 49340) = v347 - *(_DWORD *)(v2 + 49336);
  *(_DWORD *)(v2 + 49680) = 68;
  *(_DWORD *)(v2 + 49684) = v61;
  v380 = 0.5 * (double)(2 * ((signed int)((*(float *)(v2 + 51668) + 6.0) * 2.0 + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       - (*(float *)(v2 + 51668)
        + 6.0)
       + *(float *)(v2 + 51680)
       + 2.0;
  v62 = v380;
  v381 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_1002B400(v2 + 12320, &v347, (int)&unk_10089520, -256, v2 + 51616, v381, v62, 0.0, 0.0);
  v63 = v347;
  *(_DWORD *)(v2 + 49688) = v347 - *(_DWORD *)(v2 + 49684);
  *(_DWORD *)(v2 + 49692) = 68;
  *(_DWORD *)(v2 + 49696) = v63;
  v382 = 0.5 * (double)(2 * ((signed int)((*(float *)(v2 + 51668) + 6.0) * 2.0 + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + *(float *)(v2 + 51680)
       + 2.0;
  v64 = v382;
  v383 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_1002B400(v2 + 12320, &v347, (int)&unk_10089520, -256, v2 + 51616, v383, v64, 0.0, 0.0);
  v65 = v347;
  *(_DWORD *)(v2 + 49700) = v347 - *(_DWORD *)(v2 + 49696);
  *(_DWORD *)(v2 + 49704) = 68;
  *(_DWORD *)(v2 + 49708) = v65;
  v384 = *(float *)(v2 + 51668)
       + 6.0
       + 0.5 * (double)(2 * ((signed int)((*(float *)(v2 + 51668) + 6.0) * 2.0 + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + *(float *)(v2 + 51680)
       + 2.0;
  v66 = v384;
  v385 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_1002B400(v2 + 12320, &v347, (int)&unk_10089520, -256, v2 + 51616, v385, v66, 0.0, 0.0);
  v67 = v347;
  *(_DWORD *)(v2 + 49712) = v347 - *(_DWORD *)(v2 + 49708);
  *(_DWORD *)(v2 + 49716) = 68;
  *(_DWORD *)(v2 + 49720) = v67;
  v386 = *(float *)(v2 + 24) - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 - 4.0 + 1.0;
  v68 = v386;
  v387 = *(float *)(v2 + 51652)
       - 4.5
       - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2))
       + *(float *)(v2 + 51700);
  sub_1002B400(v2 + 12320, &v347, (int)&unk_10089520, -256, v2 + 51616, v387, v68, 0.0, 0.0);
  v69 = v347;
  *(_DWORD *)(v2 + 49724) = v347 - *(_DWORD *)(v2 + 49720);
  *(_DWORD *)(v2 + 49368) = 68;
  *(_DWORD *)(v2 + 49372) = v69;
  v348 = 0.5
       - (double)(signed int)((double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) * 0.5 + 4.5)
       + *(float *)(v2 + 51652);
  v388 = (double)(signed int)((double)(signed int)((double)(2 * ((signed int)(*(float *)(v2 + 51664) + 4.0) / 2)) * 0.5
                                                 + 2.0)
                            + 0.5
                            + *(float *)(v2 + 51664) * 1.5)
       + 0.5;
  sub_1002B400(v2 + 12320, &v347, (int)"ALTN", -256, v2 + 51628, v348, v388, 0.5, 0.5);
  v70 = v347;
  v71 = 3 * v347;
  *(_DWORD *)(v2 + 49376) = v347 - *(_DWORD *)(v2 + 49372);
  *(_DWORD *)(v2 + 49380) = 67;
  *(_DWORD *)(v2 + 49384) = v70;
  v351 = v388 - *(float *)(v2 + 51684) - 2.0;
  ++v70;
  *(float *)&v352 = v388 + *(float *)(v2 + 51680) + 2.0;
  v72 = 2.0 * *(float *)(v2 + 51700) + 1.0;
  v389 = v348 - v72;
  v348 = v72 + v348;
  sub_100165C0(v389, v351, 0.0, 0.0, 0.0, -256, v23 + 8 * v71);
  v73 = v23 + 24 * v70++;
  sub_100165C0(v389, *(float *)&v352, 0.0, 0.0, 0.0, -256, v73);
  v74 = v23 + 24 * v70++;
  sub_100165C0(v348, *(float *)&v352, 0.0, 0.0, 0.0, -256, v74);
  v75 = v23 + 24 * v70++;
  sub_100165C0(v348, v351, 0.0, 0.0, 0.0, -256, v75);
  v76 = v23 + 24 * v70++;
  v347 = v70;
  sub_100165C0(v389, v351, 0.0, 0.0, 0.0, -256, v76);
  *(_DWORD *)(v2 + 49388) = v70 - *(_DWORD *)(v2 + 49384);
  *(_DWORD *)(v2 + 49392) = 68;
  *(_DWORD *)(v2 + 49396) = v70;
  v348 = 0.5
       - (double)(signed int)((double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) * 0.5 + 4.5)
       + *(float *)(v2 + 51652);
  v390 = (double)(signed int)((double)(signed int)((double)(2 * ((signed int)(*(float *)(v2 + 51664) + 4.0) / 2)) * 0.5
                                                 + 2.0)
                            + 0.5
                            + *(float *)(v2 + 51664) * 1.5)
       + 0.5;
  sub_1002B400(v2 + 12320, &v347, (int)"ALTN", -1, v2 + 51628, v348, v390, 0.5, 0.5);
  v77 = v347;
  v78 = 3 * v347;
  *(_DWORD *)(v2 + 49400) = v347 - *(_DWORD *)(v2 + 49396);
  *(_DWORD *)(v2 + 49404) = 67;
  *(_DWORD *)(v2 + 49408) = v77;
  v351 = v390 - *(float *)(v2 + 51684) - 2.0;
  ++v77;
  *(float *)&v352 = v390 + *(float *)(v2 + 51680) + 2.0;
  v79 = 2.0 * *(float *)(v2 + 51700) + 1.0;
  v391 = v348 - v79;
  v348 = v79 + v348;
  sub_100165C0(v391, v351, 0.0, 0.0, 0.0, -1, v23 + 8 * v78);
  v80 = v23 + 24 * v77++;
  sub_100165C0(v391, *(float *)&v352, 0.0, 0.0, 0.0, -1, v80);
  v81 = v23 + 24 * v77++;
  sub_100165C0(v348, *(float *)&v352, 0.0, 0.0, 0.0, -1, v81);
  v82 = v23 + 24 * v77++;
  sub_100165C0(v348, v351, 0.0, 0.0, 0.0, -1, v82);
  v83 = v23 + 24 * v77++;
  v347 = v77;
  sub_100165C0(v391, v351, 0.0, 0.0, 0.0, -1, v83);
  *(_DWORD *)(v2 + 49412) = v77 - *(_DWORD *)(v2 + 49408);
  *(_DWORD *)(v2 + 49416) = 68;
  *(_DWORD *)(v2 + 49420) = v77;
  v392 = (double)(2 * ((signed int)(*(float *)(v2 + 51664) + 4.0) / 2));
  v348 = *(float *)(v2 + 51652) - 2.0 - (double)(2 * ((signed int)(4.0 * v392) / 2)) * 0.5 - 7.0;
  v393 = (double)(signed int)(v392 * 0.5 + 2.0) + 0.5;
  sub_1002B400(v2 + 12320, &v347, (int)"CYC CTR", -16777216, v2 + 51628, v348, v393, 0.5, 0.5);
  v84 = v347;
  *(_DWORD *)(v2 + 49424) = v347 - *(_DWORD *)(v2 + 49420);
  *(_DWORD *)(v2 + 49428) = 68;
  *(_DWORD *)(v2 + 49432) = v84;
  v85 = v23 + 24 * v84;
  v351 = v393 - *(float *)(v2 + 51684) - 1.0;
  ++v84;
  *(float *)&v352 = v393 + *(float *)(v2 + 51680) + 2.0;
  v86 = *(float *)(v2 + 51700) * 3.5;
  v394 = v348 - (v86 + 0.0);
  v348 = v86 + 1.0 + v348;
  sub_100165C0(v394, v351, 0.0, 0.0, 0.0, -256, v85);
  v87 = v23 + 24 * v84++;
  sub_100165C0(v394, *(float *)&v352, 0.0, 0.0, 0.0, -256, v87);
  v88 = v23 + 24 * v84++;
  sub_100165C0(v348, v351, 0.0, 0.0, 0.0, -256, v88);
  v89 = v23 + 24 * v84++;
  sub_100165C0(v348, v351, 0.0, 0.0, 0.0, -256, v89);
  v90 = v23 + 24 * v84++;
  sub_100165C0(v394, *(float *)&v352, 0.0, 0.0, 0.0, -256, v90);
  v91 = v23 + 24 * v84++;
  v347 = v84;
  sub_100165C0(v348, *(float *)&v352, 0.0, 0.0, 0.0, -256, v91);
  *(_DWORD *)(v2 + 49436) = v84 - *(_DWORD *)(v2 + 49432);
  *(_DWORD *)(v2 + 49452) = 68;
  *(_DWORD *)(v2 + 49456) = v84;
  v395 = *(float *)(v2 + 12) - (*(float *)(v2 + 51668) * 0.5 + 3.0);
  v92 = v395;
  v396 = *(float *)(v2 + 8) - *(float *)(v2 + 4) * 0.4000000059604645;
  sub_1002B400(v2 + 12320, &v347, (int)"5 MIN", -256, v2 + 51628, v396, v92, 0.5, 0.0);
  v93 = v347;
  v94 = v23 + 24 * v347;
  *(_DWORD *)(v2 + 49460) = v347 - *(_DWORD *)(v2 + 49456);
  *(_DWORD *)(v2 + 49560) = 68;
  *(_DWORD *)(v2 + 49564) = v93++;
  sub_100165C0(0.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -65536, v94);
  v95 = v23 + 24 * v93++;
  v397 = *(float *)(v2 + 4) + 10.0;
  sub_100165C0(-8.0, v397, 0.0, 0.0, 0.0, -65536, v95);
  v96 = v23 + 24 * v93++;
  v398 = *(float *)(v2 + 4) + 10.0;
  sub_100165C0(8.0, v398, 0.0, 0.0, 0.0, -65536, v96);
  *(_DWORD *)(v2 + 49568) = v93 - *(_DWORD *)(v2 + 49564);
  v97 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49572) = 67;
  *(_DWORD *)(v2 + 49576) = v93++;
  sub_100165C0(0.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -16777216, v97);
  v98 = v23 + 24 * v93++;
  v399 = *(float *)(v2 + 4) + 10.0;
  sub_100165C0(-8.0, v399, 0.0, 0.0, 0.0, -16777216, v98);
  v99 = v23 + 24 * v93++;
  v400 = *(float *)(v2 + 4) + 10.0;
  sub_100165C0(8.0, v400, 0.0, 0.0, 0.0, -16777216, v99);
  v100 = v23 + 24 * v93++;
  sub_100165C0(0.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -16777216, v100);
  v101 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49580) = v93 - *(_DWORD *)(v2 + 49576);
  *(_DWORD *)(v2 + 49584) = 69;
  *(_DWORD *)(v2 + 49588) = v93++;
  sub_100165C0(-2.0, *(float *)(v2 + 16), 0.0, 0.0, 0.0, -65281, v101);
  v102 = v23 + 24 * v93++;
  sub_100165C0(2.0, *(float *)(v2 + 16), 0.0, 0.0, 0.0, -65281, v102);
  v103 = v23 + 24 * v93++;
  v401 = *(float *)(v2 + 16) + 8.456999778747559;
  sub_100165C0(-2.0, v401, 0.0, 0.0, 0.0, -65281, v103);
  v104 = v23 + 24 * v93++;
  v402 = *(float *)(v2 + 16) + 8.456999778747559;
  sub_100165C0(2.0, v402, 0.0, 0.0, 0.0, -65281, v104);
  v105 = v23 + 24 * v93++;
  v403 = *(float *)(v2 + 16) + 11.70400047302246;
  sub_100165C0(-5.5430002, v403, 0.0, 0.0, 0.0, -65281, v105);
  v106 = v23 + 24 * v93++;
  v404 = *(float *)(v2 + 16) + 11.70400047302246;
  sub_100165C0(5.5430002, v404, 0.0, 0.0, 0.0, -65281, v106);
  v107 = v23 + 24 * v93++;
  v405 = *(float *)(v2 + 16) + 14.0;
  sub_100165C0(-6.0, v405, 0.0, 0.0, 0.0, -65281, v107);
  v108 = v23 + 24 * v93++;
  v406 = *(float *)(v2 + 16) + 14.0;
  sub_100165C0(6.0, v406, 0.0, 0.0, 0.0, -65281, v108);
  v109 = v23 + 24 * v93++;
  v407 = *(float *)(v2 + 16) + 16.29599952697754;
  sub_100165C0(-5.5430002, v407, 0.0, 0.0, 0.0, -65281, v109);
  v110 = v23 + 24 * v93++;
  v408 = *(float *)(v2 + 16) + 16.29599952697754;
  sub_100165C0(5.5430002, v408, 0.0, 0.0, 0.0, -65281, v110);
  v111 = v23 + 24 * v93++;
  v409 = *(float *)(v2 + 16) + 19.54299926757812;
  sub_100165C0(-2.296, v409, 0.0, 0.0, 0.0, -65281, v111);
  v112 = v23 + 24 * v93++;
  v410 = *(float *)(v2 + 16) + 19.54299926757812;
  sub_100165C0(2.296, v410, 0.0, 0.0, 0.0, -65281, v112);
  v113 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49592) = v93 - *(_DWORD *)(v2 + 49588);
  *(_DWORD *)(v2 + 49596) = 67;
  *(_DWORD *)(v2 + 49600) = v93++;
  sub_100165C0(-2.0, *(float *)(v2 + 16), 0.0, 0.0, 0.0, -16777216, v113);
  v114 = v23 + 24 * v93++;
  v411 = *(float *)(v2 + 16) + 8.456999778747559;
  sub_100165C0(-2.0, v411, 0.0, 0.0, 0.0, -16777216, v114);
  v115 = v23 + 24 * v93++;
  v412 = *(float *)(v2 + 16) + 11.70400047302246;
  sub_100165C0(-5.5430002, v412, 0.0, 0.0, 0.0, -16777216, v115);
  v116 = v23 + 24 * v93++;
  v413 = *(float *)(v2 + 16) + 14.0;
  sub_100165C0(-6.0, v413, 0.0, 0.0, 0.0, -16777216, v116);
  v117 = v23 + 24 * v93++;
  v414 = *(float *)(v2 + 16) + 16.29599952697754;
  sub_100165C0(-5.5430002, v414, 0.0, 0.0, 0.0, -16777216, v117);
  v118 = v23 + 24 * v93++;
  v415 = *(float *)(v2 + 16) + 19.54299926757812;
  sub_100165C0(-2.296, v415, 0.0, 0.0, 0.0, -16777216, v118);
  v119 = v23 + 24 * v93++;
  v416 = *(float *)(v2 + 16) + 19.54299926757812;
  sub_100165C0(2.296, v416, 0.0, 0.0, 0.0, -16777216, v119);
  v120 = v23 + 24 * v93++;
  v417 = *(float *)(v2 + 16) + 16.29599952697754;
  sub_100165C0(5.5430002, v417, 0.0, 0.0, 0.0, -16777216, v120);
  v121 = v23 + 24 * v93++;
  v418 = *(float *)(v2 + 16) + 14.0;
  sub_100165C0(6.0, v418, 0.0, 0.0, 0.0, -16777216, v121);
  v122 = v23 + 24 * v93++;
  v419 = *(float *)(v2 + 16) + 11.70400047302246;
  sub_100165C0(5.5430002, v419, 0.0, 0.0, 0.0, -16777216, v122);
  v123 = v23 + 24 * v93++;
  v420 = *(float *)(v2 + 16) + 8.456999778747559;
  sub_100165C0(2.0, v420, 0.0, 0.0, 0.0, -16777216, v123);
  v124 = v23 + 24 * v93++;
  sub_100165C0(2.0, *(float *)(v2 + 16), 0.0, 0.0, 0.0, -16777216, v124);
  *(_DWORD *)(v2 + 49604) = v93 - *(_DWORD *)(v2 + 49600);
  v125 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49620) = 69;
  *(_DWORD *)(v2 + 49624) = v93++;
  sub_100165C0(-3.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -1, v125);
  v126 = v23 + 24 * v93++;
  sub_100165C0(3.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -1, v126);
  v127 = v23 + 24 * v93++;
  v421 = *(float *)(v2 + 4) + 9.0;
  sub_100165C0(-3.0, v421, 0.0, 0.0, 0.0, -1, v127);
  v128 = v23 + 24 * v93++;
  v422 = *(float *)(v2 + 4) + 9.0;
  sub_100165C0(3.0, v422, 0.0, 0.0, 0.0, -1, v128);
  v129 = v23 + 24 * v93;
  *(_DWORD *)(v2 + 49628) = v93 - *(_DWORD *)(v2 + 49624);
  *(_DWORD *)(v2 + 49608) = 69;
  *(_DWORD *)(v2 + 49612) = v93++;
  v423 = *(float *)(v2 + 4) + 16.0;
  sub_100165C0(0.0, v423, 0.0, 0.0, 0.0, -1, v129);
  sub_10070810(0.0, (int)&v349, (int)&v350);
  v130 = v23 + 24 * v93++;
  v424 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
  v131 = v424;
  v425 = 8.0 * *(float *)&v350;
  sub_100165C0(v425, v131, 0.0, 0.0, 0.0, -1, v130);
  sub_10070810(0.62831855, (int)&v349, (int)&v350);
  v132 = v23 + 24 * v93;
  v133 = v93 + 1;
  v426 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
  v134 = v426;
  v427 = 8.0 * *(float *)&v350;
  sub_100165C0(v427, v134, 0.0, 0.0, 0.0, -1, v132);
  v428 = 2;
  v354 = v23 + 24 * v133;
  do
  {
    v353 = (double)v428 * 6.283185482025146 / 10.0;
    sub_10070810(v353, (int)&v349, (int)&v350);
    v135 = v354;
    v354 += 24;
    v353 = *(float *)(v2 + 4) + 16.0;
    sub_100165C0(0.0, v353, 0.0, 0.0, 0.0, -1, v135);
    v136 = v354;
    v133 += 2;
    v354 += 24;
    v353 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
    v137 = v353;
    v353 = 8.0 * *(float *)&v350;
    sub_100165C0(v353, v137, 0.0, 0.0, 0.0, -1, v136);
    v139 = __OFSUB__(v428 + 1, 10);
    v60 = v428 == 9;
    v138 = v428++ - 9 < 0;
  }
  while ( (unsigned __int8)(v138 ^ v139) | v60 );
  v140 = v23 + 24 * v133;
  *(_DWORD *)(v2 + 49616) = v133 - *(_DWORD *)(v2 + 49612);
  *(_DWORD *)(v2 + 49644) = 69;
  *(_DWORD *)(v2 + 49648) = v133;
  v141 = v133 + 1;
  sub_100165C0(-3.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -16711681, v140);
  v142 = v23 + 24 * v141++;
  sub_100165C0(3.0, *(float *)(v2 + 4), 0.0, 0.0, 0.0, -16711681, v142);
  v143 = v23 + 24 * v141++;
  v429 = *(float *)(v2 + 4) + 9.0;
  sub_100165C0(-3.0, v429, 0.0, 0.0, 0.0, -16711681, v143);
  v144 = v23 + 24 * v141++;
  v430 = *(float *)(v2 + 4) + 9.0;
  sub_100165C0(3.0, v430, 0.0, 0.0, 0.0, -16711681, v144);
  *(_DWORD *)(v2 + 49652) = v141 - *(_DWORD *)(v2 + 49648);
  *(_DWORD *)(v2 + 49632) = 69;
  *(_DWORD *)(v2 + 49636) = v141;
  v145 = v23 + 24 * v141++;
  v431 = *(float *)(v2 + 4) + 16.0;
  sub_100165C0(0.0, v431, 0.0, 0.0, 0.0, -16711681, v145);
  sub_10070810(0.0, (int)&v349, (int)&v350);
  v146 = v23 + 24 * v141++;
  v432 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
  v147 = v432;
  v433 = 8.0 * *(float *)&v350;
  sub_100165C0(v433, v147, 0.0, 0.0, 0.0, -16711681, v146);
  sub_10070810(0.62831855, (int)&v349, (int)&v350);
  v148 = v23 + 24 * v141;
  v149 = v141 + 1;
  v434 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
  v150 = v434;
  v435 = 8.0 * *(float *)&v350;
  sub_100165C0(v435, v150, 0.0, 0.0, 0.0, -16711681, v148);
  v436 = 2;
  v354 = v23 + 24 * v149;
  do
  {
    v353 = (double)v436 * 6.283185482025146 / 10.0;
    sub_10070810(v353, (int)&v349, (int)&v350);
    v151 = v354;
    v354 += 24;
    v353 = *(float *)(v2 + 4) + 16.0;
    sub_100165C0(0.0, v353, 0.0, 0.0, 0.0, -16711681, v151);
    v152 = v354;
    v149 += 2;
    v354 += 24;
    v353 = *(float *)&v349 * 8.0 + *(float *)(v2 + 4) + 16.0;
    v153 = v353;
    v353 = 8.0 * *(float *)&v350;
    sub_100165C0(v353, v153, 0.0, 0.0, 0.0, -16711681, v152);
    v139 = __OFSUB__(v436 + 1, 10);
    v60 = v436 == 9;
    v138 = v436++ - 9 < 0;
  }
  while ( (unsigned __int8)(v138 ^ v139) | v60 );
  *(_DWORD *)(v2 + 49640) = v149 - *(_DWORD *)(v2 + 49636);
  *(_DWORD *)(v2 + 49656) = 69;
  *(_DWORD *)(v2 + 49660) = v149;
  sub_10070810(0.0, (int)&v349, (int)&v350);
  v154 = v23 + 24 * v149;
  v155 = v149 + 1;
  v437 = *(float *)&v349 * 2.0 + *(float *)(v2 + 4) + 16.0;
  v156 = v437;
  v438 = 2.0 * *(float *)&v350;
  sub_100165C0(v438, v156, 0.0, 0.0, 0.0, -16777216, v154);
  v157 = v23 + 24 * v155;
  v158 = v155 + 1;
  v439 = *(float *)&v349 * 6.0 + *(float *)(v2 + 4) + 16.0;
  v159 = v439;
  v440 = 6.0 * *(float *)&v350;
  sub_100165C0(v440, v159, 0.0, 0.0, 0.0, -16777216, v157);
  v441 = 1;
  v354 = v23 + 24 * v158;
  do
  {
    v353 = (double)v441 * 6.283185482025146 / 10.0;
    sub_10070810(v353, (int)&v349, (int)&v350);
    v160 = v354;
    v354 += 24;
    v353 = *(float *)&v349 * 6.0 + *(float *)(v2 + 4) + 16.0;
    v161 = v353;
    v353 = 6.0 * *(float *)&v350;
    sub_100165C0(v353, v161, 0.0, 0.0, 0.0, -16777216, v160);
    v162 = v354;
    v158 += 2;
    v354 += 24;
    v353 = *(float *)&v349 * 2.0 + *(float *)(v2 + 4) + 16.0;
    v163 = v353;
    v353 = 2.0 * *(float *)&v350;
    sub_100165C0(v353, v163, 0.0, 0.0, 0.0, -16777216, v162);
    v139 = __OFSUB__(v441 + 1, 10);
    v60 = v441 == 9;
    v138 = v441++ - 9 < 0;
  }
  while ( (unsigned __int8)(v138 ^ v139) | v60 );
  v164 = v23 + 24 * v158;
  *(_DWORD *)(v2 + 49664) = v158 - *(_DWORD *)(v2 + 49660);
  *(_DWORD *)(v2 + 49668) = 69;
  *(_DWORD *)(v2 + 49672) = v158;
  v165 = v158 + 1;
  v442 = *(float *)(v2 + 4) + 16.0 - 5.0;
  sub_100165C0(-1.2, v442, 0.0, 0.0, 0.0, -16777216, v164);
  v166 = v23 + 24 * v165++;
  v443 = *(float *)(v2 + 4) + 16.0 - 5.0;
  sub_100165C0(1.2, v443, 0.0, 0.0, 0.0, -16777216, v166);
  v167 = v23 + 24 * v165++;
  v444 = *(float *)(v2 + 4) + 16.0 + 5.0;
  sub_100165C0(-1.2, v444, 0.0, 0.0, 0.0, -16777216, v167);
  v168 = v23 + 24 * v165++;
  v445 = *(float *)(v2 + 4) + 16.0 + 5.0;
  sub_100165C0(1.2, v445, 0.0, 0.0, 0.0, -16777216, v168);
  *(_DWORD *)(v2 + 49676) = v165 - *(_DWORD *)(v2 + 49672);
  *(_DWORD *)(v2 + 49184) = v165;
  sub_10016660(&unk_101B0878, 0, v2 + 12320, (_DWORD *)(24 * v165), 0x9000u);
  *(_DWORD *)(v2 + 12316) = 0;
  *(_DWORD *)(v2 + 49440) = 67;
  *(_DWORD *)(v2 + 49444) = 0;
  v169 = *(float *)(v2 + 51652) - 4.5 - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2));
  v446 = v169 - *(float *)(v2 + 51700) * 3.0 - (*(float *)(v2 + 51696) + 1.0) - 3.0;
  v348 = v169;
  v351 = -*(float *)(v2 + 51684) - 4.0;
  *(float *)&v352 = *(float *)(v2 + 51680) + 4.0;
  sub_100165C0(v348, v351, 0.0, 0.0, 0.0, -16728064, v2 + 28);
  sub_100165C0(v446, v351, 0.0, 0.0, 0.0, -16728064, v2 + 52);
  sub_100165C0(v446, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v2 + 76);
  sub_100165C0(v348, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v2 + 100);
  *(float *)&v354 = *(float *)&v352 + 1.0;
  sub_100165C0(v348, *(float *)&v354, 0.0, 0.0, 0.0, -16728064, v2 + 124);
  v447 = v446 - 1.0;
  sub_100165C0(v447, *(float *)&v354, 0.0, 0.0, 0.0, -16728064, v2 + 148);
  *(float *)&v354 = v351 - 1.0;
  sub_100165C0(v447, *(float *)&v354, 0.0, 0.0, 0.0, -16728064, v2 + 172);
  v347 = 8;
  sub_100165C0(v348, *(float *)&v354, 0.0, 0.0, 0.0, -16728064, v2 + 196);
  *(_DWORD *)(v2 + 49448) = 8 - *(_DWORD *)(v2 + 49444);
  *(_DWORD *)(v2 + 49344) = 68;
  *(_DWORD *)(v2 + 49348) = 8;
  v448 = 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       - (*(float *)(v2 + 51668)
        + 6.0);
  v170 = v448;
  v449 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_1002B400(v2 + 28, &v347, (int)&unk_100A547C, -1, v2 + 51628, v449, v170, 1.0, 0.5);
  v450 = 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5;
  v171 = v450;
  v451 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_1002B400(v2 + 28, &v347, dword_102D2B4C + 7664, -1, v2 + 51628, v451, v171, 1.0, 0.5);
  v452 = *(float *)(v2 + 51668)
       + 6.0
       + 0.5 * (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2))
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5;
  v172 = v452;
  v453 = *(float *)(v2 + 51652)
       - 4.5
       - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2))
       - (*(float *)(v2 + 51696)
        + 1.0);
  sub_1002B400(v2 + 28, &v347, (int)&unk_100A5478, -1, v2 + 51628, v453, v172, 1.0, 0.5);
  *(_DWORD *)(v2 + 49352) = v347 - *(_DWORD *)(v2 + 49348);
  sub_10028C00(&unk_100A5340, v2 + 49236, 0.0, 0.0, *(float *)(v2 + 4), 0, 2, &v347, v2 + 28, 1);
  v173 = v347;
  v348 = *(float *)(v2 + 4) - 5.0;
  v174 = v2 + 28 + 24 * v347;
  *(float *)(v2 + 51128) = 9.8999998e24;
  *(_DWORD *)(v2 + 51136) = 68;
  *(_DWORD *)(v2 + 51140) = v173++;
  sub_100165C0(0.0, 0.0, 0.0, 0.0, 0.0, -16728064, v174);
  v175 = v2 + 28 + 24 * v173;
  v454 = 0.8500000238418579 * v348;
  ++v173;
  *(float *)&v354 = -v348 * 0.07000000029802322;
  sub_100165C0(*(float *)&v354, v454, 0.0, 0.0, 0.0, -16728064, v175);
  v176 = v2 + 28 + 24 * v173;
  v353 = v348 * 0.07000000029802322;
  ++v173;
  sub_100165C0(v353, v454, 0.0, 0.0, 0.0, -16728064, v176);
  v177 = v2 + 28 + 24 * v173++;
  sub_100165C0(*(float *)&v354, v454, 0.0, 0.0, 0.0, -16728064, v177);
  v178 = v2 + 28 + 24 * v173++;
  sub_100165C0(0.0, v348, 0.0, 0.0, 0.0, -16728064, v178);
  v179 = v2 + 28 + 24 * v173++;
  sub_100165C0(v353, v454, 0.0, 0.0, 0.0, -16728064, v179);
  v180 = v2 + 28 + 24 * v173;
  *(_DWORD *)(v2 + 51144) = v173 - *(_DWORD *)(v2 + 51140);
  *(_DWORD *)(v2 + 51148) = 67;
  *(_DWORD *)(v2 + 51152) = v173++;
  sub_100165C0(0.0, 0.0, 0.0, 0.0, 0.0, -16777216, v180);
  v181 = v2 + 28 + 24 * v173++;
  sub_100165C0(*(float *)&v354, v454, 0.0, 0.0, 0.0, -16777216, v181);
  v182 = v2 + 28 + 24 * v173++;
  sub_100165C0(0.0, v348, 0.0, 0.0, 0.0, -16777216, v182);
  v183 = v2 + 28 + 24 * v173++;
  sub_100165C0(v353, v454, 0.0, 0.0, 0.0, -16777216, v183);
  v184 = v2 + 28 + 24 * v173++;
  sub_100165C0(0.0, 0.0, 0.0, 0.0, 0.0, -16777216, v184);
  *(_DWORD *)(v2 + 51156) = v173 - *(_DWORD *)(v2 + 51152);
  v185 = v2 + 28 + 24 * v173;
  v348 = *(float *)(v2 + 16) * 0.75;
  *(float *)&v352 = *(float *)(v2 + 16) * 0.25;
  *(float *)(v2 + 51160) = 9.8999998e24;
  *(_DWORD *)(v2 + 51168) = 68;
  v186 = v348;
  *(_DWORD *)(v2 + 51172) = v173++;
  v353 = v186 * -0.02999999932944775;
  sub_100165C0(v353, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v185);
  v187 = v2 + 28 + 24 * v173;
  v455 = 0.8500000238418579 * v348;
  ++v173;
  *(float *)&v347 = v348 * -0.07999999821186066;
  sub_100165C0(*(float *)&v347, v455, 0.0, 0.0, 0.0, -16728064, v187);
  v188 = v2 + 28 + 24 * v173;
  v351 = v348 * 0.02999999932944775;
  ++v173;
  sub_100165C0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v188);
  v189 = v2 + 28 + 24 * v173++;
  sub_100165C0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v189);
  v190 = v2 + 28 + 24 * v173++;
  sub_100165C0(*(float *)&v347, v455, 0.0, 0.0, 0.0, -16728064, v190);
  v191 = v2 + 28 + 24 * v173;
  *(float *)&v354 = v348 * 0.07999999821186066;
  ++v173;
  sub_100165C0(*(float *)&v354, v455, 0.0, 0.0, 0.0, -16728064, v191);
  v192 = v2 + 28 + 24 * v173++;
  sub_100165C0(*(float *)&v347, v455, 0.0, 0.0, 0.0, -16728064, v192);
  v193 = v2 + 28 + 24 * v173++;
  sub_100165C0(0.0, v348, 0.0, 0.0, 0.0, -16728064, v193);
  v194 = v2 + 28 + 24 * v173++;
  sub_100165C0(*(float *)&v354, v455, 0.0, 0.0, 0.0, -16728064, v194);
  v195 = v2 + 28 + 24 * v173;
  v196 = *(float *)&v352;
  *(_DWORD *)(v2 + 51176) = v173 - *(_DWORD *)(v2 + 51172);
  v197 = v196;
  *(_DWORD *)(v2 + 51180) = 67;
  v198 = v353;
  *(_DWORD *)(v2 + 51184) = v173;
  v199 = v198;
  ++v173;
  sub_100165C0(v199, v197, 0.0, 0.0, 0.0, -16777216, v195);
  v200 = v2 + 28 + 24 * v173++;
  sub_100165C0(*(float *)&v347, v455, 0.0, 0.0, 0.0, -16777216, v200);
  v201 = v2 + 28 + 24 * v173++;
  sub_100165C0(0.0, v348, 0.0, 0.0, 0.0, -16777216, v201);
  v202 = v2 + 28 + 24 * v173++;
  sub_100165C0(*(float *)&v354, v455, 0.0, 0.0, 0.0, -16777216, v202);
  v203 = v2 + 28 + 24 * v173++;
  sub_100165C0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16777216, v203);
  v204 = v2 + 28 + 24 * v173++;
  sub_100165C0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16777216, v204);
  *(_DWORD *)(v2 + 51188) = v173 - *(_DWORD *)(v2 + 51184);
  v205 = v2 + 28 + 24 * v173;
  v348 = *(float *)(v2 + 16) - 5.0;
  *(float *)(v2 + 51192) = 9.8999998e24;
  *(_DWORD *)(v2 + 51200) = 68;
  v206 = v348;
  *(_DWORD *)(v2 + 51204) = v173++;
  v353 = v206 * -0.02999999932944775;
  sub_100165C0(v353, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v205);
  v207 = v2 + 28 + 24 * v173;
  v456 = v348 * 0.8500000238418579;
  ++v173;
  sub_100165C0(v353, v456, 0.0, 0.0, 0.0, -16728064, v207);
  v208 = v2 + 28 + 24 * v173;
  v351 = v348 * 0.02999999932944775;
  ++v173;
  sub_100165C0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v208);
  v209 = v2 + 28 + 24 * v173++;
  sub_100165C0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16728064, v209);
  v210 = v2 + 28 + 24 * v173++;
  sub_100165C0(v353, v456, 0.0, 0.0, 0.0, -16728064, v210);
  v211 = v2 + 28 + 24 * v173++;
  sub_100165C0(v351, v456, 0.0, 0.0, 0.0, -16728064, v211);
  v212 = v2 + 28 + 24 * v173;
  *(float *)&v347 = v348 * -0.07999999821186066;
  ++v173;
  sub_100165C0(*(float *)&v347, v456, 0.0, 0.0, 0.0, -16728064, v212);
  v213 = v2 + 28 + 24 * v173++;
  sub_100165C0(0.0, v348, 0.0, 0.0, 0.0, -16728064, v213);
  v214 = v2 + 28 + 24 * v173;
  *(float *)&v354 = v348 * 0.07999999821186066;
  ++v173;
  sub_100165C0(*(float *)&v354, v456, 0.0, 0.0, 0.0, -16728064, v214);
  v215 = v2 + 28 + 24 * v173;
  v216 = *(float *)&v352;
  *(_DWORD *)(v2 + 51208) = v173 - *(_DWORD *)(v2 + 51204);
  v217 = v216;
  *(_DWORD *)(v2 + 51212) = 67;
  v218 = v353;
  *(_DWORD *)(v2 + 51216) = v173;
  v219 = v218;
  ++v173;
  sub_100165C0(v219, v217, 0.0, 0.0, 0.0, -16777216, v215);
  v220 = v2 + 28 + 24 * v173++;
  sub_100165C0(v353, v456, 0.0, 0.0, 0.0, -16777216, v220);
  v221 = v2 + 28 + 24 * v173++;
  sub_100165C0(*(float *)&v347, v456, 0.0, 0.0, 0.0, -16777216, v221);
  v222 = v2 + 28 + 24 * v173++;
  sub_100165C0(0.0, v348, 0.0, 0.0, 0.0, -16777216, v222);
  v223 = v2 + 28 + 24 * v173++;
  sub_100165C0(*(float *)&v354, v456, 0.0, 0.0, 0.0, -16777216, v223);
  v224 = v2 + 28 + 24 * v173++;
  sub_100165C0(v351, v456, 0.0, 0.0, 0.0, -16777216, v224);
  v225 = v2 + 28 + 24 * v173++;
  sub_100165C0(v351, *(float *)&v352, 0.0, 0.0, 0.0, -16777216, v225);
  v226 = 3 * v173++;
  v347 = v173;
  sub_100165C0(v353, *(float *)&v352, 0.0, 0.0, 0.0, -16777216, v2 + 28 + 8 * v226);
  *(_DWORD *)(v2 + 51220) = v173 - *(_DWORD *)(v2 + 51216);
  sub_1002BCB0(v2, &v347);
  v227 = v347;
  *(_DWORD *)(v2 + 51264) = 68;
  *(_DWORD *)(v2 + 51268) = v227;
  v457 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2));
  v228 = v457;
  v348 = *(float *)(v2 + 51652) - 4.5 - v457;
  v229 = v2 + 28 + 24 * v227;
  v230 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v458 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)((*(float *)(v2 + 51668) + 6.0) * 2.0 + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5
       - (*(float *)(v2 + 51668)
        + 6.0);
  *(float *)&v354 = v458 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) + 2.0;
  v231 = *(float *)&v354;
  *(float *)&v354 = v228 + v348;
  sub_100165C0(*(float *)&v354, v231, 0.0, 0.0, 0.0, v230, v229);
  v232 = v2 + 28 + 24 * v227;
  v233 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v458;
  v234 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v234, 0.0, 0.0, 0.0, v233, v232);
  v235 = *(_DWORD *)(v2 + 51488);
  *(float *)&v352 = v348 + 1.0;
  v236 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v458;
  sub_100165C0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v235, v236);
  v237 = v2 + 28 + 24 * v227;
  v238 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v458;
  sub_100165C0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v238, v237);
  v239 = v2 + 28 + 24 * v227;
  v240 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_100165C0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v240, v239);
  v241 = v2 + 28 + 24 * v227;
  v242 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  v243 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v243, 0.0, 0.0, 0.0, v242, v241);
  v244 = v2 + 28 + 24 * v227;
  v245 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  v246 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v246, 0.0, 0.0, 0.0, v245, v244);
  v247 = v2 + 28 + 24 * v227;
  v248 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  v249 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v249, 0.0, 0.0, 0.0, v248, v247);
  v250 = v2 + 28 + 24 * v227++;
  v251 = *(_DWORD *)(v2 + 51488);
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  v252 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v252, 0.0, 0.0, 0.0, v251, v250);
  v253 = v2 + 28 + 24 * v227;
  v254 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  v255 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v255, 0.0, 0.0, 0.0, v254, v253);
  v256 = v2 + 28 + 24 * v227;
  v257 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  v258 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v258, 0.0, 0.0, 0.0, v257, v256);
  v259 = *(_DWORD *)(v2 + 51488);
  v351 = v348 + 3.0;
  v260 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v259, v260);
  v261 = v2 + 28 + 24 * v227;
  v262 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v262, v261);
  v263 = v2 + 28 + 24 * v227;
  v264 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  v265 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v265, 0.0, 0.0, 0.0, v264, v263);
  v266 = v2 + 28 + 24 * v227;
  v267 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v267, v266);
  v268 = v2 + 28 + 24 * v227;
  v269 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 0.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v269, v268);
  v270 = v2 + 28 + 24 * v227;
  v271 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v271, v270);
  v272 = v2 + 28 + 24 * v227++;
  v459 = v458 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 2.0;
  sub_100165C0(*(float *)&v352, v459, 0.0, 0.0, 0.0, *(_DWORD *)(v2 + 51488), v272);
  *(_DWORD *)(v2 + 51272) = v227 - *(_DWORD *)(v2 + 51268);
  *(_DWORD *)(v2 + 51316) = 68;
  *(_DWORD *)(v2 + 51320) = v227;
  v348 = *(float *)(v2 + 51652) - 4.5 - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2));
  v273 = v2 + 28 + 24 * v227;
  v274 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v460 = (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5;
  *(float *)&v352 = v348 + 1.0;
  *(float *)&v354 = 1.0 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) + v460;
  sub_100165C0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v274, v273);
  v275 = v2 + 28 + 24 * v227;
  v276 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v460 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v277 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v277, 0.0, 0.0, 0.0, v276, v275);
  v278 = v2 + 28 + 24 * v227;
  v279 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v460;
  sub_100165C0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v279, v278);
  v280 = v2 + 28 + 24 * v227++;
  v281 = *(_DWORD *)(v2 + 51488);
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v460;
  sub_100165C0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v281, v280);
  v282 = v2 + 28 + 24 * v227;
  v283 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v460 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v284 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v284, 0.0, 0.0, 0.0, v283, v282);
  v285 = v2 + 28 + 24 * v227;
  v286 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v354 = 2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2);
  v461 = (double)v354 * 0.5 + v460;
  v287 = v461;
  v462 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(v462, v287, 0.0, 0.0, 0.0, v286, v285);
  *(_DWORD *)(v2 + 51324) = v227 - *(_DWORD *)(v2 + 51320);
  *(_DWORD *)(v2 + 51368) = 68;
  *(_DWORD *)(v2 + 51372) = v227;
  v348 = *(float *)(v2 + 51652) - 4.5 - (double)(2 * ((signed int)(4.5 * *(float *)(v2 + 51704) + 6.0) / 2));
  v288 = v2 + 28 + 24 * v227;
  v289 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v463 = *(float *)(v2 + 51668)
       + 6.0
       + (double)(signed int)((double)(signed int)((double)(signed int)((double)(2
                                                                               * ((signed int)(*(float *)(v2 + 51664)
                                                                                             + 4.0)
                                                                                / 2))
                                                                      * 0.5
                                                                      + 2.0)
                                                 + 0.5
                                                 + *(float *)(v2 + 51664) * 1.5)
                            + 0.5
                            + *(float *)(v2 + 51664)
                            - 1.0)
       + 0.5
       + (double)(2 * ((signed int)(2.0 * (*(float *)(v2 + 51668) + 6.0) + *(float *)(v2 + 51668) + 10.0) / 2)) * 0.5;
  *(float *)&v352 = v348 + 1.0;
  *(float *)&v354 = 1.0 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) + v463;
  sub_100165C0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v289, v288);
  v290 = v2 + 28 + 24 * v227;
  v291 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v463 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v292 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v292, 0.0, 0.0, 0.0, v291, v290);
  v293 = v2 + 28 + 24 * v227;
  v294 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_100165C0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v294, v293);
  v295 = v2 + 28 + 24 * v227;
  v296 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_100165C0(*(float *)&v352, *(float *)&v354, 0.0, 0.0, 0.0, v296, v295);
  v297 = v2 + 28 + 24 * v227;
  v298 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = v463 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v299 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v299, 0.0, 0.0, 0.0, v298, v297);
  v300 = v2 + 28 + 24 * v227;
  v301 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  v302 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v302, 0.0, 0.0, 0.0, v301, v300);
  v303 = v2 + 28 + 24 * v227;
  v304 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  v305 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v305, 0.0, 0.0, 0.0, v304, v303);
  v306 = v2 + 28 + 24 * v227;
  v307 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  v308 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v308, 0.0, 0.0, 0.0, v307, v306);
  v309 = v2 + 28 + 24 * v227;
  v310 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  v311 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v311, 0.0, 0.0, 0.0, v310, v309);
  v312 = v2 + 28 + 24 * v227;
  v313 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  v314 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v314, 0.0, 0.0, 0.0, v313, v312);
  v315 = v2 + 28 + 24 * v227;
  v316 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  v317 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v317, 0.0, 0.0, 0.0, v316, v315);
  v318 = v2 + 28 + 24 * v227++;
  v351 = v348 + 3.0;
  v319 = *(_DWORD *)(v2 + 51488);
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v319, v318);
  v320 = v2 + 28 + 24 * v227;
  v321 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v321, v320);
  v322 = v2 + 28 + 24 * v227;
  v323 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  v324 = *(float *)&v354;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 4.5 + 6.0) / 2)) + v348 - 2.0;
  sub_100165C0(*(float *)&v354, v324, 0.0, 0.0, 0.0, v323, v322);
  v325 = v2 + 28 + 24 * v227;
  v326 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v326, v325);
  v327 = v2 + 28 + 24 * v227;
  v328 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 + 1.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v328, v327);
  v329 = v2 + 28 + 24 * v227;
  v330 = *(_DWORD *)(v2 + 51488);
  ++v227;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v463 - 1.0;
  sub_100165C0(v351, *(float *)&v354, 0.0, 0.0, 0.0, v330, v329);
  v331 = v2 + 28 + 24 * v227;
  v332 = *(_DWORD *)(v2 + 51488);
  ++v227;
  v354 = 2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2);
  v464 = (double)v354 * 0.5 + v463 - 1.0;
  sub_100165C0(*(float *)&v352, v464, 0.0, 0.0, 0.0, v332, v331);
  *(_DWORD *)(v2 + 51376) = v227 - *(_DWORD *)(v2 + 51372);
  *(_DWORD *)(v2 + 51420) = 68;
  *(_DWORD *)(v2 + 51424) = v227;
  v333 = (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) * 0.5;
  v334 = v2 + 28 + 24 * v227++;
  v348 = *(float *)(v2 + 51652) - 4.5 - v333;
  v465 = *(float *)(v2 + 24);
  *(float *)&v354 = v465 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) + 1.0;
  v335 = *(float *)&v354;
  *(float *)&v354 = v348 - v333 + 1.0;
  sub_100165C0(*(float *)&v354, v335, 0.0, 0.0, 0.0, -16777216, v334);
  v336 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = v465 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v337 = *(float *)&v354;
  *(float *)&v354 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v337, 0.0, 0.0, 0.0, -16777216, v336);
  v338 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v465;
  v339 = *(float *)&v354;
  *(float *)&v354 = v348 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + 1.0;
  sub_100165C0(*(float *)&v354, v339, 0.0, 0.0, 0.0, -16777216, v338);
  v340 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + v465;
  v341 = *(float *)&v354;
  *(float *)&v354 = v348 - 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + 1.0;
  sub_100165C0(*(float *)&v354, v341, 0.0, 0.0, 0.0, -16777216, v340);
  v342 = v2 + 28 + 24 * v227++;
  *(float *)&v354 = v465 - (double)(2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2)) * 0.5 + 1.0;
  v343 = *(float *)&v354;
  *(float *)&v354 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_100165C0(*(float *)&v354, v343, 0.0, 0.0, 0.0, -16777216, v342);
  v344 = v2 + 28 + 24 * v227++;
  v354 = 2 * ((signed int)(*(float *)(v2 + 51668) + 7.0) / 2);
  v466 = (double)v354 * 0.5 + v465;
  v345 = v466;
  v467 = 0.5 * (double)(2 * ((signed int)(*(float *)(v2 + 51704) * 3.0 + 6.0) / 2)) + v348;
  sub_100165C0(v467, v345, 0.0, 0.0, 0.0, -16777216, v344);
  *(_DWORD *)(v2 + 51428) = v227 - *(_DWORD *)(v2 + 51424);
  *(_DWORD *)(v2 + 12316) = v227;
  sub_10016660(&unk_101B0884, 0, v2 + 28, (_DWORD *)(24 * v227), 0x3000u);
  *(float *)(v2 + 51128) = 0.0;
  *(float *)(v2 + 51160) = 0.0;
  *(float *)(v2 + 51192) = 0.0;
  return 2;
}
// 10028C00: using guessed type int __cdecl sub_10028C00(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102D2B4C: using guessed type int dword_102D2B4C;

//----- (10032950) --------------------------------------------------------
unsigned int __cdecl sub_10032950(int a1)
{
  int v1; // ebp@1
  char v2; // al@1
  bool v3; // zf@1
  int v4; // eax@1
  bool v5; // al@3
  void *v6; // ecx@7
  int *v7; // esi@18
  float *v8; // ebx@18
  int v9; // edx@20
  double v10; // st7@20
  _DWORD *v11; // ebx@25
  float *v12; // esi@25
  char v13; // dl@25
  double v14; // st7@28
  double v15; // st7@28
  float v16; // ecx@35
  int *v17; // esi@38
  float *v18; // ebx@38
  char v19; // dl@38
  int v20; // eax@41
  double v21; // st7@41
  int v22; // eax@49
  _BYTE *v23; // ebx@49
  int v24; // ecx@50
  unsigned __int8 v25; // al@51
  int v26; // esi@58
  double v27; // st7@61
  bool v28; // c3@63
  int *v29; // esi@64
  int v30; // edi@64
  char v31; // dl@64
  int v32; // esi@75
  bool v33; // al@77
  bool v34; // al@81
  double v35; // ST0C_8@83
  char *v36; // ebx@83
  int v37; // edx@87
  unsigned int result; // eax@88
  float v39; // [sp+18h] [bp-10h]@17
  int v40; // [sp+1Ch] [bp-Ch]@11
  float v41; // [sp+20h] [bp-8h]@20
  float v42; // [sp+24h] [bp-4h]@20

  v1 = a1;
  *(_BYTE *)(a1 + 51608) = 1;
  *(_BYTE *)(v1 + 51607) = 0;
  *(_BYTE *)(v1 + 51610) = sub_1003E540((int)"_start_mode");
  v2 = sub_1003E540((int)"_autorotation");
  *(_BYTE *)(v1 + 51602) = v2;
  v3 = v2 == 0;
  v4 = v1 + 50728;
  if ( v3 )
    v4 = v1 + 50332;
  *(_DWORD *)(v1 + 51124) = v4;
  *(_BYTE *)(v1 + 51609) = sub_1003E540((int)"_cyc_ctr");
  *(_BYTE *)(v1 + 51603) = sub_1003E540((int)"_quiet_mode");
  *(_BYTE *)(v1 + 51605) = sub_1003E540((int)"_engine_out");
  *(_BYTE *)(v1 + 51606) = sub_1003E540((int)"_manual_mode");
  *(_BYTE *)(v1 + 51613) = sub_1003E540((int)"_nr_inhibit");
  sub_1002B990(24, 0, v1);
  sub_1002B990(22, 1, v1);
  sub_1002B990(20, 2, v1);
  v5 = sub_1002B6A0(v1);
  if ( v5 != *(_BYTE *)(v1 + 51615) )
  {
    *(_BYTE *)(v1 + 51615) = v5;
    if ( v5 )
      sub_10028A00(v1);
    else
      sub_10028B00(v1);
  }
  sub_10016380(41114, v1 + 51572, 20);
  sub_1002BB20(v6, v1);
  sub_1002B990(26, 3, v1);
  sub_1002B990(26, 4, v1);
  if ( !sub_1003E540((int)"_to_timer") || *(_BYTE *)(v1 + 51610) && *(_BYTE *)(v1 + 51484) == 1 )
  {
    if ( *(_DWORD *)(v1 + 51596) )
    {
      v40 = 0;
      sub_10016450(9212, (int)&v40, 4);
    }
    *(_DWORD *)(v1 + 51596) = 0;
    *(_BYTE *)(v1 + 51600) = 0;
  }
  else if ( !*(_DWORD *)(v1 + 51596) )
  {
    sub_10016380(9212, (int)&v40, 4);
    if ( !v40 )
    {
      v40 = 300000;
      sub_10016450(9212, (int)&v40, 4);
    }
    *(_DWORD *)(v1 + 51596) = v40 + sub_100160A0();
    sub_10038570((char *)(v1 + 51432), 8u, "05:00");
  }
  v39 = -1.0;
  *(float *)(v1 + 51544) = 1000.0;
  if ( 9.8999998e24 == *(float *)(v1 + 51720) )
  {
    sub_10038570((char *)(v1 + 51224), 8u, "     ");
    sub_1002BAE0(v1 + 51264, v1, -16777216);
    *(float *)(v1 + 51520) = -1000.0;
  }
  else
  {
    v7 = (int *)(v1 + 51240);
    v8 = (float *)(v1 + 51532);
    sub_1002C250(v1 + 51532, 2, 14, (float *)(v1 + 49828), v1 + 51720, v1 + 51520, (_DWORD *)(v1 + 51240));
    if ( *(_BYTE *)(v1 + 51605) )
      *v7 = -8355712;
    v9 = *v7;
    v39 = *(float *)(v1 + 51520);
    LOBYTE(a1) = 0;
    v10 = *v8;
    *(_DWORD *)(v1 + 51132) = v9;
    v42 = v10;
    v41 = *(float *)(v1 + 50260) - *(float *)(v1 + 51520);
    if ( *(float *)(v1 + 50260) - *v8 < 0.0 )
      *v7 = -65536;
    *(float *)(v1 + 51544) = v41;
    sub_10038570((char *)(v1 + 51224), 8u, "%5.1f", *(float *)(v1 + 51724));
    *(_DWORD *)(v1 + 51492) = *v7;
    sub_1002BC50(v1, v1 + 51224);
  }
  if ( 9.8999998e24 == *(float *)(v1 + 51776) )
  {
    sub_10038570((char *)(v1 + 51276), 8u, "    ");
    sub_1002BAE0(v1 + 51316, v1, -16777216);
    *(float *)(v1 + 51524) = -1000.0;
  }
  else
  {
    v11 = (_DWORD *)(v1 + 51292);
    v12 = (float *)(v1 + 51524);
    sub_1002C250(v1 + 51536, 1, 14, (float *)(v1 + 49828), v1 + 51776, v1 + 51524, (_DWORD *)(v1 + 51292));
    if ( *(_BYTE *)(v1 + 51605) )
      *v11 = -8355712;
    if ( v39 < (double)*v12 )
    {
      v14 = *v12;
      LOBYTE(a1) = v13;
      v39 = v14;
      v15 = *(float *)(v1 + 51536);
      *(_DWORD *)(v1 + 51132) = *v11;
      v42 = v15;
    }
    v41 = *(float *)(v1 + 51560);
    if ( sub_1003E540((int)"_mgt_lo_trans") )
      v41 = *(float *)(v1 + 51556);
    sub_1002B7E0(1, (float *)(v1 + 49828), 14, v41, v1 + 51568);
    v41 = *(float *)(v1 + 50260) - *v12;
    if ( *(float *)(v1 + 50260) - *(float *)(v1 + 51536) < 0.0 )
      *(_DWORD *)(v1 + 51292) = -65536;
    if ( *(float *)(v1 + 51544) > (double)v41 )
      *(float *)(v1 + 51544) = v41;
    sub_10038570((char *)(v1 + 51276), 8u, "%4.0f", *(float *)(v1 + 51780));
    *(_DWORD *)(v1 + 51496) = *(_DWORD *)(v1 + 51292);
    sub_1002BC50(v1, v1 + 51276);
  }
  if ( 9.8999998e24 == *(float *)(v1 + 51832) )
  {
    sub_10038570((char *)(v1 + 51328), 8u, "     ");
    sub_1002BAE0(v1 + 51368, v1, -16777216);
    *(float *)(v1 + 51528) = -1000.0;
  }
  else
  {
    *(float *)(v1 + 50240) = sub_1002B790(v1, v16);
    v17 = (int *)(v1 + 51344);
    v18 = (float *)(v1 + 51528);
    sub_1002C250(v1 + 51540, 0, 14, (float *)(v1 + 49828), v1 + 51832, v1 + 51528, (_DWORD *)(v1 + 51344));
    if ( *(_BYTE *)(v1 + 51605) != v19 )
      *v17 = -8355712;
    if ( v39 < (double)*v18 )
    {
      v20 = *v17;
      v39 = *v18;
      LOBYTE(a1) = 2;
      v21 = *(float *)(v1 + 51540);
      *(_DWORD *)(v1 + 51132) = v20;
      v42 = v21;
    }
    v41 = *(float *)(v1 + 50224) - *v18;
    if ( *(float *)(v1 + 50224) - *(float *)(v1 + 51540) < 0.0 )
      *v17 = -65536;
    if ( *(float *)(v1 + 51544) > (double)v41 )
      *(float *)(v1 + 51544) = v41;
    sub_10038570((char *)(v1 + 51328), 8u, "%5.1f", *(float *)(v1 + 51836));
    *(_DWORD *)(v1 + 51500) = *v17;
    sub_1002BC50(v1, v1 + 51328);
  }
  if ( v39 <= -1.0 )
  {
    *(_DWORD *)(v1 + 51132) = -16777216;
    v27 = 9.8999998e24;
    *(float *)(v1 + 51128) = 9.8999998e24;
  }
  else
  {
    v22 = *(_BYTE *)(v1 + 51484);
    *(float *)(v1 + 51128) = v39;
    v23 = (_BYTE *)(v1 + 51484);
    if ( v39 - *(float *)(v1 + 4 * v22 + 51520) > 3.0 )
    {
      v24 = (unsigned __int8)a1;
      *v23 = a1;
      *(float *)(v1 + 51516) = *(float *)(v1 + 4 * v24 + 51504);
      sub_10016450(9213, v1 + 51484, 1);
    }
    sub_10016380(9213, (int)&a1, 1);
    v25 = a1;
    if ( *v23 != (_BYTE)a1 )
    {
      *v23 = a1;
      *(float *)(v1 + 51516) = *(float *)(v1 + 4 * v25 + 51504);
    }
    if ( *(float *)(v1 + 51548) < (double)v42 )
      *(_DWORD *)(v1 + 51132) = -65536;
    if ( *(_DWORD *)(v1 + 51132) == -16728064 && *(_BYTE *)(v1 + 51606) )
      *(_DWORD *)(v1 + 51132) = -16711681;
    sub_1002BAE0(v1 + 51136, v1, *(_DWORD *)(v1 + 51132));
    v26 = *(_DWORD *)(v1 + 4 * *v23 + 51492);
    if ( v26 == -16728064 && *(_BYTE *)(v1 + 51606) )
      v26 = -16711681;
    sub_1002BAE0(v1 + 49440, v1, v26);
    *(float *)(v1 + 51552) = *(float *)(v1 + 51544) + v39;
    v27 = 9.8999998e24;
  }
  v28 = v27 == *(float *)(v1 + 51888);
  *(_BYTE *)(v1 + 51611) = 0;
  *(_BYTE *)(v1 + 51612) = 0;
  *(_BYTE *)(v1 + 51614) = 0;
  if ( v28 )
  {
    *(float *)(v1 + 51160) = v27;
  }
  else
  {
    v29 = (int *)(v1 + 51164);
    v30 = sub_1002C250(0, 0, 11, *(float **)(v1 + 51124), v1 + 51888, v1 + 51160, (_DWORD *)(v1 + 51164));
    if ( *(_BYTE *)(v1 + 51605) != v31 )
      *v29 = -8355712;
    v3 = *v29 == -65536;
    *(_BYTE *)(v1 + 51611) = *(float *)(*(_DWORD *)(v1 + 51124) + 72) > (double)*(float *)(v1 + 51160);
    *(_BYTE *)(v1 + 51612) = v3;
    if ( sub_1003E540((int)"_np_excess") )
      *v29 = -65536;
    if ( v30 >= 8 )
    {
      *v29 = -65536;
      *(_BYTE *)(v1 + 51614) = 1;
    }
    sub_1002BAE0(v1 + 51168, v1, *v29);
    v27 = 9.8999998e24;
  }
  if ( *(_BYTE *)(v1 + 51613) )
    *(float *)(v1 + 51944) = 0.0;
  if ( v27 == *(float *)(v1 + 51944) )
  {
    v36 = (char *)(v1 + 51380);
    sub_10038570((char *)(v1 + 51380), 8u, "   ");
    *(float *)(v1 + 51192) = 9.8999998e24;
    sub_1002BAE0(v1 + 51420, v1, -16777216);
  }
  else
  {
    sub_1002C250(0, 0, 11, *(float **)(v1 + 51124), v1 + 51944, v1 + 51192, (_DWORD *)(v1 + 51396));
    v32 = *(_DWORD *)(v1 + 51396);
    *(_DWORD *)(v1 + 51196) = v32;
    sub_1002BAE0(v1 + 51200, v1, v32);
    v33 = *(_BYTE *)(v1 + 51611) || *(float *)(*(_DWORD *)(v1 + 51124) + 72) > (double)*(float *)(v1 + 51192);
    v3 = *(_BYTE *)(v1 + 51612) == 0;
    *(_BYTE *)(v1 + 51611) = v33;
    v34 = !v3 || *(_DWORD *)(v1 + 51196) == -65536;
    v35 = *(float *)(v1 + 51948);
    v36 = (char *)(v1 + 51380);
    *(_BYTE *)(v1 + 51612) = v34;
    sub_10038570((char *)(v1 + 51380), 8u, "%3.0f", v35);
    sub_1002BC50(v1, v1 + 51380);
  }
  if ( *(_BYTE *)(v1 + 51613) )
  {
    sub_10038570(v36, 8u, "   ");
    sub_1002BAE0(v1 + 51420, v1, -16777216);
  }
  v37 = v1 + 49344;
  if ( *(_BYTE *)(v1 + 51605) )
    result = sub_1002BAE0(v37, v1, -8355712);
  else
    result = sub_1002BAE0(v37, v1, -1);
  return result;
}

//----- (100332A0) --------------------------------------------------------
char __usercall sub_100332A0@<al>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  int v3; // esi@1
  unsigned int v4; // eax@1
  unsigned int v5; // edi@1
  double v6; // st6@6
  bool v7; // cf@18
  bool v8; // zf@18
  float v9; // ST3C_4@24
  float v10; // ST38_4@24
  int v11; // eax@27
  int v12; // ecx@27
  int v13; // edx@27
  int v14; // eax@34
  int v15; // ecx@34
  int v16; // edx@34
  int v17; // eax@44
  int v18; // ecx@44
  int v19; // edx@44
  int v20; // ecx@48
  int v21; // edx@48
  int v22; // eax@48
  int v23; // edx@55
  int v24; // eax@55
  int v25; // ecx@55
  int v26; // edx@58
  int v27; // eax@58
  int v28; // ecx@58
  _DWORD *v29; // eax@66
  int v30; // ecx@75
  int v31; // edx@75
  int v32; // eax@75
  int v33; // ecx@87
  int v34; // eax@88
  int v35; // edi@92
  int v36; // ebp@92
  float v38; // [sp+1Ch] [bp-4h]@5
  float v39; // [sp+1Ch] [bp-4h]@14
  float v40; // [sp+24h] [bp+4h]@3
  float v41; // [sp+24h] [bp+4h]@12
  float v42; // [sp+24h] [bp+4h]@38
  float v43; // [sp+24h] [bp+4h]@85

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 16);
  v4 = sub_100160A0();
  v5 = v4;
  if ( 9.8999998e24 != *(float *)(v3 + 51552) )
  {
    if ( 9.8999998e24 == *(float *)(v3 + 51548) )
    {
      v6 = *(float *)(v3 + 51552);
    }
    else
    {
      v40 = (*(float *)(v3 + 51552) - *(float *)(v3 + 51548)) * *(float *)(v3 + 51708);
      if ( *(float *)(v3 + 51712) < (double)v40 )
        v40 = *(float *)(v3 + 51712);
      v38 = -*(float *)(v3 + 51712);
      if ( v38 <= (double)v40 )
        v6 = *(float *)(v3 + 51548) + v40;
      else
        v6 = *(float *)(v3 + 51548) + v38;
    }
    *(float *)(v3 + 51548) = v6;
  }
  if ( 9.8999998e24 != *(float *)(v3 + 51568) )
  {
    if ( 9.8999998e24 == *(float *)(v3 + 51564) )
    {
      *(float *)(v3 + 51564) = *(float *)(v3 + 51568);
    }
    else
    {
      v41 = (*(float *)(v3 + 51568) - *(float *)(v3 + 51564)) * *(float *)(v3 + 51708);
      if ( *(float *)(v3 + 51712) < (double)v41 )
        v41 = *(float *)(v3 + 51712);
      v39 = -*(float *)(v3 + 51712);
      if ( v39 <= (double)v41 )
        *(float *)(v3 + 51564) = v41 + *(float *)(v3 + 51564);
      else
        *(float *)(v3 + 51564) = v39 + *(float *)(v3 + 51564);
    }
  }
  v7 = v4 < *(_DWORD *)(v3 + 52000);
  v8 = v4 == *(_DWORD *)(v3 + 52000);
  *(_BYTE *)(v3 + 49824) = 0;
  if ( !v7 && !v8 )
  {
    *(_DWORD *)(v3 + 52000) = v4 + 75;
    sub_10032950(v3);
  }
  if ( v5 > *(_DWORD *)(v3 + 52004) )
  {
    *(_DWORD *)(v3 + 52004) = v5 + 175;
    sub_1002BCB0(v3, 0);
  }
  v8 = *(_BYTE *)(v3 + 49824) == 0;
  *(_BYTE *)(v3 + 49825) = 0;
  if ( !v8 )
    sub_10016660(&unk_101B0884, 0, v3 + 28, (_DWORD *)(24 * *(_DWORD *)(v3 + 12316)), 0x3000u);
  *(_BYTE *)v2 = *(_BYTE *)v3;
  j_gdi_pvg_push_matrix();
  v9 = (double)*(_WORD *)(a1 + 2);
  v10 = (double)*(_WORD *)a1;
  sub_10015920(v10, v9, 0.0);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_enable(38);
  sub_10016600((int)&unk_101B0878);
  if ( *(_BYTE *)(v2 + 1) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49188), *(_DWORD *)(v3 + 49192), *(_DWORD *)(v3 + 49196));
  sub_10015770(1.0);
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49200), *(_DWORD *)(v3 + 49204), *(_DWORD *)(v3 + 49208));
  if ( *(_BYTE *)(v3 + 51607) )
  {
    v11 = *(_DWORD *)(v3 + 49388);
    v12 = *(_DWORD *)(v3 + 49384);
    v13 = *(_DWORD *)(v3 + 49380);
  }
  else
  {
    if ( *(_BYTE *)(v3 + 51608) )
      goto LABEL_31;
    v11 = *(_DWORD *)(v3 + 49412);
    v12 = *(_DWORD *)(v3 + 49408);
    v13 = *(_DWORD *)(v3 + 49404);
  }
  j_gdi_pvg_draw_arrays(v13, v12, v11);
LABEL_31:
  if ( *(_BYTE *)(v3 + 51609) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49428), *(_DWORD *)(v3 + 49432), *(_DWORD *)(v3 + 49436));
  sub_10015770(1.0);
  if ( *(_DWORD *)(v3 + 51132) == -65536 )
  {
    v14 = *(_DWORD *)(v3 + 49484);
    v15 = *(_DWORD *)(v3 + 49480);
    v16 = *(_DWORD *)(v3 + 49476);
  }
  else
  {
    v14 = *(_DWORD *)(v3 + 49472);
    v15 = *(_DWORD *)(v3 + 49468);
    v16 = *(_DWORD *)(v3 + 49464);
  }
  j_gdi_pvg_draw_arrays(v16, v15, v14);
  if ( 9.8999998e24 != *(float *)(v3 + 51128) )
  {
    j_gdi_pvg_push_matrix();
    sub_10015920(*(float *)(v3 + 8), *(float *)(v3 + 12), 0.0);
    if ( 9.8999998e24 != *(float *)(v3 + 51548) )
    {
      j_gdi_pvg_push_matrix();
      v42 = *(float *)(v3 + 51548) - 198.0;
      sub_10015850(v42, 0.0, 0.0, 1.0);
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49488), *(_DWORD *)(v3 + 49492), *(_DWORD *)(v3 + 49496));
      j_gdi_pvg_pop_matrix();
    }
    if ( *(_BYTE *)(v3 + 51610) && 9.8999998e24 != *(float *)(v3 + 51564) )
    {
      sub_10015850(*(float *)(v3 + 51564), 0.0, 0.0, 1.0);
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49560), *(_DWORD *)(v3 + 49564), *(_DWORD *)(v3 + 49568));
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49572), *(_DWORD *)(v3 + 49576), *(_DWORD *)(v3 + 49580));
    }
    j_gdi_pvg_pop_matrix();
  }
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49212), *(_DWORD *)(v3 + 49216), *(_DWORD *)(v3 + 49220));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49224), *(_DWORD *)(v3 + 49228), *(_DWORD *)(v3 + 49232));
  if ( *(_BYTE *)(v3 + 51612) )
  {
    v17 = *(_DWORD *)(v3 + 49520);
    v18 = *(_DWORD *)(v3 + 49516);
    v19 = *(_DWORD *)(v3 + 49512);
  }
  else
  {
    v17 = *(_DWORD *)(v3 + 49508);
    v18 = *(_DWORD *)(v3 + 49504);
    v19 = *(_DWORD *)(v3 + 49500);
  }
  j_gdi_pvg_draw_arrays(v19, v18, v17);
  if ( *(_DWORD *)(v3 + 51124) == v3 + 50332 )
  {
    if ( *(_BYTE *)(v3 + 51611) )
    {
      v20 = *(_DWORD *)(v3 + 49556);
      v21 = *(_DWORD *)(v3 + 49552);
      v22 = *(_DWORD *)(v3 + 49548);
    }
    else
    {
      v20 = *(_DWORD *)(v3 + 49544);
      v21 = *(_DWORD *)(v3 + 49540);
      v22 = *(_DWORD *)(v3 + 49536);
    }
    j_gdi_pvg_draw_arrays(v22, v21, v20);
  }
  if ( *(_BYTE *)(v3 + 51603) )
  {
    j_gdi_pvg_push_matrix();
    sub_10015920(*(float *)(v3 + 20), *(float *)(v3 + 24), 0.0);
    sub_10015850(*(float *)(*(_DWORD *)(v3 + 51124) + 180), 0.0, 0.0, 1.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49584), *(_DWORD *)(v3 + 49588), *(_DWORD *)(v3 + 49592));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49596), *(_DWORD *)(v3 + 49600), *(_DWORD *)(v3 + 49604));
    j_gdi_pvg_pop_matrix();
  }
  if ( *(_BYTE *)(v3 + 51604) )
  {
    j_gdi_pvg_push_matrix();
    sub_10015920(*(float *)(v3 + 8), *(float *)(v3 + 12), 0.0);
    sub_10015850(*(float *)(v3 + 51592), 0.0, 0.0, 1.0);
    if ( *(_BYTE *)(v3 + 51589) )
    {
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49632), *(_DWORD *)(v3 + 49636), *(_DWORD *)(v3 + 49640));
      v23 = *(_DWORD *)(v3 + 49652);
      v24 = *(_DWORD *)(v3 + 49648);
      v25 = *(_DWORD *)(v3 + 49644);
    }
    else
    {
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49608), *(_DWORD *)(v3 + 49612), *(_DWORD *)(v3 + 49616));
      v23 = *(_DWORD *)(v3 + 49628);
      v24 = *(_DWORD *)(v3 + 49624);
      v25 = *(_DWORD *)(v3 + 49620);
    }
    j_gdi_pvg_draw_arrays(v25, v24, v23);
    if ( *(_BYTE *)(v3 + 51588) )
    {
      v26 = *(_DWORD *)(v3 + 49676);
      v27 = *(_DWORD *)(v3 + 49672);
      v28 = *(_DWORD *)(v3 + 49668);
    }
    else
    {
      v26 = *(_DWORD *)(v3 + 49664);
      v27 = *(_DWORD *)(v3 + 49660);
      v28 = *(_DWORD *)(v3 + 49656);
    }
    j_gdi_pvg_draw_arrays(v28, v27, v26);
    j_gdi_pvg_pop_matrix();
  }
  if ( *(_BYTE *)(v3 + 51602) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49284), *(_DWORD *)(v3 + 49288), *(_DWORD *)(v3 + 49292));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49296), *(_DWORD *)(v3 + 49300), *(_DWORD *)(v3 + 49304));
  }
  else
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49260), *(_DWORD *)(v3 + 49264), *(_DWORD *)(v3 + 49268));
    if ( *(_BYTE *)(v3 + 51614) )
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49524), *(_DWORD *)(v3 + 49528), *(_DWORD *)(v3 + 49532));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49272), *(_DWORD *)(v3 + 49276), *(_DWORD *)(v3 + 49280));
  }
  j_gdi_pvg_enable(34);
  v29 = (_DWORD *)sub_100165A0(0x33u);
  j_gdi_pvg_bind_texture(34, *v29);
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51624) + 8212));
  if ( *(_BYTE *)(v3 + 51742) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49680), *(_DWORD *)(v3 + 49684), *(_DWORD *)(v3 + 49688));
  if ( *(_BYTE *)(v3 + 51798) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49692), *(_DWORD *)(v3 + 49696), *(_DWORD *)(v3 + 49700));
  if ( *(_BYTE *)(v3 + 51854) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49704), *(_DWORD *)(v3 + 49708), *(_DWORD *)(v3 + 49712));
  if ( *(_BYTE *)(v3 + 51966) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49716), *(_DWORD *)(v3 + 49720), *(_DWORD *)(v3 + 49724));
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51636) + 8212));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49356), *(_DWORD *)(v3 + 49360), *(_DWORD *)(v3 + 49364));
  if ( *(_BYTE *)(v3 + 51607) )
  {
    v30 = *(_DWORD *)(v3 + 49376);
    v31 = *(_DWORD *)(v3 + 49372);
    v32 = *(_DWORD *)(v3 + 49368);
  }
  else
  {
    if ( *(_BYTE *)(v3 + 51608) )
      goto LABEL_79;
    v30 = *(_DWORD *)(v3 + 49400);
    v31 = *(_DWORD *)(v3 + 49396);
    v32 = *(_DWORD *)(v3 + 49392);
  }
  j_gdi_pvg_draw_arrays(v32, v31, v30);
LABEL_79:
  if ( *(_BYTE *)(v3 + 51609) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49416), *(_DWORD *)(v3 + 49420), *(_DWORD *)(v3 + 49424));
  if ( *(_DWORD *)(v3 + 51596) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49452), *(_DWORD *)(v3 + 49456), *(_DWORD *)(v3 + 49460));
  j_gdi_pvg_disable(34);
  sub_10016700();
  sub_10015770(1.0);
  sub_10016600((int)&unk_101B0884);
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51264), *(_DWORD *)(v3 + 51268), *(_DWORD *)(v3 + 51272));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51316), *(_DWORD *)(v3 + 51320), *(_DWORD *)(v3 + 51324));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51368), *(_DWORD *)(v3 + 51372), *(_DWORD *)(v3 + 51376));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51420), *(_DWORD *)(v3 + 51424), *(_DWORD *)(v3 + 51428));
  if ( 9.8999998e24 != *(float *)(v3 + 51128) )
  {
    j_gdi_pvg_push_matrix();
    sub_10015920(*(float *)(v3 + 8), *(float *)(v3 + 12), 0.0);
    if ( 9.8999998e24 != *(float *)(v3 + 51548) )
    {
      j_gdi_pvg_push_matrix();
      v43 = *(float *)(v3 + 51548) - 198.0;
      sub_10015850(v43, 0.0, 0.0, 1.0);
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49236), *(_DWORD *)(v3 + 49240), *(_DWORD *)(v3 + 49244));
      j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49248), *(_DWORD *)(v3 + 49252), *(_DWORD *)(v3 + 49256));
      j_gdi_pvg_pop_matrix();
    }
    sub_10015850(*(float *)(v3 + 51128), 0.0, 0.0, 1.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51136), *(_DWORD *)(v3 + 51140), *(_DWORD *)(v3 + 51144));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51148), *(_DWORD *)(v3 + 51152), *(_DWORD *)(v3 + 51156));
    j_gdi_pvg_pop_matrix();
  }
  j_gdi_pvg_push_matrix();
  sub_10015920(*(float *)(v3 + 20), *(float *)(v3 + 24), 0.0);
  v33 = *(_DWORD *)(v3 + 51196);
  if ( (v33 != -16728064 || (v34 = *(_DWORD *)(v3 + 51164), v34 != -256) && v34 != -65536)
    && (v33 != -256 || *(_DWORD *)(v3 + 51164) != -65536) )
  {
    v35 = v3 + 51160;
    v36 = v3 + 51192;
  }
  else
  {
    v35 = v3 + 51192;
    v36 = v3 + 51160;
  }
  if ( 9.8999998e24 != *(float *)v35 )
  {
    j_gdi_pvg_push_matrix();
    sub_10015850(*(float *)v35, 0.0, 0.0, 1.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v35 + 8), *(_DWORD *)(v35 + 12), *(_DWORD *)(v35 + 16));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v35 + 20), *(_DWORD *)(v35 + 24), *(_DWORD *)(v35 + 28));
    j_gdi_pvg_pop_matrix();
  }
  if ( 9.8999998e24 != *(float *)v36 )
  {
    j_gdi_pvg_push_matrix();
    sub_10015850(*(float *)v36, 0.0, 0.0, 1.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v36 + 8), *(_DWORD *)(v36 + 12), *(_DWORD *)(v36 + 16));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v36 + 20), *(_DWORD *)(v36 + 24), *(_DWORD *)(v36 + 28));
    j_gdi_pvg_pop_matrix();
  }
  j_gdi_pvg_pop_matrix();
  j_gdi_pvg_enable(34);
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51636) + 8212));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49344), *(_DWORD *)(v3 + 49348), *(_DWORD *)(v3 + 49352));
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51648) + 8212));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51252), *(_DWORD *)(v3 + 51256), *(_DWORD *)(v3 + 51260));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51304), *(_DWORD *)(v3 + 51308), *(_DWORD *)(v3 + 51312));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51356), *(_DWORD *)(v3 + 51360), *(_DWORD *)(v3 + 51364));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51408), *(_DWORD *)(v3 + 51412), *(_DWORD *)(v3 + 51416));
  if ( *(_DWORD *)(v3 + 51596) && (!*(_BYTE *)(v3 + 51600) || *(_BYTE *)(v3 + 51601)) )
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 51460), *(_DWORD *)(v3 + 51464), *(_DWORD *)(v3 + 51468));
  j_gdi_pvg_disable(34);
  if ( 9.8999998e24 != *(float *)(v3 + 51128) )
  {
    j_gdi_pvg_push_matrix();
    sub_10015920(0.0, *(float *)(v3 + 51516), 0.0);
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49440), *(_DWORD *)(v3 + 49444), *(_DWORD *)(v3 + 49448));
    j_gdi_pvg_pop_matrix();
  }
  sub_10016700();
  sub_10016600((int)&unk_101B0878);
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49308), *(_DWORD *)(v3 + 49312), *(_DWORD *)(v3 + 49316));
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49320), *(_DWORD *)(v3 + 49324), *(_DWORD *)(v3 + 49328));
  sub_10015770(3.0);
  if ( 9.8999998e24 == *(float *)(v3 + 51720) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49740), *(_DWORD *)(v3 + 49744), *(_DWORD *)(v3 + 49748));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49728), *(_DWORD *)(v3 + 49732), *(_DWORD *)(v3 + 49736));
  }
  if ( 9.8999998e24 == *(float *)(v3 + 51776) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49764), *(_DWORD *)(v3 + 49768), *(_DWORD *)(v3 + 49772));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49752), *(_DWORD *)(v3 + 49756), *(_DWORD *)(v3 + 49760));
  }
  if ( 9.8999998e24 == *(float *)(v3 + 51832) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49788), *(_DWORD *)(v3 + 49792), *(_DWORD *)(v3 + 49796));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49776), *(_DWORD *)(v3 + 49780), *(_DWORD *)(v3 + 49784));
  }
  if ( 9.8999998e24 == *(float *)(v3 + 51944) )
  {
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49812), *(_DWORD *)(v3 + 49816), *(_DWORD *)(v3 + 49820));
    j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49800), *(_DWORD *)(v3 + 49804), *(_DWORD *)(v3 + 49808));
  }
  sub_10015770(1.0);
  j_gdi_pvg_bind_texture(34, *(_DWORD *)(*(_DWORD *)(v3 + 51636) + 8212));
  j_gdi_pvg_enable(34);
  j_gdi_pvg_draw_arrays(*(_DWORD *)(v3 + 49332), *(_DWORD *)(v3 + 49336), *(_DWORD *)(v3 + 49340));
  sub_10016700();
  j_gdi_pvg_disable(34);
  j_gdi_pvg_disable(38);
  j_gdi_pvg_disable(35);
  j_gdi_pvg_pop_matrix();
  return 2;
}
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 100156B0: using guessed type int __cdecl j_gdi_pvg_draw_arrays(_DWORD, _DWORD, _DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015810: using guessed type int j_gdi_pvg_pop_matrix(void);
// 10015830: using guessed type int j_gdi_pvg_push_matrix(void);

//----- (10034160) --------------------------------------------------------
char __cdecl sub_10034160(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char v5; // bl@1
  char result; // al@2

  v5 = 1;
  switch ( *a5 )
  {
    case 0x8015:
    case 0x8016:
      sub_1002B890(a4, a1);
      result = 1;
      break;
    case 0x8041:
      result = sub_1002C2B0(a1, a4);
      break;
    case 0x8022:
    case 0x8078:
      v5 = sub_100332A0(a3, a4);
      goto LABEL_5;
    default:
LABEL_5:
      result = v5;
      break;
  }
  return result;
}

//----- (10034240) --------------------------------------------------------
int __cdecl sub_10034240(unsigned __int16 a1)
{
  return dword_100A5C48[a1];
}
// 100A5C48: using guessed type int dword_100A5C48[];

//----- (10034250) --------------------------------------------------------
char __cdecl sub_10034250(int a1, int a2, int a3, int a4, __int16 *a5)
{
  __int16 v5; // ax@1
  unsigned __int16 v6; // dx@4
  double v7; // st7@4
  int v8; // ST04_4@4
  double v9; // st7@4
  int v10; // eax@4
  char *v11; // edi@5
  const char *v12; // esi@6
  bool v13; // zf@97
  const char *v14; // ebx@98
  __int16 v15; // cx@98
  __int16 v16; // dx@98
  char v18; // [sp+1Eh] [bp-11Ah]@1
  char v19; // [sp+1Fh] [bp-119h]@1
  __int16 v20; // [sp+20h] [bp-118h]@98
  __int16 v21; // [sp+22h] [bp-116h]@98
  __int16 *v22; // [sp+24h] [bp-114h]@1
  int v23; // [sp+28h] [bp-110h]@1
  int v24; // [sp+2Ch] [bp-10Ch]@1
  int v25; // [sp+30h] [bp-108h]@98
  float v26; // [sp+34h] [bp-104h]@4
  char v27; // [sp+38h] [bp-100h]@4
  char *v28; // [sp+54h] [bp-E4h]@1
  int v29; // [sp+58h] [bp-E0h]@98
  int v30; // [sp+5Ch] [bp-DCh]@98
  char v31; // [sp+60h] [bp-D8h]@1
  char v32; // [sp+6Bh] [bp-CDh]@99

  v23 = a1;
  v22 = a5;
  v5 = *a5;
  v24 = a3;
  v19 = 1;
  v18 = 31;
  v28 = &v31;
  if ( v5 == -32648 || v5 == -32734 || v5 == -32704 )
  {
    v6 = *(_WORD *)a4;
    v7 = *(float *)(a4 + 4);
    qmemcpy(&v27, (const void *)(a4 + 8), 0x1Cu);
    *(float *)&v8 = v7;
    v9 = sub_100415D0(v8, v6, *(_BYTE *)(a4 + 40), &v18);
    v10 = *(_WORD *)a4;
    v26 = v9;
    switch ( v10 )
    {
      case 0:
        v11 = &v31;
        if ( v18 == 21 )
          v12 = "\a_.__";
        else
          v12 = "\a_.__";
        goto LABEL_97;
      case 42:
      case 46:
        v12 = (const char *)&unk_100A5EB8;
        goto LABEL_96;
      case 1:
      case 45:
        v12 = (const char *)&unk_100A5F88;
        goto LABEL_96;
      case 4:
        v12 = (const char *)&unk_100A6058;
        goto LABEL_96;
      case 5:
        v12 = (const char *)&unk_100A6128;
        goto LABEL_96;
      case 6:
      case 10:
      case 37:
        v12 = (const char *)&unk_100A61F8;
        goto LABEL_96;
      case 11:
        v12 = (const char *)&unk_100A62C8;
        goto LABEL_96;
      case 7:
      case 12:
      case 36:
        v12 = (const char *)&unk_100A6398;
        goto LABEL_96;
      case 13:
        v12 = (const char *)&unk_100A6468;
        goto LABEL_96;
      case 8:
        v12 = (const char *)&unk_100A6538;
        goto LABEL_96;
      case 9:
        v12 = (const char *)&unk_100A6608;
        goto LABEL_96;
      case 14:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_100A61F8;
        else
          v12 = (const char *)&unk_100A67A8;
        goto LABEL_97;
      case 15:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_100A6398;
        else
          v12 = (const char *)&unk_100A6878;
        goto LABEL_97;
      case 16:
        v11 = &v31;
        if ( v18 == 40 )
          v12 = (const char *)&unk_100A66D8;
        else
          v12 = (const char *)&unk_100A6948;
        goto LABEL_97;
      case 17:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100A6A18;
        else
          v12 = (const char *)&unk_100A6C88;
        goto LABEL_97;
      case 19:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100A6AE8;
        else
          v12 = (const char *)&unk_100A6D58;
        goto LABEL_97;
      case 18:
        v11 = &v31;
        if ( v18 == 10 )
          v12 = (const char *)&unk_100A6BB8;
        else
          v12 = (const char *)&unk_100A6E28;
        goto LABEL_97;
      case 20:
        v12 = (const char *)&unk_100A6EF8;
        goto LABEL_96;
      case 21:
        v12 = (const char *)&unk_100A6FC8;
        goto LABEL_96;
      case 22:
        v12 = (const char *)&unk_100A7098;
        goto LABEL_96;
      case 23:
        v12 = (const char *)&unk_100A7168;
        goto LABEL_96;
      case 24:
        v12 = (const char *)&unk_100A7238;
        goto LABEL_96;
      case 25:
        v12 = (const char *)&unk_100A7308;
        goto LABEL_96;
      case 43:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_100A77E8;
            break;
          case 21:
            v12 = (const char *)&unk_100A7988;
            break;
          case 30:
            v12 = (const char *)&unk_100A74A8;
            break;
          default:
            v12 = (const char *)&unk_100A7B28;
            break;
        }
        goto LABEL_97;
      case 26:
      case 38:
        v11 = &v31;
        switch ( v18 )
        {
          case 12:
            v12 = (const char *)&unk_100A7578;
            break;
          case 21:
            v12 = (const char *)&unk_100A78B8;
            break;
          case 30:
            v12 = (const char *)&unk_100A73D8;
            break;
          default:
            v12 = (const char *)&unk_100A7A58;
            break;
        }
        goto LABEL_97;
      case 48:
        v12 = (const char *)&unk_100A7648;
        goto LABEL_96;
      case 49:
        v12 = (const char *)&unk_100A7718;
        goto LABEL_96;
      case 27:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_100A7BF8;
        else
          v12 = (const char *)&unk_100A7D98;
        goto LABEL_97;
      case 29:
        v11 = &v31;
        if ( v18 == 28 )
          v12 = (const char *)&unk_100A7CC8;
        else
          v12 = (const char *)&unk_100A7E68;
        goto LABEL_97;
      case 30:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_100A7F38;
            break;
          case 0x10:
            v12 = (const char *)&unk_100A80D8;
            break;
          case 0x18:
            v12 = (const char *)&unk_100A8418;
            break;
          default:
            v12 = (const char *)&unk_100A85B8;
            break;
          case 0x13:
            goto LABEL_95;
        }
        goto LABEL_96;
      case 31:
        switch ( v18 )
        {
          case 0xD:
            v12 = (const char *)&unk_100A8008;
            break;
          case 0x10:
            v12 = (const char *)&unk_100A81A8;
            break;
          case 0x13:
            v12 = (const char *)&unk_100A8348;
            break;
          case 0x18:
            v12 = (const char *)&unk_100A84E8;
            break;
          default:
            v12 = (const char *)&unk_100A8688;
            break;
        }
        goto LABEL_96;
      case 32:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_100A8758;
            break;
          case 0x11:
            v12 = (const char *)&unk_100A88F8;
            break;
          case 0x14:
            v12 = (const char *)&unk_100A8A98;
            break;
          case 0x19:
            v12 = (const char *)&unk_100A8C38;
            break;
          default:
            v12 = (const char *)&unk_100A8DD8;
            break;
        }
        goto LABEL_96;
      case 33:
        switch ( v18 )
        {
          case 0xE:
            v12 = (const char *)&unk_100A8828;
            break;
          case 0x11:
            v12 = (const char *)&unk_100A89C8;
            break;
          case 0x14:
            v12 = (const char *)&unk_100A8B68;
            break;
          case 0x19:
            v12 = (const char *)&unk_100A8D08;
            break;
          default:
            v12 = (const char *)&unk_100A8EA8;
            break;
        }
        goto LABEL_96;
      case 35:
        v12 = (const char *)&unk_100A8F78;
        goto LABEL_96;
      case 34:
        v12 = (const char *)&unk_100A9048;
        goto LABEL_96;
      case 39:
        v12 = (const char *)&unk_100A9118;
        goto LABEL_96;
      case 40:
        v12 = (const char *)&unk_100A91E8;
        goto LABEL_96;
      case 41:
        v12 = (const char *)&unk_100A92B8;
        goto LABEL_96;
      case 44:
        v12 = (const char *)&unk_100A9388;
        goto LABEL_96;
      case 47:
        v12 = (const char *)&unk_100A9458;
        goto LABEL_96;
      case 50:
        v12 = (const char *)&unk_100A8418;
        if ( v18 == 19 )
LABEL_95:
          v12 = (const char *)&unk_100A8278;
LABEL_96:
        v11 = &v31;
LABEL_97:
        v13 = v28 == 0;
        qmemcpy(v11, v12, 0xCCu);
        if ( !v13 )
        {
          v14 = *(const char **)(a4 + 36);
          v30 = *(_DWORD *)(a4 + 60);
          v15 = *(_WORD *)v24;
          v29 = a4 + 41;
          v16 = *(_WORD *)(v24 + 2);
          v25 = 27;
          v20 = v15;
          v21 = v16;
          if ( v14 )
            strcpy(&v32, v14);
          v19 = sub_10048EA0(v23, (int)&v25, (int)&v20, (int)&v26, v22);
        }
        break;
      default:
        return v19;
    }
  }
  return v19;
}

//----- (100348B0) --------------------------------------------------------
signed int __cdecl sub_100348B0(int a1)
{
  unsigned __int8 v1; // cl@1
  signed int result; // eax@1

  v1 = *(_BYTE *)(a1 + 5556);
  result = -1;
  if ( v1 < 0x31u )
  {
    result = v1;
    *(_BYTE *)(a1 + 5556) = v1 + 1;
  }
  return result;
}

//----- (100348D0) --------------------------------------------------------
void __cdecl sub_100348D0(int a1)
{
  int v1; // esi@1
  double v2; // st7@1
  double v3; // st6@3
  float v4; // ST18_4@5
  float v5; // ST18_4@5
  float v6; // ST18_4@5
  float v7; // ST18_4@5
  double v8; // st6@6
  double v9; // st7@6
  double v10; // st4@9
  double v11; // st5@9
  double v12; // rt2@11
  double v13; // st4@11
  double v14; // st6@11
  double v15; // rtt@13
  double v16; // st5@13
  double v17; // st7@13
  long double i; // st7@15
  float v19; // ST28_4@16
  double v20; // st7@16
  float v21; // ST28_4@17
  int v22; // edx@27
  int v23; // ecx@27
  float v24; // [sp+Ch] [bp-28h]@5
  float v25; // [sp+Ch] [bp-28h]@13
  float v26; // [sp+10h] [bp-24h]@5
  float v27; // [sp+10h] [bp-24h]@15
  float v28; // [sp+14h] [bp-20h]@5
  float v29; // [sp+14h] [bp-20h]@9
  float v30; // [sp+18h] [bp-1Ch]@6
  float v31; // [sp+1Ch] [bp-18h]@5
  float v32; // [sp+20h] [bp-14h]@5
  float v33; // [sp+24h] [bp-10h]@3
  float v34; // [sp+24h] [bp-10h]@15
  float v35; // [sp+28h] [bp-Ch]@1
  float v36; // [sp+28h] [bp-Ch]@3
  float v37; // [sp+28h] [bp-Ch]@5
  float v38; // [sp+2Ch] [bp-8h]@5
  double v39; // [sp+2Ch] [bp-8h]@15
  float v40; // [sp+38h] [bp+4h]@3
  float v41; // [sp+38h] [bp+4h]@5
  float v42; // [sp+38h] [bp+4h]@5
  float v43; // [sp+38h] [bp+4h]@28
  float v44; // [sp+38h] [bp+4h]@30
  float v45; // [sp+38h] [bp+4h]@32
  float v46; // [sp+38h] [bp+4h]@34
  float v47; // [sp+38h] [bp+4h]@36
  float v48; // [sp+38h] [bp+4h]@38
  float v49; // [sp+38h] [bp+4h]@40
  float v50; // [sp+38h] [bp+4h]@42

  v1 = a1;
  v35 = *(float *)(a1 + 224);
  v2 = *(float *)(a1 + 220);
  if ( v35 <= v2 )
    v2 = v35;
  v40 = v2;
  v33 = v40 * 0.01745329238474369;
  v36 = *(float *)(v1 + 224);
  v3 = *(float *)(v1 + 220);
  if ( v36 >= v3 )
    v3 = v36;
  v41 = v3;
  v37 = 0.01745329238474369 * v41;
  v42 = *(float *)(v1 + 212) * 0.5;
  v31 = *(float *)(v1 + 204) + v42;
  v32 = v42 + *(float *)(v1 + 208);
  v4 = cos(v33);
  v28 = v4 * v42 + v31;
  v5 = cos(v37);
  v26 = v5 * v42 + v31;
  v6 = sin(v33);
  v24 = v6 * v42 + v32;
  v7 = sin(v37);
  v38 = v7 * v42 + v32;
  if ( v26 >= (double)v28 )
  {
    v30 = v26;
    v8 = v28;
    v9 = v26;
  }
  else
  {
    v8 = v28;
    v9 = v26;
    v30 = v28;
  }
  if ( v38 >= (double)v24 )
  {
    v29 = v38;
    v10 = v24;
    v11 = v38;
  }
  else
  {
    v10 = v24;
    v11 = v38;
    v29 = v24;
  }
  v12 = v10;
  v13 = v8;
  v14 = v12;
  if ( v13 < v9 )
    v9 = v13;
  v15 = v11;
  v16 = v9;
  v17 = v15;
  v25 = v16;
  if ( v14 < v15 )
    v17 = v14;
  v27 = v17;
  v34 = floor(v33 / 1.5707963267949 + 1.0) * 3.1415926535898 * 0.5;
  v39 = v37;
  for ( i = v34; v34 < v39; i = v34 )
  {
    v19 = fmod(i, 6.2831853071796);
    v20 = v19;
    if ( v19 < 0.0 )
    {
      v21 = v20 + 6.283185482025146;
      v20 = v21;
    }
    if ( v20 >= 0.7853981633974501 )
    {
      if ( v20 >= 2.35619449019235 )
      {
        if ( v20 >= 3.92699081698725 )
          v27 = v32 - v42;
        else
          v25 = v31 - v42;
      }
      else
      {
        v29 = v32 + v42;
      }
    }
    else
    {
      v30 = v31 + v42;
    }
    v34 = v34 + 1.570796370506287;
  }
  if ( *(_BYTE *)(v1 + 5556) )
  {
    v22 = *(_BYTE *)(v1 + 5556);
    v23 = v1 + 2360;
    do
    {
      v43 = *(float *)(v23 - 4);
      if ( v43 <= (double)v25 )
        v25 = v43;
      v44 = *(float *)(v23 - 4);
      if ( v44 >= (double)v30 )
        v30 = v44;
      v45 = *(float *)v23;
      if ( v45 <= (double)v25 )
        v25 = v45;
      v46 = *(float *)v23;
      if ( v46 >= (double)v30 )
        v30 = v46;
      v47 = *(float *)(v23 + 4);
      if ( v47 <= (double)v27 )
        v27 = v47;
      v48 = *(float *)(v23 + 4);
      if ( v48 >= (double)v29 )
        v29 = v48;
      v49 = *(float *)(v23 + 8);
      if ( v49 <= (double)v27 )
        v27 = v49;
      v50 = *(float *)(v23 + 8);
      if ( v50 >= (double)v29 )
        v29 = v50;
      v23 += 64;
      --v22;
    }
    while ( v22 );
  }
  *(float *)(v1 + 24) = v25;
  *(float *)(v1 + 28) = v27;
  *(float *)(v1 + 36) = v29 - v27;
  *(float *)(v1 + 32) = v30 - v25;
}

//----- (10034CB0) --------------------------------------------------------
void __cdecl sub_10034CB0(_BYTE *a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@2
  int v4; // ebp@2
  int v5; // esi@2
  int v6; // eax@7
  int v7; // ecx@7

  v2 = 0;
  if ( *a1 )
  {
    v3 = a2;
    v4 = (int)(a1 + 12);
    v5 = a2 + 232;
    while ( v2 < 10 )
    {
      *(float *)(v5 - 4) = sub_10038A30(*(float *)v4, v3 + 308, *(_BYTE *)(v3 + 404));
      *(_DWORD *)v5 = *(_DWORD *)(v4 + 40);
      *(_BYTE *)(v5 + 1736) = a1[v2 + 92];
      *(float *)(v5 + 1732) = *(float *)v4;
      ++v2;
      v4 += 4;
      v5 += 8;
      if ( v2 >= *a1 )
      {
        if ( v2 < 10 )
          goto LABEL_7;
        v3 = a2;
        break;
      }
      v3 = a2;
    }
    sub_1003C3C0(v3 + 204);
  }
  else
  {
LABEL_7:
    v6 = a2 + 8 * v2 + 232;
    v7 = 10 - v2;
    do
    {
      *(float *)(v6 - 4) = 9.8999998e24;
      *(_DWORD *)v6 = 0;
      *(float *)(v6 + 1732) = 9.8999998e24;
      *(_BYTE *)(v6 + 1736) = 10;
      v6 += 8;
      --v7;
    }
    while ( v7 );
    sub_1003C3C0(a2 + 204);
  }
}

//----- (10034D90) --------------------------------------------------------
int __cdecl sub_10034D90(int a1, char a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(_DWORD *)(a3 + 44) = a1 + 4;
  *(_DWORD *)(a3 + 48) = a1 + 8;
  if ( a2 )
    *(_DWORD *)(a3 + 2320) = a1 + 8;
  return result;
}

//----- (10034DC0) --------------------------------------------------------
int __cdecl sub_10034DC0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)(a2 + 2324) = *(float *)a1;
  *(float *)(a2 + 2328) = *(float *)(a1 + 4);
  return result;
}

//----- (10034DE0) --------------------------------------------------------
int __cdecl sub_10034DE0(float a1, char a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // edx@1
  double v8; // st7@1
  float v9; // [sp+8h] [bp+4h]@1

  result = a4;
  v5 = LOBYTE(a1);
  v6 = a4 + 36 * LOBYTE(a1);
  v7 = 9 * LOBYTE(a1) + 522;
  *(float *)(v6 + 2080) = *(float *)(a4 + 8) * 0.5 + *(float *)a4;
  *(float *)(v6 + 2084) = 0.5 * *(float *)(result + 8) + *(float *)(result + 4);
  v9 = *(float *)(a4 + 8) * 0.4777779877185822;
  *(float *)(a4 + 4 * v7) = v9;
  v8 = *(float *)(a4 + 12);
  *(_BYTE *)(v6 + 2108) = a2;
  *(_DWORD *)(v6 + 2104) = -1;
  *(float *)(v6 + 2092) = v8 * 0.1194444969296455;
  *(float *)(v6 + 2096) = 150.0;
  *(float *)(v6 + 2100) = 0.0;
  *(_DWORD *)(a4 + 4 * v5 + 52) = a3;
  *(_DWORD *)(a4 + 4 * v5 + 76) = 0;
  *(_DWORD *)(v6 + 2112) = 66;
  return result;
}

//----- (10034E90) --------------------------------------------------------
int __cdecl sub_10034E90(float a1, char *a2, float a3, float a4, float a5, int a6, int a7)
{
  int v7; // esi@1
  double v8; // st7@1
  float v9; // ST34_4@1
  long double v10; // ST2C_8@1
  int v11; // ebx@1
  double v12; // st7@1
  int v13; // eax@3
  int result; // eax@3
  double v15; // st7@3
  double v16; // st3@3
  double v17; // st7@4
  double v18; // st4@6
  double v19; // st7@6
  int v20; // [sp+1Ch] [bp-18h]@1
  float v21; // [sp+24h] [bp-10h]@1
  float v22; // [sp+28h] [bp-Ch]@1
  float v23; // [sp+2Ch] [bp-8h]@1
  float v24; // [sp+30h] [bp-4h]@1
  float v25; // [sp+40h] [bp+Ch]@3
  float v26; // [sp+44h] [bp+10h]@6

  v7 = a7;
  v8 = *(float *)(a7 + 8) * 0.5;
  v22 = v8;
  v23 = v8 + *(float *)a7;
  v24 = 0.5 * *(float *)(a7 + 12) + *(float *)(a7 + 4);
  v9 = sub_10038A30(a1, a7 + 308, *(_BYTE *)(a7 + 404)) + *(float *)(v7 + 220);
  v10 = v9 * 0.01745329251994333;
  v21 = cos(v10);
  *(float *)&v20 = sin(v10);
  v11 = (a6 << 6) + v7;
  v12 = sub_100415D0(SLODWORD(a1), *(_WORD *)(v7 + 5558), *(_BYTE *)(v7 + 5564), (char *)&a7);
  _snprintf((char *)(v11 + 2392), 7u, a2, v12 * a3);
  if ( !strncmp((const char *)(v11 + 2392), "-0", 7u) )
    sub_10038450(v11 + 2392, &word_100897F0, 7);
  v13 = sub_10038970(a4);
  v25 = sub_10016930(v13, v11 + 2392, a4);
  a7 = v20;
  result = 0x7FFFFFFF;
  v15 = a5 * (1.100000023841858 * v22) + v22;
  v16 = a4 * 0.5;
  if ( a5 >= 0.0 )
  {
    a7 &= 0x7FFFFFFFu;
    v17 = 0.5 * v25 * COERCE_FLOAT(LODWORD(v21) & 0x7FFFFFFF) + v16 * *(float *)&a7 + v15;
  }
  else
  {
    a7 &= 0x7FFFFFFFu;
    v17 = v15 - v16 * *(float *)&a7 - 0.5 * v25 * COERCE_FLOAT(LODWORD(v21) & 0x7FFFFFFF);
  }
  v18 = v17;
  v19 = a4;
  v26 = v18;
  *(_DWORD *)(v11 + 2384) = 0;
  *(_DWORD *)(v11 + 2388) = -1;
  *(float *)(v11 + 2376) = v21 * v26 + v23;
  *(float *)(v11 + 2380) = *(float *)&v20 * v26 + v24;
  *(float *)(v11 + 2404) = 0.5;
  *(float *)(v11 + 2400) = 0.5;
  *(float *)(v11 + 2408) = *(float *)&v19;
  return result;
}
// 100897F0: using guessed type __int16 word_100897F0;

//----- (10035080) --------------------------------------------------------
int __cdecl sub_10035080(float a1, float a2, float a3, int a4, int a5)
{
  int v5; // esi@1
  double v6; // st7@1
  float v7; // ST10_4@1
  float v8; // ST1C_4@1
  long double v9; // ST14_8@1
  int result; // eax@1
  double v11; // st5@1
  float v12; // [sp+2Ch] [bp+Ch]@1
  int v13; // [sp+34h] [bp+14h]@1
  int v14; // [sp+34h] [bp+14h]@1
  int v15; // [sp+34h] [bp+14h]@1

  v5 = a5;
  v6 = *(float *)(a5 + 8) * 0.5;
  v12 = v6 - a3;
  v7 = v6 + *(float *)a5;
  v8 = 0.5 * *(float *)(a5 + 12) + *(float *)(a5 + 4);
  *(float *)&v13 = sub_10038A30(a1, a5 + 308, *(_BYTE *)(a5 + 404)) + *(float *)(a5 + 220);
  v9 = *(float *)&v13 * 0.01745329251994333;
  *(float *)&v14 = cos(v9);
  *(float *)&v9 = sin(v9);
  result = (a4 << 6) + v5;
  *(_BYTE *)(result + 2416) = 0;
  *(_DWORD *)(result + 2412) = -1;
  *(float *)(result + 2356) = *(float *)&v14 * v12 + v7;
  *(float *)(result + 2364) = *(float *)&v9 * v12 + v8;
  v11 = v12 + v12 * a2;
  *(float *)(result + 2360) = v7 + *(float *)&v14 * v11;
  *(float *)&v15 = v8 + *(float *)&v9 * v11;
  *(float *)(((a4 + 37) << 6) + v5) = *(float *)&v15;
  return result;
}

//----- (10035190) --------------------------------------------------------
int __cdecl sub_10035190(int a1, char a2, float a3, int a4)
{
  int result; // eax@1
  unsigned __int8 v5; // bl@1
  int v6; // esi@1
  double v7; // st7@1
  double v8; // st6@1
  double v9; // st7@1
  int v10; // edi@2
  long double v11; // ST24_8@4
  double v12; // st5@4
  int v13; // eax@4
  double v14; // st4@4
  char *v15; // edx@4
  char v16; // cl@5
  double v17; // st7@6
  double v18; // st6@8
  double v19; // st5@8
  int v20; // ecx@8
  double v21; // rt1@9
  double v22; // rt2@10
  double v23; // st5@10
  double v24; // st6@10
  float v25; // [sp+1Ch] [bp-14h]@1
  float v26; // [sp+20h] [bp-10h]@1
  float v27; // [sp+2Ch] [bp-4h]@1
  float v28; // [sp+3Ch] [bp+Ch]@4
  float v29; // [sp+3Ch] [bp+Ch]@4
  float v30; // [sp+3Ch] [bp+Ch]@4
  int v31; // [sp+40h] [bp+10h]@1

  result = (unsigned __int8)a2;
  v5 = LOBYTE(a3);
  v6 = a4;
  v7 = *(float *)(a4 + 8);
  v31 = 0;
  v8 = v7 * 0.5;
  v25 = v8;
  v26 = v8 + *(float *)v6;
  v27 = 0.5 * *(float *)(v6 + 12) + *(float *)(v6 + 4);
  v9 = 0.5;
  if ( (signed int)(unsigned __int8)a2 > 0 )
  {
    v10 = a1 + 8;
    do
    {
      if ( v5 >= 0x32u )
        break;
      v28 = sub_10038A30(*(float *)(v10 - 8), v6 + 308, *(_BYTE *)(v6 + 404)) + *(float *)(v6 + 220);
      v11 = v28 * 0.01745329251994333;
      v29 = cos(v11);
      *(float *)&v11 = sin(v11);
      v12 = v25;
      v13 = (v5 << 6) + v6;
      *(float *)(v13 + 2356) = v29 * v25 + v26;
      *(float *)(v13 + 2364) = *(float *)&v11 * v25 + v27;
      *(float *)(v13 + 2360) = v26 + v29 * (*(float *)(v10 - 4) * v12 + v12);
      v14 = *(float *)(v10 - 4);
      *(_DWORD *)(v13 + 2412) = -1;
      *(_BYTE *)(v13 + 2416) = 0;
      v30 = v27 + *(float *)&v11 * (v12 + v14 * v12);
      *(float *)(((v5 + 37) << 6) + v6) = v30;
      v15 = (char *)v10;
      *(float *)(v13 + 2372) = 2.0;
      do
      {
        v16 = *v15;
        *(&v15[(v5 << 6) - v10 + 2392] + v6) = *v15;
        ++v15;
      }
      while ( v16 );
      *(float *)(v13 + 2376) = *(float *)(v13 + 2356);
      v17 = *(float *)(v13 + 2364);
      *(_DWORD *)(v13 + 2384) = 0;
      *(_DWORD *)(v13 + 2388) = -1;
      v10 += 16;
      ++v5;
      *(float *)(v13 + 2380) = v17 + 8.0;
      v9 = 0.5;
      *(float *)(v13 + 2404) = 0.5;
      *(float *)(v13 + 2400) = 0.5;
      *(float *)(v13 + 2408) = 9.0;
      result = v31++ + 1;
    }
    while ( v31 < (unsigned __int8)a2 );
  }
  *(_BYTE *)(v6 + 5556) = v5;
  if ( v5 < 0x32u )
  {
    v18 = 0.0;
    v19 = 1.0;
    result = (v5 << 6) + v6 + 2364;
    v20 = (unsigned __int8)(50 - v5);
    while ( 1 )
    {
      v22 = v19;
      v23 = v18;
      *(_DWORD *)(result + 48) = 0;
      *(float *)(result - 8) = v18;
      *(_BYTE *)(result + 52) = 1;
      *(float *)result = v18;
      *(_BYTE *)(result + 28) = 0;
      *(float *)(result - 4) = v18;
      *(_DWORD *)(result + 20) = 0;
      *(float *)(result + 4) = v18;
      *(_DWORD *)(result + 24) = -1;
      result += 64;
      --v20;
      *(float *)(result - 56) = v22;
      v24 = v22;
      *(float *)(result - 52) = v23;
      *(float *)(result - 48) = v23;
      *(float *)(result - 24) = v9;
      *(float *)(result - 28) = v9;
      *(float *)(result - 20) = *(float *)&v23;
      if ( !v20 )
        break;
      v21 = v23;
      v19 = v24;
      v18 = v21;
    }
  }
  return result;
}

//----- (100353D0) --------------------------------------------------------
int __usercall sub_100353D0@<eax>(int result@<eax>)
{
  int v1; // esi@1
  double v2; // st7@6
  float v3; // ST20_4@6
  float v4; // ST08_4@6
  float v5; // ST20_4@6
  float v6; // ST04_4@6
  float v7; // ST20_4@6

  v1 = result;
  if ( *(_BYTE *)(result + 2348) != 1 )
    result = sub_10039460(result + 204);
  if ( *(_BYTE *)(v1 + 2351) != 1 )
  {
    if ( *(float *)(v1 + 1952) != *(float *)(v1 + 220) || *(float *)(v1 + 1956) != *(float *)(v1 + 224) )
    {
      *(float *)(v1 + 1952) = *(float *)(v1 + 220);
      *(float *)(v1 + 1956) = *(float *)(v1 + 224);
      v2 = *(float *)(v1 + 212) * 0.5;
      *(_DWORD *)(v1 + 1948) = 49;
      v3 = v2;
      v4 = v3;
      v5 = *(float *)(v1 + 208) + v2;
      v6 = v5;
      v7 = v2 + *(float *)(v1 + 204);
      sub_1003E1B0(v7, v6, v4, *(float *)(v1 + 220), *(float *)(v1 + 224), v1 + 1556, v1 + 1948);
    }
    result = sub_1003AC80(v1 + 1556, *(_DWORD *)(v1 + 1948), -1, 1.5);
  }
  return result;
}

//----- (100354E0) --------------------------------------------------------
void __usercall sub_100354E0(int a1@<esi>, int a2@<edi>)
{
  float *v2; // ecx@2
  float v3; // ST24_4@4
  double v4; // st7@5
  float v5; // ST24_4@7
  double v6; // st7@7
  double v7; // st6@7
  float v8; // ST28_4@10
  double v9; // st7@10
  float v10; // ST24_4@12
  float *v11; // edx@14
  float v12; // ST24_4@14
  char v13; // ST28_1@14
  int v14; // eax@15
  float v15; // [sp+14h] [bp-Ch]@4
  float v16; // [sp+14h] [bp-Ch]@10
  float v17; // [sp+18h] [bp-8h]@5
  float v18; // [sp+18h] [bp-8h]@8
  char v19; // [sp+1Ch] [bp-4h]@14

  if ( *(_BYTE *)(a1 + 2349) != 1 )
  {
    v2 = *(float **)(a1 + 44);
    if ( v2 )
    {
      if ( 9.8999998e24 != *v2 )
      {
        v3 = sub_10038A30(*v2, a1 + 308, *(_BYTE *)(a1 + 404));
        v15 = v3 + *(float *)(a1 + 220);
        *(float *)(a1 + 2060) = v15;
        if ( *(float *)(a1 + 220) >= (double)*(float *)(a1 + 224) )
        {
          v8 = v15;
          v16 = *(float *)(a1 + 224);
          v9 = v8;
          if ( v16 >= (double)v8 )
            v9 = v16;
          v10 = v9;
          v6 = v10;
          *(float *)(a1 + 2060) = v10;
          v7 = *(float *)(a1 + 220);
        }
        else
        {
          v17 = *(float *)(a1 + 220);
          v4 = v15;
          if ( v17 >= (double)v15 )
            v4 = v17;
          v5 = v4;
          v6 = v5;
          *(float *)(a1 + 2060) = v5;
          v7 = *(float *)(a1 + 224);
        }
        v18 = v7;
        if ( v18 <= v6 )
          v6 = v18;
        v11 = *(float **)(a1 + 48);
        v12 = v6;
        *(float *)(a1 + 2060) = v12;
        v13 = sub_10047DE0(*v11, a1 + 1964, 10, a1 + 5568);
        sub_10047ED0(v13, &v19, (_DWORD *)(a1 + 2068), *(_BYTE *)(a1 + 2349));
        sub_1003CCE0(a2, a1 + 2044);
        if ( *(_BYTE *)(a1 + 2072) != 1 )
        {
          v14 = *(_DWORD *)(a1 + 2076);
          if ( v14 == 54 || v14 == 55 || v14 == 70 || v14 == 68 || v14 == 69 || v14 == 71 )
            sub_1003A310(*(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 8), *(float *)(a1 + 12), 59);
        }
      }
    }
  }
}

//----- (10035690) --------------------------------------------------------
void __usercall sub_10035690(int a1@<esi>)
{
  int v1; // edi@3
  int v2; // ebp@3
  float *v3; // ecx@4
  float v4; // ST18_4@6
  float *v5; // eax@6
  char v6; // al@8
  double v7; // st7@14
  float v8; // ST18_4@16
  double v9; // st7@16
  double v10; // st6@16
  float v11; // ST18_4@23
  float v12; // [sp+18h] [bp-Ch]@6
  float v13; // [sp+18h] [bp-Ch]@19
  signed int v14; // [sp+1Ch] [bp-8h]@2
  float v15; // [sp+20h] [bp-4h]@14
  float v16; // [sp+20h] [bp-4h]@17
  float v17; // [sp+20h] [bp-4h]@19

  if ( *(_BYTE *)(a1 + 2354) != 1 )
  {
    v14 = 0;
    if ( *(_BYTE *)(a1 + 2296) )
    {
      v1 = a1 + 2096;
      v2 = a1 + 52;
      do
      {
        v3 = *(float **)v2;
        if ( *(_DWORD *)v2 && 9.8999998e24 != *v3 )
        {
          v4 = sub_10038A30(*v3, a1 + 308, *(_BYTE *)(a1 + 404));
          *(float *)v1 = *(float *)(a1 + 220) + v4;
          v5 = *(float **)(v2 + 24);
          v12 = 0.0;
          if ( v5 )
            v12 = sub_10038A30(*v5, a1 + 308, *(_BYTE *)(a1 + 404));
          v6 = *(_BYTE *)(v1 + 12);
          if ( v6 != 9 && v6 != 4 && v6 != 14 && v6 != 5 )
            *(float *)(v1 + 4) = *(float *)(a1 + 220) + v12;
          if ( *(float *)(a1 + 220) >= (double)*(float *)(a1 + 224) )
          {
            v17 = *(float *)v1;
            v13 = *(float *)(a1 + 224);
            if ( v13 >= (double)v17 )
            {
              v9 = v13;
              *(float *)v1 = v13;
              v10 = *(float *)(a1 + 220);
            }
            else
            {
              v9 = v17;
              *(float *)v1 = v17;
              v10 = *(float *)(a1 + 220);
            }
          }
          else
          {
            v15 = *(float *)(a1 + 220);
            v7 = *(float *)v1;
            if ( v15 >= v7 )
              v7 = v15;
            v8 = v7;
            v9 = v8;
            *(float *)v1 = v8;
            v10 = *(float *)(a1 + 224);
          }
          v16 = v10;
          if ( v16 <= v9 )
            v9 = v16;
          v11 = v9;
          *(float *)v1 = v11;
          sub_1003CCE0(v1, v1 - 16);
        }
        v2 += 4;
        v1 += 36;
        ++v14;
      }
      while ( v14 < *(_BYTE *)(a1 + 2296) );
    }
  }
}

//----- (10035840) --------------------------------------------------------
int __usercall sub_10035840@<eax>(int result@<eax>, int a2@<edx>, int a3@<edi>)
{
  if ( *(_BYTE *)(result + 2352) != 1 )
    result = sub_1003BEB0(a3, a2, result + 2356, *(_BYTE *)(result + 5556), 1);
  return result;
}

//----- (10035870) --------------------------------------------------------
void __usercall sub_10035870(int a1@<edi>, int a2)
{
  float *v2; // eax@1
  _DWORD *v3; // esi@4
  signed int v4; // ebx@4
  char v5; // [sp+10h] [bp-4h]@1

  v2 = *(float **)(a1 + 44);
  v5 = 0;
  if ( v2 && 9.8999998e24 != *v2 )
    v5 = sub_10047DE0(**(float **)(a1 + 48), a1 + 1964, 10, a1 + 5568);
  v3 = (_DWORD *)(a1 + 112);
  v4 = 2;
  do
  {
    sub_10047FA0(v5, v3, v3 - 1, *(_BYTE *)(a1 + 2353), *(_DWORD *)(a1 + 5576));
    sub_1003E0F0(a2, (int)(v3 - 3));
    v3 += 13;
    --v4;
  }
  while ( v4 );
}

//----- (10035900) --------------------------------------------------------
int __thiscall sub_10035900(int this)
{
  float *v1; // edx@2
  int result; // eax@6

  result = 1;
  if ( !*(_BYTE *)(this + 46) )
  {
    v1 = *(float **)(this + 20);
    if ( 9.8999998e24 == *v1
      || *(_BYTE *)(this + 44) && (*(float *)(this + 24) > (double)*v1 || *(float *)(this + 28) < (double)*v1) )
    {
      result = 0;
    }
  }
  return result;
}

//----- (10035950) --------------------------------------------------------
void __usercall sub_10035950(int a1@<esi>)
{
  float *v1; // eax@2
  int v2; // ecx@9

  if ( *(_BYTE *)(a1 + 2349) == 1 )
  {
    if ( *(_BYTE *)(a1 + 2350) != 1 && *(_DWORD *)(a1 + 2320) && !(unsigned __int8)sub_10035900(a1 + 2300) )
      sub_1003C630(v2);
  }
  else
  {
    v1 = *(float **)(a1 + 44);
    if ( v1 && 9.8999998e24 == *v1 || *(_DWORD *)(a1 + 2320) && !(unsigned __int8)sub_10035900(a1 + 2300) )
      sub_10039220(
        *(float *)(a1 + 24),
        *(float *)(a1 + 28),
        *(float *)(a1 + 32),
        *(float *)(a1 + 36),
        0.0,
        0.0,
        *(_BYTE *)(a1 + 40));
  }
}

//----- (100359F0) --------------------------------------------------------
int __cdecl sub_100359F0(int a1, int a2, int a3, float a4, float a5, float a6, float a7)
{
  int v7; // esi@1
  signed int v8; // edx@1
  double v9; // st3@1
  int v10; // eax@1
  double v11; // st7@1
  double v12; // st4@1
  double v13; // st3@1
  double v14; // rtt@2
  double v15; // st3@2
  double v16; // rt1@2
  double v17; // st2@3
  double v18; // rt2@3
  double v19; // st3@3
  double v20; // st7@3
  double v21; // rt0@3
  double v22; // st3@3
  double v23; // st4@3
  char *v24; // edi@4
  char v25; // al@5
  double v26; // st5@6
  double v27; // st5@6
  double v28; // st5@6

  v7 = a1;
  *(float *)a1 = a4;
  v8 = 2;
  *(float *)(a1 + 4) = a5;
  *(float *)(a1 + 8) = a6;
  *(float *)(a1 + 12) = a7;
  *(float *)(a1 + 16) = *(float *)(a3 + 4);
  v9 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 40) = 0;
  *(float *)(a1 + 20) = v9;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(float *)(a1 + 24) = a4;
  *(_BYTE *)(a1 + 1960) = 0;
  *(float *)(a1 + 28) = a5;
  *(float *)(a1 + 32) = a6;
  *(float *)(a1 + 36) = a7;
  *(float *)(a1 + 204) = a4;
  *(float *)(a1 + 208) = a5;
  *(float *)(a1 + 212) = a6;
  *(float *)(a1 + 216) = a7;
  *(float *)(a1 + 220) = 150.0;
  *(float *)(a1 + 224) = 375.0;
  *(float *)(a1 + 1952) = 0.0;
  *(float *)(a1 + 1956) = 0.0;
  *(float *)(a1 + 308) = 0.0;
  *(float *)(a1 + 312) = 0.0;
  *(float *)(a1 + 316) = 1.0;
  *(float *)(a1 + 328) = 1.0;
  *(float *)(a1 + 340) = 1.0;
  *(float *)(a1 + 352) = 1.0;
  *(float *)(a1 + 364) = 1.0;
  *(float *)(a1 + 376) = 1.0;
  *(float *)(a1 + 388) = 1.0;
  *(float *)(a1 + 400) = 1.0;
  *(float *)(a1 + 320) = 0.0;
  *(float *)(a1 + 324) = 0.0;
  *(float *)(a1 + 332) = 0.0;
  *(float *)(a1 + 336) = 0.0;
  *(float *)(a1 + 344) = 0.0;
  *(float *)(a1 + 348) = 0.0;
  *(float *)(a1 + 356) = 0.0;
  *(float *)(a1 + 360) = 0.0;
  *(float *)(a1 + 368) = 0.0;
  *(float *)(a1 + 372) = 0.0;
  *(float *)(a1 + 380) = 0.0;
  *(float *)(a1 + 384) = 0.0;
  *(float *)(a1 + 392) = 0.0;
  *(float *)(a1 + 396) = 0.0;
  *(_BYTE *)(a1 + 404) = 2;
  *(float *)(a1 + 308) = *(float *)(a3 + 4);
  *(float *)(a1 + 320) = *(float *)(a3 + 8);
  *(float *)(a1 + 312) = 0.0;
  *(float *)(a1 + 324) = 225.0;
  *(_DWORD *)(a1 + 2068) = -1;
  *(_BYTE *)(a1 + 2072) = 0;
  *(_DWORD *)(a1 + 2076) = 54;
  v10 = a1 + 104;
  *(float *)(a1 + 2044) = a4 + a6 * 0.5;
  v11 = 1.0;
  *(float *)(a1 + 2048) = a5 + 0.5 * a7;
  *(float *)(v7 + 2052) = *(float *)(v7 + 8) * 0.4777779877185822;
  *(float *)(v7 + 2056) = *(float *)(v7 + 12) * 0.1194444969296455;
  *(float *)(a1 + 2060) = 150.0;
  *(float *)(v7 + 2064) = *(float *)(v7 + 220);
  v12 = 0.5;
  v13 = 12.0;
  while ( 1 )
  {
    v10 += 52;
    --v8;
    *(float *)(v10 - 56) = *(float *)(a1 + 2044);
    v17 = *(float *)(a1 + 2048);
    *(_DWORD *)(v10 - 48) = 0;
    *(_DWORD *)(v10 - 44) = -1;
    *(_BYTE *)(v10 - 40) = 0;
    *(float *)(v10 - 52) = v17 + 35.0;
    v18 = v13;
    *(float *)(v10 - 16) = v12;
    v19 = v11;
    v20 = v12;
    *(float *)(v10 - 12) = v19;
    v21 = v19;
    v22 = v18;
    v23 = v21;
    *(float *)(v10 - 8) = v18;
    if ( !v8 )
      break;
    v14 = v22;
    v15 = v20;
    v11 = v23;
    v16 = v15;
    v13 = v14;
    v12 = v16;
  }
  v24 = (char *)a2;
  do
  {
    v25 = *v24;
    v24[a1 - a2 + 116] = *v24;
    ++v24;
  }
  while ( v25 );
  v26 = *(float *)(a1 + 2044);
  *(_DWORD *)(a1 + 2320) = 0;
  *(float *)(a1 + 2300) = v26;
  *(_DWORD *)(a1 + 2308) = 0;
  v27 = *(float *)(a1 + 104);
  *(_DWORD *)(a1 + 2312) = -1;
  *(_DWORD *)(a1 + 2316) = -1;
  *(float *)(a1 + 2304) = v27 + 3.0;
  *(float *)(a1 + 2324) = *(float *)(a3 + 4);
  v28 = *(float *)(a3 + 8);
  *(_BYTE *)(a1 + 2344) = 0;
  *(float *)(a1 + 2328) = v28;
  *(_BYTE *)(a1 + 2345) = 0;
  *(_BYTE *)(a1 + 2346) = 0;
  *(float *)(a1 + 2332) = v20;
  *(_WORD *)(a1 + 5558) = 12;
  *(_DWORD *)(a1 + 5560) = &unk_100984F8;
  *(float *)(a1 + 2336) = 0.0;
  *(_BYTE *)(a1 + 5564) = 1;
  *(float *)(a1 + 2340) = 23.0;
  *(_DWORD *)(a1 + 2348) = 0;
  *(_WORD *)(a1 + 2352) = 0;
  *(_BYTE *)(a1 + 2354) = 0;
  *(_BYTE *)(a1 + 2296) = 0;
  sub_10034CB0((_BYTE *)a3, a1);
  sub_10035190(0, 0, 0.0, a1);
  return sub_10048030(a1 + 5568);
}

//----- (10035D00) --------------------------------------------------------
void __cdecl sub_10035D00(float a1, char *a2, float a3, float a4, float a5, int a6)
{
  int v6; // edi@1
  int v7; // esi@1
  float v8; // ST28_4@1
  double v9; // st7@1
  bool v10; // c0@1
  double v11; // st7@1
  float v12; // ST00_4@2
  double v13; // [sp+28h] [bp-8h]@1
  int v14; // [sp+48h] [bp+18h]@1

  v6 = a6;
  v7 = 0;
  v8 = a1 * 0.5 + *(float *)(a6 + 20);
  v14 = *(int *)(a6 + 16);
  v9 = v8;
  v13 = v9;
  v10 = *(float *)&v14 < v9;
  v11 = *(float *)&v14;
  if ( v10 )
  {
    do
    {
      v12 = v11;
      sub_10034E90(v12, a2, a3, a4, a5, v7++, v6);
      *(float *)&v14 = *(float *)&v14 + a1;
      v11 = *(float *)&v14;
    }
    while ( *(float *)&v14 < v13 );
  }
}

//----- (10035D90) --------------------------------------------------------
int __cdecl sub_10035D90(int a1)
{
  int v2; // [sp+0h] [bp-24h]@1
  float v3; // [sp+4h] [bp-20h]@1
  char v4; // [sp+8h] [bp-1Ch]@1
  float v5; // [sp+10h] [bp-14h]@1
  float v6; // [sp+14h] [bp-10h]@1
  char v7; // [sp+18h] [bp-Ch]@1

  v2 = *(int *)(a1 + 16);
  v3 = -0.2;
  v5 = *(float *)(a1 + 20);
  v4 = 0;
  v6 = -0.2;
  v7 = 0;
  return sub_10035190((int)&v2, 2, 0.0, a1);
}

//----- (10035DF0) --------------------------------------------------------
int __cdecl sub_10035DF0(float a1, float a2, int a3, int a4)
{
  return sub_10035080(a1, a2, 0.0, a3, a4);
}

//----- (10035E20) --------------------------------------------------------
void __usercall sub_10035E20(int a1@<esi>, int a2)
{
  char v2; // ST3C_1@4

  if ( *(_BYTE *)(a1 + 2350) != 1 && *(_DWORD *)(a1 + 2320) )
  {
    if ( (unsigned __int8)sub_10035900(a1 + 2300) )
    {
      v2 = sub_10047DE0(**(float **)(a1 + 48), a1 + 1964, 10, a1 + 5568);
      sub_10047F10(v2, (_DWORD *)(a1 + 2312), (int *)(a1 + 2308), *(_BYTE *)(a1 + 2350), *(_DWORD *)(a1 + 5576));
      sub_1003AD10(a2, a1 + 2300, *(_WORD *)(a1 + 5558), *(_DWORD *)(a1 + 5560), *(_BYTE *)(a1 + 5564));
    }
  }
}

//----- (10035EC0) --------------------------------------------------------
char __cdecl sub_10035EC0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8022:
    case 0x8078:
      sub_100353D0(a4);
      sub_10035840(a4, a1, a1);
      sub_10035690(a4);
      sub_100354E0(a4, a1);
      sub_10035E20(a4, a1);
      sub_10035950(a4);
      sub_10035870(a4, a1);
      result = 1;
      break;
    case 0x8015:
    case 0x8016:
      sub_10035870(a4, a1);
      sub_10035E20(a4, a1);
      goto LABEL_4;
    default:
LABEL_4:
      result = 1;
      break;
  }
  return result;
}

//----- (10035FB0) --------------------------------------------------------
int __cdecl sub_10035FB0(float a1, float a2, float a3, int a4)
{
  int v4; // esi@1
  double v5; // st7@1
  signed int v6; // edi@2
  char v7; // bl@4
  double i; // st7@4
  int v9; // ecx@6
  float v10; // ST00_4@9
  float v12; // [sp+1Ch] [bp-Ch]@2
  double v13; // [sp+20h] [bp-8h]@4
  float v14; // [sp+30h] [bp+8h]@2
  float v15; // [sp+30h] [bp+8h]@7
  int v16; // [sp+38h] [bp+10h]@4

  v4 = a4;
  v5 = a2;
  if ( a2 == 0.0 )
  {
    v6 = 0;
    v14 = 0.5 * a1 + *(float *)(a4 + 20);
    v12 = a1;
  }
  else
  {
    v14 = v5 * 0.5 + *(float *)(a4 + 20);
    v12 = v5;
    v6 = (signed int)(a1 / v5 + 0.5);
  }
  v7 = 0;
  v16 = *(int *)(a4 + 16);
  v13 = v14;
  for ( i = *(float *)&v16; *(float *)&v16 < v13; i = *(float *)&v16 )
  {
    if ( v6 && (v9 = (unsigned __int8)v7, (unsigned __int8)v7 % v6) )
    {
      v15 = a3 * 0.6000000238418579;
      *(float *)(((unsigned __int8)v7 << 6) + v4 + 2372) = 1.5;
    }
    else
    {
      v9 = (unsigned __int8)v7;
      v15 = a3;
      *(float *)(((unsigned __int8)v7 << 6) + v4 + 2372) = 2.0;
    }
    v10 = i;
    sub_10035DF0(v10, v15, v9, v4);
    ++v7;
    *(float *)&v16 = *(float *)&v16 + v12;
  }
  *(_BYTE *)(v4 + 5556) = v7;
  return (unsigned __int8)v7;
}

//----- (100360D0) --------------------------------------------------------
unsigned __int8 __cdecl sub_100360D0(char a1, int a2)
{
  unsigned __int8 result; // al@1
  int v3; // esi@3
  unsigned __int8 v4; // bl@4
  char *v5; // eax@6
  char v6; // cl@7
  char v7; // cl@8
  int v8; // eax@8
  bool v9; // zf@8
  unsigned __int8 v10; // [sp+Ah] [bp-AAh]@1
  unsigned __int8 v11; // [sp+Bh] [bp-A9h]@3
  _BYTE *v12; // [sp+Ch] [bp-A8h]@1
  __int16 v13; // [sp+10h] [bp-A4h]@4
  char v14; // [sp+12h] [bp-A2h]@6
  char v15; // [sp+96h] [bp-1Eh]@8
  char v16; // [sp+ADh] [bp-7h]@8

  result = 0;
  v10 = 0;
  v12 = &unk_100AA6FC;
  if ( !(a1 & 8) )
    v12 = &unk_100AA6E8;
  v3 = (int)v12;
  v11 = 0;
  if ( *v12 != 5 )
  {
    do
    {
      v4 = 0;
      if ( sub_1003E480(0, *(_BYTE *)v3, *(_BYTE *)(v3 + 1), (int)&v13) )
      {
        do
        {
          if ( v10 >= 0x96u )
            break;
          v5 = &v14;
          do
          {
            v6 = *v5;
            *(&v5[38 * v10 - (_DWORD)&v14 + 2] + a2) = *v5;
            ++v5;
          }
          while ( v6 );
          v7 = v16;
          v8 = 38 * v10 + a2;
          *(_WORD *)v8 = v13;
          *(_BYTE *)(v8 + 35) = v7;
          *(_BYTE *)(v8 + 34) = *(_BYTE *)(v3 + 1);
          v9 = (v15 & 0x40) == 64;
          *(_BYTE *)(v8 + 33) = *(_BYTE *)v3;
          ++v10;
          *(_BYTE *)(v8 + 36) = v9;
          ++v4;
        }
        while ( sub_1003E480(v4, *(_BYTE *)v3, *(_BYTE *)(v3 + 1), (int)&v13) );
      }
      v3 = (int)&v12[2 * ++v11];
    }
    while ( v12[2 * v11] != 5 );
    result = v10;
  }
  return result;
}

//----- (10036210) --------------------------------------------------------
char __usercall sub_10036210@<al>(int a1@<eax>)
{
  char result; // al@1

  *(_BYTE *)(a1 + 8) = 0;
  result = 40;
  byte_101B0891 = 40;
  byte_101B0890 = 40;
  return result;
}
// 101B0890: using guessed type char byte_101B0890;
// 101B0891: using guessed type char byte_101B0891;

//----- (10036230) --------------------------------------------------------
char sub_10036230()
{
  char v0; // bl@1
  __int16 v1; // bp@1
  __int16 v2; // di@1
  unsigned int v3; // eax@4
  _DWORD *v4; // ecx@4
  char *v5; // edx@4
  int v6; // esi@8
  int v7; // eax@9
  _BYTE *v8; // ecx@9
  _BYTE *v9; // edx@9
  int v10; // eax@11
  _BYTE *v11; // ecx@11
  _BYTE *v12; // edx@11
  _BYTE *v13; // ecx@13
  _BYTE *v14; // edx@13
  signed int v15; // eax@15
  unsigned int v16; // eax@24
  _DWORD *v17; // ecx@24
  char *v18; // edx@24
  int v19; // esi@28
  int v20; // eax@29
  _BYTE *v21; // ecx@29
  _BYTE *v22; // edx@29
  int v23; // eax@31
  _BYTE *v24; // ecx@31
  _BYTE *v25; // edx@31
  _BYTE *v26; // ecx@33
  _BYTE *v27; // edx@33
  signed int v28; // eax@35
  char v30; // [sp+14h] [bp-144h]@1
  char v31; // [sp+B4h] [bp-A4h]@1

  memset(&v30, 0, 0xA0u);
  memset(&v31, 0, 0xA0u);
  v0 = 0;
  v1 = sub_1003E450(1, 0, 1);
  v2 = sub_1003E450(2, 0, 1);
  sub_1003E480(0, 1, 0, (int)&v31);
  sub_1003E480(0, 2, 0, (int)&v30);
  if ( (unsigned __int16)v2 > (unsigned __int16)word_101B0940 )
  {
LABEL_19:
    v0 = 1;
    goto LABEL_21;
  }
  if ( v2 && v2 == word_101B0940 )
  {
    v3 = 160;
    v4 = &unk_101B0948;
    v5 = &v30;
    do
    {
      if ( *(_DWORD *)v5 != *v4 )
        goto LABEL_8;
      v3 -= 4;
      ++v4;
      v5 += 4;
    }
    while ( v3 >= 4 );
    if ( v3 )
    {
LABEL_8:
      v6 = (unsigned __int8)*v5 - *(_BYTE *)v4;
      if ( (unsigned __int8)*v5 != *(_BYTE *)v4
        || (v7 = v3 - 1, v8 = (char *)v4 + 1, v9 = v5 + 1, v7)
        && ((v6 = *v9 - *v8, *v9 != *v8)
         || (v10 = v7 - 1, v11 = v8 + 1, v12 = v9 + 1, v10)
         && ((v6 = *v12 - *v11, *v12 != *v11)
          || (v13 = v11 + 1, v14 = v12 + 1, v10 != 1) && (v6 = *v14 - *v13, *v14 != *v13))) )
      {
        v15 = 1;
        if ( v6 <= 0 )
          v15 = -1;
LABEL_18:
        if ( v15 )
          goto LABEL_19;
        v0 = 0;
        goto LABEL_21;
      }
    }
    v15 = 0;
    goto LABEL_18;
  }
LABEL_21:
  word_101B0940 = v2;
  qmemcpy(&unk_101B0948, &v30, 0xA0u);
  if ( (unsigned __int16)v1 > (unsigned __int16)word_101B093C )
  {
LABEL_39:
    v0 = 2;
    goto LABEL_40;
  }
  if ( v1 && v1 == word_101B093C )
  {
    v16 = 160;
    v17 = &unk_101B0898;
    v18 = &v31;
    do
    {
      if ( *(_DWORD *)v18 != *v17 )
        goto LABEL_28;
      v16 -= 4;
      ++v17;
      v18 += 4;
    }
    while ( v16 >= 4 );
    if ( v16 )
    {
LABEL_28:
      v19 = (unsigned __int8)*v18 - *(_BYTE *)v17;
      if ( (unsigned __int8)*v18 != *(_BYTE *)v17
        || (v20 = v16 - 1, v21 = (char *)v17 + 1, v22 = v18 + 1, v20)
        && ((v19 = *v22 - *v21, *v22 != *v21)
         || (v23 = v20 - 1, v24 = v21 + 1, v25 = v22 + 1, v23)
         && ((v19 = *v25 - *v24, *v25 != *v24)
          || (v26 = v24 + 1, v27 = v25 + 1, v23 != 1) && (v19 = *v27 - *v26, *v27 != *v26))) )
      {
        v28 = 1;
        if ( v19 <= 0 )
          v28 = -1;
LABEL_38:
        if ( v28 )
          goto LABEL_39;
        goto LABEL_40;
      }
    }
    v28 = 0;
    goto LABEL_38;
  }
LABEL_40:
  qmemcpy(&unk_101B0898, &v31, 0xA0u);
  word_101B093C = v1;
  return v0;
}
// 101B093C: using guessed type __int16 word_101B093C;
// 101B0940: using guessed type __int16 word_101B0940;

//----- (10036470) --------------------------------------------------------
char __usercall sub_10036470@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, int a4, _WORD *a5, int a6)
{
  _WORD *v6; // ebp@1
  int v7; // esi@1
  float *v8; // edx@1
  unsigned __int8 v9; // al@1
  void *v10; // ecx@1
  signed int v11; // ST74_4@1
  bool v12; // cf@1
  char result; // al@2
  void *v14; // ecx@14
  __int16 v15; // si@20
  __int16 v16; // si@20
  __int16 v17; // bx@20
  __int16 v18; // bx@20
  char v19; // ST74_1@20
  unsigned __int8 v20; // al@24
  unsigned int v21; // ecx@26
  unsigned int v22; // eax@32
  int v23; // eax@41
  __int16 v24; // ax@43
  __int16 v25; // ax@48
  unsigned __int8 v26; // cl@50
  unsigned int v27; // edx@50
  int v28; // ebx@54
  __int16 v29; // dx@54
  unsigned int v30; // esi@54
  int v31; // eax@54
  int v32; // ecx@54
  int v33; // ecx@54
  int v34; // esi@62
  unsigned __int8 v35; // cl@64
  int v36; // ebx@66
  char v37; // al@66
  double v38; // st7@67
  double v39; // st7@73
  unsigned int v40; // eax@76
  double v41; // st7@82
  float v42; // ST68_4@86
  float v43; // ST58_4@86
  float v44; // ST58_4@86
  float v45; // ST68_4@86
  float v46; // ST58_4@86
  float v47; // ST58_4@86
  float v48; // ST40_4@86
  signed int v49; // eax@86
  float v50; // ST68_4@86
  float v51; // ST58_4@86
  float v52; // ST58_4@86
  float v53; // ST68_4@86
  float v54; // ST58_4@86
  float v55; // ST58_4@86
  float v56; // ST40_4@86
  float v57; // ST68_4@86
  float v58; // ST58_4@86
  float v59; // ST58_4@86
  float v60; // ST68_4@86
  float v61; // ST58_4@86
  float v62; // ST58_4@86
  double v63; // st7@90
  double v64; // st7@91
  double v65; // ST84_8@96
  float v66; // ST44_4@96
  char *v67; // ST38_4@96
  int v68; // eax@96
  float v69; // ST58_4@96
  char *v70; // ST38_4@96
  int v71; // eax@96
  signed int v72; // ST68_4@98
  float v73; // ST74_4@98
  float v74; // ST34_4@98
  int v75; // esi@99
  __int16 v76; // ax@101
  unsigned __int16 v77; // cx@104
  unsigned __int8 v78; // al@104
  int v79; // ecx@111
  void *v80; // edi@112
  char v81; // cl@113
  int v82; // ebp@113
  char v83; // bl@113
  int v84; // eax@114
  int v85; // esi@128
  double v86; // ST84_8@128
  float v87; // ST8C_4@128
  float v88; // ST58_4@128
  float v89; // ST44_4@128
  int v90; // ebx@128
  float v91; // ST8C_4@128
  float v92; // ST8C_4@128
  float v93; // ST40_4@128
  int v94; // eax@129
  unsigned __int8 v95; // bl@133
  float v96; // ST60_4@137
  signed int v97; // eax@137
  _WORD *v98; // esi@137
  float v99; // ST84_4@137
  float v100; // ST84_4@137
  unsigned __int8 v101; // al@138
  signed int v102; // ST84_4@155
  double v103; // st7@155
  bool v104; // zf@155
  __int16 v105; // ax@157
  unsigned __int16 v106; // cx@157
  __int16 v107; // si@157
  float v108; // ST6C_4@161
  float v109; // ST38_4@161
  float v110; // ST34_4@161
  float v111; // ST6C_4@164
  float v112; // ST40_4@164
  float v113; // ST6C_4@164
  float v114; // ST3C_4@164
  float v115; // ST6C_4@164
  float v116; // ST34_4@164
  float v117; // ST60_4@166
  signed int v118; // eax@166
  float v119; // ST58_4@166
  float v120; // ST6C_4@166
  float v121; // ST6C_4@166
  char *v122; // eax@167
  float *v123; // eax@169
  int v124; // ST44_4@169
  bool v125; // al@172
  bool v126; // bl@176
  int v127; // esi@179
  char v128; // di@180
  float v129; // [sp+8h] [bp-B4h]@128
  float v130; // [sp+10h] [bp-ACh]@128
  float v131; // [sp+10h] [bp-ACh]@166
  int v132; // [sp+14h] [bp-A8h]@20
  float v133; // [sp+24h] [bp-98h]@159
  unsigned __int8 v134; // [sp+29h] [bp-93h]@1
  unsigned __int8 v135; // [sp+2Ah] [bp-92h]@20
  char v136; // [sp+2Ah] [bp-92h]@59
  unsigned __int8 v137; // [sp+2Ah] [bp-92h]@111
  unsigned __int8 v138; // [sp+2Bh] [bp-91h]@24
  unsigned __int8 v139; // [sp+2Ch] [bp-90h]@20
  float v140; // [sp+2Ch] [bp-90h]@69
  float v141; // [sp+2Ch] [bp-90h]@111
  float v142; // [sp+2Ch] [bp-90h]@166
  unsigned __int8 v143; // [sp+31h] [bp-8Bh]@111
  bool v144; // [sp+32h] [bp-8Ah]@24
  unsigned __int8 v145; // [sp+33h] [bp-89h]@1
  __int16 v146; // [sp+34h] [bp-88h]@20
  int v147; // [sp+38h] [bp-84h]@1
  unsigned __int8 v148; // [sp+3Ch] [bp-80h]@24
  char v149; // [sp+3Eh] [bp-7Eh]@22
  bool v150; // [sp+3Fh] [bp-7Dh]@18
  int v151; // [sp+40h] [bp-7Ch]@54
  char v152; // [sp+40h] [bp-7Ch]@174
  float v153; // [sp+44h] [bp-78h]@78
  char v154; // [sp+4Ah] [bp-72h]@1
  char v155; // [sp+4Bh] [bp-71h]@1
  __int16 v156; // [sp+4Ch] [bp-70h]@20
  int v157; // [sp+4Ch] [bp-70h]@112
  float v158; // [sp+58h] [bp-64h]@159
  float v159; // [sp+5Ch] [bp-60h]@76
  float v160; // [sp+64h] [bp-58h]@1
  unsigned int v161; // [sp+68h] [bp-54h]@1
  int v162; // [sp+6Ch] [bp-50h]@1
  int v163; // [sp+70h] [bp-4Ch]@54
  unsigned __int16 v164; // [sp+74h] [bp-48h]@157
  __int16 v165; // [sp+76h] [bp-46h]@157
  __int16 v166; // [sp+78h] [bp-44h]@157
  _WORD *v167; // [sp+7Ch] [bp-40h]@1
  int v168; // [sp+80h] [bp-3Ch]@1
  float v169; // [sp+84h] [bp-38h]@1
  int v170; // [sp+88h] [bp-34h]@52
  float v171; // [sp+8Ch] [bp-30h]@1
  int v172; // [sp+90h] [bp-2Ch]@155
  float v173; // [sp+94h] [bp-28h]@155
  float v174; // [sp+98h] [bp-24h]@155
  __int16 v175; // [sp+9Ch] [bp-20h]@155
  __int16 v176; // [sp+9Eh] [bp-1Eh]@155
  float *v177; // [sp+A0h] [bp-1Ch]@1
  char v178; // [sp+A4h] [bp-18h]@167

  v171 = 0.0;
  v6 = a5;
  v162 = a4;
  v7 = a1;
  v8 = *(float **)(a6 + 12);
  v168 = v7;
  v167 = a5;
  v147 = a2;
  v155 = 5;
  v154 = 5;
  v177 = v8;
  v145 = 0;
  sub_10016BE0(39, &v161);
  memset(word_101B09F8, 0, 0x1644u);
  v9 = sub_100360D0(v161, (int)word_101B09F8);
  v11 = *a5;
  v134 = v9;
  v12 = (unsigned __int8)(dword_101B09EC + 1) < 0xAu;
  v160 = *(float *)(a6 + 4) + 3.0 + 1.0;
  LOBYTE(dword_101B09EC) = dword_101B09EC + 1;
  v169 = (double)v11 + 0.5;
  if ( !v12
    || (result = BYTE1(dword_101B09EC), BYTE1(dword_101B09EC) != byte_1026D91E)
    || (LOWORD(v10) = word_101B09F0, word_101B09F0 != *(_WORD *)a6)
    || !BYTE2(dword_101B09EC) && (result = j_gdi_pvg_cmd_list_execute(0)) == 0 )
  {
    BYTE2(dword_101B09EC) = 1;
    BYTE1(dword_101B09EC) = byte_1026D91E;
    LOBYTE(dword_101B09EC) = 0;
    word_101B09F0 = *(_WORD *)a6;
    if ( v161 & 1 && sub_100405D0(v10) & 3 && !(*(_BYTE *)(v7 + 22) & 0x18) && !sub_100405F0(2) )
    {
      if ( *(_BYTE *)(a6 + 8) )
      {
        sub_10014620(v7, byte_101B0891, 1);
        result = sub_10014620(v7, byte_101B0890, 1);
      }
      else
      {
        sub_10025D80(0);
        sub_10025D70(0);
        sub_10047DA0(0);
        result = sub_10047D60(0);
      }
      return result;
    }
    v150 = v161 & 0x400
        && (sub_100405D0(v10) & 0xC && sub_100405F0(1) || *(_BYTE *)(v7 + 22) & 0x1E || !(sub_100405D0(v14) & 0xC));
    v132 = a3;
    v15 = sub_1003E450(5, 1, 1);
    v16 = v15 - sub_1003E450(3, 1, 1);
    v17 = sub_1003E450(5, 0, 1);
    v146 = v17 - sub_1003E450(3, 0, 1);
    v156 = sub_1003E450(0, 1, 1);
    v18 = sub_1003E450(0, 0, 1);
    v135 = v18 + v156;
    v19 = sub_1003E450(1, 1, 1);
    v139 = v19 + sub_1003E450(1, 0, 1);
    if ( !(~(unsigned __int8)(v161 >> 3) & 1) || !v16 || (v149 = 1, !v146) )
      v149 = 0;
    v144 = (v161 & 0x10000) == 0x10000;
    v138 = 0;
    v20 = (signed int)(*(float *)(v162 + 8) / v160);
    v148 = (signed int)(*(float *)(v162 + 8) / v160);
    if ( ~(unsigned __int8)(v161 >> 3) & 1 )
    {
      if ( v18 )
      {
        v21 = (unsigned __int16)v18;
      }
      else
      {
        if ( v146 )
          goto LABEL_35;
        v21 = (unsigned __int16)v156;
      }
      if ( v20 < v21 )
        LOBYTE(v21) = (signed int)(*(float *)(v162 + 8) / v160);
      v138 = v21;
    }
    else
    {
      v22 = (unsigned __int16)v156 + (unsigned __int16)v18;
      if ( v148 < v22 )
        LOBYTE(v22) = (signed int)(*(float *)(v162 + 8) / v160);
      v138 = v22;
      v20 = (signed int)(*(float *)(v162 + 8) / v160);
    }
LABEL_35:
    if ( v161 & 4 )
    {
      if ( (v161 & 0x8000) == 0x8000 )
      {
        v145 = v134 - v135;
      }
      else if ( v134 <= v20 )
      {
        v145 = 0;
      }
      else
      {
        v145 = v134 - v20;
      }
    }
    v23 = (unsigned __int8)sub_10036230() - 1;
    if ( v23 )
    {
      if ( v23 == 1 )
        v24 = 0;
      else
        v24 = *(_WORD *)a6;
    }
    else
    {
      v24 = v139;
    }
    if ( (unsigned __int16)v24 < *(_WORD *)a6 )
      *(_WORD *)a6 = v24;
    LOBYTE(v25) = v145;
    if ( *(_WORD *)a6 < (unsigned int)v145 )
      v25 = *(_WORD *)a6;
    v26 = v18 + v156;
    v25 = (unsigned __int8)v25;
    v27 = (unsigned __int8)(v134 - v25);
    *(_WORD *)a6 = (unsigned __int8)v25;
    if ( v27 > v135 )
      v26 = v134 - v25;
    v170 = v148;
    if ( v26 >= (unsigned int)v148 )
      v26 = v148;
    v28 = (unsigned __int16)v25;
    v29 = v25;
    v30 = v26;
    v31 = v134 - v26 - (unsigned __int16)v25;
    v32 = v31 < 0;
    LOBYTE(v32) = v31 <= 0;
    v151 = v28;
    v33 = v31 & (v32 - 1);
    v163 = (unsigned __int8)v33;
    if ( v145 && (v29 || (_BYTE)v33) && !v144 )
      v171 = 5.0;
    v136 = sub_10025D50();
    if ( v136 )
    {
      v35 = v148;
    }
    else
    {
      if ( !v134 )
      {
        if ( *(_BYTE *)(a6 + 8) )
        {
          v34 = v168;
          sub_10014620(v168, byte_101B0891, 1);
          result = sub_10014620(v34, byte_101B0890, 1);
          *(_WORD *)a6 = 0;
          word_101B09E8 = -1;
        }
        else
        {
          sub_10025D80(0);
          sub_10025D70(0);
          sub_10047DA0(0);
          result = sub_10047D60(0);
          *(_WORD *)a6 = 0;
          word_101B09E8 = -1;
        }
        return result;
      }
      v35 = 0;
    }
    v36 = v162;
    v37 = *(_BYTE *)(v162 + 12);
    if ( v37 )
      v38 = 2.0;
    else
      v38 = 8.0;
    v140 = v38;
    if ( v149 )
      v140 = v140 + 8.0;
    if ( v144 || v150 )
    {
      v39 = v160;
      v140 = v140 + v160;
    }
    else
    {
      v39 = v160;
    }
    if ( *(_BYTE *)(v162 + 13) )
    {
      v40 = v35;
      v159 = (double)a5[1];
      if ( v30 > v35 )
        v40 = v30;
      v153 = v159 - (v39 * (double)v40 + v140);
    }
    else
    {
      v153 = (double)a5[1];
      if ( v37 )
      {
        if ( v30 <= v35 )
          v30 = v35;
        v41 = v39 * (double)v30;
      }
      else
      {
        v41 = v39 * (double)v170;
      }
      v159 = v41 + v153 + v140;
    }
    BYTE2(dword_101B09EC) = 0;
    j_gdi_pvg_cmd_list_start(0, 2);
    if ( *(_BYTE *)(v36 + 12) )
    {
      v169 = (double)*a5 + 1.5;
      sub_10015770(1.0);
      j_gdi_pvg_begin(66);
      j_gdi_pvg_color_u32(-16777216);
      v42 = v153 - 0.5;
      v43 = (double)*a5 - 0.5;
      sub_10015960(v43, v42);
      v44 = (double)*a5 + *(float *)(v36 + 4) + 0.5;
      sub_10015960(v44, v42);
      v45 = v159 + 0.5;
      v46 = (double)*a5 + *(float *)(v36 + 4) + 0.5;
      sub_10015960(v46, v45);
      v47 = (double)*a5 - 0.5;
      sub_10015960(v47, v45);
      j_gdi_pvg_end(LODWORD(v48));
      j_gdi_pvg_begin(66);
      v49 = sub_10047D20(-1);
      j_gdi_pvg_color_u32(v49);
      v50 = v153 + 0.5;
      v51 = (double)*a5 + 0.5;
      sub_10015960(v51, v50);
      v52 = (double)*a5 + *(float *)(v36 + 4) - 0.5;
      sub_10015960(v52, v50);
      v53 = v159 - 0.5;
      v54 = (double)*a5 + *(float *)(v36 + 4) - 0.5;
      sub_10015960(v54, v53);
      v55 = (double)*a5 + 0.5;
      sub_10015960(v55, v53);
      j_gdi_pvg_end(LODWORD(v56));
      j_gdi_pvg_begin(72);
      j_gdi_pvg_color_u32(-16777216);
      v57 = v153 + 1.0;
      v58 = (double)*a5 + 1.0;
      sub_10015960(v58, v57);
      v59 = (double)*a5 + *(float *)(v36 + 4) - 1.0;
      sub_10015960(v59, v57);
      v60 = v159 - 1.0;
      v61 = (double)*a5 + *(float *)(v36 + 4) - 1.0;
      sub_10015960(v61, v60);
      v62 = (double)*a5 + 1.0;
      sub_10015960(v62, v60);
      j_gdi_pvg_end(v132);
    }
    if ( v150 == 1 && !v144 || !v136 )
    {
      v63 = v153;
      if ( *(_BYTE *)(v36 + 12) )
        v64 = v63 + 1.0 + 3.0;
      else
        v64 = v63 + 6.0;
      v153 = v64;
    }
    if ( v150 == 1 && !v144 )
    {
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      j_gdi_pvg_color_u32(-1);
      v65 = *(float *)(v36 + 4) * 0.5 + (double)*a5;
      v66 = *(float *)(a6 + 4);
      v67 = sub_10040510(0x4E4u);
      v68 = sub_10038970(*(float *)(a6 + 4));
      v69 = v65 - sub_10016930(v68, (int)v67, v66) * 0.5;
      v70 = sub_10040510(0x4E4u);
      v71 = sub_10038970(*(float *)(a6 + 4));
      sub_10016790(v71, (int)v70, v69, v153, v66);
      j_gdi_pvg_disable(35);
      v153 = v153 + v160;
    }
    if ( v136 )
    {
      v72 = *a5;
      v73 = *(float *)(v36 + 4) + (double)v72;
      v74 = (double)v72;
      sub_10038FD0(v74, v153, v73, v159, 0);
      if ( *(_BYTE *)(a6 + 8) )
      {
        v75 = v168;
        sub_10014620(v168, byte_101B0891, 1);
        sub_10014620(v75, byte_101B0890, 1);
        *(_WORD *)a6 = 0;
      }
      else
      {
        sub_10025D80(0);
        sub_10025D70(0);
        sub_10047DA0(0);
        sub_10047D60(0);
        *(_WORD *)a6 = 0;
      }
      return j_gdi_pvg_cmd_list_stop(0);
    }
    v76 = *(_WORD *)a6;
    if ( *(_WORD *)a6 && v76 == word_101B0938 && word_101B09F8[19 * (unsigned __int16)(v76 + v138)] != word_101B09E8 )
    {
      v77 = v134;
      v78 = 0;
      if ( v134 )
      {
        while ( word_101B09F8[19 * v78] != word_101B09E8 )
        {
          if ( ++v78 >= v134 )
            goto LABEL_109;
        }
        v77 = v78;
      }
LABEL_109:
      if ( v77 < v134 )
        *(_WORD *)a6 = v77 - v138;
    }
    v79 = v138;
    v141 = v153;
    word_101B0938 = *(_WORD *)a6;
    word_101B09E8 = word_101B09F8[19 * (v138 + (unsigned __int16)word_101B0938)];
    v137 = 0;
    v143 = 0;
    if ( v134 )
    {
      v157 = -v138;
      v80 = &unk_101B0A19;
      do
      {
        v81 = *((_BYTE *)v80 + 1);
        v82 = (int)v80 - 31;
        v83 = 0;
        if ( v81 || (v84 = v161 & 0x60, v84 != 96) && v84 != 32 && (v84 != 64 || *(_BYTE *)v80) )
        {
          if ( *(_BYTE *)(v82 + 34) || (v161 & 0x60) == 64 && !v81 && *(_BYTE *)v80 == 1 )
            v83 = 2;
        }
        else
        {
          v83 = byte_1026D91E + 1;
        }
        if ( (!*(_BYTE *)v80 && v143 < v138 || v157 >= *(_WORD *)a6) && v137 < v148 )
        {
          j_gdi_pvg_enable(35);
          j_gdi_pvg_blend_func(4, 5);
          j_gdi_pvg_begin(72);
          v85 = (unsigned __int8)v83;
          j_gdi_pvg_color_u32(dword_100AA6AC[*(_BYTE *)v80 + (unsigned __int8)v83 + 2 * *(_BYTE *)v80]);
          v86 = v141 - 2.5;
          v87 = v86;
          v88 = v169 - 0.5;
          sub_10015960(v88, v87);
          v89 = v87;
          v90 = v162;
          v91 = (double)*v167 + *(float *)(v162 + 4) - v171 - 1.0;
          sub_10015960(v91, v89);
          v92 = v160 + v86;
          *(float *)&v86 = (double)*v167 + *(float *)(v90 + 4) - v171 - 1.0;
          sub_10015960(*(float *)&v86, v92);
          sub_10015960(v88, v92);
          j_gdi_pvg_end(LODWORD(v93));
          j_gdi_pvg_color_u32(*(&dword_100AA670 + *(_BYTE *)v80 + v85 + 2 * *(_BYTE *)v80));
          v130 = *(float *)(a6 + 4);
          v129 = v169;
          v94 = v161 & 0x20000 ? sub_10038A00(v130) : sub_10038970(v130);
          sub_10016790(v94, (int)v80 - 31, v129, v141, v130);
          j_gdi_pvg_disable(35);
          ++v137;
          v141 = v141 + v160;
          if ( !*(_BYTE *)(v82 + 33) )
            sub_10048F80(*(_WORD *)((char *)v80 - 33));
        }
        v95 = v143;
        if ( v149 && v143 < 0x95u && !*(_BYTE *)(v82 + 32) && *(_BYTE *)(v82 + 70) )
        {
          v96 = v141 + 1.0;
          j_gdi_pvg_begin(64);
          v97 = sub_10047D20(-1);
          j_gdi_pvg_color_u32(v97);
          v98 = v167;
          v99 = (double)*v167 + 4.0;
          sub_10015960(v99, v96);
          v100 = *(float *)(v162 + 4) + (double)*v98 - 4.0;
          sub_10015960(v100, v96);
          j_gdi_pvg_end(v132);
          v141 = v96 + 7.0;
        }
        v101 = *(_BYTE *)v80;
        if ( *(_BYTE *)v80 < (unsigned __int8)v154 && *(_WORD *)a6 > v157 && (!v101 && v143 >= v138 || v101 == 1) )
          v154 = *(_BYTE *)v80;
        if ( v101 < (unsigned __int8)v155 && v157 + v138 >= v170 + *(_WORD *)a6 && (!v101 || v101 == 1) )
          v155 = *(_BYTE *)v80;
        ++v157;
        v80 = (char *)v80 + 38;
        ++v143;
      }
      while ( (unsigned __int8)(v95 + 1) < v134 );
      v6 = v167;
      v79 = v138;
      v36 = v162;
    }
    if ( v161 & 4 && v134 > v148 && v138 < v148 )
    {
      if ( !v144 )
      {
        v173 = 5.0;
        v172 = 35;
        v174 = (double)(v170 - v79) * v160;
        v102 = *v6;
        v103 = *(float *)(v162 + 4);
        v176 = (signed int)(v160 * (double)v138 + v153 - 3.0);
        v104 = *(_BYTE *)(v162 + 12) == 0;
        v175 = (signed int)(v103 - 5.0 + (double)v102);
        if ( !v104 )
          --v175;
        v105 = v137 - v138;
        v106 = v134 - v138;
        v107 = *(_WORD *)a6;
        v165 = v137 - v138;
        v164 = v134 - v138;
        v166 = v107;
        if ( v149 )
        {
          ++v105;
          ++v106;
          v165 = v105;
          v164 = v106;
        }
        v158 = (v174 - 20.0) * (double)(unsigned __int16)v105 / (double)v106;
        v133 = (v174 - v158 - 20.0) * (double)v107 / (double)(v106 - (unsigned __int16)v105)
             + (double)((signed __int16)(signed int)(v160 * (double)v138 + v153 - 3.0) + 10);
        sub_10037940(v168, v147, (char *)&v172, (int)&v164);
        if ( v166 > 0 && (unsigned __int8)v154 <= 1u )
        {
          v108 = (double)v175 + 5.0;
          v109 = (double)(v176 + 10);
          v110 = (double)v175;
          sub_10038660(9, v110, v109, v108, v133, *(&dword_100AA670 + 3 * (unsigned __int8)v154));
        }
        if ( v166 < (signed int)v164 && (unsigned __int8)v155 <= 1u )
        {
          v111 = (double)v176 + v174 - 10.0;
          v112 = v111;
          v113 = (double)v175 + 5.0;
          v114 = v113;
          v115 = v133 + v158;
          v116 = (double)v175;
          sub_10038660(9, v116, v115, v114, v112, *(&dword_100AA670 + 3 * (unsigned __int8)v155));
        }
        goto LABEL_170;
      }
    }
    else if ( !v144 )
    {
      goto LABEL_170;
    }
    v117 = v159 - v160 - 1.0;
    j_gdi_pvg_begin(64);
    v118 = sub_10047D20(-1);
    j_gdi_pvg_color_u32(v118);
    v119 = v117 + 0.5;
    v120 = (double)*v6 + 4.0;
    sub_10015960(v120, v119);
    v121 = (double)*v6 + *(float *)(v36 + 4) - 4.0;
    sub_10015960(v121, v119);
    j_gdi_pvg_end(v132);
    LODWORD(v131) = (unsigned __int16)v163;
    v142 = v117 + 3.0;
    if ( v150 )
    {
      v122 = sub_10040510(0x4E4u);
      sub_10038570(&v178, 0x14u, "%s  %2d  %2d", v122, v151, v131);
    }
    else
    {
      sub_10038570(&v178, 0x14u, "%2d  %2d", v151, (unsigned __int16)v163);
    }
    v123 = v177;
    v124 = (int)v177;
    *v177 = *(float *)(v36 + 4) * 0.5 + (double)*v6;
    v123[1] = v142;
    sub_10038F80((int)&v178, v124);
LABEL_170:
    v125 = v145 && *(_WORD *)a6;
    v152 = v125;
    v126 = v145 && *(_WORD *)a6 < (unsigned __int16)v145;
    v104 = *(_BYTE *)(a6 + 8) == 0;
    LOBYTE(v163) = v126;
    if ( v104 )
    {
      sub_10025D80(v125);
      v128 = v163;
      sub_10025D70(v163);
      sub_10047DA0(v152);
      sub_10047D60(v128);
    }
    else
    {
      v127 = v168;
      sub_10014620(v168, byte_101B0891, v125 == 0);
      sub_10014620(v127, byte_101B0890, v126 == 0);
    }
    return j_gdi_pvg_cmd_list_stop(0);
  }
  return result;
}
// 10036470: could not find valid save-restore pair for ebx
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 100155E0: using guessed type int __cdecl j_gdi_pvg_cmd_list_execute(_DWORD);
// 100155F0: using guessed type int __cdecl j_gdi_pvg_cmd_list_start(_DWORD, _DWORD);
// 10015600: using guessed type int __cdecl j_gdi_pvg_cmd_list_stop(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 100AA6AC: using guessed type int dword_100AA6AC[];
// 101B0890: using guessed type char byte_101B0890;
// 101B0891: using guessed type char byte_101B0891;
// 101B0938: using guessed type __int16 word_101B0938;
// 101B09E8: using guessed type __int16 word_101B09E8;
// 101B09EC: using guessed type int dword_101B09EC;
// 101B09F0: using guessed type __int16 word_101B09F0;
// 101B09F8: using guessed type __int16 word_101B09F8[];
// 1026D91D: using guessed type char byte_1026D91D;
// 1026D91E: using guessed type char byte_1026D91E;

//----- (10037760) --------------------------------------------------------
char __usercall sub_10037760@<al>(int a1@<ebx>, int a2, int a3, _WORD *a4, int a5, _WORD *a6)
{
  char result; // al@1
  int v7; // eax@6
  int v8; // esi@6

  result = 1;
  if ( *a6 == 32802 )
    goto LABEL_9;
  if ( *a6 == 32833 )
  {
    dword_101B09EC = 0;
    word_101B09F0 = 0;
    _mkgmtime(0);
    sub_10036210(a5);
    v7 = sub_10002860(a2, 36);
    v8 = v7;
    *(_DWORD *)(a5 + 12) = v7;
    *(_DWORD *)v7 = 0;
    *(_DWORD *)(v7 + 4) = 0;
    *(_DWORD *)(v7 + 8) = 0;
    *(_DWORD *)(v7 + 12) = 0;
    *(_DWORD *)(v7 + 24) = 0;
    *(_DWORD *)(v7 + 28) = 0;
    *(_DWORD *)(v7 + 32) = 0;
    *(_DWORD *)(v7 + 16) = 0;
    *(_DWORD *)(v7 + 20) = -4144960;
    *(_DWORD *)(v7 + 8) = sub_10038970(*(float *)(a5 + 4));
    *(float *)(v8 + 24) = 0.5;
    result = 2;
    *(float *)(v8 + 28) = 0.0;
    *(float *)(v8 + 32) = 0.0;
    *(float *)(v8 + 12) = *(float *)(a5 + 4);
    return result;
  }
  if ( *a6 == 32888 )
  {
LABEL_9:
    sub_10036470(a2, (int)a6, a1, a3, a4, a5);
    result = 2;
  }
  return result;
}
// 101B09EC: using guessed type int dword_101B09EC;
// 101B09F0: using guessed type __int16 word_101B09F0;

//----- (10037820) --------------------------------------------------------
_DWORD *__cdecl sub_10037820(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (10037830) --------------------------------------------------------
int __cdecl sub_10037830(int *a1, int a2)
{
  int result; // eax@1
  int i; // esi@1

  result = (int)a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (*(int (__cdecl **)(int, int))i)(i, a2);
  return result;
}

//----- (10037860) --------------------------------------------------------
_DWORD *__cdecl sub_10037860(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (10037870) --------------------------------------------------------
char __cdecl sub_10037870(int a1, int a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == -32744 || !a2 || *(_BYTE *)(a2 + a3) & 2 )
    result = 1;
  return result;
}

//----- (100378A0) --------------------------------------------------------
char __cdecl sub_100378A0(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (100378D0) --------------------------------------------------------
__int16 __cdecl sub_100378D0(unsigned int a1)
{
  return word_100AB23C[(a1 >> 17) & 0xF];
}
// 100AB23C: using guessed type __int16 word_100AB23C[];

//----- (100378F0) --------------------------------------------------------
bool __cdecl sub_100378F0(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  int v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = (int)&a1[dword_102D1B44[8 * v3]];
    if ( a2 )
      *a2 = v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (10037940) --------------------------------------------------------
int __cdecl sub_10037940(int a1, int a2, char *a3, int a4)
{
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@1
  int v8; // [sp+8h] [bp-4h]@1

  v4 = a3;
  sub_100378F0(a3, &v8, 0);
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v5 = *(_DWORD *)(a1 + 56);
  LOWORD(a3) = *(_WORD *)v8 + *(_WORD *)(v5 + 36);
  v6 = *(_DWORD *)v4;
  HIWORD(a3) = *(_WORD *)(v8 + 2) + *(_WORD *)(v5 + 38);
  return ((int (__cdecl *)(int, char *, char **, int, int))dword_102D1B40[2 * (unsigned __int8)v6])(a1, v4, &a3, a4, a2);
}
// 102D1B40: using guessed type int dword_102D1B40[];

//----- (100379B0) --------------------------------------------------------
char __cdecl sub_100379B0(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_10015C20("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = (_WORD *)a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_100378A0(a1, v7, (int)v3);
    sub_100378F0(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_100012F0(a1, (int)v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_102D1B40[2
                                                                              * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                             + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 102D1B40: using guessed type int dword_102D1B40[];

//----- (10037A60) --------------------------------------------------------
int __cdecl sub_10037A60(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_100430B0(&a1, 4u, (int)&unk_100AB880, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_10015C20(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_100AB884 + 2 * v2);
}
// 100AB884: using guessed type void *off_100AB884;

//----- (10037AE0) --------------------------------------------------------
char __cdecl sub_10037AE0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10037B20) --------------------------------------------------------
char __cdecl sub_10037B20(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10015C20("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10037B90) --------------------------------------------------------
signed int __cdecl sub_10037B90(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10015C20("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10037C10) --------------------------------------------------------
char __cdecl sub_10037C10(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10015C20("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (10037C80) --------------------------------------------------------
char __cdecl sub_10037C80(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10015C20("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10037D30) --------------------------------------------------------
char __cdecl sub_10037D30(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10015C20("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (10037E30) --------------------------------------------------------
char __thiscall sub_10037E30(void *this)
{
  int v1; // eax@1

  v1 = sub_100405D0(this);
  return sub_10037D30(v1);
}

//----- (10037E40) --------------------------------------------------------
int __cdecl sub_10037E40(int *a1)
{
  int result; // eax@1

  result = sub_100492C0((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_100160A0();
    result = sub_10046130();
  }
  return result;
}

//----- (10037E70) --------------------------------------------------------
char __usercall sub_10037E70@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_10016170(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1004A380("%i %i\r\n", 13, v2);
    sub_10049920(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_10016150(*(_DWORD *)(a1 + 4));
    v6 = sub_1004A380("%i %i\r\n", 14, v5);
    sub_10049920(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_100AC2D4, (int)v6);
    result = 1;
  }
  else
  {
    sub_10015C20(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10037F10) --------------------------------------------------------
int __cdecl sub_10037F10(const char *a1)
{
  int result; // eax@1

  result = sub_10044450();
  if ( a1 )
    result = sub_100492F0(dword_101B203C[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 101B203C: using guessed type int dword_101B203C[];

//----- (10037F50) --------------------------------------------------------
char __cdecl sub_10037F50(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_10049240((char *)a1 + 4);
  v1 = sub_1004FCA0();
  sub_10046210((int)v1, 0, 0);
  dword_101B203C[sub_10044450()] = (int)a1;
  v2 = sub_1004FC60((int)sub_10037F10);
  return sub_10049310(v2);
}
// 101B203C: using guessed type int dword_101B203C[];

//----- (10037FA0) --------------------------------------------------------
signed int __cdecl sub_10037FA0(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_100160A0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10016220(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_100160A0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_100162B0(&v23);
          }
          while ( sub_100160A0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_10016080(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_100160C0((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1004A380("The %s task is loaded.", &v24);
            sub_10049920(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1004A380("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10049920(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1004A380("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10049920(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1004A380(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10049920(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10016010(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1004A380("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10049920(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1004A380("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10049920(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10049920(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10016100(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_1004FC60((int)sub_10037F10);
        sub_100499F0((int)v15);
        v16 = sub_10051040((int)sub_10037F10);
        sub_100499F0((int)v16);
        v17 = sub_10051040((int)sub_10037F10);
        sub_10049310(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_1004FC60((int)sub_10037F10);
        sub_100499F0((int)v18);
        v19 = sub_10051040((int)sub_10037F10);
        sub_100499F0((int)v19);
        v20 = sub_1004FC60((int)sub_10037F10);
        sub_10049310(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_10037E70(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10038340) --------------------------------------------------------
char **sub_10038340()
{
  return off_100AC2C0;
}
// 100AC2C0: using guessed type char *off_100AC2C0[3];

//----- (10038360) --------------------------------------------------------
int __cdecl sub_10038360(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101B2050 = a1;
  return result;
}
// 101B2050: using guessed type int dword_101B2050;

//----- (10038370) --------------------------------------------------------
int __cdecl sub_10038370(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101B2054 = a1;
  return result;
}
// 101B2054: using guessed type int dword_101B2054;

//----- (10038380) --------------------------------------------------------
char __cdecl sub_10038380(char a1, unsigned __int16 a2, char a3)
{
  char result; // al@1

  result = a1;
  do
    result += a3;
  while ( !(a2 & (unsigned __int16)word_100AD4C0[(unsigned __int8)result]) && result != a1 );
  return result;
}
// 100AD4C0: using guessed type __int16 word_100AD4C0[];

//----- (100383B0) --------------------------------------------------------
void __cdecl sub_100383B0(const char *a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax@2

  if ( a1 )
  {
    v3 = strlen(a1);
    if ( v3 < a2 )
      memset((void *)&a1[v3], a3, a2 - v3);
    a1[a2] = 0;
  }
}

//----- (10038400) --------------------------------------------------------
void __cdecl sub_10038400(const char *a1, char a2, char a3)
{
  unsigned int v3; // esi@4
  unsigned int v4; // ecx@4

  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        v3 = strlen(a1);
        v4 = 0;
        if ( v3 )
        {
          do
          {
            if ( a1[v4] == a2 )
              a1[v4] = a3;
            ++v4;
          }
          while ( v4 < v3 );
        }
      }
    }
  }
}

//----- (10038450) --------------------------------------------------------
int __cdecl sub_10038450(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (100384A0) --------------------------------------------------------
int __cdecl sub_100384A0(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (100384D0) --------------------------------------------------------
int __cdecl sub_100384D0(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (10038530) --------------------------------------------------------
int __cdecl sub_10038530(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10038570) --------------------------------------------------------
int sub_10038570(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_10038530(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (100385A0) --------------------------------------------------------
int __cdecl sub_100385A0(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_10038450((int)&a1[v3], a2, a3 - v3);
}

//----- (100385E0) --------------------------------------------------------
int __cdecl sub_100385E0(int a1, int a2)
{
  return sub_100384D0(a1, "_ ", a2);
}

//----- (10038600) --------------------------------------------------------
signed int __cdecl sub_10038600(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_1008DDDC;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 1 );
  if ( result == 1 )
    result = -1;
  return result;
}
// 1008DDDC: using guessed type int (__cdecl *off_1008DDDC)(int);

//----- (10038630) --------------------------------------------------------
char *__cdecl sub_10038630(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 1 )
    result = byte_100879F8;
  else
    result = (char *)&unk_1008DDE1 + 56 * a1;
  return result;
}

//----- (10038660) --------------------------------------------------------
int __cdecl sub_10038660(int a1, float a2, float a3, float a4, float a5, int a6)
{
  float v6; // ST1C_4@1
  float v7; // ST18_4@1
  _DWORD *v8; // eax@1
  float v9; // ST10_4@1

  v6 = (a4 - a2) * 0.0625;
  v7 = 0.0625 * (a5 - a3);
  j_gdi_pvg_enable(34);
  j_gdi_pvg_color_u32(a6);
  v8 = (_DWORD *)sub_100165A0(a1);
  j_gdi_pvg_bind_texture(34, *v8);
  j_gdi_pvg_begin(72);
  sub_10015890(0.0, 0.0);
  sub_10015960(a2, a5);
  sub_10015890(0.0, v7);
  sub_10015960(a2, a3);
  sub_10015890(v6, v7);
  sub_10015960(a4, a3);
  sub_10015890(v6, 0.0);
  sub_10015960(a4, a5);
  j_gdi_pvg_end(LODWORD(v9));
  return j_gdi_pvg_disable(34);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (10038760) --------------------------------------------------------
int __cdecl sub_10038760(unsigned int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char *v4; // edi@1
  float v5; // ST28_4@1
  float v6; // ST2C_4@1
  float v7; // ST30_4@1
  _DWORD *v8; // eax@1
  float v9; // ST14_4@1
  float v11; // [sp+28h] [bp+8h]@1

  v2 = sub_100165A0(a1);
  v3 = a2;
  v2 += 4;
  v4 = (char *)&unk_100AE1F8 + 8 * *(_BYTE *)a2;
  v5 = *(float *)(a2 + 4) - *(float *)(a2 + 20) * *(float *)(a2 + 12);
  v11 = *(float *)(a2 + 8) - *(float *)(a2 + 24) * *(float *)(a2 + 16);
  v6 = *(float *)(v3 + 12) + v5;
  v7 = *(float *)(v3 + 16) + v11;
  j_gdi_pvg_enable(34);
  sub_100158F0(84, 82, 79.0);
  v8 = (_DWORD *)sub_100165A0(a1);
  j_gdi_pvg_bind_texture(34, *v8);
  j_gdi_pvg_begin(72);
  sub_10015890(*(float *)(v2 + 8 * (unsigned __int8)*v4), *(float *)(v2 + 8 * (unsigned __int8)v4[4] + 4));
  sub_10015960(v5, v11);
  sub_10015890(*(float *)(v2 + 8 * (unsigned __int8)v4[1]), *(float *)(v2 + 8 * (unsigned __int8)v4[5] + 4));
  sub_10015960(v6, v11);
  sub_10015890(*(float *)(v2 + 8 * (unsigned __int8)v4[2]), *(float *)(v2 + 8 * (unsigned __int8)v4[6] + 4));
  sub_10015960(v6, v7);
  sub_10015890(*(float *)(v2 + 8 * (unsigned __int8)v4[3]), *(float *)(v2 + 8 * (unsigned __int8)v4[7] + 4));
  sub_10015960(v5, v7);
  j_gdi_pvg_end(LODWORD(v9));
  return j_gdi_pvg_disable(34);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (100388C0) --------------------------------------------------------
int __cdecl sub_100388C0(int a1, int a2)
{
  int v2; // esi@1
  float v3; // ST24_4@1
  float v4; // ST28_4@1
  float v6; // [sp+24h] [bp+8h]@1
  float v7; // [sp+24h] [bp+8h]@1

  v2 = a2;
  v3 = sub_10016990(*(_DWORD *)(a2 + 8), a1, *(float *)(a2 + 12));
  v6 = sub_10016B80(*(_DWORD *)(v2 + 8), a1, *(float *)(v2 + 12));
  v4 = *(float *)v2 - *(float *)(v2 + 24) * v6;
  v7 = *(float *)(v2 + 4) - *(float *)(v2 + 28) * v3;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v2 + 20));
  sub_100169F0(*(_DWORD *)(v2 + 8), a1, v4, v7, *(float *)(v2 + 12));
  return j_gdi_pvg_disable(35);
}
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10038970) --------------------------------------------------------
int __cdecl sub_10038970(float a1)
{
  double v1; // st7@1
  signed int v2; // ecx@1
  int result; // eax@13

  v1 = a1;
  v2 = 6;
  if ( a1 > 0.0 )
    v2 = 0;
  if ( v1 > 8.0 )
    v2 = 1;
  if ( v1 > 10.0 )
    v2 = 2;
  if ( v1 > 12.5 )
    v2 = 3;
  if ( v1 > 14.0 )
    v2 = 4;
  if ( v1 > 16.0 )
    v2 = 6;
  result = 7;
  if ( v1 <= 20.0 )
    result = v2;
  return result;
}

//----- (10038A00) --------------------------------------------------------
int __cdecl sub_10038A00(float a1)
{
  signed int v1; // ecx@1
  int result; // eax@3

  v1 = 9;
  if ( a1 > 0.0 )
    v1 = 8;
  result = 9;
  if ( a1 <= 14.0 )
    result = v1;
  return result;
}

//----- (10038A30) --------------------------------------------------------
double __cdecl sub_10038A30(float a1, int a2, int a3)
{
  int v3; // edx@1
  double v4; // st7@1
  int v5; // edi@1
  int v6; // ecx@1
  char v7; // bl@2
  double v8; // st6@4
  double result; // st7@5
  signed int v10; // esi@8
  float *v11; // ecx@9
  int v12; // eax@15
  int v13; // ebx@16
  long double v14; // ST14_8@18
  float v15; // [sp+8h] [bp-10h]@2
  float v16; // [sp+10h] [bp-8h]@2
  float v17; // [sp+1Ch] [bp+4h]@15
  float v18; // [sp+1Ch] [bp+4h]@15
  int v19; // [sp+20h] [bp+8h]@2
  int v20; // [sp+24h] [bp+Ch]@2

  v3 = a3;
  v4 = 0.0;
  v5 = a2;
  v6 = a2 + 12 * a3;
  if ( *(float *)(a2 + 12 * a3 - 12) <= (double)*(float *)a2 )
  {
    v15 = *(float *)a2;
    v7 = 1;
    v16 = *(float *)(a2 + 4);
    v20 = *(int *)(v6 - 12);
    v19 = *(int *)(v6 - 8);
  }
  else
  {
    v20 = *(int *)a2;
    v7 = 0;
    v19 = *(int *)(a2 + 4);
    v15 = *(float *)(v6 - 12);
    v16 = *(float *)(v6 - 8);
  }
  v8 = a1;
  if ( *(float *)&v20 <= (double)a1 )
  {
    if ( v15 > v8 )
    {
      v10 = 1;
      if ( v3 > 1 )
      {
        v11 = (float *)(v5 + 12);
        while ( (*v11 <= v8 || v7) && (*v11 >= v8 || !v7) )
        {
          ++v10;
          v11 += 3;
          if ( v10 >= v3 )
            goto LABEL_15;
        }
        v13 = v5 + 12 * v10;
        if ( 1.0 == *(float *)(v13 + 8) )
        {
          v4 = (a1 - *(float *)(v13 - 12)) / (*(float *)v13 - *(float *)(v13 - 12));
        }
        else
        {
          v14 = pow(*(float *)(v13 - 12), *(float *)(v13 + 8));
          v4 = (pow(a1, *(float *)(v13 + 8)) - v14) / (pow(*(float *)v13, *(float *)(v13 + 8)) - v14);
        }
      }
LABEL_15:
      v12 = v5 + 12 * v10;
      v17 = v4 * (*(float *)(v5 + 12 * v10 + 4) - *(float *)(v12 - 8));
      v18 = v17 + *(float *)(v12 - 8);
      result = v18;
    }
    else
    {
      result = v16;
    }
  }
  else
  {
    result = *(float *)&v19;
  }
  return result;
}

//----- (10038B90) --------------------------------------------------------
int __cdecl sub_10038B90(int a1, _WORD *a2, char *a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  char *v8; // ebp@1
  int v9; // edi@1
  int v10; // eax@3
  int v11; // ebx@3
  bool v12; // al@5
  bool v13; // al@9
  _WORD *v14; // edx@11
  int result; // eax@13
  char *v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v7 = a1;
  sub_100012F0(a1, *(_DWORD *)(a1 + 56));
  v8 = a3;
  v9 = 0;
  if ( sub_100378F0(a3, &v17, &v16) )
  {
    do
    {
      if ( sub_10037870(v7, a5, v9) )
      {
        v10 = *(_DWORD *)(v7 + 56);
        LOWORD(a1) = *(_WORD *)a6 + *(_WORD *)v17 + *(_WORD *)(v10 + 36);
        HIWORD(a1) = *(_WORD *)(a6 + 2) + *(_WORD *)(v17 + 2) + *(_WORD *)(v10 + 38);
        v11 = a7;
        v12 = v9 == a7 && sub_100378A0(v7, a2, v10);
        *(_BYTE *)(v7 + 3) = v12;
        v13 = v9 == v11 && *(_DWORD *)(v7 + 56) == *(_DWORD *)(*(_DWORD *)(v7 + 48) + 4);
        v14 = a2;
        *(_BYTE *)(v7 + 9) = v13;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_102D1B40[2 * (*(_DWORD *)v8 & 0xFF)])(
          v7,
          v8,
          &a1,
          *(_DWORD *)(a4 + 4 * v9),
          v14);
      }
      v8 = v16;
      ++v9;
    }
    while ( sub_100378F0(v16, &v17, &v16) );
  }
  result = *a2 - 32802;
  if ( *a2 == 32802 )
  {
    *(_BYTE *)(v7 + 1) = 1;
  }
  else
  {
    result = *a2 - 32888;
    if ( *a2 == 32888 )
    {
      *(_BYTE *)(v7 + 1) = 1;
      result = j_gdi_pvg_flush();
      *(_BYTE *)(v7 + 3) = 0;
      return result;
    }
  }
  *(_BYTE *)(v7 + 3) = 0;
  return result;
}
// 10015740: using guessed type int j_gdi_pvg_flush(void);
// 102D1B40: using guessed type int dword_102D1B40[];

//----- (10038CD0) --------------------------------------------------------
int __cdecl sub_10038CD0(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  __int16 v7; // [sp+0h] [bp-4h]@1
  __int16 v8; // [sp+2h] [bp-2h]@1

  v7 = 0;
  v8 = 0;
  return sub_10038B90(a1, a2, a3, a4, a5, (int)&v7, a6);
}

//----- (10038D10) --------------------------------------------------------
void __usercall sub_10038D10(int a1@<eax>, int a2@<edi>, int a3@<esi>, char a4)
{
  double v4; // st7@1
  double v5; // st6@1
  double v6; // st5@2
  double v7; // st6@6
  float v8; // ST18_4@6
  double v9; // st5@6
  double v10; // st7@6
  float v11; // [sp+8h] [bp-14h]@4
  float v12; // [sp+Ch] [bp-10h]@4
  float v13; // [sp+10h] [bp-Ch]@1
  float v14; // [sp+14h] [bp-8h]@4
  float v15; // [sp+18h] [bp-4h]@1
  float v16; // [sp+20h] [bp+4h]@6
  float v17; // [sp+20h] [bp+4h]@6
  float v18; // [sp+20h] [bp+4h]@6

  v13 = sub_10016930(*(_DWORD *)(a3 + 8), a1, *(float *)(a3 + 12));
  v4 = 4.0;
  v15 = *(float *)(a3 + 12) + 4.0;
  v5 = v13;
  if ( 0.0 == *(float *)(a3 + 32) )
    v6 = v13;
  else
    v6 = *(float *)(a3 + 32);
  v14 = v6 + 4.0;
  v11 = *(float *)a3 - *(float *)(a3 + 24) * v5;
  v12 = *(float *)(a3 + 4) - *(float *)(a3 + 28) * *(float *)(a3 + 12);
  if ( a4 )
  {
    v11 = sub_100706D0(v11, 1.0) + 0.5;
    v12 = sub_100707A0(v12, 1.0);
    v4 = 4.0;
    v5 = v13;
  }
  v16 = (v4 + v5) * *(float *)(a3 + 24) + v11 - 2.0;
  v7 = v14;
  v8 = v16 - *(float *)(a3 + 24) * v14;
  v17 = *(float *)(a3 + 12) * 0.5 + v12;
  v18 = v17 - 0.5 * v15;
  *(float *)(a2 + 304) = v15 + v18;
  *(float *)(a2 + 292) = v8;
  *(float *)(a2 + 300) = v7 + v8;
  v9 = v18;
  *(float *)(a2 + 296) = *(float *)&v9;
  v10 = v12;
  *(float *)(a2 + 36) = v11;
  *(float *)(a2 + 40) = *(float *)&v10;
}

//----- (10038E60) --------------------------------------------------------
void *sub_10038E60()
{
  void *result; // eax@1

  result = (void *)dword_101B2050;
  if ( !dword_101B2050 )
    result = &unk_100AE1D8;
  return result;
}
// 101B2050: using guessed type int dword_101B2050;

//----- (10038E70) --------------------------------------------------------
int __usercall sub_10038E70@<eax>(int a1@<edi>, int a2@<esi>, char a3)
{
  float v3; // ST18_4@1
  float v5; // [sp+Ch] [bp-8h]@1
  float v6; // [sp+10h] [bp-4h]@1

  v3 = sub_10016930(*(_DWORD *)(a2 + 8) & 0x3FFFFFFF, a1, *(float *)(a2 + 12));
  v6 = *(float *)a2 - *(float *)(a2 + 24) * v3;
  v5 = *(float *)(a2 + 4) - *(float *)(a2 + 28) * *(float *)(a2 + 12);
  if ( a3 )
  {
    v6 = sub_100706D0(v6, 1.0) + 0.5;
    v5 = sub_100707A0(v5, 1.0);
  }
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(a2 + 20));
  sub_10016790(*(_DWORD *)(a2 + 8), a1, v6, v5, *(float *)(a2 + 12));
  return j_gdi_pvg_disable(35);
}
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10038F40) --------------------------------------------------------
void __cdecl sub_10038F40(int a1, int a2, int a3)
{
  sub_10038D10(a2, a1, a3, 1);
}

//----- (10038F60) --------------------------------------------------------
int __cdecl sub_10038F60(int a1, int a2)
{
  return sub_10038E70(a1, a2, 0);
}

//----- (10038F80) --------------------------------------------------------
int __cdecl sub_10038F80(int a1, int a2)
{
  return sub_10038E70(a1, a2, 1);
}

//----- (10038FA0) --------------------------------------------------------
int __cdecl sub_10038FA0(unsigned __int8 a1)
{
  if ( a1 >= 2u )
    sub_10015C20("..\\lib\\adl\\cdp_fld_3d_utl.c", 1492, 1, 0);
  return *((_DWORD *)sub_10038E60() + a1 + 4);
}

//----- (10038FD0) --------------------------------------------------------
void __cdecl sub_10038FD0(float a1, float a2, float a3, float a4, char a5)
{
  void *v5; // ebp@3
  float v6; // ST10_4@5
  void *v7; // ecx@5
  void *v8; // ecx@5
  float v9; // ST28_4@5
  float v10; // ST2C_4@5
  double v11; // st7@5
  float v12; // ST28_4@7
  float v13; // ST2C_4@7
  float v14; // ST28_4@7
  float v15; // ST10_4@7
  float v16; // [sp+1Ch] [bp-44h]@5
  char v17; // [sp+20h] [bp-40h]@5
  float v18; // [sp+30h] [bp-30h]@5
  float v19; // [sp+34h] [bp-2Ch]@5
  float v20; // [sp+38h] [bp-28h]@5

  if ( a3 != a1 && a4 != a2 )
  {
    v5 = sub_10038E60();
    j_gdi_pvg_push_attrib(0x2000);
    j_gdi_pvg_enable(38);
    j_gdi_pvg_enable(35);
    j_gdi_pvg_blend_func(4, 5);
    if ( (unsigned __int8)a5 >= 2u )
      sub_10015C20("..\\lib\\adl\\cdp_fld_3d_utl.c", 1596, 1, 0);
    j_gdi_pvg_color_u32(*((_DWORD *)v5 + (unsigned __int8)a5));
    j_gdi_pvg_begin(72);
    sub_10015960(a1, a2);
    sub_10015960(a3, a2);
    sub_10015960(a3, a4);
    sub_10015960(a1, a4);
    j_gdi_pvg_end(LODWORD(v6));
    j_gdi_pvg_read_matrix(&v17, 4, 4, 0);
    v9 = (double)((unsigned int)sub_10025C90(v7) >> 1);
    v10 = (double)((unsigned int)sub_10025C70(v8) >> 1);
    v16 = sqrt(v10 * (v10 * v18 * v18) + v9 * (v9 * v19 * v19) + v20 * v20 * 0.5);
    v11 = 0.0;
    if ( v16 != 0.0 )
      v11 = *((float *)v5 + 7) * 0.5 / v16;
    v12 = v11;
    sub_10015770(*((float *)v5 + 7));
    j_gdi_pvg_color_u32(*((_DWORD *)v5 + (unsigned __int8)a5 + 2));
    j_gdi_pvg_begin(64);
    v13 = v12 + a2;
    sub_10015960(a1, v13);
    v14 = a4 - v12;
    sub_10015960(a3, v14);
    sub_10015960(a3, v13);
    sub_10015960(a1, v14);
    j_gdi_pvg_end(LODWORD(v15));
    sub_10015770(1.0);
    j_gdi_pvg_pop_attrib();
  }
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10015800: using guessed type int j_gdi_pvg_pop_attrib(void);
// 10015820: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);
// 10015840: using guessed type int __cdecl j_gdi_pvg_read_matrix(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10039220) --------------------------------------------------------
void __cdecl sub_10039220(float a1, float a2, float a3, float a4, float a5, float a6, char a7)
{
  double v7; // st6@1
  double v8; // st4@1
  float v9; // ST0C_4@1
  float v10; // ST08_4@1
  float v11; // ST04_4@1
  float v12; // [sp+24h] [bp+10h]@1
  float v13; // [sp+24h] [bp+10h]@1
  float v14; // [sp+24h] [bp+10h]@1
  float v15; // [sp+24h] [bp+10h]@1

  v7 = a4 * a6;
  v8 = a3 * a5;
  v12 = a4 + a2 - v7;
  v9 = v12;
  v13 = a3 + a1 - v8;
  v10 = v13;
  v14 = a2 - v7;
  v11 = v14;
  v15 = a1 - v8;
  sub_10038FD0(v15, v11, v10, v9, a7);
}

//----- (100392A0) --------------------------------------------------------
int __usercall sub_100392A0@<eax>(char a1@<al>, int a2@<ecx>, int a3@<ebx>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  float v6; // ST10_4@1

  v4 = a4;
  v5 = a2;
  sub_10038D10(a3, a4, a2, a1);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 16));
  j_gdi_pvg_begin(72);
  sub_10015960(*(float *)(v4 + 292), *(float *)(v4 + 296));
  sub_10015960(*(float *)(v4 + 300), *(float *)(v4 + 296));
  sub_10015960(*(float *)(v4 + 300), *(float *)(v4 + 304));
  sub_10015960(*(float *)(v4 + 292), *(float *)(v4 + 304));
  j_gdi_pvg_end(LODWORD(v6));
  j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 20));
  sub_10016790(*(_DWORD *)(v5 + 8), a3, *(float *)(v4 + 36), *(float *)(v4 + 40), *(float *)(v5 + 12));
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (10039380) --------------------------------------------------------
int __cdecl sub_10039380(int a1, int a2, int a3)
{
  return sub_100392A0(0, a3, a2, a1);
}

//----- (100393A0) --------------------------------------------------------
int __cdecl sub_100393A0(int a1, int a2, int a3)
{
  return sub_100392A0(1, a3, a2, a1);
}

//----- (100393C0) --------------------------------------------------------
int __cdecl sub_100393C0(int a1, int a2, int a3)
{
  int v3; // eax@5
  char v5; // [sp+8h] [bp-24h]@1
  int v6; // [sp+18h] [bp-14h]@5
  int v7; // [sp+1Ch] [bp-10h]@5

  qmemcpy(&v5, (const void *)a3, 0x24u);
  if ( *(_BYTE *)(a1 + 3) && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_1026D91E || byte_102D1B20) )
  {
    v3 = *(_DWORD *)(a3 + 16);
    v6 = *(_DWORD *)(a3 + 20);
    v7 = v3;
  }
  return sub_100393A0(a1, a2, (int)&v5);
}
// 1026D91E: using guessed type char byte_1026D91E;
// 102D1B20: using guessed type char byte_102D1B20;

//----- (10039430) --------------------------------------------------------
_BYTE *__cdecl sub_10039430(int a1, int a2, char a3)
{
  _BYTE *result; // eax@2
  char v4; // cl@2

  if ( !a3 || (result = sub_10038E60(), result[24] == v4) )
    result = (_BYTE *)sub_10038F60(a1, a2);
  return result;
}

//----- (10039460) --------------------------------------------------------
int __cdecl sub_10039460(int a1)
{
  int v1; // ST0C_4@2
  int v2; // ST0C_4@3
  float *v3; // ebp@5
  float *v4; // ebx@5
  float *v5; // edi@5
  int v6; // esi@5
  double v7; // st7@6
  int v8; // esi@6
  float v9; // ST04_4@6
  float *v10; // edi@6
  float *v11; // ebx@6
  float *v12; // ebp@6
  int v14; // [sp+14h] [bp-Ch]@0
  _DWORD *v15; // [sp+18h] [bp-8h]@5
  int v16; // [sp+1Ch] [bp-4h]@4

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_enable(34);
  if ( *(_BYTE *)(a1 + 1756) )
  {
    v1 = *(_DWORD *)sub_100165A0(0x34u);
    j_gdi_pvg_bind_texture(34, v1);
  }
  else
  {
    v2 = *(_DWORD *)sub_100165A0(0x33u);
    j_gdi_pvg_bind_texture(34, v2);
  }
  sub_100158F0(84, 82, 79.0);
  j_gdi_pvg_begin(68);
  v16 = 0;
  if ( *(_DWORD *)(a1 + 1348) > 0 )
  {
    v3 = (float *)(a1 + 204);
    v4 = (float *)(a1 + 208);
    v5 = (float *)(a1 + 732);
    v6 = a1 + 736;
    v15 = (_DWORD *)(a1 + 1260);
    do
    {
      j_gdi_pvg_color_u32(*v15);
      sub_10015890(*v5, *(float *)v6);
      sub_10015960(*v3, *v4);
      v7 = *(float *)(v6 + 8);
      v8 = v6 + 8;
      v9 = v7;
      v10 = v5 + 2;
      v11 = v4 + 2;
      v12 = v3 + 2;
      sub_10015890(*v10, v9);
      sub_10015960(*v12, *v11);
      v10 += 2;
      v11 += 2;
      v12 += 2;
      sub_10015890(*v10, *(float *)(v8 + 8));
      sub_10015960(*v12, *v11);
      ++v15;
      v6 = v8 + 16;
      v5 = v10 + 2;
      v4 = v11 + 2;
      v3 = v12 + 2;
      ++v16;
    }
    while ( v16 < *(_DWORD *)(a1 + 1348) );
  }
  j_gdi_pvg_end(v14);
  j_gdi_pvg_disable(34);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (100395F0) --------------------------------------------------------
int __cdecl sub_100395F0(int a1)
{
  int v1; // esi@1
  float v2; // ST48_4@1
  float v3; // ST4C_4@1
  float v4; // ST4C_4@1
  float v5; // ST24_4@1
  double v6; // st6@1
  float v7; // ST20_4@1
  float v8; // ST30_4@1
  float v9; // ST28_4@1
  float v10; // ST3C_4@1
  float v11; // ST38_4@1
  float v12; // ST1C_4@1
  float v13; // ST34_4@1
  float v14; // ST2C_4@1
  float v15; // ST40_4@1
  float v16; // ST44_4@1
  float v17; // ST48_4@1
  float v18; // ST4C_4@1
  float v19; // ST50_4@1
  float v20; // ST14_4@1
  float v21; // ST50_4@1
  float v22; // ST50_4@1
  float v23; // ST14_4@1
  float v24; // ST50_4@1
  float v25; // ST20_4@1
  float v26; // ST24_4@1
  float v27; // ST2C_4@1
  float v28; // ST34_4@1
  float v29; // ST10_4@1
  float v30; // ST50_4@1
  float v31; // ST14_4@1
  float v32; // ST50_4@1
  float v33; // ST14_4@1
  float v34; // ST10_4@1
  float v36; // [sp+48h] [bp+4h]@1
  float v37; // [sp+48h] [bp+4h]@1
  float v38; // [sp+48h] [bp+4h]@1
  float v39; // [sp+48h] [bp+4h]@1
  float v40; // [sp+48h] [bp+4h]@1
  float v41; // [sp+48h] [bp+4h]@1

  v1 = a1;
  v2 = *(float *)(a1 + 20) / *(float *)(a1 + 8);
  v36 = *(float *)(a1 + 24) * 0.01745329238474369;
  v3 = cos(v36);
  v4 = v3 * *(float *)(v1 + 8);
  v37 = sin(v36);
  v38 = v37 * *(float *)(v1 + 8);
  v5 = *(float *)(v1 + 12) * v4 + *(float *)v1;
  v6 = v38;
  v7 = *(float *)(v1 + 12) * v38 + *(float *)(v1 + 4);
  v8 = v4 * *(float *)(v1 + 16) + *(float *)v1;
  v9 = v38 * *(float *)(v1 + 16) + *(float *)(v1 + 4);
  v10 = *(float *)v1 + v4;
  v11 = *(float *)(v1 + 4) + v38;
  v12 = v38 * 0.1500000059604645 * v2;
  v39 = -(0.1500000059604645 * v4 * v2);
  v13 = v6 * 0.5 * v2;
  v14 = -(v2 * (0.5 * v4));
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 28));
  j_gdi_pvg_begin(71);
  sub_10015960(v10, v11);
  v15 = v14 + v9;
  v16 = v13 + v8;
  sub_10015960(v16, v15);
  v17 = v39 + v7;
  v18 = v12 + v5;
  sub_10015960(v18, v17);
  v19 = *(float *)(v1 + 4) + v39;
  v20 = v19;
  v21 = *(float *)v1 + v12;
  sub_10015960(v21, v20);
  v22 = *(float *)(v1 + 4) - v39;
  v23 = v22;
  v24 = *(float *)v1 - v12;
  sub_10015960(v24, v23);
  v25 = v7 - v39;
  v26 = v5 - v12;
  sub_10015960(v26, v25);
  v27 = v9 - v14;
  v28 = v8 - v13;
  sub_10015960(v28, v27);
  j_gdi_pvg_end(LODWORD(v29));
  j_gdi_pvg_enable(35);
  j_gdi_pvg_enable(38);
  j_gdi_pvg_color_u32(-16777216);
  j_gdi_pvg_begin(66);
  sub_10015960(v10, v11);
  sub_10015960(v16, v15);
  sub_10015960(v18, v17);
  v30 = *(float *)(v1 + 4) + v39;
  v31 = v30;
  v32 = *(float *)v1 + v12;
  sub_10015960(v32, v31);
  v40 = *(float *)(v1 + 4) - v39;
  v33 = v40;
  v41 = *(float *)v1 - v12;
  sub_10015960(v41, v33);
  sub_10015960(v26, v25);
  sub_10015960(v28, v27);
  j_gdi_pvg_end(LODWORD(v34));
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (10039900) --------------------------------------------------------
int __cdecl sub_10039900(int a1)
{
  int v1; // esi@1
  unsigned int v2; // eax@1
  unsigned int v3; // edi@1
  float v4; // ST10_4@1
  float v5; // ST10_4@1
  float v6; // ST10_4@1
  int v8; // [sp+8h] [bp-8h]@0
  unsigned int v9; // [sp+14h] [bp+4h]@1
  float v10; // [sp+14h] [bp+4h]@1
  float v11; // [sp+14h] [bp+4h]@1
  float v12; // [sp+14h] [bp+4h]@1
  float v13; // [sp+14h] [bp+4h]@1
  float v14; // [sp+14h] [bp+4h]@1
  float v15; // [sp+14h] [bp+4h]@1
  float v16; // [sp+14h] [bp+4h]@1
  float v17; // [sp+14h] [bp+4h]@1
  float v18; // [sp+14h] [bp+4h]@1
  float v19; // [sp+14h] [bp+4h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v1 = a1;
  v9 = *(_DWORD *)(a1 + 16);
  v2 = v9;
  BYTE1(v9) >>= 1;
  LOBYTE(v9) = (unsigned __int8)v9 >> 1;
  BYTE2(v9) = (unsigned __int8)(v2 >> 16) >> 1;
  j_gdi_pvg_begin(73);
  v3 = v9;
  j_gdi_pvg_color_u32(v9);
  sub_10015960(*(float *)v1, *(float *)(v1 + 4));
  v10 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  sub_10015960(*(float *)v1, v10);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v11 = *(float *)(v1 + 8) * 0.25 + *(float *)v1;
  sub_10015960(v11, *(float *)(v1 + 4));
  v12 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v4 = v12;
  v13 = *(float *)(v1 + 8) * 0.25 + *(float *)v1;
  sub_10015960(v13, v4);
  v14 = *(float *)(v1 + 8) * 0.75 + *(float *)v1;
  sub_10015960(v14, *(float *)(v1 + 4));
  v15 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v5 = v15;
  v16 = *(float *)(v1 + 8) * 0.75 + *(float *)v1;
  sub_10015960(v16, v5);
  j_gdi_pvg_color_u32(v3);
  v17 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v17, *(float *)(v1 + 4));
  v18 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v6 = v18;
  v19 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v19, v6);
  j_gdi_pvg_end(v8);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (10039A80) --------------------------------------------------------
int __cdecl sub_10039A80(float a1, float a2, float a3, float a4, char a5, int a6)
{
  double v6; // st7@4
  char v8; // [sp+0h] [bp-1Ch]@4
  float v9; // [sp+4h] [bp-18h]@1
  float v10; // [sp+8h] [bp-14h]@1
  float v11; // [sp+Ch] [bp-10h]@1
  float v12; // [sp+10h] [bp-Ch]@1
  float v13; // [sp+14h] [bp-8h]@4
  float v14; // [sp+18h] [bp-4h]@8

  v12 = a4;
  v11 = a3;
  v9 = a1;
  v10 = a2;
  if ( a5 )
  {
    if ( a5 == 2 )
    {
      v8 = 3;
      v13 = 1.0;
      v6 = 0.5;
    }
    else if ( a5 == 3 )
    {
      v8 = 1;
      v13 = 0.0;
      v6 = 0.5;
    }
    else
    {
      v8 = 2;
      v13 = 0.5;
      v6 = 0.0;
    }
  }
  else
  {
    v8 = 0;
    v13 = 0.5;
    v6 = 1.0;
  }
  v14 = v6;
  j_gdi_pvg_color_u32(a6);
  j_gdi_pvg_enable(35);
  sub_10038760(4u, (int)&v8);
  return j_gdi_pvg_disable(35);
}
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);

//----- (10039B30) --------------------------------------------------------
int __cdecl sub_10039B30(int a1)
{
  int v1; // esi@1
  unsigned int v2; // eax@1
  double v3; // st7@2
  int v4; // edi@4
  float v5; // ST18_4@4
  float v6; // ST18_4@4
  float v7; // ST18_4@4
  float v8; // ST0C_4@4
  float v9; // ST18_4@4
  float v10; // ST18_4@4
  float v11; // ST18_4@4
  float v12; // ST0C_4@4
  float v13; // ST18_4@4
  float v14; // ST08_4@4
  float v15; // ST18_4@4
  float v16; // ST0C_4@4
  float v17; // ST18_4@4
  float v18; // ST18_4@4
  float v19; // ST18_4@4
  float v20; // ST0C_4@4
  float v21; // ST18_4@4
  float v22; // ST18_4@4
  float v23; // ST0C_4@4
  float v24; // ST18_4@4
  float v25; // ST18_4@4
  float v26; // ST0C_4@4
  float v27; // ST18_4@4
  float v28; // ST18_4@4
  float v29; // ST0C_4@4
  float v30; // ST18_4@4
  float v31; // ST08_4@4
  float v32; // ST18_4@4
  float v33; // ST0C_4@4
  float v34; // ST18_4@4
  float v35; // ST18_4@4
  float v36; // ST0C_4@4
  float v37; // ST18_4@4
  float v38; // ST0C_4@4
  float v39; // ST18_4@4
  float v40; // ST0C_4@4
  float v41; // ST18_4@4
  float v42; // ST0C_4@4
  int v44; // [sp+10h] [bp-4h]@1
  float v45; // [sp+18h] [bp+4h]@4
  float v46; // [sp+18h] [bp+4h]@4

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v1 = a1;
  v2 = *(_DWORD *)(a1 + 16);
  v44 = *(_DWORD *)(a1 + 16);
  BYTE1(v44) >>= 1;
  LOBYTE(v44) = (unsigned __int8)v2 >> 1;
  BYTE2(v44) = (unsigned __int8)(v2 >> 16) >> 1;
  if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a1 + 8)) & 0x7FFFFFFF) > (double)*(float *)(a1 + 12) )
    v3 = 0.0;
  else
    v3 = COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a1 + 8)) & 0x7FFFFFFF) - *(float *)(a1 + 12);
  v45 = v3;
  j_gdi_pvg_begin(73);
  v4 = v44;
  j_gdi_pvg_color_u32(v44);
  sub_10015960(*(float *)v1, *(float *)(v1 + 4));
  v5 = *(float *)(v1 + 4) + v45;
  sub_10015960(*(float *)v1, v5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v6 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_10015960(v6, *(float *)(v1 + 4));
  v7 = *(float *)(v1 + 4) + v45;
  v8 = v7;
  v9 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_10015960(v9, v8);
  j_gdi_pvg_color_u32(v4);
  v10 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v10, *(float *)(v1 + 4));
  v11 = *(float *)(v1 + 4) + v45;
  v12 = v11;
  v13 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v13, v12);
  j_gdi_pvg_end(LODWORD(v14));
  j_gdi_pvg_begin(73);
  v15 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v16 = v15;
  v17 = *(float *)v1 - *(float *)(v1 + 8);
  sub_10015960(v17, v16);
  v18 = *(float *)(v1 + 4) + v45;
  sub_10015960(*(float *)v1, v18);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v19 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v20 = v19;
  v21 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_10015960(v21, v20);
  v22 = *(float *)(v1 + 4) + v45;
  v23 = v22;
  v24 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_10015960(v24, v23);
  j_gdi_pvg_color_u32(v4);
  v25 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v26 = v25;
  v27 = *(float *)(v1 + 8) + *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v27, v26);
  v28 = *(float *)(v1 + 4) + v45;
  v29 = v28;
  v30 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v30, v29);
  j_gdi_pvg_end(LODWORD(v31));
  j_gdi_pvg_enable(38);
  j_gdi_pvg_begin(64);
  sub_10015770(2.0);
  v32 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v33 = v32;
  v34 = *(float *)(v1 + 8) + *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v34, v33);
  v35 = *(float *)(v1 + 4) + v45;
  v36 = v35;
  v37 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v37, v36);
  sub_10015770(1.0);
  j_gdi_pvg_end(LODWORD(v38));
  j_gdi_pvg_disable(38);
  j_gdi_pvg_enable(38);
  j_gdi_pvg_begin(64);
  sub_10015770(2.0);
  v39 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v40 = v39;
  v41 = *(float *)v1 - *(float *)(v1 + 8);
  sub_10015960(v41, v40);
  v46 = *(float *)(v1 + 4) + v45;
  sub_10015960(*(float *)v1, v46);
  sub_10015770(1.0);
  j_gdi_pvg_end(LODWORD(v42));
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (10039EC0) --------------------------------------------------------
int __cdecl sub_10039EC0(float a1, float a2, float a3, float a4, int a5, int a6)
{
  int v6; // esi@1
  unsigned int v7; // eax@1
  double v8; // ST18_8@1
  double v9; // ST20_8@1
  float v10; // ST0C_4@1
  float v11; // ST0C_4@1
  float v13; // [sp+28h] [bp+Ch]@1
  float v14; // [sp+2Ch] [bp+10h]@1
  int v15; // [sp+30h] [bp+14h]@1

  v6 = a5;
  v7 = (unsigned int)a5 >> 16;
  BYTE1(a5) >>= 1;
  LOBYTE(a5) = (unsigned __int8)a5 >> 1;
  BYTE2(a5) = (unsigned __int8)v7 >> 1;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(v6);
  j_gdi_pvg_begin(71);
  sub_10015960(a1, a2);
  j_gdi_pvg_color_u32(a5);
  v8 = a3 * 0.5;
  *(float *)&v15 = a1 - v8;
  sub_10015960(*(float *)&v15, a2);
  v9 = a4 * 0.5;
  v13 = a2 - v9;
  sub_10015960(a1, v13);
  v14 = a1 + v8;
  sub_10015960(v14, a2);
  *(float *)&v8 = a2 + v9;
  sub_10015960(a1, *(float *)&v8);
  sub_10015960(*(float *)&v15, a2);
  j_gdi_pvg_end(LODWORD(v10));
  j_gdi_pvg_enable(38);
  sub_10015770(1.0);
  j_gdi_pvg_color_u32(a6);
  j_gdi_pvg_begin(66);
  sub_10015960(*(float *)&v15, a2);
  sub_10015960(a1, v13);
  sub_10015960(v14, a2);
  sub_10015960(a1, *(float *)&v8);
  j_gdi_pvg_end(LODWORD(v11));
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003A060) --------------------------------------------------------
int __usercall sub_1003A060@<eax>(int a1@<edi>, float a2, float a3, float a4, float a5, float a6, float a7, int a8)
{
  double v8; // st7@1
  double v9; // st6@1
  float v10; // ST20_4@3
  double v11; // st7@3
  float v12; // ST20_4@3
  signed int v13; // edi@3
  signed int v14; // esi@5
  int i; // ebx@5
  signed int j; // esi@10
  float v17; // ST1C_4@11
  float v18; // ST0C_4@11
  float v19; // ST1C_4@11
  float v20; // ST1C_4@11
  float v21; // ST0C_4@11
  float v22; // ST1C_4@11
  signed int k; // esi@13
  float v24; // ST1C_4@14
  float v25; // ST0C_4@14
  float v26; // ST1C_4@14
  int l; // esi@15
  float v28; // ST1C_4@16
  float v29; // ST0C_4@16
  float v30; // ST1C_4@16
  int v32; // [sp+8h] [bp-1ACh]@3
  float v33; // [sp+14h] [bp-1A0h]@3
  int v34; // [sp+1Ch] [bp-198h]@8
  int v35; // [sp+20h] [bp-194h]@8
  float v36[49]; // [sp+24h] [bp-190h]@11
  float v37; // [sp+E8h] [bp-CCh]@8
  float v38[50]; // [sp+ECh] [bp-C8h]@11

  sub_10015770(1.0);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_enable(38);
  v8 = a6;
  v9 = a7;
  if ( a7 > (double)a6 )
  {
    v9 = a6;
    v8 = a7;
  }
  v10 = v9;
  v33 = v8;
  v32 = a1;
  v11 = v10;
  v12 = (v33 - v10) * 0.1333333402872086;
  v13 = (signed int)(COERCE_FLOAT(LODWORD(v12) & 0x7FFFFFFF) + 1.990000009536743);
  if ( v13 >= 50 )
    v13 = 50;
  v14 = 0;
  for ( i = (unsigned __int64)(v11 * 11930464.71111111);
        v14 < v13;
        *((float *)&v35 + v14) = 4.656612873077393e-10 * (double)v35 )
  {
    if ( v14 == v13 - 1 )
      i = (unsigned __int64)(v33 * 11930464.71111111);
    sub_10070C80(i, &v35, &v34);
    ++v14;
    i += 89478485;
    *(&v37 + v14) = (double)v34 * 4.656612873077393e-10;
  }
  j_gdi_pvg_color_u32(a8);
  if ( a4 - a5 > 1.5 )
  {
    j_gdi_pvg_begin(73);
    for ( j = 0; j < v13; ++j )
    {
      v17 = v36[j] * a4 + a3;
      v18 = v17;
      v19 = a4 * v38[j] + a2;
      sub_10015960(v19, v18);
      v20 = v36[j] * a5 + a3;
      v21 = v20;
      v22 = a5 * v38[j] + a2;
      sub_10015960(v22, v21);
    }
    j_gdi_pvg_end(v32);
  }
  j_gdi_pvg_begin(66);
  for ( k = 0; k < v13; ++k )
  {
    v24 = v36[k] * a5 + a3;
    v25 = v24;
    v26 = a5 * v38[k] + a2;
    sub_10015960(v26, v25);
  }
  for ( l = v13 - 1; l >= 0; --l )
  {
    v28 = v36[l] * a4 + a3;
    v29 = v28;
    v30 = a4 * v38[l] + a2;
    sub_10015960(v30, v29);
  }
  j_gdi_pvg_end(v32);
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 1003A060: could not find valid save-restore pair for edi
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 1003A060: using guessed type float var_190[49];
// 1003A060: using guessed type float var_C8[50];

//----- (1003A310) --------------------------------------------------------
int __cdecl sub_1003A310(float a1, float a2, float a3, float a4, int a5)
{
  _DWORD *v5; // eax@1
  float v6; // ST14_4@1
  float v8; // [sp+Ch] [bp+4h]@1
  float v9; // [sp+18h] [bp+10h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_enable(34);
  v5 = (_DWORD *)sub_100165A0(a5);
  j_gdi_pvg_bind_texture(34, *v5);
  sub_100158F0(84, 82, 79.0);
  j_gdi_pvg_color_u32(-1);
  j_gdi_pvg_begin(72);
  sub_10015890(0.0, 0.0);
  v9 = a2 + a4;
  sub_10015960(a1, v9);
  sub_10015890(0.0, 1.0);
  sub_10015960(a1, a2);
  sub_10015890(1.0, 1.0);
  v8 = a1 + a3;
  sub_10015960(v8, a2);
  sub_10015890(1.0, 0.0);
  sub_10015960(v8, v9);
  j_gdi_pvg_end(LODWORD(v6));
  j_gdi_pvg_disable(34);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003A420) --------------------------------------------------------
int __cdecl sub_1003A420(float a1, float a2, float a3, float a4, int a5, float a6)
{
  float v6; // ST08_4@1
  float v8; // [sp+Ch] [bp+4h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(a5);
  sub_10015770(a6);
  j_gdi_pvg_begin(66);
  v8 = a1 - 0.5;
  sub_10015960(v8, a2);
  sub_10015960(a3, a2);
  sub_10015960(a3, a4);
  sub_10015960(v8, a4);
  j_gdi_pvg_end(LODWORD(v6));
  sub_10015770(1.0);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003A4D0) --------------------------------------------------------
int __cdecl sub_1003A4D0(float a1, float a2, float a3, float a4, int a5, float a6)
{
  float v6; // ST08_4@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(a5);
  sub_10015770(a6);
  j_gdi_pvg_begin(64);
  sub_10015960(a1, a2);
  sub_10015960(a3, a4);
  j_gdi_pvg_end(LODWORD(v6));
  sub_10015770(1.0);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003A550) --------------------------------------------------------
int __cdecl sub_1003A550(float a1, float a2, float a3, float a4, int a5, float a6, int a7)
{
  _DWORD *v7; // eax@1
  float v8; // ST2C_4@1
  int v9; // ecx@1
  double v10; // st7@1
  double v11; // st4@3
  double v12; // st3@3
  float v13; // ST30_4@5
  float v14; // ST38_4@5
  float v15; // ST28_4@5
  float v16; // ST38_4@5
  float v17; // ST28_4@5
  float v18; // ST28_4@5
  float v19; // ST28_4@5
  float v20; // ST24_4@5
  float v22; // [sp+8h] [bp-10h]@3
  double v23; // [sp+Ch] [bp-Ch]@1
  float v24; // [sp+Ch] [bp-Ch]@3
  float v25; // [sp+20h] [bp+8h]@5
  float v26; // [sp+20h] [bp+8h]@5
  float v27; // [sp+20h] [bp+8h]@5
  float v28; // [sp+20h] [bp+8h]@5
  float v29; // [sp+20h] [bp+8h]@5
  float v30; // [sp+20h] [bp+8h]@5
  float v31; // [sp+30h] [bp+18h]@3

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_enable(34);
  v7 = (_DWORD *)sub_100165A0(a7);
  j_gdi_pvg_bind_texture(34, *v7);
  sub_100158F0(84, 82, 79.0);
  j_gdi_pvg_color_u32(a5);
  v23 = a3 - a1;
  v8 = sqrt(v23 * v23 + (a4 - a2) * (a4 - a2));
  v9 = 3 * sub_100430B0(&a7, 4u, (int)&unk_100AE860, 12, 6, 0);
  v10 = v8;
  if ( v8 <= 0.1000000014901161 )
    v10 = (float)0.1;
  v11 = a6;
  v12 = 0.5 * a6;
  v22 = (a2 - a4) * v12 / v10;
  v31 = v12 * v23 / v10;
  v24 = v11 * flt_100AE864[v9];
  if ( v24 <= 0.1000000014901161 )
    v24 = 0.1;
  v13 = v10 * flt_100AE868[v9] / v24;
  j_gdi_pvg_begin(72);
  sub_10015890(0.0, 0.0);
  v14 = v31 + a2;
  v15 = v14;
  v16 = v22 + a1;
  sub_10015960(v16, v15);
  sub_10015890(0.0, 1.0);
  v25 = a2 - v31;
  v17 = v25;
  v26 = a1 - v22;
  sub_10015960(v26, v17);
  sub_10015890(v13, 1.0);
  v27 = a4 - v31;
  v18 = v27;
  v28 = a3 - v22;
  sub_10015960(v28, v18);
  sub_10015890(v13, 0.0);
  v29 = v31 + a4;
  v19 = v29;
  v30 = v22 + a3;
  sub_10015960(v30, v19);
  j_gdi_pvg_end(LODWORD(v20));
  j_gdi_pvg_disable(34);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 100AE864: using guessed type float flt_100AE864[];
// 100AE868: using guessed type float flt_100AE868[];

//----- (1003A780) --------------------------------------------------------
int __cdecl sub_1003A780(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  int v7; // esi@1
  unsigned int v8; // eax@1
  double v9; // ST28_8@5
  int v10; // edi@5
  double v11; // ST30_8@5
  float v12; // ST20_4@5
  double v13; // ST18_8@5
  float v14; // ST14_4@5
  float v15; // ST04_4@5
  double v16; // st7@5
  double v17; // ST30_8@7
  int v18; // edi@7
  double v19; // ST20_8@7
  float v20; // ST28_4@7
  float v21; // ST18_4@7
  double v22; // ST30_8@7
  float v23; // ST14_4@7
  float v24; // ST04_4@7
  float v25; // ST04_4@8
  float v26; // ST04_4@8
  float v28; // [sp+4h] [bp-30h]@5
  float v29; // [sp+14h] [bp-20h]@1
  float v30; // [sp+48h] [bp+14h]@5
  float v31; // [sp+48h] [bp+14h]@7
  int v32; // [sp+4Ch] [bp+18h]@5
  int v33; // [sp+4Ch] [bp+18h]@7

  v7 = a6;
  v29 = 1.0;
  v8 = (unsigned int)a6 >> 16;
  BYTE1(a6) >>= 1;
  LOBYTE(a6) = (unsigned __int8)a6 >> 1;
  BYTE2(a6) = (unsigned __int8)v8 >> 1;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( !LOBYTE(a5) )
  {
    v29 = -1.0;
    goto LABEL_7;
  }
  if ( LOBYTE(a5) != 2 )
  {
    if ( LOBYTE(a5) == 3 )
    {
      v29 = -1.0;
      goto LABEL_5;
    }
LABEL_7:
    j_gdi_pvg_begin(71);
    j_gdi_pvg_color_u32(v7);
    v17 = v29 * a4;
    v31 = a2 - v17;
    sub_10015960(a1, v31);
    v18 = a6;
    j_gdi_pvg_color_u32(a6);
    v19 = a3 * 0.5;
    v20 = a1 - v19;
    sub_10015960(v20, v31);
    v21 = a2 - v17 * 0.699999988079071;
    v22 = a3 * 0.1000000014901161;
    *(float *)&v33 = a1 - v22;
    sub_10015960(*(float *)&v33, v21);
    sub_10015960(*(float *)&v33, a2);
    j_gdi_pvg_color_u32(v7);
    sub_10015960(a1, a2);
    j_gdi_pvg_color_u32(v18);
    v23 = a1 + v22;
    sub_10015960(v23, a2);
    sub_10015960(v23, v21);
    *(float *)&v19 = a1 + v19;
    sub_10015960(*(float *)&v19, v31);
    j_gdi_pvg_end(LODWORD(v24));
    j_gdi_pvg_enable(38);
    sub_10015770(1.0);
    j_gdi_pvg_color_u32(a7);
    j_gdi_pvg_begin(66);
    sub_10015960(a1, a2);
    sub_10015960(*(float *)&v33, a2);
    sub_10015960(*(float *)&v33, v21);
    sub_10015960(v20, v31);
    sub_10015960(*(float *)&v19, v31);
    sub_10015960(v23, v21);
    v28 = a2;
    v16 = v23;
    goto LABEL_8;
  }
LABEL_5:
  j_gdi_pvg_begin(71);
  j_gdi_pvg_color_u32(v7);
  v9 = v29 * a3;
  v30 = a1 - v9;
  sub_10015960(v30, a2);
  v10 = a6;
  j_gdi_pvg_color_u32(a6);
  v11 = a4 * 0.5;
  v12 = a2 - v11;
  sub_10015960(v30, v12);
  v13 = a4 * 0.1000000014901161;
  *(float *)&v32 = a2 - v13;
  v14 = a1 - v9 * 0.699999988079071;
  sub_10015960(v14, *(float *)&v32);
  sub_10015960(a1, *(float *)&v32);
  j_gdi_pvg_color_u32(v7);
  sub_10015960(a1, a2);
  j_gdi_pvg_color_u32(v10);
  *(float *)&v13 = a2 + v13;
  sub_10015960(a1, *(float *)&v13);
  sub_10015960(v14, *(float *)&v13);
  *(float *)&v9 = a2 + v11;
  sub_10015960(v30, *(float *)&v9);
  j_gdi_pvg_end(LODWORD(v15));
  j_gdi_pvg_enable(38);
  sub_10015770(1.0);
  j_gdi_pvg_color_u32(a7);
  j_gdi_pvg_begin(66);
  sub_10015960(a1, a2);
  sub_10015960(a1, *(float *)&v32);
  sub_10015960(v14, *(float *)&v32);
  sub_10015960(v30, v12);
  sub_10015960(v30, *(float *)&v9);
  sub_10015960(v14, *(float *)&v13);
  v28 = *(float *)&v13;
  v16 = a1;
LABEL_8:
  v25 = v16;
  sub_10015960(v25, v28);
  j_gdi_pvg_end(LODWORD(v26));
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003ABF0) --------------------------------------------------------
int __cdecl sub_1003ABF0(float a1, float a2, float a3, int a4)
{
  float v4; // ST08_4@1
  float v6; // [sp+Ch] [bp+4h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(a4);
  sub_10015770(3.0);
  j_gdi_pvg_begin(64);
  sub_10015960(a1, a2);
  v6 = a1 + a3;
  sub_10015960(v6, a2);
  j_gdi_pvg_end(LODWORD(v4));
  sub_10015770(1.0);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003AC80) --------------------------------------------------------
int __cdecl sub_1003AC80(int a1, int a2, int a3, float a4)
{
  int i; // esi@1
  int v6; // [sp+Ch] [bp-8h]@0

  j_gdi_pvg_color_u32(a3);
  sub_10015770(a4);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_enable(38);
  j_gdi_pvg_begin(67);
  for ( i = 0; i < a2; ++i )
    sub_10015960(*(float *)(a1 + 8 * i), *(float *)(a1 + 8 * i + 4));
  j_gdi_pvg_end(v6);
  j_gdi_pvg_disable(38);
  j_gdi_pvg_disable(35);
  return sub_10015770(1.0);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003AD10) --------------------------------------------------------
char __cdecl sub_1003AD10(int a1, int a2, unsigned __int16 a3, int a4, char a5)
{
  int v5; // edx@1
  double v6; // st7@1
  int v7; // eax@1
  float v8; // ST10_4@1
  int v9; // eax@1
  const char *v10; // edi@1
  double v11; // st7@2
  char v12; // al@2
  int v13; // edx@3
  char *v14; // ecx@3
  double v15; // st7@11
  float *v16; // ecx@13
  int v17; // eax@16
  double v18; // st6@17
  bool v19; // zf@17
  char v21; // [sp+1Fh] [bp-65h]@1
  __int16 v22; // [sp+20h] [bp-64h]@17
  __int16 v23; // [sp+22h] [bp-62h]@17
  float v24; // [sp+24h] [bp-60h]@11
  float v25; // [sp+28h] [bp-5Ch]@13
  int v26; // [sp+2Ch] [bp-58h]@1
  float v27; // [sp+30h] [bp-54h]@15
  int v28; // [sp+34h] [bp-50h]@1
  int v29; // [sp+38h] [bp-4Ch]@1
  float v30; // [sp+3Ch] [bp-48h]@1
  float v31; // [sp+40h] [bp-44h]@1
  int v32; // [sp+44h] [bp-40h]@1
  float v33; // [sp+48h] [bp-3Ch]@1
  float v34; // [sp+4Ch] [bp-38h]@1
  int v35; // [sp+50h] [bp-34h]@1
  int v36; // [sp+54h] [bp-30h]@1
  int v37; // [sp+68h] [bp-1Ch]@1
  char v38; // [sp+6Ch] [bp-18h]@2

  v5 = *(_DWORD *)(a2 + 12);
  v30 = *(float *)(a2 + 40);
  v35 = a4;
  v31 = 0.0;
  v6 = *(float *)(a2 + 40);
  LOBYTE(v36) = a5;
  v7 = *(_DWORD *)(a2 + 8);
  v8 = v6;
  v21 = 31;
  LOWORD(v26) = a3;
  v37 = 0;
  v28 = v5;
  v29 = v7;
  v9 = sub_10038970(v8);
  v33 = *(float *)(a2 + 32);
  v34 = *(float *)(a2 + 36);
  v32 = v9;
  v10 = (const char *)sub_10034240(a3);
  if ( v10 )
  {
    v11 = sub_100415D0(COERCE_INT(*(float *)(a2 + 28)), v26, v36, &v21);
    sprintf(&v38, v10, LODWORD(v11), (_DWORD)(*(unsigned __int64 *)&v11 >> 32));
    v12 = v38;
    if ( v38 )
    {
      v13 = v37;
      v14 = &v38;
      do
      {
        if ( (unsigned __int8)v12 >= 0x30u && (unsigned __int8)v12 <= 0x39u )
          ++v13;
        v12 = (v14++)[1];
      }
      while ( v12 );
      v37 = v13;
    }
  }
  else
  {
    v37 = 0;
  }
  if ( *(float *)(a2 + 28) >= (double)*(float *)(a2 + 24) )
  {
    v24 = *(float *)(a2 + 24);
    v15 = *(float *)(a2 + 28);
  }
  else
  {
    v24 = *(float *)(a2 + 28);
    v15 = *(float *)(a2 + 24);
  }
  v16 = *(float **)(a2 + 20);
  v25 = v15;
  if ( v24 > (double)*v16 || v25 < (double)*v16 )
  {
    v17 = *(_DWORD *)(a2 + 16);
    v27 = 9.8999998e24;
    v29 = 0;
    v28 = v17;
  }
  else
  {
    v27 = *v16;
  }
  v18 = *(float *)(a2 + 4);
  v22 = (signed int)*(float *)a2;
  v19 = *(_BYTE *)(a2 + 46) == 0;
  v23 = (signed int)v18;
  if ( !v19 && 9.8999998e24 == v27 )
    v23 += (signed int)(*(float *)(a2 + 40) * -0.5);
  return sub_10034250(a1, 0, (int)&v22, (int)&v26, (__int16 *)&unk_100AB7D4);
}

//----- (1003AEE0) --------------------------------------------------------
int __cdecl sub_1003AEE0(float a1, float a2, float a3, int a4)
{
  int v4; // ST34_4@1
  int v5; // eax@1
  int v6; // ST08_4@1
  float v7; // ST0C_4@1
  float v8; // ST38_4@1
  float v9; // ST54_4@1
  float v10; // ST40_4@1
  float v11; // ST10_4@1
  float v12; // ST3C_4@1
  float v13; // ST44_4@1
  float v14; // ST1C_4@1
  float v15; // ST20_4@1
  float v16; // ST24_4@1
  float v17; // ST28_4@1
  float v18; // ST2C_4@1
  float v19; // ST30_4@1
  float v20; // ST48_4@1
  float v21; // ST14_4@1
  float v22; // ST50_4@1
  float v23; // ST4C_4@1
  float v24; // ST18_4@1
  float v25; // ST54_4@1
  float v26; // ST54_4@1
  float v27; // ST04_4@1
  float v29; // [sp+58h] [bp+4h]@1
  float v30; // [sp+60h] [bp+Ch]@1
  float v31; // [sp+60h] [bp+Ch]@1
  float v32; // [sp+60h] [bp+Ch]@1
  int v33; // [sp+64h] [bp+10h]@1

  v4 = a4;
  BYTE3(v4) = BYTE3(a4) >> 1;
  v5 = 3 * LOBYTE(a3);
  v6 = a4;
  v29 = flt_100AE8B0[v5] + a1;
  v33 = SLODWORD(flt_100AE8A8[v5]);
  v30 = flt_100AE8AC[v5];
  j_gdi_pvg_color_u32(v6);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_begin(63);
  v7 = v30 * 0.5 + a2;
  v8 = 0.5 * *(float *)&v33 + v29;
  sub_10015960(v8, v7);
  v9 = *(float *)&v33 * 1.5 + v29;
  sub_10015960(v9, v7);
  v10 = *(float *)&v33 * 2.5 + v29;
  sub_10015960(v10, v7);
  v11 = v30 * 1.5 + a2;
  v12 = *(float *)&v33 * 3.5 + v29;
  sub_10015960(v12, v11);
  v13 = *(float *)&v33 * 4.5 + v29;
  sub_10015960(v13, v11);
  v14 = v30 * 2.5 + a2;
  v15 = *(float *)&v33 * 5.5 + v29;
  sub_10015960(v15, v14);
  v16 = v30 * 3.5 + a2;
  v17 = *(float *)&v33 * 6.5 + v29;
  sub_10015960(v17, v16);
  v18 = v30 * 4.5 + a2;
  v19 = *(float *)&v33 * 7.5 + v29;
  sub_10015960(v19, v18);
  v20 = v30 * 5.5 + a2;
  v21 = *(float *)&v33 * 8.5 + v29;
  sub_10015960(v21, v20);
  v22 = v30 * 6.5 + a2;
  sub_10015960(v21, v22);
  v23 = v30 * 7.5 + a2;
  v24 = *(float *)&v33 * 9.5 + v29;
  sub_10015960(v24, v23);
  v25 = v30 * 8.5 + a2;
  sub_10015960(v24, v25);
  v26 = v30 * 9.5 + a2;
  sub_10015960(v24, v26);
  j_gdi_pvg_color_u32(v4);
  v31 = v30 * -0.5 + a2;
  sub_10015960(v8, v31);
  sub_10015960(v12, v7);
  sub_10015960(v10, v11);
  sub_10015960(v15, v11);
  sub_10015960(v13, v14);
  sub_10015960(v17, v14);
  sub_10015960(v15, v16);
  sub_10015960(v19, v16);
  sub_10015960(v17, v18);
  sub_10015960(v21, v18);
  sub_10015960(v19, v20);
  sub_10015960(v21, v23);
  sub_10015960(v24, v22);
  v32 = *(float *)&v33 * 10.5 + v29;
  sub_10015960(v32, v26);
  j_gdi_pvg_end(LODWORD(v27));
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 100AE8A8: using guessed type float flt_100AE8A8[];
// 100AE8AC: using guessed type float flt_100AE8AC[];
// 100AE8B0: using guessed type float flt_100AE8B0[];

//----- (1003B300) --------------------------------------------------------
int __cdecl sub_1003B300(float a1, float a2, float a3, float a4, int a5)
{
  float v5; // ST14_4@1
  double v6; // ST28_8@1
  float v7; // ST18_4@1
  double v8; // ST20_8@1
  float v9; // ST1C_4@1
  int v11; // [sp+10h] [bp-20h]@0
  float v12; // [sp+38h] [bp+8h]@1
  float v13; // [sp+3Ch] [bp+Ch]@1
  float v14; // [sp+40h] [bp+10h]@1
  float v15; // [sp+40h] [bp+10h]@1
  float v16; // [sp+40h] [bp+10h]@1

  j_gdi_pvg_color_u32(a5);
  sub_10015770(1.0);
  j_gdi_pvg_begin(64);
  v5 = a2 + 10.0;
  sub_10015960(a1, v5);
  v6 = a2 + a4;
  v14 = v6 - 10.0;
  sub_10015960(a1, v14);
  v7 = a1 + 10.0;
  sub_10015960(v7, a2);
  v8 = a1 + a3;
  v9 = v8 - 10.0;
  sub_10015960(v9, a2);
  v13 = v8 + 0.5;
  sub_10015960(v13, v5);
  sub_10015960(v13, v14);
  v15 = v6 + 0.5;
  sub_10015960(v7, v15);
  sub_10015960(v9, v15);
  j_gdi_pvg_end(v11);
  sub_1003AEE0(a1, a2, 0.0, a5);
  v16 = v8;
  sub_1003AEE0(v16, a2, COERCE_FLOAT(1), a5);
  v12 = v6;
  sub_1003AEE0(v16, v12, COERCE_FLOAT(2), a5);
  return sub_1003AEE0(a1, v12, COERCE_FLOAT(3), a5);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003B4C0) --------------------------------------------------------
int __cdecl sub_1003B4C0(int a1)
{
  int v1; // esi@1
  double v2; // st7@2
  float v3; // ST08_4@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@0
  float v8; // [sp+10h] [bp+4h]@2
  float v9; // [sp+10h] [bp+4h]@2
  float v10; // [sp+10h] [bp+4h]@3

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_color_u32(-1);
  sub_10015770(1.0);
  j_gdi_pvg_begin(64);
  v1 = a1;
  v5 = *(float *)(a1 + 4);
  if ( *(_BYTE *)(a1 + 16) == 1 )
  {
    sub_10015960(*(float *)a1, v5);
    v10 = *(float *)(a1 + 4) - *(float *)(a1 + 12);
    v6 = v10;
    v2 = *(float *)v1;
  }
  else
  {
    v8 = *(float *)a1 - 1.0;
    sub_10015960(v8, v5);
    v6 = *(float *)(v1 + 4);
    v9 = *(float *)(v1 + 8) + *(float *)v1;
    v2 = v9;
  }
  v3 = v2;
  sub_10015960(v3, v6);
  j_gdi_pvg_end(v7);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003B570) --------------------------------------------------------
int __cdecl sub_1003B570(int a1, int a2, unsigned __int16 a3, int a4, char a5)
{
  int v5; // esi@1
  float v6; // ST10_4@1
  float v7; // ST10_4@1
  float v8; // ST0C_4@1
  float v10; // [sp+10h] [bp+4h]@1
  float v11; // [sp+10h] [bp+4h]@1
  float v12; // [sp+10h] [bp+4h]@1
  float v13; // [sp+10h] [bp+4h]@1
  float v14; // [sp+10h] [bp+4h]@1
  float v15; // [sp+10h] [bp+4h]@1

  v5 = a1;
  sub_1003AD10(a1, a2, a3, a4, a5);
  sub_10015770(1.5);
  j_gdi_pvg_begin(66);
  j_gdi_pvg_color_u32(-16711681);
  v10 = *(float *)(a1 + 296) - 1.0;
  v6 = v10;
  v11 = *(float *)(v5 + 292) - 1.0;
  sub_10015960(v11, v6);
  v12 = *(float *)(v5 + 296) - 1.0;
  sub_10015960(*(float *)(v5 + 300), v12);
  v13 = *(float *)(v5 + 304) + 1.0;
  sub_10015960(*(float *)(v5 + 300), v13);
  v14 = *(float *)(v5 + 304) + 1.0;
  v7 = v14;
  v15 = *(float *)(v5 + 292) - 1.0;
  sub_10015960(v15, v7);
  j_gdi_pvg_end(LODWORD(v8));
  return sub_10015770(1.0);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003B680) --------------------------------------------------------
int __cdecl sub_1003B680(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  int v7; // esi@1
  unsigned int v8; // eax@1
  int v9; // edi@5
  double v10; // ST2C_8@5
  double v11; // ST1C_8@5
  float v12; // ST18_4@5
  double v13; // ST24_8@5
  float v14; // ST14_4@5
  float v15; // ST14_4@5
  float v16; // ST14_4@5
  float v17; // ST04_4@5
  double v18; // st7@5
  int v19; // edi@7
  double v20; // ST1C_8@7
  float v21; // ST18_4@7
  double v22; // ST24_8@7
  float v23; // ST14_4@7
  double v24; // ST2C_8@7
  float v25; // ST14_4@7
  float v26; // ST04_4@7
  float v27; // ST04_4@8
  float v28; // ST04_4@8
  float v30; // [sp+4h] [bp-2Ch]@5
  float v31; // [sp+14h] [bp-1Ch]@1
  float v32; // [sp+44h] [bp+14h]@5
  float v33; // [sp+44h] [bp+14h]@7
  int v34; // [sp+48h] [bp+18h]@5
  int v35; // [sp+48h] [bp+18h]@7

  v7 = a6;
  v31 = 1.0;
  v8 = (unsigned int)a6 >> 16;
  BYTE1(a6) >>= 1;
  LOBYTE(a6) = (unsigned __int8)a6 >> 1;
  BYTE2(a6) = (unsigned __int8)v8 >> 1;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( !LOBYTE(a5) )
  {
    v31 = -1.0;
    goto LABEL_7;
  }
  if ( LOBYTE(a5) != 2 )
  {
    if ( LOBYTE(a5) == 3 )
    {
      v31 = -1.0;
      goto LABEL_5;
    }
LABEL_7:
    j_gdi_pvg_begin(73);
    v19 = a6;
    j_gdi_pvg_color_u32(a6);
    v20 = v31 * a4;
    v21 = a2 - v20 * 0.4000000059604645;
    v22 = a3 * 0.5;
    *(float *)&v35 = a1 - v22;
    sub_10015960(*(float *)&v35, v21);
    v33 = a2 - v20;
    sub_10015960(*(float *)&v35, v33);
    j_gdi_pvg_color_u32(v7);
    v23 = a2 - v20 * 0.2000000029802322;
    v24 = a3 * 0.25;
    *(float *)&v20 = a1 - v24;
    sub_10015960(*(float *)&v20, v23);
    sub_10015960(*(float *)&v20, v33);
    sub_10015960(a1, a2);
    sub_10015960(a1, v33);
    *(float *)&v20 = a1 + v24;
    sub_10015960(*(float *)&v20, v23);
    sub_10015960(*(float *)&v20, v33);
    j_gdi_pvg_color_u32(v19);
    v25 = a1 + v22;
    sub_10015960(v25, v21);
    sub_10015960(v25, v33);
    j_gdi_pvg_end(LODWORD(v26));
    j_gdi_pvg_enable(38);
    sub_10015770(1.0);
    j_gdi_pvg_color_u32(a7);
    j_gdi_pvg_begin(66);
    sub_10015960(a1, a2);
    sub_10015960(*(float *)&v35, v21);
    sub_10015960(*(float *)&v35, v33);
    sub_10015960(v25, v33);
    v30 = v21;
    v18 = v25;
    goto LABEL_8;
  }
LABEL_5:
  j_gdi_pvg_begin(73);
  v9 = a6;
  j_gdi_pvg_color_u32(a6);
  v10 = a4 * 0.5;
  *(float *)&v34 = v10 + a2;
  v11 = v31 * a3;
  v12 = v11 * 0.4000000059604645 + a1;
  sub_10015960(v12, *(float *)&v34);
  v32 = a1 + v11;
  sub_10015960(v32, *(float *)&v34);
  j_gdi_pvg_color_u32(v7);
  v13 = a4 * 0.25;
  v14 = v13 + a2;
  *(float *)&v11 = v11 * 0.2000000029802322 + a1;
  sub_10015960(*(float *)&v11, v14);
  sub_10015960(v32, v14);
  sub_10015960(a1, a2);
  sub_10015960(v32, a2);
  v15 = a2 - v13;
  sub_10015960(*(float *)&v11, v15);
  sub_10015960(v32, v15);
  j_gdi_pvg_color_u32(v9);
  v16 = a2 - v10;
  sub_10015960(v12, v16);
  sub_10015960(v32, v16);
  j_gdi_pvg_end(LODWORD(v17));
  j_gdi_pvg_enable(38);
  sub_10015770(1.0);
  j_gdi_pvg_color_u32(a7);
  j_gdi_pvg_begin(66);
  sub_10015960(a1, a2);
  sub_10015960(v12, *(float *)&v34);
  sub_10015960(v32, *(float *)&v34);
  sub_10015960(v32, v16);
  v30 = v16;
  v18 = v12;
LABEL_8:
  v27 = v18;
  sub_10015960(v27, v30);
  j_gdi_pvg_end(LODWORD(v28));
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003BB00) --------------------------------------------------------
int __cdecl sub_1003BB00(int a1)
{
  int v1; // esi@1
  unsigned int v2; // eax@1
  double v3; // st7@2
  int v4; // edi@4
  float v5; // ST18_4@4
  float v6; // ST18_4@4
  float v7; // ST18_4@4
  float v8; // ST0C_4@4
  float v9; // ST18_4@4
  float v10; // ST18_4@4
  float v11; // ST18_4@4
  float v12; // ST0C_4@4
  float v13; // ST18_4@4
  float v14; // ST08_4@4
  float v15; // ST18_4@4
  float v16; // ST18_4@4
  float v17; // ST18_4@4
  float v18; // ST0C_4@4
  float v19; // ST18_4@4
  float v20; // ST18_4@4
  float v21; // ST0C_4@4
  float v22; // ST18_4@4
  float v23; // ST18_4@4
  float v24; // ST0C_4@4
  float v25; // ST18_4@4
  float v26; // ST18_4@4
  float v27; // ST0C_4@4
  float v28; // ST18_4@4
  float v29; // ST08_4@4
  float v30; // ST18_4@4
  float v31; // ST0C_4@4
  float v32; // ST18_4@4
  float v33; // ST0C_4@4
  float v34; // ST0C_4@4
  int v36; // [sp+10h] [bp-4h]@1
  float v37; // [sp+18h] [bp+4h]@4
  float v38; // [sp+18h] [bp+4h]@4
  float v39; // [sp+18h] [bp+4h]@4

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v1 = a1;
  v2 = *(_DWORD *)(a1 + 16);
  v36 = *(_DWORD *)(a1 + 16);
  BYTE1(v36) >>= 1;
  LOBYTE(v36) = (unsigned __int8)v2 >> 1;
  BYTE2(v36) = (unsigned __int8)(v2 >> 16) >> 1;
  if ( COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a1 + 8)) & 0x7FFFFFFF) > (double)*(float *)(a1 + 12) )
    v3 = 0.0;
  else
    v3 = COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)(a1 + 8)) & 0x7FFFFFFF) - *(float *)(a1 + 12);
  v37 = v3;
  j_gdi_pvg_begin(73);
  v4 = v36;
  j_gdi_pvg_color_u32(v36);
  sub_10015960(*(float *)v1, *(float *)(v1 + 4));
  v5 = *(float *)(v1 + 4) + v37;
  sub_10015960(*(float *)v1, v5);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v6 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_10015960(v6, *(float *)(v1 + 4));
  v7 = *(float *)(v1 + 4) + v37;
  v8 = v7;
  v9 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_10015960(v9, v8);
  j_gdi_pvg_color_u32(v4);
  v10 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v10, *(float *)(v1 + 4));
  v11 = *(float *)(v1 + 4) + v37;
  v12 = v11;
  v13 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v13, v12);
  j_gdi_pvg_end(LODWORD(v14));
  j_gdi_pvg_begin(73);
  v15 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  sub_10015960(*(float *)v1, v15);
  v16 = *(float *)(v1 + 4) + v37;
  sub_10015960(*(float *)v1, v16);
  j_gdi_pvg_color_u32(*(_DWORD *)(v1 + 16));
  v17 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v18 = v17;
  v19 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_10015960(v19, v18);
  v20 = *(float *)(v1 + 4) + v37;
  v21 = v20;
  v22 = *(float *)(v1 + 8) * 0.5 + *(float *)v1;
  sub_10015960(v22, v21);
  j_gdi_pvg_color_u32(v4);
  v23 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v24 = v23;
  v25 = *(float *)(v1 + 8) + *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v25, v24);
  v26 = *(float *)(v1 + 4) + v37;
  v27 = v26;
  v28 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v28, v27);
  j_gdi_pvg_end(LODWORD(v29));
  j_gdi_pvg_enable(38);
  j_gdi_pvg_begin(64);
  sub_10015770(2.0);
  v30 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v31 = v30;
  v32 = *(float *)(v1 + 8) + *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v32, v31);
  v38 = *(float *)(v1 + 4) + v37;
  v33 = v38;
  v39 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v39, v33);
  sub_10015770(1.0);
  j_gdi_pvg_end(LODWORD(v34));
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003BE00) --------------------------------------------------------
int __cdecl sub_1003BE00(int a1)
{
  int v1; // esi@1
  float v2; // ST10_4@1
  int v4; // [sp+8h] [bp-4h]@0
  float v5; // [sp+10h] [bp+4h]@1
  float v6; // [sp+10h] [bp+4h]@1
  float v7; // [sp+10h] [bp+4h]@1
  float v8; // [sp+10h] [bp+4h]@1

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  j_gdi_pvg_begin(73);
  v1 = a1;
  j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 16));
  sub_10015960(*(float *)v1, *(float *)(v1 + 4));
  v5 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  sub_10015960(*(float *)v1, v5);
  v6 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v6, *(float *)(v1 + 4));
  v7 = *(float *)(v1 + 4) - *(float *)(v1 + 12);
  v2 = v7;
  v8 = *(float *)(v1 + 8) + *(float *)v1;
  sub_10015960(v8, v2);
  j_gdi_pvg_end(v4);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003BEB0) --------------------------------------------------------
int __usercall sub_1003BEB0@<eax>(int edi0@<edi>, int a1, int a2, unsigned __int8 a3, char a4)
{
  int v5; // ebp@3
  int v6; // edi@3
  int v7; // esi@3
  int v8; // ebp@4
  int result; // eax@13
  int v10; // esi@16
  int v11; // ebp@16
  int v12; // eax@18
  int v13; // ecx@18
  int v14; // edx@18
  int v15; // [sp+8h] [bp-38h]@3
  float v16; // [sp+18h] [bp-28h]@3
  float v17; // [sp+1Ch] [bp-24h]@18
  float v18; // [sp+20h] [bp-20h]@18
  int v19; // [sp+24h] [bp-1Ch]@18
  float v20; // [sp+28h] [bp-18h]@18
  int v21; // [sp+2Ch] [bp-14h]@18
  int v22; // [sp+30h] [bp-10h]@18
  float v23; // [sp+34h] [bp-Ch]@18
  float v24; // [sp+38h] [bp-8h]@18
  float v25; // [sp+3Ch] [bp-4h]@20

  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( a4 )
    j_gdi_pvg_enable(38);
  v5 = a2;
  v16 = *(float *)(a2 + 16);
  v15 = edi0;
  v6 = *(_DWORD *)(a2 + 56);
  v7 = a2 + 56;
  sub_10015770(v16);
  j_gdi_pvg_begin(64);
  j_gdi_pvg_color_u32(v6);
  if ( a3 )
  {
    v8 = a3;
    do
    {
      if ( *(_BYTE *)(v7 + 4) != 1 )
      {
        if ( *(_DWORD *)v7 != v6 )
        {
          v6 = *(_DWORD *)v7;
          j_gdi_pvg_color_u32(*(_DWORD *)v7);
        }
        if ( v16 != *(float *)(v7 - 40) )
        {
          j_gdi_pvg_end(v15);
          v16 = *(float *)(v7 - 40);
          sub_10015770(v16);
          j_gdi_pvg_begin(64);
        }
        sub_10015960(*(float *)(v7 - 56), *(float *)(v7 - 48));
        sub_10015960(*(float *)(v7 - 52), *(float *)(v7 - 44));
      }
      v7 += 64;
      --v8;
    }
    while ( v8 );
    v5 = a2;
  }
  j_gdi_pvg_end(v15);
  sub_10015770(1.0);
  result = j_gdi_pvg_disable(35);
  if ( a4 )
    result = j_gdi_pvg_disable(38);
  if ( a3 )
  {
    v10 = v5 + 48;
    v11 = a3;
    do
    {
      if ( *(_BYTE *)(v10 - 12) )
      {
        v23 = *(float *)(v10 - 4);
        v24 = *(float *)v10;
        v17 = *(float *)(v10 - 28);
        v18 = *(float *)(v10 - 24);
        v12 = sub_10038970(*(float *)(v10 + 4));
        v13 = *(_DWORD *)(v10 - 20);
        v14 = *(_DWORD *)(v10 - 16);
        v20 = *(float *)(v10 + 4);
        v19 = v12;
        v21 = v13;
        v22 = v14;
        if ( v13 )
        {
          v25 = sub_10016930(v12, v10 - 12, v20);
          result = sub_100393A0(a1, v10 - 12, (int)&v17);
        }
        else
        {
          result = sub_10038F80(v10 - 12, (int)&v17);
        }
      }
      v10 += 64;
      --v11;
    }
    while ( v11 );
  }
  return result;
}
// 1003BEB0: could not find valid save-restore pair for edi
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003C070) --------------------------------------------------------
int __cdecl sub_1003C070(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  int v7; // esi@1
  double v8; // ST1C_8@5
  float v9; // ST18_4@5
  float v10; // ST04_4@5
  double v11; // st7@5
  double v12; // ST1C_8@7
  float v13; // ST18_4@7
  float v14; // ST04_4@7
  float v15; // ST04_4@8
  float v16; // ST04_4@8
  float v18; // [sp+4h] [bp-1Ch]@5
  int v19; // [sp+10h] [bp-10h]@1
  float v20; // [sp+14h] [bp-Ch]@1
  float v21; // [sp+34h] [bp+14h]@5
  float v22; // [sp+34h] [bp+14h]@7
  int v23; // [sp+38h] [bp+18h]@5
  int v24; // [sp+38h] [bp+18h]@7

  v7 = a6;
  v20 = 1.0;
  v19 = a6;
  BYTE2(v19) = (signed int)((double)(unsigned __int8)((unsigned int)a6 >> 16) * 0.8999999761581421);
  BYTE1(v19) = (signed int)((double)BYTE1(v19) * 0.8999999761581421);
  LOBYTE(v19) = (signed int)(0.8999999761581421 * (double)(unsigned __int8)a6);
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( !LOBYTE(a5) )
  {
    v20 = -1.0;
    goto LABEL_7;
  }
  if ( LOBYTE(a5) != 2 )
  {
    if ( LOBYTE(a5) == 3 )
    {
      v20 = -1.0;
      goto LABEL_5;
    }
LABEL_7:
    j_gdi_pvg_begin(71);
    j_gdi_pvg_color_u32(a6);
    sub_10015960(a1, a2);
    j_gdi_pvg_color_u32(v19);
    v22 = a2 - v20 * a4;
    v12 = a3 * 0.5;
    *(float *)&v24 = v12 + a1;
    sub_10015960(*(float *)&v24, v22);
    j_gdi_pvg_color_u32(v7);
    sub_10015960(a1, v22);
    j_gdi_pvg_color_u32(v19);
    v13 = a1 - v12;
    sub_10015960(v13, v22);
    j_gdi_pvg_end(LODWORD(v14));
    j_gdi_pvg_enable(38);
    sub_10015770(1.0);
    j_gdi_pvg_color_u32(a7);
    j_gdi_pvg_begin(66);
    sub_10015960(a1, a2);
    sub_10015960(*(float *)&v24, v22);
    v18 = v22;
    v11 = v13;
    goto LABEL_8;
  }
LABEL_5:
  j_gdi_pvg_begin(71);
  j_gdi_pvg_color_u32(a6);
  sub_10015960(a1, a2);
  j_gdi_pvg_color_u32(v19);
  v8 = a4 * 0.5;
  *(float *)&v23 = a2 - v8;
  v21 = v20 * a3 + a1;
  sub_10015960(v21, *(float *)&v23);
  j_gdi_pvg_color_u32(v7);
  sub_10015960(v21, a2);
  j_gdi_pvg_color_u32(v19);
  v9 = a2 + v8;
  sub_10015960(v21, v9);
  j_gdi_pvg_end(LODWORD(v10));
  j_gdi_pvg_enable(38);
  sub_10015770(1.0);
  j_gdi_pvg_color_u32(a7);
  j_gdi_pvg_begin(66);
  sub_10015960(a1, a2);
  sub_10015960(v21, *(float *)&v23);
  v18 = v9;
  v11 = v21;
LABEL_8:
  v15 = v11;
  sub_10015960(v15, v18);
  j_gdi_pvg_end(LODWORD(v16));
  j_gdi_pvg_disable(38);
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003C3C0) --------------------------------------------------------
void __cdecl sub_1003C3C0(int a1)
{
  int v1; // ebp@1
  double v2; // st7@1
  signed int v3; // edx@1
  int v4; // ecx@1
  double v5; // st5@1
  int v6; // ebx@1
  double v7; // st7@1
  double v8; // st6@1
  double v9; // st5@1
  double v10; // st4@4
  double v11; // st6@7
  int v12; // edi@7
  int v13; // esi@7
  int v14; // esi@9
  int v15; // edi@9
  float v16; // ST10_4@9
  float v17; // ST20_4@9
  float v18; // ST20_4@9
  int v19; // ebx@9
  int v20; // esi@9
  int v21; // edi@9
  double v22; // st7@9
  double v23; // st7@11
  float v24; // ST10_4@14
  float v25; // ST20_4@14
  int v26; // esi@14
  int v27; // edi@14
  float v28; // ST20_4@14
  float v29; // [sp+Ch] [bp-20h]@1
  float v30; // [sp+14h] [bp-18h]@6
  float v31; // [sp+1Ch] [bp-10h]@1
  float v32; // [sp+20h] [bp-Ch]@1
  int v33; // [sp+24h] [bp-8h]@1
  signed int v34; // [sp+28h] [bp-4h]@1
  float v35; // [sp+30h] [bp+4h]@4

  v1 = a1;
  v2 = *(float *)(a1 + 8);
  v3 = 0;
  v4 = a1 + 24;
  v5 = *(float *)a1;
  v6 = 0;
  *(_DWORD *)(a1 + 1348) = 0;
  v34 = 0;
  v33 = a1 + 24;
  v31 = v2 * 0.5 + v5;
  v32 = 0.5 * *(float *)(v1 + 12) + *(float *)(v1 + 4);
  v29 = *(float *)(a1 + 8);
  v7 = v32;
  v8 = 0.0;
  v9 = 0.5;
  do
  {
    if ( 9.8999998e24 == *(float *)v4 )
      break;
    if ( v3 <= 0 )
    {
      v35 = *(float *)v4;
      v10 = *(float *)(v1 + 16);
    }
    else
    {
      v35 = *(float *)v4 - *(float *)(v4 - 8);
      v10 = *(float *)(v1 + 16) + *(float *)(v4 - 8);
    }
    v30 = v10;
    if ( v35 != v8 )
    {
      v11 = v35;
      v12 = v1 + 4 * v6 + 732;
      v13 = v1 + 4 * v6 + 204;
      while ( 1 )
      {
        v14 = v13 + 4;
        *(float *)(v14 - 4) = v31;
        v15 = v12 + 4;
        *(float *)(v15 - 4) = v9;
        v14 += 4;
        *(float *)(v14 - 4) = v7;
        v15 += 4;
        *(float *)(v15 - 4) = v9;
        *(_DWORD *)(v1 + 4 * *(_DWORD *)(v1 + 1348) + 1260) = *(_DWORD *)(v4 + 4);
        v16 = (v11 + v30) * 0.01745329251994333;
        v17 = cos(v16);
        v14 += 4;
        v15 += 4;
        *(float *)(v14 - 4) = v17 * v29 + v31;
        *(float *)(v15 - 4) = v17 + 0.5;
        v18 = sin(v16);
        v19 = v6 + 4;
        v20 = v14 + 4;
        v21 = v15 + 4;
        *(float *)(v20 - 4) = v18 * v29 + v32;
        *(float *)(v21 - 4) = v18 + 0.5;
        v22 = v35;
        if ( COERCE_FLOAT(LODWORD(v35) & 0x7FFFFFFF) <= 30.0 )
          v23 = 0.0;
        else
          v23 = v22 <= 0.0 ? v22 + 30.0 : v22 - 30.0;
        v35 = v23;
        v24 = (v30 + v35) * 0.01745329251994333;
        v25 = cos(v24);
        v26 = v20 + 4;
        v27 = v21 + 4;
        *(float *)(v26 - 4) = v25 * v29 + v31;
        *(float *)(v27 - 4) = v25 + 0.5;
        v28 = sin(v24);
        v4 = v33;
        v6 = v19 + 2;
        v13 = v26 + 4;
        v12 = v27 + 4;
        *(float *)(v13 - 4) = v28 * v29 + v32;
        v7 = v32;
        *(float *)(v12 - 4) = v28 + 0.5;
        ++*(_DWORD *)(v1 + 1348);
        v8 = 0.0;
        if ( v35 == 0.0 )
          break;
        v11 = v35;
        v9 = 0.5;
      }
      v3 = v34;
      v9 = 0.5;
    }
    ++v3;
    v4 += 8;
    v34 = v3;
    v33 = v4;
  }
  while ( v3 < 10 );
}

//----- (1003C630) --------------------------------------------------------
void __cdecl sub_1003C630(int a1)
{
  sub_10039220(
    *(float *)a1,
    *(float *)(a1 + 4),
    25.0,
    *(float *)(a1 + 40),
    *(float *)(a1 + 32),
    *(float *)(a1 + 36),
    *(_BYTE *)(a1 + 45));
}

//----- (1003C670) --------------------------------------------------------
int __usercall sub_1003C670@<eax>(char a1@<al>, int a2@<ecx>, char a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // esi@3
  unsigned int v6; // eax@4
  unsigned int v7; // edi@4
  float v8; // ST08_4@4
  float v9; // ST08_4@4
  float v10; // ST08_4@4
  int v12; // esi@7
  unsigned int v13; // eax@8
  unsigned int v14; // edi@8
  float v15; // ST08_4@8
  float v16; // ST08_4@8
  float v17; // ST08_4@8
  int v18; // [sp+8h] [bp-Ch]@0
  unsigned int v19; // [sp+18h] [bp+4h]@4
  float v20; // [sp+18h] [bp+4h]@4
  float v21; // [sp+18h] [bp+4h]@4
  float v22; // [sp+18h] [bp+4h]@4
  float v23; // [sp+18h] [bp+4h]@4
  float v24; // [sp+18h] [bp+4h]@4
  float v25; // [sp+18h] [bp+4h]@4
  float v26; // [sp+18h] [bp+4h]@4
  float v27; // [sp+18h] [bp+4h]@4
  float v28; // [sp+18h] [bp+4h]@4
  float v29; // [sp+18h] [bp+4h]@4
  unsigned int v30; // [sp+18h] [bp+4h]@8
  float v31; // [sp+18h] [bp+4h]@8
  float v32; // [sp+18h] [bp+4h]@8
  float v33; // [sp+18h] [bp+4h]@8
  float v34; // [sp+18h] [bp+4h]@8
  float v35; // [sp+18h] [bp+4h]@8
  float v36; // [sp+18h] [bp+4h]@8
  float v37; // [sp+18h] [bp+4h]@8
  float v38; // [sp+18h] [bp+4h]@8
  float v39; // [sp+18h] [bp+4h]@8
  float v40; // [sp+18h] [bp+4h]@8

  LOBYTE(v3) = a1;
  v4 = a2;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  if ( !a3 )
  {
    if ( (_BYTE)v3 )
    {
      v12 = v4 + 4;
      v3 = (unsigned __int8)v3;
      do
      {
        v30 = *(_DWORD *)(v12 + 12);
        v13 = v30;
        BYTE1(v30) >>= 1;
        LOBYTE(v30) = (unsigned __int8)v30 >> 1;
        BYTE2(v30) = (unsigned __int8)(v13 >> 16) >> 1;
        j_gdi_pvg_begin(73);
        v14 = v30;
        j_gdi_pvg_color_u32(v30);
        sub_10015960(*(float *)(v12 - 4), *(float *)v12);
        v31 = *(float *)(v12 - 4) + *(float *)(v12 + 4);
        sub_10015960(v31, *(float *)v12);
        j_gdi_pvg_color_u32(*(_DWORD *)(v12 + 12));
        v32 = *(float *)(v12 + 8) * 0.25 + *(float *)v12;
        sub_10015960(*(float *)(v12 - 4), v32);
        v33 = *(float *)(v12 + 8) * 0.25 + *(float *)v12;
        v15 = v33;
        v34 = *(float *)(v12 - 4) + *(float *)(v12 + 4);
        sub_10015960(v34, v15);
        v35 = *(float *)(v12 + 8) * 0.75 + *(float *)v12;
        sub_10015960(*(float *)(v12 - 4), v35);
        v36 = *(float *)(v12 + 8) * 0.75 + *(float *)v12;
        v16 = v36;
        v37 = *(float *)(v12 - 4) + *(float *)(v12 + 4);
        sub_10015960(v37, v16);
        j_gdi_pvg_color_u32(v14);
        v38 = *(float *)(v12 + 8) + *(float *)v12;
        sub_10015960(*(float *)(v12 - 4), v38);
        v39 = *(float *)(v12 + 8) + *(float *)v12;
        v17 = v39;
        v40 = *(float *)(v12 - 4) + *(float *)(v12 + 4);
        sub_10015960(v40, v17);
        j_gdi_pvg_end(v18);
        v12 += 20;
        --v3;
      }
      while ( v3 );
    }
    return j_gdi_pvg_disable(35);
  }
  if ( !(_BYTE)v3 )
    return j_gdi_pvg_disable(35);
  v5 = v4 + 4;
  v3 = (unsigned __int8)v3;
  do
  {
    v19 = *(_DWORD *)(v5 + 12);
    v6 = v19;
    BYTE1(v19) >>= 1;
    LOBYTE(v19) = (unsigned __int8)v19 >> 1;
    BYTE2(v19) = (unsigned __int8)(v6 >> 16) >> 1;
    j_gdi_pvg_begin(73);
    v7 = v19;
    j_gdi_pvg_color_u32(v19);
    sub_10015960(*(float *)(v5 - 4), *(float *)v5);
    v20 = *(float *)(v5 + 8) + *(float *)v5;
    sub_10015960(*(float *)(v5 - 4), v20);
    j_gdi_pvg_color_u32(*(_DWORD *)(v5 + 12));
    v21 = *(float *)(v5 + 4) * 0.25 + *(float *)(v5 - 4);
    sub_10015960(v21, *(float *)v5);
    v22 = *(float *)(v5 + 8) + *(float *)v5;
    v8 = v22;
    v23 = *(float *)(v5 + 4) * 0.25 + *(float *)(v5 - 4);
    sub_10015960(v23, v8);
    v24 = *(float *)(v5 + 4) * 0.75 + *(float *)(v5 - 4);
    sub_10015960(v24, *(float *)v5);
    v25 = *(float *)(v5 + 8) + *(float *)v5;
    v9 = v25;
    v26 = *(float *)(v5 + 4) * 0.75 + *(float *)(v5 - 4);
    sub_10015960(v26, v9);
    j_gdi_pvg_color_u32(v7);
    v27 = *(float *)(v5 + 4) + *(float *)(v5 - 4);
    sub_10015960(v27, *(float *)v5);
    v28 = *(float *)(v5 + 8) + *(float *)v5;
    v10 = v28;
    v29 = *(float *)(v5 + 4) + *(float *)(v5 - 4);
    sub_10015960(v29, v10);
    j_gdi_pvg_end(v18);
    v5 += 20;
    --v3;
  }
  while ( v3 );
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003C9A0) --------------------------------------------------------
void __usercall sub_1003C9A0(int a1@<ebx>, int a2@<esi>, char a3)
{
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edx@2
  float v6; // [sp+8h] [bp-24h]@2
  float v7; // [sp+Ch] [bp-20h]@2
  int v8; // [sp+10h] [bp-1Ch]@2
  float v9; // [sp+14h] [bp-18h]@2
  int v10; // [sp+18h] [bp-14h]@2
  int v11; // [sp+1Ch] [bp-10h]@2
  float v12; // [sp+20h] [bp-Ch]@2
  float v13; // [sp+24h] [bp-8h]@2
  float v14; // [sp+28h] [bp-4h]@2

  if ( *(_BYTE *)(a2 + 16) )
  {
    v12 = *(float *)(a2 + 40);
    v13 = *(float *)(a2 + 44);
    v6 = *(float *)a2;
    v7 = *(float *)(a2 + 4);
    v3 = sub_10038970(*(float *)(a2 + 48));
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    v9 = *(float *)(a2 + 48);
    v8 = v3;
    v10 = v4;
    v11 = v5;
    v14 = sub_10016930(v3, a2 + 16, v9);
    if ( a3 )
      sub_100393A0(a1, a2 + 16, (int)&v6);
    else
      sub_10039380(a1, a2 + 16, (int)&v6);
  }
}

//----- (1003CA40) --------------------------------------------------------
int __usercall sub_1003CA40@<eax>(int a1@<esi>, float a2, float a3, float a4, float a5, char a6)
{
  double v6; // st7@2
  float v7; // ST10_4@4
  float v9; // [sp+10h] [bp-28h]@2
  float v10; // [sp+14h] [bp-24h]@2
  float v11; // [sp+18h] [bp-20h]@1
  int v12; // [sp+1Ch] [bp-1Ch]@1
  float v13; // [sp+20h] [bp-18h]@1
  int v14; // [sp+24h] [bp-14h]@1
  int v15; // [sp+28h] [bp-10h]@1
  float v16; // [sp+2Ch] [bp-Ch]@2
  float v17; // [sp+30h] [bp-8h]@1
  float v18; // [sp+34h] [bp-4h]@1
  float v19; // [sp+4Ch] [bp+14h]@2
  float v20; // [sp+4Ch] [bp+14h]@2
  float v21; // [sp+4Ch] [bp+14h]@3
  float v22; // [sp+4Ch] [bp+14h]@3

  v17 = 0.5;
  v11 = a3;
  v13 = 12.0;
  v12 = sub_10038970(12.0);
  v14 = 0;
  v15 = -1;
  v18 = sub_10016930(v12, a1, 12.0);
  sub_1003B300(a2, a3, a4, a5, -1);
  j_gdi_pvg_color_u32(-16777216);
  if ( a6 )
  {
    v10 = a4 * 0.5 + a2;
    v16 = 0.5;
    j_gdi_pvg_begin(64);
    v19 = v10 - v18 * 0.5 - 3.0;
    sub_10015960(v19, a3);
    v9 = a3;
    v20 = v18 * 0.5 + v10 + 3.0;
    v6 = v20;
  }
  else
  {
    v10 = a2 + 10.0 + 10.0;
    v16 = 0.0;
    j_gdi_pvg_begin(64);
    v21 = v10 - 3.0;
    sub_10015960(v21, a3);
    v9 = a3;
    v22 = v10 + v18 + 3.0;
    v6 = v22;
  }
  v7 = v6;
  sub_10015960(v7, v9);
  j_gdi_pvg_end(LODWORD(v10));
  return sub_10038F80(a1, (int)&v10);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003CBC0) --------------------------------------------------------
void __usercall sub_1003CBC0(int *a1@<ebx>, int a2@<edi>, float a3, float a4, float a5, float a6, float a7, float a8)
{
  double v8; // st7@1
  double v9; // st6@1
  double v10; // st7@2
  int v11; // esi@4
  long double v12; // st7@5
  float v13; // ST04_4@7
  float v14; // ST04_4@7
  int v15; // esi@8
  float v16; // [sp+10h] [bp+4h]@8
  float v17; // [sp+1Ch] [bp+10h]@2
  float v18; // [sp+1Ch] [bp+10h]@8
  float v19; // [sp+20h] [bp+14h]@4

  v8 = a6;
  v9 = a7;
  if ( a7 <= (double)a6 )
  {
    v17 = v9 * 0.01745329251994333;
    v10 = v8 * 0.01745329251994333;
  }
  else
  {
    v17 = v8 * 0.01745329251994333;
    v10 = 0.01745329251994333 * v9;
  }
  v19 = v10;
  v11 = 0;
  if ( v19 > (double)v17 )
  {
    v12 = v17;
    do
    {
      if ( v11 >= *a1 - 1 )
        break;
      v13 = cos(v12);
      *(float *)(a2 + 8 * v11) = v13 * a5 + a3;
      v14 = sin(v17);
      *(float *)(a2 + 8 * ++v11 - 4) = v14 * a5 + a4;
      v17 = v17 + a8;
      v12 = v17;
    }
    while ( v17 < (double)v19 );
  }
  v18 = cos(v19);
  *(float *)(a2 + 8 * v11) = v18 * a5 + a3;
  v16 = sin(v19);
  v15 = v11 + 1;
  *(float *)(a2 + 8 * v15 - 4) = v16 * a5 + a4;
  *a1 = v15;
}

//----- (1003CCC0) --------------------------------------------------------
int __cdecl sub_1003CCC0(int a1, char a2)
{
  return sub_1003C670(a2, a1, 0);
}

//----- (1003CCE0) --------------------------------------------------------
int __usercall sub_1003CCE0@<eax>(int edi0@<edi>, int a1)
{
  float v2; // ST34_4@1
  float v3; // ST38_4@1
  float v4; // ST2C_4@1
  float v5; // ST2C_4@1
  float v6; // ST34_4@1
  float v7; // ST2C_4@1
  float v8; // ST6C_4@1
  float v9; // ST34_4@1
  float v10; // ST30_4@1
  float v11; // ST38_4@1
  double v12; // ST54_8@1
  float v13; // ST38_4@1
  double v14; // st7@1
  float v15; // ST30_4@1
  float v16; // ST38_4@1
  double v17; // ST54_8@1
  float v18; // ST3C_4@1
  double v19; // st7@1
  float v20; // ST34_4@3
  char v21; // bl@1
  _DWORD *v22; // eax@3
  double v23; // st7@3
  float v24; // ST14_4@4
  double v25; // st7@4
  float v26; // ST2C_4@5
  double v28; // st7@6
  float v29; // ST64_4@6
  double v30; // st7@6
  float v31; // ST30_4@6
  double v32; // ST5C_8@6
  float v33; // ST0C_4@6
  float v34; // ST2C_4@6
  float v35; // ST2C_4@6
  float v36; // ST08_4@6
  float v37; // ST2C_4@6
  float v38; // ST2C_4@6
  double v39; // st7@7
  float v40; // ST2C_4@7
  double v41; // st7@7
  float v42; // ST34_4@7
  float v43; // ST38_4@7
  float v44; // ST2C_4@7
  float v45; // ST2C_4@7
  float v46; // ST6C_4@7
  float v47; // ST6C_4@7
  float v48; // ST0C_4@7
  float v49; // ST2C_4@7
  float v50; // ST2C_4@7
  float v51; // ST08_4@7
  float v52; // ST2C_4@7
  float v53; // ST2C_4@7
  double v54; // st7@8
  float v55; // ST2C_4@8
  double v56; // st7@8
  double v57; // ST6C_8@8
  float v58; // ST30_4@8
  double v59; // ST5C_8@8
  float v60; // ST2C_4@8
  float v61; // ST54_4@8
  float v62; // ST2C_4@8
  float v63; // ST34_4@8
  double v64; // ST64_8@8
  float v65; // ST30_4@8
  double v66; // ST5C_8@8
  float v67; // ST2C_4@8
  float v68; // ST44_4@8
  float v69; // ST2C_4@8
  float v70; // ST40_4@8
  float v71; // ST30_4@8
  float v72; // ST2C_4@8
  float v73; // ST4C_4@8
  float v74; // ST2C_4@8
  float v75; // ST48_4@8
  float v76; // ST30_4@9
  float v77; // ST2C_4@9
  float v78; // ST2C_4@9
  double v79; // st7@9
  double v80; // ST5C_8@9
  float v81; // ST2C_4@9
  double v82; // ST64_8@9
  float v83; // ST30_4@9
  float v84; // ST6C_4@9
  float v85; // ST6C_4@9
  float v86; // ST30_4@9
  float v87; // ST2C_4@9
  float v88; // ST2C_4@9
  float v89; // ST14_4@10
  float v90; // ST14_4@11
  double v91; // st7@14
  float v92; // ST2C_4@16
  float v93; // ST30_4@16
  float v94; // ST3C_4@16
  double v95; // ST5C_8@16
  float v96; // ST64_4@16
  float v97; // ST30_4@16
  float v98; // ST3C_4@16
  float v99; // ST64_4@16
  _DWORD *v100; // eax@20
  float v101; // ST14_4@20
  double v102; // st7@21
  float v103; // ST2C_4@21
  int v104; // edi@21
  float v105; // ST2C_4@21
  double v106; // st6@21
  double v107; // st7@21
  float v108; // ST6C_4@23
  _DWORD *v109; // eax@21
  int v110; // edi@22
  float v111; // ST3C_4@23
  float v112; // ST54_4@23
  float v113; // ST64_4@23
  float v114; // ST34_4@23
  double v115; // st6@23
  float v116; // ST44_4@23
  float v117; // ST40_4@23
  float v118; // ST30_4@25
  float v119; // ST2C_4@25
  float v120; // ST54_4@25
  float v121; // ST2C_4@25
  float v122; // ST34_4@25
  long double v123; // ST5C_8@25
  float v124; // ST2C_4@25
  double v125; // ST6C_8@25
  float v126; // ST44_4@25
  float v127; // ST2C_4@25
  double v128; // ST5C_8@25
  float v129; // ST40_4@25
  float v130; // ST30_4@25
  float v131; // ST2C_4@25
  float v132; // ST4C_4@25
  float v133; // ST2C_4@25
  float v134; // ST48_4@25
  float v135; // ST38_4@25
  float v136; // ST3C_4@25
  _DWORD *v137; // eax@25
  float v138; // ST14_4@25
  float v139; // ST34_4@26
  float v140; // ST30_4@26
  float v141; // ST2C_4@26
  double v142; // st7@26
  double v143; // ST54_8@26
  float v144; // ST2C_4@26
  double v145; // st7@26
  float v146; // ST30_4@26
  float v147; // ST2C_4@26
  double v148; // st7@26
  float v149; // ST2C_4@26
  double v150; // ST5C_8@26
  _DWORD *v151; // eax@26
  float v152; // ST2C_4@26
  float v153; // ST2C_4@26
  float v154; // ST34_4@27
  float v155; // ST30_4@27
  float v156; // ST2C_4@27
  double v157; // st7@27
  double v158; // ST54_8@27
  float v159; // ST2C_4@27
  double v160; // st7@27
  float v161; // ST30_4@27
  float v162; // ST2C_4@27
  double v163; // st7@27
  float v164; // ST2C_4@27
  double v165; // ST5C_8@27
  _DWORD *v166; // eax@27
  float v167; // ST2C_4@27
  float v168; // ST2C_4@27
  float v169; // ST30_4@28
  float v170; // ST3C_4@28
  float v171; // ST6C_4@28
  float v172; // ST64_4@28
  double v173; // st7@28
  float v174; // ST2C_4@28
  double v175; // st6@28
  float v176; // ST64_4@28
  float v177; // ST50_4@28
  float v178; // ST34_4@28
  float v179; // ST30_4@28
  float v180; // ST38_4@28
  double v181; // st7@28
  double v182; // ST54_8@28
  float v183; // ST4C_4@28
  float v184; // ST38_4@28
  double v185; // st7@28
  float v186; // ST48_4@28
  float v187; // ST44_4@28
  float v188; // ST40_4@28
  float v189; // ST30_4@28
  _DWORD *v190; // eax@28
  float v191; // ST38_4@28
  double v192; // ST5C_8@28
  float v193; // ST38_4@28
  double v194; // ST54_8@28
  float v195; // ST50_4@28
  float v196; // ST64_4@28
  float v197; // ST2C_4@28
  float v198; // ST2C_4@28
  float v199; // ST14_4@29
  float v200; // ST14_4@29
  float v201; // [sp+18h] [bp-73Ch]@3
  float v202; // [sp+18h] [bp-73Ch]@4
  int v203; // [sp+1Ch] [bp-738h]@0
  float v204; // [sp+2Ch] [bp-728h]@1
  float v205; // [sp+2Ch] [bp-728h]@21
  float v206; // [sp+30h] [bp-724h]@21
  float v207; // [sp+34h] [bp-720h]@9
  float v208; // [sp+34h] [bp-720h]@16
  float v209; // [sp+38h] [bp-71Ch]@1
  float v210; // [sp+38h] [bp-71Ch]@16
  float v211; // [sp+3Ch] [bp-718h]@1
  float v212; // [sp+3Ch] [bp-718h]@16
  float v213; // [sp+40h] [bp-714h]@1
  float v214; // [sp+40h] [bp-714h]@9
  float v215; // [sp+40h] [bp-714h]@16
  float v216; // [sp+44h] [bp-710h]@1
  float v217; // [sp+44h] [bp-710h]@9
  float v218; // [sp+44h] [bp-710h]@16
  float v219; // [sp+48h] [bp-70Ch]@1
  float v220; // [sp+48h] [bp-70Ch]@9
  float v221; // [sp+48h] [bp-70Ch]@16
  float v222; // [sp+4Ch] [bp-708h]@1
  float v223; // [sp+4Ch] [bp-708h]@9
  float v224; // [sp+4Ch] [bp-708h]@16
  float v225; // [sp+50h] [bp-704h]@1
  float v226; // [sp+50h] [bp-704h]@21
  float v227; // [sp+54h] [bp-700h]@1
  float v228; // [sp+54h] [bp-700h]@9
  float v229; // [sp+54h] [bp-700h]@16
  float v230; // [sp+64h] [bp-6F0h]@1
  float v231; // [sp+6Ch] [bp-6E8h]@1
  float v232; // [sp+74h] [bp-6E0h]@6
  float v233; // [sp+78h] [bp-6DCh]@6
  float v234; // [sp+7Ch] [bp-6D8h]@6
  float v235; // [sp+80h] [bp-6D4h]@6
  float v236; // [sp+84h] [bp-6D0h]@6
  float v237; // [sp+88h] [bp-6CCh]@6
  float v238; // [sp+8Ch] [bp-6C8h]@6
  int v239; // [sp+90h] [bp-6C4h]@6
  float v240; // [sp+94h] [bp-6C0h]@6
  char v241; // [sp+750h] [bp-4h]@6

  v2 = *(float *)(a1 + 8);
  v3 = *(float *)(a1 + 16) * 0.01745329251994333;
  v4 = cos(v3);
  v230 = v4 * v2 + *(float *)a1;
  v5 = sin(v3);
  v225 = v5 * v2 + *(float *)(a1 + 4);
  v6 = v2 * 0.800000011920929 * 0.949999988079071;
  v7 = cos(v3);
  v204 = v7 * v6 + *(float *)a1;
  v8 = sin(v3);
  v231 = v8 * v6 + *(float *)(a1 + 4);
  v9 = *(float *)(a1 + 12) * 0.5;
  v10 = (*(float *)(a1 + 16) + 90.0) * 0.01745329251994333;
  v11 = cos(v10);
  v12 = v11 * v9;
  v222 = v12 + *(float *)a1;
  v13 = sin(v10);
  v14 = v13 * v9;
  v219 = *(float *)(a1 + 4) + v14;
  v216 = v230 + v12;
  v213 = v14 + v225;
  v15 = (*(float *)(a1 + 16) - 90.0) * 0.01745329251994333;
  v16 = cos(v15);
  v17 = v16 * v9;
  v209 = v17 + *(float *)a1;
  v18 = sin(v15);
  v19 = v18 * v9;
  v211 = *(float *)(a1 + 4) + v19;
  v227 = v230 + v17;
  j_gdi_pvg_enable(35);
  j_gdi_pvg_blend_func(4, 5);
  v21 = *(_BYTE *)(a1 + 28);
  switch ( v21 )
  {
    case 1:
      *(_DWORD *)(a1 + 32) = 65;
      goto LABEL_3;
    case 0:
LABEL_3:
      j_gdi_pvg_enable(34);
      v22 = (_DWORD *)sub_100165A0(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v22);
      sub_100158F0(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_10015890(0.0, 0.0);
      v20 = v19 + v225;
      v201 = v20;
      v23 = v227;
      goto LABEL_4;
    case 3:
      v26 = *(float *)(a1 + 8) - 5.0;
      sub_1003A060(
        edi0,
        *(float *)a1,
        *(float *)(a1 + 4),
        v26,
        0.0,
        *(float *)(a1 + 20),
        *(float *)(a1 + 16),
        *(_DWORD *)(a1 + 24));
      return j_gdi_pvg_disable(35);
    case 2:
      v28 = *(float *)(a1 + 16) - *(float *)(a1 + 20);
      v239 = *(_DWORD *)(a1 + 24);
      v238 = v28;
      v241 = 0;
      v240 = 9.8999998e24;
      v237 = *(float *)(a1 + 16);
      v236 = *(float *)(a1 + 20);
      v29 = (*(float *)(a1 + 8) + *(float *)(a1 + 8)) * 0.800000011920929;
      v235 = v29;
      v234 = v29;
      v30 = 0.800000011920929 * *(float *)(a1 + 8);
      v232 = *(float *)a1 - v30;
      v233 = *(float *)(a1 + 4) - v30;
      sub_1003C3C0((int)&v232);
      sub_10039460((int)&v232);
      v31 = *(float *)(a1 + 16) * 0.01745329251994333;
      v32 = *(float *)(a1 + 8) - 5.0;
      v33 = v204;
      v34 = sin(v31);
      v35 = v34 * v32 + *(float *)(a1 + 4);
      v36 = v35;
      v37 = cos(v31);
      v38 = v37 * v32 + *(float *)a1;
      sub_1003A4D0(v38, v36, v33, v231, *(_DWORD *)(a1 + 24), 3.0);
      return j_gdi_pvg_disable(35);
    case 0xF:
      v39 = *(float *)(a1 + 16) - *(float *)(a1 + 20);
      v239 = *(_DWORD *)(a1 + 24);
      v238 = v39;
      v241 = 1;
      v240 = 9.8999998e24;
      v237 = *(float *)(a1 + 16);
      v236 = *(float *)(a1 + 20);
      v40 = (*(float *)(a1 + 8) + *(float *)(a1 + 8)) * *(float *)(a1 + 12);
      v235 = v40;
      v234 = v40;
      v41 = *(float *)(a1 + 12) * *(float *)(a1 + 8);
      v232 = *(float *)a1 - v41;
      v233 = *(float *)(a1 + 4) - v41;
      sub_1003C3C0((int)&v232);
      sub_10039460((int)&v232);
      v42 = *(float *)(a1 + 12) * *(float *)(a1 + 8) * 0.949999988079071;
      v43 = *(float *)(a1 + 16) * 0.01745329251994333;
      v44 = cos(v43);
      v45 = v44 * v42 + *(float *)a1;
      v46 = sin(v43);
      v47 = v46 * v42 + *(float *)(a1 + 4);
      v48 = v45;
      v49 = sin(v43);
      v50 = v49 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v51 = v50;
      v52 = cos(v43);
      v53 = v52 * *(float *)(a1 + 8) + *(float *)a1;
      sub_1003A4D0(v53, v51, v48, v47, *(_DWORD *)(a1 + 24), 3.0);
      return j_gdi_pvg_disable(35);
    case 6:
      v54 = *(float *)(a1 + 16) - *(float *)(a1 + 20);
      v239 = *(_DWORD *)(a1 + 24);
      v238 = v54;
      v241 = 0;
      v240 = 9.8999998e24;
      v237 = *(float *)(a1 + 16);
      v236 = *(float *)(a1 + 20);
      v55 = *(float *)(a1 + 8) * 1.799999952316284;
      v235 = v55;
      v234 = v55;
      v56 = *(float *)(a1 + 8) * 0.8999999761581421;
      v232 = *(float *)a1 - v56;
      v233 = *(float *)(a1 + 4) - v56;
      sub_1003C3C0((int)&v232);
      sub_10039460((int)&v232);
      v57 = (*(float *)(a1 + 16) + *(float *)(a1 + 20)) * 0.5;
      v58 = v57 * 0.01745329251994333;
      v59 = *(float *)(a1 + 8) * 0.8799999952316284;
      v60 = cos(v58);
      v61 = v60 * v59 + *(float *)a1;
      v62 = sin(v58);
      v63 = v62 * v59 + *(float *)(a1 + 4);
      v64 = (*(float *)(a1 + 16) - *(float *)(a1 + 20)) * 0.25;
      v65 = (v57 - v64) * 0.01745329251994333;
      v66 = *(float *)(a1 + 8) * 0.75;
      v67 = cos(v65);
      v68 = v67 * v66 + *(float *)a1;
      v69 = sin(v65);
      v70 = v69 * v66 + *(float *)(a1 + 4);
      v71 = (v64 + v57) * 0.01745329251994333;
      v72 = cos(v71);
      v73 = v72 * v66 + *(float *)a1;
      v74 = sin(v71);
      v75 = v74 * v66 + *(float *)(a1 + 4);
      j_gdi_pvg_begin(69);
      j_gdi_pvg_color_u32(-14671840);
      sub_10015960(v61, v63);
      sub_10015960(v68, v70);
      sub_10015960(v73, v75);
      j_gdi_pvg_end(v203);
      return j_gdi_pvg_disable(35);
    case 8:
    case 0xD:
      v76 = *(float *)(a1 + 16) * 0.01745329251994333;
      v77 = cos(v76);
      v228 = v77 * *(float *)(a1 + 8) + *(float *)a1;
      v78 = sin(v76);
      v207 = v78 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v79 = *(float *)(a1 + 12);
      v80 = *(float *)(a1 + 8) - v79;
      v81 = atan(v79 / (v80 + v80));
      v82 = *(float *)(a1 + 16) * 0.01745329238474369;
      v83 = v82 + v81;
      v84 = cos(v83);
      v217 = v84 * v80 + *(float *)a1;
      v85 = sin(v83);
      v214 = v85 * v80 + *(float *)(a1 + 4);
      v86 = v82 - v81;
      v87 = cos(v86);
      v223 = v87 * v80 + *(float *)a1;
      v88 = sin(v86);
      v220 = v88 * v80 + *(float *)(a1 + 4);
      j_gdi_pvg_enable(35);
      j_gdi_pvg_enable(38);
      if ( *(_BYTE *)(a1 + 28) == 13 )
      {
        sub_10015770(2.5);
        j_gdi_pvg_begin(66);
        j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
        sub_10015960(v228, v207);
        sub_10015960(v217, v214);
        sub_10015960(v223, v220);
        j_gdi_pvg_end(LODWORD(v89));
        sub_10015770(1.0);
      }
      else
      {
        j_gdi_pvg_begin(68);
        j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
        sub_10015960(v228, v207);
        sub_10015960(v217, v214);
        sub_10015960(v223, v220);
        j_gdi_pvg_end(LODWORD(v90));
        j_gdi_pvg_begin(66);
        j_gdi_pvg_color_u32(-16777216);
        sub_10015960(v228, v207);
        sub_10015960(v217, v214);
        sub_10015960(v223, v220);
        j_gdi_pvg_end(v203);
      }
      j_gdi_pvg_disable(38);
      j_gdi_pvg_disable(35);
      return j_gdi_pvg_disable(35);
    case 4:
    case 5:
    case 0xE:
      if ( 0.0 == *(float *)(a1 + 20) )
        v91 = 5.0;
      else
        v91 = *(float *)(a1 + 20);
      v92 = v91;
      v93 = (*(float *)(a1 + 16) - v92) * 0.01745329251994333;
      v94 = cos(v93);
      v95 = *(float *)(a1 + 12) + *(float *)(a1 + 8);
      v229 = v95 * v94 + *(float *)a1;
      v96 = sin(v93);
      v208 = v95 * v96 + *(float *)(a1 + 4);
      v218 = v94 * *(float *)(a1 + 8) + *(float *)a1;
      v215 = v96 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v97 = (*(float *)(a1 + 16) + v92) * 0.01745329251994333;
      v98 = cos(v97);
      v224 = v98 * *(float *)(a1 + 8) + *(float *)a1;
      v99 = sin(v97);
      *(_DWORD *)(a1 + 32) = 5;
      v221 = v99 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v210 = v98 * v95 + *(float *)a1;
      v212 = v99 * v95 + *(float *)(a1 + 4);
      if ( v21 == 5 )
      {
        *(_DWORD *)(a1 + 32) = 56;
      }
      else if ( v21 == 14 )
      {
        *(_DWORD *)(a1 + 32) = 112;
      }
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      j_gdi_pvg_enable(34);
      v100 = (_DWORD *)sub_100165A0(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v100);
      sub_100158F0(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_10015890(0.0, 0.0);
      sub_10015960(v229, v208);
      sub_10015890(0.0, 1.0);
      sub_10015960(v218, v215);
      sub_10015890(1.0, 1.0);
      sub_10015960(v224, v221);
      sub_10015890(1.0, 0.0);
      sub_10015960(v210, v212);
      j_gdi_pvg_end(LODWORD(v101));
      j_gdi_pvg_disable(34);
      j_gdi_pvg_disable(35);
      return j_gdi_pvg_disable(35);
    case 7:
      v102 = *(float *)(a1 + 16) - *(float *)(a1 + 20);
      v103 = v102;
      v104 = (signed int)COERCE_FLOAT(LODWORD(v103) & 0x7FFFFFFF) / 5 + 1;
      *(_DWORD *)(a1 + 32) = 66;
      v105 = (double)v104;
      v106 = v102 / v105;
      v107 = v105;
      v205 = v106 * 0.01745329238474369;
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      j_gdi_pvg_enable(34);
      v109 = (_DWORD *)sub_100165A0(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v109);
      sub_100158F0(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(73);
      v206 = *(float *)(a1 + 20) * 0.01745329238474369;
      v226 = 0.0;
      if ( v104 >= 0 )
      {
        v110 = v104 + 1;
        do
        {
          v111 = cos(v206);
          v112 = v111 * *(float *)(a1 + 8) + *(float *)a1;
          v113 = sin(v206);
          v114 = v113 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
          v115 = *(float *)(a1 + 12) + *(float *)(a1 + 8);
          v116 = v111 * v115 + *(float *)a1;
          v117 = v113 * v115 + *(float *)(a1 + 4);
          sub_10015890(v226, 0.0);
          sub_10015960(v112, v114);
          sub_10015890(v226, 1.0);
          sub_10015960(v116, v117);
          --v110;
          v206 = v205 + v206;
          v108 = 1.0 / v107;
          v226 = v226 + v108;
        }
        while ( v110 );
      }
      j_gdi_pvg_end(v203);
      j_gdi_pvg_disable(34);
      j_gdi_pvg_disable(35);
      return j_gdi_pvg_disable(35);
    case 9:
      v118 = (*(float *)(a1 + 16) - *(float *)(a1 + 20)) * 0.01745329251994333;
      v119 = cos(v118);
      v120 = v119 * *(float *)(a1 + 8) + *(float *)a1;
      v121 = sin(v118);
      v122 = v121 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v123 = *(float *)(a1 + 16) * 0.01745329251994333;
      v124 = cos(v123);
      v125 = v124 * *(float *)(a1 + 12);
      v126 = v125 + v120;
      v127 = sin(v123);
      v128 = v127 * *(float *)(a1 + 12);
      v129 = v128 + v122;
      v130 = (*(float *)(a1 + 16) + *(float *)(a1 + 20)) * 0.01745329251994333;
      v131 = cos(v130);
      v132 = v131 * *(float *)(a1 + 8) + *(float *)a1;
      v133 = sin(v130);
      v134 = v133 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v135 = v132 + v125;
      v136 = v134 + v128;
      j_gdi_pvg_enable(35);
      j_gdi_pvg_blend_func(4, 5);
      j_gdi_pvg_enable(34);
      v137 = (_DWORD *)sub_100165A0(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v137);
      sub_100158F0(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_10015890(0.0, 0.0);
      sub_10015960(v120, v122);
      sub_10015890(0.0, 1.0);
      sub_10015960(v126, v129);
      sub_10015890(1.0, 1.0);
      sub_10015960(v135, v136);
      sub_10015890(1.0, 0.0);
      sub_10015960(v132, v134);
      j_gdi_pvg_end(LODWORD(v138));
      j_gdi_pvg_disable(34);
      j_gdi_pvg_disable(35);
      return j_gdi_pvg_disable(35);
    case 0xA:
      v139 = *(float *)(a1 + 12);
      v140 = (*(float *)(a1 + 16) + 90.0) * 0.01745329251994333;
      v141 = cos(v140);
      v142 = v141 * v139;
      v143 = v142;
      v222 = v142 + *(float *)a1;
      v144 = sin(v140);
      v145 = v144 * v139;
      v219 = *(float *)(a1 + 4) + v145;
      v216 = v230 + v143;
      v213 = v145 + v225;
      v146 = (*(float *)(a1 + 16) - 90.0) * 0.01745329251994333;
      v147 = cos(v146);
      v148 = v147 * v139;
      v209 = v148 + *(float *)a1;
      v149 = sin(v146);
      *(_DWORD *)(a1 + 32) = 68;
      v150 = v149 * v139;
      v211 = v150 + *(float *)(a1 + 4);
      j_gdi_pvg_enable(34);
      v151 = (_DWORD *)sub_100165A0(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v151);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_10015890(0.0, 0.0);
      v152 = v225 + v150;
      v201 = v152;
      v153 = v230 + v148;
      v23 = v153;
      goto LABEL_4;
    case 0xB:
      v154 = *(float *)(a1 + 12);
      v155 = (*(float *)(a1 + 16) + 90.0) * 0.01745329251994333;
      v156 = cos(v155);
      v157 = v156 * v154;
      v158 = v157;
      v222 = v157 + *(float *)a1;
      v159 = sin(v155);
      v160 = v159 * v154;
      v219 = *(float *)(a1 + 4) + v160;
      v216 = v230 + v158;
      v213 = v160 + v225;
      v161 = (*(float *)(a1 + 16) - 90.0) * 0.01745329251994333;
      v162 = cos(v161);
      v163 = v162 * v154;
      v209 = v163 + *(float *)a1;
      v164 = sin(v161);
      *(_DWORD *)(a1 + 32) = 69;
      v165 = v164 * v154;
      v211 = v165 + *(float *)(a1 + 4);
      j_gdi_pvg_enable(34);
      v166 = (_DWORD *)sub_100165A0(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v166);
      sub_100158F0(84, 82, 79.0);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_10015890(0.0, 0.0);
      v167 = v225 + v165;
      v201 = v167;
      v168 = v230 + v163;
      v23 = v168;
LABEL_4:
      v24 = v23;
      sub_10015960(v24, v201);
      sub_10015890(0.0, 1.0);
      sub_10015960(v216, v213);
      sub_10015890(1.0, 1.0);
      sub_10015960(v222, v219);
      sub_10015890(1.0, 0.0);
      v202 = v211;
      v25 = v209;
      goto LABEL_29;
    case 0xC:
      v169 = *(float *)(a1 + 16) * 0.01745329251994333;
      v170 = cos(v169);
      v171 = v170 * *(float *)(a1 + 8) + *(float *)a1;
      v172 = sin(v169);
      v173 = v172;
      v174 = v172 * *(float *)(a1 + 8) + *(float *)(a1 + 4);
      v175 = *(float *)(a1 + 12) + *(float *)(a1 + 8);
      v176 = v170 * v175 + *(float *)a1;
      v177 = v173 * v175 + *(float *)(a1 + 4);
      v178 = *(float *)(a1 + 12) * 0.015625 * 16.0;
      v179 = (*(float *)(a1 + 16) + 90.0) * 0.01745329251994333;
      v180 = cos(v179);
      v181 = v180 * v178;
      v182 = v181;
      v183 = v181 + v171;
      v184 = sin(v179);
      v185 = v184 * v178;
      *(_DWORD *)(a1 + 32) = 68;
      v186 = v174 + v185;
      v187 = v176 + v182;
      v188 = v185 + v177;
      v189 = (*(float *)(a1 + 16) - 90.0) * 0.01745329251994333;
      j_gdi_pvg_enable(34);
      v190 = (_DWORD *)sub_100165A0(*(_DWORD *)(a1 + 32));
      j_gdi_pvg_bind_texture(34, *v190);
      j_gdi_pvg_color_u32(*(_DWORD *)(a1 + 24));
      j_gdi_pvg_begin(72);
      sub_10015890(0.0, 0.0);
      v191 = sin(v189);
      v192 = v191 * v178;
      v193 = cos(v189);
      v194 = v193 * v178;
      v195 = v177 + v192;
      v196 = v194 + v176;
      sub_10015960(v196, v195);
      sub_10015890(0.0, 1.0);
      sub_10015960(v187, v188);
      sub_10015890(1.0, 1.0);
      sub_10015960(v183, v186);
      sub_10015890(1.0, 0.0);
      v197 = v174 + v192;
      v202 = v197;
      v198 = v171 + v194;
      v25 = v198;
LABEL_29:
      v199 = v25;
      sub_10015960(v199, v202);
      j_gdi_pvg_end(LODWORD(v200));
      j_gdi_pvg_disable(34);
      break;
    default:
      return j_gdi_pvg_disable(35);
  }
  return j_gdi_pvg_disable(35);
}
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 100155C0: using guessed type int __cdecl j_gdi_pvg_blend_func(_DWORD, _DWORD);
// 10015680: using guessed type int __cdecl j_gdi_pvg_color_u32(_DWORD);
// 10015690: using guessed type int __cdecl j_gdi_pvg_disable(_DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);

//----- (1003E0F0) --------------------------------------------------------
void __cdecl sub_1003E0F0(int a1, int a2)
{
  sub_1003C9A0(a1, a2, 1);
}

//----- (1003E110) --------------------------------------------------------
int __cdecl sub_1003E110(int a1, float a2, float a3, float a4, float a5)
{
  return sub_1003CA40(a1, a2, a3, a4, a5, 0);
}

//----- (1003E150) --------------------------------------------------------
int __cdecl sub_1003E150(int a1, float a2, float a3, float a4, float a5)
{
  return sub_1003CA40(a1, a2, a3, a4, a5, 1);
}

//----- (1003E190) --------------------------------------------------------
int __cdecl sub_1003E190(int a1, char a2)
{
  return sub_1003C670(a2, a1, 1);
}

//----- (1003E1B0) --------------------------------------------------------
void __cdecl sub_1003E1B0(float a1, float a2, float a3, float a4, float a5, int a6, int a7)
{
  sub_1003CBC0((int *)a7, a6, a1, a2, a3, a4, a5, 0.1308997);
}

//----- (1003E200) --------------------------------------------------------
void __usercall sub_1003E200(int a1@<edx>, int a2@<ecx>, char a3)
{
  int v3; // esi@1
  int v4; // eax@1
  double v5; // st7@1
  int v6; // ebx@1
  float v7; // [sp+8h] [bp-38h]@1
  float v8; // [sp+Ch] [bp-34h]@1
  int v9; // [sp+10h] [bp-30h]@1
  int v10; // [sp+14h] [bp-2Ch]@1
  char v11; // [sp+18h] [bp-28h]@1
  float v12; // [sp+30h] [bp-10h]@1
  float v13; // [sp+34h] [bp-Ch]@1
  float v14; // [sp+38h] [bp-8h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 8);
  v7 = *(float *)a1;
  v5 = *(float *)(a1 + 4);
  v9 = v4;
  v8 = v5;
  v6 = a2;
  v10 = *(_DWORD *)(a1 + 12);
  strncpy(&v11, (const char *)(a1 + 16), 7u);
  v12 = *(float *)(v3 + 24);
  v13 = *(float *)(v3 + 28);
  v14 = *(float *)(v3 + 32);
  sub_1003C9A0(v6, (int)&v7, a3);
}

//----- (1003E280) --------------------------------------------------------
void __cdecl sub_1003E280(int a1, int a2)
{
  sub_1003E200(a2, a1, 0);
}

//----- (1003E2A0) --------------------------------------------------------
void __cdecl sub_1003E2A0(int a1, int a2)
{
  sub_1003E200(a2, a1, 1);
}

//----- (1003E2C0) --------------------------------------------------------
void __cdecl sub_1003E2C0(int a1, int a2)
{
  switch ( *(_BYTE *)(a2 + 62) )
  {
    case 1:
      sub_10039EC0(
        *(float *)a2,
        *(float *)(a2 + 4),
        *(float *)(a2 + 8),
        *(float *)(a2 + 12),
        *(_DWORD *)(a2 + 56),
        -16777216);
      sub_1003E280(a1, a2 + 16);
      break;
    case 2:
      sub_1003B680(
        *(float *)a2,
        *(float *)(a2 + 4),
        *(float *)(a2 + 8),
        *(float *)(a2 + 12),
        COERCE_FLOAT(*(_BYTE *)(a2 + 52)),
        *(_DWORD *)(a2 + 56),
        -16777216);
      sub_1003E280(a1, a2 + 16);
      break;
    case 3:
      sub_1003A780(
        *(float *)a2,
        *(float *)(a2 + 4),
        *(float *)(a2 + 8),
        *(float *)(a2 + 12),
        COERCE_FLOAT(*(_BYTE *)(a2 + 52)),
        *(_DWORD *)(a2 + 56),
        -16777216);
      sub_1003E280(a1, a2 + 16);
      break;
    default:
      sub_1003C070(
        *(float *)a2,
        *(float *)(a2 + 4),
        *(float *)(a2 + 8),
        *(float *)(a2 + 12),
        COERCE_FLOAT(*(_BYTE *)(a2 + 52)),
        *(_DWORD *)(a2 + 56),
        -16777216);
      sub_1003E280(a1, a2 + 16);
      break;
  }
}

//----- (1003E3E0) --------------------------------------------------------
bool __cdecl sub_1003E3E0(char a1)
{
  int v1; // eax@1

  v1 = a1 & 0x3F;
  return !(a1 & 0x3F) || v1 == 6 || v1 == 7 || v1 == 21 || v1 == 9 || v1 == 16 || v1 == 20;
}

//----- (1003E410) --------------------------------------------------------
int __cdecl sub_1003E410(unsigned __int8 a1)
{
  return (int)*(&off_100AF0E8 + 2 * a1);
}
// 100AF0E8: using guessed type void *off_100AF0E8;

//----- (1003E420) --------------------------------------------------------
int __cdecl sub_1003E420(unsigned int a1, float *a2)
{
  unsigned __int8 v2; // ST0C_1@1

  v2 = sub_100411B0(a1, a2);
  return sub_1003E410(v2);
}

//----- (1003E450) --------------------------------------------------------
__int16 __cdecl sub_1003E450(int a1, int a2, int a3)
{
  __int16 v3; // si@1

  SYS_enter_krnl();
  v3 = SYS_pvg_alrt_cnt(a1, a2, a3, 0);
  SYS_exit_krnl();
  return v3;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070F40: using guessed type int __cdecl SYS_pvg_alrt_cnt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E480) --------------------------------------------------------
char __cdecl sub_1003E480(int a1, int a2, int a3, int a4)
{
  char v4; // bl@1

  SYS_enter_krnl();
  v4 = SYS_pvg_alrt_get_dsply_alrt(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070F46: using guessed type int __cdecl SYS_pvg_alrt_get_dsply_alrt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E4B0) --------------------------------------------------------
char __cdecl sub_1003E4B0(int a1, int a2, int a3)
{
  char v3; // bl@1

  SYS_enter_krnl();
  v3 = SYS_pvg_alrt_get_hdr_text(a1, a2, a3);
  SYS_exit_krnl();
  return v3;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070F4C: using guessed type int __cdecl SYS_pvg_alrt_get_hdr_text(_DWORD, _DWORD, _DWORD);

//----- (1003E4E0) --------------------------------------------------------
char __cdecl sub_1003E4E0(__int16 a1)
{
  char v1; // bl@1
  __int16 v3; // [sp+4h] [bp-A0h]@1

  v3 = a1;
  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_id_is_set(&v3, 0);
  SYS_exit_krnl();
  return v1;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070F52: using guessed type int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD);

//----- (1003E540) --------------------------------------------------------
char __cdecl sub_1003E540(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_text(a1, 1);
  SYS_exit_krnl();
  return v1;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10070F58: using guessed type int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD);

//----- (1003E5B0) --------------------------------------------------------
int __cdecl sub_1003E5B0(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_100B0684[a1];
  return result;
}
// 100B0684: using guessed type __int16 word_100B0684[];

//----- (1003E5D0) --------------------------------------------------------
signed int sub_1003E5D0()
{
  signed int result; // eax@1

  result = -15;
  dword_101B2094 = -15;
  dword_101B20A0 = -15;
  dword_101B207C = -15;
  dword_101B20A4 = -15;
  dword_101B2090 = -15;
  dword_101B2080 = -15;
  dword_101B2078 = -15;
  dword_101B208C = -15;
  dword_101B209C = -15;
  dword_101B2098 = -15;
  dword_101B2088 = -15;
  dword_101B2084 = -15;
  return result;
}
// 101B2078: using guessed type int dword_101B2078;
// 101B207C: using guessed type int dword_101B207C;
// 101B2080: using guessed type int dword_101B2080;
// 101B2084: using guessed type int dword_101B2084;
// 101B2088: using guessed type int dword_101B2088;
// 101B208C: using guessed type int dword_101B208C;
// 101B2090: using guessed type int dword_101B2090;
// 101B2094: using guessed type int dword_101B2094;
// 101B2098: using guessed type int dword_101B2098;
// 101B209C: using guessed type int dword_101B209C;
// 101B20A0: using guessed type int dword_101B20A0;
// 101B20A4: using guessed type int dword_101B20A4;

//----- (1003E620) --------------------------------------------------------
signed int __usercall sub_1003E620@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_100175B0((int)&off_100B06A4);
      break;
    case 0:
      result = sub_100175B0((int)&off_100B06B8);
      break;
    case 1:
      result = sub_100175B0((int)&off_100B06CC);
      break;
    case 2:
      result = sub_100175B0((int)&off_100B06F4);
      break;
    case 3:
      result = sub_100175B0((int)&off_100B06E0);
      break;
    case 5:
      result = sub_100175B0((int)&off_100B0708);
      break;
    default:
      result = sub_100175B0(a2);
      break;
  }
  return result;
}
// 100B06A4: using guessed type char *off_100B06A4;
// 100B06B8: using guessed type char *off_100B06B8;
// 100B06CC: using guessed type char *off_100B06CC;
// 100B06E0: using guessed type char *off_100B06E0;
// 100B06F4: using guessed type char *off_100B06F4;
// 100B0708: using guessed type char *off_100B0708;

//----- (1003E6C0) --------------------------------------------------------
int __usercall sub_1003E6C0@<eax>(char a1@<al>)
{
  return sub_10016150(dword_100B01D4[a1]);
}
// 100B01D4: using guessed type int dword_100B01D4[];

//----- (1003E6E0) --------------------------------------------------------
int __usercall sub_1003E6E0@<eax>(char a1@<al>)
{
  return sub_10016170(dword_100B01D4[a1], 10);
}
// 100B01D4: using guessed type int dword_100B01D4[];

//----- (1003E700) --------------------------------------------------------
signed __int16 __usercall sub_1003E700@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_1003E620(a1, a1) )
        {
          sub_10015C20("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_101B2094 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_10015C20("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10015C20("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_1003E620(a1, a1) )
      {
        result = *(_WORD *)(dword_101B20A0 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_10025B90(15000) )
        goto LABEL_6;
      sub_10015C20("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10015C20("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1003E620(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101B207C + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10015C20("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1003E620(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101B20A4 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10015C20("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1003E620(a1, a1) )
      {
        sub_10015C20("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_101B2090 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_1003E620(a1, a1) )
        {
          result = *(_WORD *)(dword_101B2080 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 101B207C: using guessed type int dword_101B207C;
// 101B2080: using guessed type int dword_101B2080;
// 101B2090: using guessed type int dword_101B2090;
// 101B2094: using guessed type int dword_101B2094;
// 101B20A0: using guessed type int dword_101B20A0;
// 101B20A4: using guessed type int dword_101B20A4;

//----- (1003E940) --------------------------------------------------------
char __cdecl sub_1003E940(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_1003E700(a1, a2);
  if ( v3 != -1 && !sub_1003E6E0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101B2094);
        sub_1003E6C0(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101B20A0);
        sub_1003E6C0(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_101B207C;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101B20A4);
        sub_1003E6C0(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_101B2090);
        sub_1003E6C0(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_101B2080;
LABEL_16:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_1003E6C0(a1);
        return 1;
      default:
LABEL_17:
        sub_1003E6C0(a1);
        break;
    }
  }
  return 0;
}
// 101B207C: using guessed type int dword_101B207C;
// 101B2080: using guessed type int dword_101B2080;
// 101B2090: using guessed type int dword_101B2090;
// 101B2094: using guessed type int dword_101B2094;
// 101B20A0: using guessed type int dword_101B20A0;
// 101B20A4: using guessed type int dword_101B20A4;

//----- (1003EAA0) --------------------------------------------------------
char __cdecl sub_1003EAA0(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_1003E700(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1003E620(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B2094 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_1003E620(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B20A0 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_1003E620(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B207C + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_1003E620(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B20A4 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_1003E620(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B2090 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_1003E620(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_101B2080 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 101B207C: using guessed type int dword_101B207C;
// 101B2080: using guessed type int dword_101B2080;
// 101B2090: using guessed type int dword_101B2090;
// 101B2094: using guessed type int dword_101B2094;
// 101B20A0: using guessed type int dword_101B20A0;
// 101B20A4: using guessed type int dword_101B20A4;

//----- (1003EC20) --------------------------------------------------------
char __cdecl sub_1003EC20(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_1003E700(a1, a2);
  if ( v3 != -1 && !sub_1003E6E0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B2094 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B20A0 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B207C + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B20A4 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B2090 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_1003E620(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101B2080 + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_1003E6C0(a1);
        return 1;
      default:
LABEL_17:
        sub_1003E6C0(a1);
        break;
    }
  }
  return 0;
}
// 101B207C: using guessed type int dword_101B207C;
// 101B2080: using guessed type int dword_101B2080;
// 101B2090: using guessed type int dword_101B2090;
// 101B2094: using guessed type int dword_101B2094;
// 101B20A0: using guessed type int dword_101B20A0;
// 101B20A4: using guessed type int dword_101B20A4;

//----- (1003ED80) --------------------------------------------------------
char __cdecl sub_1003ED80(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_1003E620(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_1003E700(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_1003EAA0(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy_0(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_100160A0();
      v13 = 0;
      LOBYTE(v7) = sub_10051170(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (1003EEC0) --------------------------------------------------------
char __cdecl sub_1003EEC0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_1003E700(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_10051170(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (1003EFA0) --------------------------------------------------------
char __cdecl sub_1003EFA0(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_100160A0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_1003E700(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_1003E620(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_101B2094 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_101B2094 + 210116;
          v12 = dword_101B2094 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_1003E620(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_101B20A0 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_101B20A0 + 257156;
          v12 = dword_101B20A0 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_1003E620(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_101B207C + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_101B207C + 321708;
          v12 = dword_101B207C + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_1003E620(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_101B20A4 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_101B20A4 + 326220;
          v12 = dword_101B20A4 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_1003E620(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_101B2090 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_101B2090 + 18832;
          v12 = dword_101B2090 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_1003E620(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_101B2080 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_101B2080 + 1596;
          v12 = dword_101B2080 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_1003E6E0(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy_0(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_1003E6C0(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101B2078: using guessed type int dword_101B2078;
// 101B207C: using guessed type int dword_101B207C;
// 101B2080: using guessed type int dword_101B2080;
// 101B208C: using guessed type int dword_101B208C;
// 101B2090: using guessed type int dword_101B2090;
// 101B2094: using guessed type int dword_101B2094;
// 101B209C: using guessed type int dword_101B209C;
// 101B20A0: using guessed type int dword_101B20A0;
// 101B20A4: using guessed type int dword_101B20A4;

//----- (1003F220) --------------------------------------------------------
char __cdecl sub_1003F220(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_1003EFA0(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (1003F250) --------------------------------------------------------
char __cdecl sub_1003F250(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_1003EFA0(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (1003F280) --------------------------------------------------------
char __cdecl sub_1003F280(char a1, int a2, void *a3, int a4)
{
  return sub_1003EFA0(a1, a2, 0, 0, a3, a4);
}

//----- (1003F2B0) --------------------------------------------------------
int __cdecl sub_1003F2B0(void *a1)
{
  float v2; // [sp+0h] [bp-4h]@1

  v2 = 9.8999998e24;
  return sub_100163E0(9153, a1, 4, &v2);
}

//----- (1003F2E0) --------------------------------------------------------
bool __cdecl sub_1003F2E0(float *a1)
{
  unsigned __int8 v1; // bl@1
  _WORD *v2; // esi@1
  signed int v3; // edi@1
  float v5; // [sp+1Ch] [bp-8h]@1
  int v6; // [sp+20h] [bp-4h]@2

  v5 = 0.0;
  v1 = 0;
  v2 = &unk_100B1630;
  v3 = 4;
  do
  {
    if ( sub_1003F250(1, *v2, &v6) && !sub_10052830((int)&v6, -100.0, 70.0, COERCE_INT(0.0), 0) )
    {
      ++v1;
      v5 = *(float *)&v6 + v5;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  if ( v1 )
  {
    v6 = v1;
    *a1 = v5 / (double)v1;
  }
  return v1 != 0;
}

//----- (1003F380) --------------------------------------------------------
char __cdecl sub_1003F380(float *a1)
{
  double v1; // st7@5
  double v2; // st7@10
  double v3; // st3@13
  char result; // al@13
  double v5; // st7@13
  char v6; // [sp+7h] [bp-29h]@1
  float v7; // [sp+8h] [bp-28h]@3
  float v8; // [sp+Ch] [bp-24h]@1
  float v9; // [sp+10h] [bp-20h]@8
  float v10; // [sp+14h] [bp-1Ch]@13
  float v11; // [sp+18h] [bp-18h]@13
  float v12; // [sp+1Ch] [bp-14h]@13
  float v13; // [sp+20h] [bp-10h]@13
  float v14; // [sp+24h] [bp-Ch]@13
  float v15; // [sp+28h] [bp-8h]@2
  float v16; // [sp+2Ch] [bp-4h]@13

  sub_10040E50((bool *)&v6);
  if ( sub_10040700(0xC9u, &v8) && sub_10040700(0xCAu, &v15) )
  {
    if ( !sub_10025580(&v7) )
    {
      if ( v6 )
        v1 = 59501.773;
      else
        v1 = 17857.426;
      v7 = v1;
    }
    if ( !sub_10040700(0x75u, &v9) )
    {
      if ( v6 )
        v2 = 105007.18;
      else
        v2 = 84667.641;
      v9 = v2;
    }
    v10 = v15 + 273.1499938964844;
    v11 = v10 * v10;
    v12 = v11 * v10;
    v16 = v10 * v12;
    v15 = v7 + v8;
    v13 = v15 * 0.000145037702168338;
    v7 = v13 * v13;
    v8 = v7 * v13;
    v14 = v8 * v13;
    v15 = exp(-v13 / 464.7000122070312);
    v3 = v16;
    v16 = (13.75137901306152 - v10 * 0.1226860210299492 + v11 * 0.0003980170004069805 - v12 * 0.0000004366189898519224)
        * v13
        + 10742.181640625
        - 177.0700836181641 * v10
        + 1.059352517127991 * v11
        - 0.002737746108323336 * v12
        + 0.000002587880089777173 * v16
        + (0.001406852970831096 - v10 * 0.000008421870006714016 + v11 * 0.0000000123934995599484) * v7
        + (v10 * 1.458149920252616e-11 - 0.000000004256659913437488) * v8
        + v14 * 5.409509849069703e-14;
    result = 1;
    v5 = v16 * (1.0 - v15);
    v16 = (0.001010339008644223 - v10 * 0.000006046890121069737 + v11 * 0.000000008856750000063585) * v7
        + v13
        * (4.909426212310791 - v10 * 0.02970160357654095 + v11 * 0.00007757999992463738 - v12
                                                                                        * 0.00000007407909663470491)
        + 329.7364501953125
        - v10 * 4.856092929840088
        + v11 * 0.02650014311075211
        - v12 * 0.00006350519834086299
        + v3 * 0.00000005639689959480165
        + (0.00000001747300082399761 - v10 * 3.771030016030963e-11) * v8
        - v14 * 4.320039985461488e-12;
    v8 = v5 + v16 * v15;
    *a1 = v8 * 6894.75927734375 - v9;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003F620) --------------------------------------------------------
double sub_1003F620()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_100163E0(10043, &v2, 4, &v1);
  return v2;
}

//----- (1003F650) --------------------------------------------------------
double sub_1003F650()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_100163E0(10002, &v2, 4, &v1);
  return v2;
}

//----- (1003F680) --------------------------------------------------------
int sub_1003F680()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 1;
  return sub_10016450(9151, (int)&v1, 1);
}

//----- (1003F6A0) --------------------------------------------------------
int sub_1003F6A0()
{
  float v1; // [sp+0h] [bp-4h]@1

  v1 = 0.0;
  sub_10016450(10043, (int)&v1, 4);
  sub_10016450(10044, (int)&v1, 4);
  sub_10016450(10045, (int)&v1, 4);
  return sub_10016450(10046, (int)&v1, 4);
}

//----- (1003F6F0) --------------------------------------------------------
char __cdecl sub_1003F6F0(char a1)
{
  return sub_1003ED80(1, 942, &a1, 0, 1, 1);
}

//----- (1003F710) --------------------------------------------------------
int __cdecl sub_1003F710(char a1)
{
  return sub_10016450(9153, (int)&a1, 4);
}

//----- (1003F730) --------------------------------------------------------
void __usercall sub_1003F730(int a1@<esi>, int a2, float a3)
{
  signed int v3; // ebx@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@3
  double v7; // st6@4
  double v8; // st6@5
  double v9; // st7@5
  double v10; // st6@8
  double v11; // st7@8
  int v12; // edi@10
  signed int v13; // ecx@10
  int v14; // ebx@11
  signed int v15; // edx@11
  int v16; // ebp@13
  float *v17; // eax@19
  int v18; // [sp+4h] [bp-4h]@13
  float *v19; // [sp+10h] [bp+8h]@11
  float v20; // [sp+10h] [bp+8h]@19

  v3 = *(_BYTE *)(a1 + 320);
  v4 = v3 - 1;
  v5 = 0;
  if ( *(float *)(a1 + 8 * v3 - 4) < (double)*(float *)(a1 + 4) )
  {
    v5 = v3 - 1;
    v4 = 0;
  }
  v6 = a3;
  if ( *(float *)(a1 + 8 * v4 + 4) < (double)a3 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v8 = *(float *)(a1 + 8 * v4) / v6;
      v9 = 0.0;
      *(float *)a2 = v8;
      *(float *)(a2 + 4) = *(float *)&v9;
      return;
    }
LABEL_9:
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v7;
    return;
  }
  if ( *(float *)(a1 + 8 * v5 + 4) > v6 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v10 = *(float *)(a1 + 8 * v5) / v6;
      v11 = 0.0;
      *(float *)a2 = v10;
      *(float *)(a2 + 4) = *(float *)&v11;
      return;
    }
    goto LABEL_9;
  }
  v12 = 0;
  v13 = 1;
  if ( v3 <= 1 )
  {
LABEL_18:
    *(float *)a2 = 0.0;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12);
  }
  else
  {
    v14 = 0;
    v15 = 8;
    v19 = (float *)(a1 + 12);
    while ( 1 )
    {
      if ( *(float *)(v14 + a1 + 4) >= (double)*v19 )
      {
        v12 = v13 - 1;
        v14 = v15 - 8;
        v16 = v13;
        v18 = v15;
      }
      else
      {
        v12 = v13;
        v14 = v15;
        v16 = v13 - 1;
        v18 = v15 - 8;
      }
      if ( *(float *)(v14 + a1 + 4) > v6 && *(float *)(v18 + a1 + 4) <= v6 )
        break;
      v19 += 2;
      ++v13;
      v15 += 8;
      if ( v13 >= *(_BYTE *)(a1 + 320) )
        goto LABEL_18;
    }
    v17 = (float *)(a1 + 8 * v12 + 4);
    v20 = (*(float *)(a1 + 8 * v12) - *(float *)(a1 + 8 * v16)) / (*v17 - *(float *)(a1 + 8 * v16 + 4));
    *(float *)a2 = v20;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12) - v20 * *v17;
  }
}

//----- (1003F890) --------------------------------------------------------
char __usercall sub_1003F890@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3)
{
  double v3; // st7@8
  char result; // al@10
  char v5; // [sp+7h] [bp-29h]@3
  float v6; // [sp+8h] [bp-28h]@1
  float v7; // [sp+Ch] [bp-24h]@3
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  float v12[4]; // [sp+20h] [bp-10h]@1

  v6 = 0.0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_100163E0(6117, v12, 16, &v8) )
    sub_10015C20("..\\lib\\adl\\iop_eis_intf.c", 2716, 0, 0);
  sub_1003E940(1, 0x50u, &v5);
  if ( sub_10016420(6354, (int)&v7, 4) )
    sub_10015C20("..\\lib\\adl\\iop_eis_intf.c", 2735, 0, 0);
  if ( (sub_10052C30(a2) || v5) && sub_10040700(a2, &v6) )
  {
    v6 = v12[2 * a3] * v6;
    v3 = v6;
    *a1 = v6;
    if ( v7 > v3 )
      *a1 = 0.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1003F890: using guessed type float var_10[4];

//----- (1003F980) --------------------------------------------------------
char __usercall sub_1003F980@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4)
{
  int v4; // ecx@1
  unsigned __int16 *v5; // esi@1
  char v6; // al@1
  double v7; // st7@1
  int v8; // ebp@1
  unsigned __int8 v9; // bl@4
  char result; // al@7
  int v11; // eax@9
  unsigned __int16 *v12; // edi@9
  int v13; // eax@11
  int v14; // eax@14
  int v15; // eax@17
  double v16; // st7@22
  double v17; // st7@24
  int v18; // edi@31
  int v19; // [sp-8h] [bp-A0h]@12
  int v20; // [sp-4h] [bp-9Ch]@12
  float v21; // [sp+0h] [bp-98h]@12
  float v22; // [sp+14h] [bp-84h]@1
  float v23; // [sp+18h] [bp-80h]@1
  int v24; // [sp+1Ch] [bp-7Ch]@1
  int v25; // [sp+20h] [bp-78h]@5
  float v26; // [sp+24h] [bp-74h]@6
  float v27; // [sp+28h] [bp-70h]@9
  float v28; // [sp+2Ch] [bp-6Ch]@9
  float v29; // [sp+38h] [bp-60h]@10
  float v30; // [sp+3Ch] [bp-5Ch]@11
  float v31; // [sp+48h] [bp-50h]@13
  float v32; // [sp+4Ch] [bp-4Ch]@14
  float v33; // [sp+70h] [bp-28h]@16
  float v34; // [sp+74h] [bp-24h]@17

  v4 = a2;
  v5 = a1;
  *a3 = -1.0;
  v6 = *(_BYTE *)(a2 + 320);
  v7 = 0.0;
  v8 = 0;
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0;
  if ( !v6 || v6 == 1 && 0.0 == *(float *)a2 )
  {
    if ( a4 )
    {
      v18 = a4;
      do
      {
        if ( sub_10052C30(*v5) )
        {
          ++v8;
          if ( sub_100408A0((int)v5, *v5, &v22) )
          {
            ++v24;
            v23 = v23 + v22;
          }
        }
        ++v5;
        --v18;
      }
      while ( v18 );
      if ( v8 != v24 )
        goto LABEL_42;
    }
    *a3 = v23;
    if ( v8 <= 0 )
LABEL_42:
      result = 0;
    else
      result = 1;
    return result;
  }
  v9 = 0;
  if ( !a4 )
    goto LABEL_5;
  while ( 2 )
  {
    v28 = v7;
    v11 = v5[v9];
    v27 = v7;
    v12 = &v5[v9];
    switch ( v11 )
    {
      case 58:
      case 59:
        if ( !sub_10016380(6091, (int)&v29, 16) )
        {
          v13 = 8 * *v12 - 464;
          v28 = *(float *)((char *)&v29 + v13);
          v27 = *(float *)((char *)&v30 + v13);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2889;
        goto LABEL_19;
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
        if ( !sub_10016380(6090, (int)&v31, 40) )
        {
          v14 = 8 * *v12 - 480;
          v28 = *(float *)((char *)&v31 + v14);
          v27 = *(float *)((char *)&v32 + v14);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2921;
        goto LABEL_19;
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
        if ( sub_10016380(6092, (int)&v33, 40) )
        {
          v21 = 0.0;
          v20 = 0;
          v19 = 2953;
LABEL_19:
          sub_10015C20("..\\lib\\adl\\iop_eis_intf.c", v19, v20, (char *)LODWORD(v21));
        }
        else
        {
          v15 = 8 * *v12 - 520;
          v28 = *(float *)((char *)&v33 + v15);
          v27 = *(float *)((char *)&v34 + v15);
        }
LABEL_20:
        if ( sub_10052C30(*v12) )
        {
          ++v8;
          if ( sub_10040700(*v12, &v22) )
          {
            v16 = v22;
            if ( v27 >= (double)v22 )
              v16 = v27;
            v22 = v16;
            v17 = v22;
            if ( v28 <= (double)v22 )
              v17 = v28;
            ++v24;
            v22 = v17;
            v23 = v22 + v23;
          }
        }
        if ( ++v9 < a4 )
        {
          v7 = 0.0;
          continue;
        }
        v4 = a2;
LABEL_5:
        sub_1003F730(v4, (int)&v25, v23);
        if ( v8 != v24 || (*a3 = *(float *)&v25 * v23 + v26, v8 <= 0) )
LABEL_29:
          result = 0;
        else
          result = 1;
        return result;
      default:
        goto LABEL_29;
    }
  }
}

//----- (1003FC60) --------------------------------------------------------
char __cdecl sub_1003FC60(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_10016380(6266, (int)&v2, 324) )
  {
    sub_10015C20("..\\lib\\adl\\iop_eis_intf.c", 590, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1003F980((unsigned __int16 *)&unk_100B162C, (int)&v2, a1, 2u);
  }
  return result;
}

//----- (1003FCD0) --------------------------------------------------------
char __cdecl sub_1003FCD0(float *a1)
{
  return sub_1003F890(a1, 0x14u, 0);
}

//----- (1003FCF0) --------------------------------------------------------
char __cdecl sub_1003FCF0(float *a1)
{
  return sub_1003F890(a1, 0x2Du, 1u);
}

//----- (1003FD10) --------------------------------------------------------
char __cdecl sub_1003FD10(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_1003FCD0(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_1003FCF0(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else if ( v1 )
  {
    result = v1;
    *a1 = v4;
  }
  else
  {
    *a1 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (1003FDA0) --------------------------------------------------------
char __cdecl sub_1003FDA0(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_10016380(6265, (int)&v2, 324) )
  {
    sub_10015C20("..\\lib\\adl\\iop_eis_intf.c", 1606, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1003F980(L"<=>?@", (int)&v2, a1, 5u);
  }
  return result;
}
// 100B1638: using guessed type wchar_t a__[6];

//----- (1003FE10) --------------------------------------------------------
char __cdecl sub_1003FE10(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_10016380(6266, (int)&v8, 324) )
  {
    sub_10015C20("..\\lib\\adl\\iop_eis_intf.c", 1847, 0, "Center cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L":;<=>?@";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10052E30(v4, v5, &v6);
      if ( v1 )
        v1 = sub_1003F250(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000" )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_1003F980((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100B1644: using guessed type wchar_t a___0[8];

//----- (1003FEE0) --------------------------------------------------------
char __cdecl sub_1003FEE0(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_10016380(6265, (int)&v8, 324) )
  {
    sub_10015C20("..\\lib\\adl\\iop_eis_intf.c", 1946, 0, "Left cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10052E30(v4, v5, &v6);
      if ( v1 )
        v1 = sub_1003F250(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&a___0[7] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_1003F980((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100B1644: using guessed type wchar_t a___0[8];

//----- (1003FFB0) --------------------------------------------------------
char __cdecl sub_1003FFB0(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_10016380(6267, (int)&v8, 324) )
  {
    sub_10015C20("..\\lib\\adl\\iop_eis_intf.c", 2045, 0, "Right cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"ABCDE";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10052E30(v4, v5, &v6);
      if ( v1 )
        v1 = sub_1003F250(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&aAbcde_0[5] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_1003F980((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100B1654: using guessed type wchar_t aAbcde_0[6];

//----- (10040080) --------------------------------------------------------
char __cdecl sub_10040080(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_1003FE10(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_1003FEE0(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_1003FFB0(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10040120) --------------------------------------------------------
char __cdecl sub_10040120(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_10016380(6267, (int)&v2, 324) )
  {
    sub_10015C20("..\\lib\\adl\\iop_eis_intf.c", 2199, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1003F980(L"ABCDE", (int)&v2, a1, 5u);
  }
  return result;
}
// 100B1660: using guessed type wchar_t aAbcde[6];

//----- (10040190) --------------------------------------------------------
double sub_10040190()
{
  int v0; // eax@1
  double result; // st7@1
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  double v4; // [sp+8h] [bp-8h]@2

  v3 = 9.8999998e24;
  v0 = sub_100163E0(10009, &v2, 4, &v3);
  result = v2;
  if ( !v0 )
  {
    v4 = v2;
    v2 = v4 - sub_1003F650();
    if ( v2 >= 0.0 )
    {
      result = v2;
    }
    else
    {
      v2 = 0.0;
      result = (float)0.0;
    }
  }
  return result;
}

//----- (100401F0) --------------------------------------------------------
char __cdecl sub_100401F0(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_1003FDA0(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_1003FC60(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_10040120(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10040290) --------------------------------------------------------
bool __cdecl sub_10040290(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_10052E90(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_1003E5B0(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_1003F250(v5[0], v6, a2) && !sub_100527E0(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (10040310) --------------------------------------------------------
char __cdecl sub_10040310(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_10052E90(a1, 0, &v4, &v3) != 1 && sub_10052E90(a1, 1u, &v4, &v3) != 1
    || (result = sub_1003E940(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (10040380) --------------------------------------------------------
bool __cdecl sub_10040380(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_10052F20(v2) != 0;
  return sub_10040290(a1, a2, v3);
}

//----- (100403B0) --------------------------------------------------------
char __cdecl sub_100403B0(char a1, void *a2)
{
  void *v2; // esi@3
  char v3; // al@3

  if ( a1 )
  {
    if ( a1 != 1 )
      return 0;
    v2 = a2;
    v3 = sub_1003F250(1, 1105, a2);
  }
  else
  {
    v2 = a2;
    v3 = sub_1003F250(1, 1104, a2);
  }
  if ( v3 && !sub_10052290((int)v2) )
    return 1;
  return 0;
}

//----- (10040400) --------------------------------------------------------
char __thiscall sub_10040400(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10016420(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (10040420) --------------------------------------------------------
char sub_10040420()
{
  char result; // al@1

  byte_101B20A8 = 2;
  result = sub_10043480(4);
  if ( result )
  {
    byte_101B20A8 = 0;
  }
  else
  {
    result = sub_10043480(7);
    if ( result )
      byte_101B20A8 = 1;
  }
  return result;
}
// 101B20A8: using guessed type char byte_101B20A8;

//----- (10040460) --------------------------------------------------------
double __cdecl sub_10040460(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_10052F20(v1);
  if ( sub_10040400(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_10016420(2015, (int)&v5, 12);
      return v6;
    }
    sub_10016420(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_10016420(2015, (int)&v5, 12);
      return v6;
    }
    sub_10016420(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (100404E0) --------------------------------------------------------
void sub_100404E0()
{
  sub_10040460(0);
}

//----- (100404F0) --------------------------------------------------------
int __cdecl sub_100404F0(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (10040510) --------------------------------------------------------
char *__cdecl sub_10040510(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_100B2778;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_102D2B48[(unsigned __int16)sub_100404F0(a1)];
  return result;
}
// 1006CAE2: using guessed type int TXT_get_static_string(void);

//----- (10040550) --------------------------------------------------------
int __cdecl sub_10040550(void *a1)
{
  float v2; // [sp+0h] [bp-4h]@1

  v2 = 9.8999998e24;
  return sub_100163E0(2102, a1, 4, &v2);
}

//----- (10040580) --------------------------------------------------------
char __cdecl sub_10040580(char a1)
{
  return sub_10016510(2102, (int)&a1, 4);
}

//----- (100405A0) --------------------------------------------------------
char __thiscall sub_100405A0(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_10025BB0(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 10070D1E: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (100405D0) --------------------------------------------------------
int __thiscall sub_100405D0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10025BB0(46, (char *)&v2);
  return (int)v2;
}

//----- (100405F0) --------------------------------------------------------
bool __cdecl sub_100405F0(char a1)
{
  void *v1; // ecx@0
  bool result; // al@2
  void *v3; // ecx@4

  switch ( a1 )
  {
    case 5:
      result = sub_10053280(0) == 1;
      break;
    case 6:
      goto LABEL_3;
    case 9:
      if ( sub_100405D0(v1) & 3 || sub_10025D10(v3) == 1 )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 8:
      result = sub_10025D10(v1) != 1;
      break;
    default:
      result = sub_10025D10(v1) == 1;
      break;
  }
  return result;
}

//----- (10040660) --------------------------------------------------------
char __cdecl sub_10040660(float a1, int a2)
{
  double v2; // st7@1
  long double v3; // st7@1
  char result; // al@2
  float v5; // [sp+4h] [bp+4h]@1
  float v6; // [sp+4h] [bp+4h]@4
  float v7; // [sp+4h] [bp+4h]@5

  v2 = a1;
  v5 = a1 / 101325.0;
  v3 = v2 / 22631.953125;
  if ( v3 > 0.0 )
  {
    if ( v5 <= 0.223360002040863 )
    {
      v7 = log(v3);
      result = 1;
      *(float *)a2 = 11000.232421875 - v7 * 6341.615234375;
    }
    else
    {
      v6 = pow(v5, 0.1902630904662425);
      result = 1;
      *(float *)a2 = (v6 - 1.0) * -44330.76953125;
    }
  }
  else
  {
    *(float *)a2 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (10040700) --------------------------------------------------------
char __cdecl sub_10040700(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_10052E30(a1, v4, &v6) == 1 )
  {
    v2 = sub_1003E5B0(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_1003F250(v4[0], v6, &v5) && !sub_10052830((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10040820) --------------------------------------------------------
void sub_10040820()
{
  dword_101B20AC = -15;
}
// 101B20AC: using guessed type int dword_101B20AC;

//----- (10040830) --------------------------------------------------------
double __cdecl sub_10040830(float a1)
{
  int v1; // ecx@0
  double result; // st7@1
  float v3; // [sp+0h] [bp-4h]@1
  float v4; // [sp+8h] [bp+4h]@1
  float v5; // [sp+8h] [bp+4h]@3

  v4 = *(float *)v1 * a1 + *(float *)(v1 + 4);
  v3 = *(float *)(v1 + 8);
  result = v4;
  if ( v3 >= (double)v4 )
    result = v3;
  v5 = *(float *)(v1 + 12);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10040890) --------------------------------------------------------
signed int sub_10040890()
{
  return sub_100175B0((int)&off_100B35E8);
}
// 100B35E8: using guessed type char *off_100B35E8;

//----- (100408A0) --------------------------------------------------------
char __usercall sub_100408A0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3)
{
  char v3; // dl@39
  char result; // al@39
  float v5; // [sp+0h] [bp-280h]@11
  float v6[19]; // [sp+4h] [bp-27Ch]@11
  float v7; // [sp+50h] [bp-230h]@11
  float v8[76]; // [sp+54h] [bp-22Ch]@11
  int v9; // [sp+17Ch] [bp-104h]@29
  int v10; // [sp+180h] [bp-100h]@29
  float v11; // [sp+184h] [bp-FCh]@29
  char v12; // [sp+197h] [bp-E9h]@1
  float v13; // [sp+198h] [bp-E8h]@1
  float v14; // [sp+19Ch] [bp-E4h]@1
  float v15; // [sp+1A0h] [bp-E0h]@1
  float v16; // [sp+1A4h] [bp-DCh]@1
  float v17; // [sp+1A8h] [bp-D8h]@1
  float v18; // [sp+1ACh] [bp-D4h]@1
  float v19; // [sp+1B0h] [bp-D0h]@17
  float v20; // [sp+1B4h] [bp-CCh]@37
  float v21; // [sp+1B8h] [bp-C8h]@22
  float v22; // [sp+1BCh] [bp-C4h]@17
  int v23; // [sp+1C0h] [bp-C0h]@1
  int v24[3]; // [sp+1C4h] [bp-BCh]@1
  int v25; // [sp+1D0h] [bp-B0h]@1
  int v26[3]; // [sp+1D4h] [bp-ACh]@1
  int v27; // [sp+1E0h] [bp-A0h]@1
  int v28; // [sp+1E4h] [bp-9Ch]@1
  int v29; // [sp+208h] [bp-78h]@1
  int v30; // [sp+20Ch] [bp-74h]@1
  int v31; // [sp+230h] [bp-50h]@1
  int v32; // [sp+234h] [bp-4Ch]@1
  int v33; // [sp+258h] [bp-28h]@1
  int v34; // [sp+25Ch] [bp-24h]@1

  v12 = 0;
  v25 = 0;
  v26[0] = 0;
  v23 = 0;
  v24[0] = 0;
  v27 = 0;
  v28 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0;
  v30 = 0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  switch ( a2 )
  {
    case 0x3Au:
    case 0x3Bu:
      if ( sub_10016380(6091, (int)&v23, 16) )
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 192, 0, 0);
      if ( sub_10016380(6115, (int)&v25, 16) )
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 193, 0, 0);
      v16 = *((float *)&v23 + 2 * a1);
      v15 = *(float *)&v24[2 * a1];
      v13 = *((float *)&v25 + 2 * a1);
      v14 = *(float *)&v26[2 * a1];
      goto LABEL_37;
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x3Fu:
    case 0x40u:
      if ( sub_10016380(6090, (int)&v31, 40) )
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 205, 0, 0);
      if ( sub_10016380(6114, (int)&v27, 40) )
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 206, 0, 0);
      v16 = *(&v7 + 2 * a2);
      v15 = v8[2 * a2];
      v13 = *(&v5 + 2 * a2);
      v14 = v6[2 * a2];
      goto LABEL_37;
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
      if ( sub_10016380(6092, (int)&v29, 40) )
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 218, 0, 0);
      if ( sub_10016380(6116, (int)&v33, 40) )
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 219, 0, 0);
      v16 = *(&v5 + 2 * a2);
      v15 = v6[2 * a2];
      v13 = *(&v7 + 2 * a2);
      v14 = v8[2 * a2];
      goto LABEL_37;
    case 0x4Eu:
      v19 = 9.8999998e24;
      if ( sub_100163E0(6355, &v22, 4, &v19) )
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 228, 0, 0);
      sub_10016BE0(14, &v12);
      if ( v12 == 10 )
        v22 = v22 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v22;
      v13 = 1.0;
      goto LABEL_37;
    case 0x4Fu:
      v19 = 9.8999998e24;
      if ( sub_100163E0(6356, &v21, 4, &v19) )
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 250, 0, 0);
      sub_10016BE0(14, &v12);
      if ( v12 == 10 )
        v21 = v21 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v21;
      v13 = 1.0;
      goto LABEL_37;
    case 0x98u:
    case 0x99u:
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v13 = 1.0;
      v14 = 0.0;
      goto LABEL_37;
    case 0x67u:
      if ( !sub_10016380(6162, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 282;
      goto LABEL_36;
    case 0x68u:
    case 0xC0u:
      if ( !sub_10016380(6161, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 287;
      goto LABEL_36;
    case 0x69u:
      if ( !sub_10016380(6160, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 291;
      goto LABEL_36;
    case 0x70u:
      if ( sub_10016380(6235, (int)&v13, 24) )
      {
        v11 = 0.0;
        v10 = 0;
        v9 = 295;
LABEL_36:
        sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", v9, v10, (char *)LODWORD(v11));
      }
LABEL_37:
      if ( sub_10040700(a2, &v20) && (LODWORD(v20) & 0x7F800000) != 2139095040 )
      {
        *a3 = sub_10040830(v20);
        result = v3;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 100408A0: using guessed type int var_AC[3];
// 100408A0: using guessed type int var_BC[3];
// 100408A0: using guessed type float var_22C[76];
// 100408A0: using guessed type float var_27C[19];

//----- (10040DE0) --------------------------------------------------------
char __cdecl sub_10040DE0(unsigned __int8 a1, _DWORD *a2)
{
  char result; // al@3

  if ( a1 >= 4u )
  {
    sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 795, 0, 0);
    return 0;
  }
  if ( (unsigned __int8)sub_10040890() != 1 )
    return 0;
  if ( *(_DWORD *)(dword_101B20AC + 4 * a1 + 696) + 4000 <= (unsigned int)sub_100160A0() )
  {
    result = 0;
  }
  else
  {
    *a2 = *(_DWORD *)(dword_101B20AC + 4 * a1 + 228);
    result = 1;
  }
  return result;
}
// 101B20AC: using guessed type int dword_101B20AC;

//----- (10040E50) --------------------------------------------------------
char __cdecl sub_10040E50(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_100462B0() > 1u;
  v1 = 0;
  v12 = sub_100252F0(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_100B3BF0;
  if ( sub_10040310(0x2E6u) || sub_10040310(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_100B3BE8;
  v3 = 4;
  do
  {
    if ( sub_10040310(*v2) && sub_10040380(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_100B3BF8[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_100462E0() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_10025CF0(v4) == 2 || sub_10025CF0(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (10040F90) --------------------------------------------------------
char __cdecl sub_10040F90(unsigned __int16 a1, int a2, char a3)
{
  int v3; // ecx@0
  char result; // al@1
  int v5; // [sp-2h] [bp-4h]@1

  v5 = v3;
  result = 31;
  BYTE3(v5) = 31;
  switch ( a1 )
  {
    case 0x1Au:
      if ( a3 )
      {
        sub_10016BE0(44, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10025700((void *)a1);
      }
      break;
    case 0u:
    case 0x26u:
    case 0x2Bu:
      if ( a3 )
      {
        sub_10016BE0(77, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10025730((void *)a1);
      }
      break;
    case 0x30u:
    case 0x31u:
      result = 18;
      break;
    case 8u:
    case 9u:
      result = 32;
      break;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( a3 )
      {
        sub_10016BE0(17, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = 33;
      }
      break;
    case 4u:
    case 5u:
      result = sub_10025850();
      break;
    case 0x11u:
    case 0x12u:
    case 0x13u:
      if ( a3 )
      {
        sub_10016BE0(14, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10025A30(a1);
      }
      break;
    case 0x14u:
    case 0x15u:
      result = 39;
      break;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( a3 )
      {
        sub_10016BE0(45, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10025B10((void *)a1);
      }
      break;
    case 0x1Eu:
    case 0x1Fu:
      if ( a3 )
      {
        sub_10016BE0(15, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10025800(a1);
      }
      break;
    case 0x20u:
    case 0x21u:
      if ( a3 )
      {
        sub_10016BE0(16, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10025760(a1);
      }
      break;
    case 0x22u:
    case 0x23u:
      sub_10016BE0(67, (_BYTE *)&v5 + 3);
      result = BYTE3(v5);
      break;
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
      result = 0;
      break;
    case 6u:
    case 7u:
      result = 34;
      break;
    case 0x24u:
    case 0x25u:
      result = 41;
      break;
    case 0x29u:
      result = 23;
      break;
    case 1u:
    case 2u:
    case 3u:
    case 0x2Du:
    case 0x2Eu:
      result = 5;
      break;
    case 0x2Fu:
      result = 51;
      break;
    case 0x32u:
      if ( a3 )
      {
        sub_10016BE0(136, (_BYTE *)&v5 + 3);
        result = BYTE3(v5);
      }
      else
      {
        result = sub_10025B40(a1);
      }
      break;
    default:
      return result;
  }
  return result;
}

//----- (10041190) --------------------------------------------------------
char __cdecl sub_10041190(char a1)
{
  char result; // al@3

  if ( a1 == 1 )
  {
    result = 2;
  }
  else if ( a1 == 3 )
  {
    result = 3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100411B0) --------------------------------------------------------
char __cdecl sub_100411B0(unsigned int a1, float *a2)
{
  __int16 v2; // si@1
  int v3; // edx@1
  char v4; // al@1
  char v5; // cl@1
  char result; // al@3
  float *v7; // edi@37
  int v8; // esi@37
  char v9; // al@51

  v2 = a1;
  v3 = a1 & 0x3F;
  v4 = (a1 >> 12) & 1;
  v5 = 31;
  LOBYTE(a1) = 31;
  switch ( v3 )
  {
    case 0:
    case 1:
      if ( v4 )
      {
        sub_10016BE0(44, &a1);
        result = a1;
      }
      else
      {
        result = sub_10025700((void *)31);
      }
      break;
    case 2:
    case 27:
      if ( v4 )
      {
        sub_10016BE0(77, &a1);
        result = a1;
      }
      else
      {
        result = sub_10025730((void *)31);
      }
      break;
    case 3:
      result = sub_10025730((void *)31) != 30 ? 29 : 12;
      break;
    case 4:
      v5 = sub_10025730((void *)31);
      if ( v5 == 21 )
      {
        if ( !a2 || *a2 >= 1000.0 )
          goto LABEL_60;
        result = 29;
      }
      else
      {
        if ( !a2 || *a2 >= 185.2 )
          goto LABEL_60;
        result = 12;
      }
      break;
    case 5:
      result = 18;
      break;
    case 10:
      result = 32;
      break;
    case 11:
      result = sub_100259D0((void *)31);
      break;
    case 12:
      if ( v4 )
      {
        sub_10016BE0(17, &a1);
        result = a1;
      }
      else
      {
        result = 33;
      }
      break;
    case 13:
    case 14:
      result = sub_10025850();
      break;
    case 15:
      if ( v4 )
      {
        sub_10016BE0(49, &a1);
        result = a1;
      }
      else
      {
        result = sub_10025A00((void *)31);
      }
      break;
    case 16:
    case 17:
      if ( v4 )
      {
        sub_10016BE0(14, &a1);
        result = a1;
      }
      else
      {
        result = sub_10025A30(31);
      }
      break;
    case 18:
      result = 49;
      break;
    case 19:
      result = 39;
      break;
    case 20:
      if ( v4 )
      {
        sub_10016BE0(45, &a1);
        result = a1;
      }
      else
      {
        result = sub_10025B10((void *)31);
      }
      break;
    case 21:
      if ( v4 )
      {
        sub_10016BE0(15, &a1);
        result = a1;
      }
      else
      {
        result = sub_10025800(31);
      }
      break;
    case 36:
      v7 = a2;
      v8 = v2 & 0x1000;
      switch ( (unsigned __int8)sub_100411B0(v8 | 0x15, a2) )
      {
        case 0xDu:
          result = (unsigned __int8)sub_100411B0(v8 | 2, v7) != 21 ? 45 : 57;
          break;
        case 0x18u:
          result = (unsigned __int8)sub_100411B0(v8 | 2, v7) != 21 ? 54 : 59;
          break;
        case 0x10u:
          result = (unsigned __int8)sub_100411B0(v8 | 2, v7) != 21 ? 53 : 58;
          break;
        case 0x13u:
          result = (unsigned __int8)sub_100411B0(v8 | 2, v7) != 21 ? 55 : 60;
          break;
        default:
          result = 4 * ((unsigned __int8)sub_100411B0(v8 | 2, v7) == 21) + 52;
          break;
      }
      break;
    case 22:
      if ( v4 )
      {
        sub_10016BE0(16, &a1);
        result = a1;
      }
      else
      {
        result = sub_10025760(31);
      }
      break;
    case 23:
      result = 50;
      break;
    case 24:
      result = 0;
      break;
    case 25:
      result = 34;
      break;
    case 26:
      result = 1;
      break;
    case 38:
    case 39:
    case 42:
    case 43:
      result = 5;
      break;
    case 40:
    case 41:
      v9 = sub_10083A30();
      result = sub_10041190(v9);
      break;
    case 29:
      result = 41;
      break;
    case 30:
      result = 42;
      break;
    case 31:
      result = 43;
      break;
    case 32:
      result = sub_10025B40(31);
      break;
    case 33:
      result = 46;
      break;
    case 34:
      result = 47;
      break;
    case 35:
      result = 48;
      break;
    case 37:
      v5 = (sub_10025B40(31) != 19) + 61;
      goto LABEL_60;
    default:
LABEL_60:
      result = v5;
      break;
  }
  return result;
}

//----- (100415D0) --------------------------------------------------------
double __cdecl sub_100415D0(int a1, unsigned __int16 a2, char a3, char *a4)
{
  unsigned __int16 v4; // si@1
  char v5; // al@1
  double v6; // st7@3
  double result; // st7@16
  int v8; // eax@22
  int v9; // eax@23
  int v10; // eax@29
  int v11; // eax@30
  int v12; // eax@39
  int v13; // eax@40
  int v14; // eax@46
  int v15; // eax@47
  float v16; // [sp+4h] [bp-4h]@1

  v16 = 1.0;
  v4 = a2;
  v5 = sub_10040F90(a2, 0, a3);
  *a4 = v5;
  switch ( v4 )
  {
    case 0u:
    case 0x1Au:
    case 0x26u:
    case 0x2Bu:
    case 0x30u:
    case 0x31u:
      switch ( v5 )
      {
        case 0x12:
          v6 = 39.370079;
          goto LABEL_64;
        case 0xC:
          v6 = 3.2808399;
          goto LABEL_64;
        case 0x1E:
          v6 = 0.00053995679;
          goto LABEL_64;
        case 0x15:
          goto LABEL_63;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 8u:
    case 9u:
      v6 = 100.0;
      goto LABEL_64;
    case 0xEu:
    case 0xFu:
    case 0x10u:
      if ( v5 == 40 )
        v6 = 0.0000099999997;
      else
        v6 = 0.0001450377;
      goto LABEL_64;
    case 4u:
    case 5u:
      v6 = 0.00029530001;
      goto LABEL_64;
    case 0x1Bu:
    case 0x1Cu:
    case 0x1Du:
      if ( v5 == 28 )
        v6 = 60.0;
      else
        v6 = 196.85039;
      goto LABEL_64;
    case 0x11u:
    case 0x12u:
      if ( v5 != 10 || *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      sub_100534D0((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x13u:
      if ( v5 != 10 )
        goto LABEL_65;
      v6 = 1.8;
      goto LABEL_64;
    case 0x1Eu:
    case 0x1Fu:
      switch ( v5 )
      {
        case 0xD:
          v6 = 0.26417205;
          goto LABEL_64;
        case 0x10:
          v6 = 0.21997361;
          goto LABEL_64;
        case 0x13:
          v8 = (unsigned __int8)sub_100257D0((void *)v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
                v6 = 0.77890778;
              else
                v6 = 0.84999973;
            }
            else
            {
              v6 = 0.80407244;
            }
          }
          else
          {
            v6 = 0.71895844;
          }
          goto LABEL_64;
        case 0x18:
          v10 = (unsigned __int8)sub_100257D0((void *)v4);
          if ( (_BYTE)v10 )
          {
            v11 = v10 - 1;
            if ( v11 )
            {
              if ( v11 == 1 )
                v6 = 1.7171981;
              else
                v6 = 1.8756201;
            }
            else
            {
              v6 = 1.7726756;
            }
          }
          else
          {
            v6 = 1.5850322;
          }
          goto LABEL_64;
        default:
          goto LABEL_67;
      }
      goto LABEL_67;
    case 0x20u:
    case 0x21u:
      switch ( v5 )
      {
        case 0xE:
          v6 = 951.01935;
          break;
        case 0x11:
          v6 = 791.90497;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_100257D0((void *)v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
                v6 = 2804.0679;
              else
                v6 = 3059.999;
            }
            else
            {
              v6 = 2894.6609;
            }
          }
          else
          {
            v6 = 2588.2505;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_100257D0((void *)v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
                v6 = 6181.9131;
              else
                v6 = 6752.2324;
            }
            else
            {
              v6 = 6381.6323;
            }
          }
          else
          {
            v6 = 5706.1162;
          }
          break;
        default:
          v6 = 3600.0;
          break;
      }
      goto LABEL_64;
    case 0x22u:
    case 0x23u:
      if ( v5 == 45 )
        v6 = 0.0020439588;
      else
        v6 = 0.0023521457;
      goto LABEL_64;
    case 0x28u:
      v6 = 0.73756248;
      goto LABEL_64;
    case 0x29u:
      v6 = 1.9438444;
      goto LABEL_64;
    case 0x2Du:
    case 0x2Eu:
      v6 = 57.29578;
      goto LABEL_64;
    case 0x2Fu:
      v6 = 61.023743;
      goto LABEL_64;
    case 0x32u:
      if ( v5 == 19 )
LABEL_63:
        v6 = 0.001;
      else
        v6 = 0.0022046;
LABEL_64:
      v16 = v6;
LABEL_65:
      if ( *(float *)&a1 == 9.8999998e24 )
        goto LABEL_67;
      *(float *)&a1 = *(float *)&a1 * v16;
      result = *(float *)&a1;
      break;
    default:
LABEL_67:
      result = *(float *)&a1;
      break;
  }
  return result;
}

//----- (100419A0) --------------------------------------------------------
double __cdecl sub_100419A0(int a1, unsigned int a2)
{
  __int16 v2; // si@1
  char v3; // al@1
  void *v4; // ecx@1
  double result; // st7@3
  int v6; // eax@26
  int v7; // eax@27
  int v8; // eax@33
  int v9; // eax@34
  double v10; // st7@42
  float v11; // ST0C_4@44
  int v12; // eax@48
  int v13; // eax@49
  int v14; // eax@55
  int v15; // eax@56
  float v16; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v16 = 1.0;
  v3 = sub_100411B0(a2, (float *)&a1);
  v4 = (void *)(v2 & 0x3F);
  switch ( v4 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 0x1Bu:
      switch ( v3 )
      {
        case 0xC:
          *(float *)&a1 = (float)3.2808399 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)0.00053995679 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)39.370079 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_67;
        default:
          goto LABEL_69;
      }
      goto LABEL_69;
    case 0xAu:
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v3 != 15 )
        goto LABEL_8;
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_8:
      *(float *)&a1 = (float)0.00029530001 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v3 == 40 )
      {
        *(float *)&a1 = (float)0.0000099999997 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0001450377 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v3 == 22 )
      {
        *(float *)&a1 = (float)3.5999999 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)1.9438444 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v3 == 28 )
      {
        *(float *)&a1 = (float)60.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)196.85039 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v3 != 10 )
        goto LABEL_69;
      sub_100534D0((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v3 != 10 )
        goto LABEL_68;
      *(float *)&a1 = (float)1.8 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v3 )
      {
        case 0xD:
          *(float *)&a1 = (float)0.26417205 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)0.21997361 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v6 = (unsigned __int8)sub_100257D0(v4);
          if ( (_BYTE)v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                *(float *)&a1 = (float)0.77890778 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.84999973 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.80407244 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.71895844 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v8 = (unsigned __int8)sub_100257D0(v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
              {
                *(float *)&a1 = (float)1.7171981 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.8756201 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.7726756 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.5850322 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_69;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v3 < 0x38u || (unsigned __int8)v3 > 0x3Cu )
        v10 = 0.00053995679;
      else
        v10 = 0.001;
      v11 = v10;
      *(float *)&a1 = v11 * *(float *)&a1;
      *(float *)&a1 = sub_10041FD0(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v3 )
      {
        case 0xE:
          *(float *)&a1 = (float)951.01935 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)791.90497 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_100257D0(v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
              {
                *(float *)&a1 = (float)2804.0679 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)3059.999 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)2894.6609 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)2588.2505 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_100257D0(v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
              {
                *(float *)&a1 = (float)6181.9131 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)6752.2324 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)6381.6323 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)5706.1162 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)3600.0 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v3 == 19 )
        goto LABEL_67;
      *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v3 == 61 )
      {
LABEL_67:
        v16 = 0.001;
LABEL_68:
        *(float *)&a1 = v16 * *(float *)&a1;
LABEL_69:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_69;
  }
}

//----- (10041FD0) --------------------------------------------------------
double __cdecl sub_10041FD0(int a1, unsigned int a2)
{
  __int16 v2; // di@1
  int v3; // esi@1
  void *v4; // ecx@1
  char v5; // bl@1
  double result; // st7@5
  int v7; // eax@28
  int v8; // eax@29
  int v9; // eax@35
  int v10; // eax@36
  double v11; // st7@44
  float v12; // ST1C_4@46
  int v13; // eax@50
  int v14; // eax@51
  int v15; // eax@57
  int v16; // eax@58
  float v17; // [sp+14h] [bp-4h]@1

  v17 = 1.0;
  v2 = a2;
  v3 = a2 & 0x3F;
  v5 = sub_100411B0(a2, 0);
  if ( v3 == 4 )
    sub_10015C20("..\\lib\\adl\\cdp_cnvt.c", 1174, 1, 0);
  switch ( v3 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 27:
      switch ( v5 )
      {
        case 0xC:
          *(float *)&a1 = (float)0.3048 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)1852.0 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)0.0254 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_69;
        default:
          goto LABEL_71;
      }
      goto LABEL_71;
    case 10:
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 11:
      if ( v5 != 15 )
        goto LABEL_10;
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 13:
    case 14:
LABEL_10:
      *(float *)&a1 = (float)3386.3867 * *(float *)&a1;
      return *(float *)&a1;
    case 12:
      if ( v5 == 40 )
      {
        *(float *)&a1 = (float)100000.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)6894.7593 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 15:
      if ( v5 == 22 )
      {
        *(float *)&a1 = (float)0.27777779 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.51444447 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 20:
      if ( v5 == 11 )
      {
        *(float *)&a1 = (float)0.00508 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.016666668 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 16:
      if ( v5 != 10 )
        goto LABEL_71;
      sub_100534F0((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 17:
      if ( v5 != 10 )
        goto LABEL_70;
      *(float *)&a1 = (float)0.55555558 * *(float *)&a1;
      return *(float *)&a1;
    case 21:
      switch ( v5 )
      {
        case 0xD:
          *(float *)&a1 = (float)3.7854118 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)4.546 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v7 = (unsigned __int8)sub_100257D0(v4);
          if ( (_BYTE)v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              if ( v8 == 1 )
              {
                *(float *)&a1 = (float)1.283849 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.176471 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.243669 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.390901 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v9 = (unsigned __int8)sub_100257D0(v4);
          if ( (_BYTE)v9 )
          {
            v10 = v9 - 1;
            if ( v10 )
            {
              if ( v10 == 1 )
              {
                *(float *)&a1 = (float)0.582344 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.53315699 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.56411898 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.63090199 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_71;
      }
      return result;
    case 36:
      if ( (unsigned __int8)v5 < 0x38u || (unsigned __int8)v5 > 0x3Cu )
        v11 = 1852.0;
      else
        v11 = 1000.0;
      v12 = v11;
      *(float *)&a1 = v12 * *(float *)&a1;
      *(float *)&a1 = sub_100419A0(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 22:
      switch ( v5 )
      {
        case 0xE:
          *(float *)&a1 = (float)0.0010515032 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)0.0012627778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v13 = (unsigned __int8)sub_100257D0(v4);
          if ( (_BYTE)v13 )
          {
            v14 = v13 - 1;
            if ( v14 )
            {
              if ( v14 == 1 )
              {
                *(float *)&a1 = (float)0.00035662472 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00032679751 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00034546363 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00038636138 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v15 = (unsigned __int8)sub_100257D0(v4);
          if ( (_BYTE)v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              if ( v16 == 1 )
              {
                *(float *)&a1 = (float)0.00016176222 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00014809916 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00015669972 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00017525055 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)0.00027777778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 32:
      if ( v5 == 19 )
        goto LABEL_69;
      *(float *)&a1 = (float)453.59241 * *(float *)&a1;
      return *(float *)&a1;
    case 37:
      if ( v5 == 61 )
      {
LABEL_69:
        v17 = 1000.0;
LABEL_70:
        *(float *)&a1 = v17 * *(float *)&a1;
LABEL_71:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)453.59241 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_71;
  }
}

//----- (100426C0) --------------------------------------------------------
char __cdecl sub_100426C0(int a1, unsigned __int8 a2, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // eax@1
  int v5; // ecx@1
  float *v6; // edx@3
  char result; // al@7
  char v8; // [sp+7h] [bp-5h]@1
  float v9; // [sp+8h] [bp-4h]@1
  char v10; // [sp+14h] [bp+8h]@2

  v9 = -9.8999998e24;
  v3 = a2;
  v4 = a2;
  v5 = a2 + a3;
  v8 = 0;
  if ( a2 >= v5 )
  {
    result = 0;
  }
  else
  {
    v10 = 0;
    do
    {
      v6 = (float *)(a1 + 12 * v4 + 8);
      if ( 9.8999998e24 != *v6 && v9 + 0.05000000074505806 < *v6 )
      {
        v9 = *v6;
        v8 = v10;
      }
      ++v10;
      v4 = ++v3;
    }
    while ( v3 < v5 );
    result = v8;
  }
  return result;
}

//----- (10042760) --------------------------------------------------------
char __cdecl sub_10042760(int a1, void *a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // ecx@1
  int v5; // edi@1
  char result; // al@5
  int v7; // eax@7
  int v8; // ebp@7
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@1
  float v11; // [sp+10h] [bp-8h]@1

  v11 = 9.8999998e24;
  *(float *)a2 = 9.8999998e24;
  LOBYTE(v9) = 0;
  v10 = 0;
  v2 = sub_10053AA0(a1);
  v3 = sub_10053A20(a1);
  v5 = v3;
  if ( !v2 )
    goto LABEL_15;
  if ( !v3 )
    return sub_10053910(a1, a2);
  if ( *(_WORD *)(v2 + 12) != 6 )
    goto LABEL_15;
  if ( sub_10025CF0(v4) == 4 )
  {
    *(float *)a2 = *(float *)(v2 + 8);
    return 1;
  }
  if ( (unsigned __int8)(*(_BYTE *)(v5 + 2) - 1) <= 2u )
  {
    v7 = sub_10053970(&v9, (void *)(v5 + 4), 0xCu, 27, 100);
    *(float *)a2 = v11;
    v8 = v7;
    result = sub_100160A0() - v10 < (unsigned int)(unsigned __int16)word_100B48D0[*(_BYTE *)(v5 + 3)] ? v9 : 0;
    if ( v8 >= 0 )
    {
      if ( result )
        result = sub_10053510(v2, (float *)a2);
    }
    else
    {
      sub_10015C20("..\\lib\\acl\\dat\\dat_proc_float.c", 174, 0, 0);
      result = 0;
    }
  }
  else
  {
LABEL_15:
    result = 0;
  }
  return result;
}
// 100B48D0: using guessed type __int16 word_100B48D0[];

//----- (100428C0) --------------------------------------------------------
void *__usercall sub_100428C0@<eax>(int a1@<eax>, unsigned __int16 a2@<di>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-8h]@0
  int v5; // [sp+4h] [bp-4h]@0

  result = (void *)sub_10016380(a1, v4, v5);
  if ( result )
    result = memset(a3, 204, a2);
  return result;
}

//----- (100428F0) --------------------------------------------------------
void *sub_100428F0()
{
  void *result; // eax@1

  dword_102D2B44 = 0;
  sub_100428C0(40200, 0x6D8u, &unk_101B20B0);
  sub_100428C0(40201, 0x6D8u, &unk_101B2788);
  sub_100428C0(40202, 0x6D8u, &unk_101B2E60);
  sub_100428C0(40203, 0x6D8u, &unk_101B3538);
  sub_100428C0(40204, 0x6D8u, &unk_101B3C10);
  sub_100428C0(40205, 0x6D8u, &unk_101B42E8);
  sub_100428C0(40206, 0x6D8u, &unk_101B49C0);
  sub_100428C0(40207, 0x6D8u, &unk_101B5098);
  sub_100428C0(40208, 0x6D8u, &unk_101B5770);
  sub_100428C0(40209, 0x6D8u, &unk_101B5E48);
  sub_100428C0(40210, 0x6D8u, &unk_101B6520);
  sub_100428C0(40211, 0x6D8u, &unk_101B6BF8);
  sub_100428C0(40212, 0x6D8u, &unk_101B72D0);
  sub_100428C0(40213, 0x6D8u, &unk_101B79A8);
  sub_100428C0(40214, 0x6D8u, &unk_101B8080);
  sub_100428C0(40215, 0x6D8u, &unk_101B8758);
  sub_100428C0(40216, 0x6D8u, &unk_101B8E30);
  sub_100428C0(40217, 0x6D8u, &unk_101B9508);
  sub_100428C0(40218, 0x6D8u, &unk_101B9BE0);
  sub_100428C0(40219, 0x6D8u, &unk_101BA2B8);
  sub_100428C0(40220, 0x6D8u, &unk_101BA990);
  sub_100428C0(40221, 0x6D8u, &unk_101BB068);
  sub_100428C0(40222, 0x6D8u, &unk_101BB740);
  sub_100428C0(40223, 0x6D8u, &unk_101BBE18);
  sub_100428C0(40224, 0x6D8u, &unk_101BC4F0);
  sub_100428C0(40225, 0x6D8u, &unk_101BCBC8);
  sub_100428C0(40226, 0x6D8u, &unk_101BD2A0);
  sub_100428C0(40227, 0x6D8u, &unk_101BD978);
  sub_100428C0(40228, 0x6D8u, &unk_101BE050);
  sub_100428C0(40229, 0x6D8u, &unk_101BE728);
  sub_100428C0(40230, 0x6D8u, &unk_101BEE00);
  sub_100428C0(40231, 0x6D8u, &unk_101BF4D8);
  sub_100428C0(40232, 0x6D8u, &unk_101BFBB0);
  sub_100428C0(40233, 0x6D8u, &unk_101C0288);
  sub_100428C0(40234, 0x6D8u, &unk_101C0960);
  sub_100428C0(40235, 0x6D8u, &unk_101C1038);
  sub_100428C0(40236, 0x6D8u, &unk_101C1710);
  sub_100428C0(40237, 0x6D8u, &unk_101C1DE8);
  sub_100428C0(40238, 0x6D8u, &unk_101C24C0);
  sub_100428C0(40239, 0x6D8u, &unk_101C2B98);
  sub_100428C0(40240, 0x6D8u, &unk_101C3270);
  sub_100428C0(40241, 0x6D8u, &unk_101C3948);
  sub_100428C0(40242, 0x6D8u, &unk_101C4020);
  sub_100428C0(40243, 0x6D8u, &unk_101C46F8);
  sub_100428C0(40244, 0x6D8u, &unk_101C4DD0);
  sub_100428C0(40245, 0x6D8u, &unk_101C54A8);
  sub_100428C0(40246, 0x6D8u, &unk_101C5B80);
  sub_100428C0(40247, 0x6D8u, &unk_101C6258);
  sub_100428C0(40248, 0x6D8u, &unk_101C6930);
  sub_100428C0(40249, 0x6D8u, &unk_101C7008);
  sub_100428C0(40250, 0x6D8u, &unk_101C76E0);
  sub_100428C0(40251, 0x6D8u, &unk_101C7DB8);
  sub_100428C0(40252, 0x6D8u, &unk_101C8490);
  sub_100428C0(40253, 0x6D8u, &unk_101C8B68);
  sub_100428C0(40254, 0x6D8u, &unk_101C9240);
  sub_100428C0(40255, 0x6D8u, &unk_101C9918);
  sub_100428C0(40256, 0x6D8u, &unk_101C9FF0);
  sub_100428C0(40257, 0x6D8u, &unk_101CA6C8);
  sub_100428C0(40258, 0x6D8u, &unk_101CADA0);
  sub_100428C0(40259, 0x6D8u, &unk_101CB478);
  sub_100428C0(40260, 0x6D8u, &unk_101CBB50);
  sub_100428C0(40261, 0x6D8u, &unk_101CC228);
  sub_100428C0(40262, 0x6D8u, &unk_101CC900);
  sub_100428C0(40263, 0x6D8u, &unk_101CCFD8);
  sub_100428C0(40264, 0x6D8u, &unk_101CD6B0);
  sub_100428C0(40265, 0x6D8u, &unk_101CDD88);
  sub_100428C0(40266, 0x6D8u, &unk_101CE460);
  sub_100428C0(40267, 0x6D8u, &unk_101CEB38);
  sub_100428C0(40268, 0x6D8u, &unk_101CF210);
  sub_100428C0(40269, 0x6D8u, &unk_101CF8E8);
  sub_100428C0(40270, 0x6D8u, &unk_101CFFC0);
  sub_100428C0(40271, 0x6D8u, &unk_101D0698);
  sub_100428C0(40272, 0x6D8u, &unk_101D0D70);
  sub_100428C0(40273, 0x6D8u, &unk_101D1448);
  sub_100428C0(40274, 0x6D8u, &unk_101D1B20);
  sub_100428C0(40275, 0x6D8u, &unk_101D21F8);
  sub_100428C0(40276, 0x6D8u, &unk_101D28D0);
  sub_100428C0(40277, 0x6D8u, &unk_101D2FA8);
  sub_100428C0(40278, 0x6D8u, &unk_101D3680);
  sub_100428C0(40279, 0x6D8u, &unk_101D3D58);
  sub_100428C0(40280, 0x6D8u, &unk_101D4430);
  sub_100428C0(40281, 0x6D8u, &unk_101D4B08);
  sub_100428C0(40282, 0x6D8u, &unk_101D51E0);
  sub_100428C0(40283, 0x6D8u, &unk_101D58B8);
  sub_100428C0(40284, 0x6D8u, &unk_101D5F90);
  sub_100428C0(40285, 0x6D8u, &unk_101D6668);
  sub_100428C0(40286, 0x6D8u, &unk_101D6D40);
  sub_100428C0(40287, 0x6D8u, &unk_101D7418);
  sub_100428C0(40288, 0x6D8u, &unk_101D7AF0);
  sub_100428C0(40289, 0x6D8u, &unk_101D81C8);
  sub_100428C0(40290, 0x6D8u, &unk_101D88A0);
  sub_100428C0(40291, 0x6D8u, &unk_101D8F78);
  sub_100428C0(40292, 0x6D8u, &unk_101D9650);
  sub_100428C0(40293, 0x6D8u, &unk_101D9D28);
  sub_100428C0(40294, 0x6D8u, &unk_101DA400);
  sub_100428C0(40295, 0x6D8u, &unk_101DAAD8);
  sub_100428C0(40296, 0x6D8u, &unk_101DB1B0);
  sub_100428C0(40297, 0x6D8u, &unk_101DB888);
  sub_100428C0(40298, 0x6D8u, &unk_101DBF60);
  sub_100428C0(40299, 0x6D8u, &unk_101DC638);
  result = sub_100428C0(40300, 0x1774u, &unk_101DCD10);
  dword_102D2B44 = (int)&unk_101B20B0;
  return result;
}
// 102D2B44: using guessed type int dword_102D2B44;

//----- (10042F00) --------------------------------------------------------
bool sub_10042F00()
{
  void *v0; // ecx@2
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v2 = 0;
  sub_100163E0(9373, &v3, 4, &v2);
  return v3 && !(unsigned __int8)sub_10025D50() && sub_10025CF0(v0) != 4;
}

//----- (10042F50) --------------------------------------------------------
char __cdecl sub_10042F50(char a1)
{
  void *v1; // ecx@0
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_100163A0(6470, (int)&a1, 1);
      result = a1 && sub_10053AF0(2u);
    }
    else if ( a1 == 2 )
    {
      result = sub_10043480(14);
    }
    else
    {
      sub_10015C20("..\\lib\\adl\\iop_dl_wx_intf_a.c", 475, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = (sub_10025CD0(v1) & 0x800) == 2048;
  }
  return result;
}

//----- (10042FD0) --------------------------------------------------------
BOOL sub_10042FD0()
{
  return sub_10042F50(0) || sub_10042F50(1) || sub_10042F50(2);
}

//----- (10043010) --------------------------------------------------------
char __cdecl sub_10043010(unsigned __int8 a1)
{
  unsigned __int8 v1; // bl@1
  char result; // al@10
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@4

  v1 = 0;
  LOBYTE(v3) = 0;
  if ( (unsigned __int8)sub_10042FD0() )
  {
    if ( sub_10016380(dword_100B5770[a1], (int)&v3, 1) || !sub_10042F50(v3) )
    {
      LOBYTE(v3) = 0;
      LOBYTE(v4) = 0;
      while ( !sub_10042F50(v4) )
      {
        LOBYTE(v4) = ++v1;
        if ( v1 > 3u )
          goto LABEL_9;
      }
      LOBYTE(v3) = v1;
LABEL_9:
      sub_10016450(dword_100B5770[a1], (int)&v3, 1);
    }
    result = v3;
  }
  else
  {
    result = v3;
  }
  return result;
}
// 100B5770: using guessed type int dword_100B5770[];

//----- (100430B0) --------------------------------------------------------
int __cdecl sub_100430B0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (10043240) --------------------------------------------------------
char __thiscall sub_10043240(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_101DE488 = sub_10025CF0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_101DE490, 0, 0x1540u);
  memset(&unk_101DF9D0, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_101DE490;
  do
  {
    sub_100530E0(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_101DF9D0 );
  v3 = 0;
  v4 = &unk_101DF9D0;
  do
  {
    result = sub_10053160(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&unk_101E1380 );
  return result;
}
// 101DE488: using guessed type int dword_101DE488;

//----- (100432D0) --------------------------------------------------------
char __cdecl sub_100432D0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_101DE488 != 1379255385;
  v7 = 0;
  v8 = dword_101DE488 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10016320(86, 10);
      memset((char *)&unk_101DE490 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_100530E0(a1, (int)&unk_101DE490 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_101DE768[v6] == a2 || byte_101DE769[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_100162F0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101DE488: using guessed type int dword_101DE488;

//----- (10043390) --------------------------------------------------------
char __cdecl sub_10043390(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_101DE488 != 1379255385;
  v7 = 0;
  v8 = dword_101DE488 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10016320(86, 10);
      memset((char *)&unk_101DE490 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_100530E0(a1, (int)&unk_101DE490 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_101DE788[v6] == a2 || byte_101DE789[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_100162F0(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101DE488: using guessed type int dword_101DE488;

//----- (10043450) --------------------------------------------------------
char __cdecl sub_10043450(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_100432D0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10043480) --------------------------------------------------------
char __cdecl sub_10043480(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10043390(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (100434B0) --------------------------------------------------------
BOOL __fastcall sub_100434B0(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_10053DA0(6, 1, 27, 0, (int)&v2, 4) && v2 & 1;
}

//----- (100434E0) --------------------------------------------------------
bool __thiscall sub_100434E0(void *this)
{
  int v1; // ecx@1
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  BYTE2(v3) = 0;
  sub_100163E0(6791, (char *)&v3 + 3, 1, (char *)&v3 + 2);
  return BYTE3(v3) && (unsigned __int8)sub_100434B0(v1);
}

//----- (10043520) --------------------------------------------------------
char __thiscall sub_10043520(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_101E1A20 = sub_10025CF0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_101E1A28, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_101E1A28;
  do
  {
    result = sub_100530E0(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 101E1A20: using guessed type int dword_101E1A20;

//----- (10043590) --------------------------------------------------------
char __usercall sub_10043590@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_1003F220(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_1003F220(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (100435D0) --------------------------------------------------------
void *__usercall sub_100435D0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_101E1A20 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10016320(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_101E1A28 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_100530E0(a1, (int)&unk_101E1A28 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy_0(
               a4,
               (char *)&unk_101E1A28 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2,
               (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_101E1A20 != 1379255385 )
    result = (void *)sub_100162F0(v4, 86);
  return result;
}
// 101E1A20: using guessed type int dword_101E1A20;

//----- (10043670) --------------------------------------------------------
char __cdecl sub_10043670(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10043590(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (100436B0) --------------------------------------------------------
bool __cdecl sub_100436B0(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_100435D0(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10043710) --------------------------------------------------------
char __cdecl sub_10043710(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10043590(a2, 1, a3, a1);
  return result;
}

//----- (10043750) --------------------------------------------------------
char __cdecl sub_10043750(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_100435D0(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10043780) --------------------------------------------------------
char __cdecl sub_10043780(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10043590(a2 + 10, 1, a3, a1);
  return result;
}

//----- (100437C0) --------------------------------------------------------
char __cdecl sub_100437C0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_100435D0(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10043800) --------------------------------------------------------
char __cdecl sub_10043800(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10043590(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10043840) --------------------------------------------------------
bool __cdecl sub_10043840(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_100435D0(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10043890) --------------------------------------------------------
char __cdecl sub_10043890(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10043590(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (100438D0) --------------------------------------------------------
bool __cdecl sub_100438D0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_100435D0(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10043910) --------------------------------------------------------
char __cdecl sub_10043910(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10043590(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10043950) --------------------------------------------------------
bool __cdecl sub_10043950(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_100435D0(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10043990) --------------------------------------------------------
char __cdecl sub_10043990(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10043590(1229, 1, a2, a1);
  return result;
}

//----- (100439C0) --------------------------------------------------------
char __cdecl sub_100439C0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100435D0(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (100439F0) --------------------------------------------------------
char __cdecl sub_100439F0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10043590(1212, 16, a2, a1);
  return result;
}

//----- (10043A20) --------------------------------------------------------
char __cdecl sub_10043A20(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100435D0(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10043A50) --------------------------------------------------------
char __cdecl sub_10043A50(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10043590(2400, 65, a2, a1);
  return result;
}

//----- (10043A80) --------------------------------------------------------
char __cdecl sub_10043A80(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100435D0(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10043AB0) --------------------------------------------------------
char __cdecl sub_10043AB0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10043590(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10043AF0) --------------------------------------------------------
char __cdecl sub_10043AF0(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10015C20("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_100435D0(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10043B40) --------------------------------------------------------
char __cdecl sub_10043B40(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10043590(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10043B80) --------------------------------------------------------
char __cdecl sub_10043B80(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_100435D0(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (10043BB0) --------------------------------------------------------
char __cdecl sub_10043BB0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10043590(22, 1, a2, a1);
  return result;
}

//----- (10043BE0) --------------------------------------------------------
char __cdecl sub_10043BE0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10043590(832, 4, a2, a1);
  return result;
}

//----- (10043C10) --------------------------------------------------------
char __cdecl sub_10043C10(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100435D0(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10043C40) --------------------------------------------------------
char __cdecl sub_10043C40(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10053E10(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10043AF0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10043AB0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10043B80(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10043B40(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_100436B0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10043670(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_100438D0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10043890(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10043950(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10043910(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10043750(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10043710(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_100437C0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10043780(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_10043BB0(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10043A20(v6, a5);
        else
          result = sub_100439F0(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10043840(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10043800(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10043A80(v6, a5);
        else
          result = sub_10043A50(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_100439C0(v6, a5);
        else
          result = sub_10043990(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10043C10(v6, a5);
        else
          result = sub_10043BE0(v6, a5);
        break;
      default:
        sub_10015C20("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10016C70: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10043FE0) --------------------------------------------------------
bool __cdecl sub_10043FE0(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_101E2F68 != 1379255385 )
    {
      sub_100530C0(a1, (int)&byte_101E2F70[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_101E2F75[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_101E2F74[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 101E2F68: using guessed type int dword_101E2F68;

//----- (10044050) --------------------------------------------------------
bool __cdecl sub_10044050(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_101E2F68 != 1379255385 )
      sub_100530C0(a1, (int)&byte_101E2F70[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_101E2F84[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E2F68: using guessed type int dword_101E2F68;
// 101E2F84: using guessed type int dword_101E2F84[];

//----- (100440B0) --------------------------------------------------------
bool __cdecl sub_100440B0(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_101E2F68 != 1379255385 )
    {
      sub_100530C0(a1, (int)&byte_101E2F70[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_101E2F7C[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 101E2F68: using guessed type int dword_101E2F68;
// 101E2F7C: using guessed type int dword_101E2F7C[];

//----- (10044120) --------------------------------------------------------
char __cdecl sub_10044120(char a1, _BYTE *a2)
{
  if ( dword_101E2F68 != 1379255385 )
    sub_100530C0(a1, (int)&byte_101E2F70[24 * (unsigned __int8)a1]);
  *a2 = byte_101E2F70[24 * (unsigned __int8)a1];
  return 1;
}
// 101E2F68: using guessed type int dword_101E2F68;

//----- (10044160) --------------------------------------------------------
char __thiscall sub_10044160(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_101E2F68 = sub_10025CF0(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_101E2F70, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_101E2F70;
  do
  {
    result = sub_100530C0(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 101E2F68: using guessed type int dword_101E2F68;

//----- (100441D0) --------------------------------------------------------
char __cdecl sub_100441D0(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10037B90(a1);
  v3 = sub_10083850(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10044200) --------------------------------------------------------
char __cdecl sub_10044200(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_10037B90(a1);
  v3 = sub_100838C0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10044230) --------------------------------------------------------
char __cdecl sub_10044230(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_10037C80(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_100440B0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10043FE0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_10044050(v7, *a4, (int)a5);
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10044120(v7, a5);
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10044200(v7, (int)a5);
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_100441D0(v7, (int)a5);
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10015C20("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10044400) --------------------------------------------------------
char *__cdecl sub_10044400(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = byte_100879F8;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10044450) --------------------------------------------------------
int sub_10044450()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10016030();
  result = 0;
  while ( 1 )
  {
    v3 = dword_101E2FCC[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_101E2FCC[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 101E2FCC: using guessed type int dword_101E2FCC[];

//----- (10044490) --------------------------------------------------------
int __cdecl sub_10044490(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10044500) --------------------------------------------------------
signed int __cdecl sub_10044500(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100445A0) --------------------------------------------------------
int __usercall sub_100445A0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10044500(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100445D0) --------------------------------------------------------
signed int __usercall sub_100445D0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10044500((_BYTE *)a3, (int)(&off_100B69A0)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_100B69A4[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_10073208(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_10073208(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_10073208(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 100B69A0: using guessed type char *off_100B69A0;

//----- (100447A0) --------------------------------------------------------
char *__usercall sub_100447A0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10044800) --------------------------------------------------------
int __usercall sub_10044800@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10044500((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10044890) --------------------------------------------------------
int __usercall sub_10044890@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_100445A0(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (100448E0) --------------------------------------------------------
char **__usercall sub_100448E0@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10044400(v6);
      if ( !sub_10044500((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10044940) --------------------------------------------------------
const char *__usercall sub_10044940@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10044960) --------------------------------------------------------
int __usercall sub_10044960@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_101E2FB8[sub_10044450()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E2FB8: using guessed type int dword_101E2FB8[];

//----- (100449A0) --------------------------------------------------------
int __usercall sub_100449A0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_100445D0(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10044A30) --------------------------------------------------------
int __usercall sub_10044A30@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10044B80) --------------------------------------------------------
int __usercall sub_10044B80@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_100498A0(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_10045460(v3, v6, 0);
        v7 = -*v3;
        sub_100498A0(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_100498A0(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_100B6658);
      sub_10053E90(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_100B6658);
      sub_100498A0(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10044C20) --------------------------------------------------------
int __usercall sub_10044C20@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10044C60) --------------------------------------------------------
char *__cdecl sub_10044C60(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_100447A0(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_100447A0(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_100447A0(result, v5, (int)&v20);
      v10 = byte_100879F8;
    }
    LOBYTE(v9) = 0;
    sub_100447A0(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_100447A0(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_100447A0(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_100447A0(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10049830(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10044C60: using guessed type int var_61C[6];

//----- (10044E10) --------------------------------------------------------
int __usercall sub_10044E10@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10044400((char **)a1);
  result = sub_100498C0(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_100B6658);
  return result;
}

//----- (10044E40) --------------------------------------------------------
int __usercall sub_10044E40@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_100B6658);
  v2 = (unsigned int)sub_10044400((char **)a1);
  return sub_100498A0(10, v2);
}

//----- (10044E70) --------------------------------------------------------
void __cdecl sub_10044E70(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10044400(v5);
            v7 = sub_10044400((char **)v3);
            if ( !sub_10044490(v7, (int)v6) )
            {
              v8 = sub_10044400((char **)v3);
              sub_10049960(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10044400((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10044400((char **)v3);
        sub_10049960(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10044940(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1004A380("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10044400((char **)v3);
            sub_100499A0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10044490(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10044940(v18);
                  v25 = sub_1004A380("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10044400((char **)v3);
                  sub_100499A0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10044400((char **)v3);
                  sub_100499A0(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10044400((char **)v3);
              sub_100499A0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10044400((char **)v3);
              sub_100499A0(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10044400((char **)v3);
              sub_100499A0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_10044E70(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10044400((char **)v3);
            sub_100499A0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10044400((char **)v3);
            sub_100499A0(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10044400((char **)v3);
          sub_100499A0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10044400((char **)v3);
        sub_100499A0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10044400(a2);
      sub_10049960(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (100452E0) --------------------------------------------------------
int sub_100452E0()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_101E2FB8[sub_10044450()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_10044E70(i, 0, &v2);
  }
  return v2;
}
// 101E2FB8: using guessed type int dword_101E2FB8[];

//----- (10045330) --------------------------------------------------------
void *sub_10045330()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_101E2FB8[0] = 0;
  dword_101E2FBC = 0;
  dword_101E2FC0 = 0;
  dword_101E2FC4 = 0;
  dword_101E2FC8 = 0;
  result = &unk_101E2FE0;
  dword_101E2FCC[0] = -1;
  dword_101E2FD0 = -1;
  dword_101E2FD4 = -1;
  dword_101E2FD8 = -1;
  dword_101E2FDC = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10044C20((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 101E2FB8: using guessed type int dword_101E2FB8[];
// 101E2FBC: using guessed type int dword_101E2FBC;
// 101E2FC0: using guessed type int dword_101E2FC0;
// 101E2FC4: using guessed type int dword_101E2FC4;
// 101E2FC8: using guessed type int dword_101E2FC8;
// 101E2FCC: using guessed type int dword_101E2FCC[];
// 101E2FD0: using guessed type int dword_101E2FD0;
// 101E2FD4: using guessed type int dword_101E2FD4;
// 101E2FD8: using guessed type int dword_101E2FD8;
// 101E2FDC: using guessed type int dword_101E2FDC;

//----- (10045390) --------------------------------------------------------
char *sub_10045390()
{
  return (char *)&unk_101E2FE0 + 56 * sub_10044450();
}

//----- (100453B0) --------------------------------------------------------
char sub_100453B0()
{
  return sub_10045390()[33];
}

//----- (100453C0) --------------------------------------------------------
char __cdecl sub_100453C0(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10045390();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_10049420(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10045400) --------------------------------------------------------
int *__usercall sub_10045400@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_10045390() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10044500((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (10045450) --------------------------------------------------------
char **sub_10045450()
{
  return &off_100B6A08;
}
// 100B6A08: using guessed type char *off_100B6A08;

//----- (10045460) --------------------------------------------------------
int __cdecl sub_10045460(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1004E5F0();
  v3 = sub_10045390();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_100452E0();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10044E10(a2);
    if ( a3 )
    {
      v7 = sub_10044B80(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10044B80(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10044E40(a2);
        return v7;
      }
    }
    sub_10044E40(a2);
    result = v7;
  }
  return result;
}

//----- (10045510) --------------------------------------------------------
int __cdecl sub_10045510(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_100447A0(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_100447A0(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_100447A0(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10049830(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_100447A0(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_100447A0(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_100447A0(v14, "group-begin", (int)&v29);
          sub_10049830(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10044400(v15);
          sub_10045510(v16[2], v16[3], v16[4], v17, a4);
          sub_10044400(v16);
          v18 = sub_10044C60((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_100447A0(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_100447A0(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_100447A0(v20, "group-end", (int)&v29);
          result = sub_10049830(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_100447A0(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_100447A0(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_100447A0(v21, a4, (int)&v28);
          v23 = byte_100879F8;
        }
        LOBYTE(v22) = 0;
        v24 = sub_100447A0(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_100447A0(v24, *(const char **)v5, (int)&v30);
        result = sub_10049830(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10045510: using guessed type int var_414[4];

//----- (10045720) --------------------------------------------------------
char *__usercall sub_10045720@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_100447A0(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_100447A0(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10049830(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10045510(a3, (int)a4, a5, a2, 0);
    result = sub_10044C60(a3, a4, a5, 0);
  }
  return result;
}
// 10045720: using guessed type int var_20C[2];

//----- (100457E0) --------------------------------------------------------
char *__cdecl sub_100457E0(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_101E2FB8[sub_10044450()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10044400((char **)v2);
    sub_10045720("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10045390() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10045720(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 101E2FB8: using guessed type int dword_101E2FB8[];

//----- (10045880) --------------------------------------------------------
int *__cdecl sub_10045880(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_101E2FB8[sub_10044450()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10044400(v2);
      if ( !sub_10044500(a1, (int)v4) )
      {
        v5 = sub_10044400(v3);
        sub_10045720("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10045390();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10044500(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10045720(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 101E2FB8: using guessed type int dword_101E2FB8[];

//----- (10045940) --------------------------------------------------------
int __usercall sub_10045940@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10044960(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_10045460((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10044960(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_10045460((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10044E10(v5);
        sub_10044B80(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10044E40(v8);
          v10 = sub_10044960(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10045AA0) --------------------------------------------------------
signed int __usercall sub_10045AA0@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_101E2FB8[sub_10044450()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_10045460((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 101E2FB8: using guessed type int dword_101E2FB8[];

//----- (10045B10) --------------------------------------------------------
int __cdecl sub_10045B10(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10045390();
  switch ( a1 )
  {
    case 9:
      sub_100498A0(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10044500((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10044500(v6, (int)"-q") )
            {
              sub_10045880(v6);
              v9 = sub_100452E0();
              sub_100498A0(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_100457E0(0);
              v8 = sub_100452E0();
              sub_100498A0(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_100457E0(1);
            v7 = sub_100452E0();
            sub_100498A0(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10049920(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_100498A0(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_100457E0(0);
        v4 = sub_100452E0();
        sub_100498A0(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_100498A0(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_101E2FB8[sub_10044450()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10045B10 )
              v12(2, (int)&unk_100B6658);
          }
        }
      }
      sub_1004E5F0();
      v3[34] = 0;
      return 0;
    case 3:
      sub_100498A0(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_101E2FB8[sub_10044450()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10049920(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_10045940((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10049920(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10045AA0((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10049920(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10045B10 )
          v15(3, (int)&unk_100B6658);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10045B10: using guessed type int __cdecl sub_10045B10(int, int);
// 101E2FB8: using guessed type int dword_101E2FB8[];

//----- (10045DF0) --------------------------------------------------------
char **sub_10045DF0()
{
  return off_100B67FC;
}
// 100B67FC: using guessed type char *off_100B67FC[3];

//----- (10045E00) --------------------------------------------------------
int __usercall sub_10045E00@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10044890(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_100449A0(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_10045DF0();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (10045EF0) --------------------------------------------------------
int __cdecl sub_10045EF0(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_10045390();
  *a1 = 0;
  v4 = sub_1004A380("Processing command '%s'", v2);
  sub_10049920(3, (int)&unk_100B71B0, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10044A30(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_10045940((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10045AA0((int)v3);
    v11 = 0;
    v6 = sub_10044450();
    v7 = sub_100448E0((int (**)(void))dword_101E2FB8[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10044800((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10044800((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10045460(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10045460(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_10045E00(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10045400(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_10045E00(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_10045DF0();
        result = sub_10045E00(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 101E2FB8: using guessed type int dword_101E2FB8[];
// 10045EF0: using guessed type char var_2D4[720];

//----- (10046130) --------------------------------------------------------
int sub_10046130()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_10045EF0(&v4);
  if ( !sub_10045390()[32] )
    sub_100498A0(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1004A380("%s %i, %s", "Command status:", v0, &v4);
    sub_10049920(3, (int)&unk_100B71B0, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1004A380("%s %i", "Command status:", v0);
    sub_10049920(3, (int)&unk_100B71B0, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (10046210) --------------------------------------------------------
int __cdecl sub_10046210(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_101E2FB8[sub_10044450()] = a1;
  sub_10045390()[32] = a3;
  sub_1004E5F0();
  sub_100540A0(a2);
  v3 = sub_10045450();
  sub_10049310(v3);
  return sub_10046130();
}
// 101E2FB8: using guessed type int dword_101E2FB8[];

//----- (10046260) --------------------------------------------------------
_DWORD *sub_10046260()
{
  sub_10001620();
  return sub_10054430();
}

//----- (10046270) --------------------------------------------------------
#error "1004627F: call analysis failed (funcsize=5)"

//----- (10046290) --------------------------------------------------------
void sub_10046290()
{
  dword_102D2B34 = -15;
}
// 102D2B34: using guessed type int dword_102D2B34;

//----- (100462A0) --------------------------------------------------------
signed int sub_100462A0()
{
  return sub_100175B0((int)&off_100B7848);
}
// 100B7848: using guessed type char *off_100B7848;

//----- (100462B0) --------------------------------------------------------
signed int sub_100462B0()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_100462A0() )
    v0 = *(_BYTE *)(dword_102D2B34 + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 102D2B34: using guessed type int dword_102D2B34;

//----- (100462E0) --------------------------------------------------------
char sub_100462E0()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_100462A0() )
  {
    sub_10016170(101, 10000);
    if ( !*(_BYTE *)(dword_102D2B34 + 1444)
      || !*(_BYTE *)(dword_102D2B34 + 1451)
      || (v0 = 1, *(_WORD *)(dword_102D2B34 + 1456) <= 1u)
      || *(float *)(dword_102D2B34 + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_10016150(101);
  }
  return v0;
}
// 102D2B34: using guessed type int dword_102D2B34;

//----- (10046350) --------------------------------------------------------
bool __cdecl sub_10046350(float *a1)
{
  bool v1; // bl@1
  int v2; // eax@2

  *a1 = 0.0;
  v1 = 0;
  if ( (unsigned __int8)sub_100462A0() )
  {
    sub_10016170(101, 60000);
    v2 = dword_102D2B34;
    if ( *(_BYTE *)(dword_102D2B34 + 1451) )
    {
      *a1 = *(float *)(dword_102D2B34 + 1480);
      v2 = dword_102D2B34;
    }
    v1 = *(_WORD *)(v2 + 1456) > 1u;
    sub_10016150(101);
  }
  return v1;
}
// 102D2B34: using guessed type int dword_102D2B34;

//----- (100463B0) --------------------------------------------------------
void sub_100463B0()
{
  dword_102D2B30 = -15;
}
// 102D2B30: using guessed type int dword_102D2B30;

//----- (100463C0) --------------------------------------------------------
int sub_100463C0()
{
  int result; // eax@1

  result = 0;
  dword_101E30F8 = -15;
  dword_102D2B2C = 0;
  dword_102D2B20 = 0;
  dword_102D2B24 = 0;
  dword_102D2B28 = 0;
  return result;
}
// 101E30F8: using guessed type int dword_101E30F8;
// 102D2B20: using guessed type int dword_102D2B20;
// 102D2B24: using guessed type int dword_102D2B24;
// 102D2B28: using guessed type int dword_102D2B28;
// 102D2B2C: using guessed type int dword_102D2B2C;

//----- (100463F0) --------------------------------------------------------
char sub_100463F0()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_100175B0((int)&off_100B78AC);
  if ( v0 )
  {
    dword_102D2B2C = dword_101E30F8;
    v1 = *(_BYTE *)(dword_101E30F8 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_102D2B2C + 36) < (unsigned int)sub_100160A0() )
      v0 = 0;
    dword_102D2B28 = dword_101E30F8 + 56116;
    result = v0;
    dword_102D2B20 = dword_101E30F8 + 1516;
    dword_102D2B24 = dword_101E30F8 + 20484;
  }
  else
  {
    dword_102D2B2C = 0;
    dword_102D2B20 = 0;
    dword_102D2B24 = 0;
    dword_102D2B28 = 0;
    result = 0;
  }
  return result;
}
// 100B78AC: using guessed type char *off_100B78AC;
// 101E30F8: using guessed type int dword_101E30F8;
// 102D2B20: using guessed type int dword_102D2B20;
// 102D2B24: using guessed type int dword_102D2B24;
// 102D2B28: using guessed type int dword_102D2B28;
// 102D2B2C: using guessed type int dword_102D2B2C;

//----- (10046490) --------------------------------------------------------
void sub_10046490()
{
  dword_101E30FC = -15;
}
// 101E30FC: using guessed type int dword_101E30FC;

//----- (100464B0) --------------------------------------------------------
signed int sub_100464B0()
{
  return sub_100175B0((int)&off_100B791C);
}
// 100B791C: using guessed type char *off_100B791C;

//----- (100464C0) --------------------------------------------------------
int sub_100464C0()
{
  return (unsigned __int8)sub_100464B0() != 0 ? dword_101E30FC : 0;
}
// 101E30FC: using guessed type int dword_101E30FC;

//----- (100464D0) --------------------------------------------------------
int sub_100464D0()
{
  int result; // eax@2

  if ( (unsigned __int8)sub_100464B0() )
    result = dword_101E30FC + 55656;
  else
    result = 0;
  return result;
}
// 101E30FC: using guessed type int dword_101E30FC;

//----- (100464F0) --------------------------------------------------------
void sub_100464F0()
{
  dword_102D2B18 = -15;
}
// 102D2B18: using guessed type int dword_102D2B18;

//----- (10046500) --------------------------------------------------------
char __cdecl sub_10046500(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_10052F20(v1);
  v3 = sub_10048980(v2);
  if ( sub_10016380(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 10046500: using guessed type char var_48[68];

//----- (10046560) --------------------------------------------------------
signed int sub_10046560()
{
  return sub_100175B0((int)&off_100B7950);
}
// 100B7950: using guessed type char *off_100B7950;

//----- (10046570) --------------------------------------------------------
char __usercall sub_10046570@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_10046560()
    || sub_10016170(33, 10) )
  {
    sub_10015C20("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_100160A0()
                         - *(_DWORD *)(dword_102D2B18 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_102D2B18 + 37) )
  {
    memcpy_0(
      a3,
      (const void *)(dword_102D2B18 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_102D2B18 + 2 * v3 + 62));
    sub_10016150(33);
    result = 1;
  }
  else
  {
    sub_10016150(33);
    result = 0;
  }
  return result;
}
// 102D2B18: using guessed type int dword_102D2B18;

//----- (10046650) --------------------------------------------------------
char __cdecl sub_10046650(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_10046570(a1, a2, a3);
    }
    else
    {
      v4 = sub_100544F0(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_1003E5B0(*(_BYTE *)v5)) )
      {
        result = sub_1003F250(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 100544F0: using guessed type _DWORD __cdecl sub_100544F0(char);

//----- (100466D0) --------------------------------------------------------
char __cdecl sub_100466D0(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_10046500(a1);
  return sub_10046650(a1, v2, a2);
}

//----- (100466F0) --------------------------------------------------------
int __cdecl sub_100466F0(int a1, int a2)
{
  byte_102D2B48[0] = 0;
  return nullsub_1(a1, a2);
}

//----- (10046700) --------------------------------------------------------
BOOL __cdecl sub_10046700(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_100160A0();
  for ( i = sub_10083960(6, 0, 1, (int)&v4); i == 12; i = sub_10083960(6, 0, 1, (int)&v4) )
  {
    if ( sub_100160A0() - v1 >= a1 )
      break;
    sub_10016220(100);
  }
  return i == 12;
}

//----- (10046770) --------------------------------------------------------
char __thiscall sub_10046770(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10016BE0(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10046790) --------------------------------------------------------
void __cdecl sub_10046790(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_10016BE0(120, a1);
  sub_10016BE0(124, a2);
  sub_10016BE0(121, a3);
}

//----- (100467C0) --------------------------------------------------------
int __cdecl sub_100467C0(int a1)
{
  return sub_10016380(3025, a1, 84);
}

//----- (100467E0) --------------------------------------------------------
signed int sub_100467E0()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_100839A0(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (10046810) --------------------------------------------------------
void __cdecl sub_10046810(_BYTE *a1)
{
  sub_10016BE0(129, a1);
}

//----- (10046830) --------------------------------------------------------
char __cdecl sub_10046830(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_10083960(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10046870) --------------------------------------------------------
int __cdecl sub_10046870(int a1)
{
  return sub_10016450(3025, a1, 84);
}

//----- (10046890) --------------------------------------------------------
char __fastcall sub_10046890(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_102D2B14 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_10046830(147, 0xCu, &v38);
  sub_10046830(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_100163E0(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_100405A0(a1);
  if ( !result || result == 3 )
    result = sub_10025D90(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_10016450(2000, (int)&v20, 29);
  }
  return result;
}
// 102D2B14: using guessed type char byte_102D2B14;

//----- (10046AB0) --------------------------------------------------------
char sub_10046AB0()
{
  int *v0; // ecx@1

  sub_10046700(0x9C40u);
  sub_10024900(&off_100B7EA8);
  return sub_10046890(v0);
}
// 100B7EA8: using guessed type int (__cdecl *off_100B7EA8)(int, size_t, void *);

//----- (10046AD0) --------------------------------------------------------
signed int sub_10046AD0()
{
  return 1000;
}

//----- (10046B00) --------------------------------------------------------
int sub_10046B00()
{
  return sub_100510B0((int)off_100B83F0);
}
// 100B83F0: using guessed type int (*off_100B83F0[4])();

//----- (10046B50) --------------------------------------------------------
signed int __cdecl sub_10046B50(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10046BD0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10047AF0(v4, a4, 0) == a4 )
      result = sub_10047A90(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10046BB0) --------------------------------------------------------
signed int __cdecl sub_10046BB0(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10046BD0(a1);
  return sub_10047AF0(v3, a2, a3);
}

//----- (10046BD0) --------------------------------------------------------
unsigned int __cdecl sub_10046BD0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10046BF0) --------------------------------------------------------
bool __cdecl sub_10046BF0(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10046CC0) --------------------------------------------------------
int __cdecl sub_10046CC0(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10046CE0) --------------------------------------------------------
int __cdecl sub_10046CE0(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10046CC0(a1 + 20);
  return result;
}

//----- (10046D20) --------------------------------------------------------
signed int __cdecl sub_10046D20(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_10015E50(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_10015E50(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10046DE0) --------------------------------------------------------
int __cdecl sub_10046DE0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10046E20) --------------------------------------------------------
int __usercall sub_10046E20@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_100580D0(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_10015F30(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_10015F50(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 10015F70: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10046ED0) --------------------------------------------------------
signed int __usercall sub_10046ED0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_10015F80(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10058520((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10046D20(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10015E50(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_10015E50(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_100583F0(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_10015F80(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_10015F80(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (100470A0) --------------------------------------------------------
char __usercall sub_100470A0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_10058080(a2, a3, a1 + 212);
}

//----- (100470B0) --------------------------------------------------------
int __usercall sub_100470B0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10046E20(result + 148, result);
  return result;
}

//----- (100470D0) --------------------------------------------------------
char __usercall sub_100470D0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (100470F0) --------------------------------------------------------
int __usercall sub_100470F0@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_10070830(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_10070830(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10047130) --------------------------------------------------------
int __fastcall sub_10047130(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10047150) --------------------------------------------------------
int __usercall sub_10047150@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_10015FD0(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_10015F50(v4, v3, 0);
}
// 10015F70: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10047190) --------------------------------------------------------
signed int __usercall sub_10047190@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10047130(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_10070850(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_100470A0(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_1005A2D0(a2 + 28, 4);
      else
        v22 = sub_1005A2D0(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy_0(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_100470A0(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 10015F70: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100473A0) --------------------------------------------------------
int __cdecl sub_100473A0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_100470B0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_100256B0(&v23);
    sub_10048BC0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10046CE0(v1, (int)&v24);
  v13 = sub_10015F30(v31);
  if ( v3 == v31 )
  {
    result = sub_10015DA0(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_10015FD0(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_10015DA0(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_10015FD0(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10046CC0(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10047150(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_10015F30(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 10015F70: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10047610) --------------------------------------------------------
signed int __cdecl sub_10047610(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_10015FD0(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10047190(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100476B0) --------------------------------------------------------
int __usercall sub_100476B0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_100470D0(a1);
  *v3 ^= v2;
  return sub_100470F0(v1, *v3);
}

//----- (100476D0) --------------------------------------------------------
int __usercall sub_100476D0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_100476B0(a2);
  return result;
}

//----- (10047700) --------------------------------------------------------
signed int __usercall sub_10047700@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_100470F0(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_10015E50(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (100477F0) --------------------------------------------------------
char __usercall sub_100477F0@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_10058030(a1, a2, a3 + 212);
  else
    result = sub_100476D0(a2, a3 + 148);
  return result;
}

//----- (10047820) --------------------------------------------------------
signed int __usercall sub_10047820@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10046ED0(v3, v1);
  else
    result = sub_10047700(v3, v1);
  return result;
}

//----- (10047850) --------------------------------------------------------
signed int __cdecl sub_10047850(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10046DE0(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_1005BD40(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10047820(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100478A0) --------------------------------------------------------
signed int __cdecl sub_100478A0(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_10015E50(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_100477F0(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_10015E50(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_100580D0(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10047130(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1005D100(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_10070850(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy_0(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_10070850(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10047A90) --------------------------------------------------------
signed int __cdecl sub_10047A90(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_100478A0(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10046BF0(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10047AF0) --------------------------------------------------------
signed int __cdecl sub_10047AF0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10047850(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10046DE0(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10047850(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10047A90(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10047C80) --------------------------------------------------------
int __cdecl sub_10047C80(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 0x7Fu, 0, 0);
}

//----- (10047CA0) --------------------------------------------------------
int __cdecl sub_10047CA0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10052A90(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10047CD0) --------------------------------------------------------
int __cdecl sub_10047CD0(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 3u, 0, 0);
}

//----- (10047CF0) --------------------------------------------------------
char __cdecl sub_10047CF0(char a1)
{
  char v1; // bl@1
  char result; // al@4

  v1 = a1;
  sub_10016BE0(69, &a1);
  if ( a1 && (v1 == 15 || v1 == 13) )
    result = 17;
  else
    result = v1;
  return result;
}

//----- (10047D20) --------------------------------------------------------
signed int __cdecl sub_10047D20(signed int a1)
{
  signed int v1; // esi@1
  signed int result; // eax@4

  v1 = a1;
  sub_10016BE0(69, &a1);
  if ( (_BYTE)a1 && (v1 == -1 || v1 == -4144960) )
    result = -11250604;
  else
    result = v1;
  return result;
}

//----- (10047D60) --------------------------------------------------------
int __cdecl sub_10047D60(char a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int result; // eax@3

  v2 = sub_10025880(v1) - 1;
  if ( v2 && v2 != 3 )
    result = sub_10016450(41029, (int)&a1, 1);
  else
    result = sub_10016450(41028, (int)&a1, 1);
  return result;
}

//----- (10047DA0) --------------------------------------------------------
int __cdecl sub_10047DA0(char a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int result; // eax@3

  v2 = sub_10025880(v1) - 1;
  if ( v2 && v2 != 3 )
    result = sub_10016450(41027, (int)&a1, 1);
  else
    result = sub_10016450(41026, (int)&a1, 1);
  return result;
}

//----- (10047DE0) --------------------------------------------------------
char __cdecl sub_10047DE0(float a1, int a2, char a3, int a4)
{
  char v4; // bl@1
  int v5; // ebp@1
  double v6; // st6@1
  unsigned __int8 v7; // dl@4
  int v8; // ecx@5
  int v9; // ecx@17
  bool v10; // zf@17
  int v11; // ebp@19
  char v13; // [sp+13h] [bp-1h]@1

  v4 = *(_BYTE *)(a2 + 4);
  v13 = 0;
  v5 = sub_100160A0();
  v6 = a1;
  if ( a1 == 9.8999998e24 )
  {
    v4 = 10;
    v13 = 10;
  }
  else if ( *(_BYTE *)(a4 + 24) )
  {
    v4 = *(_BYTE *)a4;
    v13 = *(_BYTE *)(a4 + 12);
  }
  else
  {
    v7 = 1;
    if ( (unsigned __int8)a3 > 1u )
    {
      v8 = a2;
      do
      {
        if ( 9.8999998e24 != *(float *)(v8 + 8)
          && (*(float *)v8 < (double)*(float *)(v8 + 8) && *(float *)v8 < v6
           || *(float *)v8 > (double)*(float *)(v8 + 8) && *(float *)v8 > v6) )
        {
          v4 = *(_BYTE *)(v8 + 12);
          v13 = v7;
        }
        ++v7;
        v8 += 8;
      }
      while ( v7 < (unsigned __int8)a3 );
    }
  }
  if ( v4 != *(_BYTE *)a4 )
  {
    *(_DWORD *)(a4 + 8) = 0;
    *(_DWORD *)(a4 + 4) = v5;
  }
  v9 = v5 - *(_DWORD *)(a4 + 4);
  v10 = v13 == *(_BYTE *)(a4 + 12);
  *(_BYTE *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v9;
  if ( !v10 )
  {
    *(_DWORD *)(a4 + 20) = 0;
    *(_DWORD *)(a4 + 16) = v5;
  }
  v11 = v5 - *(_DWORD *)(a4 + 16);
  *(_BYTE *)(a4 + 12) = v13;
  *(_DWORD *)(a4 + 20) = v11;
  return v4;
}

//----- (10047ED0) --------------------------------------------------------
void __cdecl sub_10047ED0(char a1, _DWORD *a2, _DWORD *a3, char a4)
{
  int v4; // eax@2

  if ( !a4 )
  {
    v4 = 8 * sub_100430B0(&a1, 1u, (int)&unk_100CDA68, 32, 20, 0);
    *a2 = dword_100CDA7C[v4];
    *a3 = dword_100CDA80[v4];
  }
}
// 100CDA7C: using guessed type int dword_100CDA7C[];
// 100CDA80: using guessed type int dword_100CDA80[];

//----- (10047F10) --------------------------------------------------------
char __cdecl sub_10047F10(char a1, _DWORD *a2, int *a3, char a4, int a5)
{
  int v5; // eax@1
  int *v6; // ecx@2
  int v7; // ecx@4
  int v8; // edx@8

  LOBYTE(v5) = a4;
  if ( a4 == 1 )
  {
    LOBYTE(v5) = (_BYTE)a2;
    v6 = a3;
    *a2 = 0;
    *v6 = 0;
  }
  else if ( !a4 )
  {
    v5 = 32 * sub_100430B0(&a1, 1u, (int)&unk_100CDA68, 32, 20, 0);
    v7 = *(int *)((char *)&dword_100CDA84 + v5);
    if ( !v7 || v7 != -1 && a5 > v7 || byte_1026D91E )
    {
      *a2 = *(int *)((char *)&dword_100CDA74 + v5);
      v5 = *(int *)((char *)&dword_100CDA78 + v5);
      *a3 = v5;
    }
    else
    {
      *a2 = *(int *)((char *)&dword_100CDA78 + v5);
      v8 = *(int *)((char *)&dword_100CDA74 + v5);
      LOBYTE(v5) = (_BYTE)a3;
      *a3 = v8;
    }
  }
  return v5;
}
// 100CDA74: using guessed type int dword_100CDA74;
// 100CDA78: using guessed type int dword_100CDA78;
// 100CDA84: using guessed type int dword_100CDA84;
// 1026D91E: using guessed type char byte_1026D91E;

//----- (10047FA0) --------------------------------------------------------
char __cdecl sub_10047FA0(char a1, _DWORD *a2, int *a3, char a4, int a5)
{
  int v5; // eax@1
  int *v6; // ecx@2
  int v7; // ecx@4
  int v8; // edx@8

  LOBYTE(v5) = a4;
  if ( a4 == 1 )
  {
    LOBYTE(v5) = (_BYTE)a2;
    v6 = a3;
    *a2 = 0;
    *v6 = 0;
  }
  else if ( !a4 )
  {
    v5 = 32 * sub_100430B0(&a1, 1u, (int)&unk_100CDA68, 32, 20, 0);
    v7 = *(int *)((char *)&dword_100CDA84 + v5);
    if ( !v7 || v7 != -1 && a5 > v7 || byte_1026D91E )
    {
      *a2 = *(int *)((char *)&dword_100CDA6C + v5);
      v5 = *(int *)((char *)&dword_100CDA70 + v5);
      *a3 = v5;
    }
    else
    {
      *a2 = *(int *)((char *)&dword_100CDA70 + v5);
      v8 = *(int *)((char *)&dword_100CDA6C + v5);
      LOBYTE(v5) = (_BYTE)a3;
      *a3 = v8;
    }
  }
  return v5;
}
// 100CDA6C: using guessed type int dword_100CDA6C;
// 100CDA70: using guessed type int dword_100CDA70;
// 100CDA84: using guessed type int dword_100CDA84;
// 1026D91E: using guessed type char byte_1026D91E;

//----- (10048030) --------------------------------------------------------
int __cdecl sub_10048030(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 12) = 10;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_BYTE *)a1 = 10;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  return result;
}

//----- (10048050) --------------------------------------------------------
int __usercall sub_10048050@<eax>(const char *a1@<eax>, int a2@<ecx>)
{
  int v2; // ebp@1
  int v3; // esi@1
  const char *v4; // edi@2
  int result; // eax@5
  const char *v6; // [sp+8h] [bp-4h]@2

  v2 = *(_WORD *)(a2 + 4);
  v3 = 0;
  if ( v2 <= 0 )
  {
    result = 0;
  }
  else
  {
    v6 = *(const char **)a2;
    v4 = *(const char **)a2;
    while ( strcmp(v4, a1) )
    {
      ++v3;
      v4 += 56;
      if ( v3 >= v2 )
        return 0;
    }
    result = (int)&v6[56 * v3];
  }
  return result;
}

//----- (100480D0) --------------------------------------------------------
int __usercall sub_100480D0@<eax>(int a1@<ebx>, float a2, float a3, int a4, int a5, int a6, float a7, char a8)
{
  int result; // eax@1
  int v9; // edi@1
  float v10; // ST20_4@2
  float v11; // ST24_4@2
  float v12; // ST10_4@2
  float v13; // ST24_4@2
  float v14; // ST24_4@2
  float v15; // ST10_4@2
  float v16; // ST24_4@2
  float v17; // ST20_4@2
  float v18; // ST24_4@2
  float v19; // ST10_4@2
  float v20; // ST24_4@2
  float v21; // ST24_4@2
  float v22; // ST10_4@2
  float v23; // ST24_4@2

  result = sub_10048050((const char *)a6, a4);
  v9 = result;
  if ( result )
  {
    j_gdi_pvg_push_attrib(0x2000);
    j_gdi_pvg_enable(34);
    j_gdi_pvg_bind_texture(34, *(_DWORD *)(a4 + 8));
    sub_10015610(1.0, 1.0, 1.0, a7);
    j_gdi_pvg_begin(72);
    v10 = (double)(a8 != 0);
    sub_10015890(v10, *(float *)(v9 + 52));
    v11 = *(float *)(a5 + 4) + a3;
    v12 = v11;
    v13 = *(float *)a5 + a2;
    sub_10015960(v13, v12);
    sub_10015890(v10, *(float *)(v9 + 52));
    v14 = *(float *)(a5 + 28) + a3;
    v15 = v14;
    v16 = *(float *)(a5 + 24) + a2;
    sub_10015960(v16, v15);
    v17 = (double)(a8 == 0);
    sub_10015890(v17, *(float *)(v9 + 52));
    v18 = *(float *)(a5 + 20) + a3;
    v19 = v18;
    v20 = *(float *)(a5 + 16) + a2;
    sub_10015960(v20, v19);
    sub_10015890(v17, *(float *)(v9 + 52));
    v21 = *(float *)(a5 + 12) + a3;
    v22 = v21;
    v23 = *(float *)(a5 + 8) + a2;
    sub_10015960(v23, v22);
    j_gdi_pvg_end(a1);
    result = j_gdi_pvg_pop_attrib();
  }
  return result;
}
// 100480D0: could not find valid save-restore pair for ebx
// 10015540: using guessed type int __cdecl j_gdi_pvg_begin(_DWORD);
// 10015560: using guessed type int __cdecl j_gdi_pvg_bind_texture(_DWORD, _DWORD);
// 10015710: using guessed type int __cdecl j_gdi_pvg_enable(_DWORD);
// 10015730: using guessed type int __stdcall j_gdi_pvg_end(_DWORD);
// 10015800: using guessed type int j_gdi_pvg_pop_attrib(void);
// 10015820: using guessed type int __cdecl j_gdi_pvg_push_attrib(_DWORD);

//----- (10048270) --------------------------------------------------------
double __cdecl sub_10048270(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_100706D0(a1, a4);
  *(float *)&v16 = sub_100705F0(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (10048350) --------------------------------------------------------
int __cdecl sub_10048350(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_102D2B14 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_102D21D4)(146, 1, a1);
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;
// 102D2B14: using guessed type char byte_102D2B14;

//----- (10048380) --------------------------------------------------------
char __cdecl sub_10048380(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_102D2B14 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_102D21D4)(dword_102D25E4, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;
// 102D25E4: using guessed type int dword_102D25E4;
// 102D2B14: using guessed type char byte_102D2B14;

//----- (100483D0) --------------------------------------------------------
char __cdecl sub_100483D0(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_102D2B14 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_102D21D4)(dword_102D25E4, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;
// 102D25E4: using guessed type int dword_102D25E4;
// 102D2B14: using guessed type char byte_102D2B14;

//----- (10048420) --------------------------------------------------------
int sub_10048420()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_102D22C0, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_102D21C4)(512, &v6);
  v1 = 0;
  do
  {
    word_102D22C4[v1 / 2] = 0;
    dword_102D22C8[v1 / 4] = 0;
    dword_102D22C0[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_102D22CC = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_102D22D0 = v7;
    dword_102D22D4 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_102D22D8;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_102D21C4)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_102D22D0;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 102D21C4: using guessed type int dword_102D21C4;
// 102D22C0: using guessed type int dword_102D22C0[];
// 102D22C4: using guessed type __int16 word_102D22C4[];
// 102D22C8: using guessed type int dword_102D22C8[];
// 102D22CC: using guessed type int dword_102D22CC;
// 102D22D0: using guessed type int dword_102D22D0;
// 102D22D4: using guessed type int dword_102D22D4;
// 102D22D8: using guessed type int dword_102D22D8;

//----- (100484F0) --------------------------------------------------------
__int16 sub_100484F0()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_102D22DC;
  v1 = dword_102D22E0;
  v2 = 1;
  v3 = dword_102D22D8;
  if ( (unsigned int)dword_102D22E0 >= 1 )
  {
    v4 = (unsigned __int16)word_102D22DC;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_102D21D4)(v3, 2, &v5);
      result = v5;
      word_102D29E0[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;
// 102D22D8: using guessed type int dword_102D22D8;
// 102D22DC: using guessed type __int16 word_102D22DC;
// 102D22E0: using guessed type int dword_102D22E0;
// 102D29E0: using guessed type __int16 word_102D29E0[];

//----- (10048550) --------------------------------------------------------
int __usercall sub_10048550@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (100485D0) --------------------------------------------------------
char sub_100485D0()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_102D2B14 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_102D21D4)(147, 12, &v17);
  byte_102D2B14 = 1;
  dword_101F0848 = 0;
  dword_101F084C = 0;
  dword_101F0850 = 0;
  dword_101F0854 = 0;
  byte_101F0858 = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_102D22C0, 0, 0x708u);
  sub_10048550((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_102D22C0, 0, 0x708u);
  }
  byte_102D2B14 = 0;
  sub_10048350(&v16);
  if ( v16 != 101 )
  {
    byte_102D2B14 = 2;
    return (unsigned int)memset(dword_102D22C0, 0, 0x708u);
  }
  if ( byte_102D2B14 )
    return (unsigned int)memset(dword_102D22C0, 0, 0x708u);
  sub_100483D0(&unk_102D29C8, &byte_102D2B0D);
  byte_102D2B0C = byte_102D2B0D - 1;
  if ( byte_102D2B14 )
    return (unsigned int)memset(dword_102D22C0, 0, 0x708u);
  result = sub_10048380(&unk_102D29C9, &unk_102D29CA);
  byte_102D22B0 = 0;
  if ( byte_102D2B14 )
    return (unsigned int)memset(dword_102D22C0, 0, 0x708u);
  return result;
}
// 101F0848: using guessed type int dword_101F0848;
// 101F084C: using guessed type int dword_101F084C;
// 101F0850: using guessed type int dword_101F0850;
// 101F0854: using guessed type int dword_101F0854;
// 101F0858: using guessed type char byte_101F0858;
// 102D21D4: using guessed type int dword_102D21D4;
// 102D22B0: using guessed type char byte_102D22B0;
// 102D22C0: using guessed type int dword_102D22C0[];
// 102D2B0C: using guessed type char byte_102D2B0C;
// 102D2B0D: using guessed type char byte_102D2B0D;
// 102D2B14: using guessed type char byte_102D2B14;

//----- (10048790) --------------------------------------------------------
int (__cdecl *(*sub_10048790())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_102D21C4 = (int)off_100E2D18;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_102D21D4)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_10048550((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_100CDD40)[8 * v1];
      v3 = strlen((&off_100CDD40)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_100CDD44)[v1];
        dword_102D21C4 = (int)(&off_100CDD44)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 100CDD40: using guessed type char *off_100CDD40;
// 100CDD44: using guessed type int (__cdecl *(*off_100CDD44)[2])(int, int);
// 100E2D18: using guessed type int (__cdecl *off_100E2D18[2])(int, int);
// 102D21C4: using guessed type int dword_102D21C4;
// 102D21D4: using guessed type int dword_102D21D4;

//----- (100488C0) --------------------------------------------------------
signed int __cdecl sub_100488C0(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 < 0x17u )
      result = *(_DWORD *)(a1 + 36);
  }
  return result;
}

//----- (100488E0) --------------------------------------------------------
bool __cdecl sub_100488E0(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_102D22C8[v2 / 4] && word_102D22C4[v2 / 2] && dword_102D22C0[v2 / 4] )
      result = 1;
  }
  return result;
}
// 102D22C0: using guessed type int dword_102D22C0[];
// 102D22C4: using guessed type __int16 word_102D22C4[];
// 102D22C8: using guessed type int dword_102D22C8[];

//----- (10048920) --------------------------------------------------------
int __cdecl sub_10048920(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_100488E0(0, a1) )
    result = dword_102D22C8[3 * v1];
  else
    result = 0;
  return result;
}
// 102D22C8: using guessed type int dword_102D22C8[];

//----- (10048950) --------------------------------------------------------
bool sub_10048950()
{
  return sub_10016150(99) == 0;
}

//----- (10048960) --------------------------------------------------------
bool sub_10048960()
{
  return sub_10016170(99, 10000) == 0;
}

//----- (10048980) --------------------------------------------------------
int __cdecl sub_10048980(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (10048990) --------------------------------------------------------
int __usercall sub_10048990@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_1005D590(a2, a1);
}

//----- (100489A0) --------------------------------------------------------
char __usercall sub_100489A0@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_10048990((char *)&v5, a2);
  v2 = sub_10048980(a1);
  if ( sub_10016380(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 100489A0: using guessed type char var_48[68];

//----- (10048A60) --------------------------------------------------------
char __cdecl sub_10048A60(char a1, char a2)
{
  return sub_100489A0(a1, a2);
}

//----- (10048A80) --------------------------------------------------------
int __cdecl sub_10048A80(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_100CE2EE[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_100CE2EE[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10048B70) --------------------------------------------------------
__int16 __cdecl sub_10048B70(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10048BC0) --------------------------------------------------------
__int16 __cdecl sub_10048BC0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10048B70((int)&v5, *a1);
  sub_10048A80((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10048C40) --------------------------------------------------------
int __cdecl sub_10048C40(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_102D22AC)();
  *a1 = result;
  return result;
}
// 102D22AC: using guessed type int dword_102D22AC;

//----- (10048C60) --------------------------------------------------------
unsigned int __usercall sub_10048C60@<eax>(int a1@<eax>)
{
  int v1; // ebx@1
  int v2; // ebp@1
  char v3; // dl@1
  int v4; // ecx@5
  int v5; // esi@5
  float *v6; // edx@6
  _BYTE *v7; // edx@11
  char *v8; // ecx@11
  char v9; // al@12
  int v10; // eax@14
  int v11; // edi@16
  char *v12; // eax@16
  long double v13; // ST28_8@19
  long double v14; // st6@19
  int v15; // edi@19
  char *v16; // eax@21
  _BYTE *v17; // esi@21
  char v18; // cl@22
  unsigned int result; // eax@23
  _BYTE *v20; // edi@23
  char v21; // cl@24
  const void *v22; // ebx@25
  char *v23; // eax@28
  char v24; // cl@29
  char v25; // cl@31
  char *v26; // eax@34
  _BYTE *v27; // edx@34
  char v28; // cl@35
  _BYTE *v29; // edi@36
  char v30; // cl@37
  __int32 v31; // [sp+18h] [bp-8h]@17

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 32);
  v3 = 0;
  if ( *(_BYTE *)v2 <= 1u )
    v3 = 1;
  if ( 9.8999998e24 == *(float *)a1 )
    goto LABEL_10;
  if ( !v3 )
  {
    v4 = *(_BYTE *)v2 - 1;
    v5 = 0;
    if ( v4 > 0 )
    {
      v6 = (float *)(v2 + 44);
      while ( *(v6 - 5) > (double)*(float *)a1 || *v6 <= (double)*(float *)a1 )
      {
        ++v5;
        v6 += 5;
        if ( v5 >= v4 )
          goto LABEL_10;
      }
      v10 = v5 + 1;
      if ( *(float *)v1 >= 0.0 )
        v10 = v5;
      v11 = 20 * v10;
      sprintf(*(char **)(v1 + 36), (const char *)(20 * v10 + v2 + 28), *(float *)v1);
      v12 = strrchr((const char *)(v11 + *(_DWORD *)(v1 + 32) + 28), 46);
      if ( v12 )
        v31 = j__atol(v12 + 1);
      else
        v31 = 0;
      v13 = pow(10.0, (double)v31);
      v14 = atof((const char *)*(_DWORD *)(v1 + 36)) * v13;
      v15 = *(_DWORD *)(v1 + 32);
      if ( (signed int)v14 != (signed int)(v13 * *(float *)(v15 + 20 * v5 + 24)) )
        ++v5;
      sprintf(*(char **)(v1 + 36), (const char *)(v15 + 20 * v5 + 28), *(float *)v1);
      v16 = (char *)(*(_DWORD *)(v1 + 32) + 11);
      v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
      do
        v18 = *v16++;
      while ( v18 );
      result = v16 - v17;
      v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
      do
        v21 = (v20++)[1];
      while ( v21 );
      goto LABEL_25;
    }
LABEL_10:
    if ( *(_DWORD *)(a1 + 40) )
    {
      memset(*(void **)(a1 + 36), 95, *(_DWORD *)(a1 + 40));
      *(_BYTE *)(*(_DWORD *)(v1 + 40) + *(_DWORD *)(v1 + 36)) = 0;
    }
    else
    {
      v7 = *(_BYTE **)(a1 + 36);
      v8 = (char *)(v2 + 1);
      do
      {
        v9 = *v8;
        *v7++ = *v8++;
      }
      while ( v9 );
    }
    v26 = (char *)(*(_DWORD *)(v1 + 32) + 11);
    v27 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
    do
      v28 = *v26++;
    while ( v28 );
    result = v26 - v27;
    v29 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
    do
      v30 = (v29++)[1];
    while ( v30 );
    qmemcpy(v29, v27, result);
    return result;
  }
  sprintf(*(char **)(a1 + 36), (const char *)(v2 + 28), *(float *)a1);
  v23 = (char *)(*(_DWORD *)(v1 + 32) + 11);
  v17 = (_BYTE *)(*(_DWORD *)(v1 + 32) + 11);
  do
    v24 = *v23++;
  while ( v24 );
  result = v23 - v17;
  v20 = (_BYTE *)(*(_DWORD *)(v1 + 36) - 1);
  do
    v25 = (v20++)[1];
  while ( v25 );
LABEL_25:
  qmemcpy(v20, v17, result);
  v22 = *(const void **)(v1 + 36);
  if ( !memcmp(v22, "-0", 3u) )
    *(_WORD *)v22 = 48;
  return result;
}

//----- (10048EA0) --------------------------------------------------------
char __cdecl sub_10048EA0(int a1, int a2, int a3, int a4, __int16 *a5)
{
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  signed int v8; // ecx@1
  signed int v9; // edx@1
  __int16 v10; // ax@1
  float v12; // [sp+4h] [bp-24h]@1
  float v13; // [sp+8h] [bp-20h]@1
  int v14; // [sp+Ch] [bp-1Ch]@1
  float v15; // [sp+10h] [bp-18h]@1
  int v16; // [sp+14h] [bp-14h]@1
  int v17; // [sp+18h] [bp-10h]@1
  float v18; // [sp+1Ch] [bp-Ch]@1
  float v19; // [sp+20h] [bp-8h]@1
  float v20; // [sp+24h] [bp-4h]@1

  v5 = *(_DWORD *)(a4 + 8);
  v6 = *(_DWORD *)(a4 + 4);
  v15 = *(float *)(a4 + 12);
  v7 = *(_DWORD *)(a4 + 20);
  v18 = *(float *)(a4 + 24);
  v16 = v5;
  v19 = *(float *)(a4 + 28);
  v17 = v6;
  v8 = *(_WORD *)a3;
  v20 = *(float *)(a4 + 16);
  v14 = v7;
  v9 = *(_WORD *)(a3 + 2);
  v12 = (double)v8;
  v10 = *a5;
  v13 = (double)v9;
  if ( v10 == -32648 || v10 == -32734 || v10 == -32704 )
    sub_10048C60(a4);
  if ( (unsigned __int16)*a5 != 32802 )
  {
    if ( (unsigned __int16)*a5 == 32832 )
    {
      sub_10038F40(a1, *(_DWORD *)(a4 + 36), (int)&v12);
      return 2;
    }
    if ( (unsigned __int16)*a5 != 32888 )
      return 1;
  }
  sub_100393C0(a1, *(_DWORD *)(a4 + 36), (int)&v12);
  return 2;
}

//----- (10048F80) --------------------------------------------------------
char __cdecl sub_10048F80(unsigned __int16 a1)
{
  int v1; // eax@2
  char v3; // [sp+Ah] [bp-2h]@1
  char v4; // [sp+Bh] [bp-1h]@1

  v3 = 0;
  v4 = 1;
  if ( a1 > 0x3E7u )
  {
    if ( (unsigned __int16)(a1 - 1000) > 0x3E7u )
    {
      if ( (unsigned __int16)(a1 - 2000) > 0x1F3u )
      {
        sub_10038570(byte_101F0860, 0x64u, "Invalid alert ID (%u) out of range", a1);
        LOBYTE(v1) = sub_10015C20("..\\lib\\adl\\sys_updt_alrt_data.c", 450, 0, byte_101F0860);
      }
      else
      {
        v1 = sub_10016550((unsigned __int16)(a1 - 2000) + 26000, &v3, 1, &v4);
        if ( !v1 && !v3 )
        {
          v3 = 1;
          LOBYTE(v1) = sub_10016450((unsigned __int16)(a1 - 2000) + 26000, (int)&v3, 1);
        }
      }
    }
    else
    {
      v1 = sub_10016550((unsigned __int16)(a1 - 1000) + 27000, &v3, 1, &v4);
      if ( !v1 && !v3 )
      {
        v3 = 1;
        LOBYTE(v1) = sub_10016450((unsigned __int16)(a1 - 1000) + 27000, (int)&v3, 1);
      }
    }
  }
  else
  {
    v1 = sub_10016550(a1 + 28000, &v3, 1, &v4);
    if ( !v1 && !v3 )
    {
      v3 = 1;
      LOBYTE(v1) = sub_10016450(a1 + 28000, (int)&v3, 1);
    }
  }
  return v1;
}

//----- (100490D0) --------------------------------------------------------
int __cdecl sub_100490D0(_BYTE *a1)
{
  return sub_10052AE0(a1, 0, 0x2710u, 5000, 0);
}

//----- (100490F0) --------------------------------------------------------
int __cdecl sub_100490F0(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 5u, 5u, 0);
}

//----- (10049110) --------------------------------------------------------
int __cdecl sub_10049110(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 6u, 0, 0);
}

//----- (10049130) --------------------------------------------------------
int __cdecl sub_10049130(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 0xEu, 1u, 0);
}

//----- (10049150) --------------------------------------------------------
int __cdecl sub_10049150(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 1u, 0, 0);
}

//----- (10049180) --------------------------------------------------------
int __cdecl sub_10049180(int a1)
{
  int result; // eax@1

  result = sub_100490F0((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_10049170(a1 + 12);
    if ( !result )
    {
      result = sub_10049150((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_10049130((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 10049170: using guessed type _DWORD __cdecl sub_10049170(_DWORD);

//----- (100491C0) --------------------------------------------------------
int __cdecl sub_100491C0(int a1)
{
  int result; // eax@1

  result = sub_1005D6F0((void *)(a1 + 28));
  if ( !result )
    result = sub_10049180(a1);
  return result;
}

//----- (100491E0) --------------------------------------------------------
signed int __fastcall sub_100491E0(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (100491F0) --------------------------------------------------------
char __cdecl sub_100491F0(unsigned __int8 a1)
{
  return byte_100CEE24[6 * sub_100491E0(a1)];
}

//----- (10049210) --------------------------------------------------------
__int16 __cdecl sub_10049210(unsigned __int8 a1)
{
  return word_100CEE20[3 * sub_100491E0(a1)];
}
// 100CEE20: using guessed type __int16 word_100CEE20[];

//----- (10049230) --------------------------------------------------------
int __cdecl sub_10049230(int a1)
{
  return a1 + 9;
}

//----- (10049240) --------------------------------------------------------
int __cdecl sub_10049240(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10016030();
  memset(a1, 0, 0xDCu);
  sub_10038570((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_10049230(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_1005D820((int)a1, (int)v3);
}

//----- (100492C0) --------------------------------------------------------
int __cdecl sub_100492C0(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_1005DA30(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (100492F0) --------------------------------------------------------
signed int __cdecl sub_100492F0(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_100836E0(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_100160A0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_100160A0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_1005D820(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (10049310) --------------------------------------------------------
char __cdecl sub_10049310(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_10045390() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10053EE0("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_10046130() )
          v7 = 0;
      }
      v5 = sub_10053EE0("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_10046130() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (10049420) --------------------------------------------------------
char __cdecl sub_10049420(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (10049450) --------------------------------------------------------
bool __cdecl sub_10049450(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (10049480) --------------------------------------------------------
bool __cdecl sub_10049480(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (100494B0) --------------------------------------------------------
bool __cdecl sub_100494B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (100494E0) --------------------------------------------------------
bool __cdecl sub_100494E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (10049510) --------------------------------------------------------
bool __cdecl sub_10049510(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (10049540) --------------------------------------------------------
bool __cdecl sub_10049540(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (10049580) --------------------------------------------------------
bool __cdecl sub_10049580(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (100495C0) --------------------------------------------------------
bool __cdecl sub_100495C0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (100495F0) --------------------------------------------------------
bool __cdecl sub_100495F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (10049620) --------------------------------------------------------
char __cdecl sub_10049620(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (10049650) --------------------------------------------------------
bool __cdecl sub_10049650(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (10049680) --------------------------------------------------------
bool __cdecl sub_10049680(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (100496B0) --------------------------------------------------------
bool __cdecl sub_100496B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (100496E0) --------------------------------------------------------
bool __cdecl sub_100496E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (10049710) --------------------------------------------------------
bool __cdecl sub_10049710(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_100B71B0, 9u);
}

//----- (10049740) --------------------------------------------------------
bool __cdecl sub_10049740(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10049770) --------------------------------------------------------
bool __cdecl sub_10049770(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (100497A0) --------------------------------------------------------
bool __cdecl sub_100497A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (100497D0) --------------------------------------------------------
bool __cdecl sub_100497D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (10049800) --------------------------------------------------------
bool __cdecl sub_10049800(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10049830) --------------------------------------------------------
int __cdecl sub_10049830(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10045390() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (100498A0) --------------------------------------------------------
int __cdecl sub_100498A0(int a1, char a2)
{
  return sub_10049830(a1, (int)&a2, 1);
}

//----- (100498C0) --------------------------------------------------------
int __cdecl sub_100498C0(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10049830(a1, (int)&v4, 2);
}

//----- (100498F0) --------------------------------------------------------
int __cdecl sub_100498F0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10049830(a1, (int)&v5, 3);
}

//----- (10049920) --------------------------------------------------------
int __cdecl sub_10049920(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10049830(a1, (int)&v6, 4);
}

//----- (10049960) --------------------------------------------------------
int __cdecl sub_10049960(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10049830(a1, (int)&v7, 5);
}

//----- (100499A0) --------------------------------------------------------
int __cdecl sub_100499A0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10049830(a1, (int)&v8, 6);
}

//----- (100499F0) --------------------------------------------------------
char __cdecl sub_100499F0(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10045390();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10049A20) --------------------------------------------------------
char __cdecl sub_10049A20(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10049A30) --------------------------------------------------------
char __cdecl sub_10049A30(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = byte_100879F8;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_1005DB50(v16) )
        sub_1005DB30((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_1005DB60((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 1005DB50: using guessed type _DWORD __cdecl sub_1005DB50(_DWORD);
// 10049A30: using guessed type char var_104[255];

//----- (10049BB0) --------------------------------------------------------
signed int __cdecl sub_10049BB0(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (10049BF0) --------------------------------------------------------
signed int __cdecl sub_10049BF0(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10049C90) --------------------------------------------------------
char __cdecl sub_10049C90(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (10049CF0) --------------------------------------------------------
char __cdecl sub_10049CF0(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_1005DB10(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (10049D60) --------------------------------------------------------
char *__cdecl sub_10049D60(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_101F08C8, v1, v2);
  *(&byte_101F08C8 + v2) = 0;
  return &byte_101F08C8;
}

//----- (10049E00) --------------------------------------------------------
int __cdecl sub_10049E00(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10049E70) --------------------------------------------------------
bool __cdecl sub_10049E70(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_10073208(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_10073208(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (10049F00) --------------------------------------------------------
char __cdecl sub_10049F00(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (10049FB0) --------------------------------------------------------
char __cdecl sub_10049FB0(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (10049FC0) --------------------------------------------------------
char __cdecl sub_10049FC0(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_1005DB10(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1004A040) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004A040(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_1005DBE0((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1004A090) --------------------------------------------------------
signed int __cdecl sub_1004A090(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_10049FC0(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1004A0E0) --------------------------------------------------------
char *__cdecl sub_1004A0E0(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10053EE0("CFG_ActDir", (int)byte_100879F8);
      v10 = sub_10053EE0("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10053EE0("CFG_ExpDir", (int)byte_100879F8);
      v10 = sub_10053EE0("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10053EE0("CFG_ActDir", (int)byte_100879F8);
      break;
    case 4:
      v10 = sub_10053EE0("CFG_ExpDir", (int)byte_100879F8);
      break;
    default:
      v10 = byte_100879F8;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = byte_100879F8;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1004A0E0: using guessed type char var_104[256];

//----- (1004A260) --------------------------------------------------------
int sub_1004A260()
{
  return dword_101F55B8[sub_10044450()];
}
// 101F55B8: using guessed type int dword_101F55B8[];

//----- (1004A270) --------------------------------------------------------
const char *__cdecl sub_1004A270(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_100CF3F8[a1];
  return result;
}
// 100CF3F8: using guessed type char *off_100CF3F8[7];

//----- (1004A290) --------------------------------------------------------
int __cdecl sub_1004A290(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10049960(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1004A340) --------------------------------------------------------
int __cdecl sub_1004A340(int a1)
{
  int result; // eax@1

  result = sub_10044450();
  dword_101F76C4[result] = a1;
  return result;
}
// 101F76C4: using guessed type int dword_101F76C4[];

//----- (1004A360) --------------------------------------------------------
int __cdecl sub_1004A360(int a1)
{
  int result; // eax@1

  result = sub_10044450();
  dword_101F55B8[result] = a1;
  return result;
}
// 101F55B8: using guessed type int dword_101F55B8[];

//----- (1004A380) --------------------------------------------------------
char *sub_1004A380(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10044450() << 8;
  _vsnprintf(&byte_101F09C8[v1], 0x100u, a1, va);
  result = &byte_101F09C8[v1];
  byte_101F0AC6[v1] = 42;
  byte_101F0AC7[v1] = 0;
  return result;
}

//----- (1004A3C0) --------------------------------------------------------
char *__usercall sub_1004A3C0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_100CF40C[a1 & 1];
  else
    result = off_100CF404[a2];
  return result;
}
// 100CF404: using guessed type char *off_100CF404[4];
// 100CF40C: using guessed type char *off_100CF40C[2];

//----- (1004A3E0) --------------------------------------------------------
char __usercall sub_1004A3E0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10044450();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1004A260() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_101F8CB8[v6];
      v12 = dword_101F8CCC[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_101F55CC[v6];
      v12 = dword_101F76B0[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 101F55CC: using guessed type int dword_101F55CC[];
// 101F76B0: using guessed type int dword_101F76B0[];
// 101F8CB8: using guessed type int dword_101F8CB8[];
// 101F8CCC: using guessed type int dword_101F8CCC[];

//----- (1004A5C0) --------------------------------------------------------
int sub_1004A5C0()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370");
  return 0;
}

//----- (1004A5E0) --------------------------------------------------------
int sub_1004A5E0()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c", "2396");
}

//----- (1004A600) --------------------------------------------------------
int __cdecl sub_1004A600(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10044450();
  dword_101F76B0[result] = a1;
  if ( a2 >= 0 )
  {
    dword_101F55CC[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1004A380(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10049920(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_101F55CC[result] = 8;
  }
  return result;
}
// 101F55CC: using guessed type int dword_101F55CC[];
// 101F76B0: using guessed type int dword_101F76B0[];

//----- (1004A660) --------------------------------------------------------
int __cdecl sub_1004A660(int a1)
{
  return sub_1004A600(0, a1);
}

//----- (1004A670) --------------------------------------------------------
int __cdecl sub_1004A670(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10044450();
  dword_101F8CCC[result] = a1;
  if ( a2 >= 0 )
  {
    dword_101F8CB8[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1004A380(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10049920(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_101F8CB8[result] = 8;
  }
  return result;
}
// 101F8CB8: using guessed type int dword_101F8CB8[];
// 101F8CCC: using guessed type int dword_101F8CCC[];

//----- (1004A6D0) --------------------------------------------------------
int __cdecl sub_1004A6D0(int a1)
{
  return sub_1004A670(0, a1);
}

//----- (1004A6E0) --------------------------------------------------------
bool __cdecl sub_1004A6E0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_100453B0() )
    v8 = v8 == 0;
  v9 = off_100CF3DC[a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_100CF3CC[v8 != 0];
  v19 = off_100CF3D4[a1];
  v18 = v10;
  v21 = sub_1004A3C0(0, a6);
  v22 = sub_1004A3C0(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_1005DDC0();
  sub_10049830(7, (int)&v14, v11);
  sub_1005DDD0(v12);
  return v8;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004A820) --------------------------------------------------------
bool __cdecl sub_1004A820(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_10044450();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_100453B0() )
    v16 = v16 == 0;
  sub_1004A3E0((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_101F19B8[v11], 0x400u, &v30, a6);
  byte_101F1DB6[v11] = 42;
  byte_101F1DB7[v11] = 0;
  v17 = sub_1004A3E0((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v11], 0x400u, &v30, a7);
  byte_101F21B6[v11] = 42;
  byte_101F21B7[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_101F21B8[v11];
    byte_101F21B8[v11] = 0;
  }
  else
  {
    v17 = sub_1004A3E0((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_101F21B8[v11];
    _snprintf(&byte_101F21B8[v11], 0x400u, &v30, 0);
    byte_101F25B6[v11] = 42;
    byte_101F25B7[v11] = 0;
  }
  v19 = off_100CF3DC[a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_101F19B8[v11];
  v27 = &byte_101F1DB8[v11];
  v13 = off_100CF3D4[a1];
  v23 = off_100CF3CC[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_1005DDC0();
  sub_10049830(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v14);
  return v16;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004ABD0) --------------------------------------------------------
bool __cdecl sub_1004ABD0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10044450();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_100453B0() )
    v20 = v20 == 0;
  sub_1004A3E0((int)&v34, (char *)&unk_100CF6C0, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v34);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v21 = sub_1004A3E0((int)&v34, (char *)&unk_100CF6C0, 3, 0xCu, a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v34, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v13 = &byte_101F21B8[v12];
    v21 = sub_1004A3E0((int)&v34, (char *)&unk_100CF6C0, 3, 0xCu, v10);
    _snprintf(&byte_101F21B8[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v23 = off_100CF3DC[a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_101F19B8[v12];
  v32 = v13;
  v17 = off_100CF3D4[a1];
  v27 = off_100CF3CC[v20 != 0];
  v28 = v17;
  v31 = &byte_101F1DB8[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_1005DDC0();
  sub_10049830(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v18);
  return v20;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004B020) --------------------------------------------------------
bool __cdecl sub_1004B020(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_10044450();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_100453B0() )
    v25 = v25 == 0;
  sub_1004A3E0((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_101F19B8[v20], 0x400u, &v40);
  byte_101F1DB6[v20] = 42;
  byte_101F1DB7[v20] = 0;
  v26 = sub_1004A3E0((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_101F1DB8[v20], 0x400u, &v40, a7);
  byte_101F21B6[v20] = 42;
  byte_101F21B7[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_101F21B8[v20];
    byte_101F21B8[v20] = 0;
  }
  else
  {
    v21 = &byte_101F21B8[v20];
    v26 = sub_1004A3E0((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_101F21B8[v20], 0x400u, &v40, v28);
    byte_101F25B6[v20] = 42;
    byte_101F25B7[v20] = 0;
  }
  v29 = off_100CF3DC[a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_101F19B8[v20];
  v37 = &byte_101F1DB8[v20];
  v38 = v21;
  v22 = off_100CF3CC[v25 != 0];
  v34 = off_100CF3D4[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_1005DDC0();
  sub_10049830(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v23);
  return v25;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004B4E0) --------------------------------------------------------
bool __cdecl sub_1004B4E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v18 = sub_1004A3E0((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_101F21B8[v12];
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_100CF6FC;
  v27 = &byte_101F19B8[v12];
  v28 = &byte_101F1DB8[v12];
  v29 = v13;
  v14 = off_100CF3CC[v17 != 0];
  v25 = off_100CF3D4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004B8A0) --------------------------------------------------------
bool __cdecl sub_1004B8A0(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v13 = &byte_101F21B8[v12];
    v18 = sub_1004A3E0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101F19B8[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_101F1DB8[v12];
  v29 = v13;
  v14 = off_100CF3D4[a1];
  v24 = off_100CF3CC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004BCA0) --------------------------------------------------------
bool __cdecl sub_1004BCA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v18 = sub_1004A3E0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_101F21B8[v12];
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_101F19B8[v12];
  v28 = &byte_101F1DB8[v12];
  v29 = v13;
  v14 = off_100CF3CC[v17 != 0];
  v25 = off_100CF3D4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004C060) --------------------------------------------------------
bool __cdecl sub_1004C060(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_10044450();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_100453B0() )
        v18 = v18 == 0;
      sub_1004A3E0((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_101F19B8[3072 * v21], 0x400u, &v33, a6);
      byte_101F1DB6[v13] = 42;
      byte_101F1DB7[v13] = 0;
      v19 = sub_1004A3E0((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_101F1DB8[3072 * v21], 0x400u, &v33, a7);
      byte_101F21B6[v13] = 42;
      byte_101F21B7[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_101F21B8[v13];
        byte_101F21B8[v13] = 0;
      }
      else
      {
        v19 = sub_1004A3E0((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_101F21B8[v13];
        _snprintf(&byte_101F21B8[v13], 0x400u, &v33, a8);
        byte_101F25B6[v13] = 42;
        byte_101F25B7[v13] = 0;
      }
      v22 = off_100CF3DC[a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_101F19B8[3072 * v21];
      v30 = &byte_101F1DB8[3072 * v21];
      v15 = off_100CF3D4[a1];
      v26 = off_100CF3CC[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_1005DDC0();
      sub_10049830(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3, a4);
        sub_10049920(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1005DDD0(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004C5A0) --------------------------------------------------------
bool __cdecl sub_1004C5A0(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v13 = &byte_101F21B8[v12];
    v18 = sub_1004A3E0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101F19B8[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_101F1DB8[v12];
  v29 = v13;
  v14 = off_100CF3D4[a1];
  v24 = off_100CF3CC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004C980) --------------------------------------------------------
bool __cdecl sub_1004C980(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v18 = sub_1004A3E0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_101F21B8[v12];
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_101F19B8[v12];
  v28 = &byte_101F1DB8[v12];
  v29 = v13;
  v14 = off_100CF3CC[v17 != 0];
  v25 = off_100CF3D4[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004CD40) --------------------------------------------------------
bool __cdecl sub_1004CD40(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v18 = sub_1004A3E0((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_101F21B8[v12];
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_100CF3CC[v17 != 0];
  v25 = off_100CF3D4[a1];
  v24 = v14;
  v27 = &byte_101F19B8[v12];
  v28 = &byte_101F1DB8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004D0E0) --------------------------------------------------------
bool __cdecl sub_1004D0E0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v13 = &byte_101F21B8[v12];
    v18 = sub_1004A3E0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101F19B8[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_101F1DB8[v12];
  v29 = v13;
  v14 = off_100CF3D4[a1];
  v24 = off_100CF3CC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004D4E0) --------------------------------------------------------
bool __cdecl sub_1004D4E0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v18 = sub_1004A3E0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_101F21B8[v12];
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_100CF3CC[v17 != 0];
  v25 = off_100CF3D4[a1];
  v24 = v14;
  v27 = &byte_101F19B8[v12];
  v28 = &byte_101F1DB8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004D880) --------------------------------------------------------
bool __cdecl sub_1004D880(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_10044450();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_100453B0() )
        v19 = v19 == 0;
      sub_1004A3E0((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_101F19B8[3072 * v22];
      _snprintf(&byte_101F19B8[3072 * v22], 0x400u, &v35, a6);
      byte_101F1DB6[v13] = 42;
      byte_101F1DB7[v13] = 0;
      v20 = sub_1004A3E0((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_101F1DB8[3072 * v22];
      _snprintf(&byte_101F1DB8[v13], 0x400u, &v35, a7);
      byte_101F21B6[v13] = 42;
      byte_101F21B7[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_101F21B8[v13];
        byte_101F21B8[v13] = 0;
      }
      else
      {
        v20 = sub_1004A3E0((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_101F21B8[v13];
        _snprintf(&byte_101F21B8[v13], 0x400u, &v35, a8);
        byte_101F25B6[v13] = 42;
        byte_101F25B7[v13] = 0;
      }
      v24 = off_100CF3DC[a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_100CF3D4[a1];
      v28 = off_100CF3CC[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_1005DDC0();
      sub_10049830(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3, a4);
        sub_10049920(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_1005DDD0(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004DE60) --------------------------------------------------------
bool __cdecl sub_1004DE60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v13 = &byte_101F21B8[v12];
    v18 = sub_1004A3E0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_101F19B8[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_101F1DB8[v12];
  v29 = v13;
  v14 = off_100CF3D4[a1];
  v24 = off_100CF3CC[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004E250) --------------------------------------------------------
bool __cdecl sub_1004E250(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10044450();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_100453B0() )
    v17 = v17 == 0;
  sub_1004A3E0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_101F19B8[v12], 0x400u, &v31, a6);
  byte_101F1DB6[v12] = 42;
  byte_101F1DB7[v12] = 0;
  v18 = sub_1004A3E0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_101F1DB8[v12], 0x400u, &v31, a7);
  byte_101F21B6[v12] = 42;
  byte_101F21B7[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_101F21B8[v12];
    byte_101F21B8[v12] = 0;
  }
  else
  {
    v18 = sub_1004A3E0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_101F21B8[v12];
    _snprintf(&byte_101F21B8[v12], 0x400u, &v31, a8);
    byte_101F25B6[v12] = 42;
    byte_101F25B7[v12] = 0;
  }
  v20 = off_100CF3DC[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_100CF3CC[v17 != 0];
  v25 = off_100CF3D4[a1];
  v24 = v14;
  v27 = &byte_101F19B8[v12];
  v28 = &byte_101F1DB8[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_1005DDC0();
  sub_10049830(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10049920(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_1005DDD0(v15);
  return v17;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004E5F0) --------------------------------------------------------
int sub_1004E5F0()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10044450();
  sub_1004A340(1);
  sub_1004A6D0(-1);
  result = sub_1004A660(-1);
  dword_101F55B8[v0] = 0;
  return result;
}
// 101F55B8: using guessed type int dword_101F55B8[];

//----- (1004E620) --------------------------------------------------------
BOOL __usercall sub_1004E620@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10044450();
  sub_1005DE00((int)&v13);
  sub_1005DE00((int)&v14);
  sub_1005DE00((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_1005EA50((int (__cdecl *)(unsigned int))sub_1004A5C0, v7, (int)&v13) )
  {
    if ( sub_1005EA50((int (__cdecl *)(unsigned int))sub_1004A5C0, a2, (int)&v14) )
    {
      v9 = sub_1005E8C0(
             dword_101F76C4[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1004A5C0,
             (void (__cdecl *)(_DWORD))sub_1004A5E0,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_1005ECF0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_1005DED0((void (__cdecl *)(_DWORD))sub_1004A5E0, (int)&v12);
  sub_1005DED0((void (__cdecl *)(_DWORD))sub_1004A5E0, (int)&v13);
  sub_1005DED0((void (__cdecl *)(_DWORD))sub_1004A5E0, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 101F76C4: using guessed type int dword_101F76C4[];

//----- (1004E790) --------------------------------------------------------
bool __usercall sub_1004E790@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10044450();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_100453B0() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1004CD40(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_100453B0() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_101F19B8[3072 * v24], 0x400u, "%s", v9);
  byte_101F1DB6[v15] = 42;
  byte_101F1DB7[v15] = 0;
  _snprintf(&byte_101F1DB8[3072 * v24], 0x400u, "%s", v22);
  v16 = off_100CF3DC[a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_101F21B6[v15] = 42;
  v17 = off_100CF3CC[v14 != 0];
  v18 = off_100CF3D4[a3];
  byte_101F21B7[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_101F19B8[3072 * v24];
  v34 = &byte_101F1DB8[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_1005DDC0();
  sub_10049830(7, (int)&v26, v19);
  sub_1005DDD0(v20);
  return v14;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];

//----- (1004EA00) --------------------------------------------------------
char __cdecl sub_1004EA00(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10044450();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_101F76C4[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_101F8CE0[v10];
  sub_1004A0E0(a3, 1, a6, 0x230u, &byte_101F8CE0[v10]);
  v27 = &byte_101F55E0[v10];
  sub_1004A0E0(a3, 2, a7, 0x230u, &byte_101F55E0[v10]);
  v24 = &byte_101F6BC0[v10];
  sub_1004A0E0(a3, 3, a6, 0x230u, &byte_101F6BC0[v10]);
  v26 = &byte_101F76D8[v10];
  sub_1004A0E0(a3, 4, a7, 0x230u, &byte_101F76D8[v10]);
  _snprintf(&byte_101F81C8[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_101F81C8[v10];
  byte_101F83F7[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1004A0E0(a3, 0, v25, 560 - (v11 - &byte_101F81C8[v10 + 1]), &byte_101F81C8[v10] + v11 - &byte_101F81C8[v10 + 1]);
  v13 = &byte_101F81C8[v10];
  byte_101F83F7[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_101F81C4[v10] + v13 - &byte_101F81C8[v10 + 1]) = 0;
  sub_1004A0E0(a3, 1, (int)&byte_101F81C8[v10], 0x230u, &byte_101F0EC8[v10]);
  sub_1004A0E0(a3, 1, (int)&byte_101F81C8[v10], 0x230u, &byte_101F60D0[v10]);
  v15 = sub_1004E620(v22, v27, v21, a2 == 1, (int)&byte_101F0EC8[v10], (const char **)&v22);
  if ( sub_100453B0() )
    v15 = v15 == 0;
  v30 = off_100CF3DC[a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_100CF3D4[a1];
  v34 = off_100CF3CC[v15 != 0];
  v17 = dword_101F76C4[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_1005DDC0();
  sub_10049830(7, (int)&v30, v18);
  sub_1005DDD0(v19);
  return v15;
}
// 100CF3CC: using guessed type char *off_100CF3CC[18];
// 100CF3D4: using guessed type char *off_100CF3D4[16];
// 100CF3DC: using guessed type char *off_100CF3DC[14];
// 101F76C4: using guessed type int dword_101F76C4[];

//----- (1004ED00) --------------------------------------------------------
bool __cdecl sub_1004ED00(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1004B4E0(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (1004EDB0) --------------------------------------------------------
bool __cdecl sub_1004EDB0(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_1004E790(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (1004EDF0) --------------------------------------------------------
const char *__cdecl sub_1004EDF0(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1004EE30) --------------------------------------------------------
char __cdecl sub_1004EE30(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  char *v39; // ebx@106
  char *v40; // edi@109
  char *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  char *v51; // [sp+18h] [bp-314h]@94
  char *v52; // [sp+1Ch] [bp-310h]@97
  char *v53; // [sp+20h] [bp-30Ch]@103
  char *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10044450();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_101F97D8 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1004A090((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_10049BB0((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1004A090((int)v6, 0);
      return v5;
    case 4:
      sub_10049A30((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_10049D60((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1004A040((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_10049A20((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_10049420((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1004EDF0((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1004A040((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1004A040((int)v6, v55);
        if ( v48 )
          sub_1004A040((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1004A040((int)v6, v55);
        if ( v48 )
          sub_1004A040((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], &word_100897F0, 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1004A040((int)v6, v55);
              if ( v48 )
                sub_1004A040((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = (char)(&v54)[v14 + 3];
          if ( v16 != 10 && v16 != 13 )
            break;
          LOBYTE((&v54)[4 * --v14 + 13]) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1004A040((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1004A040((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1004A040((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1004A040((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_10049C90((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_10049740((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_10049800((const void **)a2, a3)
          || (LOBYTE(v5) = sub_10049650((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = byte_100879F8;
          else
            v51 = (char *)a2[8];
          if ( a3 <= 7 )
            v52 = byte_100879F8;
          else
            v52 = (char *)a2[7];
          if ( a3 <= 6 )
            v54 = byte_100879F8;
          else
            v54 = (char *)a2[6];
          if ( a3 <= 5 )
            v53 = byte_100879F8;
          else
            v53 = (char *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = byte_100879F8;
          }
          else
          {
            v38 = a2;
            v39 = (char *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = byte_100879F8;
          else
            v40 = (char *)v38[3];
          if ( a3 )
            v41 = (char *)*v38;
          else
            v41 = byte_100879F8;
          v10 = sub_10049710((const void **)a2, a3) == 0;
          v42 = byte_100879F8;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_10049450((const void **)a2, a3) )
      {
        dword_101F97D0 = 2;
        sub_1004A040((int)v6, (const char *)&word_10085470);
        sub_1004A040((int)v6, "   Command Format:\r\n");
        sub_1004A040(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1004A040(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1004A040(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1004A040(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1004A040((int)v6, "                                         strings depending upon the command\r\n");
        sub_1004A040((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1004A040(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1004A040(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1004A040((int)v6, (const char *)&word_10085470);
        sub_1004A040((int)v6, "   Notes:\r\n");
        sub_1004A040((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1004A040((int)v6, (const char *)&word_10085470);
        sub_1004A040(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1004A040(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1004A040(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1004A040((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1004A040((int)v6, (const char *)&word_10085470);
        sub_1004A040(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1004A040(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1004A040((int)v6, "       without a test suite name.\r\n");
        sub_1004A040((int)v6, (const char *)&word_10085470);
        sub_1004A040((int)v6, "   Examples:\r\n");
        sub_1004A040(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1004A040((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1004A040(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1004A040(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1004A040(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1004A040(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1004A040(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1004A040(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1004A040((int)v6, (const char *)&word_10085470);
        sub_1004A040((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1004A040(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_100494E0((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, (const char *)&word_10085470);
        return v5;
      }
      if ( sub_100494B0((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_101F97D0,
          byte_100879F8,
          &v58,
          6 - dword_101F97D0,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, v55);
        return v5;
      }
      if ( sub_10049510((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_10049540((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_101F97D0 += 2;
          return v5;
        }
        if ( sub_10049580((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_101F97D0 < 2 )
            dword_101F97D0 = 0;
          else
            dword_101F97D0 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_101F97D0,
          byte_100879F8,
          a2[2],
          6 - dword_101F97D0,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, v55);
        return v5;
      }
      if ( sub_10049480((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_101F97D0,
          byte_100879F8,
          a2[3],
          6 - dword_101F97D0,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_100495F0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, v55);
      }
      else if ( sub_100495C0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1004EDF0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1004A040((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1004A040((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1004A040((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1004EDF0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1004A040((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1004A040((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1004A040((int)v6, v55);
      }
      LOBYTE(v5) = sub_10049CF0((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_10049FC0((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1004A040((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 10085470: using guessed type __int16 word_10085470;
// 100897F0: using guessed type __int16 word_100897F0;
// 101F97D0: using guessed type int dword_101F97D0;
// 1004EE30: using guessed type char var_304[508];

//----- (1004FBE0) --------------------------------------------------------
signed int __cdecl sub_1004FBE0(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_101F97D8 + 580 * sub_10044450();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_10049BF0(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (1004FC60) --------------------------------------------------------
char **__cdecl sub_1004FC60(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_101F97D8 + 580 * sub_10044450();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_10049E00((int)v1, a1, (int)".txt");
  return &off_100CFAB8;
}
// 100CFAB8: using guessed type char *off_100CFAB8;

//----- (1004FCA0) --------------------------------------------------------
int (**sub_1004FCA0())()
{
  return off_100D07A0;
}
// 100D07A0: using guessed type int (*off_100D07A0[2])();

//----- (1004FCB0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004FCB0(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10044450();
  return sub_1004A040((int)&unk_101FA330 + 1812 * v1, a1);
}

//----- (1004FCD0) --------------------------------------------------------
const char *sub_1004FCD0()
{
  return "See version control for test execution date";
}

//----- (1004FCE0) --------------------------------------------------------
__int64 sub_1004FCE0()
{
  return 0i64;
}

//----- (1004FCF0) --------------------------------------------------------
const char *sub_1004FCF0()
{
  return "Not Available";
}

//----- (1004FD00) --------------------------------------------------------
int __usercall sub_1004FD00@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (1004FD50) --------------------------------------------------------
signed int __cdecl sub_1004FD50(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10044450();
  return sub_10049BF0(a1, a2, (int)&unk_101FA330 + 1812 * v2);
}

//----- (1004FEA0) --------------------------------------------------------
int __usercall sub_1004FEA0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_100666E0((int)&a2[151 * (*a2 + 1)], (int)sub_1004FCB0, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_1004FCE0();
  v4 = sub_10053EE0("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_10066B30((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10053EE0("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_10066B30((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_10066B30((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_10066AB0((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_10066940((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10053EE0("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10044500(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_10066B80((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_10066B80((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_10066AB0((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_10066AB0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_10066B80((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_10049D60(v3);
  sub_10066B80((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_10066A30((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10053EA0(i, &v15, &v16); ++i )
  {
    sub_10066AB0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_10066B80((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_10066B80((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_10066A30((int)&a2[151 * (*a2 + 1)]);
  }
  sub_10066A30((int)&a2[151 * (*a2 + 1)]);
  sub_10066AB0((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_10066940((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 1004FEA0: using guessed type char var_103[253];

//----- (10050220) --------------------------------------------------------
char __cdecl sub_10050220(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10044450();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_101FA330 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_100497A0(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_1004FD00(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_10066AB0(v8, (int)"Req");
            sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_10049770(a2, a3) )
      {
        if ( sub_10049F00((int)v5, 3, 1, 0) )
          sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_10066A30(v12);
          sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_10066940(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_100496B0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10066B80(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_100497D0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_10066B80(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10049740(a2, a3) )
      {
        if ( sub_10049F00((int)v5, 3, 1, 0) )
          sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10049E70((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_100496E0(a2, a3) )
      {
        sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_10066940(v13, (int)"success", (unsigned __int8 *)&word_100897F0);
          sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_10066940(v13, (int)"success", (unsigned __int8 *)&unk_100897E8);
        }
        if ( v5[309] )
        {
          sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10049F00((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_10049680(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_10049FB0((int)v5) )
            sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_10066B80((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_10049F00((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_10049A30((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_1004FEA0((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_10049A20((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_10066B80(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_10066B80(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_10066B80((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_10049FB0((int)v5) )
        sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_10049620((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_100669E0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_10066B80((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_10049420((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_10066990((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_10066990((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_10066990((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, "NE", 3u) )
              v44 = byte_100879F8;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], &word_100897F0, 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_10066AB0(v19, (int)"Expected");
          sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_10049F00((int)v5, 8, 1, 0) )
        sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_10049C90((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_10049CF0((int)v5, (void (__cdecl *)(int))sub_1004FD80);
      return v4;
    case 0:
    case 11:
      sub_1004A090((int)v5, (void (__cdecl *)(int))sub_1004FD80);
      goto LABEL_139;
    case 1:
      sub_10049BB0((int)v5);
      goto LABEL_139;
    case 12:
      sub_10049FC0((int)v5, (void (__cdecl *)(int))sub_1004FD80);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_10066AB0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_10066940((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_10049F00((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_10066A30((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 1004FD80: using guessed type int sub_1004FD80();
// 100897F0: using guessed type __int16 word_100897F0;
// 10050220: using guessed type char var_104[255];

//----- (10051040) --------------------------------------------------------
char **__cdecl sub_10051040(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_101FA330 + 1812 * sub_10044450();
  *((_DWORD *)v1 + 146) = 0;
  sub_10049E00((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_100666E0(v2, (int)sub_1004FCB0, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_100D0850;
}
// 100D0850: using guessed type char *off_100D0850;

//----- (100510B0) --------------------------------------------------------
int __cdecl sub_100510B0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101FC694 = *(_DWORD *)a1;
  dword_101FC698 = *(_DWORD *)(a1 + 4);
  dword_101FC69C = *(_DWORD *)(a1 + 8);
  dword_101FC6A0 = *(_DWORD *)(a1 + 12);
  dword_102D22AC = (int)&dword_101FC694;
  return result;
}
// 101FC694: using guessed type int dword_101FC694;
// 101FC698: using guessed type int dword_101FC698;
// 101FC69C: using guessed type int dword_101FC69C;
// 101FC6A0: using guessed type int dword_101FC6A0;
// 102D22AC: using guessed type int dword_102D22AC;

//----- (100510F0) --------------------------------------------------------
char sub_100510F0()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10016420(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 100510F0: using guessed type int var_1C[7];

//----- (10051170) --------------------------------------------------------
char __cdecl sub_10051170(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_100430B0((_DWORD *)a2, 2u, (int)&unk_100D19A8, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100D19AC[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_100161D0(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10016030();
        sub_10038570(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10015C20("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100D19AC: using guessed type int dword_100D19AC[];

//----- (10051290) --------------------------------------------------------
char __cdecl sub_10051290(int a1)
{
  return sub_10051170(31, a1);
}

//----- (100512A0) --------------------------------------------------------
unsigned int __cdecl sub_100512A0(char *a1)
{
  return sub_10052920(a1, -100, 100, 0, 0);
}

//----- (100512C0) --------------------------------------------------------
int __cdecl sub_100512C0(_BYTE *a1)
{
  return sub_10052B80(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (100512E0) --------------------------------------------------------
int __cdecl sub_100512E0(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 1u, 1u, 0);
}

//----- (10051300) --------------------------------------------------------
unsigned int __cdecl sub_10051300(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100527E0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10052A90((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_100527E0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052A90((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052A90((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10051630) --------------------------------------------------------
unsigned int __cdecl sub_10051630(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100527E0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100527E0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10052920((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10051A70) --------------------------------------------------------
unsigned int __cdecl sub_10051A70(_BYTE *a1)
{
  return sub_10052970(a1, -1, 5, -1, 0);
}

//----- (10051A90) --------------------------------------------------------
int __cdecl sub_10051A90(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 5u, 0, 0);
}

//----- (10051AB0) --------------------------------------------------------
int __cdecl sub_10051AB0(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 4u, 2u, 0);
}

//----- (10051AD0) --------------------------------------------------------
int __cdecl sub_10051AD0(_BYTE *a1)
{
  return sub_10052B80(a1, 0, 2u, 0, 0);
}

//----- (10051AF0) --------------------------------------------------------
int __cdecl sub_10051AF0(int a1)
{
  return sub_10052830(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10051B40) --------------------------------------------------------
int __cdecl sub_10051B40(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10051AF0((int)(a1 + 4));
  if ( !result )
    result = sub_10051AB0(a1);
  return result;
}

//----- (10051B60) --------------------------------------------------------
int __cdecl sub_10051B60(int a1)
{
  int result; // eax@1

  result = sub_10051A90((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10051A90((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10051A90((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_1005D5E0((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_100527E0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_100527E0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_100527E0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_100527E0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10051BF0) --------------------------------------------------------
unsigned int __cdecl sub_10051BF0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10051A70((_BYTE *)a1);
  if ( !result )
    result = sub_10051A70((_BYTE *)(a1 + 4));
  return result;
}

//----- (10051C10) --------------------------------------------------------
signed int __cdecl sub_10051C10(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_100527E0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_100527E0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (10051C60) --------------------------------------------------------
unsigned int __cdecl sub_10051C60(int a1)
{
  unsigned int result; // eax@1

  result = sub_10051A70((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10051A70((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10051A70((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10051A70((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_100527E0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10051CC0) --------------------------------------------------------
int __cdecl sub_10051CC0(_BYTE *a1)
{
  return sub_10052B80(a1, 0, 0x20u, 2u, 0);
}

//----- (10051CE0) --------------------------------------------------------
unsigned int __cdecl sub_10051CE0(_BYTE *a1)
{
  return sub_10052970(a1, -1, 4, -1, 0);
}

//----- (10051D00) --------------------------------------------------------
int __cdecl sub_10051D00(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 9u, 0, 0);
}

//----- (10051D20) --------------------------------------------------------
int __cdecl sub_10051D20(_BYTE *a1)
{
  return sub_10052B80(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (10051D40) --------------------------------------------------------
signed int __cdecl sub_10051D40(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10052B80(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10051D70) --------------------------------------------------------
int __cdecl sub_10051D70(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10052AE0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10051DB0) --------------------------------------------------------
signed int __cdecl sub_10051DB0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10052AE0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10051DE0) --------------------------------------------------------
int __cdecl sub_10051DE0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_10051D40((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_10051D70((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10051D70((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10047CA0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10051D70((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10051E70) --------------------------------------------------------
int __cdecl sub_10051E70(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 2u, 0, 0);
}

//----- (10051E90) --------------------------------------------------------
int __cdecl sub_10051E90(int a1)
{
  int result; // eax@1

  result = sub_10052A90((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10052A90((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10051EC0) --------------------------------------------------------
int __cdecl sub_10051EC0(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 3u, 1u, 0);
}

//----- (10051EE0) --------------------------------------------------------
unsigned int __cdecl sub_10051EE0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10052970((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10052970((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10051F10) --------------------------------------------------------
int __cdecl sub_10051F10(int a1)
{
  int result; // eax@1

  result = sub_10052830(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10052830(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10052830(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10052830(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10052830(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10052000) --------------------------------------------------------
int __cdecl sub_10052000(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100527E0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10052A90((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10051EE0(a1 + 36);
        if ( !result )
        {
          result = sub_10052830(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10051F10(a1 + 8);
            if ( !result )
            {
              result = sub_10051EE0(a1 + 28);
              if ( !result )
              {
                result = sub_10052AE0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_10051E70((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10051E90(a1 + 57);
                    if ( !result )
                    {
                      result = sub_100527E0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10051EC0((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10052110) --------------------------------------------------------
signed int __cdecl sub_10052110(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10052A90(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10052140) --------------------------------------------------------
int __cdecl sub_10052140(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_100491C0(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (10052170) --------------------------------------------------------
int __cdecl sub_10052170(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 0x64u, 0x64u, 0);
}

//----- (100521D0) --------------------------------------------------------
int __cdecl sub_100521D0(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100527E0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10052170((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (100521E0) --------------------------------------------------------
signed int __cdecl sub_100521E0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10052B80(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10052210) --------------------------------------------------------
int __cdecl sub_10052210(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10052A90((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10052A90((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10052290) --------------------------------------------------------
signed int __cdecl sub_10052290(int a1)
{
  signed int result; // eax@1

  result = sub_100527E0((_BYTE *)(a1 + 5), 0, 0);
  if ( !result )
  {
    result = sub_100527E0((_BYTE *)a1, 0, 0);
    if ( !result )
    {
      result = sub_100527E0((_BYTE *)(a1 + 6), 0, 0);
      if ( !result )
      {
        result = sub_100527E0((_BYTE *)(a1 + 7), 0, 0);
        if ( !result )
        {
          result = sub_10047CD0((unsigned __int8 *)(a1 + 2));
          if ( !result )
          {
            result = sub_10047CD0((unsigned __int8 *)(a1 + 3));
            if ( !result )
            {
              result = sub_10047CD0((unsigned __int8 *)(a1 + 4));
              if ( !result )
                result = sub_100527E0((_BYTE *)(a1 + 1), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10052330) --------------------------------------------------------
int __cdecl sub_10052330(int a1)
{
  int result; // eax@1

  result = sub_100490D0((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_100490D0((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_10047CD0((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_10052320(a1 + 24);
        if ( !result )
        {
          result = sub_10047CD0((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_10047C80((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_10047CD0((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 10052320: using guessed type _DWORD __cdecl sub_10052320(_DWORD);

//----- (100523B0) --------------------------------------------------------
unsigned int __cdecl sub_100523B0(int a1)
{
  unsigned int result; // eax@1

  result = sub_100512A0((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_100512A0((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_100512A0((char *)a1);
      if ( !result )
        result = sub_100512A0((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (100523F0) --------------------------------------------------------
unsigned int __cdecl sub_100523F0(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_100523B0(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_10051E70((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_100512E0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10052440) --------------------------------------------------------
int __cdecl sub_10052440(int a1)
{
  int result; // eax@1

  result = sub_100512C0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_10052AE0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10052470) --------------------------------------------------------
int __cdecl sub_10052470(int a1)
{
  int result; // eax@1

  result = sub_10051AD0((_BYTE *)a1);
  if ( !result )
    result = sub_10051D20((_BYTE *)(a1 + 4));
  return result;
}

//----- (100524A0) --------------------------------------------------------
unsigned int __cdecl sub_100524A0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10051A70((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10051A70((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10051CE0((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (100524D0) --------------------------------------------------------
unsigned int __cdecl sub_100524D0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10051A70((_BYTE *)a1);
  if ( !result )
    result = sub_10051D00((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (100524F0) --------------------------------------------------------
unsigned int __cdecl sub_100524F0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10051A70((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10052A90((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10051CE0((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10052530) --------------------------------------------------------
void __cdecl __noreturn sub_10052530(int a1)
{
  exit_1(a1 + 4);
}

//----- (100526A0) --------------------------------------------------------
signed int __cdecl sub_100526A0(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10052110((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10051DB0((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10052110((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10052700) --------------------------------------------------------
signed int __usercall sub_10052700@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_100526A0(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10052A90((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_100527E0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10051630(v2 + 5, a2);
    else
      result = sub_10051300(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_100521E0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (100527D0) --------------------------------------------------------
signed int __cdecl sub_100527D0(int a1)
{
  return sub_10052700(a1, 0);
}

//----- (100527E0) --------------------------------------------------------
signed int __cdecl sub_100527E0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10052830) --------------------------------------------------------
int __cdecl sub_10052830(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10052920) --------------------------------------------------------
unsigned int __cdecl sub_10052920(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10052970) --------------------------------------------------------
unsigned int __cdecl sub_10052970(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10052A30) --------------------------------------------------------
unsigned int __cdecl sub_10052A30(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_100384A0(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10052A90) --------------------------------------------------------
int __cdecl sub_10052A90(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10052AE0) --------------------------------------------------------
int __cdecl sub_10052AE0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10052B80) --------------------------------------------------------
int __cdecl sub_10052B80(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10052C30) --------------------------------------------------------
char __cdecl sub_10052C30(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_10052E30(a1, &v5, &v4) && sub_1003E940(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_10016420(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 10052C30: using guessed type char var_408[1028];

//----- (10052CD0) --------------------------------------------------------
char __cdecl sub_10052CD0(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10066FA0(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10066DA0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10066E20(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10066EA0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_10066F20(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (10052DE0) --------------------------------------------------------
int __cdecl sub_10052DE0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100430B0(&a1, 1u, (int)&unk_100D32E8, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100D32EC[2 * v1];
  }
  return result;
}
// 100D32EC: using guessed type int dword_100D32EC[];

//----- (10052E30) --------------------------------------------------------
char __cdecl sub_10052E30(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_100D3330[4 * a1];
    *a3 = word_100D3332[2 * a1];
    result = 1;
  }
  else
  {
    sub_10015C20("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 100D3332: using guessed type __int16 word_100D3332[];

//----- (10052E90) --------------------------------------------------------
char __cdecl sub_10052E90(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_10015C20("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100FFBA8[8 * a1];
  *a4 = word_100FFBAA[a2 + 4 * a1];
  return 1;
}
// 100FFBAA: using guessed type __int16 word_100FFBAA[];

//----- (10052EF0) --------------------------------------------------------
char __cdecl sub_10052EF0(char a1)
{
  char result; // al@1

  result = sub_10067040();
  if ( result == 2 )
    result = byte_100D4044[8 * sub_100430B0(&a1, 4u, (int)&unk_100D4040, 8, 7, 7)];
  return result;
}

//----- (10052F20) --------------------------------------------------------
char __thiscall sub_10052F20(void *this)
{
  char v1; // al@1

  v1 = sub_100405D0(this);
  return sub_10052EF0(v1);
}

//----- (10052F30) --------------------------------------------------------
signed int __cdecl sub_10052F30(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_100D4158;
    v6 = &unk_100D4158;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_100D4170;
    v6 = &unk_100D4170;
    v5 = &a1;
  }
  v3 = sub_100430B0(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10052F90) --------------------------------------------------------
int __cdecl sub_10052F90(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100430B0(&a1, 1u, (int)&unk_100D41B8, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100D41BC[2 * v1];
  return result;
}
// 100D41BC: using guessed type int dword_100D41BC[];

//----- (10052FD0) --------------------------------------------------------
signed int __cdecl sub_10052FD0(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_100D41C8;
    v7 = &unk_100D41C8;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_100D41E0;
    v7 = &unk_100D41E0;
    v6 = &a1;
  }
  v4 = sub_100430B0(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (10053040) --------------------------------------------------------
int __cdecl sub_10053040(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100430B0(&a1, 1u, (int)&unk_100D41F8, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_100D41FC[2 * v1];
  return result;
}
// 100D41FC: using guessed type int dword_100D41FC[];

//----- (10053080) --------------------------------------------------------
int __cdecl sub_10053080(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100430B0(&a1, 1u, (int)&unk_100D4210, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100D4214[2 * v1];
  return result;
}
// 100D4214: using guessed type int dword_100D4214[];

//----- (100530C0) --------------------------------------------------------
char __cdecl sub_100530C0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10052F30(a1, 11);
  return sub_100163A0(v2, a2, 24);
}

//----- (100530E0) --------------------------------------------------------
char __cdecl sub_100530E0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10052F90(a1);
  return sub_100163A0(v2, a2, 2720);
}

//----- (10053110) --------------------------------------------------------
char __cdecl sub_10053110(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10052FD0(a1, 11, 1);
  sub_100163A0(v2, a2, 36);
  v3 = sub_10052FD0(a1, 11, 0);
  return sub_100163A0(v3, a2 + 36, 32);
}

//----- (10053160) --------------------------------------------------------
char __cdecl sub_10053160(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10053040(a1);
  return sub_100163A0(v2, a2, 2192);
}

//----- (10053190) --------------------------------------------------------
char __cdecl sub_10053190(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10053080(a1);
  return sub_100163A0(v2, a2, 60);
}

//----- (100531B0) --------------------------------------------------------
char __cdecl sub_100531B0(int a1)
{
  return sub_100163A0(6453, a1, 5);
}

//----- (100531D0) --------------------------------------------------------
char __cdecl sub_100531D0(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_1003F250(1, v2, a2) || sub_10052330((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10053280) --------------------------------------------------------
char __cdecl sub_10053280(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+11h] [bp-CC3h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_100531D0(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 3;
  return result;
}

//----- (100532E0) --------------------------------------------------------
int __cdecl sub_100532E0(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 10083990: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10053350) --------------------------------------------------------
bool __cdecl sub_10053350(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_10037E30(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100D6448[(unsigned __int8)v4](v3) )
    {
      sub_100532E0((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10049210(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_1003E5B0(2) )
    result = 0;
  else
    result = sub_1003F250(2, v5, a2) == 1 && !sub_1005D7C0(a2);
  return result;
}
// 100D6448: using guessed type int (__cdecl *off_100D6448[3])(char);

//----- (10053410) --------------------------------------------------------
char __cdecl sub_10053410(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_10053350(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_100491F0(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (100534D0) --------------------------------------------------------
int __cdecl sub_100534D0(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = a2 * 1.799999952316284 + 32.0;
  return result;
}

//----- (100534F0) --------------------------------------------------------
int __cdecl sub_100534F0(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = (a2 - 32.0) * 0.5555555820465088;
  return result;
}

//----- (10053510) --------------------------------------------------------
char __cdecl sub_10053510(int a1, float *a2)
{
  char v2; // bl@1
  char result; // al@8

  v2 = 1;
  if ( *(float *)(a1 + 4) > (double)*a2 )
  {
    if ( *(_BYTE *)(a1 + 19) )
    {
      if ( *(_BYTE *)(a1 + 19) == 1 )
        *a2 = *(float *)(a1 + 4);
    }
    else
    {
      v2 = 0;
    }
  }
  if ( *(float *)a1 >= (double)*a2 )
  {
    result = v2;
  }
  else if ( *(_BYTE *)(a1 + 20) )
  {
    result = v2;
    if ( *(_BYTE *)(a1 + 20) == 1 )
      *a2 = *(float *)a1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10053570) --------------------------------------------------------
char __usercall sub_10053570@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5)
{
  unsigned __int8 v5; // cl@1
  char v6; // dl@2
  char v7; // bl@4
  double v8; // st7@6
  int v9; // edi@6
  int v10; // ecx@6
  bool v11; // zf@10
  unsigned int v12; // eax@18
  char v14; // [sp+3h] [bp-5h]@1
  char v15; // [sp+4h] [bp-4h]@2
  char v16; // [sp+10h] [bp+8h]@10
  char v17; // [sp+14h] [bp+Ch]@10

  v5 = *(_BYTE *)(a2 + 10 * a1 + 22535);
  v14 = 10;
  if ( (unsigned __int8)a4 >= 9u )
  {
    v15 = 9;
    v6 = 9;
  }
  else
  {
    v6 = a4;
    v15 = a4;
  }
  v7 = a5;
  if ( (unsigned __int8)a5 >= 9u )
    v7 = 9;
  v8 = a3;
  v9 = v5;
  v10 = 10 * v5;
  if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v6) + 53416) >= (double)a3 )
  {
    if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7) + 53416) <= v8 )
    {
      v11 = v7 == v6;
      v16 = 1;
      v17 = 0;
      if ( (unsigned __int8)v7 > (unsigned __int8)v6 )
      {
        v16 = -1;
        v17 = -1;
        v11 = v7 == v6;
      }
      if ( !v11 )
      {
        while ( *(float *)(a2 + 4 * ((unsigned __int8)v7 + v10) + 53416) > v8
             || *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7 + v16) + 53416) < v8 )
        {
          v7 += v16;
          if ( v7 == v15 )
            goto LABEL_18;
        }
        v14 = v7 + v17;
      }
    }
    else
    {
      v14 = v7;
    }
  }
  else
  {
    v14 = v6;
  }
LABEL_18:
  v12 = *(_BYTE *)(44 * v9 + a2 + 52576) - 2;
  if ( (unsigned __int8)v14 < v12 )
    LOBYTE(v12) = v14;
  return v12;
}

//----- (10053680) --------------------------------------------------------
double __usercall sub_10053680@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4)
{
  int v4; // esi@1
  unsigned __int8 v5; // al@1
  int v6; // edi@2
  unsigned __int8 v7; // al@2
  char v8; // al@6
  double v9; // st7@7
  double result; // st7@7
  char v11; // [sp+14h] [bp-8h]@4
  char v12; // [sp+18h] [bp-4h]@4
  float v13; // [sp+24h] [bp+8h]@7

  v4 = a1;
  v5 = *(_BYTE *)(a1 + 10 * (unsigned __int16)a3 + 22535);
  if ( v5 >= 0x14u )
  {
    *a2 = 1;
    result = a4;
  }
  else
  {
    v6 = v5;
    v7 = *(_BYTE *)(44 * v5 + v4 + 52576);
    if ( v7 <= 1u || v7 > 0xAu )
      goto LABEL_12;
    v11 = 0;
    v12 = v7 - 1;
    if ( *(float *)(v4 + 4 * (10 * v6 + (unsigned __int8)(v7 - 1)) + 53416) < (double)*(float *)(v4 + 40 * v6 + 53416) )
    {
      v11 = v7 - 1;
      v12 = 0;
    }
    v8 = sub_10053570(a3, v4, a4, v12, v11);
    if ( (unsigned __int8)v8 >= 9u )
    {
LABEL_12:
      *a2 = 1;
      result = a4;
    }
    else
    {
      v9 = *(float *)(v4 + 4 * ((unsigned __int8)v8 + 2 * (9 * v6 + 6777))) * a4
         + *(float *)(v4 + 4 * ((unsigned __int8)v8 + 18 * v6) + 54252);
      *a2 = 1;
      v13 = v9;
      result = v13;
    }
  }
  return result;
}

//----- (10053780) --------------------------------------------------------
unsigned __int8 __cdecl sub_10053780(int a1, int a2, char a3, void *a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  unsigned __int8 result; // al@1
  int v7; // edi@1
  int v8; // esi@4
  char v9; // bl@7
  int v10; // edi@7
  char v11; // al@7
  int v12; // edx@7
  char v13; // al@8
  char v14; // dl@8
  unsigned __int8 v15; // [sp+16h] [bp-156h]@1
  char v16; // [sp+17h] [bp-155h]@7
  int v17; // [sp+18h] [bp-154h]@1
  int v18; // [sp+1Ch] [bp-150h]@1
  int v19; // [sp+20h] [bp-14Ch]@1
  char v20[12]; // [sp+24h] [bp-148h]@7
  float v21[78]; // [sp+30h] [bp-13Ch]@8

  *(float *)a4 = 9.8999998e24;
  v4 = a2;
  v5 = *(_WORD *)(a2 + 16);
  result = 0;
  v7 = a1;
  v17 = a1;
  v19 = a2;
  v15 = 0;
  v18 = v5;
  while ( v15 < *(_BYTE *)(v4 + 18) )
  {
    v5 = (unsigned __int16)v5;
    v8 = v7 + 10 * (unsigned __int16)v5 + 22534;
    switch ( *(_BYTE *)v8 )
    {
      case 1:
        result = sub_100464A0(
                   *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22538),
                   *(_WORD *)(v7 + 2 * (5 * v5 + 11270)),
                   *(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22542),
                   4,
                   a4);
        break;
      case 3:
        result = sub_10069480(COERCE_FLOAT(*(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22538)), a4);
        break;
      case 4:
        v9 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v10 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v11 = sub_10070690((unsigned int)*(_BYTE *)(v8 + 5) >> 3, 1);
        v12 = *(_BYTE *)(v8 + 4);
        v16 = v11;
        result = sub_100464A0(6, (unsigned __int16)word_100D64AC[v12], 0, 324, v20);
        if ( result )
        {
          v13 = v16;
          v14 = v16;
          *(float *)a4 = v21[v10];
          result = ((unsigned __int8)v20[(unsigned __int8)v13] >> (v9 - 8 * v14)) & 1;
        }
        v7 = v17;
        break;
    }
    ++v15;
    v5 = v18++ + 1;
    if ( result )
    {
      v15 = result;
      goto LABEL_15;
    }
    v4 = v19;
  }
  v15 = result;
  if ( !result )
    return result;
LABEL_15:
  if ( a3 )
  {
    *(float *)a4 = sub_10053680(v7, &v15, v5 - 1, *(float *)a4);
    result = v15;
  }
  return result;
}
// 100D64AC: using guessed type __int16 word_100D64AC[];
// 10053780: using guessed type char var_148[12];
// 10053780: using guessed type float var_13C[78];

//----- (10053910) --------------------------------------------------------
char __cdecl sub_10053910(unsigned __int16 a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(float *)a2 = 9.8999998e24;
  v2 = sub_10053AA0(a1);
  v3 = sub_100464C0();
  if ( v2 && v3 && *(_WORD *)(v2 + 12) == 6 )
  {
    result = sub_10053780(v3, v2, 1, a2);
    if ( result )
      result = sub_10053510(v2, (float *)a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10053970) --------------------------------------------------------
int __cdecl sub_10053970(void *a1, void *a2, size_t a3, int a4, int a5)
{
  int result; // eax@8

  if ( a3 > 4 || a3 == 3 || a3 - 1 > 3 || ((unsigned int)a2 | (unsigned int)a1) & (a3 - 1) )
  {
    if ( sub_10016170(a4, a5) )
    {
      result = -1;
    }
    else
    {
      memcpy_0(a1, a2, a3);
      sub_10016150(a4);
      result = 1;
    }
  }
  else
  {
    switch ( a3 )
    {
      case 1u:
        result = 0;
        *(_BYTE *)a1 = *(_BYTE *)a2;
        break;
      case 2u:
        *(_WORD *)a1 = *(_WORD *)a2;
        result = 0;
        break;
      case 4u:
        result = 0;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        break;
      default:
        memcpy_0(a1, a2, a3);
        result = 0;
        break;
    }
  }
  return result;
}

//----- (10053A20) --------------------------------------------------------
int __cdecl sub_10053A20(unsigned __int16 a1)
{
  int v1; // ecx@1
  unsigned __int16 v2; // ax@3
  int result; // eax@4

  v1 = sub_100464D0();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 0x2000), v2 < 0x2000u) )
    result = v1 + v2;
  else
    result = 0;
  return result;
}

//----- (10053A60) --------------------------------------------------------
int __usercall sub_10053A60@<eax>(unsigned __int16 a1@<di>)
{
  int v1; // eax@1
  unsigned __int16 v2; // cx@3
  int result; // eax@4

  v1 = sub_100464C0();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 14400), v2 < 0x3840u) )
    result = v1 + 24 * v2;
  else
    result = 0;
  return result;
}

//----- (10053AA0) --------------------------------------------------------
int __cdecl sub_10053AA0(unsigned __int16 a1)
{
  int result; // eax@1
  int v2; // esi@1

  result = sub_10053A60(a1);
  v2 = result;
  if ( !result )
  {
    sub_10015C20("..\\lib\\acl\\dat\\dat_intf.c", 100, 0, 0);
    result = v2;
  }
  return result;
}

//----- (10053AF0) --------------------------------------------------------
signed int __cdecl sub_10053AF0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_10069EA0(v1) )
  {
    v2 = sub_10016380(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_10053E50(v8);
      if ( (v4 & sub_10025CD0(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_10043A80(v8, v9);
    v6 = 0;
    while ( !sub_100432D0(v8, byte_100D6D39[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 10053AF0: using guessed type char var_1AE[426];
// 10053AF0: using guessed type char var_1B0[2];
// 10053AF0: using guessed type char var_24C[68];

//----- (10053C20) --------------------------------------------------------
char __cdecl sub_10053C20(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10043450(11);
  }
  else
  {
    result = sub_10043450(5);
  }
  return result;
}

//----- (10053C50) --------------------------------------------------------
char sub_10053C50()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_1003F250(1, 1309, &v1) )
    sub_10052530((int)&v1);
  return 0;
}

//----- (10053CF0) --------------------------------------------------------
BOOL __cdecl sub_10053CF0(int a1, int a2)
{
  return sub_10016380(6455, a2, 252) == 0;
}

//----- (10053D10) --------------------------------------------------------
char __cdecl sub_10053D10(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10053CF0(a1, a5);
  }
  else
  {
    result = sub_10053C50();
  }
  return result;
}

//----- (10053D50) --------------------------------------------------------
int __cdecl sub_10053D50(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100430B0(&a1, 1u, (int)&unk_100DA4C8, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100DA4CC[2 * v1];
  }
  else
  {
    sub_10015C20("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100DA4CC: using guessed type int dword_100DA4CC[];

//----- (10053DA0) --------------------------------------------------------
char __cdecl sub_10053DA0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int, int, int); // eax@2

  v6 = sub_100430B0(&a1, 1u, (int)&unk_100DA128, 16, 58, 57);
  if ( v6 == 57 )
  {
    sub_10015C20("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2231, 0, 0);
  }
  else
  {
    v7 = (int (__cdecl *)(int, int, int, int, int, int))dword_100DA12C[4 * v6];
    if ( v7 )
      return v7(a1, a2, a3, a4, a5, a6);
  }
  return 0;
}
// 100DA12C: using guessed type int dword_100DA12C[];

//----- (10053E10) --------------------------------------------------------
char __cdecl sub_10053E10(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10015C20("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10053E50) --------------------------------------------------------
signed int __cdecl sub_10053E50(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_10015C20("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (10053E90) --------------------------------------------------------
int __cdecl sub_10053E90(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (10053EA0) --------------------------------------------------------
char __cdecl sub_10053EA0(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_1025C400[592 * a1]) || byte_1025C450[v3]) )
  {
    *a2 = &byte_1025C400[v3];
    *a3 = &byte_1025C450[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10053EE0) --------------------------------------------------------
char *__cdecl sub_10053EE0(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_1025C400;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_1025C450[592 * v2];
}

//----- (10053F50) --------------------------------------------------------
char *__usercall sub_10053F50@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10053F80) --------------------------------------------------------
void __cdecl sub_10053F80(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10053EE0(v2 + 3, (int)byte_100879F8);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10053F80(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (10054040) --------------------------------------------------------
void __cdecl sub_10054040(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_1025C3F8 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_1025C3F8;
    v4 = (char *)(&byte_1025C400[592 * dword_1025C3F8] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_1025C450[v3];
    v8 = (char *)(&byte_1025C450[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10053F80(v7);
    ++dword_1025C3F8;
  }
}
// 1025C3F8: using guessed type int dword_1025C3F8;

//----- (100540A0) --------------------------------------------------------
void *__cdecl sub_100540A0(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_1025C400, 0, 0x73A0u);
  dword_1025C3F8 = 0;
  if ( a1 )
  {
    v2 = sub_1005DB60(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_1005DD40((int)&v11, 512, v2) )
      {
        do
        {
          sub_10053F50(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_10054040((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_10054040(&v11, v4 + 1);
          }
        }
        while ( sub_1005DD40((int)&v11, 512, v3) );
      }
      result = (void *)sub_1005DB10(v3);
    }
    else
    {
      result = (void *)sub_100499A0(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 1025C3F8: using guessed type int dword_1025C3F8;

//----- (10054230) --------------------------------------------------------
char __thiscall sub_10054230(void *this)
{
  int v1; // eax@1
  char result; // al@3

  v1 = sub_100405D0(this) - 2;
  if ( v1 )
  {
    if ( v1 == 2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10054250) --------------------------------------------------------
_DWORD *__usercall sub_10054250@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_1006BCB0(a2, a1);
  result = (_DWORD *)sub_10025DB0(a3, a4);
  if ( (_BYTE)result )
    result = sub_100017D0(a2);
  return result;
}

//----- (10054330) --------------------------------------------------------
char __cdecl sub_10054330(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_10038600(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_10038600(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_10054230(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_10038630(v16);
  LOBYTE(v3) = sub_1006BCD0(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (10054430) --------------------------------------------------------
_DWORD *sub_10054430()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_10016420(6463, (int)&v1, 256);
  sub_10054250((int)sub_100542E0, (int)&unk_102637B0, &v1, "PAGE_INIT");
  sub_10054250((int)sub_10054280, (int)&unk_102637A0, &v1, "PAGE_SET_FOCUS");
  return sub_10054250((int)sub_10054330, (int)&unk_102637A8, &v1, "KEY_PRESS");
}
// 10054280: using guessed type int sub_10054280();
// 100542E0: using guessed type int sub_100542E0();

//----- (100544C0) --------------------------------------------------------
int __cdecl sub_100544C0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_100430B0(&a1, 1u, (int)&unk_100DB170, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_100DB174 + 2 * v1);
  return result;
}
// 100DB174: using guessed type void *off_100DB174;

//----- (10054500) --------------------------------------------------------
signed int __usercall sub_10054500@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100DBF18[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100DB318[2 * (unsigned __int8)v68] ^ dword_100DB718[2 * BYTE1(v65)] ^ dword_100DBB18[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100DBF18[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100DBF18[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100DBF18[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100DBF18[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100DBF18[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100DBF18[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100DBF18[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100DBF18[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100DBF18[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100DC318[(unsigned __int8)v57] ^ dword_100DCF18[v58 >> 24] ^ dword_100DC718[BYTE1(v59)] ^ dword_100DCB18[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100DC318[(unsigned __int8)v59] ^ dword_100DCB18[(unsigned __int8)(v58 >> 16)] ^ dword_100DCF18[v57 >> 24] ^ dword_100DC718[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100DC318[(unsigned __int8)v60] ^ dword_100DC718[BYTE1(v58)] ^ dword_100DCB18[(unsigned __int8)(v57 >> 16)] ^ dword_100DCF18[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100DC318[(unsigned __int8)v58] ^ dword_100DC718[BYTE1(v57)] ^ dword_100DCB18[(unsigned __int8)(v59 >> 16)] ^ dword_100DCF18[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100DBF18[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100DBF18[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100DBF18[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100DBF18[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100DBF18[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100DB318[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100DB718[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100DBB18[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100DBF18[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100DC318: using guessed type int dword_100DC318[];
// 100DC718: using guessed type int dword_100DC718[];
// 100DCB18: using guessed type int dword_100DCB18[];
// 100DCF18: using guessed type int dword_100DCF18[];

//----- (100555B0) --------------------------------------------------------
int __usercall sub_100555B0@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_10054500(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (10055610) --------------------------------------------------------
signed int __usercall sub_10055610@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100DCF18[(unsigned __int8)v9] ^ dword_100DC318[BYTE1(v9)] ^ dword_100DC718[(unsigned __int8)(v9 >> 16)] ^ dword_100DCB18[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100DCF18[(unsigned __int8)v129] ^ dword_100DC318[BYTE1(v129)] ^ dword_100DC718[(unsigned __int8)(v129 >> 16)] ^ dword_100DCB18[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100DCF18[(unsigned __int8)v133] ^ dword_100DC318[BYTE1(v133)] ^ dword_100DC718[(unsigned __int8)(v133 >> 16)] ^ dword_100DCB18[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100DCF18[(unsigned __int8)v137] ^ dword_100DC318[BYTE1(v137)] ^ dword_100DC718[(unsigned __int8)(v137 >> 16)] ^ dword_100DCB18[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100DCF18[(unsigned __int8)v141] ^ dword_100DC318[BYTE1(v141)] ^ dword_100DC718[(unsigned __int8)(v141 >> 16)] ^ dword_100DCB18[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100DCF18[(unsigned __int8)v145] ^ dword_100DC318[BYTE1(v145)] ^ dword_100DC718[(unsigned __int8)(v145 >> 16)] ^ dword_100DCB18[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100DCF18[(unsigned __int8)v149] ^ dword_100DC318[BYTE1(v149)] ^ dword_100DC718[(unsigned __int8)(v149 >> 16)] ^ dword_100DCB18[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100DCF18[(unsigned __int8)v153] ^ dword_100DC318[BYTE1(v153)] ^ dword_100DC718[(unsigned __int8)(v153 >> 16)] ^ dword_100DCB18[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100DCF18[(unsigned __int8)v157] ^ dword_100DC318[BYTE1(v157)] ^ dword_100DC718[(unsigned __int8)(v157 >> 16)] ^ dword_100DCB18[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100DCF18[(unsigned __int8)v161] ^ dword_100DC318[BYTE1(v161)] ^ dword_100DC718[(unsigned __int8)(v161 >> 16)] ^ dword_100DCB18[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100DCF18[(unsigned __int8)v77] ^ dword_100DC318[BYTE1(v77)] ^ dword_100DC718[(unsigned __int8)(v77 >> 16)] ^ dword_100DCB18[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100DCF18[(unsigned __int8)v82] ^ dword_100DC318[BYTE1(v82)] ^ dword_100DC718[(unsigned __int8)(v82 >> 16)] ^ dword_100DCB18[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100DCF18[(unsigned __int8)v89] ^ dword_100DC318[BYTE1(v89)] ^ dword_100DC718[(unsigned __int8)(v89 >> 16)] ^ dword_100DCB18[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100DCF18[(unsigned __int8)v94] ^ dword_100DC318[BYTE1(v94)] ^ dword_100DC718[(unsigned __int8)(v94 >> 16)] ^ dword_100DCB18[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100DCF18[(unsigned __int8)v100] ^ dword_100DC318[BYTE1(v100)] ^ dword_100DC718[(unsigned __int8)(v100 >> 16)] ^ dword_100DCB18[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100DCF18[(unsigned __int8)v100] ^ dword_100DC318[BYTE1(v100)] ^ dword_100DC718[(unsigned __int8)(v100 >> 16)] ^ dword_100DCB18[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100DCF18[(unsigned __int8)v108] ^ dword_100DC318[BYTE1(v108)] ^ dword_100DC718[(unsigned __int8)(v108 >> 16)] ^ dword_100DCB18[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100DCF18[(unsigned __int8)v114] ^ dword_100DC318[BYTE1(v114)] ^ dword_100DC718[(unsigned __int8)(v114 >> 16)] ^ dword_100DCB18[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100DCF18[(unsigned __int8)v120] ^ dword_100DC318[BYTE1(v120)] ^ dword_100DC718[(unsigned __int8)(v120 >> 16)] ^ dword_100DCB18[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100DCF18[(unsigned __int8)v19] ^ dword_100DC318[BYTE1(v19)] ^ dword_100DC718[(unsigned __int8)(v19 >> 16)] ^ dword_100DCB18[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100DC318[(unsigned __int8)v23] ^ dword_100DC718[BYTE1(v23)] ^ dword_100DCB18[(unsigned __int8)(v23 >> 16)] ^ dword_100DCF18[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100DCF18[(unsigned __int8)v26] ^ dword_100DC318[BYTE1(v26)] ^ dword_100DC718[(unsigned __int8)(v26 >> 16)] ^ dword_100DCB18[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100DC318[(unsigned __int8)v31] ^ dword_100DC718[BYTE1(v31)] ^ dword_100DCB18[(unsigned __int8)(v31 >> 16)] ^ dword_100DCF18[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100DCF18[(unsigned __int8)v35] ^ dword_100DC318[BYTE1(v35)] ^ dword_100DC718[(unsigned __int8)(v35 >> 16)] ^ dword_100DCB18[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100DC318[(unsigned __int8)v41] ^ dword_100DC718[BYTE1(v41)] ^ dword_100DCB18[(unsigned __int8)(v41 >> 16)] ^ dword_100DCF18[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100DCF18[(unsigned __int8)v43] ^ dword_100DC318[BYTE1(v43)] ^ dword_100DC718[(unsigned __int8)(v43 >> 16)] ^ dword_100DCB18[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100DC318[(unsigned __int8)v47] ^ dword_100DC718[BYTE1(v47)] ^ dword_100DCB18[(unsigned __int8)(v47 >> 16)] ^ dword_100DCF18[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100DCF18[(unsigned __int8)v52] ^ dword_100DC318[BYTE1(v52)] ^ dword_100DC718[(unsigned __int8)(v52 >> 16)] ^ dword_100DCB18[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100DC318[(unsigned __int8)v58] ^ dword_100DC718[BYTE1(v58)] ^ dword_100DCB18[(unsigned __int8)(v58 >> 16)] ^ dword_100DCF18[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100DCF18[(unsigned __int8)v60] ^ dword_100DC318[BYTE1(v60)] ^ dword_100DC718[(unsigned __int8)(v60 >> 16)] ^ dword_100DCB18[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100DC318[(unsigned __int8)v66] ^ dword_100DC718[BYTE1(v66)] ^ dword_100DCB18[(unsigned __int8)(v66 >> 16)] ^ dword_100DCF18[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100DCF18[(unsigned __int8)v69] ^ dword_100DC318[BYTE1(v69)] ^ dword_100DC718[(unsigned __int8)(v69 >> 16)] ^ dword_100DCB18[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100DC318: using guessed type int dword_100DC318[];
// 100DC718: using guessed type int dword_100DC718[];
// 100DCB18: using guessed type int dword_100DCB18[];
// 100DCF18: using guessed type int dword_100DCF18[];

//----- (10056390) --------------------------------------------------------
void *__usercall sub_10056390@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (100563B0) --------------------------------------------------------
unsigned int __cdecl sub_100563B0(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_100160A0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 100160F0: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10056410) --------------------------------------------------------
int __usercall sub_10056410@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (10056450) --------------------------------------------------------
int __usercall sub_10056450@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (10057B70) --------------------------------------------------------
unsigned int __usercall sub_10057B70@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100DD340[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100DD350[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_10056450(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_10056450(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100DD340: using guessed type int dword_100DD340[];
// 100DD350: using guessed type int dword_100DD350[];

//----- (10057C70) --------------------------------------------------------
void *__usercall sub_10057C70@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy_0((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_10056450(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy_0((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10057CF0) --------------------------------------------------------
void *__usercall sub_10057CF0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_10057B70(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10056410(v3 + 64);
    result = sub_10057C70(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_10057C70(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10057D90) --------------------------------------------------------
int __usercall sub_10057D90@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10057CF0(a1, 0, 0);
  sub_10057B70(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10056410(a1 + 64);
  sub_10057C70(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_10057C70(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_10057B70(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy_0((void *)a2, &v5, a3);
  return result;
}

//----- (10057E50) --------------------------------------------------------
int __usercall sub_10057E50@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy_0((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10056410(a2 + 64);
    sub_10057C70(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_10057C70(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10057EB0) --------------------------------------------------------
int __usercall sub_10057EB0@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy_0(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy_0(&v19[v6], a1, 64 - v6);
    sub_10056450((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10057EB0: using guessed type char var_40[64];

//----- (10057F70) --------------------------------------------------------
int __usercall sub_10057F70@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10057EB0((char *)a1);
  return sub_10057EB0(v8);
}

//----- (10058030) --------------------------------------------------------
char __cdecl sub_10058030(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10057CF0(a3 + 296, a2, a1);
    sub_100555B0(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10058080) --------------------------------------------------------
char __cdecl sub_10058080(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_100555B0(a3, (int)a1, a2);
    sub_10057CF0(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100580D0) --------------------------------------------------------
bool __cdecl sub_100580D0(int a1, int a2)
{
  if ( a2 )
    sub_10057D90(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (10058100) --------------------------------------------------------
int __usercall sub_10058100@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10056390(&v24);
  sub_10057E50(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10057CF0((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10057CF0((int)&v23, v12, (char *)&v31);
          sub_10057D90((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 10058100: using guessed type char var_14[16];

//----- (10058310) --------------------------------------------------------
int __usercall sub_10058310@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_10057F70(v2);
  v3 = 20;
  do
  {
    sub_10057EB0((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_10057F70(v2);
}

//----- (10058360) --------------------------------------------------------
char *__cdecl sub_10058360(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy_0(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10057F70(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (100583F0) --------------------------------------------------------
signed int __cdecl sub_100583F0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_10058100(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_10055610(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10056390((void *)(a6 + 296));
      sub_10057E50(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 100583F0: using guessed type char var_40[8];
// 100583F0: using guessed type __int16 var_38[26];

//----- (10058520) --------------------------------------------------------
bool __cdecl sub_10058520(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_10058310(&v4, (int)sub_100563B0);
  if ( v2 )
    sub_10058360(a2, (int)&v4);
  return v2;
}

//----- (100585A0) --------------------------------------------------------
BOOL __usercall sub_100585A0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100DDB58[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100DDA58[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100DD958[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (10058640) --------------------------------------------------------
int __usercall sub_10058640@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (100586D0) --------------------------------------------------------
unsigned int __fastcall sub_100586D0(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (100586F0) --------------------------------------------------------
int __usercall sub_100586F0@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (10058780) --------------------------------------------------------
int __usercall sub_10058780@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100DDB58[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100DDB58[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100DD360[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100DDC58[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100DDA58[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100DD958[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100DD3E8[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100DDCD0[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100DD360: using guessed type int dword_100DD360[];
// 100DD3E8: using guessed type int dword_100DD3E8[];
// 100DDC58: using guessed type int dword_100DDC58[];
// 100DDCD0: using guessed type int dword_100DDCD0[];

//----- (10058C00) --------------------------------------------------------
int __usercall sub_10058C00@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_100586F0(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10058CB0) --------------------------------------------------------
void *__usercall sub_10058CB0@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy_0(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10058D10) --------------------------------------------------------
int __usercall sub_10058D10@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10058EE0) --------------------------------------------------------
signed int __usercall sub_10058EE0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_100586D0(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (10058F60) --------------------------------------------------------
_WORD *__fastcall sub_10058F60(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10058FD0) --------------------------------------------------------
unsigned int __usercall sub_10058FD0@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10059180) --------------------------------------------------------
unsigned int __usercall sub_10059180@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (10059250) --------------------------------------------------------
int __usercall sub_10059250@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (10059300) --------------------------------------------------------
int __usercall sub_10059300@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (10059340) --------------------------------------------------------
unsigned int __usercall sub_10059340@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_1005B110(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy_0(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100593A0) --------------------------------------------------------
signed int __usercall sub_100593A0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (10059480) --------------------------------------------------------
int __usercall sub_10059480@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (10059A20) --------------------------------------------------------
int __usercall sub_10059A20@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_10058640(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_10058640(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_10058640(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (10059C60) --------------------------------------------------------
int __usercall sub_10059C60@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_10058C00(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_10058C00(a1, a3, a4);
  }
  return result;
}

//----- (10059D00) --------------------------------------------------------
signed int __usercall sub_10059D00@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_10059250(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_10059250(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_10059250(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10058D10(a1, a2);
  return sub_10058EE0(a1, v16, v5);
}

//----- (10059EE0) --------------------------------------------------------
unsigned int __usercall sub_10059EE0@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy_0(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_10059340(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (1005A020) --------------------------------------------------------
int __usercall sub_1005A020@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100DD3D4[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_10059480(a1, a1 + 2936, a2 - 1);
  return sub_10059480(v24, v24 + 5228, a3 - 1);
}

//----- (1005A2D0) --------------------------------------------------------
signed int __cdecl sub_1005A2D0(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_10059300(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_10059300(v9, *(_WORD *)(a1 + 30));
      sub_10059300(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_1005B110(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10058CB0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100DDD50 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_10059A20(v2);
    }
    else
    {
      sub_10059C60(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10058CB0(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_10059300(v2, *(_WORD *)(a1 + 30));
    sub_10059300(v13, *(_WORD *)(a1 + 28));
    sub_10058CB0(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100DDD50: using guessed type int (__cdecl *off_100DDD50)(int, int);

//----- (1005A590) --------------------------------------------------------
signed int __usercall sub_1005A590@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_100593A0(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_100593A0(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10059D00(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100DD3D4[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100DD3D3[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100DD3D2[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100DD3D1[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (1005A660) --------------------------------------------------------
_WORD *__usercall sub_1005A660@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10059D00(a2, a2 + 5628);
  sub_10059D00(v4, v4 + 5640);
  v8 = sub_1005A590(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_10059C60(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_10058780(v4, (int)&unk_100DD460, (int)&unk_100DD8E0);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_1005A020(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_10058780(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_10058F60(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_100586F0(v4);
  return result;
}

//----- (1005A880) --------------------------------------------------------
signed int __cdecl sub_1005A880(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10059EE0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10058FD0(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_10059180(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_100585A0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_100585A0(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_1005A660(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10058CB0(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_1005A660(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10058CB0(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1005AB90) --------------------------------------------------------
signed int __cdecl sub_1005AB90(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10059EE0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10058FD0(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_10059180(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_100585A0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_1005A660(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10058CB0(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_100585A0(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_1005A660(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10058CB0(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_100585A0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_1005A660(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10058CB0(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1005AFA0) --------------------------------------------------------
signed int __cdecl sub_1005AFA0(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_10059EE0(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_1005A660(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10058CB0(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_1005A660(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10058CB0(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_1005A660(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10058CB0(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1005B110) --------------------------------------------------------
int __cdecl sub_1005B110(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (1005B210) --------------------------------------------------------
signed int __cdecl sub_1005B210(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1005B230) --------------------------------------------------------
signed int __usercall sub_1005B230@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 1005B230: using guessed type int var_78[14];
// 1005B230: using guessed type int var_3C[15];

//----- (1005B6D0) --------------------------------------------------------
int (__cdecl *__usercall sub_1005B6D0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (1005B720) --------------------------------------------------------
int __usercall sub_1005B720@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (1005B740) --------------------------------------------------------
signed int __cdecl sub_1005B740(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100DDF38[a1];
  v51 = dword_100DDF38[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100DDF38[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100DDF38[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100DDF38[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100DDF38[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100DDF38: using guessed type int dword_100DDF38[];

//----- (1005BAF0) --------------------------------------------------------
int __usercall sub_1005BAF0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy_0(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy_0(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (1005BC30) --------------------------------------------------------
signed int __usercall sub_1005BC30@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_1005B230(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (1005BC80) --------------------------------------------------------
signed int __usercall sub_1005BC80@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_1005B230(a7, a6, a4, 257, (int)&unk_100DDFD0, (int)&unk_100DE050, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_1005B230(a8, &a6[a4], a5, 0, (int)&unk_100DE0D0, (int)&unk_100DE148, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005BD20) --------------------------------------------------------
int __usercall sub_1005BD20@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100DE1C0;
  *a4 = &unk_100DF1C0;
  return 0;
}

//----- (1005BD40) --------------------------------------------------------
signed int __cdecl sub_1005BD40(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_1005B6D0(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1005BD50) --------------------------------------------------------
int __usercall sub_1005BD50@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_1005B740(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100DDF38[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100DDF38[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100DDF38[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100DDF38[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_1005BAF0(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_1005BAF0(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_1005BAF0(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_1005BAF0(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100DDF38: using guessed type int dword_100DDF38[];

//----- (1005C3F0) --------------------------------------------------------
int __usercall sub_1005C3F0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_1005BD20(&v67, &v69, &v66, &v68);
          sub_1005B720(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_1005BAF0(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy_0(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100DDF80[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100DDF80[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_1005BC30(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_1005BC80(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_1005B720(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_1005BD50(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_1005BAF0(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_1005BAF0(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_1005BAF0(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100DDF38[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100DDF38[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_1005BAF0(v7, v3, v58);
}
// 100DDF38: using guessed type int dword_100DDF38[];
// 100DDF80: using guessed type int dword_100DDF80[];

//----- (1005CDD0) --------------------------------------------------------
signed int __usercall sub_1005CDD0@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_1005C3F0(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_1005B6D0((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1005D100) --------------------------------------------------------
signed int __cdecl sub_1005D100(int a1, int a2)
{
  return sub_1005CDD0(a1, a2);
}

//----- (1005D120) --------------------------------------------------------
char __cdecl sub_1005D120(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_1003F250(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_1003F250(0, 183, a2);
  }
  return result;
}

//----- (1005D170) --------------------------------------------------------
unsigned __int8 __cdecl sub_1005D170(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_10016450(dword_100E1E2C[a1], (int)&a2, 1);
  }
  return result;
}
// 100E1E2C: using guessed type int dword_100E1E2C[];

//----- (1005D1B0) --------------------------------------------------------
int __cdecl sub_1005D1B0(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_1005D120(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1005D1F0) --------------------------------------------------------
char __cdecl sub_1005D1F0(char a1)
{
  return byte_100E2CE9[2 * (unsigned __int8)sub_100430B0(&a1, 1u, (int)&unk_100E2CE8, 2, 4, 3)];
}

//----- (1005D220) --------------------------------------------------------
char __cdecl sub_1005D220(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_1003F250(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_10067050(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_1003F250(1, 538, a2);
  }
  if ( !v4 || sub_10052440((int)v3) )
    return 0;
  return 1;
}

//----- (1005D2A0) --------------------------------------------------------
int __cdecl sub_1005D2A0(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_1005D220(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1005D2F0) --------------------------------------------------------
void __cdecl sub_1005D2F0(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_10016450(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_100670C0(a2);
        sub_10015C20("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_10016450(2010, (int)&a2, 1);
    }
  }
}

//----- (1005D360) --------------------------------------------------------
char __cdecl sub_1005D360(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_102D21D4)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;

//----- (1005D3B0) --------------------------------------------------------
char __cdecl sub_1005D3B0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_102D21D4)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;

//----- (1005D460) --------------------------------------------------------
char __cdecl sub_1005D460(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_102D21D4)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;

//----- (1005D4C0) --------------------------------------------------------
char __cdecl sub_1005D4C0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_102D21D4)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 102D21D4: using guessed type int dword_102D21D4;

//----- (1005D590) --------------------------------------------------------
int __cdecl sub_1005D590(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_100430B0(&a1, 1u, (int)&unk_100E2D20, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_100E2D21 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (1005D5E0) --------------------------------------------------------
int __cdecl sub_1005D5E0(unsigned __int8 *a1)
{
  return sub_10052A90(a1, 0, 0, 0, 0);
}

//----- (1005D600) --------------------------------------------------------
unsigned int __cdecl sub_1005D600(void *a1)
{
  return sub_10052A30(a1, 0x20u, 0);
}

//----- (1005D620) --------------------------------------------------------
unsigned int __cdecl sub_1005D620(void *a1)
{
  return sub_10052A30(a1, 0x1Cu, 0);
}

//----- (1005D640) --------------------------------------------------------
unsigned int __cdecl sub_1005D640(void *a1)
{
  return sub_10052A30(a1, 0x10u, 0);
}

//----- (1005D660) --------------------------------------------------------
unsigned int __cdecl sub_1005D660(void *a1)
{
  return sub_10052A30(a1, 0xCu, 0);
}

//----- (1005D680) --------------------------------------------------------
unsigned int __cdecl sub_1005D680(void *a1)
{
  return sub_10052A30(a1, 8u, 0);
}

//----- (1005D6A0) --------------------------------------------------------
int __cdecl sub_1005D6A0(int a1)
{
  int result; // eax@1

  result = sub_10052A90((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_10052A90((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_10052AE0((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (1005D6F0) --------------------------------------------------------
int __cdecl sub_1005D6F0(void *a1)
{
  int result; // eax@1

  result = sub_1005D600((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1005D600((char *)a1 + 128);
    if ( !result )
    {
      result = sub_1005D680((char *)a1 + 120);
      if ( !result )
      {
        result = sub_1005D620((char *)a1 + 36);
        if ( !result )
        {
          result = sub_1005D6A0((int)a1 + 168);
          if ( !result )
          {
            result = sub_1005D6A0((int)a1 + 160);
            if ( !result )
            {
              result = sub_1005D6A0((int)a1 + 164);
              if ( !result )
              {
                result = sub_1005D640(a1);
                if ( !result )
                {
                  result = sub_1005D660((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_1005D660((char *)a1 + 24);
                    if ( !result )
                      result = sub_1005D680((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (1005D7C0) --------------------------------------------------------
unsigned int __cdecl sub_1005D7C0(void *a1)
{
  unsigned int result; // eax@1

  result = sub_1005D600((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1005D620((char *)a1 + 36);
    if ( !result )
    {
      result = sub_1005D640(a1);
      if ( !result )
      {
        result = sub_1005D660((char *)a1 + 96);
        if ( !result )
        {
          result = sub_1005D660((char *)a1 + 24);
          if ( !result )
            result = sub_1005D680((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (1005D820) --------------------------------------------------------
int __cdecl sub_1005D820(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10083650: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10083660: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10083670: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10083680: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10083730: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (1005D960) --------------------------------------------------------
char __usercall sub_1005D960@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (1005DA30) --------------------------------------------------------
signed int __cdecl sub_1005DA30(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_10083690(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_1005D960(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_1005D820(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10083740: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (1005DB10) --------------------------------------------------------
BOOL __cdecl sub_1005DB10(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10015D40(a1) == 0;
}
// 10015D30: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (1005DB30) --------------------------------------------------------
BOOL __cdecl sub_1005DB30(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 10015D80: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (1005DB60) --------------------------------------------------------
unsigned int __cdecl sub_1005DB60(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10015E00: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1005DBC0) --------------------------------------------------------
signed int __cdecl sub_1005DBC0(void *a1, int a2, unsigned int a3)
{
  return sub_10015E10(a3, a1, a2);
}

//----- (1005DBE0) --------------------------------------------------------
int __cdecl sub_1005DBE0(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 10015F70: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1005DC00) --------------------------------------------------------
char __cdecl sub_1005DC00(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_1005DB60((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_1005DB60((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_1005DBC0(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_1005DBE0((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_1005DBC0(&v8, 512, v3);
        }
        v2 = i;
        sub_1005DB10(v4);
      }
      sub_1005DB10(v3);
    }
    return v2;
  }
  return 1;
}

//----- (1005DD40) --------------------------------------------------------
int __cdecl sub_1005DD40(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_1005DBC0(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (1005DDC0) --------------------------------------------------------
int sub_1005DDC0()
{
  return 0;
}

//----- (1005DDD0) --------------------------------------------------------
void __cdecl sub_1005DDD0(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (1005DE00) --------------------------------------------------------
int __cdecl sub_1005DE00(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1005DE20) --------------------------------------------------------
bool __cdecl sub_1005DE20(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (1005DE50) --------------------------------------------------------
void *__cdecl sub_1005DE50(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (1005DE90) --------------------------------------------------------
unsigned int __usercall sub_1005DE90@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (1005DEB0) --------------------------------------------------------
int __usercall sub_1005DEB0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (1005DED0) --------------------------------------------------------
char __cdecl sub_1005DED0(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_1005DE20(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_1005DE00(a2);
  }
  return result;
}

//----- (1005DF00) --------------------------------------------------------
signed int __cdecl sub_1005DF00(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_1005DE90(v5, v7, v9);
          v11 = (_BYTE *)sub_1005DE90(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_1005DE90(a4, v7, v9);
            sub_1005DEB0(v16, (int)&unk_100E2EAC);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (1005DFE0) --------------------------------------------------------
void __cdecl sub_1005DFE0(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_1005DE90((int)v3, v4, v6);
          v8 = sub_1005DE90(a2, v4, v6);
          v9 = sub_1005DE90(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (1005E090) --------------------------------------------------------
void *__usercall sub_1005E090@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_1005DE90(a1, v31, v4);
      v6 = sub_1005DE90(a2, 0, 0);
      sub_1005DEB0(v5, v6);
      v7 = sub_1005DE90(a1, v33, v4);
      v8 = sub_1005DE90(a2, *(_DWORD *)a2 - 1, 0);
      sub_1005DEB0(v7, v8);
      v9 = sub_1005DE90(a1, v31, v34 - v4 - 1);
      v10 = sub_1005DE90(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_1005DEB0(v9, v10);
      v11 = sub_1005DE90(a1, v33, v34 - v4 - 1);
      v12 = sub_1005DE90(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_1005DEB0(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_1005DE90(a2, 0, 1);
    v16 = (void *)sub_1005DE90(a1, v13, a3 + 1);
    memcpy_0(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_1005DE90(a1, a3 + i, v18);
      v20 = sub_1005DE90(a2, i, 0);
      sub_1005DEB0(v19, v20);
      v21 = sub_1005DE90(a1, i + a3, v34 - v18 - 1);
      v22 = sub_1005DE90(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_1005DEB0(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_1005DE90(a2, i, 1);
    v25 = (void *)sub_1005DE90(a1, a3 + i, a3 + 1);
    memcpy_0(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_1005DE90(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_1005DE90(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy_0(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (1005E310) --------------------------------------------------------
void __cdecl sub_1005E310(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_1005DE90(a1, v2, v4);
          v6 = sub_1005DE90(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (1005E3E0) --------------------------------------------------------
char __cdecl sub_1005E3E0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_1005DE20(a1);
  if ( result )
  {
    result = sub_1005DE20(a4);
    if ( result )
    {
      sub_1005DED0(a3, a4);
      sub_1005DE50(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy_0(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (1005E450) --------------------------------------------------------
int __usercall sub_1005E450@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_1005DE50(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_1005E090((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_1005DE90((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_1005DE90(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_1005DED0((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_1005E3E0(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (1005E7B0) --------------------------------------------------------
int __usercall sub_1005E7B0@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_1005DE50(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_1005DFE0(v8, a3, (int)&v16);
  sub_1005DE50(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_1005E450(9u, v7, (int)&v16, (int)&unk_100E2E88, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_1005DE90((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_1005DE90(a6, v9, v11);
            sub_1005DEB0(v13, (int)&unk_100E2EAC);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_1005DED0(a5, (int)&v15);
  sub_1005DED0(a5, (int)&v16);
  return v10;
}

//----- (1005E8C0) --------------------------------------------------------
int __cdecl sub_1005E8C0(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_1005DE50(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_1005E310(a3, a8);
  if ( a1 )
    result = sub_1005E7B0(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_1005DF00((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (1005EA50) --------------------------------------------------------
char __cdecl sub_1005EA50(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_1005DB60((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_1005DBC0(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_1005DBC0(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_1005DE50(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_1005DBC0(v6, v7, v12) == v7 && (!v9 || sub_1005DBC0(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_1005DB10(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005EBA0) --------------------------------------------------------
char __usercall sub_1005EBA0@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_1005DB60(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_1005DBE0((int)&v14, 14, v9) == 14 && sub_1005DBE0((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_1005DBE0(v12, v6, v10) == v6 && (!v7 || sub_1005DBE0((int)&unk_100E3038, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_1005DB10(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_1005DB10(v10);
  }
  return v30;
}

//----- (1005ECF0) --------------------------------------------------------
char __cdecl sub_1005ECF0(int a1, int a2)
{
  char result; // al@2

  if ( sub_1005DE20(a1) )
    result = sub_1005EBA0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (1005ED30) --------------------------------------------------------
signed int __cdecl sub_1005ED30(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_102657B9 = 1;
    byte_102657B8 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_102657B8 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_102657B9 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 102657B8: using guessed type char byte_102657B8;
// 102657B9: using guessed type char byte_102657B9;

//----- (1005ED90) --------------------------------------------------------
bool __cdecl sub_1005ED90(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_100498F0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100FAC28, (int)"failing_subroutine( depth-1 )");
    sub_1005ED90(a1 - 1);
    exit_0(14);
  }
  return sub_1004EDB0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (1005EE00) --------------------------------------------------------
int sub_1005EE00()
{
  const char *v0; // eax@1

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_102657B8 )
  {
    sub_1004EDB0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_100498F0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_1005ED90(1);
    exit_0(14);
  }
  return sub_10049920(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 102657B8: using guessed type char byte_102657B8;

//----- (1005F120) --------------------------------------------------------
char sub_1005F120()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  int v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_102657B8 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100E3C9C + v2) )
      {
        sub_1004A0E0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100E3CA4[v2], 0x100u, &v11);
        sub_1004A0E0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100E3C9C + v2), 0x100u, &v12);
        sub_1005DC00(&v12, &v11);
      }
      if ( byte_100E3C98[v2] )
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = *(int *)((char *)&off_100E3CA0 + v2);
        v4 = *(char **)&off_100E3CA4[v2];
        v5 = sub_1004A380(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100E3CA4[v2],
               *(void **)((char *)&off_100E3CA0 + v2));
        v6 = sub_1004EA00(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1004A6E0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = *(int *)((char *)&off_100E3CA0 + v2);
        v8 = *(char **)&off_100E3CA4[v2];
        v9 = sub_1004A380(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100E3CA4[v2],
               *(void **)((char *)&off_100E3CA0 + v2));
        v10 = sub_1004EA00(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1004A6E0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100E3C9C: using guessed type void *off_100E3C9C;
// 100E3CA0: using guessed type void *off_100E3CA0;
// 102657B8: using guessed type char byte_102657B8;

//----- (1005F340) --------------------------------------------------------
char sub_1005F340()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_102657B8 )
  {
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1004A6E0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1004A6E0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1004A6E0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1004A6E0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1004A6E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 102657B8: using guessed type char byte_102657B8;

//----- (1005F540) --------------------------------------------------------
char sub_1005F540()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E3D2C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_100E3D29[v2 * 4];
        v4 = byte_100E3D28[v2 * 4];
        v5 = sub_1004A380(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + dword_100E3D2C[v2])],
               (&off_100E3D30)[v2 * 4]);
        v6 = sub_1004A820(
               0,
               *(&dword_100E3C7C + dword_100E3D2C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1004A380(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E3D2C[v2]],
               (&off_100E3D30)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E3D2C: using guessed type int dword_100E3D2C[];
// 100E3D30: using guessed type char *off_100E3D30;
// 102657B8: using guessed type char byte_102657B8;

//----- (1005F6C0) --------------------------------------------------------
char sub_1005F6C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E3FB0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100E3FA8[v2 / 8];
        v4 = dbl_100E3FA0[v2 / 8];
        v5 = dbl_100E3F98[v2 / 8];
        v6 = sub_1004A380(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100E3FB4[v2]);
        v7 = sub_1004ABD0(
               0,
               *(&dword_100E3C7C + dword_100E3FB0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E3FB0[v2 / 4]],
               *(_DWORD *)&off_100E3FB4[v2]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E3F98: using guessed type double dbl_100E3F98[];
// 100E3FA0: using guessed type double dbl_100E3FA0[];
// 100E3FA8: using guessed type double dbl_100E3FA8[];
// 100E3FB0: using guessed type int dword_100E3FB0[];
// 102657B8: using guessed type char byte_102657B8;

//----- (1005F840) --------------------------------------------------------
char sub_1005F840()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E4BC4[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100E4BC0[v2];
        v4 = flt_100E4BBC[v2];
        v5 = flt_100E4BB8[v2];
        v6 = sub_1004A380(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100E4BC8[v2 * 4]);
        v7 = sub_1004B020(
               0,
               *(&dword_100E3C7C + dword_100E4BC4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E4BC4[v2]],
               *(_DWORD *)&off_100E4BC8[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E4BB8: using guessed type float flt_100E4BB8[];
// 100E4BBC: using guessed type float flt_100E4BBC[];
// 100E4BC0: using guessed type float flt_100E4BC0[];
// 100E4BC4: using guessed type int dword_100E4BC4[];
// 102657B8: using guessed type char byte_102657B8;

//----- (1005F9B0) --------------------------------------------------------
char sub_1005F9B0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_102657B8 )
  {
    sub_1004ED00(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_1005F9B0,
      (int)sub_1005F9B0,
      (int)"This test is expected to fail");
    sub_1004ED00(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_1005F9B0,
      0,
      (int)"This test is expected to fail");
    result = sub_1004ED00(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1005F9B0,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 102657B8: using guessed type char byte_102657B8;

//----- (1005FAB0) --------------------------------------------------------
char sub_1005FAB0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E536C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100E5368[v2];
        v4 = dword_100E5364[v2];
        v5 = dword_100E5360[v2];
        v6 = sub_1004A380(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100E5370)[v2 * 4]);
        v7 = sub_1004B4E0(
               0,
               *(&dword_100E3C7C + dword_100E536C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E536C[v2]],
               (&off_100E5370)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E5360: using guessed type int dword_100E5360[];
// 100E5364: using guessed type int dword_100E5364[];
// 100E5368: using guessed type int dword_100E5368[];
// 100E536C: using guessed type int dword_100E536C[];
// 100E5370: using guessed type char *off_100E5370;
// 102657B8: using guessed type char byte_102657B8;

//----- (1005FC10) --------------------------------------------------------
char sub_1005FC10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E5B00[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100E5AFC[v2 / 2];
        v4 = word_100E5AFA[v2 / 2];
        v5 = word_100E5AF8[v2 / 2];
        v6 = sub_1004A380(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100E5B04)[v2]);
        v7 = sub_1004B8A0(
               0,
               *(&dword_100E3C7C + dword_100E5B00[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E5B00[v2 / 4]],
               (&off_100E5B04)[v2]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E5AF8: using guessed type __int16 word_100E5AF8[];
// 100E5AFA: using guessed type __int16 word_100E5AFA[];
// 100E5AFC: using guessed type __int16 word_100E5AFC[];
// 100E5B00: using guessed type int dword_100E5B00[];
// 100E5B04: using guessed type char *off_100E5B04;
// 102657B8: using guessed type char byte_102657B8;

//----- (1005FD70) --------------------------------------------------------
char sub_1005FD70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E6114[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100E6110[v2];
        v4 = dword_100E610C[v2];
        v5 = dword_100E6108[v2];
        v6 = sub_1004A380(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100E6118[v2 * 4]);
        v7 = sub_1004BCA0(
               0,
               *(&dword_100E3C7C + dword_100E6114[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E6114[v2]],
               *(_DWORD *)&off_100E6118[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E6108: using guessed type int dword_100E6108[];
// 100E610C: using guessed type int dword_100E610C[];
// 100E6110: using guessed type int dword_100E6110[];
// 100E6114: using guessed type int dword_100E6114[];
// 102657B8: using guessed type char byte_102657B8;

//----- (1005FED0) --------------------------------------------------------
char sub_1005FED0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E68B8[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100E68B4[v2];
        LODWORD(v3) = dword_100E68B0[v2];
        HIDWORD(v4) = dword_100E68AC[v2];
        LODWORD(v4) = dword_100E68A8[v2];
        HIDWORD(v5) = dword_100E68A4[v2];
        LODWORD(v5) = dword_100E68A0[v2];
        v6 = sub_1004A380(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100E68BC[v2 * 4]);
        v7 = sub_1004C060(
               0,
               *(&dword_100E3C7C + dword_100E68B8[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E68B8[v2]],
               *(_DWORD *)&off_100E68BC[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E68A0: using guessed type int dword_100E68A0[];
// 100E68A4: using guessed type int dword_100E68A4[];
// 100E68A8: using guessed type int dword_100E68A8[];
// 100E68AC: using guessed type int dword_100E68AC[];
// 100E68B0: using guessed type int dword_100E68B0[];
// 100E68B4: using guessed type int dword_100E68B4[];
// 100E68B8: using guessed type int dword_100E68B8[];
// 102657B8: using guessed type char byte_102657B8;

//----- (10060040) --------------------------------------------------------
char sub_10060040()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E74C4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100E74C2[v2 * 4];
        v4 = byte_100E74C1[v2 * 4];
        v5 = byte_100E74C0[v2 * 4];
        v6 = sub_1004A380(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100E74C8)[v2 * 4]);
        v7 = sub_1004C5A0(
               0,
               *(&dword_100E3C7C + dword_100E74C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E74C4[v2]],
               (&off_100E74C8)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E74C4: using guessed type int dword_100E74C4[];
// 100E74C8: using guessed type char *off_100E74C8;
// 102657B8: using guessed type char byte_102657B8;

//----- (100601A0) --------------------------------------------------------
char sub_100601A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E795C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100E7958[v2];
        v4 = dword_100E7954[v2];
        v5 = dword_100E7950[v2];
        v6 = sub_1004A380(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100E7960)[v2 * 4]);
        v7 = sub_1004C980(
               0,
               *(&dword_100E3C7C + dword_100E795C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E795C[v2]],
               (&off_100E7960)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E7950: using guessed type int dword_100E7950[];
// 100E7954: using guessed type int dword_100E7954[];
// 100E7958: using guessed type int dword_100E7958[];
// 100E795C: using guessed type int dword_100E795C[];
// 100E7960: using guessed type char *off_100E7960;
// 102657B8: using guessed type char byte_102657B8;

//----- (10060300) --------------------------------------------------------
char sub_10060300()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_102657B8 )
  {
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_1004EDB0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           byte_100879F8,
           (int)"This test is expected to fail");
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_1004EDB0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           byte_100879F8,
           "a",
           (int)"This test is expected to fail");
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_1004EDB0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           byte_100879F8,
           byte_100879F8,
           (int)"This test is expected to fail");
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_1004EDB0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1004A6E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 102657B8: using guessed type char byte_102657B8;

//----- (10060520) --------------------------------------------------------
char sub_10060520()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E80F4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100E80F0[v2];
        v4 = dword_100E80EC[v2];
        v5 = dword_100E80E8[v2];
        v6 = sub_1004A380(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100E80F8[v2 * 4]);
        v7 = sub_1004CD40(
               0,
               *(&dword_100E3C7C + dword_100E80F4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E80F4[v2]],
               *(_DWORD *)&off_100E80F8[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E80E8: using guessed type int dword_100E80E8[];
// 100E80EC: using guessed type int dword_100E80EC[];
// 100E80F0: using guessed type int dword_100E80F0[];
// 100E80F4: using guessed type int dword_100E80F4[];
// 102657B8: using guessed type char byte_102657B8;

//----- (10060680) --------------------------------------------------------
char sub_10060680()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E8460[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100E845C[v2 / 2];
        v4 = word_100E845A[v2 / 2];
        v5 = word_100E8458[v2 / 2];
        v6 = sub_1004A380(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100E8464)[v2]);
        v7 = sub_1004D0E0(
               0,
               *(&dword_100E3C7C + dword_100E8460[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E8460[v2 / 4]],
               (&off_100E8464)[v2]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E8458: using guessed type __int16 word_100E8458[];
// 100E845A: using guessed type __int16 word_100E845A[];
// 100E845C: using guessed type __int16 word_100E845C[];
// 100E8460: using guessed type int dword_100E8460[];
// 100E8464: using guessed type char *off_100E8464;
// 102657B8: using guessed type char byte_102657B8;

//----- (100607E0) --------------------------------------------------------
char sub_100607E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E8724[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100E8720[v2];
        v4 = dword_100E871C[v2];
        v5 = dword_100E8718[v2];
        v6 = sub_1004A380(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100E8728[v2 * 4]);
        v7 = sub_1004D4E0(
               0,
               *(&dword_100E3C7C + dword_100E8724[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E8724[v2]],
               *(_DWORD *)&off_100E8728[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E8718: using guessed type int dword_100E8718[];
// 100E871C: using guessed type int dword_100E871C[];
// 100E8720: using guessed type int dword_100E8720[];
// 100E8724: using guessed type int dword_100E8724[];
// 102657B8: using guessed type char byte_102657B8;

//----- (10060940) --------------------------------------------------------
char sub_10060940()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E8AA0[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100E8A9C[v2];
        LODWORD(v3) = dword_100E8A98[v2];
        HIDWORD(v4) = dword_100E8A94[v2];
        LODWORD(v4) = dword_100E8A90[v2];
        HIDWORD(v5) = dword_100E8A8C[v2];
        LODWORD(v5) = dword_100E8A88[v2];
        v6 = sub_1004A380(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100E8AA4)[v2 * 4]);
        v7 = sub_1004D880(
               0,
               *(&dword_100E3C7C + dword_100E8AA0[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E8AA0[v2]],
               (&off_100E8AA4)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E8A88: using guessed type int dword_100E8A88[];
// 100E8A8C: using guessed type int dword_100E8A8C[];
// 100E8A90: using guessed type int dword_100E8A90[];
// 100E8A94: using guessed type int dword_100E8A94[];
// 100E8A98: using guessed type int dword_100E8A98[];
// 100E8A9C: using guessed type int dword_100E8A9C[];
// 100E8AA0: using guessed type int dword_100E8AA0[];
// 100E8AA4: using guessed type char *off_100E8AA4;
// 102657B8: using guessed type char byte_102657B8;

//----- (10060AB0) --------------------------------------------------------
char sub_10060AB0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E900C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100E900A[v2 * 4];
        v4 = byte_100E9009[v2 * 4];
        v5 = byte_100E9008[v2 * 4];
        v6 = sub_1004A380(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100E9010)[v2 * 4]);
        v7 = sub_1004DE60(
               0,
               *(&dword_100E3C7C + dword_100E900C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E900C[v2]],
               (&off_100E9010)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E900C: using guessed type int dword_100E900C[];
// 100E9010: using guessed type char *off_100E9010;
// 102657B8: using guessed type char byte_102657B8;

//----- (10060C10) --------------------------------------------------------
char sub_10060C10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E9224[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100E9220[v2];
        v4 = dword_100E921C[v2];
        v5 = dword_100E9218[v2];
        v6 = sub_1004A380(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100E9228[v2 * 4]);
        v7 = sub_1004E250(
               0,
               *(&dword_100E3C7C + dword_100E9224[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E9224[v2]],
               *(_DWORD *)&off_100E9228[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E9218: using guessed type int dword_100E9218[];
// 100E921C: using guessed type int dword_100E921C[];
// 100E9220: using guessed type int dword_100E9220[];
// 100E9224: using guessed type int dword_100E9224[];
// 102657B8: using guessed type char byte_102657B8;

//----- (10060D70) --------------------------------------------------------
char sub_10060D70()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  int v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_102657B8 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100E958C + v2) )
      {
        sub_1004A0E0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100E9594[v2], 0x100u, &v11);
        sub_1004A0E0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100E958C + v2), 0x100u, &v12);
        sub_1005DC00(&v12, &v11);
      }
      if ( byte_100E9588[v2] )
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = *(int *)((char *)&off_100E9590 + v2);
        v4 = *(char **)&off_100E9594[v2];
        v5 = sub_1004A380(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100E9594[v2],
               *(void **)((char *)&off_100E9590 + v2));
        v6 = sub_1004EA00(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1004A6E0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = *(int *)((char *)&off_100E9590 + v2);
        v8 = *(char **)&off_100E9594[v2];
        v9 = sub_1004A380(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100E9594[v2],
               *(void **)((char *)&off_100E9590 + v2));
        v10 = sub_1004EA00(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1004A6E0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100E958C: using guessed type void *off_100E958C;
// 100E9590: using guessed type void *off_100E9590;
// 102657B8: using guessed type char byte_102657B8;

//----- (10060F90) --------------------------------------------------------
char sub_10060F90()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_102657B8 )
  {
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1004A6E0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1004A6E0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1004A6E0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1004A6E0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1004A6E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 102657B8: using guessed type char byte_102657B8;

//----- (10061190) --------------------------------------------------------
char sub_10061190()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E961C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100E9619[v2 * 4];
        v4 = byte_100E9618[v2 * 4];
        v5 = sub_1004A380(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + dword_100E961C[v2])],
               (&off_100E9620)[v2 * 4]);
        v6 = sub_1004A820(
               1,
               *(&dword_100E3C7C + dword_100E961C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1004A380(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E961C[v2]],
               (&off_100E9620)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E961C: using guessed type int dword_100E961C[];
// 100E9620: using guessed type char *off_100E9620;
// 102657B8: using guessed type char byte_102657B8;

//----- (10061310) --------------------------------------------------------
char sub_10061310()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100E98A0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100E9898[v2 / 8];
        v4 = dbl_100E9890[v2 / 8];
        v5 = dbl_100E9888[v2 / 8];
        v6 = sub_1004A380(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100E98A4)[v2]);
        v7 = sub_1004ABD0(
               1,
               *(&dword_100E3C7C + dword_100E98A0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100E98A0[v2 / 4]],
               (&off_100E98A4)[v2]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100E9888: using guessed type double dbl_100E9888[];
// 100E9890: using guessed type double dbl_100E9890[];
// 100E9898: using guessed type double dbl_100E9898[];
// 100E98A0: using guessed type int dword_100E98A0[];
// 100E98A4: using guessed type char *off_100E98A4;
// 102657B8: using guessed type char byte_102657B8;

//----- (10061490) --------------------------------------------------------
char sub_10061490()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EA4B4[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100EA4B0[v2];
        v4 = flt_100EA4AC[v2];
        v5 = flt_100EA4A8[v2];
        v6 = sub_1004A380(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100EA4B8[v2 * 4]);
        v7 = sub_1004B020(
               1,
               *(&dword_100E3C7C + dword_100EA4B4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EA4B4[v2]],
               *(_DWORD *)&off_100EA4B8[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EA4A8: using guessed type float flt_100EA4A8[];
// 100EA4AC: using guessed type float flt_100EA4AC[];
// 100EA4B0: using guessed type float flt_100EA4B0[];
// 100EA4B4: using guessed type int dword_100EA4B4[];
// 102657B8: using guessed type char byte_102657B8;

//----- (10061600) --------------------------------------------------------
char sub_10061600()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_102657B8 )
  {
    sub_1004ED00(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10061600,
      (int)sub_10061600,
      0);
    sub_1004ED00(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10061600,
      0,
      0);
    result = sub_1004ED00(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10061600,
               0);
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 102657B8: using guessed type char byte_102657B8;

//----- (100616F0) --------------------------------------------------------
char sub_100616F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EAC4C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100EAC48[v2];
        v4 = dword_100EAC44[v2];
        v5 = dword_100EAC40[v2];
        v6 = sub_1004A380(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100EAC50)[v2 * 4]);
        v7 = sub_1004B4E0(
               1,
               *(&dword_100E3C7C + dword_100EAC4C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EAC4C[v2]],
               (&off_100EAC50)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EAC40: using guessed type int dword_100EAC40[];
// 100EAC44: using guessed type int dword_100EAC44[];
// 100EAC48: using guessed type int dword_100EAC48[];
// 100EAC4C: using guessed type int dword_100EAC4C[];
// 100EAC50: using guessed type char *off_100EAC50;
// 102657B8: using guessed type char byte_102657B8;

//----- (10061850) --------------------------------------------------------
char sub_10061850()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EB3E0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100EB3DC[v2 / 2];
        v4 = word_100EB3DA[v2 / 2];
        v5 = word_100EB3D8[v2 / 2];
        v6 = sub_1004A380(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100EB3E4)[v2]);
        v7 = sub_1004B8A0(
               1,
               *(&dword_100E3C7C + dword_100EB3E0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EB3E0[v2 / 4]],
               (&off_100EB3E4)[v2]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EB3D8: using guessed type __int16 word_100EB3D8[];
// 100EB3DA: using guessed type __int16 word_100EB3DA[];
// 100EB3DC: using guessed type __int16 word_100EB3DC[];
// 100EB3E0: using guessed type int dword_100EB3E0[];
// 100EB3E4: using guessed type char *off_100EB3E4;
// 102657B8: using guessed type char byte_102657B8;

//----- (100619B0) --------------------------------------------------------
char sub_100619B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EB9F4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100EB9F0[v2];
        v4 = dword_100EB9EC[v2];
        v5 = dword_100EB9E8[v2];
        v6 = sub_1004A380(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100EB9F8[v2 * 4]);
        v7 = sub_1004BCA0(
               1,
               *(&dword_100E3C7C + dword_100EB9F4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EB9F4[v2]],
               *(_DWORD *)&off_100EB9F8[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EB9E8: using guessed type int dword_100EB9E8[];
// 100EB9EC: using guessed type int dword_100EB9EC[];
// 100EB9F0: using guessed type int dword_100EB9F0[];
// 100EB9F4: using guessed type int dword_100EB9F4[];
// 102657B8: using guessed type char byte_102657B8;

//----- (10061B10) --------------------------------------------------------
char sub_10061B10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EC198[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100EC194[v2];
        LODWORD(v3) = dword_100EC190[v2];
        HIDWORD(v4) = dword_100EC18C[v2];
        LODWORD(v4) = dword_100EC188[v2];
        HIDWORD(v5) = dword_100EC184[v2];
        LODWORD(v5) = dword_100EC180[v2];
        v6 = sub_1004A380(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100EC19C[v2 * 4]);
        v7 = sub_1004C060(
               1,
               *(&dword_100E3C7C + dword_100EC198[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EC198[v2]],
               *(_DWORD *)&off_100EC19C[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EC180: using guessed type int dword_100EC180[];
// 100EC184: using guessed type int dword_100EC184[];
// 100EC188: using guessed type int dword_100EC188[];
// 100EC18C: using guessed type int dword_100EC18C[];
// 100EC190: using guessed type int dword_100EC190[];
// 100EC194: using guessed type int dword_100EC194[];
// 100EC198: using guessed type int dword_100EC198[];
// 102657B8: using guessed type char byte_102657B8;

//----- (10061C80) --------------------------------------------------------
char sub_10061C80()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100ECDA4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100ECDA2[v2 * 4];
        v4 = byte_100ECDA1[v2 * 4];
        v5 = byte_100ECDA0[v2 * 4];
        v6 = sub_1004A380(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100ECDA8)[v2 * 4]);
        v7 = sub_1004C5A0(
               1,
               *(&dword_100E3C7C + dword_100ECDA4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100ECDA4[v2]],
               (&off_100ECDA8)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100ECDA4: using guessed type int dword_100ECDA4[];
// 100ECDA8: using guessed type char *off_100ECDA8;
// 102657B8: using guessed type char byte_102657B8;

//----- (10061DE0) --------------------------------------------------------
char sub_10061DE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100ED23C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100ED238[v2];
        v4 = dword_100ED234[v2];
        v5 = dword_100ED230[v2];
        v6 = sub_1004A380(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100ED240)[v2 * 4]);
        v7 = sub_1004C980(
               1,
               *(&dword_100E3C7C + dword_100ED23C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100ED23C[v2]],
               (&off_100ED240)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100ED230: using guessed type int dword_100ED230[];
// 100ED234: using guessed type int dword_100ED234[];
// 100ED238: using guessed type int dword_100ED238[];
// 100ED23C: using guessed type int dword_100ED23C[];
// 100ED240: using guessed type char *off_100ED240;
// 102657B8: using guessed type char byte_102657B8;

//----- (10061F40) --------------------------------------------------------
char sub_10061F40()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_102657B8 )
  {
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_1004EDB0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           byte_100879F8,
           0);
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_1004EDB0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           byte_100879F8,
           "a",
           0);
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_1004EDB0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           byte_100879F8,
           byte_100879F8,
           0);
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_1004EDB0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1004A6E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 102657B8: using guessed type char byte_102657B8;

//----- (10062140) --------------------------------------------------------
char sub_10062140()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100ED9D4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100ED9D0[v2];
        v4 = dword_100ED9CC[v2];
        v5 = dword_100ED9C8[v2];
        v6 = sub_1004A380(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100ED9D8[v2 * 4]);
        v7 = sub_1004CD40(
               1,
               *(&dword_100E3C7C + dword_100ED9D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100ED9D4[v2]],
               *(_DWORD *)&off_100ED9D8[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100ED9C8: using guessed type int dword_100ED9C8[];
// 100ED9CC: using guessed type int dword_100ED9CC[];
// 100ED9D0: using guessed type int dword_100ED9D0[];
// 100ED9D4: using guessed type int dword_100ED9D4[];
// 102657B8: using guessed type char byte_102657B8;

//----- (100622A0) --------------------------------------------------------
char sub_100622A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EDD40[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100EDD3C[v2 / 2];
        v4 = word_100EDD3A[v2 / 2];
        v5 = word_100EDD38[v2 / 2];
        v6 = sub_1004A380(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100EDD44)[v2]);
        v7 = sub_1004D0E0(
               1,
               *(&dword_100E3C7C + dword_100EDD40[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EDD40[v2 / 4]],
               (&off_100EDD44)[v2]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EDD38: using guessed type __int16 word_100EDD38[];
// 100EDD3A: using guessed type __int16 word_100EDD3A[];
// 100EDD3C: using guessed type __int16 word_100EDD3C[];
// 100EDD40: using guessed type int dword_100EDD40[];
// 100EDD44: using guessed type char *off_100EDD44;
// 102657B8: using guessed type char byte_102657B8;

//----- (10062400) --------------------------------------------------------
char sub_10062400()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EE004[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100EE000[v2];
        v4 = dword_100EDFFC[v2];
        v5 = dword_100EDFF8[v2];
        v6 = sub_1004A380(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100EE008[v2 * 4]);
        v7 = sub_1004D4E0(
               1,
               *(&dword_100E3C7C + dword_100EE004[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EE004[v2]],
               *(_DWORD *)&off_100EE008[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EDFF8: using guessed type int dword_100EDFF8[];
// 100EDFFC: using guessed type int dword_100EDFFC[];
// 100EE000: using guessed type int dword_100EE000[];
// 100EE004: using guessed type int dword_100EE004[];
// 102657B8: using guessed type char byte_102657B8;

//----- (10062560) --------------------------------------------------------
char sub_10062560()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EE380[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100EE37C[v2];
        LODWORD(v3) = dword_100EE378[v2];
        HIDWORD(v4) = dword_100EE374[v2];
        LODWORD(v4) = dword_100EE370[v2];
        HIDWORD(v5) = dword_100EE36C[v2];
        LODWORD(v5) = dword_100EE368[v2];
        v6 = sub_1004A380(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100EE384)[v2 * 4]);
        v7 = sub_1004D880(
               1,
               *(&dword_100E3C7C + dword_100EE380[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EE380[v2]],
               (&off_100EE384)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EE368: using guessed type int dword_100EE368[];
// 100EE36C: using guessed type int dword_100EE36C[];
// 100EE370: using guessed type int dword_100EE370[];
// 100EE374: using guessed type int dword_100EE374[];
// 100EE378: using guessed type int dword_100EE378[];
// 100EE37C: using guessed type int dword_100EE37C[];
// 100EE380: using guessed type int dword_100EE380[];
// 100EE384: using guessed type char *off_100EE384;
// 102657B8: using guessed type char byte_102657B8;

//----- (100626D0) --------------------------------------------------------
char sub_100626D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EE8EC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100EE8EA[v2 * 4];
        v4 = byte_100EE8E9[v2 * 4];
        v5 = byte_100EE8E8[v2 * 4];
        v6 = sub_1004A380(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               (&off_100EE8F0)[v2 * 4]);
        v7 = sub_1004DE60(
               1,
               *(&dword_100E3C7C + dword_100EE8EC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EE8EC[v2]],
               (&off_100EE8F0)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EE8EC: using guessed type int dword_100EE8EC[];
// 100EE8F0: using guessed type char *off_100EE8F0;
// 102657B8: using guessed type char byte_102657B8;

//----- (10062830) --------------------------------------------------------
char sub_10062830()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_102657B8 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EEB04[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100EEB00[v2];
        v4 = dword_100EEAFC[v2];
        v5 = dword_100EEAF8[v2];
        v6 = sub_1004A380(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * *(&dword_100E3C7C + v0)],
               *(_DWORD *)&off_100EEB08[v2 * 4]);
        v7 = sub_1004E250(
               1,
               *(&dword_100E3C7C + dword_100EEB04[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A380(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EEB04[v2]],
               *(_DWORD *)&off_100EEB08[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100EEAF8: using guessed type int dword_100EEAF8[];
// 100EEAFC: using guessed type int dword_100EEAFC[];
// 100EEB00: using guessed type int dword_100EEB00[];
// 100EEB04: using guessed type int dword_100EEB04[];
// 102657B8: using guessed type char byte_102657B8;

//----- (10062990) --------------------------------------------------------
char sub_10062990()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_102657B9 )
  {
    sub_1004EDB0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10049920(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1004B4E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_100453B0() )
      v1 = 3;
    sub_1004B4E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_100453B0();
    sub_1004B4E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10049920(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1004B4E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 102657B9: using guessed type char byte_102657B9;

//----- (10062F30) --------------------------------------------------------
char sub_10062F30()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_102657B9 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100EEE6C + v2) )
      {
        sub_1004A0E0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100EEE74[v2], 0x100u, &v13);
        sub_1004A0E0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100EEE6C + v2), 0x100u, &v14);
        sub_1005DC00(&v14, &v13);
      }
      if ( byte_100EEE68[v2] )
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = *(int *)((char *)&off_100EEE70 + v2);
        v4 = *(char **)&off_100EEE74[v2];
        v5 = sub_1004A380(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100EEE74[v2],
               *(void **)((char *)&off_100EEE70 + v2));
        v12 = 1;
        v11 = sub_1004EA00(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2114", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = *(int *)((char *)&off_100EEE70 + v2);
        v7 = *(char **)&off_100EEE74[v2];
        v8 = sub_1004A380(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100EEE74[v2],
               *(void **)((char *)&off_100EEE70 + v2));
        v12 = 1;
        v11 = sub_1004EA00(0, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2123", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100EEE6C: using guessed type void *off_100EEE6C;
// 100EEE70: using guessed type void *off_100EEE70;
// 102657B9: using guessed type char byte_102657B9;

//----- (10063140) --------------------------------------------------------
char sub_10063140()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_102657B9 )
  {
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1004A6E0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1004A6E0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1004A6E0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1004A6E0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1004A6E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 102657B9: using guessed type char byte_102657B9;

//----- (10063330) --------------------------------------------------------
char sub_10063330()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100EEEBC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100EEEB9[v2 * 4];
        v4 = byte_100EEEB8[v2 * 4];
        v5 = sub_1004A380(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * dword_100EEEBC[v2]],
               (&off_100EEEC0)[v2 * 4]);
        v6 = sub_1004A820(0, dword_100EEEBC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1004A380(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100EEEBC[v2]],
               (&off_100EEEC0)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100EEEBC: using guessed type int dword_100EEEBC[];
// 100EEEC0: using guessed type char *off_100EEEC0;
// 102657B9: using guessed type char byte_102657B9;

//----- (100634A0) --------------------------------------------------------
char sub_100634A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100EF138[v2 / 2];
      v4 = dbl_100EF130[v2 / 2];
      v5 = dbl_100EF128[v2 / 2];
      v6 = sub_1004A380(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100EF140[v2]],
             (&off_100EF144)[v2 * 4]);
      v7 = sub_1004ABD0(0, dword_100EF140[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100EF140[v2]],
             (&off_100EF144)[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100EF128: using guessed type double dbl_100EF128[];
// 100EF130: using guessed type double dbl_100EF130[];
// 100EF138: using guessed type double dbl_100EF138[];
// 100EF140: using guessed type int dword_100EF140[];
// 100EF144: using guessed type char *off_100EF144;
// 102657B9: using guessed type char byte_102657B9;

//----- (10063610) --------------------------------------------------------
char sub_10063610()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100EFD50[v2];
      v4 = flt_100EFD4C[v2];
      v5 = flt_100EFD48[v2];
      v6 = sub_1004A380(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100EFD54[v2]],
             *(_DWORD *)&off_100EFD58[v2 * 4]);
      v7 = sub_1004B020(0, dword_100EFD54[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100EFD54[v2]],
             *(_DWORD *)&off_100EFD58[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100EFD48: using guessed type float flt_100EFD48[];
// 100EFD4C: using guessed type float flt_100EFD4C[];
// 100EFD50: using guessed type float flt_100EFD50[];
// 100EFD54: using guessed type int dword_100EFD54[];
// 102657B9: using guessed type char byte_102657B9;

//----- (10063770) --------------------------------------------------------
char sub_10063770()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_102657B9 )
  {
    sub_1004ED00(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_10063770,
      (int)sub_10063770,
      0);
    sub_1004ED00(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_10063770,
      0,
      0);
    result = sub_1004ED00(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10063770,
               0);
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 102657B9: using guessed type char byte_102657B9;

//----- (10063860) --------------------------------------------------------
char sub_10063860()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100F04E8[v2];
      v4 = dword_100F04E4[v2];
      v5 = dword_100F04E0[v2];
      v6 = sub_1004A380(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F04EC[v2]],
             (&off_100F04F0)[v2 * 4]);
      v7 = sub_1004B4E0(0, dword_100F04EC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F04EC[v2]],
             (&off_100F04F0)[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F04E0: using guessed type int dword_100F04E0[];
// 100F04E4: using guessed type int dword_100F04E4[];
// 100F04E8: using guessed type int dword_100F04E8[];
// 100F04EC: using guessed type int dword_100F04EC[];
// 100F04F0: using guessed type char *off_100F04F0;
// 102657B9: using guessed type char byte_102657B9;

//----- (100639C0) --------------------------------------------------------
char sub_100639C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100F0C7C[v2 / 2];
      v4 = word_100F0C7A[v2 / 2];
      v5 = word_100F0C78[v2 / 2];
      v6 = sub_1004A380(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F0C80[v2 / 4]],
             (&off_100F0C84)[v2]);
      v7 = sub_1004B8A0(
             0,
             dword_100F0C80[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F0C80[v2 / 4]],
             (&off_100F0C84)[v2]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F0C78: using guessed type __int16 word_100F0C78[];
// 100F0C7A: using guessed type __int16 word_100F0C7A[];
// 100F0C7C: using guessed type __int16 word_100F0C7C[];
// 100F0C80: using guessed type int dword_100F0C80[];
// 100F0C84: using guessed type char *off_100F0C84;
// 102657B9: using guessed type char byte_102657B9;

//----- (10063B20) --------------------------------------------------------
char sub_10063B20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100F1290[v2];
      v4 = dword_100F128C[v2];
      v5 = dword_100F1288[v2];
      v6 = sub_1004A380(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F1294[v2]],
             *(_DWORD *)&off_100F1298[v2 * 4]);
      v7 = sub_1004BCA0(0, dword_100F1294[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F1294[v2]],
             *(_DWORD *)&off_100F1298[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F1288: using guessed type int dword_100F1288[];
// 100F128C: using guessed type int dword_100F128C[];
// 100F1290: using guessed type int dword_100F1290[];
// 100F1294: using guessed type int dword_100F1294[];
// 102657B9: using guessed type char byte_102657B9;

//----- (10063C80) --------------------------------------------------------
char sub_10063C80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100F1A34[v2];
      LODWORD(v3) = dword_100F1A30[v2];
      HIDWORD(v4) = dword_100F1A2C[v2];
      LODWORD(v4) = dword_100F1A28[v2];
      HIDWORD(v5) = dword_100F1A24[v2];
      LODWORD(v5) = dword_100F1A20[v2];
      v6 = sub_1004A380(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F1A38[v2]],
             *(_DWORD *)&off_100F1A3C[v2 * 4]);
      v7 = sub_1004C060(0, dword_100F1A38[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F1A38[v2]],
             *(_DWORD *)&off_100F1A3C[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F1A20: using guessed type int dword_100F1A20[];
// 100F1A24: using guessed type int dword_100F1A24[];
// 100F1A28: using guessed type int dword_100F1A28[];
// 100F1A2C: using guessed type int dword_100F1A2C[];
// 100F1A30: using guessed type int dword_100F1A30[];
// 100F1A34: using guessed type int dword_100F1A34[];
// 100F1A38: using guessed type int dword_100F1A38[];
// 102657B9: using guessed type char byte_102657B9;

//----- (10063DF0) --------------------------------------------------------
char sub_10063DF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100F2642[v2 * 4];
      v4 = byte_100F2641[v2 * 4];
      v5 = byte_100F2640[v2 * 4];
      v6 = sub_1004A380(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F2644[v2]],
             (&off_100F2648)[v2 * 4]);
      v7 = sub_1004C5A0(0, dword_100F2644[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F2644[v2]],
             (&off_100F2648)[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F2644: using guessed type int dword_100F2644[];
// 100F2648: using guessed type char *off_100F2648;
// 102657B9: using guessed type char byte_102657B9;

//----- (10063F50) --------------------------------------------------------
char sub_10063F50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100F2AD8[v2];
      v4 = dword_100F2AD4[v2];
      v5 = dword_100F2AD0[v2];
      v6 = sub_1004A380(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F2ADC[v2]],
             (&off_100F2AE0)[v2 * 4]);
      v7 = sub_1004C980(0, dword_100F2ADC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F2ADC[v2]],
             (&off_100F2AE0)[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F2AD0: using guessed type int dword_100F2AD0[];
// 100F2AD4: using guessed type int dword_100F2AD4[];
// 100F2AD8: using guessed type int dword_100F2AD8[];
// 100F2ADC: using guessed type int dword_100F2ADC[];
// 100F2AE0: using guessed type char *off_100F2AE0;
// 102657B9: using guessed type char byte_102657B9;

//----- (100640B0) --------------------------------------------------------
char sub_100640B0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_102657B9 )
  {
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_1004EDB0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           byte_100879F8,
           byte_100879F8,
           0);
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_1004EDB0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_1004EDB0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           byte_100879F8,
           0);
    sub_1004A6E0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_1004EDB0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1004A6E0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 102657B9: using guessed type char byte_102657B9;

//----- (100642B0) --------------------------------------------------------
char sub_100642B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100F3270[v2];
      v4 = dword_100F326C[v2];
      v5 = dword_100F3268[v2];
      v6 = sub_1004A380(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F3274[v2]],
             *(_DWORD *)&off_100F3278[v2 * 4]);
      v7 = sub_1004CD40(0, dword_100F3274[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F3274[v2]],
             *(_DWORD *)&off_100F3278[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F3268: using guessed type int dword_100F3268[];
// 100F326C: using guessed type int dword_100F326C[];
// 100F3270: using guessed type int dword_100F3270[];
// 100F3274: using guessed type int dword_100F3274[];
// 102657B9: using guessed type char byte_102657B9;

//----- (10064410) --------------------------------------------------------
char sub_10064410()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100F35DC[v2 / 2];
      v4 = word_100F35DA[v2 / 2];
      v5 = word_100F35D8[v2 / 2];
      v6 = sub_1004A380(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F35E0[v2 / 4]],
             (&off_100F35E4)[v2]);
      v7 = sub_1004D0E0(
             0,
             dword_100F35E0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F35E0[v2 / 4]],
             (&off_100F35E4)[v2]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F35D8: using guessed type __int16 word_100F35D8[];
// 100F35DA: using guessed type __int16 word_100F35DA[];
// 100F35DC: using guessed type __int16 word_100F35DC[];
// 100F35E0: using guessed type int dword_100F35E0[];
// 100F35E4: using guessed type char *off_100F35E4;
// 102657B9: using guessed type char byte_102657B9;

//----- (10064570) --------------------------------------------------------
char sub_10064570()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100F38A0[v2];
      v4 = dword_100F389C[v2];
      v5 = dword_100F3898[v2];
      v6 = sub_1004A380(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F38A4[v2]],
             *(_DWORD *)&off_100F38A8[v2 * 4]);
      v7 = sub_1004D4E0(0, dword_100F38A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F38A4[v2]],
             *(_DWORD *)&off_100F38A8[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F3898: using guessed type int dword_100F3898[];
// 100F389C: using guessed type int dword_100F389C[];
// 100F38A0: using guessed type int dword_100F38A0[];
// 100F38A4: using guessed type int dword_100F38A4[];
// 102657B9: using guessed type char byte_102657B9;

//----- (100646D0) --------------------------------------------------------
char sub_100646D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100F3C1C[v2];
      LODWORD(v3) = dword_100F3C18[v2];
      HIDWORD(v4) = dword_100F3C14[v2];
      LODWORD(v4) = dword_100F3C10[v2];
      HIDWORD(v5) = dword_100F3C0C[v2];
      LODWORD(v5) = dword_100F3C08[v2];
      v6 = sub_1004A380(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F3C20[v2]],
             (&off_100F3C24)[v2 * 4]);
      v7 = sub_1004D880(0, dword_100F3C20[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F3C20[v2]],
             (&off_100F3C24)[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F3C08: using guessed type int dword_100F3C08[];
// 100F3C0C: using guessed type int dword_100F3C0C[];
// 100F3C10: using guessed type int dword_100F3C10[];
// 100F3C14: using guessed type int dword_100F3C14[];
// 100F3C18: using guessed type int dword_100F3C18[];
// 100F3C1C: using guessed type int dword_100F3C1C[];
// 100F3C20: using guessed type int dword_100F3C20[];
// 100F3C24: using guessed type char *off_100F3C24;
// 102657B9: using guessed type char byte_102657B9;

//----- (10064840) --------------------------------------------------------
char sub_10064840()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100F418A[v2 * 4];
      v4 = byte_100F4189[v2 * 4];
      v5 = byte_100F4188[v2 * 4];
      v6 = sub_1004A380(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F418C[v2]],
             (&off_100F4190)[v2 * 4]);
      v7 = sub_1004DE60(0, dword_100F418C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F418C[v2]],
             (&off_100F4190)[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F418C: using guessed type int dword_100F418C[];
// 100F4190: using guessed type char *off_100F4190;
// 102657B9: using guessed type char byte_102657B9;

//----- (100649A0) --------------------------------------------------------
char sub_100649A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100F43A0[v2];
      v4 = dword_100F439C[v2];
      v5 = dword_100F4398[v2];
      v6 = sub_1004A380(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F43A4[v2]],
             *(_DWORD *)&off_100F43A8[v2 * 4]);
      v7 = sub_1004E250(0, dword_100F43A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F43A4[v2]],
             *(_DWORD *)&off_100F43A8[v2 * 4]);
      result = sub_1004A6E0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F4398: using guessed type int dword_100F4398[];
// 100F439C: using guessed type int dword_100F439C[];
// 100F43A0: using guessed type int dword_100F43A0[];
// 100F43A4: using guessed type int dword_100F43A4[];
// 102657B9: using guessed type char byte_102657B9;

//----- (10064B00) --------------------------------------------------------
char sub_10064B00()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_102657B9 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100F470C + v2) )
      {
        sub_1004A0E0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100F4714[v2], 0x100u, &v13);
        sub_1004A0E0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100F470C + v2), 0x100u, &v14);
        sub_1005DC00(&v14, &v13);
      }
      if ( byte_100F4708[v2] )
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = *(int *)((char *)&off_100F4710 + v2);
        v4 = *(char **)&off_100F4714[v2];
        v5 = sub_1004A380(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100F4714[v2],
               *(void **)((char *)&off_100F4710 + v2));
        v12 = 1;
        v11 = sub_1004EA00(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2745", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = *(int *)((char *)&off_100F4710 + v2);
        v7 = *(char **)&off_100F4714[v2];
        v8 = sub_1004A380(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100F4714[v2],
               *(void **)((char *)&off_100F4710 + v2));
        v12 = 1;
        v11 = sub_1004EA00(1, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2754", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F470C: using guessed type void *off_100F470C;
// 100F4710: using guessed type void *off_100F4710;
// 102657B9: using guessed type char byte_102657B9;

//----- (10064D10) --------------------------------------------------------
char sub_10064D10()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_102657B9 )
  {
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1004A6E0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1004A6E0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1004A6E0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1004A6E0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1004A6E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 102657B9: using guessed type char byte_102657B9;

//----- (10064F00) --------------------------------------------------------
char sub_10064F00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      v0 = dword_100F475C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100F4759[v2 * 4];
        v4 = byte_100F4758[v2 * 4];
        v5 = sub_1004A380(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100E3C60[4 * dword_100F475C[v2]],
               (&off_100F4760)[v2 * 4]);
        v6 = sub_1004A820(1, dword_100F475C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1004A380(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100E3C60[4 * dword_100F475C[v2]],
               (&off_100F4760)[v2 * 4]);
        LOBYTE(v0) = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049920(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100F475C: using guessed type int dword_100F475C[];
// 100F4760: using guessed type char *off_100F4760;
// 102657B9: using guessed type char byte_102657B9;

//----- (10065070) --------------------------------------------------------
char sub_10065070()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100F49D8[v2 / 2];
      v4 = dbl_100F49D0[v2 / 2];
      v5 = dbl_100F49C8[v2 / 2];
      v6 = sub_1004A380(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F49E0[v2]],
             (&off_100F49E4)[v2 * 4]);
      v7 = sub_1004ABD0(1, dword_100F49E0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F49E0[v2]],
             (&off_100F49E4)[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F49C8: using guessed type double dbl_100F49C8[];
// 100F49D0: using guessed type double dbl_100F49D0[];
// 100F49D8: using guessed type double dbl_100F49D8[];
// 100F49E0: using guessed type int dword_100F49E0[];
// 100F49E4: using guessed type char *off_100F49E4;
// 102657B9: using guessed type char byte_102657B9;

//----- (100651E0) --------------------------------------------------------
char sub_100651E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100F55F0[v2];
      v4 = flt_100F55EC[v2];
      v5 = flt_100F55E8[v2];
      v6 = sub_1004A380(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F55F4[v2]],
             *(_DWORD *)&off_100F55F8[v2 * 4]);
      v7 = sub_1004B020(1, dword_100F55F4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F55F4[v2]],
             *(_DWORD *)&off_100F55F8[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F55E8: using guessed type float flt_100F55E8[];
// 100F55EC: using guessed type float flt_100F55EC[];
// 100F55F0: using guessed type float flt_100F55F0[];
// 100F55F4: using guessed type int dword_100F55F4[];
// 102657B9: using guessed type char byte_102657B9;

//----- (10065340) --------------------------------------------------------
char sub_10065340()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_102657B9 )
  {
    sub_1004ED00(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_10065340,
      (int)sub_10065340,
      0);
    sub_1004ED00(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_10065340,
      0,
      0);
    result = sub_1004ED00(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10065340,
               0);
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 102657B9: using guessed type char byte_102657B9;

//----- (10065430) --------------------------------------------------------
char sub_10065430()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100F5D88[v2];
      v4 = dword_100F5D84[v2];
      v5 = dword_100F5D80[v2];
      v6 = sub_1004A380(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F5D8C[v2]],
             (&off_100F5D90)[v2 * 4]);
      v7 = sub_1004B4E0(1, dword_100F5D8C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F5D8C[v2]],
             (&off_100F5D90)[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F5D80: using guessed type int dword_100F5D80[];
// 100F5D84: using guessed type int dword_100F5D84[];
// 100F5D88: using guessed type int dword_100F5D88[];
// 100F5D8C: using guessed type int dword_100F5D8C[];
// 100F5D90: using guessed type char *off_100F5D90;
// 102657B9: using guessed type char byte_102657B9;

//----- (10065590) --------------------------------------------------------
char sub_10065590()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100F651C[v2 / 2];
      v4 = word_100F651A[v2 / 2];
      v5 = word_100F6518[v2 / 2];
      v6 = sub_1004A380(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F6520[v2 / 4]],
             (&off_100F6524)[v2]);
      v7 = sub_1004B8A0(
             1,
             dword_100F6520[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F6520[v2 / 4]],
             (&off_100F6524)[v2]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F6518: using guessed type __int16 word_100F6518[];
// 100F651A: using guessed type __int16 word_100F651A[];
// 100F651C: using guessed type __int16 word_100F651C[];
// 100F6520: using guessed type int dword_100F6520[];
// 100F6524: using guessed type char *off_100F6524;
// 102657B9: using guessed type char byte_102657B9;

//----- (100656F0) --------------------------------------------------------
char sub_100656F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100F6B30[v2];
      v4 = dword_100F6B2C[v2];
      v5 = dword_100F6B28[v2];
      v6 = sub_1004A380(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F6B34[v2]],
             *(_DWORD *)&off_100F6B38[v2 * 4]);
      v7 = sub_1004BCA0(1, dword_100F6B34[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F6B34[v2]],
             *(_DWORD *)&off_100F6B38[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F6B28: using guessed type int dword_100F6B28[];
// 100F6B2C: using guessed type int dword_100F6B2C[];
// 100F6B30: using guessed type int dword_100F6B30[];
// 100F6B34: using guessed type int dword_100F6B34[];
// 102657B9: using guessed type char byte_102657B9;

//----- (10065850) --------------------------------------------------------
char sub_10065850()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100F72D4[v2];
      LODWORD(v3) = dword_100F72D0[v2];
      HIDWORD(v4) = dword_100F72CC[v2];
      LODWORD(v4) = dword_100F72C8[v2];
      HIDWORD(v5) = dword_100F72C4[v2];
      LODWORD(v5) = dword_100F72C0[v2];
      v6 = sub_1004A380(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F72D8[v2]],
             *(_DWORD *)&off_100F72DC[v2 * 4]);
      v7 = sub_1004C060(1, dword_100F72D8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F72D8[v2]],
             *(_DWORD *)&off_100F72DC[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F72C0: using guessed type int dword_100F72C0[];
// 100F72C4: using guessed type int dword_100F72C4[];
// 100F72C8: using guessed type int dword_100F72C8[];
// 100F72CC: using guessed type int dword_100F72CC[];
// 100F72D0: using guessed type int dword_100F72D0[];
// 100F72D4: using guessed type int dword_100F72D4[];
// 100F72D8: using guessed type int dword_100F72D8[];
// 102657B9: using guessed type char byte_102657B9;

//----- (100659C0) --------------------------------------------------------
char sub_100659C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100F7EE2[v2 * 4];
      v4 = byte_100F7EE1[v2 * 4];
      v5 = byte_100F7EE0[v2 * 4];
      v6 = sub_1004A380(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F7EE4[v2]],
             (&off_100F7EE8)[v2 * 4]);
      v7 = sub_1004C5A0(1, dword_100F7EE4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F7EE4[v2]],
             (&off_100F7EE8)[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F7EE4: using guessed type int dword_100F7EE4[];
// 100F7EE8: using guessed type char *off_100F7EE8;
// 102657B9: using guessed type char byte_102657B9;

//----- (10065B20) --------------------------------------------------------
char sub_10065B20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100F8378[v2];
      v4 = dword_100F8374[v2];
      v5 = dword_100F8370[v2];
      v6 = sub_1004A380(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F837C[v2]],
             (&off_100F8380)[v2 * 4]);
      v7 = sub_1004C980(1, dword_100F837C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F837C[v2]],
             (&off_100F8380)[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F8370: using guessed type int dword_100F8370[];
// 100F8374: using guessed type int dword_100F8374[];
// 100F8378: using guessed type int dword_100F8378[];
// 100F837C: using guessed type int dword_100F837C[];
// 100F8380: using guessed type char *off_100F8380;
// 102657B9: using guessed type char byte_102657B9;

//----- (10065C80) --------------------------------------------------------
char sub_10065C80()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049920(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1004A270(0);
  sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10049920(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_102657B9 )
  {
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_1004EDB0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           byte_100879F8,
           byte_100879F8,
           0);
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_1004EDB0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_1004EDB0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           byte_100879F8,
           0);
    sub_1004A6E0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_1004EDB0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1004A6E0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 102657B9: using guessed type char byte_102657B9;

//----- (10065E80) --------------------------------------------------------
char sub_10065E80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100F8B10[v2];
      v4 = dword_100F8B0C[v2];
      v5 = dword_100F8B08[v2];
      v6 = sub_1004A380(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F8B14[v2]],
             *(_DWORD *)&off_100F8B18[v2 * 4]);
      v7 = sub_1004CD40(1, dword_100F8B14[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F8B14[v2]],
             *(_DWORD *)&off_100F8B18[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F8B08: using guessed type int dword_100F8B08[];
// 100F8B0C: using guessed type int dword_100F8B0C[];
// 100F8B10: using guessed type int dword_100F8B10[];
// 100F8B14: using guessed type int dword_100F8B14[];
// 102657B9: using guessed type char byte_102657B9;

//----- (10065FE0) --------------------------------------------------------
char sub_10065FE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100F8E7C[v2 / 2];
      v4 = word_100F8E7A[v2 / 2];
      v5 = word_100F8E78[v2 / 2];
      v6 = sub_1004A380(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F8E80[v2 / 4]],
             (&off_100F8E84)[v2]);
      v7 = sub_1004D0E0(
             1,
             dword_100F8E80[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F8E80[v2 / 4]],
             (&off_100F8E84)[v2]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F8E78: using guessed type __int16 word_100F8E78[];
// 100F8E7A: using guessed type __int16 word_100F8E7A[];
// 100F8E7C: using guessed type __int16 word_100F8E7C[];
// 100F8E80: using guessed type int dword_100F8E80[];
// 100F8E84: using guessed type char *off_100F8E84;
// 102657B9: using guessed type char byte_102657B9;

//----- (10066140) --------------------------------------------------------
char sub_10066140()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100F9140[v2];
      v4 = dword_100F913C[v2];
      v5 = dword_100F9138[v2];
      v6 = sub_1004A380(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F9144[v2]],
             *(_DWORD *)&off_100F9148[v2 * 4]);
      v7 = sub_1004D4E0(1, dword_100F9144[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F9144[v2]],
             *(_DWORD *)&off_100F9148[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F9138: using guessed type int dword_100F9138[];
// 100F913C: using guessed type int dword_100F913C[];
// 100F9140: using guessed type int dword_100F9140[];
// 100F9144: using guessed type int dword_100F9144[];
// 102657B9: using guessed type char byte_102657B9;

//----- (100662A0) --------------------------------------------------------
char sub_100662A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100F94BC[v2];
      LODWORD(v3) = dword_100F94B8[v2];
      HIDWORD(v4) = dword_100F94B4[v2];
      LODWORD(v4) = dword_100F94B0[v2];
      HIDWORD(v5) = dword_100F94AC[v2];
      LODWORD(v5) = dword_100F94A8[v2];
      v6 = sub_1004A380(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F94C0[v2]],
             (&off_100F94C4)[v2 * 4]);
      v7 = sub_1004D880(1, dword_100F94C0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F94C0[v2]],
             (&off_100F94C4)[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F94A8: using guessed type int dword_100F94A8[];
// 100F94AC: using guessed type int dword_100F94AC[];
// 100F94B0: using guessed type int dword_100F94B0[];
// 100F94B4: using guessed type int dword_100F94B4[];
// 100F94B8: using guessed type int dword_100F94B8[];
// 100F94BC: using guessed type int dword_100F94BC[];
// 100F94C0: using guessed type int dword_100F94C0[];
// 100F94C4: using guessed type char *off_100F94C4;
// 102657B9: using guessed type char byte_102657B9;

//----- (10066410) --------------------------------------------------------
char sub_10066410()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100F9A2A[v2 * 4];
      v4 = byte_100F9A29[v2 * 4];
      v5 = byte_100F9A28[v2 * 4];
      v6 = sub_1004A380(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F9A2C[v2]],
             (&off_100F9A30)[v2 * 4]);
      v7 = sub_1004DE60(1, dword_100F9A2C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F9A2C[v2]],
             (&off_100F9A30)[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F9A2C: using guessed type int dword_100F9A2C[];
// 100F9A30: using guessed type char *off_100F9A30;
// 102657B9: using guessed type char byte_102657B9;

//----- (10066570) --------------------------------------------------------
char sub_10066570()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_102657B9 )
  {
    sub_10049920(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1004A270(0);
    sub_10049920(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10049920(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A360(0);
    v2 = 0;
    do
    {
      sub_1004A290((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100F9C40[v2];
      v4 = dword_100F9C3C[v2];
      v5 = dword_100F9C38[v2];
      v6 = sub_1004A380(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100E3C60[4 * dword_100F9C44[v2]],
             *(_DWORD *)&off_100F9C48[v2 * 4]);
      v7 = sub_1004E250(1, dword_100F9C44[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A380(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100E3C60[4 * dword_100F9C44[v2]],
             *(_DWORD *)&off_100F9C48[v2 * 4]);
      result = sub_1004A6E0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049920(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100F9C38: using guessed type int dword_100F9C38[];
// 100F9C3C: using guessed type int dword_100F9C3C[];
// 100F9C40: using guessed type int dword_100F9C40[];
// 100F9C44: using guessed type int dword_100F9C44[];
// 102657B9: using guessed type char byte_102657B9;

//----- (100666D0) --------------------------------------------------------
char **sub_100666D0()
{
  return off_100E534C;
}
// 100E534C: using guessed type char *off_100E534C[3];

//----- (100666E0) --------------------------------------------------------
int __cdecl sub_100666E0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (10066700) --------------------------------------------------------
int (__cdecl *__usercall sub_10066700@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (10066710) --------------------------------------------------------
int __usercall sub_10066710@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (10066940) --------------------------------------------------------
int (__cdecl *__cdecl sub_10066940(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10066700(a1, (int)" ");
  sub_10066700(a1, a2);
  sub_10066700(a1, (int)&unk_100FDE94);
  v3 = sub_10066710(a3, a1);
  sub_10066700(a1, v3);
  return sub_10066700(a1, (int)&unk_100FDE90);
}

//----- (10066990) --------------------------------------------------------
int (__cdecl *__cdecl sub_10066990(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_10066700(a1, (int)" ");
  sub_10066700(a1, a2);
  sub_10066700(a1, (int)&unk_100FDE9C);
  v3 = sub_10066710(a3, a1);
  sub_10066700(a1, v3);
  return sub_10066700(a1, (int)&unk_100FDE98);
}

//----- (100669E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100669E0(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_10066700(a1, (int)&unk_100FDEA0);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_10066710(a2, a1);
    result = sub_10066700(a1, v3);
  }
  return result;
}

//----- (10066A30) --------------------------------------------------------
int (__cdecl *__cdecl sub_10066A30(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100FDEA8;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_10066700(a1, dword_100FDDFC[(signed int)result]);
      sub_10066700(a1, (int)&unk_100FDEA4);
      sub_10066700(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100FDEA0;
    }
    result = sub_10066700(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_10066700(a1, (int)&word_10085470);
  }
  return result;
}
// 10085470: using guessed type __int16 word_10085470;
// 100FDDFC: using guessed type int dword_100FDDFC[];

//----- (10066AB0) --------------------------------------------------------
int __cdecl sub_10066AB0(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_10066700(a1, (int)&unk_100FDEA0);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_10066700(a1, *((_DWORD *)&off_100FDE00 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_10066700(a1, (int)&unk_100FDEAC);
  sub_10066700(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (10066B30) --------------------------------------------------------
int (__cdecl *__cdecl sub_10066B30(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_10066710(a2, a1);
    sub_10066700(a1, v3);
    result = sub_10066700(a1, (int)&word_10085470);
  }
  else
  {
    sub_10066700(a1, (int)a2);
    result = sub_10066700(a1, (int)&word_10085470);
  }
  return result;
}
// 10085470: using guessed type __int16 word_10085470;

//----- (10066B80) --------------------------------------------------------
int (__cdecl *__cdecl sub_10066B80(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_10066AB0(a1, a2);
  if ( a3 && *a3 )
    sub_100669E0(a1, a3);
  return sub_10066A30(a1);
}

//----- (10066BC0) --------------------------------------------------------
int (__cdecl *__cdecl sub_10066BC0(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_10066B80(a1, a2, (unsigned __int8 *)&v4);
}

//----- (10066C20) --------------------------------------------------------
int __cdecl sub_10066C20(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100FFA84[2 * sub_100430B0(&a1, 1u, (int)&unk_100FFA80, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100FFAC4[2 * sub_100430B0(&a2, 1u, (int)&unk_100FFAC0, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100FFAF4[2 * sub_100430B0(&a2, 1u, (int)&unk_100FFAF0, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100FFA9C[2 * sub_100430B0(&a2, 1u, (int)&unk_100FFA98, 8, 5, 5)];
  }
  return result;
}
// 100FFA84: using guessed type int dword_100FFA84[];
// 100FFA9C: using guessed type int dword_100FFA9C[];
// 100FFAC4: using guessed type int dword_100FFAC4[];
// 100FFAF4: using guessed type int dword_100FFAF4[];

//----- (10066CD0) --------------------------------------------------------
bool __usercall sub_10066CD0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_1010BCBF[44 * a1] - (unsigned __int8)byte_1010BCBA[44 * a1];
}

//----- (10066D00) --------------------------------------------------------
char __usercall sub_10066D00@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10066CD0(a1, a4, a5) )
  {
    v6 = a3
       + sub_10066C20(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_1010BCBA[44 * a1] - (unsigned __int8)byte_1010BCBF[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy_0(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10066C20(a1, a4);
    memcpy_0(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10066DA0) --------------------------------------------------------
char __cdecl sub_10066DA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10052DE0(a1);
  sub_100163A0(v5, (int)&v7, 3684);
  return sub_10066D00(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (10066E20) --------------------------------------------------------
char __cdecl sub_10066E20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10052DE0(a1);
  sub_100163A0(v5, (int)&v7, 3684);
  return sub_10066D00(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (10066EA0) --------------------------------------------------------
char __cdecl sub_10066EA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10052DE0(a1);
  sub_100163A0(v5, (int)&v7, 3684);
  return sub_10066D00(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (10066F20) --------------------------------------------------------
char __cdecl sub_10066F20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10052DE0(a1);
  sub_100163A0(v5, (int)&v7, 3684);
  return sub_10066D00(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (10066FA0) --------------------------------------------------------
char __cdecl sub_10066FA0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10015C20("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10067040) --------------------------------------------------------
char sub_10067040()
{
  return 2;
}

//----- (10067050) --------------------------------------------------------
bool __cdecl sub_10067050(void *a1)
{
  char v1; // cl@1

  v1 = sub_1003F250(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_10052440((int)a1);
}

//----- (10067090) --------------------------------------------------------
char __cdecl sub_10067090(char a1)
{
  sub_1003ED80(1, 1672, &a1, 0, 1, 1);
  return sub_1003EEC0(1, 0x688u, 0xFFFFFFF);
}

//----- (100670C0) --------------------------------------------------------
char __cdecl sub_100670C0(char a1)
{
  int v1; // eax@1

  v1 = sub_10016450(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_10067090(a1);
  return v1;
}

//----- (100670F0) --------------------------------------------------------
char __usercall sub_100670F0@<al>(void *a1@<esi>)
{
  char result; // al@2
  bool v2; // zf@3
  void *v3; // [sp+0h] [bp-8h]@0

  if ( sub_10042760(4035, v3) )
  {
    result = 1;
  }
  else
  {
    v2 = (unsigned __int8)sub_100464A0(1, 741, 0, 4, a1) == 0;
    result = 1;
    if ( v2 )
      result = 0;
  }
  return result;
}

//----- (10067130) --------------------------------------------------------
char __usercall sub_10067130@<al>(float *a1@<esi>)
{
  char result; // al@1
  void *v2; // [sp+0h] [bp-8h]@0

  result = sub_10025520(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (10067150) --------------------------------------------------------
char __cdecl sub_10067150(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_100163E0(6081, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (100671B0) --------------------------------------------------------
char __cdecl sub_100671B0(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_100163E0(6937, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (10067210) --------------------------------------------------------
char __cdecl sub_10067210(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_100163E0(6938, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (10067270) --------------------------------------------------------
char __usercall sub_10067270@<al>(int a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  float v4; // ST14_4@5
  char result; // al@5
  float v6; // [sp+Ch] [bp-8h]@1
  float v7; // [sp+10h] [bp-4h]@1

  v1 = sub_10053910(0x4B6u, &v6);
  v2 = sub_10053910(0x4B7u, &v7);
  if ( v1 )
  {
    v3 = v6;
    if ( v2 )
    {
      if ( v7 <= v3 )
        v3 = v7;
      v4 = v3;
      result = sub_10040660(v4, a1);
    }
    else
    {
      result = sub_10040660(v6, a1);
    }
  }
  else if ( v2 )
  {
    result = sub_10040660(v7, a1);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10067310) --------------------------------------------------------
char __cdecl sub_10067310(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_100464A0(1, 949, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10067360) --------------------------------------------------------
char __cdecl sub_10067360(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_100464A0(1, 950, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100673B0) --------------------------------------------------------
char __cdecl sub_100673B0(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_100464A0(0, 400, 0, 4, &v3) && (unsigned __int8)sub_100464A0(1, 527, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10067410) --------------------------------------------------------
char __cdecl sub_10067410(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_100464A0(0, 401, 0, 4, &v3) && (unsigned __int8)sub_100464A0(1, 530, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10067470) --------------------------------------------------------
char __usercall sub_10067470@<al>(float *a1@<esi>, char a2)
{
  char v2; // bl@1
  char result; // al@6
  float v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  float v6; // [sp+Ch] [bp-4h]@1
  char v7; // [sp+14h] [bp+4h]@2
  char v8; // [sp+14h] [bp+4h]@7

  v4 = 9.8999998e24;
  v6 = 9.8999998e24;
  v2 = 0;
  v5 = 0;
  if ( a2 )
  {
    v7 = sub_100464A0(6, 617, 0, 4, &v5);
    if ( sub_10042760(4026, &v4) )
    {
      v2 = 1;
      if ( v7 && v5 & 0x1000 && sub_10042760(4028, &v6) )
      {
LABEL_6:
        result = 1;
        *a1 = v6 + v4;
        return result;
      }
      goto LABEL_11;
    }
  }
  else
  {
    v8 = sub_100464A0(6, 620, 0, 4, &v5);
    if ( sub_10042760(4027, &v4) )
    {
      v2 = 1;
      if ( v8 && v5 & 0x1000 && sub_10042760(4029, &v6) )
        goto LABEL_6;
LABEL_11:
      *a1 = v4;
      return v2;
    }
  }
  return v2;
}

//----- (10067560) --------------------------------------------------------
char __cdecl sub_10067560(float a1, int a2)
{
  float v2; // ecx@0
  char v3; // al@3
  char result; // al@5
  float v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  if ( LOBYTE(a1) == 1 )
  {
    if ( !sub_10042760(65, &v5) )
      return 0;
    v3 = sub_10042760(498, &a1);
  }
  else
  {
    if ( !sub_10042760(61, &v5) )
      return 0;
    v3 = sub_10042760(477, &a1);
  }
  if ( v3 )
  {
    result = 1;
    *(float *)a2 = (a1 + v5) * 0.5;
    return result;
  }
  return 0;
}

//----- (100675D0) --------------------------------------------------------
char __usercall sub_100675D0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_100464A0(1, 740, 0, 4, &v5);
  v2 = sub_100464A0(1, 2172, 0, 4, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( !v2 || (v5 = v3 - v6, LODWORD(v5) &= 0x7FFFFFFFu, v5 <= 304.8) )
    {
      *a1 = v3;
      return 1;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (10067650) --------------------------------------------------------
char __cdecl sub_10067650(float *a1)
{
  char result; // al@4
  int v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_100464A0(1, 120, 0, 4, &v3)
    && (unsigned __int8)sub_100464A0(1, 1775, 0, 4, &v2)
    && !(v2 & 0x7C0000) )
  {
    *a1 = v3;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100676B0) --------------------------------------------------------
char __cdecl sub_100676B0(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_100464A0(1, 122, 0, 4, &v5) || !(unsigned __int8)sub_100464A0(1, 996, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (10067740) --------------------------------------------------------
char __cdecl sub_10067740(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_100464A0(1, 127, 0, 4, &v5) || !(unsigned __int8)sub_100464A0(1, 1004, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (100677D0) --------------------------------------------------------
char __usercall sub_100677D0@<al>(float *a1@<esi>)
{
  double v1; // st7@15
  double v2; // st6@19
  double v3; // st7@25
  double v4; // st7@31
  char result; // al@36
  char v6; // [sp+4h] [bp-2Ch]@2
  char v7; // [sp+5h] [bp-2Bh]@5
  char v8; // [sp+6h] [bp-2Ah]@8
  char v9; // [sp+7h] [bp-29h]@11
  float v10; // [sp+8h] [bp-28h]@2
  float v11; // [sp+Ch] [bp-24h]@21
  float v12; // [sp+10h] [bp-20h]@17
  float v13; // [sp+14h] [bp-1Ch]@14
  float v14; // [sp+18h] [bp-18h]@23
  float v15; // [sp+1Ch] [bp-14h]@29
  float v16; // [sp+20h] [bp-10h]@1
  float v17; // [sp+24h] [bp-Ch]@21
  double v18; // [sp+28h] [bp-8h]@21

  *a1 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 1744, 0, 4, &v16) )
    goto LABEL_40;
  v16 = v16 * 61.02374267578125;
  v10 = v16;
  if ( (unsigned __int8)sub_100464A0(1, 134, 0, 1, &v6) && !v6 )
    v10 = v10 + 39.90000152587891;
  if ( (unsigned __int8)sub_100464A0(1, 634, 0, 1, &v7) && !v7 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_100464A0(1, 649, 0, 1, &v8) && !v8 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_100464A0(1, 1757, 0, 1, &v9) && v9 )
    v10 = v10 + 13.5;
  if ( sub_10025520(&v13) )
    v1 = v13 * 1.799999952316284 + 32.0;
  else
    v1 = -65.0;
  v13 = v1;
  if ( (unsigned __int8)sub_100464A0(1, 1743, 0, 4, &v12) && v12 != 0.0 )
    v2 = v12 * 0.000145037702168338;
  else
    v2 = 3040.0;
  v12 = v2;
  v17 = v13 + 460.0;
  v18 = 0.0000344 - (v17 - 528.0) * 0.00000005;
  v11 = v18 * (v12 - 100.0) + 1.003999948501587;
  v11 = 100.0 - v17 * (v11 * 248.0) / v12;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  if ( (unsigned __int8)sub_100464A0(1, 1741, 0, 4, &v14) && v14 != 0.0 )
    v3 = v14 * 0.000145037702168338;
  else
    v3 = 3040.0;
  v14 = v3;
  v11 = (v14 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v11 * 124.0 * v17 / v14;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v4 = (unsigned __int8)sub_100464A0(1, 1742, 0, 4, &v15) && v15 != 0.0 ? v15 * 0.000145037702168338 : 3040.0;
  v15 = v4;
  v16 = (v15 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v16 * 124.0 * v17 / v15;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v17 = v12 * 631.0 / 250000.0;
  v10 = v17 + v10;
  v17 = 631.0 * ((v13 - 59.0) * 0.0004556);
  v17 = v17 + v10;
  v17 = (v17 - 300.0 + 100.0) / 100.0;
  if ( v17 <= 1.25 )
  {
    *a1 = v17;
    result = 1;
  }
  else
  {
LABEL_40:
    result = 0;
  }
  return result;
}

//----- (10067B70) --------------------------------------------------------
char __usercall sub_10067B70@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  *a1 = 0.0;
  if ( sub_10053910(0x40Du, &v3) && sub_10053910(0x40Eu, &v2) && v2 != 0.0 )
  {
    result = 1;
    *a1 = v3 / v2 * 11.35624027252197 + 0.1147093996405602;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10067BE0) --------------------------------------------------------
char __usercall sub_10067BE0@<al>(float *a1@<esi>)
{
  char result; // al@1
  float *v2; // [sp+0h] [bp-8h]@0

  result = sub_10025610(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (10067C00) --------------------------------------------------------
char __usercall sub_10067C00@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10053910(0x4Fu, &v5);
  v2 = sub_10053910(0x7EAu, &v6);
  if ( v1 )
  {
    if ( !v2 )
    {
      result = 1;
      *a1 = v5;
      return result;
    }
    v3 = v5;
    v5 = v6 - v5;
    LODWORD(v5) &= 0x7FFFFFFFu;
    if ( v5 <= 34473.789 )
    {
      result = 1;
      *a1 = (v6 + v3) * 0.5;
      return result;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (10067C90) --------------------------------------------------------
void __usercall sub_10067C90(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v1 = sub_10053910(0x51u, &v4);
  v2 = sub_10053910(0x7EBu, &v5);
  if ( v1 )
  {
    if ( !v2 )
    {
      *a1 = v4;
      return;
    }
    v3 = v4;
    v4 = v5 - v4;
    LODWORD(v4) &= 0x7FFFFFFFu;
    if ( v4 <= 5.0 )
    {
      *a1 = (v5 + v3) * 0.5;
      return;
    }
  }
  else if ( v2 )
  {
    *a1 = v5;
    return;
  }
  *a1 = 21.1;
}

//----- (10067D20) --------------------------------------------------------
char __cdecl sub_10067D20(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  float v3; // [sp+8h] [bp-18h]@1
  double v4; // [sp+Ch] [bp-14h]@1
  float v5; // [sp+14h] [bp-Ch]@2
  double v6; // [sp+18h] [bp-8h]@2

  v1 = sub_10067C00((float *)&v4);
  sub_10067C90(&v3);
  if ( v1 )
  {
    v5 = (v3 + 67.77799987792969) / 27.77799987792969;
    v3 = (*(float *)&v4 + 517.0900268554688) / 4137139.5;
    v4 = v5 * 27.79999923706055;
    v5 = pow(315.0 - v4, 2.0);
    v6 = v5 * 5.470000147278498e-11;
    v5 = pow(v3 * 41.40000152587891, 2.0);
    v6 = v5 * v6;
    v5 = pow(215.0 - v4, 2.0);
    v5 = v6 - v5 * 0.00000005260000079942984 * 41.40000152587891 * v3 + 1.0;
    *a1 = v3 / (v4 + 205.3000030517578) * (1.0 / v5 * 127823.0) - 195.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10067E40) --------------------------------------------------------
char __usercall sub_10067E40@<al>(float *a1@<esi>, float a2)
{
  char v2; // bl@1
  double v3; // st7@3
  long double v4; // st7@3
  float v6; // [sp+0h] [bp-20h]@1
  float v7; // [sp+4h] [bp-1Ch]@1
  float v8; // [sp+8h] [bp-18h]@3
  float v9; // [sp+Ch] [bp-14h]@1
  int v10; // [sp+10h] [bp-10h]@3
  float v11; // [sp+14h] [bp-Ch]@5
  float v12; // [sp+18h] [bp-8h]@5
  float v13; // [sp+1Ch] [bp-4h]@5
  float v14; // [sp+24h] [bp+4h]@3
  float v15; // [sp+24h] [bp+4h]@3
  unsigned __int8 v16; // [sp+24h] [bp+4h]@3

  v2 = 0;
  v9 = a2 * 32.0 * 0.0005787039990536869;
  v7 = 0.0;
  v6 = 0.0;
  if ( sub_10053910(0x4Fu, &v7) && sub_10053910(0x51u, &v6) )
  {
    *(float *)&v10 = v7 / 101325.0;
    v14 = v6 + 273.0;
    v7 = v7 * 0.000145037702168338;
    v6 = v6 * 1.799999952316284 + 32.0;
    v15 = v14 * 0.08205779641866684 / *(float *)&v10;
    v3 = v15 * 0.002983009908348322;
    v16 = 0;
    v8 = v3;
    v4 = v9;
    do
    {
      if ( v16 >= 5u )
        break;
      v12 = pow(v4, 2.0);
      v11 = pow(v8 / v9, 2.0);
      v11 = (v9 - 0.5099999904632568 * v8) * (v11 * 5140.0 + v7 + 14.69999980926514)
          - (v6 + 460.0) * 10.71000003814697 * v8;
      v13 = v11;
      v11 = pow(v8, 2.0);
      v12 = -((v11 * 7864200.0 + 10710.0 * v12 * v6 + v12 * 510.0 * v7 - 10280000.0 * v9 * v8 + v12 * 4934097.0)
            / (v12
             * 1000.0));
      v13 = v13 / v12;
      v8 = v8 - v13;
      v4 = v9;
      v10 = LODWORD(v13) & 0x7FFFFFFF;
      if ( COERCE_FLOAT(LODWORD(v13) & 0x7FFFFFFF) < 0.001 )
      {
        v2 = 1;
        *a1 = v8 / 0.002983009908348322;
      }
      ++v16;
    }
    while ( !v2 );
  }
  return v2;
}

//----- (10068040) --------------------------------------------------------
char __usercall sub_10068040@<al>(float *a1@<esi>, float a2)
{
  char v2; // al@3
  char result; // al@5
  float v4; // [sp+4h] [bp-4h]@3

  if ( LOBYTE(a2) )
  {
    if ( !sub_1003F220(1, 1516, 0, 4, &a2) )
      return 0;
    v2 = sub_1003F220(0, 356, 0, 4, &v4);
  }
  else
  {
    if ( !sub_1003F220(1, 2447, 0, 4, &a2) )
      return 0;
    v2 = sub_1003F220(0, 357, 0, 4, &v4);
  }
  if ( v2 )
  {
    result = 1;
    *a1 = a2 - v4;
    return result;
  }
  return 0;
}

//----- (100680D0) --------------------------------------------------------
char __usercall sub_100680D0@<al>(float *a1@<eax>)
{
  return sub_1003FE10(a1);
}

//----- (100680E0) --------------------------------------------------------
char __usercall sub_100680E0@<al>(float *a1@<eax>)
{
  return sub_1003FEE0(a1);
}

//----- (100680F0) --------------------------------------------------------
char __usercall sub_100680F0@<al>(float *a1@<eax>)
{
  return sub_1003FFB0(a1);
}

//----- (10068100) --------------------------------------------------------
char __usercall sub_10068100@<al>(float *a1@<eax>)
{
  return sub_10040080(a1);
}

//----- (10068110) --------------------------------------------------------
int __usercall sub_10068110@<eax>(char a1@<dl>, int a2@<ecx>, float *a3)
{
  int result; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  result = sub_100464A0(a1, a2, 0, 4, &v4);
  if ( (_BYTE)result )
    *a3 = (double)v4 * 0.00000008381903171539307;
  return result;
}

//----- (10068140) --------------------------------------------------------
char __usercall sub_10068140@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  double v2; // st7@3
  char result; // al@9
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@2

  v1 = 0;
  if ( sub_1003F220(6, 41, 0, 4, &v4) && sub_1003F220(6, 42, 0, 4, &v5) )
  {
    v2 = (v5 + v4) * 0.5;
LABEL_8:
    *a1 = v2;
    v1 = 1;
    goto LABEL_9;
  }
  if ( sub_1003F220(6, 41, 0, 4, &v4) )
  {
    v2 = v4;
    goto LABEL_8;
  }
  if ( sub_1003F220(6, 42, 0, 4, &v5) )
  {
    v2 = v5;
    goto LABEL_8;
  }
LABEL_9:
  result = v1;
  *a1 = *a1 * 1.943844437599182;
  return result;
}

//----- (100681E0) --------------------------------------------------------
char __usercall sub_100681E0@<al>(float *a1@<esi>)
{
  char result; // al@6
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@3
  char v4; // [sp+7h] [bp-B5h]@4
  char v5; // [sp+8h] [bp-B4h]@5
  char v6; // [sp+9h] [bp-B3h]@2
  float v7; // [sp+14h] [bp-A8h]@6
  float v8; // [sp+20h] [bp-9Ch]@9

  if ( (unsigned __int8)sub_100464A0(6, 429, 0, 180, &v2) )
  {
    if ( v6 )
    {
LABEL_9:
      result = 1;
      *a1 = v8;
      return result;
    }
    if ( (!v3 || !v4) && v5 )
      goto LABEL_6;
  }
  if ( (unsigned __int8)sub_100464A0(6, 430, 0, 180, &v2) )
  {
    if ( v6 )
      goto LABEL_9;
    if ( (!v3 || !v4) && v5 )
    {
LABEL_6:
      result = 1;
      *a1 = v7;
      return result;
    }
  }
  return 0;
}

//----- (100682C0) --------------------------------------------------------
char __cdecl sub_100682C0(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( sub_10042760(87, &v3) && sub_10042760(88, &v2) )
  {
    result = 1;
    *a1 = (v2 + v3) * 0.5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10068310) --------------------------------------------------------
char __usercall sub_10068310@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@2
  char v4; // [sp+7h] [bp-B5h]@3
  float v5; // [sp+Ch] [bp-B0h]@5
  float v6; // [sp+18h] [bp-A4h]@9

  if ( (unsigned __int8)sub_100464A0(6, 429, 0, 180, &v2) )
  {
    if ( v3 && v4 )
      goto LABEL_9;
    if ( v2 )
    {
LABEL_5:
      result = 1;
      *a1 = v5;
      return result;
    }
  }
  if ( (unsigned __int8)sub_100464A0(6, 430, 0, 180, &v2) )
  {
    if ( v3 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v6;
      return result;
    }
    if ( v2 )
      goto LABEL_5;
  }
  return 0;
}

//----- (100683F0) --------------------------------------------------------
char __usercall sub_100683F0@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+5h] [bp-B7h]@4
  char v4; // [sp+6h] [bp-B6h]@3
  char v5; // [sp+7h] [bp-B5h]@2
  float v6; // [sp+10h] [bp-ACh]@5
  float v7; // [sp+1Ch] [bp-A0h]@9

  if ( (unsigned __int8)sub_100464A0(6, 429, 0, 180, &v2) )
  {
    if ( v5 && v4 )
      goto LABEL_9;
    if ( v3 )
    {
LABEL_5:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_100464A0(6, 430, 0, 180, &v2) )
  {
    if ( v5 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v7;
      return result;
    }
    if ( v3 )
      goto LABEL_5;
  }
  return 0;
}

//----- (100684D0) --------------------------------------------------------
char __usercall sub_100684D0@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+44h] [bp-78h]@2
  float v4; // [sp+50h] [bp-6Ch]@3

  if ( (unsigned __int8)sub_100464A0(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_100464A0(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10068570) --------------------------------------------------------
char __usercall sub_10068570@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+40h] [bp-7Ch]@2
  float v4; // [sp+48h] [bp-74h]@3

  if ( (unsigned __int8)sub_100464A0(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_100464A0(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10068610) --------------------------------------------------------
char __usercall sub_10068610@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+41h] [bp-7Bh]@2
  float v4; // [sp+4Ch] [bp-70h]@3

  if ( (unsigned __int8)sub_100464A0(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_100464A0(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100686B0) --------------------------------------------------------
char __usercall sub_100686B0@<al>(float *a1@<esi>)
{
  char result; // al@4
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+80h] [bp-3Ch]@2
  char v4; // [sp+81h] [bp-3Bh]@3
  float v5; // [sp+8Ch] [bp-30h]@7
  float v6; // [sp+98h] [bp-24h]@4

  if ( (unsigned __int8)sub_100464A0(6, 429, 0, 180, &v2) )
  {
    if ( v3 )
    {
LABEL_7:
      result = 1;
      *a1 = v5;
      return result;
    }
    if ( v4 )
    {
LABEL_4:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_100464A0(6, 430, 0, 180, &v2) )
  {
    if ( v3 )
      goto LABEL_7;
    if ( v4 )
      goto LABEL_4;
  }
  return 0;
}

//----- (10068790) --------------------------------------------------------
char __cdecl sub_10068790(float *a1)
{
  double v1; // st7@2
  char result; // al@5
  float v3; // ST04_4@5
  float v4; // [sp+0h] [bp-Ch]@1
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v4 = 9.8999998e24;
  v5 = sub_10040190();
  if ( sub_1003FD10(&v6) && (v1 = v5, v5 != 9.8999998e24) )
  {
    if ( v1 >= 3785.411865234375 || v6 <= 0.0001051503277267329 )
    {
      result = 1;
      *a1 = v4;
    }
    else
    {
      result = 1;
      v3 = v1 / v6;
      *a1 = v3;
    }
  }
  else
  {
    *a1 = v4;
    result = 0;
  }
  return result;
}

//----- (10068830) --------------------------------------------------------
bool __cdecl sub_10068830(float *a1)
{
  char v1; // bl@1
  bool v2; // al@1
  double v3; // st6@5
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10068790(&v5);
  v2 = sub_10046350(&v6);
  if ( !v1
    || !v2
    || v5 == 9.8999998e24
    || (LODWORD(v6) & 0x7F800000) == 2139095040
    || (v5 = v5 * v6, v3 = v5, v5 > 37040000.0) )
  {
    v5 = 9.8999998e24;
    v3 = (float)9.8999998e24;
  }
  *a1 = v3;
  return v2 && v1 && v3 != 9.8999998e24;
}

//----- (100688E0) --------------------------------------------------------
char __usercall sub_100688E0@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_100464A0(1, 90, 0, 4, &v2)
    && (unsigned __int8)sub_100464A0(1, 115, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10068960) --------------------------------------------------------
char __usercall sub_10068960@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_100464A0(1, 527, 0, 4, &v2)
    && (unsigned __int8)sub_100464A0(1, 530, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100689F0) --------------------------------------------------------
char __usercall sub_100689F0@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+0h] [bp-Ch]@1
  float v3; // [sp+4h] [bp-8h]@2
  float v4; // [sp+8h] [bp-4h]@3

  *a1 = 9.8999998e24;
  if ( sub_10046350(&v2) && (v3 = v2, (LODWORD(v2) & 0x7F800000) != 2139095040) && sub_1003FD10(&v4) )
  {
    result = 1;
    if ( v4 > 0.0001051503277267329 )
      *a1 = v2 / v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10068A60) --------------------------------------------------------
int __cdecl sub_10068A60(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_100464A0(1, 74, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 75, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 76, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 77, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 78, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 79, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10068C90) --------------------------------------------------------
int __cdecl sub_10068C90(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_100464A0(1, 99, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 100, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 101, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 102, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 103, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 104, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10068EC0) --------------------------------------------------------
int __cdecl sub_10068EC0(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_100464A0(1, 68, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 69, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 70, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 71, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 72, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 73, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (100690F0) --------------------------------------------------------
int __cdecl sub_100690F0(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_100464A0(1, 93, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 94, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 95, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 96, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 97, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_100464A0(1, 98, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10069320) --------------------------------------------------------
char __usercall sub_10069320@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-24h]@1
  float v4; // [sp+8h] [bp-20h]@1
  char v5; // [sp+Ch] [bp-1Ch]@1
  float v6; // [sp+18h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  v4 = sub_10040190();
  sub_100163E0(41109, &v5, 24, &unk_10103808);
  if ( v6 != 9.8999998e24 && v4 != 9.8999998e24 )
  {
    v1 = 1;
    v3 = v4 - v6;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (100693B0) --------------------------------------------------------
char __usercall sub_100693B0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@3
  float v3; // [sp+4h] [bp-20h]@1
  char v4; // [sp+8h] [bp-1Ch]@1
  float v5; // [sp+14h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  sub_100163E0(41109, &v4, 24, &unk_10103808);
  if ( v5 != 9.8999998e24 )
  {
    v3 = v5;
    v1 = 1;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (10069420) --------------------------------------------------------
bool __cdecl sub_10069420(float *a1)
{
  bool v1; // bl@1
  bool result; // al@3
  float v3; // [sp+4h] [bp-4h]@1

  v3 = 9.8999998e24;
  v1 = sub_1006C460(&v3, 0, 0, 2) != 0;
  if ( 9.8999998e24 != v3 )
    v3 = sub_1006C3F0() + v3;
  result = v1;
  *a1 = v3;
  return result;
}

//----- (10069480) --------------------------------------------------------
char __cdecl sub_10069480(float a1, void *a2)
{
  __int16 v2; // cx@1
  char result; // al@4
  double v4; // st7@32
  double v5; // st7@69
  float v6; // ST0C_4@70
  float v7; // [sp+Ch] [bp-4h]@1
  float v8; // [sp+14h] [bp+4h]@32
  float v9; // [sp+14h] [bp+4h]@35

  HIBYTE(v2) = BYTE1(a1);
  v7 = 9.8999998e24;
  if ( (signed int)LOWORD(a1) > 301 )
  {
    switch ( LOWORD(a1) )
    {
      case 0x12Eu:
        v5 = 511.0;
        goto LABEL_70;
      case 0x12Fu:
        v5 = 1000.0;
        goto LABEL_70;
      case 0x191u:
        result = sub_10067B70((float *)a2);
        break;
      case 0x192u:
        result = sub_10067560(0.0, (int)a2);
        break;
      case 0x193u:
        result = sub_10067560(COERCE_FLOAT(1), (int)a2);
        break;
      case 0x194u:
        result = sub_100682C0((float *)a2);
        break;
      case 0x195u:
        result = sub_10067270((int)a2);
        break;
      case 0x196u:
      case 0x197u:
        result = sub_10067470((float *)a2, LOWORD(a1) == 406);
        break;
      case 0x198u:
      case 0x199u:
        LOBYTE(v2) = LOWORD(a1) == 408;
        result = ((char (__usercall *)@<al>(float *@<esi>, __int16))sub_10068040)((float *)a2, v2);
        break;
      case 0x19Au:
        result = sub_10068140((float *)a2);
        break;
      case 0x19Bu:
        result = sub_100670F0(a2);
        break;
      case 0x19Cu:
        result = sub_100680E0((float *)a2);
        break;
      case 0x19Du:
        result = sub_100680F0((float *)a2);
        break;
      case 0x19Eu:
        result = sub_100680D0((float *)a2);
        break;
      case 0x19Fu:
        result = sub_10068100((float *)a2);
        break;
      case 0x1A0u:
        result = sub_100163E0(9145, a2, 4, &v7) == 0;
        break;
      default:
LABEL_88:
        sub_10015C20("..\\lib\\adl\\dat_custom_proc_prj.c", 724, 0, 0);
        result = 0;
        break;
    }
  }
  else if ( LOWORD(a1) == 301 )
  {
    v5 = 295.0;
LABEL_70:
    v6 = v5;
    result = sub_10067E40((float *)a2, v6);
  }
  else
  {
    switch ( LOWORD(a1) )
    {
      case 0u:
        return sub_100684D0((float *)a2);
      case 1u:
        return sub_100686B0((float *)a2);
      case 2u:
        return sub_10068310((float *)a2);
      case 3u:
        return sub_100683F0((float *)a2);
      case 4u:
        return sub_100681E0((float *)a2);
      case 5u:
        return sub_10067D20((float *)a2);
      case 7u:
        return sub_10068570((float *)a2);
      case 6u:
        return sub_10068610((float *)a2);
      case 9u:
        return sub_10067310((float *)a2);
      case 0xAu:
        return sub_10067360((float *)a2);
      case 0xBu:
        return sub_100677D0((float *)a2);
      case 0xDu:
        *(float *)a2 = sub_1003F650();
        return 1;
      case 0x38u:
        return sub_10067C00((float *)a2);
      case 0x39u:
        sub_10067C90((float *)a2);
        goto LABEL_18;
      case 0x3Au:
        return sub_100676B0((float *)a2);
      case 0x3Bu:
        return sub_10067740((float *)a2);
      case 0x3Cu:
        return sub_10067650((float *)a2);
      case 0x3Du:
        return sub_100675D0((float *)a2);
      case 8u:
        return sub_10067130((float *)a2);
      case 0xCu:
        return sub_10067BE0((float *)a2);
      case 0xEu:
        return sub_1003FDA0((float *)a2);
      case 0xFu:
        return sub_10040120((float *)a2);
      case 0x10u:
        return sub_1003FC60((float *)a2);
      case 0x11u:
        return sub_100401F0((float *)a2);
      case 0x12u:
        return sub_1003FCD0((float *)a2);
      case 0x13u:
        return sub_1003FCF0((float *)a2);
      case 0x14u:
        return sub_1003FD10((float *)a2);
      case 0x15u:
        v8 = sub_10040190();
        v4 = v8;
        *(float *)a2 = v8;
        goto LABEL_33;
      case 0x35u:
        v9 = sub_1003F620();
        v4 = v9;
        *(float *)a2 = v9;
LABEL_33:
        if ( 9.8999998e24 == v4 )
          result = 0;
        else
LABEL_18:
          result = 1;
        break;
      case 0x16u:
        result = sub_100673B0((float *)a2);
        break;
      case 0x17u:
        result = sub_10067410((float *)a2);
        break;
      case 0x18u:
        result = sub_10068790((float *)a2);
        break;
      case 0x19u:
        result = sub_10068830((float *)a2);
        break;
      case 0x1Au:
        result = sub_100688E0((float *)a2);
        break;
      case 0x1Bu:
        result = sub_10068960((float *)a2);
        break;
      case 0x1Cu:
        result = sub_100689F0((float *)a2);
        break;
      case 0x1Du:
        result = sub_10068A60((float *)a2);
        break;
      case 0x1Eu:
        result = sub_10068C90((float *)a2);
        break;
      case 0x1Fu:
        result = sub_10068EC0((float *)a2);
        break;
      case 0x20u:
        result = sub_100690F0((float *)a2);
        break;
      case 0x21u:
        result = sub_10068110(6, 59, (float *)a2);
        break;
      case 0x22u:
        result = sub_10068110(6, 60, (float *)a2);
        break;
      case 0x23u:
        result = sub_10068110(6, 61, (float *)a2);
        break;
      case 0x24u:
        result = sub_10068110(6, 62, (float *)a2);
        break;
      case 0x25u:
        result = sub_10067150((float *)a2);
        break;
      case 0x26u:
        result = sub_100671B0((float *)a2);
        break;
      case 0x27u:
        result = sub_10067210((float *)a2);
        break;
      case 0x2Au:
        result = sub_100163E0(9000, a2, 4, &v7) == 0;
        break;
      case 0x2Bu:
        result = sub_100163E0(9001, a2, 4, &v7) == 0;
        break;
      case 0x2Cu:
        result = sub_100163E0(9002, a2, 4, &v7) == 0;
        break;
      case 0x2Du:
        result = sub_100163E0(9003, a2, 4, &v7) == 0;
        break;
      case 0x2Eu:
        result = sub_100163E0(9004, a2, 4, &v7) == 0;
        break;
      case 0x2Fu:
        result = sub_100163E0(9005, a2, 4, &v7) == 0;
        break;
      case 0x30u:
        result = sub_100163E0(9006, a2, 4, &v7) == 0;
        break;
      case 0x31u:
        result = sub_100163E0(9007, a2, 4, &v7) == 0;
        break;
      case 0x32u:
        result = sub_100163E0(9008, a2, 4, &v7) == 0;
        break;
      case 0x33u:
        result = sub_100163E0(9009, a2, 4, &v7) == 0;
        break;
      case 0x34u:
        result = sub_100163E0(9010, a2, 4, &v7) == 0;
        break;
      case 0x28u:
        result = sub_10069320((float *)a2);
        break;
      case 0x29u:
        result = sub_100693B0((float *)a2);
        break;
      case 0x36u:
        result = sub_10069420((float *)a2);
        break;
      case 0x37u:
        result = sub_1006C460((float *)a2, 0, 0, 2) != 0;
        break;
      default:
        goto LABEL_88;
    }
  }
  return result;
}

//----- (10069D30) --------------------------------------------------------
char __cdecl sub_10069D30(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_1003F250(2, 363, a1);
}

//----- (10069D50) --------------------------------------------------------
char __cdecl sub_10069D50(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_10016380(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10069EA0) --------------------------------------------------------
bool __thiscall sub_10069EA0(void *this)
{
  return (sub_10025CD0(this) & 0x8000) == 0x8000;
}

//----- (10069EC0) --------------------------------------------------------
char __cdecl sub_10069EC0(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10069D50(a5);
      else
        result = sub_10069D30(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10069D50(&unk_102657C8);
      else
        v7 = sub_10069D30(&unk_102657C8);
      v8 = v7;
      memcpy_0(a5, (char *)&unk_102657C8 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10069D50(&unk_102657C8);
      else
        v9 = sub_10069D30(&unk_102657C8);
      v10 = v9;
      memcpy_0(a5, (char *)&unk_102686D0 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10069D50(&unk_102657C8);
      else
        v11 = sub_10069D30(&unk_102657C8);
      v12 = v11;
      memcpy_0(a5, (char *)&unk_10268BD0 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10069D50(&unk_102657C8);
      else
        v13 = sub_10069D30(&unk_102657C8);
      v14 = v13;
      memcpy_0(a5, &unk_10268C78, a6);
      result = v14;
      break;
    default:
      sub_10015C20("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1006A060) --------------------------------------------------------
bool __cdecl sub_1006A060(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_100430B0(&a2, 4u, (int)&dword_10105A78, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_10016380((unsigned __int16)word_10105A7C[a1 + 6 * v3], a3, (unsigned __int16)word_10105A80[6 * v3]) == 0;
  }
  else
  {
    sub_10015C20("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 10105A78: using guessed type int dword_10105A78;
// 10105A7C: using guessed type __int16 word_10105A7C[];
// 10105A80: using guessed type __int16 word_10105A80[];

//----- (1006A0F0) --------------------------------------------------------
bool __cdecl sub_1006A0F0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_1006A190(a1);
  v6 = sub_100430B0(&a3, 1u, (int)&unk_10105A9C, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_100430B0(&dword_10105AA0[2 * v6], 4u, (int)&dword_10105A78, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_10105A80[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_1006A060(v11, *(int *)((char *)&dword_10105A78 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10105A78: using guessed type int dword_10105A78;
// 10105A80: using guessed type __int16 word_10105A80[];

//----- (1006A190) --------------------------------------------------------
char __cdecl sub_1006A190(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10015C20("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1006A210) --------------------------------------------------------
char __cdecl sub_1006A210(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10053190(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_10016380(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_100531B0((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1006A380) --------------------------------------------------------
int __usercall sub_1006A380@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1006A210(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1006A380: using guessed type int var_2C[10];

//----- (1006A3C0) --------------------------------------------------------
int __usercall sub_1006A3C0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1006A210(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1006A3C0: using guessed type int var_14[4];

//----- (1006A400) --------------------------------------------------------
signed int sub_1006A400()
{
  return sub_100175B0((int)&off_10107940);
}
// 10107940: using guessed type char *off_10107940;

//----- (1006A410) --------------------------------------------------------
char __cdecl sub_1006A410(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1006A400() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_102D22A8 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_102D22A8 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_102D22A8);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102D22A8: using guessed type int dword_102D22A8;

//----- (1006A470) --------------------------------------------------------
char __cdecl sub_1006A470(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1006A400() )
  {
    if ( (sub_10053C20(a1)
       || *(_BYTE *)(dword_102D22A8 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_102D22A8 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_102D22A8 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102D22A8 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102D22A8 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102D22A8 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102D22A8 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102D22A8 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102D22A8 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102D22A8 + 176))
      && *(_BYTE *)(dword_102D22A8 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_102D22A8 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_102D22A8 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_102D22A8 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_102D22A8 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102D22A8: using guessed type int dword_102D22A8;

//----- (1006A590) --------------------------------------------------------
char __cdecl sub_1006A590(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1006A400() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_102D22A8 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_102D22A8 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_102D22A8 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_102D22A8 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_102D22A8);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102D22A8: using guessed type int dword_102D22A8;

//----- (1006A610) --------------------------------------------------------
char __cdecl sub_1006A610(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10015C20("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1006A3C0(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_1006A590(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1006A380(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1006A410(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1006A210(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1006A470(v6, a5);
        }
      }
      else
      {
        sub_10015C20("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10015C20("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1006A7C0) --------------------------------------------------------
int __cdecl sub_1006A7C0(char a1)
{
  return sub_100430B0(&a1, 1u, (int)"7", 8, 2, 2);
}

//----- (1006A7E0) --------------------------------------------------------
BOOL __cdecl sub_1006A7E0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10053D50(a1);
  return sub_1003F250(0, 604, a2) && sub_1003EC20(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (1006A840) --------------------------------------------------------
int __usercall sub_1006A840@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_1006A7C0(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_10107984[2 * v1];
  return result;
}
// 10107984: using guessed type int dword_10107984[];

//----- (1006A870) --------------------------------------------------------
BOOL __cdecl sub_1006A870(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1006A840(a1);
  return sub_10016380(v2, a2, 16) == 0;
}

//----- (1006A8A0) --------------------------------------------------------
int __cdecl sub_1006A8A0(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_1006A870(a1, (int)a5);
  else
    result = sub_1006A7E0(a1, a5);
  return result;
}

//----- (1006A8D0) --------------------------------------------------------
char __cdecl sub_1006A8D0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_1003F280(1, 1947, a1, (int)&v3);
}

//----- (1006A8F0) --------------------------------------------------------
BOOL __cdecl sub_1006A8F0(int a1)
{
  return sub_10016380(6792, a1, 284) == 0;
}

//----- (1006A910) --------------------------------------------------------
char __cdecl sub_1006A910(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1006A8F0((int)a5);
  else
    result = sub_1006A8D0(a5);
  return result;
}

//----- (1006A940) --------------------------------------------------------
bool __cdecl sub_1006A940(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_10016380((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1006A980) --------------------------------------------------------
signed int __usercall sub_1006A980@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1006A9A0) --------------------------------------------------------
bool __cdecl sub_1006A9A0(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1006A980(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_1003EC20(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_1003F280(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1006A940(a1, a2);
  }
  else
  {
    v9 = sub_100405D0(v4);
    v8 = 1708;
    sub_1003ED80(1, 0, &v8, 0, 8, 1);
    sub_1003EEC0(1, 0, v2);
    result = 0;
  }
  return result;
}
// 10016C50: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10016C70: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1006AA90) --------------------------------------------------------
bool __cdecl sub_1006AA90(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1006A940(a1, a5);
  else
    result = sub_1006A9A0(a1, a5);
  return result;
}

//----- (1006AAC0) --------------------------------------------------------
BOOL __cdecl sub_1006AAC0(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (1006AAD0) --------------------------------------------------------
BOOL __usercall sub_1006AAD0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_1006AAC0(a1) && *v2 < 3u && a2 == 24;
}

//----- (1006AB00) --------------------------------------------------------
bool __cdecl sub_1006AB00(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_1006AAC0(a1) )
    {
      v6 = 10 * v5;
      if ( sub_10053410((unsigned __int8)byte_10108D30[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_1003F250(1, (unsigned __int16)word_10108D28[v6], &Tm.tm_mon) || sub_100523F0((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_1005D2A0(a1, &v15) || v15 != dword_10108D48[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_1003F250(1, (unsigned __int16)word_10108D2C[v6], &Tm) && !_mkgmtime_0(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 10108D28: using guessed type __int16 word_10108D28[];
// 10108D2C: using guessed type __int16 word_10108D2C[];
// 10108D48: using guessed type int dword_10108D48[];

//----- (1006ACB0) --------------------------------------------------------
bool __cdecl sub_1006ACB0(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_1006AAC0(a1) )
    result = sub_10016380((unsigned __int16)word_10108D32[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 10108D32: using guessed type __int16 word_10108D32[];

//----- (1006ACF0) --------------------------------------------------------
bool __cdecl sub_1006ACF0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_1005D1F0(a1);
  if ( !(unsigned __int8)sub_1006AAD0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_1006AB00(v9, a3, *a4, (int)a5);
  if ( sub_10053410((unsigned __int8)byte_10108D30[20 * v6], (bool *)&v8) && v8 && sub_1006ACB0(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 1006ACF0: using guessed type int var_20[7];

//----- (1006ADE0) --------------------------------------------------------
char __cdecl sub_1006ADE0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_1026B530, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10015C20("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_10053160(a1, (int)byte_1026B530);
    v3 = 4 * a2 - 64;
    v4 = byte_1026B531[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_1026B530[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (1006AE80) --------------------------------------------------------
bool __cdecl sub_1006AE80(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_1026B530, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10015C20("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_10053160(a1, (int)byte_1026B530);
    v3 = (char *)&unk_1026B5D0 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (1006AF00) --------------------------------------------------------
char __cdecl sub_1006AF00(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1026B530, 0, 0x890u);
  sub_10053160(a1, (int)byte_1026B530);
  if ( a2 > 0x10u )
  {
    sub_10015C20("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_1026B8A0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1026B8A4[2 * a2];
    result = 1;
  }
  return result;
}
// 1026B8A0: using guessed type int dword_1026B8A0[];
// 1026B8A4: using guessed type int dword_1026B8A4[];

//----- (1006AF70) --------------------------------------------------------
char __cdecl sub_1006AF70(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_1003F250(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_1003F250(0, 572, a2);
    }
    else
    {
      sub_10015C20("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_1003F250(0, 226, a2);
  }
  return result;
}

//----- (1006AFF0) --------------------------------------------------------
char __cdecl sub_1006AFF0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_1026B530, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10015C20("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1006AF70(a1, byte_1026B530);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_1026B531[v4];
    *(_BYTE *)a3 = byte_1026B530[v4];
  }
  return result;
}

//----- (1006B070) --------------------------------------------------------
char __cdecl sub_1006B070(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_1026B530, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10015C20("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1006AF70(a1, byte_1026B530);
    v4 = (char *)&unk_1026B5D0 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (1006B0F0) --------------------------------------------------------
char __cdecl sub_1006B0F0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_1026B530, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_1006AF70(a1, byte_1026B530);
    *(_DWORD *)a3 = dword_1026B8A0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_1026B8A4[2 * a2];
  }
  else
  {
    sub_10015C20("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 1026B8A0: using guessed type int dword_1026B8A0[];
// 1026B8A4: using guessed type int dword_1026B8A4[];

//----- (1006B160) --------------------------------------------------------
char __cdecl sub_1006B160(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1006C9F0(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_1006AF00(v6, *a4, a5);
    else
      result = sub_1006B0F0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_1006ADE0(v6, *a4, a5);
    else
      result = sub_1006AFF0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10015C20("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_1006AE80(v6, *a4, a5);
    else
      result = sub_1006B070(v6, *a4, a5);
  }
  return result;
}

//----- (1006B270) --------------------------------------------------------
char __cdecl sub_1006B270(char a1, void *a2)
{
  return sub_1003F250(6, (unsigned __int16)word_10109872[8 * (unsigned __int8)a1], a2);
}
// 10109872: using guessed type __int16 word_10109872[];

//----- (1006B290) --------------------------------------------------------
bool __cdecl sub_1006B290(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_10016380(dword_10109878[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 10109878: using guessed type int dword_10109878[];

//----- (1006B2D0) --------------------------------------------------------
char __cdecl sub_1006B2D0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1006CA30(a1);
  if ( a2 )
    result = sub_1006B290(v6, (char *)a5);
  else
    result = sub_1006B270(v6, a5);
  return result;
}

//----- (1006B310) --------------------------------------------------------
BOOL sub_1006B310()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_10053350(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (1006B370) --------------------------------------------------------
char __cdecl sub_1006B370(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_1003F250(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_1006B310() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10052000((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (1006B460) --------------------------------------------------------
BOOL __cdecl sub_1006B460(int a1, int a2)
{
  return sub_10016380(6200, a2, 60) == 0;
}

//----- (1006B480) --------------------------------------------------------
char __cdecl sub_1006B480(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1006B460(a1, (int)a5);
  }
  else
  {
    result = sub_1006B370(a1, a5);
  }
  return result;
}

//----- (1006B4C0) --------------------------------------------------------
char __cdecl sub_1006B4C0(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_1003F250(2, 284, &v6) || sub_100521D0((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (1006B570) --------------------------------------------------------
BOOL __cdecl sub_1006B570(int a1, int a2)
{
  return sub_10016380(6169, a2, 40) == 0;
}

//----- (1006B590) --------------------------------------------------------
char __cdecl sub_1006B590(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1006B570(a1, a5);
  }
  else
  {
    result = sub_1006B4C0(a1, a5);
  }
  return result;
}

//----- (1006B5D0) --------------------------------------------------------
char __cdecl sub_1006B5D0(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10015C20("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1006B610) --------------------------------------------------------
__int16 __usercall sub_1006B610@<ax>(unsigned __int8 a1@<al>)
{
  return word_1010B594[a1];
}
// 1010B594: using guessed type __int16 word_1010B594[];

//----- (1006B620) --------------------------------------------------------
char __cdecl sub_1006B620(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_1006B610(a1);
    if ( sub_1003F280(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1006B6F0) --------------------------------------------------------
char __cdecl sub_1006B6F0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_1006B5D0(a1);
  if ( a3 != 11 )
  {
    sub_10015C20("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_1006B620(v7, a5);
  }
  else
  {
    sub_10015C20("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1006B770) --------------------------------------------------------
char __cdecl sub_1006B770(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10015C20("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_1003F280(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_1003F280(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_100527D0((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_1026BDC8, (char *)&v6 + 1, 0x20u);
      byte_1026BDC0 = 1;
      byte_1026BDC1 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_1026BDE8, (char *)&v6 + 1, 0x20u);
    byte_1026BDC1 = 1;
    byte_1026BDC2 = 1;
    return result;
  }
  return 0;
}
// 1026BDC0: using guessed type char byte_1026BDC0;
// 1026BDC1: using guessed type char byte_1026BDC1;
// 1026BDC2: using guessed type char byte_1026BDC2;

//----- (1006B8A0) --------------------------------------------------------
char __cdecl sub_1006B8A0(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10053110(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10015C20("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (1006B920) --------------------------------------------------------
bool __cdecl sub_1006B920(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_1026BDC0 == 0;
    qmemcpy(a1, &unk_1026BDC8, 0x40u);
    result = !v1 && byte_1026BDC2;
  }
  else
  {
    sub_10015C20("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 1026BDC0: using guessed type char byte_1026BDC0;
// 1026BDC2: using guessed type char byte_1026BDC2;

//----- (1006B970) --------------------------------------------------------
char __cdecl sub_1006B970(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10015C20("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_10043450(15);
    v3 = 555;
  }
  else
  {
    result = sub_10043450(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_1026BDC1 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_1003ED80(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10016C70: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1026BDC1: using guessed type char byte_1026BDC1;

//----- (1006BA50) --------------------------------------------------------
__int16 __usercall sub_1006BA50@<ax>(unsigned __int8 a1@<al>)
{
  return word_1010B6A0[a1];
}
// 1010B6A0: using guessed type __int16 word_1010B6A0[];

//----- (1006BA60) --------------------------------------------------------
char __cdecl sub_1006BA60(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_1006BA50(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_1003ED80(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_1003EEC0(1, v3, 0xFFFFFFF);
}

//----- (1006BAF0) --------------------------------------------------------
char __cdecl sub_1006BAF0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10015C20("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_1026BDC1 != 0 ? 25 : 11;
      sub_1006BA60(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_1006BA60(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 1026BDC1: using guessed type char byte_1026BDC1;

//----- (1006BBB0) --------------------------------------------------------
bool __cdecl sub_1006BBB0(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_1006B8A0(a1, (int)a5);
    return 1;
  }
  if ( byte_1026BDC1 )
  {
    if ( sub_1006B770(a1, &v6, 1) )
    {
LABEL_14:
      byte_1026BDC3 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_1026BDC3 >= 5u )
    {
      byte_1026BDC0 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_1006B770(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_1026BDC3 >= 5u )
    {
      byte_1026BDC2 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_1006B8A0(a1, (int)&v6);
    sub_1006B970(a1, (int)&v6);
  }
  sub_1006BAF0(a1, 11);
  return sub_1006B920(a5);
}
// 10016C70: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1026BDC0: using guessed type char byte_1026BDC0;
// 1026BDC1: using guessed type char byte_1026BDC1;
// 1026BDC2: using guessed type char byte_1026BDC2;
// 1026BDC3: using guessed type char byte_1026BDC3;

//----- (1006BCB0) --------------------------------------------------------
int __cdecl sub_1006BCB0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (1006BCD0) --------------------------------------------------------
char __cdecl sub_1006BCD0(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_10051290((int)&v12);
}
// 1006BCD0: using guessed type char var_518[1300];

//----- (1006BDA0) --------------------------------------------------------
int __cdecl sub_1006BDA0(char a1, float a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  unsigned int v6; // esi@7
  int result; // eax@7
  double v8; // st6@11
  unsigned int v9; // ecx@14
  unsigned int v10; // edi@14
  char *v11; // edx@14
  signed int v12; // ebx@14
  int v13; // edx@56
  int v14; // edi@56
  char *v15; // ecx@56
  signed int v16; // ebp@56
  int v17; // ebp@63
  unsigned int v18; // ecx@63
  double v19; // st7@63
  signed int v20; // edi@64
  char *v21; // edx@64
  float *v22; // edx@81
  char v23; // [sp+Fh] [bp-4D9h]@7
  int v24; // [sp+18h] [bp-4D0h]@7
  float v25; // [sp+1Ch] [bp-4CCh]@61
  float v26; // [sp+20h] [bp-4C8h]@7
  float v27; // [sp+24h] [bp-4C4h]@11
  float v28[4]; // [sp+28h] [bp-4C0h]@11
  char v29; // [sp+38h] [bp-4B0h]@64
  float v30; // [sp+278h] [bp-270h]@7
  float v31; // [sp+27Ch] [bp-26Ch]@10
  float v32; // [sp+280h] [bp-268h]@9
  char v33; // [sp+284h] [bp-264h]@14
  char v34; // [sp+4C4h] [bp-24h]@56

  v5 = 0;
  if ( a3 )
    *(float *)a3 = 0.0;
  if ( a4 )
    *(float *)a4 = 0.0;
  if ( a5 )
    *(float *)a5 = 0.0;
  *(float *)&v24 = 9.8999998e24;
  v23 = 0;
  v6 = 0;
  memset(&v26, 0, 0x258u);
  result = sub_10016380(42065, (int)&v30, 624);
  if ( !a1 )
  {
    if ( v30 == 0.0 )
    {
      v8 = 9.8999998e24;
    }
    else if ( v32 == 9.8999998e24 || v31 == 9.8999998e24 )
    {
      v8 = 9.8999998e24;
    }
    else
    {
      v6 = 1;
      v26 = v30;
      v28[0] = v32;
      v8 = 9.8999998e24;
      v27 = v31;
    }
    v9 = 12 * v6;
    v10 = 0;
    v11 = &v33;
    v12 = 6;
    do
    {
      if ( 0.0 != *(float *)v11
        && *(float *)((char *)&v26 + v10) < (double)*(float *)v11
        && v8 != *((float *)v11 + 2)
        && v8 != *((float *)v11 + 1) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *(float *)v11;
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 2);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 1);
      }
      if ( 0.0 != *((float *)v11 + 3)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 3)
        && v8 != *((float *)v11 + 5)
        && v8 != *((float *)v11 + 4) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 3);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 5);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 4);
      }
      if ( 0.0 != *((float *)v11 + 6)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 6)
        && v8 != *((float *)v11 + 8)
        && v8 != *((float *)v11 + 7) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 6);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 8);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 7);
      }
      if ( 0.0 != *((float *)v11 + 9)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 9)
        && v8 != *((float *)v11 + 11)
        && v8 != *((float *)v11 + 10) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 9);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 11);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 10);
      }
      if ( 0.0 != *((float *)v11 + 12)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 12)
        && v8 != *((float *)v11 + 14)
        && v8 != *((float *)v11 + 13) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 12);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 14);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 13);
      }
      if ( 0.0 != *((float *)v11 + 15)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 15)
        && v8 != *((float *)v11 + 17)
        && v8 != *((float *)v11 + 16) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 15);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 17);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 16);
      }
      if ( 0.0 != *((float *)v11 + 18)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 18)
        && v8 != *((float *)v11 + 20)
        && v8 != *((float *)v11 + 19) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 18);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 20);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 19);
      }
      if ( 0.0 != *((float *)v11 + 21)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 21)
        && v8 != *((float *)v11 + 23)
        && v8 != *((float *)v11 + 22) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 21);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 23);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 22);
      }
      v11 += 96;
      --v12;
    }
    while ( v12 );
    v13 = 12 * v6;
    v14 = 12 * v5;
    v15 = &v34;
    v16 = 1;
    do
    {
      if ( 0.0 != *(float *)v15
        && *(float *)((char *)&v26 + v14) < (double)*(float *)v15
        && v8 != *((float *)v15 + 2)
        && v8 != *((float *)v15 + 1) )
      {
        v14 = v13;
        *(float *)((char *)&v26 + v13) = *(float *)v15;
        ++v6;
        v13 += 12;
        *(float *)((char *)&v25 + v13) = *((float *)v15 + 2);
        *(int *)((char *)&v24 + v13) = *((int *)v15 + 1);
      }
      v15 += 12;
      --v16;
    }
    while ( v16 );
    v17 = 0;
    v18 = 0;
    v19 = a2;
    if ( (signed int)v6 < 4 )
    {
LABEL_80:
      if ( v18 < v6 )
      {
        v22 = &v26 + 3 * v18;
        do
        {
          if ( v23 )
            break;
          if ( v19 == *v22 )
          {
            v23 = 1;
            v17 = v18;
          }
          else
          {
            v25 = *v22 - v19;
            if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
            {
              v17 = v18;
              v24 = LODWORD(v25) & 0x7FFFFFFF;
            }
          }
          ++v18;
          v22 += 3;
        }
        while ( v18 < v6 );
      }
    }
    else
    {
      v20 = 3;
      v21 = &v29;
      while ( !v23 )
      {
        if ( v19 == *((float *)v21 - 6) )
        {
          v17 = v18;
          break;
        }
        v25 = *((float *)v21 - 6) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v18;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 - 3) )
        {
          v17 = v18 + 1;
          break;
        }
        v25 = *((float *)v21 - 3) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 2;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *(float *)v21 )
        {
          v17 = v18 + 2;
          break;
        }
        v25 = *(float *)v21 - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 1;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 + 3) )
        {
          v23 = 1;
          v17 = v20;
        }
        else
        {
          v25 = *((float *)v21 + 3) - v19;
          if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
          {
            v17 = v20;
            v24 = LODWORD(v25) & 0x7FFFFFFF;
          }
        }
        v18 += 4;
        v21 += 48;
        v20 += 4;
        if ( v18 >= v6 - 3 )
          goto LABEL_80;
      }
    }
    if ( a3 )
      *(float *)a3 = sub_1006CA50(*(&v26 + 3 * v17));
    if ( a4 )
      *(float *)a4 = v28[3 * v17] * 0.02539999969303608;
    result = a5;
    if ( a5 )
      *(float *)a5 = 0.02539999969303608 * *(&v27 + 3 * v17);
  }
  return result;
}
// 1006BDA0: using guessed type float var_4C0[4];

//----- (1006C3F0) --------------------------------------------------------
double sub_1006C3F0()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 0.0;
  v2 = 0.0;
  sub_10016550(3875, &v1, 4, &v2);
  return v1;
}

//----- (1006C420) --------------------------------------------------------
double __cdecl sub_1006C420(int a1, float a2, float a3)
{
  int v3; // ecx@0
  double result; // st7@2

  if ( sub_10025B40(v3) == 24 )
  {
    *(float *)a1 = a2 * 453.5924;
    result = a2;
  }
  else
  {
    *(float *)a1 = a3 * 1000.0;
    result = a3;
  }
  return result;
}

//----- (1006C460) --------------------------------------------------------
char __cdecl sub_1006C460(float *a1, float *a2, float *a3, char a4)
{
  float *v4; // ecx@10
  signed int v5; // edx@10
  double v6; // st7@29
  double v7; // st7@34
  double v8; // st7@37
  double v9; // st6@37
  double v10; // st5@43
  double v11; // rtt@48
  double v12; // st5@48
  double v13; // st7@48
  char result; // al@48
  char v15; // [sp+22h] [bp-3EEh]@1
  char v16; // [sp+23h] [bp-3EDh]@1
  float v17; // [sp+24h] [bp-3ECh]@1
  float v18; // [sp+28h] [bp-3E8h]@1
  float v19; // [sp+2Ch] [bp-3E4h]@1
  float v20; // [sp+30h] [bp-3E0h]@1
  float v21; // [sp+34h] [bp-3DCh]@1
  float v22; // [sp+38h] [bp-3D8h]@1
  int v23; // [sp+3Ch] [bp-3D4h]@1
  int v24; // [sp+40h] [bp-3D0h]@1
  float v25; // [sp+44h] [bp-3CCh]@29
  int v26; // [sp+48h] [bp-3C8h]@10
  char v27; // [sp+4Ch] [bp-3C4h]@10
  char v28; // [sp+68h] [bp-3A8h]@10
  char v29; // [sp+6Ch] [bp-3A4h]@10
  char v30; // [sp+8Ch] [bp-384h]@10
  char v31; // [sp+ACh] [bp-364h]@10
  char v32; // [sp+CCh] [bp-344h]@10
  char v33; // [sp+ECh] [bp-324h]@10
  char v34; // [sp+10Ch] [bp-304h]@10
  char v35; // [sp+12Ch] [bp-2E4h]@10
  char v36; // [sp+14Ch] [bp-2C4h]@10
  char v37; // [sp+16Ch] [bp-2A4h]@10
  char v38; // [sp+18Ch] [bp-284h]@10
  char v39; // [sp+1ACh] [bp-264h]@10
  char v40; // [sp+1CCh] [bp-244h]@10
  char v41; // [sp+1ECh] [bp-224h]@10
  char v42; // [sp+20Ch] [bp-204h]@10
  char v43; // [sp+22Ch] [bp-1E4h]@10
  char v44; // [sp+24Ch] [bp-1C4h]@10
  char v45; // [sp+26Ch] [bp-1A4h]@10
  char v46; // [sp+28Ch] [bp-184h]@10
  char v47; // [sp+2ACh] [bp-164h]@10
  char v48; // [sp+2CCh] [bp-144h]@10
  char v49; // [sp+2ECh] [bp-124h]@10
  char v50; // [sp+30Ch] [bp-104h]@10
  char v51; // [sp+32Ch] [bp-E4h]@10
  char v52; // [sp+34Ch] [bp-C4h]@10
  char v53; // [sp+36Ch] [bp-A4h]@10
  char v54; // [sp+38Ch] [bp-84h]@10
  char v55; // [sp+3ACh] [bp-64h]@10
  char v56; // [sp+3CCh] [bp-44h]@10
  char v57; // [sp+3ECh] [bp-24h]@10

  v20 = 0.0;
  *(float *)&v24 = 0.0;
  *(float *)&v23 = 0.0;
  v21 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v22 = 0.0;
  v16 = 0;
  v17 = 0.0;
  v15 = 0;
  if ( a1 && 9.8999998e24 != *a1 )
    *a1 = 0.0;
  if ( a3 && 9.8999998e24 != *a3 )
    *a3 = 0.0;
  if ( a2 && 9.8999998e24 != *a2 )
    *a2 = 0.0;
  sub_1006C420((int)&v26, 5.0, 2.0);
  sub_10016380(41113, (int)&v15, 1);
  sub_10016380(9149, (int)&v16, 1);
  sub_10016380(42004, (int)&v27, 32);
  sub_10016380(42006, (int)&v29, 32);
  sub_10016380(42008, (int)&v30, 32);
  sub_10016380(42010, (int)&v31, 32);
  sub_10016380(42012, (int)&v32, 32);
  sub_10016380(42014, (int)&v33, 32);
  sub_10016380(42016, (int)&v34, 32);
  sub_10016380(42018, (int)&v35, 32);
  sub_10016380(42020, (int)&v36, 32);
  sub_10016380(42022, (int)&v37, 32);
  sub_10016380(42024, (int)&v38, 32);
  sub_10016380(42026, (int)&v39, 32);
  sub_10016380(42028, (int)&v40, 32);
  sub_10016380(42030, (int)&v41, 32);
  sub_10016380(42032, (int)&v42, 32);
  sub_10016380(42034, (int)&v43, 32);
  sub_10016380(42036, (int)&v44, 32);
  sub_10016380(42038, (int)&v45, 32);
  sub_10016380(42040, (int)&v46, 32);
  sub_10016380(42042, (int)&v47, 32);
  sub_10016380(42044, (int)&v48, 32);
  sub_10016380(42046, (int)&v49, 32);
  sub_10016380(42048, (int)&v50, 32);
  sub_10016380(42050, (int)&v51, 32);
  sub_10016380(42052, (int)&v52, 32);
  sub_10016380(42054, (int)&v53, 32);
  sub_10016380(42056, (int)&v54, 32);
  sub_10016380(42058, (int)&v55, 32);
  sub_10016380(42060, (int)&v56, 32);
  sub_10016380(42062, (int)&v57, 32);
  v4 = (float *)&v28;
  v5 = 30;
  do
  {
    if ( *((_BYTE *)v4 - 28) == 1 )
    {
      if ( 9.8999998e24 != *(v4 - 1) )
        v20 = *(v4 - 1) + v20;
      if ( a4 )
      {
        if ( 9.8999998e24 != *v4 )
        {
          v22 = *v4 + v22;
          if ( 9.8999998e24 != *v4 )
          {
            if ( 9.8999998e24 != *(v4 - 3) )
              v19 = *v4 * *(v4 - 3) + v19;
            if ( 9.8999998e24 != *(v4 - 2) )
              v18 = *v4 * *(v4 - 2) + v18;
          }
        }
      }
      if ( 9.8999998e24 != *(v4 - 1) )
      {
        if ( 9.8999998e24 != *(v4 - 3) )
          v19 = *(v4 - 3) * *(v4 - 1) + v19;
        if ( 9.8999998e24 != *(v4 - 2) )
          v18 = *(v4 - 2) * *(v4 - 1) + v18;
      }
    }
    v4 += 8;
    --v5;
  }
  while ( v5 );
  if ( v16 && a4 == 2 )
  {
    v25 = sub_10040190();
    v21 = sub_1006CA50(v25);
    v21 = sub_100707A0(v21, *(float *)&v26);
    sub_1006BDA0(0, v25, 0, (int)&v24, (int)&v23);
    *(float *)&v24 = *(float *)&v24 * 39.37007904052734;
    *(float *)&v23 = 39.37007904052734 * *(float *)&v23;
    v6 = v21;
    v18 = v21 * *(float *)&v24 + v18;
    v19 = v21 * *(float *)&v23 + v19;
  }
  else
  {
    v6 = v21;
  }
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v7 = v22 + v20;
    }
    else
    {
      if ( a4 != 2 )
      {
        v8 = 0.0;
        goto LABEL_40;
      }
      v7 = v6 + v20 + v22;
    }
  }
  else
  {
    v7 = v20;
  }
  v17 = v7;
  v8 = 0.0;
  v9 = v17;
  if ( v17 >= 0.0 )
    goto LABEL_41;
  v17 = 0.0;
LABEL_40:
  v9 = v17;
LABEL_41:
  if ( a1 )
    *a1 = v9;
  v10 = 0.02539999969303608;
  if ( a3 )
  {
    if ( v9 > v8 )
      *a3 = v18 / v9 * 0.02539999969303608;
    v10 = 0.02539999969303608;
  }
  if ( a2 )
  {
    v11 = v10;
    v12 = v8;
    v13 = v11;
    result = v15;
    if ( v12 < v9 )
      *a2 = v13 * (v19 / v9);
  }
  else
  {
    result = v15;
  }
  return result;
}

//----- (1006C9F0) --------------------------------------------------------
char __cdecl sub_1006C9F0(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10015C20("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1006CA30) --------------------------------------------------------
char __cdecl sub_1006CA30(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1006CA50) --------------------------------------------------------
double __cdecl sub_1006CA50(float a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@2
  double result; // st7@4
  float v5; // [sp+8h] [bp+4h]@4
  float v6; // [sp+8h] [bp+4h]@5
  float v7; // [sp+8h] [bp+4h]@6
  float v8; // [sp+8h] [bp+4h]@7

  v2 = (unsigned __int8)sub_100257D0(v1);
  if ( (_BYTE)v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v6 = (float)778.90802 * a1;
        result = v6;
      }
      else
      {
        v5 = (float)850.76703 * a1;
        result = v5;
      }
    }
    else
    {
      v7 = (float)804.0722 * a1;
      result = v7;
    }
  }
  else
  {
    v8 = (float)718.95856 * a1;
    result = v8;
  }
  return result;
}

//----- (1006CAF0) --------------------------------------------------------
int __cdecl sub_1006CAF0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (1006CC00) --------------------------------------------------------
unsigned int __cdecl sub_1006CC00(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  unsigned int result; // eax@2
  int v9; // [sp+8h] [bp+8h]@1

  v9 = sub_1006D740(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *(_BYTE *)(*(_DWORD *)(v9 + 52) + 8) == 8 )
  {
    if ( *(_DWORD *)(v9 + 68) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 1 )
      {
        *(_WORD *)(v9 + 38) = **(_WORD **)(v9 + 68);
        *(_WORD *)(v9 + 36) = *(_WORD *)(*(_DWORD *)(v9 + 68) + 2);
        result = sub_1006CCE0(v9);
      }
      else
      {
        result = sub_1006D210(v9);
      }
    }
    else if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 8 )
    {
      result = sub_1006D030(v9);
    }
    else
    {
      result = sub_1006D210(v9);
    }
  }
  else
  {
    result = sub_1006D210(v9);
  }
  return result;
}

//----- (1006CCE0) --------------------------------------------------------
int __cdecl sub_1006CCE0(int a1)
{
  int result; // eax@1
  int v2; // ST1C_4@10
  int v3; // [sp+0h] [bp-44h]@3
  unsigned int v4; // [sp+4h] [bp-40h]@5
  unsigned int v5; // [sp+4h] [bp-40h]@9
  unsigned __int16 v6; // [sp+8h] [bp-3Ch]@3
  int v7; // [sp+Ch] [bp-38h]@5
  unsigned __int16 v8; // [sp+10h] [bp-34h]@3
  unsigned __int16 v9; // [sp+14h] [bp-30h]@2
  signed int v10; // [sp+1Ch] [bp-28h]@9
  unsigned int *v11; // [sp+20h] [bp-24h]@9
  int v12; // [sp+24h] [bp-20h]@11
  int v13; // [sp+28h] [bp-1Ch]@9
  unsigned int v14; // [sp+2Ch] [bp-18h]@9
  unsigned __int16 v15; // [sp+30h] [bp-14h]@2
  unsigned int *v16; // [sp+34h] [bp-10h]@3
  int v17; // [sp+38h] [bp-Ch]@4
  unsigned int v18; // [sp+3Ch] [bp-8h]@2
  unsigned __int16 v19; // [sp+40h] [bp-4h]@2
  int v20; // [sp+4Ch] [bp+8h]@1

  result = sub_1006ECE0(a1);
  v20 = result;
  if ( result )
  {
    v19 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v18 = ((unsigned int)*(_WORD *)(result + 14) >> 3)
        + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10)
        + **(_DWORD **)(result + 56);
    v9 = 8 * (*(_WORD *)(result + 14) >> 3) - *(_WORD *)(result + 14) + 8;
    v15 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    if ( !(*(_WORD *)(*(_DWORD *)(result + 52) + 10) << 30) )
    {
      v16 = (unsigned int *)(**(_DWORD **)(result + 52)
                           + *(_WORD *)(result + 8) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                           + 4 * (8 * *(_WORD *)(result + 10) >> 5));
      v8 = 32 * (8 * *(_WORD *)(result + 10) >> 5) - 8 * *(_WORD *)(result + 10) + 32;
      v3 = *(_WORD *)(result + 16);
      v6 = *(_WORD *)(result + 18);
      do
      {
        v17 = v9;
        if ( v18 << 31 )
        {
          v4 = *(_BYTE *)v18;
          v7 = v18 + 1;
        }
        else if ( v18 << 30 )
        {
          v4 = *(_WORD *)v18;
          v7 = v18 + 2;
          v17 = v9 + 8;
        }
        else
        {
          v4 = *(_DWORD *)v18;
          v7 = v18 + 4;
          v17 = v9 + 24;
        }
        v5 = (v4 >> ((-v9 + 8) & 0x1F)) | (v4 << (32 - ((-v9 + 8) & 0x1F)));
        v10 = v8;
        v11 = v16;
        v14 = (*v16 >> ((32 - v8) & 0x1F)) | (*v16 << (32 - ((32 - v8) & 0x1F)));
        v13 = v6;
        do
        {
          v2 = 2 * v5 & 3;
          v5 >>= 1;
          if ( v2 )
            v12 = *(_WORD *)(v20 + 38);
          else
            v12 = *(_WORD *)(v20 + 36);
          if ( (signed __int16)v12 >= 0 )
            v14 = (v14 >> 8) | (v12 << 24);
          else
            v14 = (v14 >> 8) | (v14 << 24);
          if ( --v13 )
          {
            v10 -= 8;
            if ( !v10 )
            {
              *v11 = v14;
              ++v11;
              v10 = 32;
              v14 = *v11;
            }
            if ( !--v17 )
            {
              if ( v7 << 30 )
              {
                v17 = 16;
                v5 = *(_WORD *)v7;
                v7 += 2;
              }
              else
              {
                v17 = 32;
                v5 = *(_DWORD *)v7;
                v7 += 4;
              }
            }
          }
        }
        while ( v13 );
        *v11 = (v14 >> ((v10 - 8) & 0x1F)) | (v14 << (32 - ((v10 - 8) & 0x1F)));
        v18 += v19;
        result = (int)v16 + v15;
        v16 = (unsigned int *)((char *)v16 + v15);
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (1006D030) --------------------------------------------------------
int __cdecl sub_1006D030(int a1)
{
  int result; // eax@1
  signed int v2; // [sp+4h] [bp-30h]@16
  int v3; // [sp+8h] [bp-2Ch]@9
  char *v4; // [sp+Ch] [bp-28h]@4
  _BYTE *v5; // [sp+Ch] [bp-28h]@10
  _BYTE *v6; // [sp+Ch] [bp-28h]@12
  _BYTE *v7; // [sp+Ch] [bp-28h]@14
  char *v8; // [sp+10h] [bp-24h]@4
  _BYTE *v9; // [sp+10h] [bp-24h]@10
  _BYTE *v10; // [sp+10h] [bp-24h]@12
  _BYTE *v11; // [sp+10h] [bp-24h]@14
  unsigned int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+14h] [bp-20h]@10
  int v14; // [sp+14h] [bp-20h]@12
  int v15; // [sp+18h] [bp-1Ch]@2
  int v16; // [sp+1Ch] [bp-18h]@2
  int v17; // [sp+20h] [bp-14h]@2
  size_t v18; // [sp+24h] [bp-10h]@2
  char *v19; // [sp+28h] [bp-Ch]@2
  int v20; // [sp+2Ch] [bp-8h]@2
  char *v21; // [sp+30h] [bp-4h]@2
  _BYTE *v22; // [sp+3Ch] [bp+8h]@1

  result = sub_1006ECE0(a1);
  v22 = (_BYTE *)result;
  if ( result )
  {
    v18 = *(_WORD *)(result + 18);
    v15 = *(_WORD *)(result + 16);
    v17 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    v16 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v21 = (char *)(*(_WORD *)(result + 14) + v16 * *(_WORD *)(result + 12) + **(_DWORD **)(result + 56));
    v19 = (char *)(*(_WORD *)(result + 10) + v17 * *(_WORD *)(result + 8) + **(_DWORD **)(result + 52));
    v20 = 0;
    do
    {
      if ( v20 )
        goto LABEL_26;
      v12 = v18;
      v8 = v21;
      v4 = v19;
      while ( v12 >= 4 )
      {
        if ( *(_DWORD *)v4 != *(_DWORD *)v8 )
          goto LABEL_9;
        v12 -= 4;
        v8 += 4;
        v4 += 4;
      }
      if ( !v12 )
      {
LABEL_16:
        v2 = 0;
        goto LABEL_19;
      }
LABEL_9:
      v3 = (unsigned __int8)*v4 - (unsigned __int8)*v8;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v8 )
      {
        v13 = v12 - 1;
        v9 = v8 + 1;
        v5 = v4 + 1;
        if ( !v13 )
          goto LABEL_16;
        v3 = *v5 - *v9;
        if ( *v5 == *v9 )
        {
          v14 = v13 - 1;
          v10 = v9 + 1;
          v6 = v5 + 1;
          if ( !v14 )
            goto LABEL_16;
          v3 = *v6 - *v10;
          if ( *v6 == *v10 )
          {
            v11 = v10 + 1;
            v7 = v6 + 1;
            if ( v14 == 1 )
              goto LABEL_16;
            v3 = *v7 - *v11;
            if ( *v7 == *v11 )
              goto LABEL_16;
          }
        }
      }
      v2 = 1;
      if ( v3 <= 0 )
        v2 = -1;
LABEL_19:
      if ( v2 )
      {
LABEL_26:
        ++v20;
        memcpy_0(v19, v21, v18);
      }
      v21 += v16;
      v19 += v17;
      result = v15-- - 1;
    }
    while ( v15 );
    if ( !v20 )
      *v22 = 0;
  }
  return result;
}

//----- (1006D210) --------------------------------------------------------
unsigned int __cdecl sub_1006D210(int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ST08_4@5
  unsigned int v3; // ST28_4@6
  int v4; // ST28_4@13
  int v5; // [sp+0h] [bp-50h]@4
  unsigned int v6; // [sp+4h] [bp-4Ch]@5
  int v7; // [sp+8h] [bp-48h]@4
  unsigned __int16 v8; // [sp+Ch] [bp-44h]@4
  int *v9; // [sp+10h] [bp-40h]@5
  unsigned __int16 v10; // [sp+14h] [bp-3Ch]@4
  int v11; // [sp+18h] [bp-38h]@3
  int v12; // [sp+18h] [bp-38h]@5
  unsigned __int16 v13; // [sp+20h] [bp-30h]@3
  unsigned int *v14; // [sp+2Ch] [bp-24h]@5
  signed int v15; // [sp+30h] [bp-20h]@13
  int v16; // [sp+34h] [bp-1Ch]@5
  unsigned int v17; // [sp+38h] [bp-18h]@5
  unsigned __int16 v18; // [sp+3Ch] [bp-14h]@3
  unsigned int *v19; // [sp+40h] [bp-10h]@4
  int v20; // [sp+48h] [bp-8h]@2
  int v21; // [sp+48h] [bp-8h]@3
  unsigned __int16 v22; // [sp+4Ch] [bp-4h]@2
  unsigned int v23; // [sp+58h] [bp+8h]@1

  result = sub_1006ECE0(a1);
  v23 = result;
  if ( result )
  {
    v22 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v20 = **(_DWORD **)(result + 56) + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    result = *(_DWORD *)(result + 56);
    if ( (unsigned int)*(_BYTE *)(result + 8) < 9 )
    {
      v21 = v20 + 4 * ((signed int)*(_WORD *)(v23 + 14) << byte_101125E8[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)] >> 5);
      v13 = 32 - ((*(_WORD *)(v23 + 14) << byte_101125E8[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)]) & 0x1F);
      v18 = *(_WORD *)(*(_DWORD *)(v23 + 52) + 10);
      v11 = *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8) | (*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8) << 8);
      result = *(_BYTE *)(*(_DWORD *)(v23 + 52) + 8);
      if ( result < 9 )
      {
        v19 = (unsigned int *)(**(_DWORD **)(v23 + 52)
                             + *(_WORD *)(v23 + 8) * *(_WORD *)(*(_DWORD *)(v23 + 52) + 10)
                             + 4
                             * ((signed int)*(_WORD *)(v23 + 10) << byte_101125E8[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)] >> 5));
        v10 = 32 - ((*(_WORD *)(v23 + 10) << byte_101125E8[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)]) & 0x1F);
        v8 = *(_WORD *)(v23 + 18);
        v5 = *(_WORD *)(v23 + 16);
        v7 = (1 << *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)) - 1;
        do
        {
          v2 = *(_DWORD *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5));
          v9 = (int *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 4);
          v6 = (v2 >> (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)) | (v2 << (32 - (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)));
          v14 = v19;
          v17 = (*v19 >> (31 * v10 & 0x1F)) | (*v19 << (32 - (31 * v10 & 0x1F)));
          v12 = (unsigned __int16)v11 | (((v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 127) | ((v10 + 127) << 8)) << 16);
          v16 = v8;
          if ( *(_DWORD *)(v23 + 68) )
          {
            do
            {
              v4 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v15 = *(_WORD *)(*(_DWORD *)(v23 + 68) + 2 * v4);
              if ( (signed __int16)v15 >= 0 )
                v17 = (v15 >> (BYTE1(v12) & 0x1F)) | (v15 << (32 - (BYTE1(v12) & 0x1F))) | ((unsigned __int64)v17 >> SBYTE1(v12));
              else
                v17 = (v17 >> (BYTE1(v12) & 0x1F)) | (v17 << (32 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( (signed __int16)v16 > 0 );
          }
          else
          {
            do
            {
              v3 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v17 = ((unsigned __int64)v17 >> SBYTE1(v12)) | (v3 >> (BYTE1(v12) & 0x1F)) | (v3 << (32
                                                                                                 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( v16 );
          }
          v11 = -65535 * v12;
          *v14 = (v17 >> ((BYTE3(v11) - 127) & 0x1F)) | (v17 << (32 - ((BYTE3(v11) - 127) & 0x1F)));
          v21 += v22;
          result = (unsigned int)v19 + v18;
          v19 = (unsigned int *)((char *)v19 + v18);
          --v5;
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (1006D740) --------------------------------------------------------
int __cdecl sub_1006D740(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  *(_DWORD *)(a1 + 56) = a2;
  *(_WORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 10) = a5;
  *(_WORD *)(a1 + 8) = a6;
  *(_WORD *)(a1 + 18) = a7;
  *(_WORD *)(a1 + 16) = a8;
  return a1;
}

//----- (1006D7A0) --------------------------------------------------------
_WORD *__cdecl sub_1006D7A0(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (1006D800) --------------------------------------------------------
int __cdecl sub_1006D800(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_1006CAF0(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (1006D8F0) --------------------------------------------------------
void sub_1006D8F0()
{
  ;
}

//----- (1006D900) --------------------------------------------------------
int __cdecl sub_1006D900(int a1, _BYTE *a2, int a3)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 2) )
    result = 0;
  else
    result = sub_1006E350(a1, a2, a3);
  return result;
}

//----- (1006D940) --------------------------------------------------------
char __cdecl sub_1006D940(char a1, char a2)
{
  char result; // al@1

  result = a1;
  byte_1026CE91 = a1;
  byte_1026CE90 = a2;
  return result;
}
// 1026CE90: using guessed type char byte_1026CE90;
// 1026CE91: using guessed type char byte_1026CE91;

//----- (1006D960) --------------------------------------------------------
int __cdecl sub_1006D960(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7)
{
  int result; // eax@12
  __int16 v8; // ST1C_2@20
  __int16 v9; // ST1E_2@43
  __int16 v10; // ST1C_2@56
  __int16 v11; // [sp+8h] [bp-8Ch]@17
  __int16 v12; // [sp+8h] [bp-8Ch]@43
  __int16 v13; // [sp+Ah] [bp-8Ah]@17
  __int16 v14; // [sp+Ah] [bp-8Ah]@43
  __int16 *v15; // [sp+10h] [bp-84h]@3
  unsigned __int8 v16; // [sp+17h] [bp-7Dh]@1
  int v17; // [sp+18h] [bp-7Ch]@47
  int v18; // [sp+1Ch] [bp-78h]@17
  int v19; // [sp+20h] [bp-74h]@11
  __int16 v20; // [sp+28h] [bp-6Ch]@29
  int v21; // [sp+2Ch] [bp-68h]@50
  int v22; // [sp+30h] [bp-64h]@47
  int i; // [sp+34h] [bp-60h]@13
  signed int v24; // [sp+38h] [bp-5Ch]@15
  unsigned __int8 v25; // [sp+3Eh] [bp-56h]@1
  bool v26; // [sp+3Fh] [bp-55h]@1
  char v27; // [sp+40h] [bp-54h]@45
  __int16 v28; // [sp+44h] [bp-50h]@43
  __int16 v29; // [sp+46h] [bp-4Eh]@56
  char v30; // [sp+48h] [bp-4Ch]@43
  char v31; // [sp+49h] [bp-4Bh]@46
  __int16 v32; // [sp+4Ah] [bp-4Ah]@56
  unsigned __int8 v33; // [sp+4Fh] [bp-45h]@1
  int v34; // [sp+50h] [bp-44h]@15
  __int16 v35; // [sp+54h] [bp-40h]@22
  int v36; // [sp+58h] [bp-3Ch]@45
  int v37; // [sp+5Ch] [bp-38h]@44
  int v38; // [sp+60h] [bp-34h]@28
  __int16 v39; // [sp+64h] [bp-30h]@17
  __int16 v40; // [sp+66h] [bp-2Eh]@17
  __int16 v41; // [sp+68h] [bp-2Ch]@55
  __int16 v42; // [sp+6Ah] [bp-2Ah]@55
  unsigned __int16 v43; // [sp+6Ch] [bp-28h]@24
  int v44; // [sp+70h] [bp-24h]@29
  char v45; // [sp+75h] [bp-1Fh]@43
  unsigned __int8 v46; // [sp+76h] [bp-1Eh]@1
  char v47; // [sp+77h] [bp-1Dh]@43
  int v48; // [sp+78h] [bp-1Ch]@22
  int v49; // [sp+7Ch] [bp-18h]@23
  __int16 v50; // [sp+80h] [bp-14h]@55
  __int16 v51; // [sp+82h] [bp-12h]@55
  __int16 v52; // [sp+84h] [bp-10h]@24
  int v53; // [sp+88h] [bp-Ch]@4
  int v54; // [sp+8Ch] [bp-8h]@19
  __int16 v55; // [sp+90h] [bp-4h]@17

  v16 = (a5 & 0xE000u) >> 13;
  v46 = (unsigned __int8)(a5 & 0x70) >> 4;
  v25 = (a5 & 0x380u) >> 7;
  v33 = (a5 & 0x1C00u) >> 10;
  v26 = 1;
  if ( a5 & 0x40000000 || a5 & 0x80000000 )
  {
    v15 = &a6;
    if ( a5 & 0x40000000 )
    {
      v15 = (__int16 *)&a7;
      v53 = a6;
      v16 = (a6 & 0xFF000000) >> 24;
      v46 = a6;
      v25 = (unsigned __int16)(a6 & 0xFF00) >> 8;
      v33 = (a6 & 0xFF0000u) >> 16;
    }
    if ( a5 & 0x80000000 )
    {
      if ( *(_DWORD *)v15 )
      {
        if ( *(_DWORD *)v15 == 2 )
          v26 = sub_1006E1A0(a3) == 0;
        else
          v26 = 0;
      }
      else
      {
        v26 = 1;
      }
    }
  }
  v19 = 0;
  if ( *(_BYTE *)(a2 + 3) & 3 )
  {
    result = 0;
  }
  else
  {
    i = sub_1006D900(a2, a3, a5);
    if ( !a4 )
      a4 = i;
    v34 = a4;
    v24 = ((a5 & 0x3F0000u) >> 16) - 1;
    if ( v24 < 0 )
      v24 = *(_WORD *)(a2 + 28);
    v18 = *(_WORD *)(a2 + 22);
    v11 = *(_WORD *)(a1 + 46);
    v55 = *(_WORD *)(a1 + 44);
    v13 = v55 - (*(_WORD *)(a2 + 24) - 1);
    v39 = *(_WORD *)(a1 + 42);
    v40 = *(_WORD *)(a1 + 40);
    if ( a5 & 3 )
    {
      if ( (a5 & 3) == 1 )
      {
        v54 = v11 - v34 / 2;
        v11 -= i / 2;
      }
      else
      {
        v54 = v11;
      }
    }
    else
    {
      v8 = v11 + 1;
      v54 = v8 - v34;
      v11 = v8 - i;
    }
    v35 = v13;
    v48 = v18;
    if ( a5 & 0xC )
    {
      v35 += *(_WORD *)(a2 + 26);
      v48 -= v18 - *(_WORD *)(a2 + 24) + *(_WORD *)(a2 + 26);
      v54 -= v46;
      v49 = v25;
      v34 += v25 + v46;
      if ( (a5 & 0xC) == 4 )
      {
        v52 = *(_WORD *)(a1 + 6);
        v43 = *(_WORD *)(a1 + 50);
        *(_WORD *)(a1 + 6) = 3;
        *(_WORD *)(a1 + 50) = *(_WORD *)(a1 + 36);
        v49 = v33;
        v35 -= v33;
        v48 += v33;
        if ( v33 > (signed int)*(_WORD *)(a2 + 26) )
          sub_1006E440(a1, v54, v35, v34, v49 - *(_WORD *)(a2 + 26));
        v49 = v16;
        v48 += v16;
        if ( v16 > v18 - *(_WORD *)(a2 + 24) )
          sub_1006E440(a1, v54, v18 + v13, v34, v49 - (v18 - *(_WORD *)(a2 + 24)));
        v38 = v11 - v54;
        if ( i > a4 )
        {
          v20 = a4 + v11;
          v44 = v25;
        }
        else
        {
          v20 = i + v11;
          v44 = v34 - (i + v38);
        }
        if ( v38 > 0 )
          sub_1006E440(a1, v54, v35, v38, v48);
        if ( v44 > 0 )
          sub_1006E440(a1, v20, v35, v44, v48);
        *(_WORD *)(a1 + 50) = v43;
        *(_WORD *)(a1 + 6) = v52;
      }
    }
    if ( v35 <= v13 )
      v35 = 0;
    else
      v35 -= v13;
    if ( v48 >= v18 - v35 )
      v48 = v18 - v35;
    if ( i < a4 )
      a4 = i;
    v30 = 1;
    v47 = 0;
    v45 = (*(_BYTE *)(a2 + 3) & 3) << 6;
    v12 = v39 + v11;
    v9 = v40 + v13;
    v52 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = 2;
    v14 = v35 + v9;
    v28 = v18;
    if ( i )
    {
      v37 = (a5 & 0x3FC00000u) >> 22;
      for ( i = 0; !sub_1006E240(a2, &a3, &v27, &v36, v26); i += v21 + (signed __int16)v36 )
      {
        v31 = v47;
        if ( v37 <= v36 )
        {
          v22 = 0;
          v17 = 0;
        }
        else
        {
          v22 = (v37 - v36) / 2;
          v17 = v37 - v36 - v22;
        }
        v21 = i <= 0 ? v22 : v22 + v24 + v19;
        if ( v36 + v21 + i > a4 )
          break;
        v19 = v17;
        v43 = *(_WORD *)(a1 + 38);
        if ( v21 > 0 && v43 != 0xFFFF )
        {
          *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
          v50 = v14;
          v51 = v12;
          v41 = v48;
          v42 = v21;
          sub_1006EEB0(a1, (signed __int16)v21 + (v12 << 16), (signed __int16)v48 + (v14 << 16));
          *(_WORD *)(a1 + 38) = v43;
        }
        v10 = v21 + v12;
        *(_WORD *)(a1 + 8) = v14;
        *(_WORD *)(a1 + 10) = v10;
        *(_WORD *)(a1 + 16) = v48;
        *(_WORD *)(a1 + 18) = v36;
        v29 = v36;
        *(_WORD *)(a1 + 14) = 0;
        *(_WORD *)(a1 + 12) = v35;
        v32 = (v29 + 7) / 8;
        *(_DWORD *)(a1 + 56) = &v27;
        sub_1006CCE0(a1);
        v12 = v36 + v10;
      }
    }
    v43 = *(_WORD *)(a1 + 38);
    if ( i < a4 && v43 != 0xFFFF )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
      v50 = v14;
      v51 = v12;
      v41 = v48;
      v42 = a4 - i;
      sub_1006EEB0(a1, (signed __int16)(a4 - i) + (v12 << 16), (signed __int16)v48 + (v14 << 16));
      *(_WORD *)(a1 + 38) = v43;
    }
    *(_WORD *)(a1 + 4) = v52;
    *(_WORD *)(a1 + 46) = v19 + v12 - v39;
    *(_WORD *)(a1 + 44) = v55;
    result = v19 + i;
  }
  return result;
}

//----- (1006E1A0) --------------------------------------------------------
bool __cdecl sub_1006E1A0(_BYTE *a1)
{
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v3 = 0;
  v4 = 0;
  while ( *a1 )
  {
    if ( (signed int)*a1 < 48 || (signed int)*a1 > 57 )
    {
      if ( (signed int)*a1 >= 97 && (signed int)*a1 <= 122 || (signed int)*a1 >= 65 && (signed int)*a1 <= 90 )
        v3 = 1;
    }
    else
    {
      v4 = 1;
    }
    ++a1;
  }
  return v3 && v4;
}

//----- (1006E240) --------------------------------------------------------
bool __cdecl sub_1006E240(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v5; // ST18_4@9
  int v7; // [sp+4h] [bp-1Ch]@7
  bool v8; // [sp+Bh] [bp-15h]@1
  unsigned int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+14h] [bp-Ch]@1

  v10 = *(_BYTE *)(*a2)++;
  v8 = v10 == 0;
  if ( byte_1026CE91 && a5 && v10 == 48 )
    v10 = (unsigned __int8)byte_1026CE90;
  if ( !v8 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      v8 = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 8) + a1;
      v9 = v10 - *(_BYTE *)(v7 + 2);
      if ( v9 >= *(_WORD *)v7 )
        v9 = *(_BYTE *)(v7 + 3);
      v5 = *(_DWORD *)(a1 + 12) + a1 + 4 * v9;
      *a3 = ((*(_BYTE *)(v5 + 2) << 16) | *(_WORD *)v5) + *(_DWORD *)(a1 + 16) + a1;
      *a4 = *(_BYTE *)(v5 + 3);
    }
  }
  return v8;
}
// 1026CE90: using guessed type char byte_1026CE90;
// 1026CE91: using guessed type char byte_1026CE91;

//----- (1006E350) --------------------------------------------------------
int __cdecl sub_1006E350(int a1, _BYTE *a2, int a3)
{
  int v3; // ST00_4@5
  unsigned int v5; // [sp+0h] [bp-20h]@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@3
  signed int v9; // [sp+10h] [bp-10h]@1
  signed int v10; // [sp+14h] [bp-Ch]@8
  signed int v11; // [sp+18h] [bp-8h]@1
  _BYTE *v12; // [sp+1Ch] [bp-4h]@3

  v11 = (a3 & 0x3FC00000u) >> 22;
  v9 = ((a3 & 0x3F0000u) >> 16) - 1;
  if ( v9 < 0 )
    v9 = *(_WORD *)(a1 + 28);
  v12 = a2;
  v6 = *(_DWORD *)(a1 + 12) + a1;
  v7 = *(_DWORD *)(a1 + 8) + a1;
  v8 = 0;
  while ( *v12 )
  {
    v3 = *v12++;
    v5 = v3 - *(_BYTE *)(v7 + 2);
    if ( v8 > 0 )
      v8 += v9;
    if ( v5 < *(_WORD *)v7 )
      v10 = *(_BYTE *)(v6 + 4 * v5 + 3);
    else
      v10 = *(_BYTE *)(v6 + 4 * *(_BYTE *)(v7 + 3) + 3);
    if ( v11 <= v10 )
      v8 += v10;
    else
      v8 += v11;
  }
  return v8;
}

//----- (1006E440) --------------------------------------------------------
int __cdecl sub_1006E440(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@1
  int v6; // [sp+0h] [bp-8h]@4
  __int16 v7; // [sp+4h] [bp-4h]@6

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + a2;
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + a3;
    if ( *(_WORD *)(a1 + 6) == 3 || *(_WORD *)(a1 + 6) == 1 )
    {
      v7 = *(_WORD *)(a1 + 4);
      if ( *(_WORD *)(a1 + 6) == 3 )
        *(_WORD *)(a1 + 4) = 2;
      else
        *(_WORD *)(a1 + 4) = 0;
      sub_1006EEB0(a1, a4 + (*(_WORD *)(a1 + 10) << 16), a5 + (*(_WORD *)(a1 + 8) << 16));
      *(_WORD *)(a1 + 4) = v7;
    }
    result = a1;
    *(_DWORD *)(a1 + 36) = v6;
  }
  return result;
}

//----- (1006E530) --------------------------------------------------------
int __cdecl sub_1006E530(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int result; // eax@1
  __int16 v7; // ST1C_2@8
  int v8; // [sp+0h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-8h]@4
  __int16 v10; // [sp+10h] [bp-4h]@8
  __int16 v11; // [sp+28h] [bp+14h]@8
  __int16 v12; // [sp+2Ch] [bp+18h]@8

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 36);
    if ( a6 & 1 )
      sub_1006E440(a1, a2, a3, a4, a5);
    if ( !(a6 & 2) )
      LOWORD(v9) = HIWORD(v9);
    v12 = a5 - 1;
    v11 = a4 - 1;
    v10 = a2;
    v10 = *(_WORD *)(a1 + 42) + a2;
    v7 = *(_WORD *)(a1 + 40) + a3;
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101125F4[0]);
    *(_WORD *)(a1 + 10) = byte_101125F4[1] + v10;
    *(_WORD *)(a1 + 8) = v7;
    *(_WORD *)(a1 + 14) = byte_101125F4[2] + v11 - byte_101125F4[1] + 1;
    sub_1006F380(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101125F4[3]);
    *(_WORD *)(a1 + 8) = byte_101125F4[4] + v7;
    *(_WORD *)(a1 + 10) = v11 + v10;
    *(_WORD *)(a1 + 12) = byte_101125F4[5] + v12 - byte_101125F4[4] + 1;
    sub_1006F4F0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101125F4[6]);
    *(_WORD *)(a1 + 10) = byte_101125F4[8] + v11 + v10;
    *(_WORD *)(a1 + 8) = v12 + v7;
    *(_WORD *)(a1 + 14) = byte_101125F4[7] - (byte_101125F4[8] + v11) - 1;
    sub_1006F380(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_101125F4[9]);
    *(_WORD *)(a1 + 8) = byte_101125F4[11] + v12 + v7;
    *(_WORD *)(a1 + 10) = v10;
    *(_WORD *)(a1 + 12) = byte_101125F4[10] - (byte_101125F4[11] + v12) - 1;
    sub_1006F4F0(a1);
    result = v8;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return result;
}

//----- (1006E790) --------------------------------------------------------
int __cdecl sub_1006E790(int a1, __int16 a2, __int16 a3, char a4)
{
  int result; // eax@25
  signed int v5; // [sp+4h] [bp-30h]@29
  int v6; // [sp+8h] [bp-2Ch]@44
  int v7; // [sp+8h] [bp-2Ch]@54
  __int16 v8; // [sp+Ch] [bp-28h]@31
  char (__cdecl *v9)(int); // [sp+10h] [bp-24h]@2
  char *(__cdecl *v10)(int); // [sp+14h] [bp-20h]@5
  __int16 v11; // [sp+18h] [bp-1Ch]@31
  signed int v12; // [sp+1Ch] [bp-18h]@31
  __int16 v13; // [sp+20h] [bp-14h]@41
  __int16 v14; // [sp+28h] [bp-Ch]@29
  __int16 v15; // [sp+2Ch] [bp-8h]@29
  __int16 v16; // [sp+30h] [bp-4h]@41

  if ( *(_DWORD *)(a1 + 72) )
    v9 = *(char (__cdecl **)(int))(a1 + 72);
  else
    v9 = sub_1006F380;
  if ( *(_DWORD *)(a1 + 76) )
    v10 = *(char *(__cdecl **)(int))(a1 + 76);
  else
    v10 = sub_1006F4F0;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + a2;
  *(_WORD *)(a1 + 12) = *(_WORD *)(a1 + 40) + a3;
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  if ( a4 & 1 )
  {
    if ( (signed int)*(_WORD *)(a1 + 10) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 10) < -8192 )
        *(_WORD *)(a1 + 10) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 10) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 8) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 8) < -8192 )
        *(_WORD *)(a1 + 8) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 8) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 14) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 14) < -8192 )
        *(_WORD *)(a1 + 14) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 14) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 12) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 12) < -8192 )
        *(_WORD *)(a1 + 12) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 12) = 0x1FFF;
    }
  }
  if ( *(_WORD *)(a1 + 10) != *(_WORD *)(a1 + 14) || (result = *(_WORD *)(a1 + 12), *(_WORD *)(a1 + 8) != result) )
  {
    v14 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
    v15 = v14;
    v5 = 1;
    if ( v14 < 0 )
    {
      v5 = -1;
      v15 = -v14;
    }
    v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
    v11 = v8;
    v12 = 1;
    if ( v8 < 0 )
    {
      v12 = -1;
      v11 = -v8;
    }
    if ( v15 )
    {
      if ( v11 )
      {
        v13 = 2 * v15;
        v16 = 2 * v11;
        if ( v15 <= v11 )
        {
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          if ( v13 >= v11 )
            *(_WORD *)(a1 + 16) -= (v12 ^ v5) + 1;
          v7 = v13 - v11 - (v5 < 0);
          *(_WORD *)(a1 + 12) = 0;
          while ( v11 )
          {
            *(_WORD *)(a1 + 12) += v12;
            if ( v7 >= 0 )
            {
              v10(a1);
              *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
              *(_WORD *)(a1 + 12) = 0;
              *(_WORD *)(a1 + 10) += v5;
              v7 -= v16;
            }
            v7 += v13;
            --v11;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 12) += v12;
          v10(a1);
          result = a1;
          *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
        }
        else
        {
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          if ( v16 >= v15 )
            *(_WORD *)(a1 + 18) -= (v12 ^ v5) + 1;
          v6 = v16 - v15 - (v12 < 0);
          *(_WORD *)(a1 + 14) = 0;
          while ( v15 )
          {
            *(_WORD *)(a1 + 14) += v5;
            if ( v6 >= 0 )
            {
              v9(a1);
              *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
              *(_WORD *)(a1 + 14) = 0;
              *(_WORD *)(a1 + 8) += v12;
              v6 -= v13;
            }
            v6 += v16;
            --v15;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 14) += v5;
          v9(a1);
          result = a1;
          *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
        }
      }
      else
      {
        *(_WORD *)(a1 + 16) = 1;
        *(_WORD *)(a1 + 18) = 0;
        *(_WORD *)(a1 + 14) = v14;
        if ( a4 & 2 )
          *(_WORD *)(a1 + 14) += v5;
        result = v9(a1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 18) = 1;
      *(_WORD *)(a1 + 12) = v8;
      if ( a4 & 2 )
        *(_WORD *)(a1 + 12) += v12;
      result = (int)v10(a1);
    }
  }
  else if ( a4 & 2 )
  {
    *(_WORD *)(a1 + 12) = 1;
    result = (int)v10(a1);
  }
  return result;
}

//----- (1006ECE0) --------------------------------------------------------
int __cdecl sub_1006ECE0(int a1)
{
  int result; // eax@6
  __int16 v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = *(_WORD *)(a1 + 10);
  v3 = *(_WORD *)(a1 + 8);
  if ( *(_WORD *)(a1 + 26) > (signed int)*(_WORD *)(a1 + 10) )
  {
    *(_WORD *)(a1 + 18) -= *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 14) += *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > (signed int)*(_WORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 16) -= *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) += *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 24);
  }
  if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) > v2 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v2 < *(_WORD *)(a1 + 18) )
      *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v2;
    if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) > v3 )
    {
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v3 < *(_WORD *)(a1 + 16) )
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 24) - v3;
      if ( (signed int)*(_WORD *)(a1 + 18) > 0 )
      {
        if ( (signed int)*(_WORD *)(a1 + 16) > 0 )
        {
          *(_BYTE *)a1 = 1;
          result = a1;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1006EEB0) --------------------------------------------------------
int __cdecl sub_1006EEB0(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_10112600 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (1006F380) --------------------------------------------------------
char __cdecl sub_1006F380(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_1006F900(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = sub_100701C0(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_1006F900(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_1006F900(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_1006FA00(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_1006FE30(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (1006F4F0) --------------------------------------------------------
char *__cdecl sub_1006F4F0(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_1006F980(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_1006FC00(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_1006FF70(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_1006F980(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_10070300(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (1006F640) --------------------------------------------------------
int __cdecl sub_1006F640(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (1006F760) --------------------------------------------------------
unsigned int __cdecl sub_1006F760(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (1006F900) --------------------------------------------------------
int __cdecl sub_1006F900(int a1, int a2, int a3)
{
  return sub_1006EEB0(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (1006F980) --------------------------------------------------------
int __cdecl sub_1006F980(int a1, int a2, int a3)
{
  return sub_1006EEB0(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (1006FA00) --------------------------------------------------------
char __cdecl sub_1006FA00(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_1006FB10(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_1006F640(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_10112600 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_10112600 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (1006FB10) --------------------------------------------------------
int __cdecl sub_1006FB10(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (1006FC00) --------------------------------------------------------
int __cdecl sub_1006FC00(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_1006FD00(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (1006FD00) --------------------------------------------------------
int __cdecl sub_1006FD00(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1006FE30) --------------------------------------------------------
char *__cdecl sub_1006FE30(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_1006F640(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_1006F760(a1, (int)v11);
  }
  return result;
}

//----- (1006FF70) --------------------------------------------------------
char *__cdecl sub_1006FF70(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_1006FD00(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (100701C0) --------------------------------------------------------
int __cdecl sub_100701C0(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_1006FE30(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_1006FA00(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int)v10 + (v8 >> 8);
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (10070300) --------------------------------------------------------
int __cdecl sub_10070300(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_1006FF70(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_1006FC00(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int)v9 + (v8 >> 8);
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (10070440) --------------------------------------------------------
int __cdecl sub_10070440(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (10070450) --------------------------------------------------------
int (*__usercall sub_10070450@<eax>(int a1@<eax>, double *a2@<ecx>, int a3@<edi>, int a4@<esi>, int a5, int a6, char a7, double a8, int a9))(void)
{
  double *v9; // ebx@1
  int (*v10)(void); // eax@4
  double v11; // st7@6
  int (*result)(void); // eax@7

  v9 = a2;
  if ( a5 == a1 + 1 )
  {
    if ( !*(_BYTE *)a4 )
    {
      *(_BYTE *)a4 = 1;
      if ( *(_DWORD *)(a3 + 40) )
      {
        v10 = *(int (**)(void))(a3 + 44);
        if ( v10 )
          *(_DWORD *)(a4 + 4) = v10();
      }
    }
    goto LABEL_6;
  }
  if ( a5 != a1 || !*(_BYTE *)a4 || a7 )
  {
LABEL_6:
    v11 = a8;
    goto LABEL_7;
  }
  v11 = *(double *)(a4 + 12);
LABEL_7:
  result = (int (*)(void))a6;
  if ( a5 >= (unsigned int)a6 )
  {
    *v9 = *(double *)(a3 + 16) * v11
        + *(double *)(a3 + 24) * *(double *)(a4 + 12)
        + *(double *)(a3 + 32) * *(double *)(a4 + 20)
        - *(double *)(a4 + 28) * *(double *)a3
        - *(double *)(a3 + 8) * *(double *)(a4 + 36);
    *(double *)(a4 + 20) = *(double *)(a4 + 12);
    *(double *)(a4 + 12) = v11;
    *(double *)(a4 + 36) = *(double *)(a4 + 28);
    *(double *)(a4 + 28) = *v9;
  }
  if ( (a5 == a6 || !*(_BYTE *)a4) && !a7 )
    result = (int (*)(void))sub_10070440(a4);
  *(_BYTE *)a9 = 0;
  if ( *(_BYTE *)a4 )
  {
    if ( !*(_DWORD *)(a3 + 40)
      || (result = *(int (**)(void))(a3 + 44)) != 0
      && (result = (int (*)(void))(result() - *(_DWORD *)(a4 + 4)), (unsigned int)result >= *(_DWORD *)(a3 + 40)) )
    {
      *(_BYTE *)a9 = 1;
    }
  }
  return result;
}

//----- (10070520) --------------------------------------------------------
int __usercall sub_10070520@<eax>(int result@<eax>, _DWORD *a2@<edi>, unsigned int a3@<esi>, char a4)
{
  unsigned int v4; // ecx@3

  *(_DWORD *)(result + 8) >>= 1;
  if ( a4 )
    *(_DWORD *)(result + 8) |= 1 << a3;
  *a2 = 0;
  v4 = 0;
  do
  {
    if ( (1 << v4) & *(_DWORD *)(result + 8) )
      ++*a2;
    ++v4;
  }
  while ( v4 <= a3 );
  return result;
}

//----- (10070560) --------------------------------------------------------
int (*__cdecl sub_10070560(char a1, double a2, int a3, int a4, int a5, int a6))(void)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v9; // [sp+18h] [bp-4h]@1

  v6 = sub_10070520(a4, &v9, 5u, a1);
  v7 = v9;
  if ( v9 == 1 )
  {
    if ( a1 )
      *(double *)(v6 + 20) = a2;
  }
  else if ( v9 == 2 )
  {
    if ( a1 )
    {
      *(double *)(v6 + 12) = a2;
      *(double *)(v6 + 36) = 0.0;
    }
  }
  else if ( v9 == 3 && a1 )
  {
    *(double *)(v6 + 28) = 0.0;
    *(double *)(v6 + 20) = *(double *)(v6 + 12);
    *(double *)(v6 + 12) = a2;
  }
  return sub_10070450(5, (double *)a6, a3, v6, v7, 4, a1, a2, a5);
}

//----- (100705F0) --------------------------------------------------------
double __cdecl sub_100705F0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10070690) --------------------------------------------------------
int __cdecl sub_10070690(signed int a1, signed int a2)
{
  int result; // eax@2

  if ( a2 > 0 )
  {
    result = a2 * (a1 / a2);
    if ( a1 == result )
    {
      result = a1;
    }
    else if ( a1 < 0 )
    {
      result -= a2;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100706D0) --------------------------------------------------------
double __cdecl sub_100706D0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10070770) --------------------------------------------------------
int __cdecl sub_10070770(float a1)
{
  double v1; // st7@1
  int result; // eax@2

  v1 = a1;
  if ( a1 >= 0.0 )
    result = (signed int)(v1 + 0.5);
  else
    result = (signed int)(v1 - 0.5);
  return result;
}

//----- (100707A0) --------------------------------------------------------
double __cdecl sub_100707A0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10070810) --------------------------------------------------------
int __cdecl sub_10070810(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (10070830) --------------------------------------------------------
int __cdecl sub_10070830(unsigned __int8 a1, unsigned int a2)
{
  return dword_10112F10[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 10112F10: using guessed type int dword_10112F10[];

//----- (10070850) --------------------------------------------------------
unsigned int __cdecl sub_10070850(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_10112F10[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_10112F10[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_10112F10[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_10112F10[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_10112F10[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_10112F10[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_10112F10[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_10112F10[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_10112F10[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_10112F10[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 10112F10: using guessed type int dword_10112F10[];

//----- (10070980) --------------------------------------------------------
double __cdecl sub_10070980(int a1)
{
  float v1; // ST00_4@1
  float v2; // ST00_4@1

  v1 = *(float *)a1 * *(float *)a1 + 0.0;
  v2 = *(float *)(a1 + 4) * *(float *)(a1 + 4) + v1;
  return (float)sqrt(v2);
}

//----- (100709C0) --------------------------------------------------------
int __cdecl sub_100709C0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = a1 * *(float *)(a2 + 4);
  return result;
}

//----- (100709E0) --------------------------------------------------------
int __cdecl sub_100709E0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 - *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) - *(float *)(a2 + 4);
  return result;
}

//----- (10070A00) --------------------------------------------------------
int __cdecl sub_10070A00(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(float *)a1;
  *(float *)(a2 + 4) = *(float *)(a1 + 4);
  return result;
}

//----- (10070A20) --------------------------------------------------------
void __cdecl sub_10070A20(int a1, int a2)
{
  int v2; // edx@1
  float v3; // ST10_4@1
  double v4; // st7@1

  sub_10070A00(a1, a2);
  v3 = sub_10070980(v2);
  v4 = v3;
  if ( v3 > 0.0 )
  {
    *(float *)a2 = *(float *)a2 / v4;
    *(float *)(a2 + 4) = *(float *)(a2 + 4) / v4;
  }
}

//----- (10070A70) --------------------------------------------------------
int __cdecl sub_10070A70(int a1, _DWORD *a2)
{
  _DWORD *v2; // ecx@0
  int v3; // eax@1
  __int64 v4; // ST30_8@1
  unsigned int v5; // eax@1
  unsigned int v6; // ST28_4@1
  unsigned int v7; // ST20_4@1
  __int64 v8; // rax@1
  unsigned __int64 v9; // ST3C_8@1
  unsigned __int64 v10; // rax@1
  signed __int64 v11; // rdi@1
  unsigned __int64 v12; // ST3C_8@1
  __int64 v13; // ST20_8@1
  unsigned __int64 v14; // ST3C_8@1
  signed __int64 v15; // kr00_8@1
  signed __int64 v16; // rdi@1
  unsigned __int64 v17; // ST3C_8@1
  int result; // eax@1

  v3 = 1686629713i64 * a1 >> 29;
  v4 = v3;
  v5 = v3 * (signed __int64)v3 >> 30;
  v6 = v5;
  v7 = v5 >> 1;
  v8 = v5 >> 1;
  v9 = __PAIR__(HIDWORD(v8), v7);
  v10 = __PAIR__(HIDWORD(v8), v7) << 31;
  v11 = -715827883i64 * v9 + 0x7FFFFFFFFFFFFFFFi64;
  v12 = v7 * (unsigned __int64)v6;
  v13 = SHIDWORD(v12);
  v14 = HIDWORD(v12) * (unsigned __int64)v6;
  v15 = -5965232i64 * SHIDWORD(v14) + 178956971i64 * (signed int)v13 + 0x7FFFFFFFFFFFFFFFi64 - v10;
  v16 = -852176i64 * SHIDWORD(v14) + 35791394 * v13 + v11;
  v17 = HIDWORD(v14) * (unsigned __int64)v6;
  result = (signed int)((unsigned __int64)(-108i64 * SHIDWORD(v17) + 11836i64 * SHIDWORD(v17) + v16) >> 32) * v4 >> 31;
  *v2 = result;
  *a2 = (unsigned __int64)(-1184i64 * SHIDWORD(v17) + 106522i64 * SHIDWORD(v17) + v15) >> 32;
  return result;
}

//----- (10070C80) --------------------------------------------------------
int __cdecl sub_10070C80(int a1, int *a2, int *a3)
{
  int v3; // esi@1
  int v4; // esi@2
  int v5; // edx@2
  int result; // eax@4
  int v7; // [sp+4h] [bp-4h]@1

  sub_10070A70(((a1 + 0x20000000) & 0x3FFFFFFF) - 0x20000000, &v7);
  v3 = ((a1 + 0x20000000) >> 30) & 3;
  if ( v3 )
  {
    v4 = v3 - 1;
    v5 = v7;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        *a2 = -a1;
        result = (int)a3;
        *a3 = -v5;
      }
      else
      {
        result = (int)a2;
        *a2 = -v7;
        *a3 = a1;
      }
    }
    else
    {
      *a2 = v7;
      result = -a1;
      *a3 = -a1;
    }
  }
  else
  {
    result = a1;
    *a2 = a1;
    *a3 = v7;
  }
  return result;
}

//----- (10072A6A) --------------------------------------------------------
int __thiscall sub_10072A6A(void *this)
{
  return _cintrindisp2(this, &unk_1011FA00);
}
// 100794E0: using guessed type int __fastcall _cintrindisp2(_DWORD, _DWORD);

//----- (10073208) --------------------------------------------------------
int __cdecl sub_10073208(int a1, int a2, char a3)
{
  return vscan_fn(sub_1007B55F, a2, 0, &a3);
}
// 100731A0: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007419A) --------------------------------------------------------
int __cdecl sub_1007419A(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1007D54E() + 8 && (void **)v2 != sub_1007D54E() + 16 || !sub_1007D4F0((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_1011F280;
      else
        v9 = (_BYTE *)(dword_102D3BA0[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_1007D3D0((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_1007D3D0((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 1007D4AC: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (10074D2F) --------------------------------------------------------
int __cdecl sub_10074D2F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1026CEB0 = a1;
  return result;
}
// 1026CEB0: using guessed type int dword_1026CEB0;

//----- (100754BE) --------------------------------------------------------
signed int __cdecl sub_100754BE(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1026D1E0 )
  {
    *a1 = dword_1026D1E0;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10074E35: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1026D1E0: using guessed type int dword_1026D1E0;

//----- (100754F5) --------------------------------------------------------
signed int __cdecl sub_100754F5(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_1026D1E0 )
  {
    *a1 = dword_1026D1EC;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10074E35: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1026D1E0: using guessed type int dword_1026D1E0;
// 1026D1EC: using guessed type int dword_1026D1EC;

//----- (1007613B) --------------------------------------------------------
void sub_1007613B()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_102D3BA0;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_102D3CA0 );
}
// 102D3BA0: using guessed type int dword_102D3BA0[];
// 102D3CA0: using guessed type int dword_102D3CA0;

//----- (100765E8) --------------------------------------------------------
int (*sub_100765E8())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_1011D560;
  v1 = (int (**)(void))&unk_1011D560;
  if ( &unk_1011D560 < &unk_1011D560 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_1011D560 );
  }
  return result;
}

//----- (1007660C) --------------------------------------------------------
void __cdecl sub_1007660C()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_1011D568;
  if ( &unk_1011D568 < &unk_1011D568 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_1011D568 );
  }
}

//----- (10079884) --------------------------------------------------------
#error "10079889: positive sp value has been found (funcsize=0)"

//----- (1007988F) --------------------------------------------------------
#error "10079894: positive sp value has been found (funcsize=0)"

//----- (1007989A) --------------------------------------------------------
#error "1007989F: positive sp value has been found (funcsize=0)"

//----- (100798A0) --------------------------------------------------------
#error "100798A5: positive sp value has been found (funcsize=0)"

//----- (100798A6) --------------------------------------------------------
#error "100798AB: positive sp value has been found (funcsize=0)"

//----- (100798AC) --------------------------------------------------------
#error "100798B1: positive sp value has been found (funcsize=0)"

//----- (100798B2) --------------------------------------------------------
#error "100798CD: positive sp value has been found (funcsize=0)"

//----- (100798D3) --------------------------------------------------------
#error "100798E8: positive sp value has been found (funcsize=0)"

//----- (100798EE) --------------------------------------------------------
#error "10079909: positive sp value has been found (funcsize=0)"

//----- (1007990A) --------------------------------------------------------
#error "10079919: positive sp value has been found (funcsize=0)"

//----- (1007991A) --------------------------------------------------------
#error "1007992D: positive sp value has been found (funcsize=0)"

//----- (1007992E) --------------------------------------------------------
#error "1007993D: positive sp value has been found (funcsize=0)"

//----- (1007993E) --------------------------------------------------------
#error "1007995D: positive sp value has been found (funcsize=0)"

//----- (10079963) --------------------------------------------------------
#error "1007997C: positive sp value has been found (funcsize=0)"

//----- (10079982) --------------------------------------------------------
#error "100799A1: positive sp value has been found (funcsize=0)"

//----- (100799A2) --------------------------------------------------------
#error "100799B5: positive sp value has been found (funcsize=0)"

//----- (100799B6) --------------------------------------------------------
#error "100799CD: positive sp value has been found (funcsize=0)"

//----- (100799CE) --------------------------------------------------------
#error "100799E1: positive sp value has been found (funcsize=0)"

//----- (100799E2) --------------------------------------------------------
#error "10079A01: positive sp value has been found (funcsize=0)"

//----- (10079A07) --------------------------------------------------------
#error "10079A20: positive sp value has been found (funcsize=0)"

//----- (10079A26) --------------------------------------------------------
#error "10079A45: positive sp value has been found (funcsize=0)"

//----- (10079A46) --------------------------------------------------------
#error "10079A59: positive sp value has been found (funcsize=0)"

//----- (10079A5A) --------------------------------------------------------
#error "10079A71: positive sp value has been found (funcsize=0)"

//----- (10079A72) --------------------------------------------------------
#error "10079A85: positive sp value has been found (funcsize=0)"

//----- (10079A86) --------------------------------------------------------
#error "10079AA5: positive sp value has been found (funcsize=0)"

//----- (10079AAB) --------------------------------------------------------
#error "10079AC4: positive sp value has been found (funcsize=0)"

//----- (10079ACA) --------------------------------------------------------
#error "10079AE9: positive sp value has been found (funcsize=0)"

//----- (10079AEA) --------------------------------------------------------
#error "10079AFD: positive sp value has been found (funcsize=0)"

//----- (10079AFE) --------------------------------------------------------
#error "10079B15: positive sp value has been found (funcsize=0)"

//----- (10079B16) --------------------------------------------------------
#error "10079B29: positive sp value has been found (funcsize=0)"

//----- (10079B2A) --------------------------------------------------------
#error "10079B49: positive sp value has been found (funcsize=0)"

//----- (10079B4F) --------------------------------------------------------
#error "10079B68: positive sp value has been found (funcsize=0)"

//----- (10079B6E) --------------------------------------------------------
#error "10079B8D: positive sp value has been found (funcsize=0)"

//----- (10079B8E) --------------------------------------------------------
#error "10079BA1: positive sp value has been found (funcsize=0)"

//----- (10079BA2) --------------------------------------------------------
#error "10079BB9: positive sp value has been found (funcsize=0)"

//----- (10079BBA) --------------------------------------------------------
#error "10079BCD: positive sp value has been found (funcsize=0)"

//----- (10079BCE) --------------------------------------------------------
#error "10079BED: positive sp value has been found (funcsize=0)"

//----- (10079BF3) --------------------------------------------------------
#error "10079C0C: positive sp value has been found (funcsize=0)"

//----- (10079C12) --------------------------------------------------------
#error "10079C31: positive sp value has been found (funcsize=0)"

//----- (10079C32) --------------------------------------------------------
#error "10079C45: positive sp value has been found (funcsize=0)"

//----- (10079C46) --------------------------------------------------------
#error "10079C5D: positive sp value has been found (funcsize=0)"

//----- (10079C5E) --------------------------------------------------------
#error "10079C71: positive sp value has been found (funcsize=0)"

//----- (10079C72) --------------------------------------------------------
#error "10079C91: positive sp value has been found (funcsize=0)"

//----- (10079C97) --------------------------------------------------------
#error "10079CB0: positive sp value has been found (funcsize=0)"

//----- (10079CB6) --------------------------------------------------------
#error "10079CD5: positive sp value has been found (funcsize=0)"

//----- (10079CD6) --------------------------------------------------------
#error "10079CE9: positive sp value has been found (funcsize=0)"

//----- (10079CEA) --------------------------------------------------------
#error "10079D01: positive sp value has been found (funcsize=0)"

//----- (10079D02) --------------------------------------------------------
#error "10079D15: positive sp value has been found (funcsize=0)"

//----- (1007B55F) --------------------------------------------------------
int __cdecl sub_1007B55F(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_1011F280;
  }
  else
  {
    v6 = &dword_102D3BA0[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_1011F280) : (v8 = &dword_102D3BA0[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_100812CC(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_100812CC(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_100812CC(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_100812CC(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_100812CC(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_1011F25C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_100812CC(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_100812CC(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_100812CC(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_100812CC(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 10074E35: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100757F4: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1007B524: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 1007B53A: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 1011F25C: using guessed type int (*off_1011F25C[3])();
// 102D3BA0: using guessed type int dword_102D3BA0[];
// 1007B55F: using guessed type char var_24[11];

//----- (1007C705) --------------------------------------------------------
int __cdecl sub_1007C705(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1007FB49((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10078D61: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007C7AB) --------------------------------------------------------
int __cdecl sub_1007C7AB(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1008008B((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10078D61: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007CC12) --------------------------------------------------------
DWORD __cdecl sub_1007CC12(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_1008228C(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_102D3BA0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 10072480: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (1007CDAE) --------------------------------------------------------
_WORD *__cdecl sub_1007CDAE(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_102D3BA0[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_102D3BA0[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_1007CC12(a1, 0, 0, 2u);
  if ( sub_1007D4F0(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 10072480: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10074E35: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10075A10: using guessed type int _getptd(void);
// 102D3BA0: using guessed type int dword_102D3BA0[];
// 1007CDAE: using guessed type CHAR var_410[688];

//----- (1007D3D0) --------------------------------------------------------
_WORD *__cdecl sub_1007D3D0(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_102D3BA0[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_1007CDAE(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_1008239D(a1);
  return v6;
}
// 10074E35: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100822FD: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (1007D4F0) --------------------------------------------------------
int __cdecl sub_1007D4F0(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_102D3BA0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 10074E35: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (1007D54E) --------------------------------------------------------
void **sub_1007D54E()
{
  return &off_1011FCE0;
}
// 1011FCE0: using guessed type void *off_1011FCE0;

//----- (1007D554) --------------------------------------------------------
signed int sub_1007D554()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_102D3B80;
  if ( !dword_102D3B80 )
  {
    v0 = 512;
LABEL_5:
    dword_102D3B80 = v0;
    goto LABEL_6;
  }
  if ( dword_102D3B80 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_102D2B6C = v1;
  if ( v1 || (dword_102D3B80 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_102D2B6C = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_1011FCE0;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&dword_1011FF60 )
        break;
      v1 = dword_102D2B6C;
    }
    v5 = 0;
    v6 = &unk_1011FCF0;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_102D3BA0[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_1011FD50 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10075E04: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 1011FCE0: using guessed type void *off_1011FCE0;
// 1011FF60: using guessed type int dword_1011FF60;
// 102D3B80: using guessed type int dword_102D3B80;
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (1007D945) --------------------------------------------------------
void sub_1007D945()
{
  dword_102D2B68 = 0;
}
// 102D2B68: using guessed type int dword_102D2B68;

//----- (1007D9FD) --------------------------------------------------------
int sub_1007D9FD()
{
  dword_102D3CB8 = _get_sse2_info();
  return 0;
}
// 1007D99D: using guessed type int _get_sse2_info(void);
// 102D3CB8: using guessed type int dword_102D3CB8;

//----- (1007DEF2) --------------------------------------------------------
int sub_1007DEF2()
{
  return _decode_pointer(dword_1026D810);
}
// 100757F4: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1026D810: using guessed type int dword_1026D810;

//----- (1007E0AF) --------------------------------------------------------
int __cdecl sub_1007E0AF(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1026D81C = a1;
  return result;
}
// 1026D81C: using guessed type int dword_1026D81C;

//----- (1007E0B9) --------------------------------------------------------
int __cdecl sub_1007E0B9(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1026D828 = a1;
  return result;
}
// 1026D828: using guessed type int dword_1026D828;

//----- (1007E0C3) --------------------------------------------------------
int __cdecl sub_1007E0C3(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1026D82C = a1;
  return result;
}
// 1026D82C: using guessed type int dword_1026D82C;

//----- (1007E1A2) --------------------------------------------------------
int __cdecl sub_1007E1A2(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1026D830 = a1;
  return result;
}
// 1026D830: using guessed type int dword_1026D830;

//----- (1007FB49) --------------------------------------------------------
signed int __cdecl sub_1007FB49(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_10120158 - 1;
    v64 = v3;
    v65 = dword_10120158 / 32;
    v9 = dword_10120158 % 32;
    v10 = (int *)(&v60 + dword_10120158 / 32);
    v66 = 31 - dword_10120158 % 32;
    if ( (1 << (31 - dword_10120158 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_10120154 - dword_10120158 )
    {
      if ( v3 > dword_10120154 )
      {
        if ( v3 < dword_10120150 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_10120164 + v3;
          v50 = dword_1012015C / 32;
          v51 = dword_1012015C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_1012015C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_1012015C / 32;
          v44 = dword_1012015C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_1012015C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_10120164 + dword_10120150;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_10120154 - v64) / 32;
      v62 = v59;
      v18 = (dword_10120154 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_10120158 - 1;
      v25 = dword_10120158 / 32;
      v65 = dword_10120158 / 32;
      v26 = (int *)(&v60 + dword_10120158 / 32);
      v64 = 31 - dword_10120158 % 32;
      if ( (1 << (31 - dword_10120158 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_10120158 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_1012015C + 1) / 32;
      v37 = (dword_1012015C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_1012015C));
  if ( dword_10120160 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_10120160 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 10120150: using guessed type int dword_10120150;
// 10120154: using guessed type int dword_10120154;
// 10120158: using guessed type int dword_10120158;
// 1012015C: using guessed type int dword_1012015C;
// 10120160: using guessed type int dword_10120160;
// 10120164: using guessed type int dword_10120164;

//----- (1008008B) --------------------------------------------------------
signed int __cdecl sub_1008008B(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_10120170 - 1;
    v64 = v3;
    v65 = dword_10120170 / 32;
    v9 = dword_10120170 % 32;
    v10 = (int *)(&v60 + dword_10120170 / 32);
    v66 = 31 - dword_10120170 % 32;
    if ( (1 << (31 - dword_10120170 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_1012016C - dword_10120170 )
    {
      if ( v3 > dword_1012016C )
      {
        if ( v3 < dword_10120168 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_1012017C + v3;
          v50 = dword_10120174 / 32;
          v51 = dword_10120174 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_10120174 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_10120174 / 32;
          v44 = dword_10120174 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_10120174 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_1012017C + dword_10120168;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_1012016C - v64) / 32;
      v62 = v59;
      v18 = (dword_1012016C - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_10120170 - 1;
      v25 = dword_10120170 / 32;
      v65 = dword_10120170 / 32;
      v26 = (int *)(&v60 + dword_10120170 / 32);
      v64 = 31 - dword_10120170 % 32;
      if ( (1 << (31 - dword_10120170 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_10120170 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_10120174 + 1) / 32;
      v37 = (dword_10120174 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_10120174));
  if ( dword_10120178 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_10120178 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 10120168: using guessed type int dword_10120168;
// 1012016C: using guessed type int dword_1012016C;
// 10120170: using guessed type int dword_10120170;
// 10120174: using guessed type int dword_10120174;
// 10120178: using guessed type int dword_10120178;
// 1012017C: using guessed type int dword_1012017C;

//----- (10080799) --------------------------------------------------------
int sub_10080799()
{
  return 0;
}

//----- (100811AC) --------------------------------------------------------
int __cdecl sub_100811AC(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_1011F280;
    }
    else
    {
      v7 = &dword_102D3BA0[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 10074E35: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1007D4AC: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (100812CC) --------------------------------------------------------
int __cdecl sub_100812CC(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_1011F280;
    }
    else
    {
      v2 = &dword_102D3BA0[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_1011F280) : (v4 = &dword_102D3BA0[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 10074E35: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1007D4AC: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (1008220B) --------------------------------------------------------
signed int __cdecl sub_1008220B(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_102D3BA0[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_1026CEAC == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 1026CEAC: using guessed type int dword_1026CEAC;
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (1008228C) --------------------------------------------------------
signed int __cdecl sub_1008228C(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_102D3BA0[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 10074E35: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (1008239D) --------------------------------------------------------
void __cdecl sub_1008239D(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_102D3BA0[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (1008269E) --------------------------------------------------------
int sub_1008269E()
{
  return flsall(1);
}
// 100825C4: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (100826A7) --------------------------------------------------------
int __cdecl sub_100826A7(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_1026D84C )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_1026D84C = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_1026D850 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_1026D854 = _encode_pointer(v7);
    if ( sub_100754BE(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_1026D85C = _encode_pointer(v8);
      if ( dword_1026D85C )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_1026D858 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_1026D858 == v23
    || dword_1026D85C == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_1026D858),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_1026D85C),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_1026D850 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_1026D850);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_1026D854 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_1026D854);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_100754F5(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_1026D84C);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 10074D39: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1007577D: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 100757EB: using guessed type int _encoded_null(void);
// 100757F4: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1026D84C: using guessed type int dword_1026D84C;
// 1026D850: using guessed type int dword_1026D850;
// 1026D854: using guessed type int dword_1026D854;
// 1026D858: using guessed type int dword_1026D858;
// 1026D85C: using guessed type int dword_1026D85C;

//----- (100834B1) --------------------------------------------------------
signed int __cdecl sub_100834B1(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_1008228C(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_102D3BA0[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_102D3BA0[0] + 68) & 1)
    && (v1 = sub_1008228C(2), sub_1008228C(1) == v1)
    || (v2 = (void *)sub_1008228C(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_1008220B(a1);
  *(_BYTE *)(dword_102D3BA0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10072480: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 102D3BA0: using guessed type int dword_102D3BA0[];

//----- (10083690) --------------------------------------------------------
int __cdecl sub_10083690(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10083A8E: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (100836E0) --------------------------------------------------------
int __cdecl sub_100836E0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10083A94: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10083750) --------------------------------------------------------
int __cdecl sub_10083750(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100405D0(v1);
  a1 = v2;
  v3 = sub_100430B0(&a1, 4u, (int)&unk_1011CC80, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1011CC84[2 * v3];
}
// 1011CC84: using guessed type int dword_1011CC84[];

//----- (10083790) --------------------------------------------------------
int __cdecl sub_10083790(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100405D0(v1);
  a1 = v2;
  v3 = sub_100430B0(&a1, 4u, (int)&unk_1011CCB8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1011CCBC[2 * v3];
}
// 1011CCBC: using guessed type int dword_1011CCBC[];

//----- (100837D0) --------------------------------------------------------
int __cdecl sub_100837D0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100405D0(v1);
  a1 = v2;
  v3 = sub_100430B0(&a1, 4u, (int)&unk_1011CCF0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1011CCF4[2 * v3];
}
// 1011CCF4: using guessed type int dword_1011CCF4[];

//----- (10083810) --------------------------------------------------------
int __cdecl sub_10083810(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_100405D0(v1);
  a1 = v2;
  v3 = sub_100430B0(&a1, 4u, (int)&unk_1011CD28, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1011CD2C[2 * v3];
}
// 1011CD2C: using guessed type int dword_1011CD2C[];

//----- (10083850) --------------------------------------------------------
int __cdecl sub_10083850(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_10083790(a4);
    result = sub_10016380(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_10016380(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_10083750(a4);
      result = sub_10016380(v6, a3, 6);
    }
  }
  return result;
}

//----- (100838C0) --------------------------------------------------------
int __cdecl sub_100838C0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_10083810(a3);
    result = sub_10016380(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10016220(100);
      v5 = sub_10083810(a3);
      result = sub_10016380(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_100837D0(a3);
    result = sub_10016380(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10016220(100);
      v7 = sub_100837D0(a3);
      result = sub_10016380(v7, a2, 8);
    }
  }
  return result;
}

//----- (10083960) --------------------------------------------------------
__int16 __cdecl sub_10083960(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10070E92: using guessed type int SYS_exit_krnl(void);
// 10070E98: using guessed type int SYS_enter_krnl(void);
// 10083AA6: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100839A0) --------------------------------------------------------
__int16 __cdecl sub_100839A0(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 10083990: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10083A00) --------------------------------------------------------
double __cdecl sub_10083A00(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (10083A30) --------------------------------------------------------
char sub_10083A30()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_100463F0() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_102D2B2C + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_102D2B2C + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_102D2B2C + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 102D2B2C: using guessed type int dword_102D2B2C;

#error "There were 52 decompilation failure(s) on 1636 function(s)"
