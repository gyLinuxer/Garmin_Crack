/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __cdecl sub_10001000(int a1);
bool __cdecl sub_100010B0(int a1, int a2);
// int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>);
char __cdecl sub_10001180(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
char __cdecl sub_100012C0(int a1, int a2);
int sub_100014A0(void); // weak
unsigned int sub_100014B0();
int __cdecl sub_10001580(int a1);
int __cdecl sub_100015B0(int a1, int a2);
int __cdecl sub_100015D0(int a1, char *a2, int a3, int a4);
char __cdecl sub_10001660(int a1, int a2, int a3);
char __cdecl sub_100016D0(int a1, int a2, int a3);
int sub_10001740();
_DWORD *__cdecl sub_10001760(int a1);
unsigned int __cdecl sub_10001780(int a1, int a2, int a3);
// void __usercall sub_100017F0(int a1@<esi>);
// char __usercall sub_10001820@<al>(int a1@<esi>);
// void __usercall sub_10001900(int a1@<esi>, int a2);
// void __usercall sub_100019D0(int a1@<esi>, int a2);
// int __usercall sub_10001A70@<eax>(int a1@<edi>, int a2);
char __thiscall sub_10001C40(int this);
signed int __cdecl sub_10001C60(int a1, int a2);
char __cdecl sub_10001DB0(int a1, int a2, __int16 a3);
char __cdecl sub_10001DE0(int a1, int a2, __int16 a3);
char __cdecl sub_10001E10(int a1);
// int __usercall sub_10002140@<eax>(int a1@<eax>);
void __noreturn sub_100021D0();
int __cdecl sub_10002400(int a1, int a2);
char __cdecl sub_10002420(int a1, unsigned int a2);
char sub_10002460();
char __thiscall sub_10002480(int this);
int __cdecl sub_100025F0(int a1);
char __cdecl sub_10002740(int a1);
int __cdecl sub_10002760(int a1, int a2);
int __cdecl sub_100027E0(int a1, __int16 a2, __int16 a3);
// int __usercall sub_10002870@<eax>(int a1@<eax>);
// char __usercall sub_10002CE0@<al>(int a1@<edi>);
// int __usercall sub_10002D60@<eax>(int a1@<eax>, char a2@<cl>);
char __cdecl sub_10002DF0(int a1, char a2);
// char __usercall sub_10003480@<al>(int a1@<eax>);
// char __usercall sub_10003860@<al>(int a1@<eax>, int a2@<ecx>);
char __cdecl sub_10003BD0(int a1);
// char __usercall sub_10004010@<al>(int a1@<edi>);
// char __usercall sub_10004120@<al>(int a1@<ebx>);
char __cdecl sub_10004550(int a1);
int __thiscall sub_10004660(void *this, void *a2, int a3);
int sub_10004690(void); // weak
char __cdecl sub_100046A0(char a1);
char sub_100046C0();
char sub_100046D0();
_WORD *__cdecl sub_100046E0(int a1);
char __cdecl sub_10004750(int a1);
char __cdecl sub_100047C0(int a1);
int sub_10004830(void); // weak
_DWORD sub_10004840(); // weak
int __cdecl sub_100048C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_10004910(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int sub_10004960();
int __cdecl j_gdi_pvg_load_identity(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_active(_DWORD); // weak
int __cdecl j_gdi_pvg_make_window_current(_DWORD); // weak
int __cdecl j_gdi_pvg_matrix_mode(_DWORD); // weak
int __cdecl sub_100049B0(float, float, float, float, float, float); // idb
int j_gdi_pvg_update_display_wdw(void); // weak
int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD); // weak
char *__cdecl sub_10004A10(int a1, char *a2, int a3, char *a4, int a5);
char sub_10004B40();
char __cdecl sub_10004B50(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10004C50(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10004CC0(int a1, int a2, int a3);
int __cdecl j_gdi_pvg_destroy_window(_DWORD); // weak
int sub_10004D00();
int __cdecl sub_10004D50(int a1);
int __cdecl sub_10004D60(int a1);
int sub_10004D80();
int __cdecl sub_10004DA0(int a1, int a2);
__int16 __cdecl sub_10004DD0(int a1);
int sub_10004DF0();
int __cdecl sub_10004E10(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_10004E50(int a1, int a2, int a3, int a4);
int __cdecl sub_10004E80(int a1);
int __cdecl sub_10004EA0(int a1);
int __cdecl sub_10004EC0(int a1, int a2);
int __cdecl sub_10004EF0(int a1, int a2);
int __cdecl sub_10004F20(int a1);
int __cdecl sub_10004F40(int a1);
char __cdecl sub_10004F60(int a1, int a2);
int __cdecl sub_10004FD0(_BYTE *a1);
int __cdecl sub_10005010(int a1, int a2);
int __cdecl sub_10005040(int a1, int a2);
int __cdecl nullsub_1(_DWORD, _DWORD);
int __cdecl sub_10005070(int a1, int a2, int a3);
char __cdecl sub_10005090(int a1, int a2, int a3);
int __cdecl sub_100050D0(int, void *, int, void *); // idb
int __cdecl sub_10005110(int a1, int a2, int a3);
int __cdecl sub_10005140(int a1, int a2, int a3);
char __cdecl sub_10005160(int a1, int a2, int a3);
int __cdecl sub_100051A0(int, void *, int, void *); // idb
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10005200(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_10005260(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_100052D0(unsigned int a1, void *a2, int a3);
signed int __cdecl sub_10005310(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
signed int __cdecl sub_100053A0(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_100053F0(int a1);
int __cdecl sub_10005410(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10005440(int a1, int a2, int a3, char a4);
char __cdecl sub_10005460(int a1);
signed int __cdecl sub_10005490(unsigned int a1, int a2, int a3);
int __cdecl sub_100054B0(int a1, int a2, int a3);
void __cdecl sub_100054D0(int a1, _BYTE *a2);
int sub_10005500(void); // weak
int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD); // weak
int j_HWM_pvg_hsdb_get_lrus_online(void); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
unsigned int __cdecl sub_10005550(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10005700@<eax>(int a1@<esi>);
int __cdecl sub_100057B0(int a1, unsigned __int64 a2);
// int __usercall sub_10005860@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_100058F0(int a1, void *a2, int a3, int a4, int a5);
void __cdecl sub_10005A40(__int16 a1, _BYTE *a2);
double __cdecl sub_10005A70(char a1);
signed int sub_10005B00();
char sub_10005B20();
char __cdecl sub_10005B40(char a1);
char __cdecl sub_10005BB0(unsigned __int8 a1);
char __cdecl sub_10005CB0(char a1, char a2, float *a3);
char __cdecl sub_10005DF0(char a1, float *a2);
bool __cdecl sub_10005F40(void *a1);
char __cdecl sub_10005F90(int a1);
char sub_100061E0();
void __cdecl sub_10006230(float *a1, float *a2, int a3);
double __cdecl sub_100062F0(int a1, int a2);
int __cdecl sub_10006310(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
unsigned int __cdecl sub_10006420(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
int __cdecl sub_10006500(int a1);
int __cdecl sub_10006850(int a1);
unsigned int __cdecl sub_10006A30(int a1);
int __cdecl sub_10006F60(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8);
_WORD *__cdecl sub_10006FC0(int a1);
int __cdecl sub_10007020(int a1, int a2, char a3);
void sub_10007110();
int __cdecl sub_10007120(int a1, _BYTE *a2, int a3);
char __cdecl sub_10007160(char a1, char a2);
int __cdecl sub_10007180(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7);
bool __cdecl sub_100079C0(_BYTE *a1);
bool __cdecl sub_10007A60(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_10007B70(int a1, _BYTE *a2, int a3);
int __cdecl sub_10007C60(int a1);
int __cdecl sub_10007E30(int a1, signed int a2, signed int a3);
int __cdecl sub_10008300(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
int __cdecl sub_100083F0(int a1, __int16 a2, __int16 a3, char a4);
char __cdecl sub_10008940(int a1);
char __cdecl sub_100089F0(int a1);
int __cdecl sub_10008B60(int a1);
char *__cdecl sub_10008BC0(int a1);
unsigned int __cdecl sub_10008D10(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10008DD0(int a1, int a2);
unsigned int __cdecl sub_10008EF0(int a1, int a2);
int __cdecl sub_10009090(int a1, int a2, int a3);
int __cdecl sub_10009110(int a1, int a2, int a3);
int __cdecl sub_10009180(int a1, int a2, int a3);
char __cdecl sub_10009200(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10009310(int a1, signed int a2, signed int a3);
int __cdecl sub_10009400(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10009500(int a1, int a2);
char *__cdecl sub_10009630(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_10009770(int a1, signed int a2, int a3, int *a4);
int __cdecl sub_100099C0(int a1, signed int a2, int a3);
int __cdecl sub_10009B00(int a1, signed int a2, int a3);
char sub_10009C40();
char __cdecl sub_10009C60(_WORD *a1);
char __cdecl sub_10009CD0(float *a1);
char __cdecl sub_10009D00(float *a1, float *a2, _BYTE *a3);
void __cdecl sub_10009D80(int a1, int a2, int a3, float *a4, int a5);
int __cdecl sub_10009EB0(int, float, float, int, int); // idb
char sub_10009F20();
void *__cdecl sub_10009F40(void *a1);
bool __cdecl sub_10009F60(char a1);
bool __cdecl sub_10009F70(char a1);
signed int __cdecl sub_10009F80(unsigned __int8 a1, unsigned __int8 a2);
signed int __cdecl sub_10009FE0(char a1, unsigned __int8 a2);
int __cdecl sub_1000A020(char, float); // idb
int __cdecl sub_1000A0C0(unsigned __int8 a1);
char __cdecl sub_1000A0E0(float a1, int a2, int a3);
double __cdecl sub_1000A340(float a1, float a2);
void __cdecl sub_1000A360(int a1, int a2, int a3, int a4, int a5, float a6);
// void __usercall sub_1000A3D0(int a1@<ebx>, int a2@<edi>, float a3, float a4);
// void __usercall sub_1000A6C0(int a1@<esi>);
void __cdecl sub_1000A730(int a1, float a2, float a3, int a4);
void __cdecl sub_1000A940(int a1, float a2, float a3, int a4);
int __cdecl sub_1000A9F0(int, float, float, int, int, float); // idb
char __cdecl sub_1000AA80(int a1, float a2, int a3, float a4, char a5, int a6);
char __cdecl sub_1000ACE0(int a1, float a2, int a3, float a4, int a5);
int __cdecl sub_1000AD90(int a1);
char __cdecl sub_1000AF90(void *a1);
int __cdecl sub_1000AFE0(unsigned int a1, char a2);
char __cdecl sub_1000B040(signed __int16 *a1, _BYTE *a2);
// __int16 __usercall sub_1000B0B0@<ax>(int a1@<eax>, int a2@<esi>, unsigned int a3);
// char *__usercall sub_1000B110@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4);
// int __usercall sub_1000B1D0@<eax>(unsigned int a1@<eax>, char a2@<cl>);
// char __usercall sub_1000B240@<al>(int *a1@<ebx>, int a2@<edi>, _DWORD *a3);
// char __usercall sub_1000B2B0@<al>(signed int *a1@<ecx>, int a2@<ebx>, int a3, int a4);
char __cdecl sub_1000B4A0(signed __int16 *a1, _BYTE *a2);
// char __usercall sub_1000B520@<al>(int a1@<eax>, int a2@<ecx>, signed int *a3, int a4);
// char __usercall sub_1000BD10@<al>(char *a1@<eax>, signed int *a2@<edx>, int a3, _BYTE *a4);
// char __usercall sub_1000C210@<al>(signed int *a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>);
char __cdecl sub_1000C2D0(int a1, int a2, int *a3, signed int *a4, int a5);
// char *__usercall sub_1000CDD0@<eax>(int a1@<eax>, void *a2@<ecx>, int a3);
// char __usercall sub_1000CE50@<al>(unsigned __int8 a1@<al>, int a2@<ecx>, char a3);
// int __usercall sub_1000CEB0@<eax>(__int16 a1@<ax>, signed __int16 a2@<dx>, _DWORD *a3@<ecx>, _DWORD *a4);
// int __usercall sub_1000CEE0@<eax>(unsigned int a1@<eax>, int a2@<ecx>, int a3, char a4);
// char __usercall sub_1000D020@<al>(int a1@<ecx>, _WORD *a2@<ebx>, int a3@<edi>, int a4, int a5);
// char __usercall sub_1000F1F0@<al>(int a1@<edi>, int a2, int a3, int a4, int a5, _WORD *a6);
// char __usercall sub_1000F240@<al>(char a1@<bl>);
// char __usercall sub_1000F270@<al>(int a1@<eax>);
// int __usercall sub_1000F2B0@<eax>(_DWORD *a1@<esi>, float a2);
char __cdecl sub_1000F2D0(char a1, const void **a2);
unsigned int sub_1000F360();
// char __usercall sub_1000F390@<al>(int a1@<eax>, int a2@<ecx>, char *a3@<edi>);
// char __usercall sub_1000F760@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<esi>, int a4);
bool __cdecl sub_1000F840(int a1, int a2);
// char __usercall sub_1000F880@<al>(_WORD *a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4, int a5);
char __cdecl sub_1000F8F0(int a1, int a2, int *a3, int a4, _WORD *a5);
char __cdecl sub_1000FA20(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_1000FB70(int a1, int a2);
char __cdecl sub_1000FB80(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
// char __usercall sub_1000FDD0@<al>(unsigned __int16 *a1@<eax>, int a2@<ebx>, int a3@<edi>, unsigned int a4@<esi>, int a5);
char __cdecl sub_1000FE60(int a1, int a2, int *a3, int a4, _WORD *a5);
// int __usercall sub_10010000@<eax>(int a1@<eax>, int a2@<ecx>);
// char *__usercall sub_10010040@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
int __fastcall sub_100101B0(int a1, int a2);
// char __usercall sub_10010200@<al>(int a1@<eax>, int a2@<ecx>);
// char __usercall sub_10010260@<al>(int a1@<esi>, int a2, int a3);
char __thiscall sub_100103F0(int this);
// int __usercall sub_10010410@<eax>(int a1@<ecx>, int *a2@<ebx>, int a3@<edi>, int *a4@<esi>, _BYTE *a5, char a6);
// int __usercall sub_10010480@<eax>(_WORD *a1@<edx>, int a2@<ecx>, int a3, char a4, char *a5, int a6, int a7, int a8);
// char __usercall sub_100108B0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4);
char __cdecl sub_10010930(int a1, int a2, _WORD *a3, int *a4, int a5);
char __cdecl sub_100113A0(char a1);
char __cdecl sub_10011400(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
char __cdecl sub_10011680(int a1, _BYTE *a2);
char __cdecl sub_10011D50(int a1, float *a2);
double sub_10011E70();
char __cdecl sub_10011F10(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
void *__cdecl sub_10012040(int a1, __int16 a2);
char __cdecl sub_10012070(int a1, int a2, char *a3);
int __cdecl sub_100120D0(int a1, int a2, int a3, signed int a4, int a5);
// char __usercall sub_10012220@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>);
// char __usercall sub_100122E0@<al>(unsigned __int16 a1@<di>, int a2);
// signed int __usercall sub_10012340@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3);
signed int __cdecl sub_100124A0(int a1, int a2, signed int a3);
char __cdecl sub_10012500(int a1, int a2, int a3, char *a4);
char __cdecl sub_10012760(int a1, int a2, int a3, char *a4);
char __cdecl sub_10012950(int a1, int a2, int a3, char *a4, int a5);
char __cdecl sub_10012BB0(int a1, int a2, int a3, int a4, _WORD *a5);
char __cdecl sub_10012DE0(int a1, int a2, int a3, _BYTE *a4, _WORD *a5);
int __cdecl sub_10012EC0(unsigned int a1, char a2, int a3, int a4);
char __cdecl sub_10012F20(int a1, int a2, int a3, double *a4);
// char __usercall sub_10013420@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4);
// char __usercall sub_10013500@<al>(int a1@<eax>, int a2, int a3, int a4);
// char __usercall sub_10013FD0@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5);
// char __usercall sub_10014090@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4);
char __cdecl sub_100140D0(int a1, int a2, int *a3, float *a4, int a5);
char __cdecl sub_100149C0(int a1, int a2, int *a3, int a4, int a5);
// int __usercall sub_10014A30@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3);
char __cdecl sub_10014B10(int a1, int a2, int a3, int a4, _WORD *a5);
// unsigned int __usercall sub_100150C0@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3);
char __cdecl sub_10015170(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5);
bool __cdecl sub_10015210(int a1, _WORD *a2, char *a3, int a4, int a5, int a6);
int __cdecl sub_10015310(unsigned int a1);
char *__cdecl sub_10015340(unsigned int a1);
int __cdecl sub_10015360(unsigned int a1);
signed int __cdecl sub_10015380(__int16 a1);
signed int __cdecl sub_100153B0(int a1);
// int __usercall sub_100153E0@<eax>(_BYTE *a1@<eax>);
// char __usercall sub_10015410@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3);
// char __usercall sub_10015460@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7);
__int16 __cdecl sub_10015960(_BYTE *a1, unsigned int a2);
int __cdecl sub_100159C0(unsigned int a1, unsigned int a2, float *a3);
int sub_100159F0();
char __cdecl sub_10015A90(int a1, const char *a2, int *a3);
int __cdecl sub_10015AD0(unsigned int a1, char a2);
char __cdecl sub_10015B30(int a1, const char *a2, int *a3, int a4);
int __cdecl sub_10015D40(int a1, int a2, unsigned int a3, int a4);
__int16 __cdecl sub_10015E10(char *a1, int a2, int a3, int a4, int a5);
char __cdecl sub_10015EA0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7);
char __cdecl sub_100160C0(char a1);
void __cdecl sub_100161A0(int a1);
bool __cdecl sub_10016430(float *a1, _BYTE *a2, _BYTE *a3, float *a4, bool *a5, _DWORD *a6, _DWORD *a7);
void __cdecl sub_100164B0(unsigned int a1, int a2);
double *__cdecl sub_10016600(char a1, char a2, double *a3);
void __cdecl sub_10016730(unsigned int a1, char *a2);
signed int __cdecl sub_10016790(int a1);
double __cdecl sub_100167E0(int a1, float a2);
int __cdecl sub_10016840(char a1, char a2, _DWORD *a3, unsigned __int16 *a4, float *a5, float *a6, _BYTE *a7, _BYTE *a8, _BYTE *a9);
bool __cdecl sub_10016950(int a1);
char __cdecl sub_10016B40(_DWORD *a1, unsigned __int8 a2, _BYTE *a3);
int __cdecl sub_10016B80(unsigned __int16 a1, int a2);
int __cdecl sub_10016C10(int *a1);
char __cdecl sub_10016C60(int a1, int a2, void *a3);
char __cdecl sub_100173C0(int a1, _BYTE *a2);
int __cdecl sub_100173F0(int a1, char a2, int a3);
signed int __cdecl sub_10017430(unsigned int a1, int a2);
// void __usercall sub_100175C0(int a1@<esi>, int a2, unsigned int a3, _BYTE *a4);
int __cdecl sub_10017B80(__int16 a1, unsigned __int16 a2);
signed int __cdecl sub_10017BA0(int a1);
signed int __cdecl sub_10017D00(int a1);
char __cdecl sub_10017DF0(_DWORD *a1);
// char __usercall sub_10017E40@<al>(signed int *a1@<edi>, signed int a2, signed int a3, unsigned __int8 a4, _BYTE *a5);
signed int __cdecl sub_100180E0(int a1, unsigned __int8 a2, _BYTE *a3);
void __cdecl sub_10018280(unsigned int a1, unsigned __int8 a2, int a3);
char __cdecl sub_10018330(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_10018380(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_100183D0(int a1, int a2);
signed int __cdecl sub_10018440(unsigned __int8 a1);
int __cdecl sub_100184C0(int, char, void *); // idb
signed int __cdecl sub_10018540(unsigned __int8 a1);
char __cdecl sub_100185A0(int a1);
char __cdecl sub_100185E0(int a1);
int __cdecl sub_10018610(int a1, int a2, _BYTE *a3, _BYTE *a4, int a5, int a6, float *a7);
// int __usercall sub_10018710@<eax>(float *a1@<esi>, float a2, float a3, float a4, float a5, int a6);
// double __usercall sub_100187B0@<st0>(int a1@<eax>, int a2@<ecx>, int a3@<esi>, unsigned int a4);
char __cdecl sub_100188B0(unsigned __int8 a1);
char __cdecl sub_100188F0(unsigned __int8 a1);
// char __usercall sub_10018930@<al>(int a1@<edi>, char a2, int a3, char a4, float a5, int a6);
char __cdecl sub_10018B10(int a1, char a2, char *a3);
int __cdecl sub_10018DF0(unsigned __int8 a1, int a2, _BYTE *a3, _BYTE *a4, int a5, int a6, float *a7);
void __cdecl sub_10018E40(int a1, unsigned __int8 a2, float *a3, float *a4);
signed int __cdecl sub_10019240(unsigned __int8 a1);
char __cdecl sub_10019280(unsigned __int8 a1);
signed int __cdecl sub_100192C0(unsigned __int8 a1, unsigned __int8 a2);
signed int __cdecl sub_10019320(unsigned __int8 a1);
char __cdecl sub_10019360(int a1);
char __cdecl sub_100193A0(int a1);
char __cdecl sub_100193E0(int a1);
char __cdecl sub_10019420(int a1);
char __cdecl sub_10019460(int a1);
char __cdecl sub_100194A0(unsigned __int8 a1);
char __cdecl sub_100194E0(unsigned __int8 a1);
char __cdecl sub_10019520(unsigned __int8 a1);
char __cdecl sub_10019560(unsigned __int8 a1);
char __cdecl sub_100195A0(unsigned __int8 a1);
char __cdecl sub_100195E0(unsigned __int8 a1, int a2, char a3, int a4);
// char __usercall sub_10019660@<al>(int a1@<eax>, unsigned __int8 a2);
// char __usercall sub_10019700@<al>(char a1@<al>);
int __fastcall sub_10019730(int a1, int a2);
void __cdecl sub_10019760(unsigned int a1, int a2);
char __cdecl sub_100198A0(unsigned int a1, int a2);
int __cdecl sub_10019950(char a1, int a2);
// void __usercall sub_10019980(int a1@<ecx>, int a2@<esi>);
char __cdecl sub_100199B0(unsigned int a1, int a2);
char __cdecl sub_10019AD0(unsigned int a1, unsigned int *a2, _BYTE *a3, _BYTE *a4);
int __cdecl sub_10019B00(int a1);
// signed int __usercall sub_10019B40@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
signed int __thiscall sub_10019B80(int this);
// signed int __usercall sub_10019C30@<eax>(int a1@<edi>);
signed int __thiscall sub_10019CC0(int this);
// char __usercall sub_10019D60@<al>(int a1@<eax>, char a2);
// int __usercall sub_10019DB0@<eax>(int a1@<esi>);
// char __usercall sub_10019DD0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6);
// void *__usercall sub_10019E90@<eax>(int a1@<eax>, char *a2@<esi>);
// int __usercall sub_10019EF0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>);
// __int16 __usercall sub_10019F90@<ax>(int a1@<eax>, int a2@<esi>, int a3);
char __cdecl sub_1001A100(unsigned int a1, int a2);
void *__cdecl sub_1001A380(unsigned int a1, char *a2);
signed int __cdecl sub_1001A3D0(unsigned __int8 a1);
// signed int __usercall sub_1001A450@<eax>(int a1@<edi>, unsigned __int8 a2);
signed int __cdecl sub_1001A4C0(unsigned __int8 a1);
// int __usercall sub_1001A530@<eax>(int a1@<eax>, char a2);
// void __usercall sub_1001A5C0(int a1@<edi>, int a2, int a3);
signed int __cdecl sub_1001A600(unsigned int a1, char a2, char a3);
__int16 __cdecl sub_1001A680(unsigned int a1, char a2, int a3);
char __cdecl sub_1001AB60(unsigned int a1);
int __cdecl sub_1001ABD0(__int64 a1);
double __cdecl sub_1001AC80(unsigned int a1);
double __cdecl sub_1001AD00(unsigned int a1);
double __cdecl sub_1001AD80(int a1);
int __cdecl sub_1001ADF0(int a1, int a2);
char __cdecl sub_1001AF80(int a1, int a2);
__int16 __cdecl sub_1001AFF0(int a1, int a2);
signed int sub_1001B030();
double sub_1001B0B0(void); // weak
int __cdecl sub_1001B0C0(unsigned __int16 a1, char a2, int a3);
int sub_1001B190();
void sub_1001B1F0();
signed int sub_1001B200();
bool sub_1001B220();
_DWORD __cdecl sub_1001B240(_DWORD, _DWORD); // weak
char __cdecl sub_1001B250(__int64 a1);
double __cdecl sub_1001B280(float a1);
void __cdecl sub_1001B340(_BYTE *a1, signed int a2, int a3);
int __cdecl sub_1001B3E0(int a1, int a2, int a3, _BYTE *a4);
unsigned int __cdecl sub_1001B460(unsigned int a1, _BYTE *a2, _BYTE *a3);
unsigned int __cdecl sub_1001B480(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_1001B4F0(int, int, int, int, int, char, char *); // idb
char __cdecl sub_1001BA80(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4);
// char __usercall sub_1001BAB0@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6);
// char __usercall sub_1001BB50@<al>(int a1@<ebx>, _BYTE *a2, int *a3);
unsigned __int8 __cdecl sub_1001BDA0(unsigned int a1);
int __cdecl sub_1001BDD0(unsigned int a1, unsigned __int8 a2, char a3);
int __cdecl sub_1001BE50(unsigned int a1);
char __cdecl sub_1001BE80(__int64 a1);
double __cdecl sub_1001BF20(unsigned int a1);
// char __usercall sub_1001BF90@<al>(unsigned __int16 a1@<ax>, void *a2);
// int __usercall sub_1001BFF0@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_1001C010(unsigned __int16 a1, int a2);
int __cdecl sub_1001C0A0(unsigned __int16 a1, int a2);
char *__cdecl sub_1001C110(unsigned __int8 a1);
signed int sub_1001C1D0();
int sub_1001C1F0();
int sub_1001C250();
char *sub_1001C2C0();
int __cdecl sub_1001C390(const void *a1);
double __cdecl sub_1001C440(unsigned int a1);
int __cdecl sub_1001C4F0(unsigned __int8 a1);
int sub_1001C530();
char __cdecl sub_1001C5D0(float *a1);
char __cdecl sub_1001C890(int a1, float *a2);
void __cdecl sub_1001C8B0(unsigned int a1, int a2);
char __cdecl sub_1001CA90(unsigned int a1, int a2);
int __cdecl sub_1001CB00(_BYTE *a1, _BYTE *a2);
int sub_1001CB30();
int __fastcall sub_1001CB40(unsigned __int8 a1);
int __fastcall sub_1001CB60(unsigned __int8 a1);
void *__cdecl sub_1001CB80(char a1, void *a2);
int __cdecl sub_1001CC50(int a1);
char sub_1001CE10();
_DWORD *__cdecl sub_1001CF70(_DWORD *a1);
int __cdecl sub_1001CF80(int *a1, int a2);
_DWORD *__cdecl sub_1001CFB0(_DWORD *a1, int a2);
char __cdecl sub_1001CFC0(int a1, int a2, int a3);
char __cdecl sub_1001CFF0(int a1, _WORD *a2, int a3);
__int16 __cdecl sub_1001D020(unsigned int a1);
bool __cdecl sub_1001D040(char *a1, int *a2, _DWORD *a3);
char __cdecl sub_1001D090(int a1, char *a2, int a3);
int __cdecl sub_1001D140(int a1);
double sub_1001D1C0(void); // weak
char __thiscall sub_1001D1E0(void *this);
char __thiscall sub_1001D210(void *this);
char __thiscall sub_1001D250(void *this);
char __fastcall sub_1001D280(int a1);
char __thiscall sub_1001D2F0(void *this);
char __fastcall sub_1001D320(int a1);
char sub_1001D370();
char __thiscall sub_1001D380(void *this);
char __thiscall sub_1001D3B0(void *this);
char __fastcall sub_1001D3E0(int a1);
char __thiscall sub_1001D430(void *this);
char __thiscall sub_1001D460(void *this);
int sub_1001D490();
char __thiscall sub_1001D4C0(void *this);
char __fastcall sub_1001D4F0(int a1);
char __cdecl sub_1001D540(int a1);
int __cdecl sub_1001D560(int, char *); // idb
int __cdecl sub_1001D5C0(char *a1, char *a2);
char __thiscall sub_1001D5E0(void *this);
int __thiscall sub_1001D600(void *this);
char __thiscall sub_1001D620(void *this);
char __thiscall sub_1001D640(void *this);
char sub_1001D660();
int __cdecl sub_1001D680(char a1);
char __cdecl sub_1001D690(char a1);
char __cdecl sub_1001D6D0(char a1);
signed int __cdecl sub_1001D740(char a1);
char __cdecl sub_1001D7C0(char a1);
char __cdecl sub_1001D830(char a1);
char __cdecl sub_1001D8E0(int a1);
char __thiscall sub_1001D9E0(void *this);
int __cdecl sub_1001D9F0(int *a1);
// char __usercall sub_1001DA20@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_1001DAC0(const char *a1);
char __cdecl sub_1001DB00(void *a1);
signed int __cdecl sub_1001DB50(unsigned int a1, int a2);
char **sub_1001DEF0();
int __cdecl j_nullsub_1(_DWORD); // weak
int __cdecl sub_1001DF10(int a1);
int __cdecl sub_1001DF20(int a1);
int sub_1001DF30(void); // weak
char __cdecl sub_1001DF60(char a1, unsigned __int16 a2, char a3);
bool __cdecl sub_1001DF90(float a1, int a2, int a3, int a4);
bool __cdecl sub_1001E100(signed int a1, signed int a2, _BYTE *a3);
void __cdecl sub_1001E170(const char *a1, unsigned int a2, int a3);
void __cdecl sub_1001E1C0(const char *a1, char a2, char a3);
int __cdecl sub_1001E210(int a1, _BYTE *a2, int a3);
int __cdecl sub_1001E260(void *, size_t); // idb
int __cdecl sub_1001E290(int, char *, int); // idb
int __cdecl sub_1001E2F0(char *, size_t, char *, va_list); // idb
int sub_1001E330(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_1001E360(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_1001E3A0(int a1, int a2);
int __cdecl sub_1001E3C0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1001E550(_DWORD *a1, unsigned int a2, int a3, int a4, int a5);
signed int sub_1001E670();
char __thiscall sub_1001E6B0(void *this);
char __cdecl sub_1001E6D0(char a1);
char sub_1001E720();
char __thiscall sub_1001E750(void *this);
char __thiscall sub_1001E770(void *this);
char sub_1001E7B0();
char sub_1001E7E0();
double __cdecl sub_1001E820(char a1);
int __cdecl sub_1001E8A0(unsigned __int8 a1);
// bool __usercall sub_1001E8C0@<al>(int a1@<esi>);
// bool __usercall sub_1001E930@<al>(int a1@<eax>);
char __cdecl sub_1001E9A0(char *a1);
char __cdecl sub_1001EB20(void *a1);
double sub_1001EBF0(void); // weak
char __fastcall sub_1001EC00(int a1);
int __cdecl sub_1001EC40(char a1);
signed int sub_1001EC60();
// signed int __usercall sub_1001ECB0@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_1001ED50@<eax>(char a1@<al>);
// int __usercall sub_1001ED70@<eax>(char a1@<al>);
// signed __int16 __usercall sub_1001ED90@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_1001EFD0(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_1001F130(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_1001F2B0(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_1001F410(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_1001F550(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_1001F630(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_1001F8B0(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_1001F8E0(char a1, int a2, void *a3);
char __cdecl sub_1001F910(char a1, int a2, void *a3, int a4);
char __cdecl sub_1001F940(unsigned __int8 a1, _BYTE *a2);
bool __cdecl sub_1001F990(int a1, void *a2, int a3);
char __cdecl sub_1001FA10(unsigned __int16 a1);
bool __cdecl sub_1001FA80(int a1, void *a2);
signed int __cdecl sub_1001FAB0(unsigned __int8 a1);
char __thiscall sub_1001FBE0(void *this);
char __cdecl sub_1001FC70(int a1, char a2);
char __cdecl sub_1001FD30(int a1, char a2);
char __cdecl sub_1001FDF0(char a1, char a2);
char __cdecl sub_1001FE40(char a1);
char __cdecl sub_1001FE70(char a1);
char __cdecl sub_1001FEA0(char a1);
char __cdecl sub_1001FEE0(char a1, _BYTE *a2);
char __thiscall sub_1001FF30(void *this);
int __thiscall sub_1001FF60(void *this);
int __cdecl sub_1001FF80(unsigned __int16 a1);
char *__cdecl sub_1001FFA0(unsigned __int16 a1);
signed int __cdecl sub_1001FFE0(int a1);
double __cdecl sub_10020000(signed int a1, char a2);
bool __cdecl sub_10020040(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_10020080(unsigned __int16 a1);
int __cdecl sub_100200B0(char *, char *); // idb
double sub_100200F0();
// char __usercall sub_10020120@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3);
char __cdecl sub_10020210(float *a1);
char __cdecl sub_10020230(float *a1);
char __cdecl sub_10020250(float *a1);
double sub_100202E0();
int __cdecl sub_10020340(double, double); // idb
void sub_10020390();
signed int sub_100203A0();
signed int sub_100203B0();
bool __cdecl sub_100203E0(char a1, int a2);
char sub_10020600();
bool __cdecl sub_10020670(float *a1);
bool __cdecl sub_10020720(float *a1);
_DWORD sub_10020780(); // weak
int sub_10020790();
BOOL __cdecl sub_100207B0(unsigned int a1);
char __thiscall sub_10020820(void *this);
void __cdecl sub_10020840(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_10020870(int a1);
signed int sub_10020890();
void __cdecl sub_100208C0(_BYTE *a1);
char __cdecl sub_100208E0(int a1, size_t a2, void *a3);
int __cdecl sub_10020920(int a1);
char __fastcall sub_10020940(int *a1);
char sub_10020B60();
void sub_10020B80();
signed int sub_10020B90();
int sub_10020BA0();
char sub_10020BD0();
void sub_10020C70();
char __cdecl sub_10020C80(unsigned __int8 a1);
signed int sub_10020CE0();
// char __usercall sub_10020CF0@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_10020DD0(int a1, char a2, void *a3);
char __cdecl sub_10020E50(int a1, void *a2);
int __cdecl sub_10020E70(int a1, int a2);
signed int sub_10020E90();
int sub_10020EB0();
char __cdecl sub_10020EC0(char *a1);
signed int __cdecl sub_10020F30(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10020F90(unsigned int a1, int a2, int a3);
int __cdecl sub_10020FB0(_BYTE *a1);
int __cdecl sub_10020FD0(unsigned __int8 *a1, int a2);
_DWORD __cdecl sub_10021000(_DWORD); // weak
bool sub_10021010();
bool sub_10021020();
bool __cdecl sub_10021040(char a1);
char *__cdecl sub_10021070(unsigned __int8 a1);
char *__cdecl sub_10021080(unsigned int a1, float *a2);
int __cdecl sub_100210B0(int a1, unsigned int a2);
__int16 __cdecl sub_100211A0(int a1, unsigned int a2);
int __cdecl sub_100211F0(int *a1, unsigned int a2);
__int16 __cdecl sub_10021220(unsigned int *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_100212A0(int *a1, int a2);
char __cdecl sub_100212C0(const void *a1);
int __cdecl sub_10021330(unsigned __int8 a1);
char __cdecl sub_100213C0(char a1);
char __cdecl sub_100213F0(char a1);
char __cdecl sub_10021410(unsigned int a1, float *a2);
double __cdecl sub_10021830(int a1, unsigned int a2);
double __cdecl sub_10021E60(int a1, unsigned int a2);
void __cdecl sub_10022550(int a1, float a2);
void __cdecl sub_10022580(int a1, float a2);
bool __cdecl sub_100225B0(float *a1);
int sub_10022650();
char __cdecl sub_10022680(void *a1);
char __cdecl sub_100226E0(void *a1);
char __cdecl sub_10022740(void *a1);
char __cdecl sub_100227A0(float *a1);
char __cdecl sub_100227D0(float *a1);
double __cdecl sub_10022870(float a1, float a2, int a3, float a4);
char __cdecl sub_10022950(bool *a1);
int __cdecl sub_10022A90(_BYTE *a1);
char __cdecl sub_10022AC0(_BYTE *a1, _BYTE *a2);
char __cdecl sub_10022B10(_BYTE *a1, _BYTE *a2);
int sub_10022B60();
__int16 sub_10022C30();
// int __usercall sub_10022C90@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
signed int __cdecl sub_10022D10(int a1);
unsigned __int8 sub_10022E00();
char sub_10022ED0();
int (__cdecl *(*sub_10023090())[2])(int, int);
int __cdecl sub_100231C0(int a1, signed int a2, signed int a3);
char __cdecl sub_100231E0(char a1);
char __thiscall sub_10023210(void *this);
int __cdecl sub_10023270(int a1);
signed int __cdecl sub_10023370(int a1, int a2);
int __cdecl sub_10023410(unsigned __int8 *a1, int a2);
int __cdecl sub_10023440(unsigned __int8 *a1, int a2);
int __cdecl sub_10023470(unsigned __int8 *a1, int a2);
int __cdecl sub_100234A0(unsigned __int8 *a1, int a2);
int __cdecl sub_100234D0(unsigned __int8 *a1, int a2);
int __cdecl sub_10023500(unsigned __int8 *a1, int a2);
int __cdecl sub_10023530(unsigned __int8 *a1, int a2);
int __cdecl sub_10023560(unsigned __int8 *a1, int a2);
int __cdecl sub_10023590(unsigned __int8 *a1, int a2);
int __cdecl sub_100235C0(unsigned __int8 *a1, int a2);
int __cdecl sub_100235F0(unsigned __int8 *a1, int a2);
int __cdecl sub_10023620(unsigned __int8 *a1);
int __cdecl sub_10023640(unsigned __int8 *a1, int a2);
int __cdecl sub_10023670(unsigned __int8 *a1, int a2);
int __cdecl sub_100236A0(unsigned __int8 *a1);
int __cdecl sub_100236C0(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_100236F0(char *a1);
int __cdecl sub_10023710(_BYTE *a1);
int __cdecl sub_10023730(unsigned __int8 *a1);
int __cdecl sub_10023750(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_10023780(int a1, int a2);
unsigned int __cdecl sub_10023AB0(int a1, int a2);
unsigned int __cdecl sub_10023EF0(_BYTE *a1);
int __cdecl sub_10023F10(unsigned __int8 *a1);
int __cdecl sub_10023F30(unsigned __int8 *a1);
int __cdecl sub_10023F50(_BYTE *a1);
int __cdecl sub_10023F70(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_10023FC0(unsigned __int8 *a1);
int __cdecl sub_10023FE0(int a1);
unsigned int __cdecl sub_10024070(int a1);
signed int __cdecl sub_10024090(int a1);
unsigned int __cdecl sub_100240E0(int a1);
int __cdecl sub_10024140(_BYTE *a1);
unsigned int __cdecl sub_10024160(_BYTE *a1);
int __cdecl sub_10024180(unsigned __int8 *a1);
int __cdecl sub_100241A0(_BYTE *a1);
signed int __cdecl sub_100241C0(_BYTE *a1, int a2);
int __cdecl sub_100241F0(_BYTE *a1, int a2);
signed int __cdecl sub_10024230(_BYTE *a1, int a2);
int __cdecl sub_10024260(int a1, int a2);
int __cdecl sub_100242F0(unsigned __int8 *a1);
int __cdecl sub_10024310(int a1);
int __cdecl sub_10024340(unsigned __int8 *a1);
unsigned int __cdecl sub_10024360(int a1);
int __cdecl sub_10024390(int a1);
int __cdecl sub_10024480(int a1);
signed int __cdecl sub_10024590(unsigned __int8 *a1, int a2);
signed int __cdecl sub_100245C0(int a1, int a2);
int __cdecl sub_10024AD0(_BYTE *a1, int a2);
signed int __cdecl sub_10024B00(_BYTE *a1, int a2);
int __cdecl sub_10024B70(unsigned __int8 *a1);
int __cdecl sub_10024BD0(int a1);
signed int __cdecl sub_10024BE0(_BYTE *a1, int a2);
int __cdecl sub_10024C10(int a1, int a2);
int __cdecl sub_10024C90(int a1);
unsigned int __cdecl sub_10024D10(int a1);
unsigned int __cdecl sub_10024D50(int a1);
int __cdecl sub_10024DA0(int a1);
int __cdecl sub_10024DD0(int a1);
unsigned int __cdecl sub_10024E00(int a1);
unsigned int __cdecl sub_10024E30(int a1);
unsigned int __cdecl sub_10024E50(int a1);
void __cdecl __noreturn sub_10024E90(int a1);
signed int __cdecl sub_10025000(int a1, int a2);
int __cdecl sub_10025050(int a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// int __usercall sub_100250B0@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>);
// signed int __usercall sub_10025100@<eax>(int a1@<eax>, int a2@<edi>);
int __cdecl sub_100251D0(unsigned __int8 *a1);
signed int __cdecl sub_100251E0(int a1);
char __cdecl sub_100251F0(char a1);
signed int __cdecl sub_10025230(char a1);
int __cdecl sub_10025270(char *a1, char a2);
bool __cdecl sub_100252E0(int a1, void *a2);
char __cdecl sub_100253A0(int a1, bool *a2);
signed int __fastcall sub_10025460(unsigned __int8 a1);
char __cdecl sub_10025470(unsigned __int8 a1);
__int16 __cdecl sub_10025490(unsigned __int8 a1);
char *__cdecl sub_100254B0(char **a1);
int sub_10025500();
int __cdecl sub_10025540(_BYTE *a1, int a2);
signed int __cdecl sub_100255B0(_BYTE *a1, int a2);
// int __usercall sub_10025650@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10025680@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10025850@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_100258B0@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10025940@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10025990@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_100259F0@<eax>(int a1@<eax>);
// int __usercall sub_10025A10@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10025A50@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10025AE0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10025C30@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10025CD0@<eax>(int result@<eax>);
char *__cdecl sub_10025D10(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10025EC0@<eax>(int a1@<eax>);
// int __usercall sub_10025EF0@<eax>(int a1@<esi>);
void __cdecl sub_10025F20(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10026390();
void *sub_100263E0();
char *sub_10026440();
char sub_10026460();
char __cdecl sub_10026470(int a1, int a2, unsigned int a3);
// int *__usercall sub_100264B0@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_10026500();
int __cdecl sub_10026510(_DWORD *a1, int a2, int a3);
int __cdecl sub_100265C0(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_100267D0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10026890(char a1);
int *__cdecl sub_10026930(_BYTE *a1);
// int __usercall sub_100269F0@<eax>(int a1@<eax>);
// signed int __usercall sub_10026B50@<eax>(int a1@<esi>);
int __cdecl sub_10026BC0(int, int); // weak
char **sub_10026EA0();
// int __usercall sub_10026EB0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_10026FA0(char *a1);
int sub_100271E0();
int __cdecl sub_100272C0(int a1, int a2, char a3);
int __cdecl sub_10027310(int a1);
int __cdecl sub_10027320(void *); // idb
int __cdecl sub_100273A0(int a1, int a2);
signed int __cdecl sub_100273D0(int a1, int a2, int a3);
char __cdecl sub_100273F0(_DWORD *a1);
char __cdecl sub_10027500(int a1, unsigned int a2);
bool __cdecl sub_10027530(const void **a1, int a2);
bool __cdecl sub_10027560(const void **a1, int a2);
bool __cdecl sub_10027590(const void **a1, int a2);
bool __cdecl sub_100275C0(const void **a1, int a2);
bool __cdecl sub_100275F0(const void **a1, int a2);
bool __cdecl sub_10027620(int a1, int a2);
bool __cdecl sub_10027660(int a1, int a2);
bool __cdecl sub_100276A0(const void **a1, int a2);
bool __cdecl sub_100276D0(const void **a1, int a2);
char __cdecl sub_10027700(int a1, unsigned int a2);
bool __cdecl sub_10027730(const void **a1, int a2);
bool __cdecl sub_10027760(const void **a1, int a2);
bool __cdecl sub_10027790(const void **a1, int a2);
bool __cdecl sub_100277C0(const void **a1, int a2);
bool __cdecl sub_100277F0(const void **a1, int a2);
bool __cdecl sub_10027820(const void **a1, int a2);
bool __cdecl sub_10027850(const void **a1, int a2);
bool __cdecl sub_10027880(const void **a1, int a2);
bool __cdecl sub_100278B0(const void **a1, int a2);
bool __cdecl sub_100278E0(const void **a1, int a2);
int __cdecl sub_10027910(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10027980(int a1, char a2);
int __cdecl sub_100279A0(int a1, int a2, int a3);
int __cdecl sub_100279D0(int a1, int a2, int a3, int a4);
int __cdecl sub_10027A00(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10027A40(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10027A80(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_10027AD0(int a1);
char __cdecl sub_10027B00(int a1);
char __cdecl sub_10027B10(int a1, int a2);
signed int __cdecl sub_10027C90(int a1);
signed int __cdecl sub_10027CD0(int a1, int a2, int a3);
char __cdecl sub_10027D70(int a1);
char __cdecl sub_10027DD0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_10027E40(char *a1);
int __cdecl sub_10027EE0(int a1, int a2, int a3);
bool __cdecl sub_10027F50(int a1, unsigned int a2, int a3);
char __cdecl sub_10027FE0(int a1, int a2, char a3, char a4);
char __cdecl sub_10028090(int a1);
char __cdecl sub_100280A0(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_10028120(int a1, const char *a2))(const char *);
signed int __cdecl sub_10028170(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_100281C0(int a1, int a2, int a3, size_t a4, char *a5);
int sub_10028340();
const char *__cdecl sub_10028350(unsigned int a1);
int __cdecl sub_10028370(int a1, int a2, int a3, int a4);
int __cdecl sub_10028420(int a1);
int __cdecl sub_10028440(int a1);
char *sub_10028460(char *a1, ...);
// char *__usercall sub_100284A0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_100284C0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_100286A0();
int sub_100286C0();
int __cdecl sub_100286E0(int a1, int a2);
int __cdecl sub_10028740(int a1);
int __cdecl sub_10028750(int a1, int a2);
int __cdecl sub_100287B0(int a1);
bool __cdecl sub_100287C0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_10028900(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_10028CB0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_10029100(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_100295C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10029980(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_10029D80(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1002A140(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1002A680(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1002AA60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1002AE20(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1002B1C0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1002B5C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1002B960(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1002BF40(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1002C330(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_1002C6D0();
// BOOL __usercall sub_1002C700@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_1002C870@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_1002CAE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_1002CDE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_1002CE90(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_1002CED0(int a1, int a2);
char __cdecl sub_1002CF10(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_1002DCC0(int a1, int a2);
char **__cdecl sub_1002DD40(int a1);
int (**sub_1002DD80())();
int (__cdecl *__cdecl sub_1002DD90(const char *a1))(const char *);
const char *sub_1002DDB0();
__int64 sub_1002DDC0();
const char *sub_1002DDD0();
// int __usercall sub_1002DDE0@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_1002DE30(int a1, int a2);
int sub_1002DE60(); // weak
// int __usercall sub_1002DF80@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_1002E300(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_1002F120(int a1);
char __thiscall sub_1002F190(void *this);
// char __usercall sub_1002F200@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_1002F240@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_1002F2E0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002F320(char a1, char a2, void *a3);
char __cdecl sub_1002F380(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002F3C0(char a1, char a2, void *a3);
char __cdecl sub_1002F3F0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002F430(char a1, char a2, void *a3);
char __cdecl sub_1002F470(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002F4B0(char a1, char a2, void *a3);
char __cdecl sub_1002F500(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002F540(char a1, char a2, void *a3);
char __cdecl sub_1002F580(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_1002F5C0(char a1, char a2, void *a3);
char __cdecl sub_1002F600(char a1, void *a2);
char __cdecl sub_1002F630(char a1, void *a2);
char __cdecl sub_1002F660(char a1, void *a2);
char __cdecl sub_1002F690(char a1, void *a2);
char __cdecl sub_1002F6C0(char a1, void *a2);
char __cdecl sub_1002F6F0(char a1, void *a2);
char __cdecl sub_1002F720(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002F760(char a1, char a2, void *a3);
char __cdecl sub_1002F7B0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_1002F7F0(char a1, char a2, void *a3);
char __cdecl sub_1002F820(char a1, void *a2);
char __cdecl sub_1002F850(char a1, void *a2);
char __cdecl sub_1002F880(char a1, void *a2);
char __cdecl sub_1002F8B0(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_1002FC50(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1002FCC0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1002FD20(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002FD90(char a1, _BYTE *a2);
char __thiscall sub_1002FDD0(void *this);
char __cdecl sub_1002FE40(char a1, int a2);
char __cdecl sub_1002FE70(char a1, int a2);
char __cdecl sub_1002FEA0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
int __cdecl sub_10030070(int a1);
char __cdecl sub_100300B0(int a1, int a2);
char __cdecl sub_100301D0(int a1);
char __cdecl sub_100301E0(int a1);
signed int __cdecl sub_100301F0(_BYTE *a1, char a2, int a3);
int __cdecl sub_10030240(int, float, float, int, int); // idb
unsigned int __cdecl sub_10030330(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_10030380(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_10030440(void *a1, size_t a2, int a3);
int __cdecl sub_100304A0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_100304F0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10030590(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char __cdecl sub_10030640(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
signed int __cdecl sub_100306A0(char a1, char a2);
int __cdecl sub_10030700(char a1);
signed int __cdecl sub_10030740(char a1, char a2, char a3);
int __cdecl sub_100307B0(char a1);
int __cdecl sub_100307F0(char a1);
char __cdecl sub_10030830(int a1, int a2);
char __cdecl sub_10030850(char a1, int a2);
char __cdecl sub_10030870(char a1, int a2);
char __cdecl sub_100308A0(char a1, int a2);
char __cdecl sub_100308F0(char a1, int a2);
char __cdecl sub_10030920(char a1, int a2);
char __cdecl sub_10030940(int a1);
char __cdecl sub_10030960(void *a1);
char __cdecl sub_10030980(void *a1);
bool __thiscall sub_10030AD0(void *this);
char __cdecl sub_10030AF0(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_10030C90(char a1);
char sub_10030CC0();
BOOL __cdecl sub_10030D60(int a1, int a2);
char __cdecl sub_10030D80(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10030DC0(unsigned __int16 a1, float *a2);
char __cdecl sub_10030EE0(unsigned __int16 a1);
char __cdecl sub_10030F80(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_10031090(char a1);
char __cdecl sub_100310E0(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
double __cdecl sub_10031140(int a1);
char __thiscall sub_10031190(void *this);
// _DWORD *__usercall sub_100311B0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4);
int sub_100311E0(); // weak
int sub_10031240(); // weak
char __cdecl sub_10031290(int a1, int a2);
_DWORD *sub_10031390();
int __cdecl sub_10031420(char a1);
// int __usercall sub_10031430@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_10031440@<al>(char a1@<bl>, char a2);
char __cdecl sub_10031500(char a1, char a2);
int __cdecl sub_10031520(char a1);
_DWORD __cdecl sub_10031550(char); // weak
unsigned int __cdecl sub_10031560(unsigned int a1);
bool __cdecl sub_10031580(int a1);
int __cdecl sub_10031650(int a1);
int __cdecl sub_10031670(int a1, int a2);
signed int __cdecl sub_100316B0(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_10031770(int a1);
// int __usercall sub_100317B0@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10031860@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10031A30@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10031A40@<eax>(int result@<eax>);
// char __usercall sub_10031A60@<al>(int a1@<eax>);
// int __usercall sub_10031A80@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_10031AC0(int a1, int a2);
// int __usercall sub_10031AE0@<eax>(int a1@<esi>);
// signed int __usercall sub_10031B20@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10031D30(int a1);
signed int __cdecl sub_10031FA0(unsigned int a1, int a2, int a3);
// int __usercall sub_10032040@<eax>(int a1@<eax>);
// int __usercall sub_10032060@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10032090@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit_1(int);
// char __usercall sub_10032180@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_100321B0@<eax>(int a1@<eax>);
signed int __cdecl sub_100321E0(unsigned int a1);
signed int __cdecl sub_10032230(int a1, int a2);
signed int __cdecl sub_10032420(unsigned int a1, int a2, int a3);
signed int __cdecl sub_10032480(unsigned int a1, int a2, int a3);
_DWORD __cdecl sub_10032610(_DWORD, _DWORD); // weak
char __cdecl sub_10032620(char a1, void *a2);
unsigned __int8 __cdecl sub_10032670(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_100326B0(char a1, _DWORD *a2);
char __cdecl sub_100326F0(char a1);
char __cdecl sub_10032720(char a1, void *a2);
int __cdecl sub_100327A0(char a1, _DWORD *a2);
void __cdecl sub_100327F0(char a1, char a2);
int __cdecl sub_10032860(int, float); // idb
int __cdecl sub_10032880(int, float); // idb
bool __cdecl sub_100328A0(void *a1);
char __cdecl sub_100328E0(char a1);
char __cdecl sub_10032910(char a1);
char __cdecl sub_10032940(int a1, int a2);
char __cdecl sub_10032990(int a1, int a2);
char __cdecl sub_10032A40(int a1, int a2);
char __cdecl sub_10032AA0(int a1, int a2);
char sub_10032B70();
char sub_10032B80();
int __cdecl sub_10032C00(unsigned __int8 *a1);
unsigned int __cdecl sub_10032C20(void *a1);
unsigned int __cdecl sub_10032C40(void *a1);
unsigned int __cdecl sub_10032C60(void *a1);
unsigned int __cdecl sub_10032C80(void *a1);
unsigned int __cdecl sub_10032CA0(void *a1);
signed int __cdecl sub_10032CC0(_BYTE *a1, int a2);
unsigned int __cdecl sub_10032CF0(void *a1);
int __cdecl sub_10032D50(int a1);
char __cdecl sub_10032D60(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10032DA0(const char *a1, int a2);
// char *__usercall sub_10032E10@<eax>(char *result@<eax>);
void __cdecl sub_10032E40(char *a1);
void __cdecl sub_10032F00(char *a1, char *a2);
void *__cdecl sub_10032F60(int a1);
int __cdecl sub_100330F0(int a1, int a2);
// char __usercall sub_10033230@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_10033300(_DWORD *a1, char *a2);
BOOL __cdecl sub_100333E0(unsigned int a1);
BOOL __cdecl sub_10033400(int a1);
_DWORD __cdecl sub_10033420(_DWORD); // weak
unsigned int __cdecl sub_10033430(int a1, char a2);
signed int __cdecl sub_10033490(void *a1, int a2, unsigned int a3);
int __cdecl sub_100334B0(int a1, int a2, int a3);
char __cdecl sub_100334D0(const char *a1, const char *a2);
int __cdecl sub_10033610(int a1, int a2, unsigned int a3);
int sub_10033690();
void __cdecl sub_100336A0(int a1);
int __cdecl sub_100336D0(int a1);
bool __cdecl sub_100336F0(int a1);
void *__cdecl sub_10033720(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10033760@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10033780@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_100337A0(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_100337D0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_100338B0(int a1, int a2, int a3);
// void *__usercall sub_10033960@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_10033BE0(int a1, int a2);
char __cdecl sub_10033CB0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10033D20@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10034080@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10034190(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10034320(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10034470@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_100345C0(int a1, int a2);
signed int __cdecl sub_10034600(int a1, int a2);
bool __cdecl sub_10034660(signed int a1);
int sub_100346D0();
char sub_100349F0();
char sub_10034C10();
char sub_10034E10();
char sub_10034F90();
char sub_10035110();
char sub_10035280();
char sub_10035380();
char sub_100354E0();
char sub_10035640();
char sub_100357A0();
char sub_10035910();
char sub_10035A70();
char sub_10035BD0();
char sub_10035DF0();
char sub_10035F50();
char sub_100360B0();
char sub_10036210();
char sub_10036380();
char sub_100364E0();
char sub_10036640();
char sub_10036860();
char sub_10036A60();
char sub_10036BE0();
char sub_10036D60();
char sub_10036ED0();
char sub_10036FC0();
char sub_10037120();
char sub_10037280();
char sub_100373E0();
char sub_10037550();
char sub_100376B0();
char sub_10037810();
char sub_10037A10();
char sub_10037B70();
char sub_10037CD0();
char sub_10037E30();
char sub_10037FA0();
char sub_10038100();
char sub_10038260();
char sub_10038800();
char sub_10038A10();
char sub_10038C00();
char sub_10038D70();
char sub_10038EE0();
char sub_10039040();
char sub_10039130();
char sub_10039290();
char sub_100393F0();
char sub_10039550();
char sub_100396C0();
char sub_10039820();
char sub_10039980();
char sub_10039B80();
char sub_10039CE0();
char sub_10039E40();
char sub_10039FA0();
char sub_1003A110();
char sub_1003A270();
char sub_1003A3D0();
char sub_1003A5E0();
char sub_1003A7D0();
char sub_1003A940();
char sub_1003AAB0();
char sub_1003AC10();
char sub_1003AD00();
char sub_1003AE60();
char sub_1003AFC0();
char sub_1003B120();
char sub_1003B290();
char sub_1003B3F0();
char sub_1003B550();
char sub_1003B750();
char sub_1003B8B0();
char sub_1003BA10();
char sub_1003BB70();
char sub_1003BCE0();
char sub_1003BE40();
char **sub_1003BFA0();
int __cdecl sub_1003BFB0(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_1003BFD0@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_1003BFE0@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_1003C210(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1003C260(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1003C2B0(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_1003C300(int a1))(int);
int __cdecl sub_1003C380(int a1, int a2);
int (__cdecl *__cdecl sub_1003C400(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_1003C450(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1003C490(int a1, int a2, int a3))(int);
int __cdecl sub_1003C4F0(char a1);
bool __cdecl sub_1003C540(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_1003C5D0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
char __cdecl sub_1003C670(char a1);
char __cdecl sub_1003C6F0(char a1, int a2);
// int __usercall sub_1003C860@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1003C8A0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1003C8E0();
char __cdecl sub_1003C8F0(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1003C950(char a1, void *a2);
char __cdecl sub_1003CA70(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003CAF0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
int __cdecl sub_1003CCA0(char a1, char a2);
// bool __usercall sub_1003CD50@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_1003CD80@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_1003CE20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003CEA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003CF20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003CFA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003D020(char a1);
int __cdecl sub_1003D0C0(int a1, int a2);
char __cdecl sub_1003D0E0(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9);
signed int __cdecl sub_1003D1B0(int (__cdecl *a1)(int));
char *__cdecl sub_1003D1E0(unsigned __int8 a1);
int __cdecl sub_1003D210(char a1, char *a2);
// signed int __usercall sub_1003D260@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1003E310@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_1003E370@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_1003F0F0@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_1003F110(int a1, unsigned int a2);
// int __usercall sub_1003F170@<eax>(int result@<eax>);
// int __usercall sub_1003F1B0@<eax>(int result@<eax>);
// unsigned int __usercall sub_100408D0@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_100409D0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10040A50@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10040AF0@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_10040BB0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10040C10@<eax>(char *a1@<edi>);
// int __usercall sub_10040CD0@<eax>(int a1@<ebx>);
char __cdecl sub_10040D90(char *a1, size_t a2, int a3);
char __cdecl sub_10040DE0(char *a1, unsigned int a2, int a3);
bool __cdecl sub_10040E30(int a1, int a2);
// int __usercall sub_10040E60@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_10041070@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_100410C0(int a1, int a2);
signed int __cdecl sub_10041150(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_10041280(void *a1, int a2);
// BOOL __usercall sub_10041300@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_100413A0@<eax>(int result@<eax>);
unsigned int __fastcall sub_10041430(unsigned int a1, int a2);
// int __usercall sub_10041450@<eax>(int result@<eax>);
// int __usercall sub_100414E0@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_10041960@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10041A10@<eax>(int a1@<edi>);
// int __usercall sub_10041A70@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10041C40@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_10041CC0(int a1, int a2);
// unsigned int __usercall sub_10041D30@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_10041EE0@<eax>(int a1@<esi>, int a2);
// int __usercall sub_10041FB0@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_10042060@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_100420A0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_10042100@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_100421E0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10042780@<eax>(int a1@<eax>);
// int __usercall sub_100429C0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10042A60@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10042C40@<eax>(int a1@<edi>);
// int __usercall sub_10042D80@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_10043030(int a1, int a2);
// signed int __usercall sub_100432F0@<eax>(int a1@<eax>);
// _WORD *__usercall sub_100433C0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_100435E0(int a1, int a2);
signed int __cdecl sub_100438F0(int a1, int a2);
signed int __cdecl sub_10043D00(int a1, int a2);
int __cdecl sub_10043E70(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_10043F70(int a1);
// signed int __usercall sub_10043F90@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_10044430@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_10044480@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_100444A0(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10044850@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_10044990@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_100449E0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_10044A80@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_10044AA0(int a1);
// int __usercall sub_10044AB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10045150@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10045B30@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_10045E60(int a1, int a2);
BOOL __cdecl sub_10045E80(unsigned __int8 a1);
// BOOL __usercall sub_10045E90@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10045EC0(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_10046070(unsigned __int8 a1, int a2);
bool __cdecl sub_100460B0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
int __cdecl sub_100461A0(char a1);
int __cdecl sub_100461C0(int, void *); // idb
// int __usercall sub_10046220@<eax>(char a1@<al>);
BOOL __cdecl sub_10046250(char a1, int a2);
int __cdecl sub_10046280(int, char, int, int, void *); // idb
char __cdecl sub_100462B0(void *a1);
BOOL __cdecl sub_100462D0(int a1);
char __cdecl sub_100462F0(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_10046320(char a1, void *a2);
// signed int __usercall sub_10046360@<eax>(char a1@<al>);
bool __cdecl sub_10046380(char a1, void *a2);
bool __cdecl sub_10046470(char a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_100464A0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10046540(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_100465C0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10046630(char a1, void *a2);
char __cdecl sub_100466B0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10046730(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_100467B0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10046820(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10046930(char a1, void *a2);
bool __cdecl sub_10046950(unsigned __int8 a1, char *a2);
char __cdecl sub_10046990(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_100469D0();
char __cdecl sub_10046A30(int a1, char *a2);
BOOL __cdecl sub_10046B20(int a1, int a2);
char __cdecl sub_10046B40(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_10046B80(int a1, int a2);
BOOL __cdecl sub_10046C30(int a1, int a2);
char __cdecl sub_10046C50(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_10046C90(char a1);
// __int16 __usercall sub_10046CD0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10046CE0(unsigned __int8 a1, char *a2);
char __cdecl sub_10046DB0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_10046E30(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10046F60(char a1, int a2);
bool __cdecl sub_10046FE0(void *a1);
char __cdecl sub_10047030(char a1, int a2);
// __int16 __usercall sub_10047110@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10047120(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_100471B0(unsigned __int8 a1, char a2);
bool __cdecl sub_10047270(__int16 a1, char a2, int a3, int a4, void *a5);
char __cdecl sub_10047370(char a1);
char __cdecl sub_100473B0(char a1);
// int __cdecl BMP_get_bm_def(_DWORD); weak
// int __cdecl FNT_get_fnt_hdr(_DWORD); weak
// int __cdecl BMP_get_xfrm(_DWORD); weak
// int TXT_get_static_string(void); weak
int __cdecl sub_100473E0(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_10047400(unsigned int *a1, signed int a2, unsigned int a3);
double __cdecl sub_10047530(float a1, float a2);
double __cdecl sub_100475D0(float a1, float a2);
double __cdecl sub_10047670(double a1, double a2);
double __cdecl sub_100476D0(float a1, float a2);
int __cdecl sub_10047750(double); // idb
double __cdecl sub_10047770(float a1);
int __cdecl sub_100477B0(int a1, int a2);
int __cdecl sub_100477D0(float); // idb
int __cdecl sub_10047800(float, int, int); // idb
int __cdecl sub_10047820(int a1, int a2);
int __cdecl sub_10047840(float); // idb
double __cdecl sub_100478A0(double a1, double a2);
double __cdecl sub_10047910(float a1, float a2);
int __cdecl sub_100479A0(int a1, int a2, int a3);
int __cdecl sub_100479D0(float, int, int); // idb
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int gdi_pvg_init(void); weak
// int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gdi_pvg_create_window(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int SYS_enter_krnl(void); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
__int32 __cdecl j__atol(const char *);
// char *__cdecl strstr(const char *, const char *);
// void *__cdecl memset(void *, int, size_t);
// int __cdecl strncmp(const char *, const char *, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// char *__cdecl strrchr(const char *, int);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// double __cdecl floor(double);
// int sprintf(char *, const char *, ...);
// char *__cdecl strchr(const char *, int);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// double __cdecl _atof_l(const char *String, _locale_t Locale);
double __cdecl sub_10049919(char *String);
// int _snprintf(char *, size_t, const char *, ...);
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isalnum(int);
// int __cdecl isprint(int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1004A2F9(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// char *__cdecl strpbrk(const char *, const char *);
signed int __cdecl sub_1004B812(_DWORD *a1);
signed int __cdecl sub_1004B849(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_1004C48F();
int (*sub_1004C93C())(void);
void __cdecl sub_1004C960(); // idb
int __cdecl sub_1004E18E(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1004F9E5(int, FILE *); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_10052527(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_1005446B(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_10054511(int, int, struct localeinfo_struct *); // idb
void sub_10054982();
// int _get_sse2_info(void); weak
int sub_10054AD5();
int sub_10054FD2();
int __cdecl sub_1005518F(int a1);
int __cdecl sub_10055199(int a1);
int __cdecl sub_100551A3(int a1);
int __cdecl sub_10055282(int a1);
int sub_100565E0();
DWORD __cdecl sub_10056DC5(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_10056F61(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_10057583(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_100576A3(signed int a1);
void **sub_10057701();
signed int sub_10057707();
// int __cdecl _fileno(FILE *);
signed int __cdecl sub_10058029(int a1, int a2);
signed int __cdecl sub_1005856B(int a1, int a2);
int __cdecl sub_10058EAC(FILE *); // idb
int __cdecl sub_10058FCC(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int __cdecl sub_10059F0B(int a1, int a2, int a3);
signed int __cdecl sub_1005A3DB(signed int a1);
signed int __cdecl sub_1005A45C(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_1005A56D(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_1005A86E();
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_1005B1B1(signed int a1);
int __cdecl sub_1005B350(int a1, int a2);
// int __usercall sub_1005B3B0@<eax>(const char **a1@<esi>);
// int __usercall sub_1005B6B0@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_1005B6D0(int a1);
__int16 __cdecl sub_1005B7A0(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_1005B7E0(int a1, _DWORD *a2, _BYTE *a3);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_1005B880(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_1005B8D0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_1005B940(int a1);
int __cdecl sub_1005B980(int a1);
int __cdecl sub_1005B9C0(int a1);
int __cdecl sub_1005BA00(int a1);
int __cdecl sub_1005BA40(int a1, int a2, int a3, int a4);
int __cdecl sub_1005BAB0(int a1, int a2, int a3);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
void __cdecl sub_1005BB60(float *a1, float *a2, float *a3, int a4);
int __cdecl sub_1005BBC0(float, float, int); // idb
void __cdecl sub_1005BD80(int a1, int a2, float *a3, float *a4, float *a5);
void __cdecl sub_1005C150(int a1, int a2, float *a3, float *a4);
int __cdecl sub_1005C230(int a1, float a2, float *a3, int a4, float *a5);
double __cdecl sub_1005C310(float a1);
int __cdecl sub_1005C340(int a1, __int16 a2, __int16 a3);
int __cdecl sub_1005C3A0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6);
int __cdecl sub_1005C600(int a1, signed int a2, int a3, int a4, int a5);
char __cdecl sub_1005CCF0(float a1, int a2, int a3);
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN SIM_intf; weak
int dword_1005DDA0[] = { 56 }; // weak
int (__cdecl *off_1005DDA4)(int, int, int, int, int) = &sub_10010930; // weak
int dword_1005DDA8[] = { 12 }; // weak
int dword_1005DDAC[] = { 63 }; // weak
int (__cdecl *off_1005DDB0)(int, int, int, int, int) = &sub_10015170; // weak
int dword_1005DDB4[] = { 4 }; // weak
int dword_1005DDB8[] = { 62 }; // weak
int (__cdecl *off_1005DDBC)(int, int, int, int, int) = &sub_1000FE60; // weak
int dword_1005DDC0[] = { 12 }; // weak
int dword_1005DDC4[] = { 66 }; // weak
int (__cdecl *off_1005DDC8)(int, int, int, int, int) = &sub_10014B10; // weak
int dword_1005DDCC[] = { 8 }; // weak
int dword_1005DDD0[] = { 67 }; // weak
int (__cdecl *off_1005DDD4)(int, int, int, int, int) = &sub_1000FB80; // weak
int dword_1005DDD8[] = { 12 }; // weak
_UNKNOWN unk_1005E400; // weak
_UNKNOWN unk_1005E408; // weak
_UNKNOWN unk_1005E428; // weak
__int16 word_1005F6A0[] = { 1116 }; // weak
_UNKNOWN unk_1005F984; // weak
_UNKNOWN unk_1005FB04; // weak
_UNKNOWN unk_10060030; // weak
_UNKNOWN unk_100600F4; // weak
_UNKNOWN unk_100601A4; // weak
__int16 word_100601A6[] = { 6 }; // weak
_UNKNOWN unk_10060274; // weak
__int16 word_10060276[] = { 6 }; // weak
char byte_10060334[] = { '\0' }; // weak
char byte_10060335[] = { '\x05' }; // weak
char byte_10060336[] = { '\x01' }; // weak
char byte_10060337[] = { '\x01' }; // weak
_UNKNOWN unk_100605E8; // weak
_UNKNOWN unk_10060668; // weak
_UNKNOWN unk_100606E8; // weak
_UNKNOWN unk_10060768; // weak
_UNKNOWN unk_100607C0; // weak
_UNKNOWN unk_10060834; // weak
_UNKNOWN unk_10060848; // weak
void *off_1006084C = &unk_1005FF3C; // weak
void *off_10060850 = &unk_10060814; // weak
void *off_10060854 = &unk_10060060; // weak
_UNKNOWN unk_100608C8; // weak
__int16 word_100608CA[] = { 6 }; // weak
_UNKNOWN unk_100608E8; // weak
__int16 word_100608EA[] = { 6 }; // weak
char byte_10060920[] = { '\0' }; // weak
__int16 word_10060922[] = { 6 }; // weak
char byte_10060924[] = { '\f' }; // weak
char byte_10060925[] = { '\x01' }; // weak
char byte_10060926[] = { '\x01' }; // weak
_UNKNOWN unk_10060960; // weak
char byte_10060961[] = { '\0' }; // weak
__int16 word_10060962[] = { 0 }; // weak
__int16 word_10060964[] = { 0 }; // weak
char byte_10060966[] = { '\0' }; // weak
_UNKNOWN unk_10060978; // weak
__int16 word_1006097A[] = { 6 }; // weak
char byte_1006097C[] = { '\f' }; // weak
char byte_1006097D[] = { '\x01' }; // weak
char byte_1006097E[] = { '\x01' }; // weak
_UNKNOWN unk_100609D0; // weak
char byte_100609D1[] = { '\0' }; // weak
__int16 word_100609D2 = 6; // weak
char byte_100609D4[] = { '\0' }; // weak
char byte_100609D5[] = { '\0' }; // weak
_UNKNOWN unk_10060A2C; // weak
__int16 word_10060A2E[] = { 6 }; // weak
_UNKNOWN unk_10060A48; // weak
char byte_10060A4C[] = { '\f' }; // weak
__int16 word_10060A4E[] = { 6 }; // weak
_UNKNOWN unk_10060A88; // weak
char byte_10060A8C[] = { '\f' }; // weak
__int16 word_10060A8E[] = { 6 }; // weak
_UNKNOWN unk_10060AD8; // weak
char byte_10060ADC[] = { '\f' }; // weak
__int16 word_10060ADE[] = { 6 }; // weak
_UNKNOWN unk_10060AF8; // weak
char byte_10060AFC[] = { '\f' }; // weak
__int16 word_10060AFE[] = { 6 }; // weak
int dword_10060B98[] = { 0 }; // weak
__int16 word_10060B9C[] = { 6 }; // weak
char byte_10060B9E[] = { '\0' }; // weak
float flt_10060BA0[] = {  0.0 }; // weak
_UNKNOWN unk_10060BCC; // weak
char word_10060D0C[] = { ' ', '\0' }; // idb
_UNKNOWN unk_10061378; // weak
int dword_1006137C[] = { 0 }; // weak
char byte_10061380[] = { '\0' }; // weak
_UNKNOWN unk_100613DC; // weak
_UNKNOWN unk_10061AC0; // weak
int (__cdecl *off_100636EC)(int) = &sub_10004550; // weak
char aStatus[7] = "STATUS"; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
_UNKNOWN unk_10065D59; // weak
char byte_100686B8[] = { '\0' }; // weak
int dword_100686C8 = 0; // idb
char *off_100692F0[2] = { "%02d:%02u", "__:__" }; // weak
char *off_100692F4 = "__:__"; // weak
char byte_100692F8[] = { '9' }; // weak
char a03d02u[11] = "%+03d:%02u"; // weak
int dword_10069320 = 1; // weak
__int16 word_10069324[] = { 99 }; // weak
int dword_10069328 = 4; // weak
char byte_1006932C[] = { '\0' }; // weak
char byte_1006932D[] = { '\x01' }; // weak
char byte_100695B0[] = { '#' }; // weak
_UNKNOWN unk_10069B88; // weak
_UNKNOWN unk_10069B90; // weak
char byte_10069D50[] = { 'c' }; // weak
char byte_10069D58[] = { 'D' }; // weak
char byte_10069D5C[] = { '0' }; // weak
char byte_10069D6C[] = { 'h' }; // weak
char byte_10069D74[] = { 'i' }; // weak
char byte_10069D7C[] = { 'm' }; // weak
char byte_10069D84[] = { 'o' }; // weak
char byte_10069D94[] = { 'v' }; // weak
__int16 word_1006A364[] = { 951 }; // weak
__int16 word_1006A37C[] = { 4811 }; // weak
__int16 word_1006A384[] = { 1136 }; // weak
__int16 word_1006A38C[] = { 6 }; // weak
int dword_1006BAB0[] = { 360 }; // weak
float flt_1006BAB4[] = {  360.0 }; // weak
char byte_1006BAB8[] = { '\0' }; // weak
char byte_1006BAB9[] = { '\x03' }; // weak
char byte_1006BABA[] = { '\x01' }; // weak
char byte_1006BABB[85] =
{
  '!',
  '\0',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '4',
  'C',
  '\x01',
  '\x04',
  '\0',
  '!',
  '\0',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  'C',
  '\0',
  '\x03',
  '\x01',
  '!',
  '\0',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '',
  'C',
  '\0',
  '\x05',
  '\x01',
  '!',
  '\0',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '3',
  'C',
  '\x01',
  '\x03',
  '\x01',
  '',
  'W',
  '\0',
  '\0',
  '\0',
  'h',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '4',
  'C',
  '\x01',
  '\x03',
  '\0',
  '',
  '',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_1006C0C0; // weak
int dword_1006C0C4[] = { 0 }; // weak
char byte_1006C0C8[] = { '\a' }; // weak
__int16 word_1006E364 = 48; // weak
_UNKNOWN unk_1006FA24; // weak
_UNKNOWN unk_1007058C; // weak
char byte_10070B2C[] = { '\0' }; // weak
char byte_10070B2D[] = { '\0' }; // weak
char byte_10070B2E[] = { '\xFF' }; // weak
char byte_10070B2F[] = { '\xFF' }; // weak
char byte_10070B30[] = { '\xFF' }; // weak
char byte_10070B60[] = { ' ' }; // weak
char byte_10070B68[] = { ' ' }; // weak
_UNKNOWN unk_10070B70; // weak
_UNKNOWN unk_100716A5; // weak
_UNKNOWN unk_100716DE; // weak
char byte_100716E0[] = { '\x0E' }; // weak
char *off_10071710 = "/shr_mem/udb_intf.shr"; // weak
char byte_10072E7C[] = { '\x05' }; // weak
char byte_10072E80[] = { '\b' }; // weak
int dword_10072E84[] = { 9 }; // weak
char a______[7] = "______"; // weak
char aWgs84[21] = "WGS 84              "; // weak
_UNKNOWN unk_10074DBC; // weak
__int16 word_100758E4[] = { 81 }; // weak
_UNKNOWN unk_10075E7C; // weak
_UNKNOWN unk_10075F28; // weak
void *off_10075F2C = &unk_10075E9C; // weak
_UNKNOWN unk_10076634; // weak
char byte_10076635[] = { '\x0E' }; // weak
char *off_100770E8[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_10076F58 }; // weak
_UNKNOWN unk_100770FC; // weak
_BYTE word_10078810[540] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  128,
  4,
  0,
  45,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  44,
  0,
  45,
  0,
  45,
  0,
  37,
  0,
  37,
  0,
  47,
  0,
  45,
  0,
  37,
  0,
  60,
  0,
  61,
  0,
  45,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  16,
  0,
  0,
  37,
  0,
  37,
  0,
  36,
  0,
  44,
  0,
  36,
  0,
  45,
  32,
  44,
  13,
  0,
  5,
  0,
  5,
  0,
  5,
  0,
  13,
  0,
  5,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  9,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  36,
  0,
  36,
  0,
  36,
  0,
  44,
  64,
  45,
  0,
  4,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  10,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  44,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  65,
  66,
  67,
  68,
  69,
  70,
  0,
  0,
  0,
  0,
  87,
  83,
  0,
  0,
  69,
  78,
  0,
  0
}; // idb
int dword_100798A0[] = { 9032 }; // weak
int dword_1007A2AC[] = { 88 }; // weak
__int16 word_1007A75C[] = { 836 }; // weak
char *off_1007A77C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1007A790 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1007A7A4 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1007A7B8 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1007A7CC = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1007A7E0 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
char byte_1007AF2D[] = { '\x1E' }; // weak
char byte_1007B484[] = { '\x02' }; // weak
char byte_1007B485[] = { '\0' }; // weak
_UNKNOWN unk_1007BA00; // weak
char *off_10080D18 = "/shr_mem/pvt_intf.shr"; // weak
int (__cdecl *off_10081810)(int, size_t, void *) = &sub_100208E0; // weak
char *off_10081844 = "/shr_mem/prx_intf.shr"; // weak
char *off_10081870 = "/shr_mem/nav_intf.shr"; // weak
char *off_100818A4 = "/shr_mem/iop_fltr_data_intf.shr"; // weak
int (*off_10081DF8[4])() = { &sub_10020EA0, &sub_10020E90, &sub_10020E80, &sub_10020E90 }; // weak
char *off_10097640[42] =
{
  "A",
  "AMPS",
  "",
  "",
  "",
  "T",
  "",
  "",
  "",
  "C",
  "",
  "",
  "E",
  "E",
  "",
  "",
  "",
  "",
  "W",
  "W",
  "",
  "F",
  "",
  "FPM",
  "",
  "FT",
  "",
  "GAL",
  "",
  "GPH",
  "",
  "HPA",
  "",
  "IG",
  "",
  "IGPH",
  "",
  "IN",
  "",
  "KG",
  "",
  "KGPH"
}; // weak
char *off_10097834 = "LB-IN"; // weak
_UNKNOWN unk_10099348; // weak
_UNKNOWN unk_10099938; // weak
_UNKNOWN unk_10099940; // weak
char byte_10099948[] = { '\x01' }; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_10099ED0 = "006-D0170-"; // weak
int (__cdecl *(*off_10099ED4)[2])(int, int) = &off_100AC5D0; // weak
_UNKNOWN unk_1009A448; // weak
char byte_1009A44C[] = { '\0' }; // weak
int (__cdecl *off_1009D818[3])(char) = { &sub_1001D7C0, &sub_1001D6D0, &sub_1001D690 }; // weak
__int16 word_1009D838[] = { 43 }; // weak
char byte_1009D83C[] = { '\x06' }; // weak
_UNKNOWN unk_1009DE38; // weak
char *off_1009DFDC[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_1009DFF0 }; // weak
char *off_1009E180 = "true"; // weak
char byte_1009E184[] = { '\x01' }; // weak
char *off_1009E1E8 = "failure listener"; // weak
_UNKNOWN unk_1009E988; // weak
char *off_1009EB84[18] =
{
  "FAIL",
  "PASS",
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1009EB8C[16] =
{
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1009EB94[14] =
{
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1009EBB0[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_1009EBBC[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_1009EBC4[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_1009EE78; // weak
_UNKNOWN unk_1009EEAC; // weak
char *off_1009F260 = "printf_listener"; // weak
__int16 word_1009FE94 = 2573; // weak
int (*off_1009FF50[2])() = { &sub_1003BFA0, &sub_1001DEF0 }; // weak
char *off_100A0000 = "gate_listener"; // weak
_UNKNOWN unk_100A19D0; // weak
int dword_100A19D4[] = { 1312 }; // weak
_UNKNOWN unk_100A1D98; // weak
_UNKNOWN unk_100A1DB0; // weak
_UNKNOWN unk_100A1DF8; // weak
int dword_100A1DFC[] = { 6767 }; // weak
_UNKNOWN unk_100A1E08; // weak
_UNKNOWN unk_100A1E20; // weak
_UNKNOWN unk_100A1E38; // weak
int dword_100A1E3C[] = { 6769 }; // weak
_UNKNOWN unk_100A1E50; // weak
int dword_100A1E54[] = { 6093 }; // weak
_UNKNOWN unk_100A5A98; // weak
int dword_100A5A9C[] = { 6006 }; // weak
char byte_100A5AE0[] = { '\x01' }; // weak
__int16 word_100A5AE2[] = { 3020 }; // weak
_UNKNOWN unk_100A6F88; // weak
void *off_100A6F8C = &unk_100A6D00; // weak
int dword_100AA868[] = { 1600085855 }; // weak
_UNKNOWN unk_100AB728; // weak
char byte_100AB729[] = { '\0' }; // weak
int (__cdecl *off_100AC5D0[2])(int, int) = { &sub_10032A40, &sub_10032AA0 }; // weak
_UNKNOWN unk_100AE1F8; // weak
_UNKNOWN unk_100AE21C; // weak
_UNKNOWN unk_100AE3C0; // weak
char off_100AEFF0[] = { 'p', '', '\t', '\x10' }; // idb
int dword_100AF00C = 1; // idb
char byte_100AF028[] = { '\x01' }; // weak
void *off_100AF02C = &unk_10074DBC; // weak
char *off_100AF030[2] = { "2", "fail_normal_1" }; // weak
char off_100AF034[8] = { '', '', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100AF0B8[] = { '\0' }; // weak
char byte_100AF0B9[] = { '\0' }; // weak
int dword_100AF0BC[] = { 0 }; // weak
char *off_100AF0C0 = "0, 0, 0"; // weak
double dbl_100AF328[] = {  0.0 }; // weak
double dbl_100AF330[] = {  0.0 }; // weak
double dbl_100AF338[] = {  0.0 }; // weak
int dword_100AF340[] = { 0 }; // weak
char *off_100AF344 = "0, 0, 0"; // weak
float flt_100AFF48[] = {  0.0 }; // weak
float flt_100AFF4C[] = {  0.0 }; // weak
float flt_100AFF50[] = {  0.0 }; // weak
int dword_100AFF54[] = { 0 }; // weak
char off_100AFF58[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_100B06DC[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100C5338
}; // weak
int dword_100B06F0[] = { 0 }; // weak
int dword_100B06F4[] = { 0 }; // weak
int dword_100B06F8[] = { 0 }; // weak
int dword_100B06FC[] = { 0 }; // weak
char *off_100B0700 = "0, 0, 0"; // weak
__int16 word_100B0E88[] = { 0 }; // weak
__int16 word_100B0E8A[] = { 0 }; // weak
__int16 word_100B0E8C[] = { 0 }; // weak
int dword_100B0E90[] = { 0 }; // weak
char *off_100B0E94 = "0, 0, 0"; // weak
int dword_100B1498[] = { 0 }; // weak
int dword_100B149C[] = { 0 }; // weak
int dword_100B14A0[] = { 0 }; // weak
int dword_100B14A4[] = { 0 }; // weak
char off_100B14A8[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B1C30[] = { 0 }; // weak
int dword_100B1C34[] = { 0 }; // weak
int dword_100B1C38[] = { 0 }; // weak
int dword_100B1C3C[] = { 0 }; // weak
int dword_100B1C40[] = { 0 }; // weak
int dword_100B1C44[] = { 0 }; // weak
int dword_100B1C48[] = { 0 }; // weak
char off_100B1C4C[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B2850[] = { '\0' }; // weak
char byte_100B2851[] = { '\0' }; // weak
char byte_100B2852[] = { '\0' }; // weak
int dword_100B2854[] = { 0 }; // weak
char *off_100B2858 = "0, 0, 0"; // weak
int dword_100B2CE0[] = { 0 }; // weak
int dword_100B2CE4[] = { 0 }; // weak
int dword_100B2CE8[] = { 0 }; // weak
int dword_100B2CEC[] = { 0 }; // weak
char *off_100B2CF0 = "0, 0, 0"; // weak
int dword_100B3478[] = { 0 }; // weak
int dword_100B347C[] = { 0 }; // weak
int dword_100B3480[] = { 0 }; // weak
int dword_100B3484[] = { 0 }; // weak
char off_100B3488[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100B37E8[] = { 0 }; // weak
__int16 word_100B37EA[] = { 0 }; // weak
__int16 word_100B37EC[] = { 0 }; // weak
int dword_100B37F0[] = { 0 }; // weak
char *off_100B37F4 = "0, 0, 0"; // weak
int dword_100B3AA8[] = { 0 }; // weak
int dword_100B3AAC[] = { 0 }; // weak
int dword_100B3AB0[] = { 0 }; // weak
int dword_100B3AB4[] = { 0 }; // weak
char off_100B3AB8[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B3E18[] = { 0 }; // weak
int dword_100B3E1C[] = { 0 }; // weak
int dword_100B3E20[] = { 0 }; // weak
int dword_100B3E24[] = { 0 }; // weak
int dword_100B3E28[] = { 0 }; // weak
int dword_100B3E2C[] = { 0 }; // weak
int dword_100B3E30[] = { 0 }; // weak
char off_100B3E34[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B4398[] = { '\0' }; // weak
char byte_100B4399[] = { '\0' }; // weak
char byte_100B439A[] = { '\0' }; // weak
int dword_100B439C[] = { 0 }; // weak
char *off_100B43A0 = "0, 0, 0"; // weak
int dword_100B45A8[] = { 0 }; // weak
int dword_100B45AC[] = { 0 }; // weak
int dword_100B45B0[] = { 0 }; // weak
int dword_100B45B4[] = { 0 }; // weak
char off_100B45B8[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B4918[] = { '\x01' }; // weak
void *off_100B491C = &unk_10074DBC; // weak
char *off_100B4920[2] = { "2", "fail_robust_1" }; // weak
char off_100B4924[8] = { 'P', '', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100B49A8[] = { '\0' }; // weak
char byte_100B49A9[] = { '\0' }; // weak
int dword_100B49AC[] = { 0 }; // weak
char *off_100B49B0 = "0, 0, 0"; // weak
double dbl_100B4C18[] = {  0.0 }; // weak
double dbl_100B4C20[] = {  0.0 }; // weak
double dbl_100B4C28[] = {  0.0 }; // weak
int dword_100B4C30[] = { 0 }; // weak
char off_100B4C34[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100B5838[] = {  0.0 }; // weak
float flt_100B583C[] = {  0.0 }; // weak
float flt_100B5840[] = {  0.0 }; // weak
int dword_100B5844[] = { 0 }; // weak
char off_100B5848[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B5FD0[] = { 0 }; // weak
int dword_100B5FD4[] = { 0 }; // weak
int dword_100B5FD8[] = { 0 }; // weak
int dword_100B5FDC[] = { 0 }; // weak
char *off_100B5FE0 = "0, 0, 0"; // weak
__int16 word_100B6768[] = { 0 }; // weak
__int16 word_100B676A[] = { 0 }; // weak
__int16 word_100B676C[] = { 0 }; // weak
int dword_100B6770[] = { 0 }; // weak
char *off_100B6774 = "0, 0, 0"; // weak
int dword_100B6D78[] = { 0 }; // weak
int dword_100B6D7C[] = { 0 }; // weak
int dword_100B6D80[] = { 0 }; // weak
int dword_100B6D84[] = { 0 }; // weak
char off_100B6D88[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B7510[] = { 0 }; // weak
int dword_100B7514[] = { 0 }; // weak
int dword_100B7518[] = { 0 }; // weak
int dword_100B751C[] = { 0 }; // weak
int dword_100B7520[] = { 0 }; // weak
int dword_100B7524[] = { 0 }; // weak
int dword_100B7528[] = { 0 }; // weak
char off_100B752C[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B8130[] = { '\0' }; // weak
char byte_100B8131[] = { '\0' }; // weak
char byte_100B8132[] = { '\0' }; // weak
int dword_100B8134[] = { 0 }; // weak
char *off_100B8138 = "0, 0, 0"; // weak
int dword_100B85C0[] = { 0 }; // weak
int dword_100B85C4[] = { 0 }; // weak
int dword_100B85C8[] = { 0 }; // weak
int dword_100B85CC[] = { 0 }; // weak
char *off_100B85D0 = "0, 0, 0"; // weak
int dword_100B8D58[] = { 0 }; // weak
int dword_100B8D5C[] = { 0 }; // weak
int dword_100B8D60[] = { 0 }; // weak
int dword_100B8D64[] = { 0 }; // weak
char off_100B8D68[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100B90C8[] = { 0 }; // weak
__int16 word_100B90CA[] = { 0 }; // weak
__int16 word_100B90CC[] = { 0 }; // weak
int dword_100B90D0[] = { 0 }; // weak
char *off_100B90D4 = "0, 0, 0"; // weak
int dword_100B9388[] = { 0 }; // weak
int dword_100B938C[] = { 0 }; // weak
int dword_100B9390[] = { 0 }; // weak
int dword_100B9394[] = { 0 }; // weak
char off_100B9398[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100B96F8[] = { 0 }; // weak
int dword_100B96FC[] = { 0 }; // weak
int dword_100B9700[] = { 0 }; // weak
int dword_100B9704[] = { 0 }; // weak
int dword_100B9708[] = { 0 }; // weak
int dword_100B970C[] = { 0 }; // weak
int dword_100B9710[] = { 0 }; // weak
char off_100B9714[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100B9C78[] = { '\0' }; // weak
char byte_100B9C79[] = { '\0' }; // weak
char byte_100B9C7A[] = { '\0' }; // weak
int dword_100B9C7C[] = { 0 }; // weak
char *off_100B9C80 = "0, 0, 0"; // weak
int dword_100B9E88[] = { 0 }; // weak
int dword_100B9E8C[] = { 0 }; // weak
int dword_100B9E90[] = { 0 }; // weak
int dword_100B9E94[] = { 0 }; // weak
char off_100B9E98[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BA1F8[] = { '\x01' }; // weak
void *off_100BA1FC = &unk_10074DBC; // weak
void *off_100BA200 = &unk_10074DBC; // weak
char off_100BA204[8] = { '', '', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100BA248[] = { '\0' }; // weak
char byte_100BA249[] = { '\0' }; // weak
int dword_100BA24C[] = { 0 }; // weak
char *off_100BA250 = "0, 0, 0"; // weak
double dbl_100BA4B8[] = {  0.0 }; // weak
double dbl_100BA4C0[] = {  0.0 }; // weak
double dbl_100BA4C8[] = {  0.0 }; // weak
int dword_100BA4D0[] = { 0 }; // weak
char off_100BA4D4[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100BB0D8[] = {  0.0 }; // weak
float flt_100BB0DC[] = {  0.0 }; // weak
float flt_100BB0E0[] = {  0.0 }; // weak
int dword_100BB0E4[] = { 0 }; // weak
char off_100BB0E8[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BB870[] = { 0 }; // weak
int dword_100BB874[] = { 0 }; // weak
int dword_100BB878[] = { 0 }; // weak
int dword_100BB87C[] = { 0 }; // weak
char *off_100BB880 = "0, 0, 0"; // weak
__int16 word_100BC008[] = { 0 }; // weak
__int16 word_100BC00A[] = { 0 }; // weak
__int16 word_100BC00C[] = { 0 }; // weak
int dword_100BC010[] = { 0 }; // weak
char *off_100BC014 = "0, 0, 0"; // weak
int dword_100BC618[] = { 0 }; // weak
int dword_100BC61C[] = { 0 }; // weak
int dword_100BC620[] = { 0 }; // weak
int dword_100BC624[] = { 0 }; // weak
char off_100BC628[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BCDB0[] = { 0 }; // weak
int dword_100BCDB4[] = { 0 }; // weak
int dword_100BCDB8[] = { 0 }; // weak
int dword_100BCDBC[] = { 0 }; // weak
int dword_100BCDC0[] = { 0 }; // weak
int dword_100BCDC4[] = { 0 }; // weak
int dword_100BCDC8[] = { 0 }; // weak
char off_100BCDCC[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BD9D0[] = { '\0' }; // weak
char byte_100BD9D1[] = { '\0' }; // weak
char byte_100BD9D2[] = { '\0' }; // weak
int dword_100BD9D4[] = { 0 }; // weak
char *off_100BD9D8 = "0, 0, 0"; // weak
int dword_100BDE60[] = { 0 }; // weak
int dword_100BDE64[] = { 0 }; // weak
int dword_100BDE68[] = { 0 }; // weak
int dword_100BDE6C[] = { 0 }; // weak
char *off_100BDE70 = "0, 0, 0"; // weak
int dword_100BE5F8[] = { 0 }; // weak
int dword_100BE5FC[] = { 0 }; // weak
int dword_100BE600[] = { 0 }; // weak
int dword_100BE604[] = { 0 }; // weak
char off_100BE608[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100BE968[] = { 0 }; // weak
__int16 word_100BE96A[] = { 0 }; // weak
__int16 word_100BE96C[] = { 0 }; // weak
int dword_100BE970[] = { 0 }; // weak
char *off_100BE974 = "0, 0, 0"; // weak
int dword_100BEC28[] = { 0 }; // weak
int dword_100BEC2C[] = { 0 }; // weak
int dword_100BEC30[] = { 0 }; // weak
int dword_100BEC34[] = { 0 }; // weak
char off_100BEC38[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100BEF98[] = { 0 }; // weak
int dword_100BEF9C[] = { 0 }; // weak
int dword_100BEFA0[] = { 0 }; // weak
int dword_100BEFA4[] = { 0 }; // weak
int dword_100BEFA8[] = { 0 }; // weak
int dword_100BEFAC[] = { 0 }; // weak
int dword_100BEFB0[] = { 0 }; // weak
char off_100BEFB4[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BF518[] = { '\0' }; // weak
char byte_100BF519[] = { '\0' }; // weak
char byte_100BF51A[] = { '\0' }; // weak
int dword_100BF51C[] = { 0 }; // weak
char *off_100BF520 = "0, 0, 0"; // weak
int dword_100BF728[] = { 0 }; // weak
int dword_100BF72C[] = { 0 }; // weak
int dword_100BF730[] = { 0 }; // weak
int dword_100BF734[] = { 0 }; // weak
char off_100BF738[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100BFA98[] = { '\x01' }; // weak
void *off_100BFA9C = &unk_10074DBC; // weak
void *off_100BFAA0 = &unk_10074DBC; // weak
char off_100BFAA4[8] = { 'p', '', '\n', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100BFAE8[] = { '\0' }; // weak
char byte_100BFAE9[] = { '\0' }; // weak
int dword_100BFAEC[] = { 0 }; // weak
char *off_100BFAF0 = "0, 0, 0"; // weak
double dbl_100BFD58[] = {  0.0 }; // weak
double dbl_100BFD60[] = {  0.0 }; // weak
double dbl_100BFD68[] = {  0.0 }; // weak
int dword_100BFD70[] = { 0 }; // weak
char off_100BFD74[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100C0978[] = {  0.0 }; // weak
float flt_100C097C[] = {  0.0 }; // weak
float flt_100C0980[] = {  0.0 }; // weak
int dword_100C0984[] = { 0 }; // weak
char off_100C0988[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C1110[] = { 0 }; // weak
int dword_100C1114[] = { 0 }; // weak
int dword_100C1118[] = { 0 }; // weak
int dword_100C111C[] = { 0 }; // weak
char *off_100C1120 = "0, 0, 0"; // weak
__int16 word_100C18A8[] = { 0 }; // weak
__int16 word_100C18AA[] = { 0 }; // weak
__int16 word_100C18AC[] = { 0 }; // weak
int dword_100C18B0[] = { 0 }; // weak
char *off_100C18B4 = "0, 0, 0"; // weak
int dword_100C1EB8[] = { 0 }; // weak
int dword_100C1EBC[] = { 0 }; // weak
int dword_100C1EC0[] = { 0 }; // weak
int dword_100C1EC4[] = { 0 }; // weak
char off_100C1EC8[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C2650[] = { 0 }; // weak
int dword_100C2654[] = { 0 }; // weak
int dword_100C2658[] = { 0 }; // weak
int dword_100C265C[] = { 0 }; // weak
int dword_100C2660[] = { 0 }; // weak
int dword_100C2664[] = { 0 }; // weak
int dword_100C2668[] = { 0 }; // weak
char off_100C266C[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100C3270[] = { '\0' }; // weak
char byte_100C3271[] = { '\0' }; // weak
char byte_100C3272[] = { '\0' }; // weak
int dword_100C3274[] = { 0 }; // weak
char *off_100C3278 = "0, 0, 0"; // weak
int dword_100C3700[] = { 0 }; // weak
int dword_100C3704[] = { 0 }; // weak
int dword_100C3708[] = { 0 }; // weak
int dword_100C370C[] = { 0 }; // weak
char *off_100C3710 = "0, 0, 0"; // weak
int dword_100C3E98[] = { 0 }; // weak
int dword_100C3E9C[] = { 0 }; // weak
int dword_100C3EA0[] = { 0 }; // weak
int dword_100C3EA4[] = { 0 }; // weak
char off_100C3EA8[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100C4208[] = { 0 }; // weak
__int16 word_100C420A[] = { 0 }; // weak
__int16 word_100C420C[] = { 0 }; // weak
int dword_100C4210[] = { 0 }; // weak
char *off_100C4214 = "0, 0, 0"; // weak
int dword_100C44C8[] = { 0 }; // weak
int dword_100C44CC[] = { 0 }; // weak
int dword_100C44D0[] = { 0 }; // weak
int dword_100C44D4[] = { 0 }; // weak
char off_100C44D8[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100C4838[] = { 0 }; // weak
int dword_100C483C[] = { 0 }; // weak
int dword_100C4840[] = { 0 }; // weak
int dword_100C4844[] = { 0 }; // weak
int dword_100C4848[] = { 0 }; // weak
int dword_100C484C[] = { 0 }; // weak
int dword_100C4850[] = { 0 }; // weak
char off_100C4854[32] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100C4DB8[] = { '\0' }; // weak
char byte_100C4DB9[] = { '\0' }; // weak
char byte_100C4DBA[] = { '\0' }; // weak
int dword_100C4DBC[] = { 0 }; // weak
char *off_100C4DC0 = "0, 0, 0"; // weak
int dword_100C4FC8[] = { 0 }; // weak
int dword_100C4FCC[] = { 0 }; // weak
int dword_100C4FD0[] = { 0 }; // weak
int dword_100C4FD4[] = { 0 }; // weak
char off_100C4FD8[20] =
{
  '@',
  '',
  '\n',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100C5FB8; // weak
int dword_100C9194[] = { 0 }; // weak
_UNKNOWN off_100C9198; // weak
_UNKNOWN unk_100C9228; // weak
_UNKNOWN unk_100C922C; // weak
_UNKNOWN unk_100C9230; // weak
_UNKNOWN unk_100C9234; // weak
_UNKNOWN unk_100C9238; // weak
_UNKNOWN unk_100C923C; // weak
_UNKNOWN unk_100C9240; // weak
_UNKNOWN unk_100C9244; // weak
_UNKNOWN unk_100CACB8; // weak
int dword_100CACBC[] = { 0 }; // weak
char byte_100CAF58[] = { '\x01' }; // weak
__int16 word_100CAF5A[] = { 3020 }; // weak
int dword_100CEAD8 = 64; // weak
__int16 word_100CEADC[] = { 6782 }; // weak
__int16 word_100CEAE0[] = { 128 }; // weak
_UNKNOWN unk_100CEAFC; // weak
_DWORD dword_100CEB00[10] = { 64, 24, 62, 18, 65, 27525120, 27394467, 27721729, 27591078, 0 }; // idb
char *off_100D09A0 = "/shr_mem/iop_gtx_intf.shr"; // weak
_UNKNOWN unk_100D1748; // weak
int dword_100D174C[] = { 0 }; // weak
_UNKNOWN unk_100D1760; // weak
int dword_100D1764[] = { 0 }; // weak
_UNKNOWN unk_100D1788; // weak
int dword_100D178C[] = { 0 }; // weak
_UNKNOWN unk_100D17B8; // weak
int dword_100D17BC[] = { 0 }; // weak
_UNKNOWN unk_100D2368; // weak
_UNKNOWN unk_100D2369; // weak
_WORD dword_100D2478[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100D2878[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100D2C78[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100D3078[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100D3478[] = { 99 }; // weak
int dword_100D3878[] = { 25344 }; // weak
int dword_100D3C78[] = { 6488064 }; // weak
int dword_100D4078[] = { 1660944384 }; // weak
int dword_100D44A0[] = { 128 }; // weak
int dword_100D44B0[] = { 0 }; // weak
int dword_100D44C0[] = { 0 }; // weak
char byte_100D4531[] = { '\0' }; // weak
char byte_100D4532[] = { '\0' }; // weak
char byte_100D4533[] = { '\0' }; // weak
char byte_100D4534[] = { '\x10' }; // weak
int dword_100D4548[] = { 0 }; // weak
_UNKNOWN unk_100D45C0; // weak
_UNKNOWN unk_100D4A40; // weak
char byte_100D4AB8[] = { '\0' }; // weak
char byte_100D4BB8[] = { '\0' }; // weak
char byte_100D4CB8[] = { '\0' }; // weak
int dword_100D4DB8[] = { 0 }; // weak
int dword_100D4E30[] = { 0 }; // weak
int (__cdecl *off_100D4EB0)(int, int) = &sub_10043D00; // weak
int dword_100D5098[] = { 0 }; // weak
int dword_100D50E0[] = { 16 }; // weak
_UNKNOWN unk_100D5130; // weak
_UNKNOWN unk_100D51B0; // weak
_UNKNOWN unk_100D5230; // weak
_UNKNOWN unk_100D52A8; // weak
_UNKNOWN unk_100D5320; // weak
_UNKNOWN unk_100D6320; // weak
__int16 word_100D7290[] = { 1565 }; // weak
__int16 word_100D7294[] = { 534 }; // weak
char byte_100D7298[] = { '\x04' }; // weak
__int16 word_100D729A[] = { 6512 }; // weak
int dword_100D72B0[] = { 118000 }; // weak
_UNKNOWN unk_100D72D4; // weak
int dword_100D72D8[] = { 6829 }; // weak
__int16 word_100D8312[] = { 233 }; // weak
int dword_100D8318[] = { 6201 }; // weak
__int16 word_100DA034[] = { 114 }; // weak
__int16 word_100DA140[] = { 551 }; // weak
char byte_100DA32A[] = { '\x04' }; // weak
char byte_100DA32F[] = { '\a' }; // weak
int dword_100DF990[] = { 0 }; // weak
_UNKNOWN unk_100EE540; // weak
int dword_100EE544[] = { 3535 }; // weak
_UNKNOWN unk_100EE578; // weak
int dword_100EE57C[] = { 6813 }; // weak
_UNKNOWN unk_100EE5B0; // weak
int dword_100EE5B4[] = { 9036 }; // weak
_UNKNOWN unk_100EE5E8; // weak
int dword_100EE5EC[] = { 6763 }; // weak
char byte_100EE680[16] =
{
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\xFF',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100EE6F0; // weak
_UNKNOWN unk_100EE6F8; // weak
int (*off_100F028C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_100F02A8; // weak
void *off_100F0F00 = &unk_101E7440; // weak
_UNKNOWN unk_100F0F10; // weak
_UNKNOWN unk_100F0F70; // weak
wchar_t *off_100F1180 = L"         (((((                  H"; // weak
int dword_100F1290 = 1024; // weak
int dword_100F1294 = 4294966273; // weak
int dword_100F1298 = 53; // weak
int dword_100F129C = 11; // weak
int dword_100F12A0 = 64; // weak
int dword_100F12A4 = 1023; // weak
int dword_100F12A8 = 128; // weak
int dword_100F12AC = 4294967169; // weak
int dword_100F12B0 = 24; // weak
int dword_100F12B4 = 8; // weak
int dword_100F12B8 = 32; // weak
int dword_100F12BC = 127; // weak
_UNKNOWN unk_100F17C0; // weak
char byte_100F17C4 = '\0'; // weak
int dword_100F17C8 = 0; // weak
_UNKNOWN unk_100F17D0; // weak
char byte_100F18A0 = '\0'; // weak
char byte_100F18A8 = '\0'; // idb
int dword_100F28A8; // weak
_UNKNOWN unk_100F28C8; // weak
int dword_100FD0C8; // weak
int dword_100FD0CC; // weak
int dword_100FD0D0; // weak
char byte_100FD158; // weak
char byte_100FD159; // weak
int dword_100FD15C; // weak
int dword_100FD160; // weak
int dword_100FD164; // weak
int dword_100FD168; // weak
int dword_100FD16C; // weak
int dword_100FD170; // weak
_DWORD dword_1010F960[16]; // idb
int dword_1010F9A0[]; // weak
int dword_1010F9E0; // weak
int dword_1010F9E8[]; // weak
char byte_1010FA28; // weak
char byte_1010FA29; // weak
char byte_1010FB68; // weak
char byte_1010FB69; // weak
_UNKNOWN unk_1010FB6A; // weak
float flt_1010FB6C; // weak
int dword_1010FB70; // weak
__int16 word_1010FC78[]; // weak
char byte_1010FCA0[]; // weak
void (__cdecl *dword_10115208[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_10115228; // weak
__int16 word_1011A41C; // weak
__int16 word_1011A420; // weak
__int16 word_1011A424; // weak
int dword_1011A428; // weak
int dword_1011A434[]; // weak
int dword_1011A448; // weak
int dword_1011A44C; // weak
char byte_1011A450; // weak
int dword_1011A454; // weak
int dword_1011A458; // weak
int dword_1011A45C; // weak
int dword_1011A460; // weak
int dword_1011A464; // weak
int dword_1011A468; // weak
int dword_1011A46C; // weak
int dword_1011A470; // weak
int dword_1011A474; // weak
int dword_1011A478; // weak
int dword_1011A47C; // weak
int dword_1011A480; // weak
int dword_1011A698; // weak
_UNKNOWN unk_1011A6A0; // weak
char byte_1011A978[]; // weak
char byte_1011A979[]; // weak
char byte_1011A998[]; // weak
char byte_1011A999[]; // weak
_UNKNOWN unk_1011BBE0; // weak
_UNKNOWN unk_1011D590; // weak
int dword_10126F60; // weak
_UNKNOWN unk_101346B0; // weak
_UNKNOWN unk_101346B4; // weak
int dword_101346B8; // weak
int dword_10134724; // weak
int dword_10134728; // weak
int dword_1013472C; // weak
int dword_10134730; // weak
char byte_10134734; // weak
int dword_10134950[]; // weak
int dword_10134954; // weak
int dword_10134958; // weak
int dword_1013495C; // weak
int dword_10134960; // weak
int dword_10134964[]; // weak
int dword_10134968; // weak
int dword_1013496C; // weak
int dword_10134970; // weak
int dword_10134974; // weak
_UNKNOWN unk_10134978; // weak
char byte_10134A90; // idb
char byte_10134B90[254]; // idb
char byte_10134C8E[]; // weak
char byte_10134C8F[]; // weak
char byte_10135090[2800]; // idb
char byte_10135B80[1022]; // idb
char byte_10135F7E[]; // weak
char byte_10135F7F[]; // weak
char byte_10135F80[1022]; // idb
char byte_1013637E[]; // weak
char byte_1013637F[]; // weak
char byte_10136380[1022]; // idb
char byte_1013677E[]; // weak
char byte_1013677F[]; // weak
int dword_10139780[]; // weak
int dword_10139794[]; // weak
char byte_101397A8[2800]; // idb
char byte_1013A298[2800]; // idb
char byte_1013AD88[2800]; // idb
int dword_1013B878[]; // weak
int dword_1013B88C[]; // weak
char byte_1013B8A0[2796]; // idb
char byte_1013C38C[]; // weak
char byte_1013C390[559]; // idb
char byte_1013C5BF[]; // weak
int dword_1013CE80[]; // weak
int dword_1013CE94[]; // weak
char byte_1013CEA8[2800]; // idb
int dword_1013D998; // weak
_UNKNOWN unk_1013D9A0; // weak
_UNKNOWN unk_1013E4F8; // weak
int dword_10140860; // weak
_UNKNOWN unk_10140868; // weak
int dword_10141DA8; // weak
char byte_10141DB0[]; // weak
char byte_10141DB4[]; // weak
char byte_10141DB5[]; // weak
int dword_10141DBC[]; // weak
int dword_10141DC4[]; // weak
int dword_10141DF8; // weak
int dword_10141DFC; // weak
int dword_10141E00; // weak
int dword_10141E04; // weak
_UNKNOWN unk_10141E08; // weak
_UNKNOWN unk_10144D10; // weak
_UNKNOWN unk_10145210; // weak
_UNKNOWN unk_101452B8; // weak
_UNKNOWN unk_101452DC; // weak
_UNKNOWN unk_101452E4; // weak
_UNKNOWN unk_101452EC; // weak
int dword_101A5040; // weak
char byte_101A5048[]; // weak
char byte_101A5098[]; // weak
char byte_101AC3E8; // weak
char byte_101AC3E9; // weak
char byte_101AEC90[]; // weak
char byte_101AEC91[]; // weak
_UNKNOWN unk_101AED30; // weak
int dword_101AF000[]; // weak
int dword_101AF004[]; // weak
char byte_101AF520; // weak
char byte_101AF521; // weak
char byte_101AF522; // weak
char byte_101AF523; // weak
_UNKNOWN unk_101AF528; // weak
_UNKNOWN unk_101AF548; // weak
int dword_101B0604; // weak
int dword_101B0930; // weak
int dword_101B093C; // weak
int dword_101B0A98; // weak
int dword_101B0F60; // weak
int dword_101B0F6C; // weak
int dword_101B0F78; // weak
int dword_101B0F7C; // weak
int dword_101B0F80; // weak
int dword_101B0F9C; // weak
int dword_101B0FA0; // weak
int dword_101B0FA4; // weak
int dword_101B0FA8; // weak
int dword_101B0FAC; // weak
char byte_101B1070; // weak
int dword_101B1080; // weak
_UNKNOWN unk_101B1084; // weak
char byte_101E30A0; // weak
char byte_101E30A1; // weak
char byte_101E30A2; // weak
char byte_101E30A4; // weak
char byte_101E30AB; // weak
__int16 word_101E30AE; // weak
__int16 word_101E30B0; // weak
__int16 word_101E30B4; // weak
int dword_101E30B8; // weak
int dword_101E30BC; // weak
int dword_101E30D4; // weak
int dword_101E30E0; // weak
int dword_101E30E8; // weak
char byte_101E3228; // weak
int dword_101E327C; // weak
char byte_101E3280; // weak
int dword_101E32A0[]; // weak
_BYTE dword_101E32A4[1120]; // idb
int dword_101E3708; // weak
float flt_101E370C; // weak
int dword_101E3710; // weak
int dword_101E3714; // weak
float flt_101E3718; // weak
int dword_101E371C; // weak
int dword_101E3720; // weak
int dword_101E3724; // weak
float flt_101E3728; // weak
int dword_101E372C; // weak
float flt_101E3730; // weak
int dword_101E3734; // weak
float flt_101E3738; // weak
int dword_101E373C; // weak
int dword_101E3740; // weak
float flt_101E3744; // weak
int dword_101E3748; // weak
int dword_101E374C; // weak
int dword_101E3750; // weak
float flt_101E3754; // weak
int dword_101E3758; // weak
int dword_101E375C; // weak
float flt_101E3760; // weak
int dword_101E3764; // weak
int dword_101E3768; // weak
int dword_101E376C; // weak
int dword_101E3770; // weak
int dword_101E3774; // weak
float flt_101E3778; // weak
int dword_101E377C; // weak
float flt_101E3780; // weak
float flt_101E3784; // weak
float flt_101E3788; // weak
float flt_101E378C; // weak
int dword_101E3790; // weak
int dword_101E3794; // weak
int dword_101E3798; // weak
int dword_101E379C; // weak
float flt_101E37A0; // weak
int dword_101E37A4; // weak
int dword_101E37A8; // weak
char byte_101E37AC; // weak
int dword_101E37B0; // weak
char byte_101E37B4; // weak
int dword_101E37B8; // weak
char byte_101E37BC; // weak
int dword_101E37C0; // weak
_UNKNOWN unk_101E37E0; // weak
int dword_101E37E4[]; // weak
char byte_101E37F1[]; // weak
int dword_101E38A8; // weak
int dword_101E38AC; // weak
char byte_101E38B0; // weak
int dword_101E38C0[]; // weak
__int16 word_101E38C4[]; // weak
int dword_101E38C8[]; // weak
int dword_101E38CC; // weak
int dword_101E38D0; // weak
int dword_101E38D4; // weak
int dword_101E38D8; // weak
__int16 word_101E38DC; // weak
int dword_101E38E0; // weak
__int16 word_101E3924; // weak
int dword_101E3928; // weak
int dword_101E3944; // weak
__int16 word_101E3948; // weak
int dword_101E3950; // weak
__int16 word_101E3954; // weak
int dword_101E3988; // weak
int dword_101E39B8; // weak
int dword_101E3A00; // weak
int dword_101E3AA8; // weak
int dword_101E3AB4; // weak
int dword_101E3AC4; // weak
__int16 word_101E3AC8; // weak
int dword_101E3AD0; // weak
__int16 word_101E3AD4; // weak
int dword_101E3ADC; // weak
__int16 word_101E3AE0; // weak
int dword_101E3BE4; // weak
int dword_101E3C5C; // weak
__int16 word_101E3C60; // weak
int dword_101E3D04; // weak
__int16 word_101E3D08; // weak
_UNKNOWN unk_101E3FC8; // weak
_UNKNOWN unk_101E3FC9; // weak
_UNKNOWN unk_101E3FCA; // weak
__int16 word_101E3FE0[]; // weak
__int16 word_101E3FE2; // weak
__int16 word_101E3FE4; // weak
__int16 word_101E3FE6; // weak
__int16 word_101E3FE8; // weak
__int16 word_101E3FEA; // weak
__int16 word_101E3FEC; // weak
__int16 word_101E3FEE; // weak
__int16 word_101E4004; // weak
__int16 word_101E4006; // weak
__int16 word_101E4008; // weak
__int16 word_101E400A; // weak
__int16 word_101E400C; // weak
__int16 word_101E4016; // weak
__int16 word_101E4018; // weak
__int16 word_101E401A; // weak
__int16 word_101E401C; // weak
__int16 word_101E401E; // weak
__int16 word_101E4020; // weak
__int16 word_101E4022; // weak
__int16 word_101E4024; // weak
__int16 word_101E4026; // weak
__int16 word_101E4028; // weak
__int16 word_101E402A; // weak
__int16 word_101E402C; // weak
__int16 word_101E402E; // weak
__int16 word_101E4030; // weak
__int16 word_101E4032; // weak
__int16 word_101E4034; // weak
__int16 word_101E4036; // weak
__int16 word_101E4038; // weak
__int16 word_101E403A; // weak
__int16 word_101E403C; // weak
__int16 word_101E403E; // weak
__int16 word_101E4040; // weak
__int16 word_101E4042; // weak
__int16 word_101E4044; // weak
__int16 word_101E4046; // weak
__int16 word_101E4048; // weak
__int16 word_101E404A; // weak
__int16 word_101E404C; // weak
char byte_101E410C; // weak
char byte_101E410D; // weak
int dword_101E4110; // weak
char byte_101E4114; // weak
int dword_101E411C; // weak
_UNKNOWN unk_101E4120; // weak
char byte_101E5EE0; // weak
int dword_101E5F0C; // weak
float flt_101E5F30; // weak
int dword_101E5F34; // weak
float flt_101E5F38; // weak
char byte_101E5F3C; // weak
char byte_101E5F3D; // weak
int dword_101E7410; // weak
int dword_101E7414; // weak
void *dword_101E7418; // idb
int dword_101E741C; // weak
int dword_101E7420; // weak
int dword_101E7424; // weak
char byte_101E7428[]; // weak
void *dword_101E742C; // idb
int dword_101E8440; // weak
int dword_101E845C; // weak
UINT uNumber; // idb
int dword_101E8480[]; // weak
int dword_101E8580; // weak
int dword_101E8598; // weak


//----- (10001000) --------------------------------------------------------
char __cdecl sub_10001000(int a1)
{
  int *v1; // ecx@1
  __int16 v2; // bx@1
  __int16 v3; // di@1
  char result; // al@1
  bool v5; // zf@1
  __int16 v6; // bp@1
  int v7; // ecx@3
  __int16 v8; // si@4
  __int16 v9; // dx@5
  char v10; // [sp+13h] [bp-1h]@1
  int v11; // [sp+18h] [bp+4h]@1

  v1 = (int *)a1;
  v2 = *(_WORD *)(a1 + 30);
  v3 = *(_WORD *)(a1 + 28);
  result = 0;
  v5 = a1 == dword_101E3708;
  v10 = 0;
  v6 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 34) - 1;
  v11 = (unsigned __int16)(*(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 32) - 1);
  if ( v5 )
  {
    result = 1;
    v10 = 1;
  }
  v7 = *v1;
  if ( v7 )
  {
    while ( 1 )
    {
      v8 = *(_WORD *)(v7 + 28);
      if ( v3 >= v8 )
      {
        v9 = *(_WORD *)(v7 + 30);
        if ( v2 >= v9 && v6 <= *(_WORD *)(v7 + 34) + v9 - 1 && (signed __int16)v11 <= *(_WORD *)(v7 + 32) + v8 - 1 )
          break;
      }
      v7 = *(_DWORD *)v7;
      if ( !v7 )
        return v10;
    }
    result = 1;
  }
  return result;
}
// 101E3708: using guessed type int dword_101E3708;

//----- (100010B0) --------------------------------------------------------
bool __cdecl sub_100010B0(int a1, int a2)
{
  char v2; // al@1

  v2 = *(_BYTE *)(a2 + 24);
  return v2 == 1 || v2 == 3;
}

//----- (100010D0) --------------------------------------------------------
int __usercall sub_100010D0@<eax>(int result@<eax>, int a2@<esi>)
{
  signed int v2; // ST1C_4@2
  float v3; // ST10_4@2
  float v4; // ST08_4@2

  if ( *(_BYTE *)(result + 11) )
  {
    j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
    j_gdi_pvg_matrix_mode(51);
    ((void (*)(void))j_gdi_pvg_load_identity)();
    v2 = *(_WORD *)(a2 + 32);
    v3 = (double)*(_WORD *)(a2 + 34);
    v4 = (double)v2;
    sub_100049B0(0.0, v4, 0.0, v3, 0.0, 1.0);
    j_gdi_pvg_matrix_mode(52);
    j_gdi_pvg_load_identity(v2);
    if ( (*(_BYTE *)(a2 + 24) & 3) == 2 )
      result = j_gdi_pvg_viewport(0, 0, *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
    else
      result = j_gdi_pvg_viewport(*(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
  }
  return result;
}
// 10004970: using guessed type int __cdecl j_gdi_pvg_load_identity(_DWORD);
// 10004990: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 100049A0: using guessed type int __cdecl j_gdi_pvg_matrix_mode(_DWORD);
// 10004A00: using guessed type int __cdecl j_gdi_pvg_viewport(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10001180) --------------------------------------------------------
char __cdecl sub_10001180(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int v6; // eax@2

  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 24) = a6;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) = a5;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) = a4;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 28) = a2;
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 30) = a3;
  switch ( a6 & 3 )
  {
    case 0:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = sub_100027E0(a1, a4, a5);
      LOBYTE(v6) = -1;
      if ( *(_DWORD *)(a1 + 24) == -1 || *(_BYTE *)(a1 + 11) != 1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = -1;
      }
      else
      {
        sub_10004D00();
        sub_10004D50(1);
        v6 = sub_10004CC0(a4, a5, 57);
        *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      }
      break;
    case 1:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = dword_100FD0C8;
      v6 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = v6;
      break;
    case 2:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      sub_10004D00();
      sub_10004D50(1);
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 52) = sub_10004CC0(a4, a5, 59);
      LOBYTE(v6) = sub_100010D0(a1, *(_DWORD *)(a1 + 56));
      break;
    case 3:
      *(_DWORD *)(*(_DWORD *)(a1 + 56) + 48) = 0;
      v6 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)(v6 + 52) = *(_DWORD *)(a1 + 24);
      break;
    default:
      LOBYTE(v6) = sub_10004C50(".\\cdp_cnvs_utl.c", 250, 1, 0);
      break;
  }
  return v6;
}
// 100FD0C8: using guessed type int dword_100FD0C8;

//----- (100012C0) --------------------------------------------------------
char __cdecl sub_100012C0(int a1, int a2)
{
  __int64 v2; // rax@4
  char result; // al@4
  int v4; // eax@5
  int v5; // eax@6
  int v6; // edx@6
  int v7; // eax@7
  int v8; // esi@9

  if ( !a2 )
    sub_10004C50(".\\cdp_cnvs_utl.c", 388, 1, 0);
  switch ( *(_BYTE *)(a2 + 24) & 3 )
  {
    case 0:
      *(_WORD *)(a1 + 270) = *(_WORD *)(a2 + 32);
      *(_WORD *)(a1 + 268) = *(_WORD *)(a2 + 34);
      *(_BYTE *)(a1 + 272) = 8;
      v2 = *(_WORD *)(a2 + 32) + 255;
      *(_WORD *)(a1 + 274) = (unsigned __int16)((BYTE4(v2) + (signed int)v2) >> 8) << 8;
      *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 48);
      *(_BYTE *)(a1 + 273) = 0;
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      *(_WORD *)(a1 + 434) = 0;
      *(_WORD *)(a1 + 432) = 0;
      result = 1;
      break;
    case 1:
      v4 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v4 + 8) != *(_DWORD *)(a1 + 44) )
      {
        *(_DWORD *)(v4 + 52) = *(_DWORD *)(a1 + 24);
        sub_100010D0(a1, *(_DWORD *)(a1 + 56));
        v5 = *(_DWORD *)(a1 + 56);
        v6 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 52) = v6;
      }
      *(_DWORD *)(a1 + 264) = dword_100FD0C8;
      v7 = a1 + 264;
      *(_DWORD *)(v7 + 4) = *(&dword_100FD0C8 + 1);
      *(_DWORD *)(v7 + 8) = *(&dword_100FD0C8 + 2);
      *(_DWORD *)(a1 + 444) = a1 + 264;
      *(_WORD *)(a1 + 418) = 0;
      *(_WORD *)(a1 + 416) = 0;
      *(_DWORD *)(a1 + 420) = *(_DWORD *)(a1 + 268);
      sub_10006310(a1 + 392, *(_WORD *)(a2 + 28), *(_WORD *)(a2 + 30), *(_WORD *)(a2 + 32), *(_WORD *)(a2 + 34));
      *(_WORD *)(a1 + 434) = *(_WORD *)(a2 + 28);
      *(_WORD *)(a1 + 432) = *(_WORD *)(a2 + 30);
      result = 1;
      break;
    case 2:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      result = 1;
      break;
    case 3:
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 52));
      v8 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(v8 + 8) == *(_DWORD *)(a1 + 44) )
        goto LABEL_12;
      sub_100010D0(a1, v8);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 8);
      result = 1;
      break;
    default:
      sub_10004C50(".\\cdp_cnvs_utl.c", 473, 1, 0);
LABEL_12:
      result = 1;
      break;
  }
  return result;
}
// 10004990: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 100FD0C8: using guessed type int dword_100FD0C8;

//----- (100014B0) --------------------------------------------------------
unsigned int sub_100014B0()
{
  int *v0; // ecx@1
  unsigned int result; // eax@1
  int v2; // ecx@3
  int v3; // ecx@3
  int v4; // ecx@3
  int v5; // ecx@3
  int v6; // ecx@3
  int v7; // edx@3

  v0 = dword_101E32A4;
  result = 0;
  do
  {
    *(v0 - 1) = 0;
    *(_BYTE *)v0 = 0;
    v0 += 2;
  }
  while ( (signed int)v0 < (signed int)&flt_101E370C );
  do
  {
    v2 = dword_1005DDA0[result];
    dword_101E32A0[2 * v2] = *(int *)((char *)&off_1005DDA4 + result * 4);
    dword_101E32A4[2 * v2] = dword_1005DDA8[result];
    v3 = dword_1005DDAC[result];
    dword_101E32A0[2 * v3] = *(int *)((char *)&off_1005DDB0 + result * 4);
    dword_101E32A4[2 * v3] = dword_1005DDB4[result];
    v4 = dword_1005DDB8[result];
    dword_101E32A0[2 * v4] = *(int *)((char *)&off_1005DDBC + result * 4);
    dword_101E32A4[2 * v4] = dword_1005DDC0[result];
    v5 = dword_1005DDC4[result];
    dword_101E32A0[2 * v5] = *(int *)((char *)&off_1005DDC8 + result * 4);
    dword_101E32A4[2 * v5] = dword_1005DDCC[result];
    v6 = dword_1005DDD0[result];
    dword_101E32A0[2 * v6] = *(int *)((char *)&off_1005DDD4 + result * 4);
    v7 = dword_1005DDD8[result];
    result += 15;
    dword_101E32A4[2 * v6] = v7;
  }
  while ( result < 45 );
  return result * 4;
}
// 1005DDA0: using guessed type int dword_1005DDA0[];
// 1005DDA4: using guessed type int (__cdecl *off_1005DDA4)(int, int, int, int, int);
// 1005DDA8: using guessed type int dword_1005DDA8[];
// 1005DDAC: using guessed type int dword_1005DDAC[];
// 1005DDB0: using guessed type int (__cdecl *off_1005DDB0)(int, int, int, int, int);
// 1005DDB4: using guessed type int dword_1005DDB4[];
// 1005DDB8: using guessed type int dword_1005DDB8[];
// 1005DDBC: using guessed type int (__cdecl *off_1005DDBC)(int, int, int, int, int);
// 1005DDC0: using guessed type int dword_1005DDC0[];
// 1005DDC4: using guessed type int dword_1005DDC4[];
// 1005DDC8: using guessed type int (__cdecl *off_1005DDC8)(int, int, int, int, int);
// 1005DDCC: using guessed type int dword_1005DDCC[];
// 1005DDD0: using guessed type int dword_1005DDD0[];
// 1005DDD4: using guessed type int (__cdecl *off_1005DDD4)(int, int, int, int, int);
// 1005DDD8: using guessed type int dword_1005DDD8[];
// 101E32A0: using guessed type int dword_101E32A0[];
// 101E32A4: using guessed type int dword_101E32A4[];
// 101E370C: using guessed type float flt_101E370C;

//----- (10001580) --------------------------------------------------------
int __cdecl sub_10001580(int a1)
{
  int result; // eax@1

  result = a1;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 3) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 10) = 0;
  *(_BYTE *)(a1 + 7) = 1;
  *(_BYTE *)(a1 + 8) = 0;
  return result;
}

//----- (100015B0) --------------------------------------------------------
int __cdecl sub_100015B0(int a1, int a2)
{
  byte_101E3280 = 0;
  sub_1001CF70(&unk_100F17C0);
  return nullsub_1(a1, a2);
}
// 101E3280: using guessed type char byte_101E3280;

//----- (100015D0) --------------------------------------------------------
int __cdecl sub_100015D0(int a1, char *a2, int a3, int a4)
{
  if ( !a2 )
    sub_10004C50(".\\cdp_main.c", 890, 1, 0);
  if ( a3 > 0 )
    *((_DWORD *)a2 + 3) = sub_10002760(a1, a3);
  *((_DWORD *)a2 + 14) = sub_10002760(a1, 4 * a4 + 4);
  a2[68] = a4;
  a2[231] = 0;
  if ( a4 > 0 )
  {
    *((_DWORD *)a2 + 15) = sub_10002760(a1, 4 * a4);
    *((_DWORD *)a2 + 16) = sub_10002760(a1, a4);
  }
  return *((_DWORD *)a2 + 3);
}

//----- (10001660) --------------------------------------------------------
char __cdecl sub_10001660(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 1;
  v9 = 1000;
  v4 = sub_10004EF0(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10004C50(".\\cdp_main.c", 1068, 0, 0);
  return v4;
}

//----- (100016D0) --------------------------------------------------------
char __cdecl sub_100016D0(int a1, int a2, int a3)
{
  int v3; // ST08_4@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-14h]@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  v8 = 0;
  v6 = a2;
  v7 = a3;
  v3 = *(_DWORD *)(a1 + 64);
  v10 = 2;
  v9 = 1000;
  v4 = sub_10004EF0(v3, (int)&v6);
  if ( v4 )
    LOBYTE(v4) = sub_10004C50(".\\cdp_main.c", 1136, 0, 0);
  return v4;
}

//----- (10001740) --------------------------------------------------------
int sub_10001740()
{
  int result; // eax@1

  result = sub_10004DF0();
  dword_100F17C8 = result;
  byte_100F17C4 = 0;
  return result;
}
// 100F17C4: using guessed type char byte_100F17C4;
// 100F17C8: using guessed type int dword_100F17C8;

//----- (10001760) --------------------------------------------------------
_DWORD *__cdecl sub_10001760(int a1)
{
  return sub_1001CFB0(&unk_100F17C0, a1);
}

//----- (10001780) --------------------------------------------------------
unsigned int __cdecl sub_10001780(int a1, int a2, int a3)
{
  unsigned int result; // eax@1

  result = (a3 * (1000 / *(_WORD *)(a1 + 20)) + 500) / 1000;
  if ( result >= 1 )
  {
    if ( result >= 0xFF )
      result = 255;
    *(_BYTE *)(a2 + 243) = result;
    *(_BYTE *)(a2 + 244) = result;
  }
  else
  {
    result = 1;
    *(_BYTE *)(a2 + 243) = 1;
    *(_BYTE *)(a2 + 244) = 1;
  }
  return result;
}

//----- (100017F0) --------------------------------------------------------
void __usercall sub_100017F0(int a1@<esi>)
{
  if ( *(_BYTE *)(a1 + 11) )
  {
    sub_10004960();
    sub_10004D00();
    *(_DWORD *)(a1 + 28) = sub_10004CC0(*(_WORD *)(a1 + 16), *(_WORD *)(a1 + 14), 57);
  }
}

//----- (10001820) --------------------------------------------------------
char __usercall sub_10001820@<al>(int a1@<esi>)
{
  _WORD *v1; // eax@1
  int v2; // edi@1
  void *v3; // ecx@1
  int v4; // eax@1
  int v5; // eax@9
  char result; // al@13
  char v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v1 = *(_WORD **)(a1 + 52);
  v8 = 2;
  byte_101B1070 = *v1 == -32749;
  byte_101E3280 = *(_BYTE *)(*(_DWORD *)(a1 + 52) + 8);
  v2 = *(_DWORD *)(a1 + 56);
  sub_100050D0(9129, &v7, 2, &v8);
  v4 = *(_DWORD *)(a1 + 64);
  if ( (v4 == 1 || v4 == 9) && sub_1001D9E0(v3) != 2 && v7 & 0x1C )
  {
    byte_101B1070 = 0;
    byte_101E3280 = 0;
  }
  if ( *(_DWORD *)(a1 + 64) == 1 && sub_1001D660() )
  {
    byte_101B1070 = 0;
    byte_101E3280 = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 238) = 1;
  }
  v5 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 56) = v5;
  if ( v5 && *(_BYTE *)(v5 + 230) != -1 && !*(_BYTE *)(v5 + 238) )
  {
    sub_1001D090(a1, (char *)v5, (int)&unk_10075E7C);
    *(_BYTE *)(a1 + 1) = 1;
  }
  *(_DWORD *)(a1 + 56) = v2;
  result = sub_10004750(a1);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 101B1070: using guessed type char byte_101B1070;
// 101E3280: using guessed type char byte_101E3280;

//----- (10001900) --------------------------------------------------------
void __usercall sub_10001900(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  __int64 v3; // rax@8

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 != -1 )
  {
    if ( *(_BYTE *)(a1 + 24) & 3 )
    {
      if ( (*(_BYTE *)(a1 + 24) & 3) == 2 )
        sub_100048C0(v2, *(_WORD *)(a1 + 28), *(_WORD *)(a1 + 30), 0, 0, *(_WORD *)(a1 + 32), *(_WORD *)(a1 + 34));
    }
    else if ( *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
    {
      j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 52));
      v3 = *(_WORD *)(a1 + 32) + 255;
      sub_10004910(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(a1 + 34), 57, 15, *(_DWORD *)(a1 + 48));
      j_gdi_pvg_make_window_current(*(_DWORD *)(a2 + 24));
      sub_100048C0(
        *(_DWORD *)(a1 + 52),
        *(_WORD *)(a1 + 28),
        *(_WORD *)(a1 + 30),
        0,
        0,
        *(_WORD *)(a1 + 32),
        *(_WORD *)(a1 + 34));
    }
  }
}
// 10004990: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);

//----- (100019D0) --------------------------------------------------------
void __usercall sub_100019D0(int a1@<esi>, int a2)
{
  __int16 v2; // ST1C_2@5
  __int16 v3; // ST14_2@5
  __int16 v4; // ST10_2@5
  int v5; // [sp+0h] [bp-Ch]@5
  __int16 v6; // [sp+4h] [bp-8h]@5
  __int16 v7; // [sp+6h] [bp-6h]@5
  char v8; // [sp+8h] [bp-4h]@5
  char v9; // [sp+9h] [bp-3h]@5
  __int16 v10; // [sp+Ah] [bp-2h]@5

  if ( !(*(_BYTE *)(a1 + 24) & 3) && *(_DWORD *)(a1 + 48) && *(_BYTE *)(a1 + 26) && !sub_10001000(a1) )
  {
    v2 = *(_WORD *)(a1 + 34);
    v7 = *(_WORD *)(a1 + 32);
    v3 = *(_WORD *)(a1 + 30);
    v4 = *(_WORD *)(a1 + 28);
    v10 = (unsigned __int16)((v7 + 255) / 256) << 8;
    v5 = *(_DWORD *)(a1 + 48);
    v6 = v2;
    v8 = 8;
    v9 = 0;
    sub_10006420(a2 + 392, (int)&v5, 0, 0, v4, v3, v7, v2);
  }
}

//----- (10001A70) --------------------------------------------------------
int __usercall sub_10001A70@<eax>(int a1@<edi>, int a2)
{
  int v2; // esi@1
  __int64 v3; // rax@8
  int result; // eax@11

  v2 = *(_DWORD *)(a1 + 48);
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)(v2 + 4) )
  {
    if ( !*(_DWORD *)(v2 + 4) )
      break;
    if ( sub_100010B0(a1, v2) )
      break;
  }
  if ( *(_DWORD *)(a1 + 24) != -1 )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 24));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
    if ( v2 )
    {
      if ( (*(_BYTE *)(v2 + 24) & 3) == 1 )
      {
        j_gdi_pvg_make_window_current(*(_DWORD *)(v2 + 52));
        v3 = *(_WORD *)(a1 + 16) + 255;
        sub_10004910(0, 0, (BYTE4(v3) + (signed int)v3) >> 8 << 8, *(_WORD *)(v2 + 34), 57, 15, *(_DWORD *)(v2 + 48));
        j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 24));
        sub_100048C0(
          *(_DWORD *)(v2 + 52),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 28),
          *(_WORD *)(v2 + 30),
          *(_WORD *)(v2 + 32),
          *(_WORD *)(v2 + 34));
      }
      nullsub_1(a1, 1);
      do
      {
        sub_10001900(v2, a1);
        v2 = *(_DWORD *)v2;
      }
      while ( v2 );
    }
    result = nullsub_1(a1, 0);
    goto LABEL_21;
  }
  if ( *(_BYTE *)(a1 + 11) )
  {
    j_gdi_pvg_make_window_active(*(_DWORD *)(a1 + 28));
    j_gdi_pvg_make_window_current(*(_DWORD *)(a1 + 28));
  }
  if ( v2 && *(_BYTE *)(v2 + 26) )
    nullsub_1(a1, 1);
  *(_DWORD *)(a1 + 444) = a2;
  *(_WORD *)(a1 + 418) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 4);
  *(_WORD *)(a1 + 434) = 0;
  for ( *(_WORD *)(a1 + 432) = 0; v2; v2 = *(_DWORD *)v2 )
    sub_100019D0(v2, a1);
  result = nullsub_1(a1, 0);
  if ( *(_BYTE *)(a1 + 11) )
  {
    result = sub_10004910(
               0,
               0,
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 10),
               *(_WORD *)(*(_DWORD *)(a1 + 444) + 4),
               57,
               15,
               **(_DWORD **)(a1 + 444));
LABEL_21:
    if ( *(_BYTE *)(a1 + 11) )
      result = j_gdi_pvg_update_display_wdw();
  }
  *(_BYTE *)(a1 + 392) = 0;
  return result;
}
// 10004980: using guessed type int __cdecl j_gdi_pvg_make_window_active(_DWORD);
// 10004990: using guessed type int __cdecl j_gdi_pvg_make_window_current(_DWORD);
// 100049F0: using guessed type int j_gdi_pvg_update_display_wdw(void);

//----- (10001C40) --------------------------------------------------------
char __thiscall sub_10001C40(int this)
{
  char result; // al@1

  result = 0;
  if ( !*(_BYTE *)(*(_DWORD *)(this + 56) + 26) && **(_WORD **)(this + 52) == -32696 )
  {
    result = 1;
    *(_BYTE *)(this + 6) = 2;
  }
  return result;
}

//----- (10001C60) --------------------------------------------------------
signed int __cdecl sub_10001C60(int a1, int a2)
{
  const void *v2; // edx@1
  int v3; // ebx@1
  char v4; // al@4
  char v6; // al@13
  char v7; // al@14
  int v8; // [sp-Ch] [bp-FCh]@15
  __int16 *v9; // [sp-8h] [bp-F8h]@15
  int v10; // [sp+Ch] [bp-E4h]@1
  __int16 v11; // [sp+18h] [bp-D8h]@7
  int v12; // [sp+1Ch] [bp-D4h]@12

  v2 = (const void *)a2;
  v3 = *(_DWORD *)(a2 + 4);
  v10 = 0;
  if ( !v3 )
  {
    if ( *(_WORD *)a2 > 0x8001u && *(_WORD *)a2 < 0x800Du )
    {
      v3 = *(_DWORD *)(a1 + 48);
      v4 = 1;
      goto LABEL_7;
    }
    v3 = 0;
  }
  v4 = 0;
LABEL_7:
  qmemcpy(&v11, (const void *)a2, 0xCCu);
  if ( !v4 )
  {
    sub_10001660(a1, (int)&v11, 204);
    return 1;
  }
  if ( v3 )
  {
    while ( 1 )
    {
      qmemcpy(&v11, v2, 0xCCu);
      v12 = v3;
      if ( v11 != -32760 )
        break;
      v6 = *(_BYTE *)(v3 + 243);
      if ( v6 )
      {
        v7 = v6 - 1;
        *(_BYTE *)(v3 + 243) = v7;
        if ( !v7 )
        {
          v11 = -32648;
          v9 = &v11;
          *(_BYTE *)(v3 + 243) = *(_BYTE *)(v3 + 244);
          v8 = a1;
LABEL_17:
          sub_10001660(v8, (int)v9, 204);
          ++v10;
          goto LABEL_18;
        }
      }
LABEL_18:
      if ( sub_100010B0(a1, v3) )
        return v10;
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        return v10;
      v2 = (const void *)a2;
    }
    v9 = &v11;
    v8 = a1;
    goto LABEL_17;
  }
  return v10;
}

//----- (10001DB0) --------------------------------------------------------
char __cdecl sub_10001DB0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_10001660(a1, (int)&v4, 8);
}

//----- (10001DE0) --------------------------------------------------------
char __cdecl sub_10001DE0(int a1, int a2, __int16 a3)
{
  __int16 v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v5 = a2;
  v4 = a3;
  return sub_100016D0(a1, (int)&v4, 8);
}

//----- (10001E10) --------------------------------------------------------
char __cdecl sub_10001E10(int a1)
{
  int v1; // eax@1
  int v2; // ecx@2
  __int16 v3; // dx@2
  unsigned int v4; // ebx@3
  _DWORD *v5; // eax@3
  char v6; // dl@3
  __int16 v7; // ax@10
  unsigned __int16 v8; // cx@14
  int v9; // eax@31
  int v10; // eax@31
  int v11; // eax@41
  __int16 v12; // ax@48
  char v13; // al@52
  _WORD *v14; // edx@55
  int v15; // ebp@58
  int v17; // [sp+0h] [bp-10h]@0
  int v18; // [sp+0h] [bp-10h]@51

  v1 = *(_DWORD *)(a1 + 52);
  if ( *(_WORD *)v1 < 0x8000u )
  {
    v2 = *(_DWORD *)(v1 + 4);
    v3 = *(_WORD *)(v1 + 8);
    *(_WORD *)v1 = -32670;
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(*(_DWORD *)(a1 + 52) + 12) = v2;
    *(_WORD *)(*(_DWORD *)(a1 + 52) + 8) = v3;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  sub_1001CF80((int *)&unk_100F17C0, a1);
  v5 = *(_DWORD **)(a1 + 32);
  v6 = 0;
  if ( v5 )
  {
    while ( *(_DWORD **)(*(_DWORD *)(a1 + 52) + 4) != v5 )
    {
      v5 = (_DWORD *)*v5;
      if ( !v5 )
        goto LABEL_8;
    }
    v6 = 1;
  }
LABEL_8:
  if ( v4 )
  {
    if ( !v6 )
    {
      v7 = **(_WORD **)(a1 + 52);
      if ( v7 != -32703 )
      {
        if ( v7 == -32744 )
          return v7;
        v4 = 0;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  LOBYTE(v7) = sub_100046D0();
  if ( !(_BYTE)v7 )
  {
    v8 = **(_WORD **)(a1 + 52);
    switch ( **(_WORD **)(a1 + 52) )
    {
      case 0x8013:
      case 0x8014:
        sub_10001820(a1);
        goto LABEL_40;
      case 0x8018:
        if ( *(_DWORD *)(a1 + 24) != -1 && (!(*(_BYTE *)(v4 + 24) & 3) || (*(_BYTE *)(v4 + 24) & 3) == 2) )
          j_gdi_pvg_destroy_window(*(_DWORD *)(v4 + 52));
        if ( v4 != *(_DWORD *)(a1 + 32) && *(_DWORD *)(v4 + 4) )
        {
          *(_DWORD *)(a1 + 48) = *(_DWORD *)(v4 + 4);
          **(_DWORD **)(v4 + 4) = 0;
        }
        else
        {
          sub_10001580(a1);
        }
        goto LABEL_40;
      case 0x8022:
      case 0x8078:
        if ( *(_BYTE *)(a1 + 4) || v4 && sub_10001000(v4) )
          v4 = 0;
        if ( *(_DWORD *)(a1 + 64) == 1 && sub_1001D660() != byte_100F17C4 )
        {
          **(_WORD **)(a1 + 52) = -32734;
          byte_100F17C4 = sub_1001D660();
        }
        goto LABEL_40;
      case 0x8041:
        v9 = sub_10002760(a1, 332);
        v4 = v9;
        qmemcpy((void *)v9, &unk_1005E428, 0x14Cu);
        *(_DWORD *)(v9 + 8) = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8);
        v10 = *(_DWORD *)(a1 + 48);
        if ( v10 )
        {
          *(_DWORD *)(v4 + 4) = v10;
          **(_DWORD **)(a1 + 48) = v4;
          *(_BYTE *)(v4 + 243) = *(_BYTE *)(*(_DWORD *)(v4 + 4) + 243);
        }
        if ( !*(_DWORD *)(a1 + 32) )
          *(_DWORD *)(a1 + 32) = v4;
        --*(_BYTE *)(a1 + 4);
        *(_DWORD *)(a1 + 48) = v4;
        goto LABEL_40;
      default:
        if ( !v4 )
        {
          if ( v8 <= 0x800Eu || v8 >= 0xFFFFu )
            goto LABEL_67;
          v4 = *(_DWORD *)(a1 + 48);
LABEL_40:
          if ( !v4 )
            goto LABEL_67;
        }
        v11 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)(a1 + 56) = v4;
        *(_BYTE *)(a1 + 6) = 1;
        *(_DWORD *)(v11 + 4) = v4;
        if ( **(_WORD **)(a1 + 52) == -32665 )
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 237) = 0;
        nullsub_1(a1, v17);
        if ( *(_BYTE *)(a1 + 6) == 1 && !sub_10001C40(a1) )
          (*(void (__cdecl **)(int))(v4 + 8))(a1);
        if ( !v4 || v4 > *(_DWORD *)(a1 + 48) && (v12 = **(_WORD **)(a1 + 52), v12 != -32703) && v12 != -32744 )
        {
LABEL_67:
          v4 = 0;
          *(_DWORD *)(a1 + 56) = 0;
        }
        LOBYTE(v7) = nullsub_1(a1, v17);
        if ( v4 )
        {
          v13 = *(_BYTE *)(a1 + 6);
          if ( v13 == 1 || v13 == 3 )
            nullsub_1(a1, v18);
          v14 = *(_WORD **)(a1 + 52);
          if ( *v14 == 32792 )
          {
            LOBYTE(v7) = sub_10002420(0, v4);
            if ( !*(_DWORD *)(a1 + 32) )
              *(_DWORD *)(a1 + 56) = 0;
            *(_BYTE *)(a1 + 1) = 1;
          }
          else if ( *v14 == 32871 )
          {
            LOBYTE(v7) = sub_10001DB0(a1, *(_DWORD *)(a1 + 56), -32734);
          }
          else
          {
            v7 = *v14 + 32648;
            if ( *v14 == 32888 )
            {
              v15 = *(_DWORD *)(a1 + 56);
              if ( v15 )
                *(_BYTE *)(v15 + 26) = 1;
            }
          }
        }
        break;
    }
  }
  return v7;
}
// 10004CF0: using guessed type int __cdecl j_gdi_pvg_destroy_window(_DWORD);
// 100F17C4: using guessed type char byte_100F17C4;

//----- (10002140) --------------------------------------------------------
int __usercall sub_10002140@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  int result; // eax@1
  __int16 v3; // ax@2
  bool v4; // al@4
  char v5; // [sp+4h] [bp-4h]@1

  v1 = a1;
  for ( result = sub_10004DA0(*(_DWORD *)(a1 + 52), (int)&v5);
        result != 1;
        result = sub_10004DA0(*(_DWORD *)(v1 + 52), (int)&v5) )
  {
    v3 = **(_WORD **)(v1 + 52);
    v4 = v3 == -32696 || v3 == -32734;
    *(_BYTE *)(v1 + 10) = v4;
    sub_10001E10(v1);
    if ( *(_BYTE *)(v1 + 6) != 1 && *(_BYTE *)(v1 + 10) && (*(_BYTE *)(v1 + 392) || *(_BYTE *)(v1 + 1)) )
    {
      sub_10001A70(v1, (int)&dword_100FD0C8);
      *(_BYTE *)(v1 + 10) = 0;
    }
  }
  return result;
}
// 100FD0C8: using guessed type int dword_100FD0C8;

//----- (100021D0) --------------------------------------------------------
void __noreturn sub_100021D0()
{
  void *v0; // ecx@8
  unsigned int v1; // esi@16
  int v2; // eax@19
  int v3; // [sp+10h] [bp-ECh]@1
  char v4; // [sp+14h] [bp-E8h]@9
  char v5; // [sp+18h] [bp-E4h]@5

  dword_101E327C = (int)&dword_101B1080;
  sub_10004FD0(&v3);
  if ( !(v3 & 0x10) )
    sub_10004C50(".\\cdp_main.c", 403, 1, 0);
  v3 |= 0x10u;
  if ( !sub_10004F60(1, 20000) )
    sub_10004C50(".\\cdp_main.c", 428, 1, 0);
  sub_1001DF30();
  sub_1001DB00(&v5);
  while ( 1 )
  {
    byte_101E3228 = 0;
    if ( v3 & 0x10 || v3 & 0x8000 )
    {
      sub_10001580((int)&byte_101E30A0);
      byte_101E30A2 = sub_1001D5E0(v0);
      byte_101E30A4 = 0;
      dword_101E30D4 = (int)&unk_100F17D0;
      word_101E30AE = 56;
      word_101E30B0 = 0;
      dword_101E30E0 = 12;
      word_101E30B4 = 250;
      dword_101E30B8 = -1;
      dword_101E30BC = -1;
      byte_101E30AB = 1;
      dword_101E30E8 = 0;
      byte_101E30A0 = 0;
      while ( sub_10004DA0(dword_101E30D4, (int)&v4) != 1 )
        ;
      sub_100014A0();
      sub_10002740((int)&byte_101E30A0);
      sub_100046E0((int)&byte_101E30A0);
      sub_1001DF20((int)&unk_1005E400);
      sub_1001DF10((int)&unk_1005E408);
      sub_100017F0((int)&byte_101E30A0);
      sub_100047C0((int)&byte_101E30A0);
    }
    if ( v3 & 2 )
      sub_10002140((int)&byte_101E30A0);
    if ( v3 & 1 )
    {
      v3 |= 0x20000000u;
      if ( (unsigned int)(sub_10004DF0() - dword_100F17C8) >= 0x3E8 )
      {
        dword_100F17C8 += 1000;
        j_nullsub_1(&byte_101E30A0);
        sub_1001D9F0((int *)&v5);
      }
    }
    v1 = 0x40000000;
    do
    {
      if ( v1 != 0x8000 && v1 & v3 )
      {
        v2 = sub_1001D140(v1);
        sub_10001C60((int)&byte_101E30A0, v2);
        sub_10002140((int)&byte_101E30A0);
      }
      v1 >>= 1;
    }
    while ( v1 >= 0x200 );
    if ( byte_101E3228 || byte_101E30A1 )
      sub_10001A70((int)&byte_101E30A0, (int)&dword_100FD0C8);
    sub_10004FD0(&v3);
  }
}
// 100014A0: using guessed type int sub_100014A0(void);
// 1001DF00: using guessed type int __cdecl j_nullsub_1(_DWORD);
// 1001DF30: using guessed type int sub_1001DF30(void);
// 100F17C8: using guessed type int dword_100F17C8;
// 100FD0C8: using guessed type int dword_100FD0C8;
// 101B1080: using guessed type int dword_101B1080;
// 101E30A0: using guessed type char byte_101E30A0;
// 101E30A1: using guessed type char byte_101E30A1;
// 101E30A2: using guessed type char byte_101E30A2;
// 101E30A4: using guessed type char byte_101E30A4;
// 101E30AB: using guessed type char byte_101E30AB;
// 101E30AE: using guessed type __int16 word_101E30AE;
// 101E30B0: using guessed type __int16 word_101E30B0;
// 101E30B4: using guessed type __int16 word_101E30B4;
// 101E30B8: using guessed type int dword_101E30B8;
// 101E30BC: using guessed type int dword_101E30BC;
// 101E30D4: using guessed type int dword_101E30D4;
// 101E30E0: using guessed type int dword_101E30E0;
// 101E30E8: using guessed type int dword_101E30E8;
// 101E3228: using guessed type char byte_101E3228;
// 101E327C: using guessed type int dword_101E327C;

//----- (10002400) --------------------------------------------------------
int __cdecl sub_10002400(int a1, int a2)
{
  return a2 * ((a1 + 255) / 256) << 8;
}

//----- (10002420) --------------------------------------------------------
char __cdecl sub_10002420(int a1, unsigned int a2)
{
  char result; // al@4

  if ( !a2 || a2 < (unsigned int)&unk_101B1084 || a2 >= dword_101B1080 )
    result = sub_10004C50(".\\cdp_mem.c", 222, 1, 0);
  dword_101B1080 = a2;
  return result;
}
// 101B1080: using guessed type int dword_101B1080;

//----- (10002460) --------------------------------------------------------
char sub_10002460()
{
  char result; // al@1

  byte_100F18A0 = 0;
  result = sub_10005460((int)"/mnt/card0/enable_heap_mntr.txt");
  if ( result )
    byte_100F18A0 = 1;
  return result;
}
// 100F18A0: using guessed type char byte_100F18A0;

//----- (10002480) --------------------------------------------------------
char __thiscall sub_10002480(int this)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@2
  int v3; // ecx@5
  int v4; // eax@5
  char *v5; // edi@6
  char v7[4]; // [sp+4h] [bp-ACh]@1
  int v8; // [sp+8h] [bp-A8h]@1
  int v9; // [sp+Ch] [bp-A4h]@1
  int v10; // [sp+10h] [bp-A0h]@1
  int v11; // [sp+14h] [bp-9Ch]@1
  char v12; // [sp+18h] [bp-98h]@1
  char v13; // [sp+2Ch] [bp-84h]@1

  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sub_10004E10((int)&v12, 1, *(_DWORD *)(this + 64), 20);
  sub_1001E330(&v13, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v12);
  LOBYTE(v1) = sub_10005460((int)&v13);
  if ( (_BYTE)v1 )
  {
    v1 = j_FIL_vfs_open(&v13, 4, 0);
    v2 = v1;
    if ( v1 < 0xFFFFFFC2
      && v1
      && (sub_100052D0(v1, &byte_100F18A8, 4096),
          sub_10005200(v2),
          (v1 = (unsigned int)strstr(&byte_100F18A8, "usage:")) != 0) )
    {
      v3 = v1 - (_DWORD)&byte_100F18A8;
      v4 = v1 - (_DWORD)&byte_100F18A8 + 7;
      if ( v4 < v3 + 27 )
      {
        v5 = &v7[-v4];
        do
        {
          if ( !((word_10078810[2 * (unsigned __int8)*(&byte_100F18A8 + v4)] >> 4) & 1) )
            break;
          v5[v4] = *(&byte_100F18A8 + v4);
          ++v4;
        }
        while ( v4 < v3 + 27 );
      }
      v1 = j__atol(v7);
      dword_100F28A8 = v1;
    }
    else
    {
      dword_100F28A8 = 0;
    }
  }
  else
  {
    dword_100F28A8 = 0;
  }
  return v1;
}
// 100052C0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 100F28A8: using guessed type int dword_100F28A8;

//----- (100025F0) --------------------------------------------------------
int __cdecl sub_100025F0(int a1)
{
  unsigned int v1; // ecx@0
  int result; // eax@1
  unsigned int v3; // edi@1
  int v4; // eax@3
  unsigned int v5; // esi@3
  int v6; // edi@7
  char v7; // [sp+4h] [bp-160h]@3
  char v8; // [sp+18h] [bp-14Ch]@4
  char v9; // [sp+E0h] [bp-84h]@3

  result = a1;
  v3 = v1;
  if ( a1 && dword_100F28A8 < v1 )
  {
    v4 = *(_DWORD *)(a1 + 64);
    dword_100F28A8 = v1;
    sub_10004E10((int)&v7, 1, v4, 20);
    sub_1001E330(&v9, 0x80u, "/mnt/card0/%s_heap_stats.txt", &v7);
    v5 = j_FIL_vfs_open(&v9, 10, 0);
    sub_1001E210((int)&byte_100F18A8, "HEAP STATISTICS:\r\n", 4096);
    if ( v3 > 0x32000 )
    {
      sub_1001E210((int)&v8, "\r\n!!!HEAP LIMIT EXCEEDED!!!\r\n", 200);
      sub_1001E360(&byte_100F18A8, &v8, 4096);
    }
    sub_1001E330(&v8, 0xC8u, "%s maximum heap usage: %d bytes out of %d bytes\r\n", &v7, v3, 204800);
    result = sub_1001E360(&byte_100F18A8, &v8, 4096);
    if ( v5 < 0xFFFFFFC2 )
    {
      if ( v5 )
      {
        v6 = sub_1001E260(&byte_100F18A8, 0x1000u);
        j_FIL_vfs_write(v5, &byte_100F18A8, v6);
        sub_10005410(v5, v6, 0);
        result = sub_10005200(v5);
      }
    }
  }
  return result;
}
// 100052C0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10005430: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 100F28A8: using guessed type int dword_100F28A8;

//----- (10002740) --------------------------------------------------------
char __cdecl sub_10002740(int a1)
{
  char result; // al@2

  dword_101B1080 = (int)&unk_101B1084;
  if ( byte_100F18A0 )
    result = sub_10002480(a1);
  return result;
}
// 100F18A0: using guessed type char byte_100F18A0;
// 101B1080: using guessed type int dword_101B1080;

//----- (10002760) --------------------------------------------------------
int __cdecl sub_10002760(int a1, int a2)
{
  unsigned int v2; // esi@1
  int v3; // ecx@2
  int result; // eax@4

  v2 = (unsigned int)(a2 + 3) >> 2;
  if ( byte_100F18A0 )
  {
    v3 = 4 * v2 - *(_DWORD *)(a1 + 476);
    sub_100025F0(a1);
  }
  if ( !a2 || (result = dword_101B1080, dword_101B1080 + 4 * v2 > *(_DWORD *)(a1 + 476) + 204804) )
  {
    sub_10004C50(".\\cdp_mem.c", 371, 1, 0);
    result = dword_101B1080;
  }
  dword_101B1080 = result + 4 * v2;
  return result;
}
// 100F18A0: using guessed type char byte_100F18A0;
// 101B1080: using guessed type int dword_101B1080;

//----- (100027E0) --------------------------------------------------------
int __cdecl sub_100027E0(int a1, __int16 a2, __int16 a3)
{
  int v3; // eax@1

  v3 = sub_10002400(a2, a3);
  return sub_10002760(a1, v3);
}

//----- (10002870) --------------------------------------------------------
int __usercall sub_10002870@<eax>(int a1@<eax>)
{
  int result; // eax@1
  char v2; // bl@1
  bool v3; // zf@1
  char v4; // [sp+13h] [bp-1h]@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v2 = 0;
  v3 = *(_BYTE *)(result + 448) == 1;
  v4 = 0;
  *(_BYTE *)(result + 619) = 0;
  if ( v3 )
  {
    v2 = 1;
    v4 = 1;
    *(_BYTE *)(result + 619) = 3;
  }
  *(_BYTE *)(result + 624) = 0;
  *(_DWORD *)(result + 640) = 62;
  *(_DWORD *)(result + 556) = result + 624;
  *(_DWORD *)(result + 632) = result + 640;
  *(_DWORD *)(result + 636) = result + 652;
  *(_WORD *)(result + 652) = 6;
  *(_DWORD *)(result + 664) = result + 672;
  *(_DWORD *)(result + 672) = 62;
  *(_DWORD *)(result + 560) = result + 656;
  *(_BYTE *)(result + 656) = 0;
  *(_DWORD *)(result + 700) = result + 716;
  *(_WORD *)(result + 716) = 6;
  *(_BYTE *)(result + 736) = v2 == 0;
  *(_DWORD *)(result + 668) = result + 684;
  *(_WORD *)(result + 684) = 6;
  *(_DWORD *)(result + 568) = result + 736;
  *(_DWORD *)(result + 564) = result + 688;
  *(_BYTE *)(result + 688) = 1;
  *(_DWORD *)(result + 748) = result + 764;
  *(_BYTE *)(result + 764) = 0;
  *(_DWORD *)(result + 696) = result + 704;
  *(_DWORD *)(result + 704) = 62;
  *(_DWORD *)(result + 744) = result + 752;
  *(_DWORD *)(result + 752) = 105;
  *(_DWORD *)(result + 572) = result + 768;
  *(_BYTE *)(result + 625) = 0;
  *(_WORD *)(result + 626) = 0;
  *(_WORD *)(result + 628) = 0;
  *(_DWORD *)(result + 644) = 6543;
  *(_WORD *)(result + 648) = 0;
  *(_BYTE *)(result + 654) = 1;
  *(_BYTE *)(result + 655) = 1;
  *(_BYTE *)(result + 657) = 0;
  *(_WORD *)(result + 658) = 0;
  *(_WORD *)(result + 660) = 0;
  *(_DWORD *)(result + 676) = 39301;
  *(_WORD *)(result + 680) = 0;
  *(_BYTE *)(result + 686) = 1;
  *(_BYTE *)(result + 687) = 1;
  *(_BYTE *)(result + 689) = 1;
  *(_WORD *)(result + 690) = 0;
  *(_WORD *)(result + 692) = 0;
  *(_DWORD *)(result + 708) = 6533;
  *(_WORD *)(result + 712) = 0;
  *(_BYTE *)(result + 718) = 1;
  *(_BYTE *)(result + 719) = 1;
  *(_BYTE *)(result + 737) = 1;
  *(_WORD *)(result + 738) = 0;
  *(_WORD *)(result + 740) = 0;
  *(_DWORD *)(result + 756) = 6533;
  *(_WORD *)(result + 760) = 0;
  *(_WORD *)(result + 762) = 1;
  *(_BYTE *)(result + 765) = 0;
  *(_BYTE *)(result + 768) = v4;
  *(_BYTE *)(result + 769) = 1;
  *(_WORD *)(result + 770) = 14;
  *(_WORD *)(result + 772) = 0;
  *(_DWORD *)(result + 780) = result + 796;
  *(_DWORD *)(result + 776) = result + 784;
  *(_DWORD *)(result + 784) = 62;
  *(_DWORD *)(result + 788) = 6533;
  *(_WORD *)(result + 792) = 0;
  *(_WORD *)(result + 796) = 6;
  *(_BYTE *)(result + 800) = 0;
  *(float *)(result + 864) = 0.0;
  *(_WORD *)(result + 828) = 1608;
  *(_BYTE *)(result + 832) = 0;
  *(_DWORD *)(result + 816) = 62;
  *(_DWORD *)(result + 848) = 89;
  *(_BYTE *)(result + 798) = 1;
  *(_BYTE *)(result + 799) = 1;
  *(_BYTE *)(result + 801) = 0;
  *(_WORD *)(result + 802) = 0;
  *(_WORD *)(result + 804) = 0;
  *(_DWORD *)(result + 820) = 6533;
  *(_WORD *)(result + 824) = 0;
  *(_BYTE *)(result + 830) = 1;
  *(_BYTE *)(result + 831) = 1;
  *(_BYTE *)(result + 833) = 0;
  *(_WORD *)(result + 834) = 0;
  *(_WORD *)(result + 836) = 0;
  *(_BYTE *)(result + 858) = 4;
  *(_WORD *)(result + 856) = 6;
  *(_BYTE *)(result + 859) = 2;
  *(_WORD *)(result + 860) = 0;
  *(_DWORD *)(result + 852) = 6533;
  *(_BYTE *)(result + 868) = v4;
  *(_DWORD *)(result + 576) = result + 800;
  *(_DWORD *)(result + 812) = result + 828;
  *(_DWORD *)(result + 580) = result + 832;
  *(_DWORD *)(result + 808) = result + 816;
  *(_DWORD *)(result + 844) = result + 864;
  *(_DWORD *)(result + 840) = result + 848;
  *(_DWORD *)(result + 584) = result + 868;
  *(_BYTE *)(result + 869) = 1;
  *(_WORD *)(result + 870) = 84;
  *(_WORD *)(result + 872) = 0;
  *(_DWORD *)(result + 880) = result + 896;
  *(_DWORD *)(result + 876) = result + 884;
  *(_DWORD *)(result + 884) = 62;
  *(_DWORD *)(result + 888) = 39301;
  *(_WORD *)(result + 892) = 0;
  *(_WORD *)(result + 896) = 6;
  *(_BYTE *)(result + 898) = 1;
  *(_BYTE *)(result + 899) = 1;
  *(_DWORD *)(result + 588) = result + 900;
  *(_BYTE *)(result + 900) = 0;
  *(_BYTE *)(result + 901) = 0;
  *(_WORD *)(result + 902) = 0;
  *(_WORD *)(result + 904) = 0;
  *(_DWORD *)(result + 912) = result + 928;
  *(_DWORD *)(result + 908) = result + 916;
  *(_DWORD *)(result + 916) = 62;
  *(_DWORD *)(result + 920) = 6533;
  *(_WORD *)(result + 924) = 0;
  *(_WORD *)(result + 928) = 6;
  *(_BYTE *)(result + 930) = 1;
  *(_BYTE *)(result + 931) = 1;
  *(_DWORD *)(result + 592) = result + 932;
  *(_BYTE *)(result + 932) = 0;
  *(_BYTE *)(result + 933) = 0;
  *(_WORD *)(result + 934) = 0;
  *(_WORD *)(result + 936) = 0;
  *(_DWORD *)(result + 944) = result + 960;
  *(_DWORD *)(result + 940) = result + 948;
  *(_DWORD *)(result + 948) = 62;
  *(_DWORD *)(result + 952) = 6533;
  *(_WORD *)(result + 956) = 0;
  *(_WORD *)(result + 960) = 6;
  *(_BYTE *)(result + 962) = 1;
  *(_BYTE *)(result + 963) = 1;
  *(_DWORD *)(result + 604) = result + 720;
  *(_BYTE *)(result + 720) = v4;
  *(_BYTE *)(result + 721) = 1;
  *(_WORD *)(result + 722) = 70;
  *(_WORD *)(result + 724) = 0;
  *(_DWORD *)(result + 732) = 0;
  *(_DWORD *)(result + 728) = &unk_100600F4;
  return result;
}

//----- (10002CE0) --------------------------------------------------------
char __usercall sub_10002CE0@<al>(int a1@<edi>)
{
  int v1; // esi@1
  char *v2; // eax@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  sub_10015210(a1, *(_WORD **)(a1 + 52), (char *)&unk_1005F984, v1 + 12, v1 + 20, 255);
  sub_10015210(a1, *(_WORD **)(a1 + 52), *(char **)v1, *(_DWORD *)(v1 + 4), *(_DWORD *)(v1 + 8), 255);
  v2 = *(char **)(v1 + 124);
  if ( v2 && *(_BYTE *)(v1 + 288) )
    LOBYTE(v2) = sub_10015210(a1, *(_WORD **)(a1 + 52), v2, *(_DWORD *)(v1 + 128), *(_DWORD *)(v1 + 120), 255);
  *(_BYTE *)(a1 + 6) = 2;
  return (unsigned int)v2;
}

//----- (10002D60) --------------------------------------------------------
int __usercall sub_10002D60@<eax>(int a1@<eax>, char a2@<cl>)
{
  int v2; // esi@1
  bool v3; // al@3
  int v4; // eax@5
  int result; // eax@5
  char v6; // [sp+7h] [bp-1h]@5

  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = *(_BYTE *)(a1 + 2) == 2 && !*(_BYTE *)(v2 + 288);
  v6 = a2 & 1 | 2 * (*(_BYTE *)(v2 + 499) & 1 | 2 * v3);
  v4 = 16 * sub_1001E550(&v6, 1u, (int)&unk_10060848, 16, 8);
  *(_DWORD *)(v2 + 132) = *(void **)((char *)&off_1006084C + v4);
  *(_DWORD *)(v2 + 136) = *(void **)((char *)&off_10060850 + v4);
  result = *(int *)((char *)&off_10060854 + v4);
  *(_DWORD *)v2 = result;
  *(_DWORD *)(v2 + 8) = v2 + 68;
  *(_DWORD *)(v2 + 4) = v2 + 24;
  return result;
}
// 1006084C: using guessed type void *off_1006084C;
// 10060850: using guessed type void *off_10060850;
// 10060854: using guessed type void *off_10060854;

//----- (10002DF0) --------------------------------------------------------
char __cdecl sub_10002DF0(int a1, char a2)
{
  unsigned int v2; // ebp@1
  int v3; // ecx@1
  int v4; // esi@1
  char v5; // al@1
  char v6; // al@4
  bool v7; // zf@9
  char v8; // al@9
  char v9; // al@10
  int v10; // eax@16
  int v11; // eax@20
  int v12; // eax@21
  int v13; // eax@21
  int v14; // eax@21
  char v15; // cl@21
  double v16; // st7@21
  char v17; // cl@21
  int v18; // eax@24
  char v19; // al@26
  int v20; // eax@31
  int v21; // eax@31
  unsigned __int8 v22; // al@35
  int v23; // eax@39
  unsigned int v24; // eax@42
  int v25; // edx@46
  char v27; // [sp+Eh] [bp-2h]@1
  char v28; // [sp+Fh] [bp-1h]@1
  char v29; // [sp+14h] [bp+4h]@1

  v2 = sub_10004DF0();
  v3 = *(_DWORD *)(a1 + 56);
  v4 = *(_DWORD *)(v3 + 12);
  v28 = sub_1001E770((void *)v3);
  *(_DWORD *)(v4 + 608) = 0;
  *(_DWORD *)(v4 + 612) = 0;
  *(_WORD *)(v4 + 616) = 0;
  v5 = *(_BYTE *)(v4 + 274);
  v29 = 0;
  v27 = 0;
  if ( a2 )
  {
    if ( v5 == 1 || v5 == 6 )
    {
      v6 = *(_BYTE *)(v4 + 168);
      if ( v6 == 2 || v6 == 3 || v6 == 4 || v6 == 5 )
        *(_DWORD *)(v4 + 264) = v2;
    }
    v7 = *(_BYTE *)(v4 + 272) == 0;
    v8 = *(_BYTE *)(v4 + 169);
    *(_BYTE *)(v4 + 274) = *(_BYTE *)(v4 + 168);
    v29 = 1;
    *(_BYTE *)(v4 + 275) = v8;
    *(_BYTE *)(v4 + 276) = 0;
    v27 = 1;
    if ( !v7 )
    {
      v9 = *(_BYTE *)(v4 + 273);
      if ( v9 != 9 && v9 != 10 && v9 != 11 && v9 != 13 && v9 != 14 && v9 != 15 )
      {
        v10 = sub_1001E3C0(&v28, 1u, (int)&unk_10060960, 8, 3, 3);
        *(_BYTE *)(v4 + 764) = byte_10060961[8 * v10];
        *(_WORD *)(v4 + 738) = word_10060962[4 * v10];
        *(_WORD *)(v4 + 690) = word_10060964[4 * v10];
        *(_BYTE *)(v4 + 611) = byte_10060966[8 * v10];
      }
    }
    if ( *(_BYTE *)(v4 + 198) )
    {
      if ( *(_BYTE *)(v4 + 195) && *(_BYTE *)(v4 + 448) == 1 )
      {
        *(_BYTE *)(v4 + 613) = 3;
        v11 = sub_1001E3C0((_DWORD *)(v4 + 196), 1u, (int)byte_10060334, 4, 13, 13);
        *(_DWORD *)(v4 + 820) = byte_10060335[4 * v11] & 0x1F | 0x1980;
        *(_BYTE *)(v4 + 830) = byte_10060336[4 * v11];
        *(_BYTE *)(v4 + 831) = byte_10060337[4 * v11];
      }
      *(_WORD *)(v4 + 652) = word_100608CA[2 * sub_1001E3C0((_DWORD *)(v4 + 177), 1u, (int)&unk_100608C8, 4, 8, 8)];
      v12 = sub_1001E3C0((_DWORD *)(v4 + 194), 1u, (int)byte_10060334, 4, 13, 13);
      *(_DWORD *)(v4 + 644) = byte_10060335[4 * v12] & 0x1F | 0x1980;
      *(_BYTE *)(v4 + 654) = byte_10060336[4 * v12];
      *(_BYTE *)(v4 + 655) = byte_10060337[4 * v12];
      *(_WORD *)(v4 + 684) = word_100608EA[2 * sub_1001E3C0((_DWORD *)(v4 + 175), 1u, (int)&unk_100608E8, 4, 14, 14)];
      v13 = sub_1001E3C0((_DWORD *)(v4 + 176), 1u, (int)byte_10060334, 4, 13, 13);
      *(_DWORD *)(v4 + 676) = byte_10060335[4 * v13] & 0x1F | 0x9980;
      *(_BYTE *)(v4 + 686) = byte_10060336[4 * v13];
      *(_BYTE *)(v4 + 687) = byte_10060337[4 * v13];
      v14 = 3 * sub_1001E3C0((_DWORD *)(v4 + 171), 1u, (int)&unk_100609D0, 6, 15, 15);
      v15 = byte_100609D4[2 * v14];
      v16 = *(float *)(v4 + 184);
      v14 *= 2;
      *(_BYTE *)(v4 + 858) = v15;
      *(_WORD *)(v4 + 856) = *(__int16 *)((char *)&word_100609D2 + v14);
      v17 = byte_100609D5[v14];
      *(float *)(v4 + 864) = v16;
      *(_BYTE *)(v4 + 859) = v17;
      if ( byte_100609D1[v14] == 1 )
        *(_DWORD *)(v4 + 852) = byte_10060335[4 * sub_1001E3C0((_DWORD *)(v4 + 172), 1u, (int)byte_10060334, 4, 13, 13)] & 0x1F | 0x5980;
      else
        *(_DWORD *)(v4 + 852) = 22924;
      *(_WORD *)(v4 + 896) = word_100601A6[2 * sub_1001E3C0((_DWORD *)(v4 + 171), 1u, (int)&unk_100601A4, 4, 15, 15)];
      v18 = sub_1001E3C0((_DWORD *)(v4 + 172), 1u, (int)byte_10060334, 4, 13, 13);
      *(_DWORD *)(v4 + 888) = byte_10060335[4 * v18] & 0x1F | 0x9980;
      *(_BYTE *)(v4 + 898) = byte_10060336[4 * v18];
      v7 = *(_BYTE *)(v4 + 448) == 1;
      *(_BYTE *)(v4 + 899) = byte_10060337[4 * v18];
      if ( !v7 )
      {
        if ( byte_10060336[4 * v18] == 1
          || (v19 = byte_10060334[4 * v18], v19 == 7)
          || v19 == 8
          || v19 == 9
          || v19 == 10 )
        {
          *(_BYTE *)(v4 + 614) = 3;
        }
      }
      *(_WORD *)(v4 + 928) = word_10060A2E[2 * sub_1001E3C0((_DWORD *)(v4 + 173), 1u, (int)&unk_10060A2C, 4, 6, 6)];
      v20 = sub_1001E3C0((_DWORD *)(v4 + 192), 1u, (int)byte_10060334, 4, 13, 13);
      *(_DWORD *)(v4 + 920) = byte_10060335[4 * v20] & 0x1F | 0x1980;
      *(_BYTE *)(v4 + 930) = byte_10060336[4 * v20];
      *(_BYTE *)(v4 + 931) = byte_10060337[4 * v20];
      *(_WORD *)(v4 + 960) = word_10060276[2 * sub_1001E3C0((_DWORD *)(v4 + 174), 1u, (int)&unk_10060274, 4, 7, 7)];
      v21 = sub_1001E3C0((_DWORD *)(v4 + 193), 1u, (int)byte_10060334, 4, 13, 13);
      *(_DWORD *)(v4 + 952) = byte_10060335[4 * v21] & 0x1F | 0x1980;
      *(_BYTE *)(v4 + 962) = byte_10060336[4 * v21];
      *(_BYTE *)(v4 + 963) = byte_10060337[4 * v21];
      *(_BYTE *)(v4 + 608) = 3;
      *(_BYTE *)(v4 + 609) = 3;
      *(_BYTE *)(v4 + 615) = 3;
      *(_BYTE *)(v4 + 616) = 3;
      *(_BYTE *)(v4 + 617) = 3;
    }
  }
  else
  {
    if ( v5 == 1 || v5 == 6 )
    {
      *(_BYTE *)(v4 + 274) = 3;
      *(_DWORD *)(v4 + 264) = v2;
    }
    v22 = *(_BYTE *)(v4 + 275);
    if ( v22 && v22 < 0xBu && !*(_BYTE *)(v4 + 276) )
    {
      *(_BYTE *)(v4 + 275) = v22 < 6u ? 3 : 8;
      *(_DWORD *)(v4 + 268) = v2;
      *(_BYTE *)(v4 + 276) = 1;
    }
  }
  v23 = *(_DWORD *)(v4 + 264);
  if ( v23 && v23 + 5000 > v2 )
  {
    v29 = 1;
    *(_BYTE *)(v4 + 168) = *(_BYTE *)(v4 + 274);
  }
  v24 = *(_DWORD *)(v4 + 268);
  if ( v24 )
  {
    v24 += 5000;
    if ( v24 > v2 )
    {
      LOBYTE(v24) = *(_BYTE *)(v4 + 275);
      v27 = 1;
      *(_BYTE *)(v4 + 169) = v24;
    }
  }
  if ( v29 )
  {
    *(_BYTE *)(v4 + 610) = 3;
    v24 = sub_1001E3C0((_DWORD *)(v4 + 168), 1u, (int)byte_10060920, 8, 8, 8);
    v25 = byte_10060924[8 * v24] & 0x1F;
    if ( byte_10060920[8 * v24] == 3 )
    {
      *(_DWORD *)(v4 + 708) = v25 | 0x19E0;
    }
    else
    {
      *(_DWORD *)(v4 + 708) = v25 | 0x1980;
      if ( v28 == 2 && word_10060922[4 * v24] == 1643 )
        *(_WORD *)(v4 + 738) += 14;
    }
    if ( *(_BYTE *)(v4 + 448) == 1 )
    {
      *(_WORD *)(v4 + 690) = 28;
      if ( word_10060922[4 * v24] == 1643 )
        *(_WORD *)(v4 + 690) = 25;
    }
    *(_WORD *)(v4 + 716) = word_10060922[4 * v24];
    *(_BYTE *)(v4 + 718) = byte_10060925[8 * v24];
    LOBYTE(v24) = byte_10060926[8 * v24];
    *(_BYTE *)(v4 + 719) = v24;
  }
  if ( v27 )
  {
    *(_BYTE *)(v4 + 612) = 3;
    v24 = sub_1001E3C0((_DWORD *)(v4 + 169), 1u, (int)&unk_10060978, 8, 11, 0);
    *(_DWORD *)(v4 + 788) = byte_1006097C[8 * v24] & 0x1F | 0x1980;
    *(_WORD *)(v4 + 796) = word_1006097A[4 * v24];
    *(_BYTE *)(v4 + 798) = byte_1006097D[8 * v24];
    LOBYTE(v24) = byte_1006097E[8 * v24];
    *(_BYTE *)(v4 + 799) = v24;
  }
  return v24;
}
// 100601A6: using guessed type __int16 word_100601A6[];
// 10060276: using guessed type __int16 word_10060276[];
// 100608CA: using guessed type __int16 word_100608CA[];
// 100608EA: using guessed type __int16 word_100608EA[];
// 10060922: using guessed type __int16 word_10060922[];
// 10060962: using guessed type __int16 word_10060962[];
// 10060964: using guessed type __int16 word_10060964[];
// 1006097A: using guessed type __int16 word_1006097A[];
// 100609D2: using guessed type __int16 word_100609D2;
// 10060A2E: using guessed type __int16 word_10060A2E[];

//----- (10003480) --------------------------------------------------------
char __usercall sub_10003480@<al>(int a1@<eax>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // eax@2
  int v4; // eax@4
  int v5; // eax@7
  int v6; // eax@9
  int v7; // eax@10
  int v8; // eax@11
  int v9; // edi@14
  unsigned int v11; // [sp+Ch] [bp-Ch]@1
  unsigned int v12; // [sp+10h] [bp-8h]@1
  float v13; // [sp+14h] [bp-4h]@12

  v1 = *(_DWORD *)(a1 + 56);
  v12 = 0;
  v2 = *(_DWORD *)(v1 + 12);
  v11 = 0;
  *(_DWORD *)(v2 + 608) = 0;
  *(_DWORD *)(v2 + 612) = 0;
  *(_WORD *)(v2 + 616) = 0;
  if ( sub_1001F8B0(1, 2954, 0, 4, &v12) )
  {
    v11 = (v12 >> 25) & 0xF;
    v3 = sub_1001E3C0(&v11, 4u, (int)&unk_10060A48, 8, 8, 0);
    if ( v3 )
    {
      *(_WORD *)(v2 + 652) = word_10060A4E[4 * v3];
      *(_DWORD *)(v2 + 644) = byte_10060A4C[8 * v3] & 0x1F | 0x1980;
      *(_BYTE *)(v2 + 654) = 1;
      *(_BYTE *)(v2 + 655) = 1;
      *(_BYTE *)(v2 + 608) = 3;
    }
    v11 = (v12 >> 21) & 0xF;
    v4 = sub_1001E3C0(&v11, 4u, (int)&unk_10060AD8, 8, 4, 0);
    if ( v4 )
    {
      *(_WORD *)(v2 + 928) = word_10060ADE[4 * v4];
      *(_DWORD *)(v2 + 920) = byte_10060ADC[8 * v4] & 0x1F | 0x1980;
      *(_BYTE *)(v2 + 930) = 1;
      *(_BYTE *)(v2 + 931) = 1;
      *(_BYTE *)(v2 + 616) = 3;
    }
  }
  if ( sub_1001F8B0(1, 2955, 0, 4, &v12) )
  {
    v11 = (v12 >> 25) & 0xF;
    v5 = sub_1001E3C0(&v11, 4u, (int)&unk_10060A88, 8, 10, 0);
    if ( v5 )
    {
      *(_WORD *)(v2 + 684) = word_10060A8E[4 * v5];
      *(_DWORD *)(v2 + 676) = byte_10060A8C[8 * v5] & 0x1F | 0x9980;
      *(_BYTE *)(v2 + 686) = 1;
      *(_BYTE *)(v2 + 687) = 1;
      *(_BYTE *)(v2 + 609) = 3;
    }
    v11 = (v12 >> 21) & 0xF;
    v6 = sub_1001E3C0(&v11, 4u, (int)&unk_10060AF8, 20, 8, 0);
    if ( v6 )
    {
      v7 = 10 * v6;
      *(_WORD *)(v2 + 896) = word_10060AFE[v7];
      *(_DWORD *)(v2 + 888) = byte_10060AFC[2 * v7] & 0x1F | 0x9980;
      *(_BYTE *)(v2 + 898) = 1;
      *(_BYTE *)(v2 + 899) = 1;
      *(_BYTE *)(v2 + 615) = 3;
    }
  }
  LOBYTE(v8) = sub_1001F8B0(1, 2953, 0, 4, &v12);
  if ( (_BYTE)v8 )
  {
    LOBYTE(v8) = sub_1001F8B0(1, 2952, 0, 4, &v13);
    if ( (_BYTE)v8 )
    {
      v11 = (unsigned __int16)v12 >> 13;
      v8 = sub_1001E3C0(&v11, 4u, (int)dword_10060B98, 12, 4, 0);
      if ( v8 )
      {
        v9 = 6 * v8;
        *(float *)(v2 + 864) = flt_10060BA0[3 * v8] * v13;
        if ( dword_10060B98[3 * v8] == 2 )
          *(float *)(v2 + 864) = sub_1001D1C0() + *(float *)(v2 + 864);
        *(_BYTE *)(v2 + 858) = byte_10060B9E[v9 * 2];
        LOWORD(v8) = word_10060B9C[v9];
        *(_WORD *)(v2 + 856) = v8;
        *(_BYTE *)(v2 + 859) = 0;
        *(_DWORD *)(v2 + 852) = 22917;
        *(_BYTE *)(v2 + 614) = 3;
      }
    }
  }
  return v8;
}
// 1001D1C0: using guessed type double sub_1001D1C0(void);
// 10060A4E: using guessed type __int16 word_10060A4E[];
// 10060A8E: using guessed type __int16 word_10060A8E[];
// 10060ADE: using guessed type __int16 word_10060ADE[];
// 10060AFE: using guessed type __int16 word_10060AFE[];
// 10060B98: using guessed type int dword_10060B98[];
// 10060B9C: using guessed type __int16 word_10060B9C[];
// 10060BA0: using guessed type float flt_10060BA0[];

//----- (10003860) --------------------------------------------------------
char __usercall sub_10003860@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // esi@1
  bool v3; // zf@1
  char result; // al@1
  int v5; // [sp-2h] [bp-4h]@1

  v5 = a2;
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v3 = *(_BYTE *)(v2 + 500) == 0;
  result = 37;
  *(_WORD *)(v2 + 502) = 37;
  *(_WORD *)(v2 + 504) = 37;
  if ( !v3 )
  {
    result = sub_1001F940(1u, (_BYTE *)&v5 + 3);
    if ( result )
    {
      if ( BYTE3(v5) )
        *(_WORD *)(v2 + 502) = 319;
    }
  }
  if ( *(_BYTE *)(v2 + 501) )
  {
    result = sub_100160C0(0);
    if ( result || (result = sub_100160C0(1)) != 0 )
      *(_WORD *)(v2 + 504) = 318;
  }
  return result;
}

//----- (10003BD0) --------------------------------------------------------
char __cdecl sub_10003BD0(int a1)
{
  int v1; // esi@1
  _DWORD *v2; // edi@1
  void *v3; // ecx@1
  void *v4; // ecx@1
  bool v5; // al@3
  bool v6; // al@5
  bool v7; // zf@5
  bool v8; // al@7
  char *v9; // ebp@13
  char *v10; // ebx@13
  char v11; // al@13
  __int16 v12; // di@14
  int v13; // edx@16
  int v14; // ecx@16
  int v15; // eax@16
  _WORD *v16; // edx@16
  int v17; // eax@16
  int v18; // ecx@16
  signed int v19; // ebp@16
  int v20; // ebx@18
  char result; // al@18

  v1 = sub_100015D0(a1, *(char **)(a1 + 56), 1340, 0);
  v2 = (_DWORD *)(v1 + 80);
  v5 = sub_1001FF60(v3) & 3 || sub_1001D640(v4) == 1;
  *(_BYTE *)(v1 + 288) = v5;
  *(_BYTE *)(v1 + 272) = sub_1001FEE0(2, (_BYTE *)(v1 + 273));
  *(_BYTE *)(v1 + 500) = sub_1001FAB0(1u) != 0;
  v6 = sub_1001FAB0(4u) != 0;
  v7 = *(_BYTE *)(v1 + 500) == 0;
  *(_BYTE *)(v1 + 501) = v6;
  v8 = !v7 || v6;
  *(_BYTE *)(v1 + 499) = v8;
  sub_100054D0(62, (_BYTE *)(v1 + 448));
  if ( *(_BYTE *)(a1 + 2) != 2 || *(_BYTE *)(v1 + 288) )
    sub_10001180(a1, 0, 0, 496, 56, 1);
  else
    sub_10001180(a1, 0, 0, 745, 28, 1);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 230) = -1;
  *(_DWORD *)(v1 + 36) = v1 + 262;
  *(_DWORD *)(v1 + 24) = v1 + 256;
  *(_DWORD *)(v1 + 40) = v1 + 224;
  *(_DWORD *)(v1 + 28) = v1 + 258;
  *(_DWORD *)(v1 + 32) = v1 + 260;
  *(_DWORD *)(v1 + 52) = v1 + 248;
  v9 = (char *)(v1 + 232);
  *(_DWORD *)(v1 + 44) = v1 + 232;
  v10 = (char *)(v1 + 240);
  *(_DWORD *)(v1 + 48) = v1 + 240;
  *(_DWORD *)(v1 + 84) = v1 + 258;
  *(_DWORD *)(v1 + 88) = v1 + 260;
  *(_DWORD *)(v1 + 108) = v1 + 248;
  *v2 = 0;
  *(_DWORD *)(v1 + 100) = v1 + 232;
  *(_DWORD *)(v1 + 104) = v1 + 240;
  *(_DWORD *)(v1 + 92) = v1 + 262;
  *(_DWORD *)(v1 + 96) = v1 + 292;
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)(v1 + 16) = v1 + 280;
  *(_DWORD *)(v1 + 280) = v1 + 300;
  *(_DWORD *)(v1 + 284) = v1 + 164;
  *(_DWORD *)(v1 + 60) = v1 + 502;
  *(_DWORD *)(v1 + 56) = v1 + 449;
  *(_DWORD *)(v1 + 64) = v1 + 504;
  *(_WORD *)(v1 + 502) = 37;
  *(_WORD *)(v1 + 504) = 37;
  sub_10002870(a1);
  *(_DWORD *)v1 = &unk_100605E8;
  *(_DWORD *)(v1 + 8) = v1 + 112;
  *(_DWORD *)(v1 + 4) = v2;
  *(_BYTE *)(v1 + 224) = sub_100113A0(4);
  *(_BYTE *)(v1 + 232) = sub_100113A0(5);
  *(_BYTE *)(v1 + 240) = sub_100113A0(6);
  v11 = sub_100113A0(7);
  v7 = *(_BYTE *)(v1 + 288) == 0;
  *(_BYTE *)(v1 + 248) = v11;
  if ( v7 )
  {
    sub_10002D60(a1, 0);
    v12 = 0;
    *(_BYTE *)(v1 + 224) = sub_100113A0(0);
    *v9 = sub_100113A0(1);
    *v10 = sub_100113A0(2);
    *(_BYTE *)(v1 + 248) = sub_100113A0(3);
  }
  else
  {
    v12 = 0;
  }
  v13 = (unsigned __int8)*v9;
  *(_WORD *)(v1 + 256) = word_1005F6A0[*(_BYTE *)(v1 + 224)];
  v14 = (unsigned __int8)*v10;
  *(_WORD *)(v1 + 258) = word_1005F6A0[v13];
  v15 = *(_BYTE *)(v1 + 248);
  *(_WORD *)(v1 + 260) = word_1005F6A0[v14];
  *(_WORD *)(v1 + 262) = word_1005F6A0[v15];
  *(_WORD *)(v1 + 20) = 771;
  *(_DWORD *)(v1 + 68) = 50529027;
  *(_DWORD *)(v1 + 72) = 50529027;
  *(_WORD *)(v1 + 76) = 771;
  *(_BYTE *)(v1 + 78) = 3;
  *(_DWORD *)(v1 + 112) = 50529027;
  *(_DWORD *)(v1 + 116) = 50529027;
  *(_BYTE *)(v1 + 113) = 0;
  *(_BYTE *)(v1 + 117) = 0;
  *(_DWORD *)(v1 + 296) = 39305;
  *(_BYTE *)(v1 + 295) = 1;
  *(_DWORD *)(v1 + 508) = v1 + 520;
  *(_BYTE *)(v1 + 520) = 0;
  *(_BYTE *)(v1 + 521) = 0;
  *(_WORD *)(v1 + 522) = v12;
  *(_WORD *)(v1 + 524) = v12;
  *(_DWORD *)(v1 + 532) = v1 + 548;
  *(_DWORD *)(v1 + 536) = 62;
  *(_WORD *)(v1 + 544) = 490;
  *(_WORD *)(v1 + 548) = 6;
  *(_BYTE *)(v1 + 550) = 1;
  *(_BYTE *)(v1 + 551) = 1;
  v16 = (_WORD *)(v1 + 984);
  v17 = v1 + 1138;
  v18 = v1 + 1096;
  v19 = 10;
  do
  {
    *(_DWORD *)(v18 + 204) = v17 - 2;
    *(_DWORD *)(v17 + 10) = v18;
    *(_WORD *)v17 = v12;
    *(_WORD *)(v17 + 2) = v12;
    *(_BYTE *)(v17 - 1) = 0;
    *(_BYTE *)(v17 - 2) = 0;
    *(_BYTE *)(v18 + 3) = 1;
    *(_BYTE *)(v18 + 2) = 1;
    *((_DWORD *)v16 - 2) = 62;
    *v16 = v12;
    v17 += 16;
    v18 += 4;
    v16 += 6;
    --v19;
  }
  while ( v19 );
  memset((void *)(v1 + 164), 0, 0x3Cu);
  *(_BYTE *)(v1 + 274) = 8;
  *(_BYTE *)(v1 + 275) = 11;
  *(_DWORD *)(v1 + 264) = 0;
  *(_DWORD *)(v1 + 268) = 0;
  *(_BYTE *)(v1 + 276) = 0;
  *(_DWORD *)(v1 + 124) = 0;
  *(_DWORD *)(v1 + 128) = 0;
  *(_DWORD *)(v1 + 120) = 0;
  *(_DWORD *)(v1 + 964) = 0;
  *(_BYTE *)(v1 + 968) = 0;
  *(_DWORD *)(v1 + 972) = 0;
  *(_BYTE *)(v1 + 1296) = sub_1001FA10(0x214u);
  v20 = a1;
  *(_DWORD *)(v1 + 512) = sub_10004DF0() - 40000;
  *(_BYTE *)(v1 + 516) = 0;
  *(_BYTE *)(v1 + 552) = 3;
  *(_BYTE *)(v1 + 553) = 0;
  sub_10001780(a1, *(_DWORD *)(a1 + 56), 250);
  sub_10015210(v20, *(_WORD **)(v20 + 52), (char *)&unk_1005F984, v1 + 12, 0, 255);
  sub_10015210(v20, *(_WORD **)(v20 + 52), *(char **)v1, *(_DWORD *)(v1 + 4), 0, 255);
  result = sub_10001DE0(v20, *(_DWORD *)(v20 + 56), -32648);
  *(_BYTE *)(a1 + 6) = 2;
  return result;
}
// 1005F6A0: using guessed type __int16 word_1005F6A0[];

//----- (10004010) --------------------------------------------------------
char __usercall sub_10004010@<al>(int a1@<edi>)
{
  int v1; // ecx@4
  int v2; // esi@4
  char v3; // bl@4
  int v4; // eax@4
  void *v5; // ecx@4
  int v6; // edi@15
  unsigned __int8 v7; // bl@17
  unsigned int v8; // eax@23
  int v9; // esi@29
  unsigned int v10; // ebx@29
  void *v11; // eax@41
  int v12; // ecx@43
  int v13; // edi@43
  int v14; // ecx@45
  int v15; // edi@45
  int v16; // ecx@47
  int v17; // edi@47
  int v18; // ecx@49
  int v19; // edi@49
  int v20; // ecx@50
  int v21; // edi@51
  int v22; // ecx@60
  int v23; // esi@1
  int v24; // eax@1
  void *v25; // ecx@1
  unsigned int v26; // eax@3
  bool v27; // zf@10
  char v29; // [sp+1h] [bp-1Dh]@38
  char v30; // [sp+2h] [bp-1Ch]@35
  int v31; // [sp+Ah] [bp-14h]@13
  char *v32; // [sp+Eh] [bp-10h]@1
  int v33; // [sp+12h] [bp-Ch]@4
  int v34; // [sp+16h] [bp-8h]@4
  char *v35; // [sp+1Ah] [bp-4h]@1

  v23 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v32 = (char *)(v23 + 164);
  *(_DWORD *)(v23 + 124) = 0;
  *(_DWORD *)(v23 + 128) = 0;
  *(_DWORD *)(v23 + 120) = 0;
  LOBYTE(v35) = sub_1001E9A0(v32);
  v24 = (unsigned __int8)sub_1001E670();
  if ( !(_BYTE)v24 )
  {
    v32 = v35;
    v31 = a1;
    *(_DWORD *)(v23 + 124) = &unk_100606E8;
    *(_DWORD *)(v23 + 128) = v23 + 556;
    *(_DWORD *)(v23 + 120) = v23 + 608;
    LOBYTE(v26) = sub_10002DF0(v31, (char)v32);
    return v26;
  }
  if ( v24 == 1 )
  {
    if ( *(_BYTE *)(v23 + 1296) )
      *(_DWORD *)(v23 + 124) = &unk_100607C0;
    else
      *(_DWORD *)(v23 + 124) = &unk_10060768;
    v27 = (_BYTE)v35 == 0;
    *(_DWORD *)(v23 + 128) = v23 + 1300;
    *(_DWORD *)(v23 + 120) = 0;
    if ( v27 )
      *(_DWORD *)(v23 + 168) = 0;
    v9 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
    v10 = *(_DWORD *)(v9 + 168) & 0xFFF3FFFF;
    *(_DWORD *)(v9 + 1144) = 0;
    *(_DWORD *)(v9 + 1160) = 0;
    *(_DWORD *)(v9 + 1176) = 0;
    *(_DWORD *)(v9 + 1192) = 0;
    *(_DWORD *)(v9 + 1208) = 0;
    *(_DWORD *)(v9 + 1224) = 0;
    *(_DWORD *)(v9 + 1240) = 0;
    *(_DWORD *)(v9 + 1256) = 0;
    *(_DWORD *)(v9 + 1272) = 0;
    *(_DWORD *)(v9 + 1288) = 0;
    if ( v10 == 128 )
      v10 = 0;
    if ( (v10 & 0x80u) == 0 && (v10 & 0x1A || v10 & 0x20400) )
      v10 |= 0x40000u;
    if ( !sub_1001EB20(&v30) )
      v10 &= 0xFFFFFF7F;
    if ( *(_BYTE *)(v9 + 1296) && sub_1001FA80(532, &v29) && v29 )
      v10 |= 0x80000u;
    v11 = &unk_10060BCC;
    do
    {
      if ( (v10 & *((_DWORD *)v11 - 1)) == *(_DWORD *)v11 )
      {
        v12 = *((_BYTE *)v11 + 4);
        v13 = v9 + 12 * v12;
        *(_DWORD *)(v9 + 16 * v12 + 1144) = v13 + 976;
        *(_DWORD *)(v13 + 980) = *((_BYTE *)v11 + 8) & 0x1F | 0x1980;
        *(_WORD *)(v9 + 4 * v12 + 1096) = *((_WORD *)v11 + 3);
      }
      if ( (v10 & *((_DWORD *)v11 + 3)) == *((_DWORD *)v11 + 4) )
      {
        v14 = *((_BYTE *)v11 + 20);
        v15 = v9 + 12 * v14;
        *(_DWORD *)(v9 + 16 * v14 + 1144) = v15 + 976;
        *(_DWORD *)(v15 + 980) = *((_BYTE *)v11 + 24) & 0x1F | 0x1980;
        *(_WORD *)(v9 + 4 * v14 + 1096) = *((_WORD *)v11 + 11);
      }
      if ( (v10 & *((_DWORD *)v11 + 7)) == *((_DWORD *)v11 + 8) )
      {
        v16 = *((_BYTE *)v11 + 36);
        v17 = v9 + 12 * v16;
        *(_DWORD *)(v9 + 16 * v16 + 1144) = v17 + 976;
        *(_DWORD *)(v17 + 980) = *((_BYTE *)v11 + 40) & 0x1F | 0x1980;
        *(_WORD *)(v9 + 4 * v16 + 1096) = *((_WORD *)v11 + 19);
      }
      if ( (v10 & *((_DWORD *)v11 + 11)) == *((_DWORD *)v11 + 12) )
      {
        v18 = *((_BYTE *)v11 + 52);
        v19 = v9 + 12 * v18;
        *(_DWORD *)(v9 + 16 * v18 + 1144) = v19 + 976;
        *(_DWORD *)(v19 + 980) = *((_BYTE *)v11 + 56) & 0x1F | 0x1980;
        *(_WORD *)(v9 + 4 * v18 + 1096) = *((_WORD *)v11 + 27);
      }
      v20 = v10 & *((_DWORD *)v11 + 15);
      if ( v20 == *((_DWORD *)v11 + 16) )
      {
        v20 = *((_BYTE *)v11 + 68);
        v21 = v9 + 12 * v20;
        *(_DWORD *)(v9 + 16 * v20 + 1144) = v21 + 976;
        *(_DWORD *)(v21 + 980) = *((_BYTE *)v11 + 72) & 0x1F | 0x1980;
        *(_WORD *)(v9 + 4 * v20 + 1096) = *((_WORD *)v11 + 35);
      }
      v11 = (char *)v11 + 80;
    }
    while ( (signed int)v11 < (signed int)word_10060D0C );
    if ( (v10 & 0x20002) == 2 && sub_1001EC00(v20) )
      *(_DWORD *)(v9 + 1040) = 6539;
    LOBYTE(v26) = *(_BYTE *)(v9 + 968) - 1;
    if ( *(_BYTE *)(v9 + 968) == 1 )
    {
      v26 = sub_10004DF0();
      if ( v10 & 0x800 )
        *(_DWORD *)(v9 + 1076) = 6543;
      if ( v10 & 0x100 || (v26 -= *(_DWORD *)(v9 + 972), v26 > 0x2BC) )
      {
        *(_BYTE *)(v9 + 968) = 0;
        *(_DWORD *)(v9 + 972) = 0;
      }
    }
    else if ( *(_DWORD *)(v9 + 964) & 0x100 )
    {
      if ( !(v10 & 0x100) )
      {
        *(_BYTE *)(v9 + 968) = 1;
        v26 = sub_10004DF0();
        *(_DWORD *)(v9 + 972) = v26;
        if ( v10 & 0x800 )
        {
          v22 = *(_DWORD *)(v9 + 168);
          *(_DWORD *)(v9 + 1076) = 6543;
          *(_DWORD *)(v9 + 964) = v22;
          return v26;
        }
      }
    }
    *(_DWORD *)(v9 + 964) = *(_DWORD *)(v9 + 168);
    return v26;
  }
  LOBYTE(v26) = sub_1001E750(v25);
  if ( (_BYTE)v26 )
  {
    *(_DWORD *)(v23 + 120) = 0;
    *(_DWORD *)(v23 + 124) = &unk_1005FB04;
    *(_DWORD *)(v23 + 128) = v23 + 508;
    v1 = *(_DWORD *)(a1 + 56);
    v35 = (char *)v34;
    v34 = v33;
    v2 = *(_DWORD *)(v1 + 12);
    v3 = *(_BYTE *)(v2 + 516);
    v33 = a1;
    *(_BYTE *)(v2 + 516) = sub_1001E720();
    v4 = sub_10004DF0();
    v6 = v4;
    if ( *(_BYTE *)(v2 + 516) != v3 && !sub_1001EC00((int)v5)
      || (v7 = *(_BYTE *)(v2 + 552), v7 != sub_1001EC00((int)v5)) && v7 < 3u
      || !*(_BYTE *)(v2 + 553) && sub_10005B40(0) && sub_1001E750(v5) == 1 )
    {
      *(_DWORD *)(v2 + 512) = v6;
      *(_WORD *)(v2 + 548) = 4688;
      *(_DWORD *)(v2 + 540) = 37263;
      *(_BYTE *)(v2 + 550) = 0;
      *(_BYTE *)(v2 + 551) = 0;
      *(_DWORD *)(v2 + 528) = v2 + 536;
    }
    v8 = v6 - *(_DWORD *)(v2 + 512);
    if ( v8 > 0x1388 )
    {
      if ( v8 >= 0x88B8 )
        goto LABEL_27;
      *(_BYTE *)(v2 + 550) = 2;
    }
    if ( v8 < 0x88B8 )
    {
LABEL_28:
      v32 = 0;
      *(_BYTE *)(v2 + 552) = sub_1001EC00((int)v5);
      LOBYTE(v26) = sub_10005B40((char)v32);
      *(_BYTE *)(v2 + 553) = v26;
      return v26;
    }
LABEL_27:
    *(_DWORD *)(v2 + 512) = v6 - 40000;
    *(_DWORD *)(v2 + 528) = 0;
    goto LABEL_28;
  }
  if ( *(_BYTE *)(v23 + 448) == 3 )
  {
    *(_DWORD *)(v23 + 128) = v23 + 556;
    *(_DWORD *)(v23 + 124) = &unk_100606E8;
    *(_DWORD *)(v23 + 120) = v23 + 608;
    LOBYTE(v26) = sub_10003480(a1);
  }
  return v26;
}

//----- (10004120) --------------------------------------------------------
char __usercall sub_10004120@<al>(int a1@<ebx>)
{
  int v1; // ebp@1
  void *v2; // ecx@1
  void *v3; // ecx@1
  bool v4; // al@3
  int v5; // esi@10
  void *v6; // ecx@10
  char *v7; // eax@12
  _WORD *v8; // edi@13
  char v9; // cl@14
  char *v10; // edi@15
  char v11; // cl@16
  unsigned int v12; // eax@17
  char *v13; // esi@17
  char v14; // cl@18
  char v15; // al@25
  int v16; // edx@25
  int v17; // eax@25
  int v18; // eax@26
  char *v19; // eax@26
  _BYTE *v20; // esi@26
  char v21; // cl@27
  _DWORD *v22; // edi@29
  char v23; // al@30
  unsigned int v24; // eax@32
  char *v25; // edi@32
  char v26; // cl@33
  int v27; // ecx@34
  bool v28; // zf@34
  char *v29; // eax@38
  char v31; // [sp+6h] [bp-62h]@1
  char v32; // [sp+7h] [bp-61h]@1
  char v33[4]; // [sp+8h] [bp-60h]@26
  int v34; // [sp+Ch] [bp-5Ch]@10
  char v35; // [sp+15h] [bp-53h]@11
  int v36; // [sp+20h] [bp-48h]@10
  int v37; // [sp+24h] [bp-44h]@10
  void *v38; // [sp+28h] [bp-40h]@10
  int v39; // [sp+2Ch] [bp-3Ch]@10
  char v40; // [sp+30h] [bp-38h]@26

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 12);
  v32 = sub_10005B20();
  sub_10005F40((void *)(v1 + 300));
  v31 = *(_BYTE *)(v1 + 288);
  v4 = sub_1001FF60(v2) & 3 || sub_1001D640(v3) == 1;
  *(_BYTE *)(v1 + 288) = v4;
  if ( v4 )
  {
    if ( v31 != v4 )
    {
      sub_10001180(a1, 0, 0, 496, 56, 1);
      *(_BYTE *)(v1 + 232) = sub_100113A0(5);
      *(_BYTE *)(v1 + 240) = sub_100113A0(6);
      *(_BYTE *)(v1 + 248) = sub_100113A0(7);
    }
    *(_DWORD *)(v1 + 132) = &unk_10060030;
    *(_DWORD *)(v1 + 136) = &unk_10060834;
    *(_DWORD *)v1 = &unk_100605E8;
    if ( v32 )
      *(_DWORD *)v1 = &unk_10060668;
    *(_DWORD *)(v1 + 8) = v1 + 112;
    *(_DWORD *)(v1 + 4) = v1 + 80;
    *(_BYTE *)(v1 + 20) = 3;
    *(_BYTE *)(v1 + 21) = 3;
    *(_WORD *)(v1 + 256) = 6;
    sub_10005F90((int)&v34);
    v5 = v1 + 140;
    *(_DWORD *)v5 = v37;
    v6 = v38;
    *(_DWORD *)(v5 + 4) = v38;
    *(_DWORD *)(v5 + 8) = v39;
    if ( v36 != 0x3FFFF && v35 != 3 )
    {
      v7 = (char *)sub_10004660(v6, 0, v34);
      if ( v7 )
      {
        v8 = (_WORD *)(v1 + 139);
        do
        {
          v9 = *((_BYTE *)v8 + 1);
          v8 = (_WORD *)((char *)v8 + 1);
        }
        while ( v9 );
        *v8 = 32;
        v10 = v7;
        do
          v11 = *v7++;
        while ( v11 );
        v12 = v7 - v10;
        v13 = (char *)(v1 + 139);
        do
          v14 = (v13++)[1];
        while ( v14 );
        qmemcpy(v13, v10, v12);
      }
    }
    *(_BYTE *)(v1 + 292) = 0;
    *(_BYTE *)(v1 + 293) = v34;
    *(_BYTE *)(v1 + 294) = 1;
  }
  else
  {
    if ( v31 )
    {
      if ( *(_BYTE *)(a1 + 2) == 2 )
        sub_10001180(a1, 0, 0, 745, 28, 1);
      else
        sub_10001180(a1, 0, 0, 496, 56, 1);
    }
    sub_10002D60(a1, v32);
    *(_BYTE *)(v1 + 224) = sub_100113A0(0);
    *(_BYTE *)(v1 + 232) = sub_100113A0(1);
    *(_BYTE *)(v1 + 240) = sub_100113A0(2);
    v15 = sub_100113A0(3);
    v16 = *(_BYTE *)(v1 + 232);
    *(_BYTE *)(v1 + 248) = v15;
    v17 = *(_BYTE *)(v1 + 224);
    *(_BYTE *)(v1 + 608) = 0;
    *(_BYTE *)(v1 + 609) = 0;
    *(_BYTE *)(v1 + 610) = 0;
    *(_BYTE *)(v1 + 611) = 0;
    *(_BYTE *)(v1 + 612) = 0;
    *(_BYTE *)(v1 + 614) = 0;
    *(_BYTE *)(v1 + 615) = 0;
    *(_BYTE *)(v1 + 616) = 0;
    *(_BYTE *)(v1 + 617) = 0;
    *(_BYTE *)(v1 + 20) = 0;
    *(_BYTE *)(v1 + 21) = 0;
    *(_WORD *)(v1 + 256) = word_1005F6A0[v17];
    *(_WORD *)(v1 + 258) = word_1005F6A0[v16];
  }
  v18 = *(_BYTE *)(v1 + 248);
  *(_WORD *)(v1 + 260) = word_1005F6A0[*(_BYTE *)(v1 + 240)];
  *(_WORD *)(v1 + 262) = word_1005F6A0[v18];
  *(_BYTE *)(v1 + 116) = sub_1000F840((int)&unk_1005F984, v1 + 280) != 0 ? 0 : 3;
  *(_BYTE *)(v1 + 618) = 3;
  *(_BYTE *)(v1 + 620) = 3;
  sub_1001D5C0(v33, &v40);
  v19 = sub_1001FFA0(*(unsigned __int16 *)v33);
  v20 = (_BYTE *)(v1 + 449);
  do
  {
    v21 = *v19;
    *v20++ = *v19++;
  }
  while ( v21 );
  if ( *(_WORD *)v33 != 6 )
  {
    v22 = (_DWORD *)(v1 + 448);
    do
    {
      v23 = *((_BYTE *)v22 + 1);
      v22 = (_DWORD *)((char *)v22 + 1);
    }
    while ( v23 );
    *v22 = 2108704;
  }
  v24 = strlen(&v40) + 1;
  v25 = (char *)(v1 + 448);
  do
    v26 = (v25++)[1];
  while ( v26 );
  qmemcpy(v25, &v40, v24);
  v27 = *(_BYTE *)(v1 + 449) != 0 ? 3 : 0;
  v28 = *(_BYTE *)(v1 + 288) == 0;
  *(_BYTE *)(v1 + 76) = v27;
  if ( !v28 )
    sub_10004010(a1);
  if ( *(_BYTE *)(v1 + 499) )
    sub_10003860(a1, v27);
  sub_10015210(a1, *(_WORD **)(a1 + 52), *(char **)(v1 + 132), *(_DWORD *)(v1 + 136), 0, 255);
  sub_10015210(a1, *(_WORD **)(a1 + 52), *(char **)v1, *(_DWORD *)(v1 + 4), *(_DWORD *)(v1 + 8), 255);
  LOBYTE(v29) = sub_10015210(a1, *(_WORD **)(a1 + 52), (char *)&unk_1005F984, v1 + 12, v1 + 20, 255);
  if ( *(_BYTE *)(v1 + 288) )
  {
    v29 = *(char **)(v1 + 124);
    if ( v29 )
      LOBYTE(v29) = sub_10015210(a1, *(_WORD **)(a1 + 52), v29, *(_DWORD *)(v1 + 128), *(_DWORD *)(v1 + 120), 255);
  }
  *(_BYTE *)(a1 + 6) = 2;
  return (unsigned int)v29;
}
// 1005F6A0: using guessed type __int16 word_1005F6A0[];

//----- (10004550) --------------------------------------------------------
char __cdecl sub_10004550(int a1)
{
  int v1; // eax@1

  v1 = **(_WORD **)(a1 + 52);
  switch ( v1 )
  {
    case 32858:
      LOBYTE(v1) = sub_10001DE0(a1, *(_DWORD *)(a1 + 56), -32648);
      break;
    case 32833:
      LOBYTE(v1) = sub_10003BD0(a1);
      break;
    case 32789:
    case 32790:
      LOBYTE(v1) = sub_10002CE0(a1);
      break;
    case 32888:
      LOBYTE(v1) = sub_10004120(a1);
      break;
    default:
      return v1;
  }
  return v1;
}

//----- (10004660) --------------------------------------------------------
int __thiscall sub_10004660(void *this, void *a2, int a3)
{
  int v3; // eax@1
  void *v5; // ST14_4@1

  v5 = this;
  LOBYTE(v5) = sub_10018330((unsigned __int8)a2, a3);
  a3 = 0;
  a2 = v5;
  v3 = sub_1001E3C0(&a2, 1u, (int)&unk_10061378, 12, 8, 0);
  if ( (_BYTE)a3 && !byte_10061380[12 * v3] )
    v3 = 0;
  return dword_1006137C[3 * v3];
}
// 1006137C: using guessed type int dword_1006137C[];

//----- (100046A0) --------------------------------------------------------
char __cdecl sub_100046A0(char a1)
{
  return sub_10007160(a1, -122);
}

//----- (100046C0) --------------------------------------------------------
char sub_100046C0()
{
  sub_10007110();
  return sub_100046A0(0);
}

//----- (100046D0) --------------------------------------------------------
char sub_100046D0()
{
  return 0;
}

//----- (100046E0) --------------------------------------------------------
_WORD *__cdecl sub_100046E0(int a1)
{
  void *v1; // eax@4

  if ( *(_BYTE *)(a1 + 2) == 2 )
  {
    dword_100FD0C8 = (int)&unk_100F28C8;
    dword_100FD0CC = 48824376;
    dword_100FD0D0 = 50331656;
    *(_WORD *)(a1 + 16) = 745;
  }
  else
  {
    dword_100FD0C8 = (int)&unk_100F28C8;
    dword_100FD0CC = 32505912;
    dword_100FD0D0 = 33554440;
    *(_WORD *)(a1 + 16) = 496;
  }
  v1 = (void *)sub_10002760(a1, 332);
  *(_DWORD *)(a1 + 56) = v1;
  qmemcpy(v1, &unk_1005E428, 0x14Cu);
  sub_100015D0(a1, *(char **)(a1 + 56), 0, 0);
  **(_WORD **)(a1 + 52) = -32671;
  sub_10007020(a1 + 392, (int)&dword_100FD0C8, 0);
  *(_WORD *)(a1 + 428) = 0;
  *(_WORD *)(a1 + 430) = 0;
  return sub_10006FC0(a1 + 392);
}
// 100FD0C8: using guessed type int dword_100FD0C8;
// 100FD0CC: using guessed type int dword_100FD0CC;
// 100FD0D0: using guessed type int dword_100FD0D0;

//----- (10004750) --------------------------------------------------------
char __cdecl sub_10004750(int a1)
{
  __int16 v1; // dx@1
  __int16 v3; // [sp+0h] [bp-D0h]@1
  int v4; // [sp+4h] [bp-CCh]@1

  v1 = **(_WORD **)(a1 + 52) != -32749;
  v4 = 0;
  v3 = v1 - 32747;
  return sub_100016D0(a1, (int)&v3, 204);
}

//----- (100047C0) --------------------------------------------------------
char __cdecl sub_100047C0(int a1)
{
  __int16 v2; // [sp+4h] [bp-D0h]@1
  int v3; // [sp+8h] [bp-CCh]@1
  char (__cdecl *v4)(int); // [sp+Ch] [bp-C8h]@1

  ++*(_BYTE *)(a1 + 4);
  v2 = -32703;
  v3 = 0;
  v4 = sub_10004550;
  sub_100016D0(a1, (int)&v2, 204);
  **(_WORD **)(a1 + 52) = -32671;
  return sub_10004550(a1);
}

//----- (10004840) --------------------------------------------------------
#error "10004859: call analysis failed (funcsize=29)"

//----- (100048C0) --------------------------------------------------------
int __cdecl sub_100048C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_bitblt(&v8, a2, a3, a7, a1, a4, a5, a6);
}
// 100479FC: using guessed type int __cdecl gdi_pvg_bitblt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004910) --------------------------------------------------------
int __cdecl sub_10004910(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-1Ch]@1

  return gdi_pvg_draw_pixels(&v8, a5, a4, a7, a6, a3, a1, a2);
}
// 10047A02: using guessed type int __cdecl gdi_pvg_draw_pixels(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004960) --------------------------------------------------------
int sub_10004960()
{
  gdi_pvg_init();
  return sub_10004D00();
}
// 10047A08: using guessed type int gdi_pvg_init(void);

//----- (100049B0) --------------------------------------------------------
int __cdecl sub_100049B0(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v7; // [sp+0h] [bp-18h]@1

  return gdi_pvg_ortho(&v7, LODWORD(a4), LODWORD(a6), LODWORD(a1), LODWORD(a5), LODWORD(a2), LODWORD(a3));
}
// 10047A26: using guessed type int __cdecl gdi_pvg_ortho(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004A10) --------------------------------------------------------
char *__cdecl sub_10004A10(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10004D80();
  *(_DWORD *)(a5 + 596) = sub_10004DF0();
  sub_10004E10((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_1001E210(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10020EC0((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10004B40) --------------------------------------------------------
char sub_10004B40()
{
  char result; // al@1

  result = 0;
  byte_100FD158 = 0;
  byte_100FD159 = 0;
  return result;
}
// 100FD158: using guessed type char byte_100FD158;
// 100FD159: using guessed type char byte_100FD159;

//----- (10004B50) --------------------------------------------------------
char __cdecl sub_10004B50(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10004A10(-5, a1, a2, a4, a5);
  else
    sub_10004A10(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_1001E360((const char *)(a5 + 485), " DBGA", 100);
  sub_10004E10((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_100FD158 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_100FD159 )
LABEL_15:
      result = sub_10004E50(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 10005530: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 100FD158: using guessed type char byte_100FD158;
// 100FD159: using guessed type char byte_100FD159;

//----- (10004C50) --------------------------------------------------------
char __cdecl sub_10004C50(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10004B50(a1, a2, a3, a4, (int)&v5);
}

//----- (10004CC0) --------------------------------------------------------
int __cdecl sub_10004CC0(int a1, int a2, int a3)
{
  dword_100FD170 = a1;
  dword_100FD164 = a2;
  dword_100FD168 = a3;
  return gdi_pvg_create_window(&dword_100FD15C);
}
// 10047A38: using guessed type int __cdecl gdi_pvg_create_window(_DWORD);
// 100FD15C: using guessed type int dword_100FD15C;
// 100FD164: using guessed type int dword_100FD164;
// 100FD168: using guessed type int dword_100FD168;
// 100FD170: using guessed type int dword_100FD170;

//----- (10004D00) --------------------------------------------------------
int sub_10004D00()
{
  int result; // eax@1

  result = 0;
  dword_100FD170 = 0;
  dword_100FD164 = 0;
  dword_100FD168 = 59;
  dword_100FD15C = 1;
  dword_100FD160 = 0;
  dword_100FD16C = 0;
  return result;
}
// 100FD15C: using guessed type int dword_100FD15C;
// 100FD160: using guessed type int dword_100FD160;
// 100FD164: using guessed type int dword_100FD164;
// 100FD168: using guessed type int dword_100FD168;
// 100FD16C: using guessed type int dword_100FD16C;
// 100FD170: using guessed type int dword_100FD170;

//----- (10004D50) --------------------------------------------------------
int __cdecl sub_10004D50(int a1)
{
  int result; // eax@1

  result = a1;
  dword_100FD15C = a1;
  return result;
}
// 100FD15C: using guessed type int dword_100FD15C;

//----- (10004D60) --------------------------------------------------------
int __cdecl sub_10004D60(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A50: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10004D80) --------------------------------------------------------
int sub_10004D80()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A56: using guessed type int TSK_pvg_get_id(void);

//----- (10004DA0) --------------------------------------------------------
int __cdecl sub_10004DA0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A5C: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (10004DD0) --------------------------------------------------------
__int16 __cdecl sub_10004DD0(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A62: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (10004DF0) --------------------------------------------------------
int sub_10004DF0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A68: using guessed type int TSK_pvg_get_timer(void);

//----- (10004E10) --------------------------------------------------------
int __cdecl sub_10004E10(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A6E: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004E50) --------------------------------------------------------
int __cdecl sub_10004E50(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A7A: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10004E80) --------------------------------------------------------
int __cdecl sub_10004E80(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A80: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (10004EA0) --------------------------------------------------------
int __cdecl sub_10004EA0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A86: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (10004EC0) --------------------------------------------------------
int __cdecl sub_10004EC0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A8C: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (10004EF0) --------------------------------------------------------
int __cdecl sub_10004EF0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A92: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10004F20) --------------------------------------------------------
int __cdecl sub_10004F20(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A98: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10004F40) --------------------------------------------------------
int __cdecl sub_10004F40(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047A9E: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10004F60) --------------------------------------------------------
char __cdecl sub_10004F60(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_10004DF0();
  if ( sub_10004E80(a1) == 5 )
    goto LABEL_4;
  while ( sub_10004DF0() < v2 )
  {
    sub_10004F40(20);
    if ( sub_10004E80(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_10004E80(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10004C50("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10004FD0) --------------------------------------------------------
int __cdecl sub_10004FD0(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10004D80();
    sub_10004E10((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047AA4: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10005010) --------------------------------------------------------
int __cdecl sub_10005010(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10004EA0(a2);
  return result;
}
// 10064D58: using guessed type void *tsk_app_hdr_ptr;

//----- (10005040) --------------------------------------------------------
int __cdecl sub_10005040(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_10004EC0(a1, a2);
  return result;
}
// 10064D58: using guessed type void *tsk_app_hdr_ptr;

//----- (10005070) --------------------------------------------------------
int __cdecl sub_10005070(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 10047AAA: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10005090) --------------------------------------------------------
char __cdecl sub_10005090(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10005070(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10004C50("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (100050D0) --------------------------------------------------------
int __cdecl sub_100050D0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_10005070(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10005110) --------------------------------------------------------
int __cdecl sub_10005110(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10005070(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10005140) --------------------------------------------------------
int __cdecl sub_10005140(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 10047AB0: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10005160) --------------------------------------------------------
char __cdecl sub_10005160(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10005140(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10004C50("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (100051A0) --------------------------------------------------------
int __cdecl sub_100051A0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_10005070(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy_0(a2, a4, (unsigned __int16)a3);
    sub_10005140(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (10005200) --------------------------------------------------------
signed int __cdecl sub_10005200(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10031560(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit_1(v4);
      sub_10043F70(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_1010F9E0 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_1010F9E8[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_1010F9E0 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_10005550(
      v2,
      *(_DWORD *)(dword_1010F9E8[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_10005200(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 10047ABC: using guessed type int FIL_vfs_close(void);
// 1010F9E0: using guessed type int dword_1010F9E0;
// 1010F9E8: using guessed type int dword_1010F9E8[];

//----- (10005260) --------------------------------------------------------
int __cdecl sub_10005260(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 10047ACE: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100052D0) --------------------------------------------------------
signed int __cdecl sub_100052D0(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_10031560(a1);
    return sub_10032420(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_10005490(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_100058F0(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 10047AE0: using guessed type int FIL_vfs_read(void);

//----- (10005310) --------------------------------------------------------
signed int __cdecl sub_10005310(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10020F30(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_100058F0(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 10047AE6: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100053A0) --------------------------------------------------------
signed int __cdecl sub_100053A0(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_10020F90(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 10047AF2: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100053F0) --------------------------------------------------------
__int64 __cdecl sub_100053F0(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 10047AF8: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (10005410) --------------------------------------------------------
int __cdecl sub_10005410(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 10047AFE: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (10005440) --------------------------------------------------------
int __cdecl sub_10005440(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 10047B0A: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10005460) --------------------------------------------------------
char __cdecl sub_10005460(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10005200(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100052C0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10005490) --------------------------------------------------------
signed int __cdecl sub_10005490(unsigned int a1, int a2, int a3)
{
  return sub_100053A0(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (100054B0) --------------------------------------------------------
int __cdecl sub_100054B0(int a1, int a2, int a3)
{
  return sub_10005410(a1, a2, a3);
}

//----- (100054D0) --------------------------------------------------------
void __cdecl sub_100054D0(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10005A40(a1, a2);
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047B10: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (10005550) --------------------------------------------------------
unsigned int __cdecl sub_10005550(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_1010F9E8[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_1010F9A0[a1];
  dword_1010F9A0[a1] = a3 + v9;
  dword_1010F960[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_1010F960[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 1010F9A0: using guessed type int dword_1010F9A0[];
// 1010F9E8: using guessed type int dword_1010F9E8[];

//----- (10005700) --------------------------------------------------------
int __usercall sub_10005700@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_1010F9E8[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_1010F9E8[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 1010F9E8: using guessed type int dword_1010F9E8[];

//----- (100057B0) --------------------------------------------------------
int __cdecl sub_100057B0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10005700(a1);
  v3 = &dword_1010F9E8[a1];
  v4 = sub_10005310(
         *(_DWORD *)dword_1010F9E8[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_1010F9E8[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_1010F9A0[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 1010F9A0: using guessed type int dword_1010F9A0[];
// 1010F9E8: using guessed type int dword_1010F9E8[];

//----- (10005860) --------------------------------------------------------
int __usercall sub_10005860@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_1010F9E8[a1];
  v3 = (int *)(dword_1010F9A0[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_1010F9E8[a1] + 32)) % *(_WORD *)(dword_1010F9E8[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_100057B0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 1010F9A0: using guessed type int dword_1010F9A0[];
// 1010F9E8: using guessed type int dword_1010F9E8[];

//----- (100058F0) --------------------------------------------------------
unsigned int __cdecl sub_100058F0(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_1010F9E0 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_1010F9E8[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_1010F9E0 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_10004EC0(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_1010F9E8[v6] + 28);
        v12 = sub_10005860(v6, (unsigned int)v7 & *(_DWORD *)(dword_1010F9E8[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy_0(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_1010F9E8[v6] + 4) != 138 )
        sub_10004EA0(*(_DWORD *)(dword_1010F9E8[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_1010F9E8[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10004EA0(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 1010F9E0: using guessed type int dword_1010F9E0;
// 1010F9E8: using guessed type int dword_1010F9E8[];

//----- (10005A40) --------------------------------------------------------
void __cdecl sub_10005A40(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_1001D5E0(v2) && sub_1001D640(v3) != 1 )
    *a2 = 0;
}

//----- (10005A70) --------------------------------------------------------
double __cdecl sub_10005A70(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_10020BD0() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_101E741C + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_101E741C + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_101E741C + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10005B00) --------------------------------------------------------
signed int sub_10005B00()
{
  signed int result; // eax@2

  if ( sub_10020BD0() )
    result = *(_DWORD *)(dword_101E741C + 840);
  else
    result = 0x3FFFF;
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10005B20) --------------------------------------------------------
char sub_10005B20()
{
  char result; // al@2

  if ( sub_10020BD0() )
    result = *(_BYTE *)(dword_101E741C + 661);
  else
    result = 0;
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10005B40) --------------------------------------------------------
char __cdecl sub_10005B40(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@2
  char v3; // al@3

  v1 = 0;
  if ( sub_10020BD0() )
  {
    sub_10021020();
    v2 = *(_BYTE *)(dword_101E741C + 812);
    if ( v2 != -1 )
    {
      v3 = *(_BYTE *)(180 * v2 + dword_101E7410 + 671);
      if ( (v3 == 18 || v3 == 19 || v3 == 20 || v3 == 21 || v3 == 22) && (!a1 || v3 == 21) )
        v1 = 1;
    }
    sub_10021010();
  }
  return v1;
}
// 101E7410: using guessed type int dword_101E7410;
// 101E741C: using guessed type int dword_101E741C;

//----- (10005BB0) --------------------------------------------------------
char __cdecl sub_10005BB0(unsigned __int8 a1)
{
  if ( !sub_10020BD0() )
    return 0;
  if ( a1 < 0x66u )
  {
    sub_10021020();
    if ( a1 >= *(_BYTE *)(dword_101E7410 + 5)
      && a1 <= *(_BYTE *)(dword_101E7410 + 3)
      && *(_BYTE *)(180 * a1 + dword_101E7410 + 668) )
    {
      sub_10021010();
      return 1;
    }
    sub_10021010();
    return 0;
  }
  return 0;
}
// 101E7410: using guessed type int dword_101E7410;

//----- (10005CB0) --------------------------------------------------------
char __cdecl sub_10005CB0(char a1, char a2, float *a3)
{
  char v3; // bl@1
  double v4; // st7@3
  int v5; // edi@3
  int *v6; // eax@3
  char v8; // [sp+Fh] [bp-31h]@1
  float v9; // [sp+10h] [bp-30h]@3
  float v10; // [sp+10h] [bp-30h]@11
  char v11; // [sp+18h] [bp-28h]@2
  char v12; // [sp+26h] [bp-1Ah]@2

  *a3 = 0.0;
  v3 = 0;
  v8 = sub_10005B40(0);
  if ( !sub_10020BD0() )
    return v3;
  sub_10005F90((int)&v11);
  if ( v12 )
    return v3;
  sub_10021020();
  v4 = 0.0;
  v9 = 0.0;
  v5 = *(_DWORD *)(dword_101E741C + 296);
  v6 = (int *)(dword_101E741C + 296);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      if ( a1 == 2 )
      {
        v4 = *(float *)(dword_101E741C + 560) - *(float *)(dword_101E741C + 720);
        *a3 = v4;
        v3 = *(_BYTE *)(dword_101E741C + 673);
      }
      goto LABEL_11;
    }
    *a3 = *(float *)(dword_101E741C + 312);
    v4 = *(float *)(dword_101E741C + 328);
    goto LABEL_10;
  }
  if ( !v8 )
  {
    *a3 = *(float *)(dword_101E741C + 308);
    v4 = *(float *)(dword_101E741C + 324);
LABEL_10:
    v5 = *v6;
    v9 = v4;
    v3 = 1;
  }
LABEL_11:
  sub_10021010();
  sub_10021000(v5);
  v10 = v4 * v9 + *a3;
  *a3 = v10;
  if ( a1 != 2 )
    *a3 = v10 - sub_10005A70(a2);
  *a3 = sub_10047770(*a3);
  return v3;
}
// 10021000: using guessed type _DWORD __cdecl sub_10021000(_DWORD);
// 101E741C: using guessed type int dword_101E741C;

//----- (10005DF0) --------------------------------------------------------
char __cdecl sub_10005DF0(char a1, float *a2)
{
  double v2; // st7@1
  char v3; // bl@1
  char result; // al@13
  float v5; // [sp+8h] [bp-2Ch]@1
  char v6; // [sp+Ch] [bp-28h]@2
  char v7; // [sp+1Ah] [bp-1Ah]@2

  v2 = 0.0;
  *a2 = 0.0;
  v3 = 0;
  v5 = 0.0;
  if ( !sub_10020BD0() )
    return v3;
  sub_10005F90((int)&v6);
  if ( v7 || sub_10005B40(1) )
    return v3;
  sub_10021020();
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      *a2 = *(float *)(dword_101E741C + 316);
      v2 = *(float *)(dword_101E741C + 332);
    }
    else
    {
      if ( a1 != 2 )
        goto LABEL_11;
      *a2 = *(float *)(dword_101E741C + 340);
      v2 = *(float *)(dword_101E741C + 336);
    }
  }
  else
  {
    *a2 = *(float *)(dword_101E741C + 304);
    v2 = *(float *)(dword_101E741C + 320);
  }
  v5 = v2;
  v3 = 1;
LABEL_11:
  sub_10021000(*(_DWORD *)(dword_101E741C + 296));
  *a2 = v2 * v5 + *a2;
  sub_10021010();
  if ( a1 == 1 )
  {
    *(_DWORD *)a2 = COERCE_UNSIGNED_INT(*a2) & 0x7FFFFFFF;
    return v3;
  }
  if ( a1 || !*(_BYTE *)(dword_101E741C + 288) )
    return v3;
  result = v3;
  if ( (*(_DWORD *)a2 >> 31) & 1 )
    *a2 = 0.0;
  return result;
}
// 10021000: using guessed type _DWORD __cdecl sub_10021000(_DWORD);
// 101E741C: using guessed type int dword_101E741C;

//----- (10005F40) --------------------------------------------------------
bool __cdecl sub_10005F40(void *a1)
{
  bool result; // al@2

  if ( sub_10020BD0() )
  {
    sub_10021020();
    qmemcpy(a1, (const void *)(dword_101E741C + 1356), 0x94u);
    result = sub_10021010();
  }
  else
  {
    memset(a1, 0, 0x94u);
    result = (char)a1;
    *((float *)a1 + 11) = 9.9999996e24;
    *((float *)a1 + 12) = 9.9999996e24;
    *((_BYTE *)a1 + 1) = 0;
    *((float *)a1 + 14) = 9.9999996e24;
    *((_BYTE *)a1 + 25) = 0;
    *((float *)a1 + 15) = 9.9999996e24;
    *((_BYTE *)a1 + 7) = 1;
    *((float *)a1 + 18) = 9.9999996e24;
    *((_BYTE *)a1 + 10) = 0;
    *((float *)a1 + 17) = 9.9999996e24;
    *((_DWORD *)a1 + 9) = -1;
    *((float *)a1 + 20) = 9.9999996e24;
    *((_BYTE *)a1 + 19) = -1;
    *((float *)a1 + 24) = 9.9999996e24;
    *((_DWORD *)a1 + 10) = -1;
    *((float *)a1 + 26) = 9.9999996e24;
    *((_BYTE *)a1 + 20) = -1;
    *((float *)a1 + 27) = 9.9999996e24;
    *((_BYTE *)a1 + 8) = 0;
    *((float *)a1 + 31) = 9.9999996e24;
    *((_BYTE *)a1 + 9) = 0;
    *((float *)a1 + 32) = 9.9999996e24;
    *((_BYTE *)a1 + 13) = 0;
    *((float *)a1 + 33) = 9.9999996e24;
    *((_BYTE *)a1 + 15) = 0;
    *((float *)a1 + 34) = 9.9999996e24;
    *((_BYTE *)a1 + 14) = 0;
    *((float *)a1 + 16) = 9.9999996e24;
    *((_BYTE *)a1 + 16) = 0;
    *((float *)a1 + 35) = 9.9999996e24;
    *((_BYTE *)a1 + 17) = 0;
    *((float *)a1 + 36) = 9.9999996e24;
    *((_BYTE *)a1 + 24) = 0;
    *((float *)a1 + 19) = 9.9999996e24;
    *((float *)a1 + 21) = 9.9999996e24;
    *((float *)a1 + 22) = 9.9999996e24;
    *((float *)a1 + 23) = 9.9999996e24;
    *((float *)a1 + 25) = 9.9999996e24;
    *((float *)a1 + 28) = 9.9999996e24;
    *((float *)a1 + 29) = 0.0;
    *((float *)a1 + 30) = 9.9999996e24;
  }
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10005F90) --------------------------------------------------------
char __cdecl sub_10005F90(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  char v3; // al@4
  unsigned __int8 v4; // al@16

  *(_DWORD *)(a1 + 16) = 0x3FFFF;
  *(_BYTE *)a1 = -1;
  *(_DWORD *)(a1 + 20) = 0x3FFFF;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = 1;
  *(_BYTE *)(a1 + 4) = 6;
  *(_BYTE *)(a1 + 5) = -1;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 11) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 1;
  *(_BYTE *)(a1 + 15) = 0;
  result = sub_10020BD0();
  if ( result )
  {
    sub_10021020();
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(dword_101E741C + 815);
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(dword_101E741C + 94);
    *(_BYTE *)(a1 + 11) = *(_BYTE *)(dword_101E741C + 97);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_101E7410 + 239);
    *(_BYTE *)(a1 + 15) = *(_BYTE *)(dword_101E741C + 826);
    strncpy((char *)(a1 + 24), (const char *)(dword_101E741C + 872), 0xCu);
    *(_BYTE *)(a1 + 35) = 0;
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(dword_101E741C + 784);
    *(_BYTE *)(a1 + 14) = 0;
    v2 = dword_101E741C;
    if ( *(_BYTE *)(dword_101E741C + 669) && !*(_BYTE *)(dword_101E741C + 667)
      || (v3 = *(_BYTE *)(dword_101E741C + 159)) != 0
      && *(_BYTE *)(dword_101E741C + 667)
      && !*(_BYTE *)(dword_101E741C + 661)
      && (v3 != 2 || -1.0 == *(float *)(dword_101E741C + 116))
      || !*(_BYTE *)(dword_101E741C + 672) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_101E741C;
    }
    else if ( *(_BYTE *)(dword_101E741C + 101) == 4
           && *(_BYTE *)(dword_101E741C + 812) >= *(_BYTE *)(dword_101E7410 + 241)
           && !*(_BYTE *)(dword_101E741C + 89)
           && -1.0 == *(float *)(dword_101E741C + 116) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_101E741C;
    }
    *(_BYTE *)(a1 + 9) = *(_BYTE *)(v2 + 816);
    *(_BYTE *)(a1 + 5) = *(_BYTE *)(dword_101E7410 + 241);
    v4 = *(_BYTE *)(a1 + 9) - 1;
    *(_BYTE *)(a1 + 10) = *(_BYTE *)(dword_101E7410 + 244);
    if ( v4 > 2u )
    {
      *(_BYTE *)(a1 + 9) = 0;
      *(_DWORD *)(a1 + 16) = 0x3FFFF;
      *(_DWORD *)(a1 + 20) = 0x3FFFF;
      *(_BYTE *)(a1 + 12) = 0;
      *(_BYTE *)a1 = -1;
      *(_BYTE *)(a1 + 2) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      *(_BYTE *)(a1 + 7) = -1;
      *(_BYTE *)(a1 + 14) = 1;
      result = sub_10021010();
    }
    else
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(dword_101E741C + 836);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(dword_101E741C + 840);
      *(_BYTE *)a1 = *(_BYTE *)(dword_101E741C + 812);
      *(_BYTE *)(a1 + 13) = *(_BYTE *)(dword_101E741C + 825);
      if ( *(_DWORD *)(dword_101E741C + 892) )
        *(_BYTE *)(a1 + 3) = 0;
      else
        *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_101E741C + 288);
      *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_101E741C + 288);
      *(_BYTE *)(a1 + 7) = *(_BYTE *)(dword_101E741C + 813);
      *(_BYTE *)(a1 + 12) = *(_BYTE *)(dword_101E7410 + 4);
      result = sub_10021010();
    }
  }
  return result;
}
// 101E7410: using guessed type int dword_101E7410;
// 101E741C: using guessed type int dword_101E741C;

//----- (100061E0) --------------------------------------------------------
char sub_100061E0()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_10020BD0() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_101E741C + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_101E741C + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_101E741C + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10006230) --------------------------------------------------------
void __cdecl sub_10006230(float *a1, float *a2, int a3)
{
  float *v3; // esi@1
  float *v4; // edi@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1
  float v7; // [sp+24h] [bp+4h]@1
  float v8; // [sp+24h] [bp+4h]@1
  float v9; // [sp+24h] [bp+4h]@1
  float v10; // [sp+24h] [bp+4h]@1
  float v11; // [sp+28h] [bp+8h]@1
  float v12; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v7 = (*a1 + *a2) * 0.5;
  sub_10047800(v7, (int)&v5, (int)&v6);
  v8 = 1.0 / (1.0 - *(float *)&v5 * (0.00669437999013 * *(float *)&v5));
  v11 = sqrt(v8) * 6378137.0;
  v9 = 0.99330562000987 * v11 * v8;
  v12 = v11 * *(float *)&v6;
  *(float *)(a3 + 4) = (*v4 - *v3) * v9;
  v10 = v4[1] - v3[1];
  *(float *)a3 = v10;
  *(float *)a3 = sub_10047770(v10) * v12;
}

//----- (100062F0) --------------------------------------------------------
double __cdecl sub_100062F0(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)a1 * *(float *)a2);
}

//----- (10006310) --------------------------------------------------------
int __cdecl sub_10006310(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (10006420) --------------------------------------------------------
unsigned int __cdecl sub_10006420(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  unsigned int result; // eax@2
  int v9; // [sp+8h] [bp+8h]@1

  v9 = sub_10006F60(a1, a2, a3, a4, a5, a6, a7, a8);
  if ( *(_BYTE *)(*(_DWORD *)(v9 + 52) + 8) == 8 )
  {
    if ( *(_DWORD *)(v9 + 68) )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 1 )
      {
        *(_WORD *)(v9 + 38) = **(_WORD **)(v9 + 68);
        *(_WORD *)(v9 + 36) = *(_WORD *)(*(_DWORD *)(v9 + 68) + 2);
        result = sub_10006500(v9);
      }
      else
      {
        result = sub_10006A30(v9);
      }
    }
    else if ( *(_BYTE *)(*(_DWORD *)(v9 + 56) + 8) == 8 )
    {
      result = sub_10006850(v9);
    }
    else
    {
      result = sub_10006A30(v9);
    }
  }
  else
  {
    result = sub_10006A30(v9);
  }
  return result;
}

//----- (10006500) --------------------------------------------------------
int __cdecl sub_10006500(int a1)
{
  int result; // eax@1
  int v2; // ST1C_4@10
  int v3; // [sp+0h] [bp-44h]@3
  unsigned int v4; // [sp+4h] [bp-40h]@5
  unsigned int v5; // [sp+4h] [bp-40h]@9
  unsigned __int16 v6; // [sp+8h] [bp-3Ch]@3
  int v7; // [sp+Ch] [bp-38h]@5
  unsigned __int16 v8; // [sp+10h] [bp-34h]@3
  unsigned __int16 v9; // [sp+14h] [bp-30h]@2
  signed int v10; // [sp+1Ch] [bp-28h]@9
  unsigned int *v11; // [sp+20h] [bp-24h]@9
  int v12; // [sp+24h] [bp-20h]@11
  int v13; // [sp+28h] [bp-1Ch]@9
  unsigned int v14; // [sp+2Ch] [bp-18h]@9
  unsigned __int16 v15; // [sp+30h] [bp-14h]@2
  unsigned int *v16; // [sp+34h] [bp-10h]@3
  int v17; // [sp+38h] [bp-Ch]@4
  unsigned int v18; // [sp+3Ch] [bp-8h]@2
  unsigned __int16 v19; // [sp+40h] [bp-4h]@2
  int v20; // [sp+4Ch] [bp+8h]@1

  result = sub_10007C60(a1);
  v20 = result;
  if ( result )
  {
    v19 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v18 = ((unsigned int)*(_WORD *)(result + 14) >> 3)
        + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10)
        + **(_DWORD **)(result + 56);
    v9 = 8 * (*(_WORD *)(result + 14) >> 3) - *(_WORD *)(result + 14) + 8;
    v15 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    if ( !(*(_WORD *)(*(_DWORD *)(result + 52) + 10) << 30) )
    {
      v16 = (unsigned int *)(**(_DWORD **)(result + 52)
                           + *(_WORD *)(result + 8) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                           + 4 * (8 * *(_WORD *)(result + 10) >> 5));
      v8 = 32 * (8 * *(_WORD *)(result + 10) >> 5) - 8 * *(_WORD *)(result + 10) + 32;
      v3 = *(_WORD *)(result + 16);
      v6 = *(_WORD *)(result + 18);
      do
      {
        v17 = v9;
        if ( v18 << 31 )
        {
          v4 = *(_BYTE *)v18;
          v7 = v18 + 1;
        }
        else if ( v18 << 30 )
        {
          v4 = *(_WORD *)v18;
          v7 = v18 + 2;
          v17 = v9 + 8;
        }
        else
        {
          v4 = *(_DWORD *)v18;
          v7 = v18 + 4;
          v17 = v9 + 24;
        }
        v5 = (v4 >> ((-v9 + 8) & 0x1F)) | (v4 << (32 - ((-v9 + 8) & 0x1F)));
        v10 = v8;
        v11 = v16;
        v14 = (*v16 >> ((32 - v8) & 0x1F)) | (*v16 << (32 - ((32 - v8) & 0x1F)));
        v13 = v6;
        do
        {
          v2 = 2 * v5 & 3;
          v5 >>= 1;
          if ( v2 )
            v12 = *(_WORD *)(v20 + 38);
          else
            v12 = *(_WORD *)(v20 + 36);
          if ( (signed __int16)v12 >= 0 )
            v14 = (v14 >> 8) | (v12 << 24);
          else
            v14 = (v14 >> 8) | (v14 << 24);
          if ( --v13 )
          {
            v10 -= 8;
            if ( !v10 )
            {
              *v11 = v14;
              ++v11;
              v10 = 32;
              v14 = *v11;
            }
            if ( !--v17 )
            {
              if ( v7 << 30 )
              {
                v17 = 16;
                v5 = *(_WORD *)v7;
                v7 += 2;
              }
              else
              {
                v17 = 32;
                v5 = *(_DWORD *)v7;
                v7 += 4;
              }
            }
          }
        }
        while ( v13 );
        *v11 = (v14 >> ((v10 - 8) & 0x1F)) | (v14 << (32 - ((v10 - 8) & 0x1F)));
        v18 += v19;
        result = (int)v16 + v15;
        v16 = (unsigned int *)((char *)v16 + v15);
        --v3;
      }
      while ( v3 );
    }
  }
  return result;
}

//----- (10006850) --------------------------------------------------------
int __cdecl sub_10006850(int a1)
{
  int result; // eax@1
  signed int v2; // [sp+4h] [bp-30h]@16
  int v3; // [sp+8h] [bp-2Ch]@9
  char *v4; // [sp+Ch] [bp-28h]@4
  _BYTE *v5; // [sp+Ch] [bp-28h]@10
  _BYTE *v6; // [sp+Ch] [bp-28h]@12
  _BYTE *v7; // [sp+Ch] [bp-28h]@14
  char *v8; // [sp+10h] [bp-24h]@4
  _BYTE *v9; // [sp+10h] [bp-24h]@10
  _BYTE *v10; // [sp+10h] [bp-24h]@12
  _BYTE *v11; // [sp+10h] [bp-24h]@14
  unsigned int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+14h] [bp-20h]@10
  int v14; // [sp+14h] [bp-20h]@12
  int v15; // [sp+18h] [bp-1Ch]@2
  int v16; // [sp+1Ch] [bp-18h]@2
  int v17; // [sp+20h] [bp-14h]@2
  size_t v18; // [sp+24h] [bp-10h]@2
  char *v19; // [sp+28h] [bp-Ch]@2
  int v20; // [sp+2Ch] [bp-8h]@2
  char *v21; // [sp+30h] [bp-4h]@2
  _BYTE *v22; // [sp+3Ch] [bp+8h]@1

  result = sub_10007C60(a1);
  v22 = (_BYTE *)result;
  if ( result )
  {
    v18 = *(_WORD *)(result + 18);
    v15 = *(_WORD *)(result + 16);
    v17 = *(_WORD *)(*(_DWORD *)(result + 52) + 10);
    v16 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v21 = (char *)(*(_WORD *)(result + 14) + v16 * *(_WORD *)(result + 12) + **(_DWORD **)(result + 56));
    v19 = (char *)(*(_WORD *)(result + 10) + v17 * *(_WORD *)(result + 8) + **(_DWORD **)(result + 52));
    v20 = 0;
    do
    {
      if ( v20 )
        goto LABEL_26;
      v12 = v18;
      v8 = v21;
      v4 = v19;
      while ( v12 >= 4 )
      {
        if ( *(_DWORD *)v4 != *(_DWORD *)v8 )
          goto LABEL_9;
        v12 -= 4;
        v8 += 4;
        v4 += 4;
      }
      if ( !v12 )
      {
LABEL_16:
        v2 = 0;
        goto LABEL_19;
      }
LABEL_9:
      v3 = (unsigned __int8)*v4 - (unsigned __int8)*v8;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v8 )
      {
        v13 = v12 - 1;
        v9 = v8 + 1;
        v5 = v4 + 1;
        if ( !v13 )
          goto LABEL_16;
        v3 = *v5 - *v9;
        if ( *v5 == *v9 )
        {
          v14 = v13 - 1;
          v10 = v9 + 1;
          v6 = v5 + 1;
          if ( !v14 )
            goto LABEL_16;
          v3 = *v6 - *v10;
          if ( *v6 == *v10 )
          {
            v11 = v10 + 1;
            v7 = v6 + 1;
            if ( v14 == 1 )
              goto LABEL_16;
            v3 = *v7 - *v11;
            if ( *v7 == *v11 )
              goto LABEL_16;
          }
        }
      }
      v2 = 1;
      if ( v3 <= 0 )
        v2 = -1;
LABEL_19:
      if ( v2 )
      {
LABEL_26:
        ++v20;
        memcpy_0(v19, v21, v18);
      }
      v21 += v16;
      v19 += v17;
      result = v15-- - 1;
    }
    while ( v15 );
    if ( !v20 )
      *v22 = 0;
  }
  return result;
}

//----- (10006A30) --------------------------------------------------------
unsigned int __cdecl sub_10006A30(int a1)
{
  unsigned int result; // eax@1
  unsigned int v2; // ST08_4@5
  unsigned int v3; // ST28_4@6
  int v4; // ST28_4@13
  int v5; // [sp+0h] [bp-50h]@4
  unsigned int v6; // [sp+4h] [bp-4Ch]@5
  int v7; // [sp+8h] [bp-48h]@4
  unsigned __int16 v8; // [sp+Ch] [bp-44h]@4
  int *v9; // [sp+10h] [bp-40h]@5
  unsigned __int16 v10; // [sp+14h] [bp-3Ch]@4
  int v11; // [sp+18h] [bp-38h]@3
  int v12; // [sp+18h] [bp-38h]@5
  unsigned __int16 v13; // [sp+20h] [bp-30h]@3
  unsigned int *v14; // [sp+2Ch] [bp-24h]@5
  signed int v15; // [sp+30h] [bp-20h]@13
  int v16; // [sp+34h] [bp-1Ch]@5
  unsigned int v17; // [sp+38h] [bp-18h]@5
  unsigned __int16 v18; // [sp+3Ch] [bp-14h]@3
  unsigned int *v19; // [sp+40h] [bp-10h]@4
  int v20; // [sp+48h] [bp-8h]@2
  int v21; // [sp+48h] [bp-8h]@3
  unsigned __int16 v22; // [sp+4Ch] [bp-4h]@2
  unsigned int v23; // [sp+58h] [bp+8h]@1

  result = sub_10007C60(a1);
  v23 = result;
  if ( result )
  {
    v22 = *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    v20 = **(_DWORD **)(result + 56) + *(_WORD *)(result + 12) * *(_WORD *)(*(_DWORD *)(result + 56) + 10);
    result = *(_DWORD *)(result + 56);
    if ( (unsigned int)*(_BYTE *)(result + 8) < 9 )
    {
      v21 = v20 + 4 * ((signed int)*(_WORD *)(v23 + 14) << byte_100686B8[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)] >> 5);
      v13 = 32 - ((*(_WORD *)(v23 + 14) << byte_100686B8[*(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)]) & 0x1F);
      v18 = *(_WORD *)(*(_DWORD *)(v23 + 52) + 10);
      v11 = *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8) | (*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8) << 8);
      result = *(_BYTE *)(*(_DWORD *)(v23 + 52) + 8);
      if ( result < 9 )
      {
        v19 = (unsigned int *)(**(_DWORD **)(v23 + 52)
                             + *(_WORD *)(v23 + 8) * *(_WORD *)(*(_DWORD *)(v23 + 52) + 10)
                             + 4
                             * ((signed int)*(_WORD *)(v23 + 10) << byte_100686B8[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)] >> 5));
        v10 = 32 - ((*(_WORD *)(v23 + 10) << byte_100686B8[*(_BYTE *)(*(_DWORD *)(v23 + 52) + 8)]) & 0x1F);
        v8 = *(_WORD *)(v23 + 18);
        v5 = *(_WORD *)(v23 + 16);
        v7 = (1 << *(_BYTE *)(*(_DWORD *)(v23 + 56) + 8)) - 1;
        do
        {
          v2 = *(_DWORD *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5));
          v9 = (int *)(v21 - (v21 & 3) - 4 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 4);
          v6 = (v2 >> (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)) | (v2 << (32 - (31 * (v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5)) & 0x1F)));
          v14 = v19;
          v17 = (*v19 >> (31 * v10 & 0x1F)) | (*v19 << (32 - (31 * v10 & 0x1F)));
          v12 = (unsigned __int16)v11 | (((v13 - 8 * (v21 & 3) - 32 * ((v13 - 8 * (v21 & 3) - 1) >> 5) + 127) | ((v10 + 127) << 8)) << 16);
          v16 = v8;
          if ( *(_DWORD *)(v23 + 68) )
          {
            do
            {
              v4 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v15 = *(_WORD *)(*(_DWORD *)(v23 + 68) + 2 * v4);
              if ( (signed __int16)v15 >= 0 )
                v17 = (v15 >> (BYTE1(v12) & 0x1F)) | (v15 << (32 - (BYTE1(v12) & 0x1F))) | ((unsigned __int64)v17 >> SBYTE1(v12));
              else
                v17 = (v17 >> (BYTE1(v12) & 0x1F)) | (v17 << (32 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( (signed __int16)v16 > 0 );
          }
          else
          {
            do
            {
              v3 = v6 & v7;
              v6 = (unsigned __int64)v6 >> v12;
              v17 = ((unsigned __int64)v17 >> SBYTE1(v12)) | (v3 >> (BYTE1(v12) & 0x1F)) | (v3 << (32
                                                                                                 - (BYTE1(v12) & 0x1F)));
              if ( --v16 )
              {
                v12 *= -65535;
                if ( v12 >= 0 )
                {
                  v12 += 0x20000000;
                  *v14 = v17;
                  ++v14;
                  v17 = *v14;
                }
                if ( !(v12 & 0x800000) )
                {
                  v12 += 0x200000;
                  v6 = *v9;
                  ++v9;
                }
              }
            }
            while ( v16 );
          }
          v11 = -65535 * v12;
          *v14 = (v17 >> ((BYTE3(v11) - 127) & 0x1F)) | (v17 << (32 - ((BYTE3(v11) - 127) & 0x1F)));
          v21 += v22;
          result = (unsigned int)v19 + v18;
          v19 = (unsigned int *)((char *)v19 + v18);
          --v5;
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (10006F60) --------------------------------------------------------
int __cdecl sub_10006F60(int a1, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8)
{
  *(_DWORD *)(a1 + 56) = a2;
  *(_WORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 12) = a4;
  *(_WORD *)(a1 + 10) = a5;
  *(_WORD *)(a1 + 8) = a6;
  *(_WORD *)(a1 + 18) = a7;
  *(_WORD *)(a1 + 16) = a8;
  return a1;
}

//----- (10006FC0) --------------------------------------------------------
_WORD *__cdecl sub_10006FC0(int a1)
{
  _WORD *result; // eax@1

  result = (_WORD *)a1;
  if ( *(_WORD *)(a1 + 36) != 0xFFFF )
  {
    result = *(_WORD **)(a1 + 52);
    if ( !(result[5] << 30) )
    {
      *(_BYTE *)a1 = 1;
      result = memset(
                 **(void ***)(a1 + 52),
                 *(_WORD *)(a1 + 36),
                 *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 4));
    }
  }
  return result;
}

//----- (10007020) --------------------------------------------------------
int __cdecl sub_10007020(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_10006310(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (10007110) --------------------------------------------------------
void sub_10007110()
{
  ;
}

//----- (10007120) --------------------------------------------------------
int __cdecl sub_10007120(int a1, _BYTE *a2, int a3)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 2) )
    result = 0;
  else
    result = sub_10007B70(a1, a2, a3);
  return result;
}

//----- (10007160) --------------------------------------------------------
char __cdecl sub_10007160(char a1, char a2)
{
  char result; // al@1

  result = a1;
  byte_1010FA29 = a1;
  byte_1010FA28 = a2;
  return result;
}
// 1010FA28: using guessed type char byte_1010FA28;
// 1010FA29: using guessed type char byte_1010FA29;

//----- (10007180) --------------------------------------------------------
int __cdecl sub_10007180(int a1, int a2, _BYTE *a3, __int16 a4, int a5, __int16 a6, int a7)
{
  int result; // eax@12
  __int16 v8; // ST1C_2@20
  __int16 v9; // ST1E_2@43
  __int16 v10; // ST1C_2@56
  __int16 v11; // [sp+8h] [bp-8Ch]@17
  __int16 v12; // [sp+8h] [bp-8Ch]@43
  __int16 v13; // [sp+Ah] [bp-8Ah]@17
  __int16 v14; // [sp+Ah] [bp-8Ah]@43
  __int16 *v15; // [sp+10h] [bp-84h]@3
  unsigned __int8 v16; // [sp+17h] [bp-7Dh]@1
  int v17; // [sp+18h] [bp-7Ch]@47
  int v18; // [sp+1Ch] [bp-78h]@17
  int v19; // [sp+20h] [bp-74h]@11
  __int16 v20; // [sp+28h] [bp-6Ch]@29
  int v21; // [sp+2Ch] [bp-68h]@50
  int v22; // [sp+30h] [bp-64h]@47
  int i; // [sp+34h] [bp-60h]@13
  signed int v24; // [sp+38h] [bp-5Ch]@15
  unsigned __int8 v25; // [sp+3Eh] [bp-56h]@1
  bool v26; // [sp+3Fh] [bp-55h]@1
  char v27; // [sp+40h] [bp-54h]@45
  __int16 v28; // [sp+44h] [bp-50h]@43
  __int16 v29; // [sp+46h] [bp-4Eh]@56
  char v30; // [sp+48h] [bp-4Ch]@43
  char v31; // [sp+49h] [bp-4Bh]@46
  __int16 v32; // [sp+4Ah] [bp-4Ah]@56
  unsigned __int8 v33; // [sp+4Fh] [bp-45h]@1
  int v34; // [sp+50h] [bp-44h]@15
  __int16 v35; // [sp+54h] [bp-40h]@22
  int v36; // [sp+58h] [bp-3Ch]@45
  int v37; // [sp+5Ch] [bp-38h]@44
  int v38; // [sp+60h] [bp-34h]@28
  __int16 v39; // [sp+64h] [bp-30h]@17
  __int16 v40; // [sp+66h] [bp-2Eh]@17
  __int16 v41; // [sp+68h] [bp-2Ch]@55
  __int16 v42; // [sp+6Ah] [bp-2Ah]@55
  unsigned __int16 v43; // [sp+6Ch] [bp-28h]@24
  int v44; // [sp+70h] [bp-24h]@29
  char v45; // [sp+75h] [bp-1Fh]@43
  unsigned __int8 v46; // [sp+76h] [bp-1Eh]@1
  char v47; // [sp+77h] [bp-1Dh]@43
  int v48; // [sp+78h] [bp-1Ch]@22
  int v49; // [sp+7Ch] [bp-18h]@23
  __int16 v50; // [sp+80h] [bp-14h]@55
  __int16 v51; // [sp+82h] [bp-12h]@55
  __int16 v52; // [sp+84h] [bp-10h]@24
  int v53; // [sp+88h] [bp-Ch]@4
  int v54; // [sp+8Ch] [bp-8h]@19
  __int16 v55; // [sp+90h] [bp-4h]@17

  v16 = (a5 & 0xE000u) >> 13;
  v46 = (unsigned __int8)(a5 & 0x70) >> 4;
  v25 = (a5 & 0x380u) >> 7;
  v33 = (a5 & 0x1C00u) >> 10;
  v26 = 1;
  if ( a5 & 0x40000000 || a5 & 0x80000000 )
  {
    v15 = &a6;
    if ( a5 & 0x40000000 )
    {
      v15 = (__int16 *)&a7;
      v53 = a6;
      v16 = (a6 & 0xFF000000) >> 24;
      v46 = a6;
      v25 = (unsigned __int16)(a6 & 0xFF00) >> 8;
      v33 = (a6 & 0xFF0000u) >> 16;
    }
    if ( a5 & 0x80000000 )
    {
      if ( *(_DWORD *)v15 )
      {
        if ( *(_DWORD *)v15 == 2 )
          v26 = sub_100079C0(a3) == 0;
        else
          v26 = 0;
      }
      else
      {
        v26 = 1;
      }
    }
  }
  v19 = 0;
  if ( *(_BYTE *)(a2 + 3) & 3 )
  {
    result = 0;
  }
  else
  {
    i = sub_10007120(a2, a3, a5);
    if ( !a4 )
      a4 = i;
    v34 = a4;
    v24 = ((a5 & 0x3F0000u) >> 16) - 1;
    if ( v24 < 0 )
      v24 = *(_WORD *)(a2 + 28);
    v18 = *(_WORD *)(a2 + 22);
    v11 = *(_WORD *)(a1 + 46);
    v55 = *(_WORD *)(a1 + 44);
    v13 = v55 - (*(_WORD *)(a2 + 24) - 1);
    v39 = *(_WORD *)(a1 + 42);
    v40 = *(_WORD *)(a1 + 40);
    if ( a5 & 3 )
    {
      if ( (a5 & 3) == 1 )
      {
        v54 = v11 - v34 / 2;
        v11 -= i / 2;
      }
      else
      {
        v54 = v11;
      }
    }
    else
    {
      v8 = v11 + 1;
      v54 = v8 - v34;
      v11 = v8 - i;
    }
    v35 = v13;
    v48 = v18;
    if ( a5 & 0xC )
    {
      v35 += *(_WORD *)(a2 + 26);
      v48 -= v18 - *(_WORD *)(a2 + 24) + *(_WORD *)(a2 + 26);
      v54 -= v46;
      v49 = v25;
      v34 += v25 + v46;
      if ( (a5 & 0xC) == 4 )
      {
        v52 = *(_WORD *)(a1 + 6);
        v43 = *(_WORD *)(a1 + 50);
        *(_WORD *)(a1 + 6) = 3;
        *(_WORD *)(a1 + 50) = *(_WORD *)(a1 + 36);
        v49 = v33;
        v35 -= v33;
        v48 += v33;
        if ( v33 > (signed int)*(_WORD *)(a2 + 26) )
          sub_10008300(a1, v54, v35, v34, v49 - *(_WORD *)(a2 + 26));
        v49 = v16;
        v48 += v16;
        if ( v16 > v18 - *(_WORD *)(a2 + 24) )
          sub_10008300(a1, v54, v18 + v13, v34, v49 - (v18 - *(_WORD *)(a2 + 24)));
        v38 = v11 - v54;
        if ( i > a4 )
        {
          v20 = a4 + v11;
          v44 = v25;
        }
        else
        {
          v20 = i + v11;
          v44 = v34 - (i + v38);
        }
        if ( v38 > 0 )
          sub_10008300(a1, v54, v35, v38, v48);
        if ( v44 > 0 )
          sub_10008300(a1, v20, v35, v44, v48);
        *(_WORD *)(a1 + 50) = v43;
        *(_WORD *)(a1 + 6) = v52;
      }
    }
    if ( v35 <= v13 )
      v35 = 0;
    else
      v35 -= v13;
    if ( v48 >= v18 - v35 )
      v48 = v18 - v35;
    if ( i < a4 )
      a4 = i;
    v30 = 1;
    v47 = 0;
    v45 = (*(_BYTE *)(a2 + 3) & 3) << 6;
    v12 = v39 + v11;
    v9 = v40 + v13;
    v52 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = 2;
    v14 = v35 + v9;
    v28 = v18;
    if ( i )
    {
      v37 = (a5 & 0x3FC00000u) >> 22;
      for ( i = 0; !sub_10007A60(a2, &a3, &v27, &v36, v26); i += v21 + (signed __int16)v36 )
      {
        v31 = v47;
        if ( v37 <= v36 )
        {
          v22 = 0;
          v17 = 0;
        }
        else
        {
          v22 = (v37 - v36) / 2;
          v17 = v37 - v36 - v22;
        }
        v21 = i <= 0 ? v22 : v22 + v24 + v19;
        if ( v36 + v21 + i > a4 )
          break;
        v19 = v17;
        v43 = *(_WORD *)(a1 + 38);
        if ( v21 > 0 && v43 != 0xFFFF )
        {
          *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
          v50 = v14;
          v51 = v12;
          v41 = v48;
          v42 = v21;
          sub_10007E30(a1, (signed __int16)v21 + (v12 << 16), (signed __int16)v48 + (v14 << 16));
          *(_WORD *)(a1 + 38) = v43;
        }
        v10 = v21 + v12;
        *(_WORD *)(a1 + 8) = v14;
        *(_WORD *)(a1 + 10) = v10;
        *(_WORD *)(a1 + 16) = v48;
        *(_WORD *)(a1 + 18) = v36;
        v29 = v36;
        *(_WORD *)(a1 + 14) = 0;
        *(_WORD *)(a1 + 12) = v35;
        v32 = (v29 + 7) / 8;
        *(_DWORD *)(a1 + 56) = &v27;
        sub_10006500(a1);
        v12 = v36 + v10;
      }
    }
    v43 = *(_WORD *)(a1 + 38);
    if ( i < a4 && v43 != 0xFFFF )
    {
      *(_WORD *)(a1 + 38) = *(_WORD *)(a1 + 36);
      v50 = v14;
      v51 = v12;
      v41 = v48;
      v42 = a4 - i;
      sub_10007E30(a1, (signed __int16)(a4 - i) + (v12 << 16), (signed __int16)v48 + (v14 << 16));
      *(_WORD *)(a1 + 38) = v43;
    }
    *(_WORD *)(a1 + 4) = v52;
    *(_WORD *)(a1 + 46) = v19 + v12 - v39;
    *(_WORD *)(a1 + 44) = v55;
    result = v19 + i;
  }
  return result;
}

//----- (100079C0) --------------------------------------------------------
bool __cdecl sub_100079C0(_BYTE *a1)
{
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v3 = 0;
  v4 = 0;
  while ( *a1 )
  {
    if ( (signed int)*a1 < 48 || (signed int)*a1 > 57 )
    {
      if ( (signed int)*a1 >= 97 && (signed int)*a1 <= 122 || (signed int)*a1 >= 65 && (signed int)*a1 <= 90 )
        v3 = 1;
    }
    else
    {
      v4 = 1;
    }
    ++a1;
  }
  return v3 && v4;
}

//----- (10007A60) --------------------------------------------------------
bool __cdecl sub_10007A60(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v5; // ST18_4@9
  int v7; // [sp+4h] [bp-1Ch]@7
  bool v8; // [sp+Bh] [bp-15h]@1
  unsigned int v9; // [sp+10h] [bp-10h]@7
  int v10; // [sp+14h] [bp-Ch]@1

  v10 = *(_BYTE *)(*a2)++;
  v8 = v10 == 0;
  if ( byte_1010FA29 && a5 && v10 == 48 )
    v10 = (unsigned __int8)byte_1010FA28;
  if ( !v8 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      v8 = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a1 + 8) + a1;
      v9 = v10 - *(_BYTE *)(v7 + 2);
      if ( v9 >= *(_WORD *)v7 )
        v9 = *(_BYTE *)(v7 + 3);
      v5 = *(_DWORD *)(a1 + 12) + a1 + 4 * v9;
      *a3 = ((*(_BYTE *)(v5 + 2) << 16) | *(_WORD *)v5) + *(_DWORD *)(a1 + 16) + a1;
      *a4 = *(_BYTE *)(v5 + 3);
    }
  }
  return v8;
}
// 1010FA28: using guessed type char byte_1010FA28;
// 1010FA29: using guessed type char byte_1010FA29;

//----- (10007B70) --------------------------------------------------------
int __cdecl sub_10007B70(int a1, _BYTE *a2, int a3)
{
  int v3; // ST00_4@5
  unsigned int v5; // [sp+0h] [bp-20h]@5
  int v6; // [sp+4h] [bp-1Ch]@3
  int v7; // [sp+8h] [bp-18h]@3
  int v8; // [sp+Ch] [bp-14h]@3
  signed int v9; // [sp+10h] [bp-10h]@1
  signed int v10; // [sp+14h] [bp-Ch]@8
  signed int v11; // [sp+18h] [bp-8h]@1
  _BYTE *v12; // [sp+1Ch] [bp-4h]@3

  v11 = (a3 & 0x3FC00000u) >> 22;
  v9 = ((a3 & 0x3F0000u) >> 16) - 1;
  if ( v9 < 0 )
    v9 = *(_WORD *)(a1 + 28);
  v12 = a2;
  v6 = *(_DWORD *)(a1 + 12) + a1;
  v7 = *(_DWORD *)(a1 + 8) + a1;
  v8 = 0;
  while ( *v12 )
  {
    v3 = *v12++;
    v5 = v3 - *(_BYTE *)(v7 + 2);
    if ( v8 > 0 )
      v8 += v9;
    if ( v5 < *(_WORD *)v7 )
      v10 = *(_BYTE *)(v6 + 4 * v5 + 3);
    else
      v10 = *(_BYTE *)(v6 + 4 * *(_BYTE *)(v7 + 3) + 3);
    if ( v11 <= v10 )
      v8 += v10;
    else
      v8 += v11;
  }
  return v8;
}

//----- (10007C60) --------------------------------------------------------
int __cdecl sub_10007C60(int a1)
{
  int result; // eax@6
  __int16 v2; // [sp+0h] [bp-8h]@1
  __int16 v3; // [sp+4h] [bp-4h]@1

  v2 = *(_WORD *)(a1 + 10);
  v3 = *(_WORD *)(a1 + 8);
  if ( *(_WORD *)(a1 + 26) > (signed int)*(_WORD *)(a1 + 10) )
  {
    *(_WORD *)(a1 + 18) -= *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 14) += *(_WORD *)(a1 + 26) - *(_WORD *)(a1 + 10);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > (signed int)*(_WORD *)(a1 + 8) )
  {
    *(_WORD *)(a1 + 16) -= *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 12) += *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 8);
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 24);
  }
  if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) > v2 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v2 < *(_WORD *)(a1 + 18) )
      *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v2;
    if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) > v3 )
    {
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v3 < *(_WORD *)(a1 + 16) )
        *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 28) + *(_WORD *)(a1 + 24) - v3;
      if ( (signed int)*(_WORD *)(a1 + 18) > 0 )
      {
        if ( (signed int)*(_WORD *)(a1 + 16) > 0 )
        {
          *(_BYTE *)a1 = 1;
          result = a1;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10007E30) --------------------------------------------------------
int __cdecl sub_10007E30(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_100686C8 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (10008300) --------------------------------------------------------
int __cdecl sub_10008300(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@1
  int v6; // [sp+0h] [bp-8h]@4
  __int16 v7; // [sp+4h] [bp-4h]@6

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v6 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + a2;
    *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + a3;
    if ( *(_WORD *)(a1 + 6) == 3 || *(_WORD *)(a1 + 6) == 1 )
    {
      v7 = *(_WORD *)(a1 + 4);
      if ( *(_WORD *)(a1 + 6) == 3 )
        *(_WORD *)(a1 + 4) = 2;
      else
        *(_WORD *)(a1 + 4) = 0;
      sub_10007E30(a1, a4 + (*(_WORD *)(a1 + 10) << 16), a5 + (*(_WORD *)(a1 + 8) << 16));
      *(_WORD *)(a1 + 4) = v7;
    }
    result = a1;
    *(_DWORD *)(a1 + 36) = v6;
  }
  return result;
}

//----- (100083F0) --------------------------------------------------------
int __cdecl sub_100083F0(int a1, __int16 a2, __int16 a3, char a4)
{
  int result; // eax@25
  signed int v5; // [sp+4h] [bp-30h]@29
  int v6; // [sp+8h] [bp-2Ch]@44
  int v7; // [sp+8h] [bp-2Ch]@54
  __int16 v8; // [sp+Ch] [bp-28h]@31
  char (__cdecl *v9)(int); // [sp+10h] [bp-24h]@2
  char *(__cdecl *v10)(int); // [sp+14h] [bp-20h]@5
  __int16 v11; // [sp+18h] [bp-1Ch]@31
  signed int v12; // [sp+1Ch] [bp-18h]@31
  __int16 v13; // [sp+20h] [bp-14h]@41
  __int16 v14; // [sp+28h] [bp-Ch]@29
  __int16 v15; // [sp+2Ch] [bp-8h]@29
  __int16 v16; // [sp+30h] [bp-4h]@41

  if ( *(_DWORD *)(a1 + 72) )
    v9 = *(char (__cdecl **)(int))(a1 + 72);
  else
    v9 = sub_100089F0;
  if ( *(_DWORD *)(a1 + 76) )
    v10 = *(char *(__cdecl **)(int))(a1 + 76);
  else
    v10 = sub_10008BC0;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + a2;
  *(_WORD *)(a1 + 12) = *(_WORD *)(a1 + 40) + a3;
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  if ( a4 & 1 )
  {
    if ( (signed int)*(_WORD *)(a1 + 10) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 10) < -8192 )
        *(_WORD *)(a1 + 10) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 10) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 8) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 8) < -8192 )
        *(_WORD *)(a1 + 8) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 8) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 14) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 14) < -8192 )
        *(_WORD *)(a1 + 14) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 14) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 12) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 12) < -8192 )
        *(_WORD *)(a1 + 12) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 12) = 0x1FFF;
    }
  }
  if ( *(_WORD *)(a1 + 10) != *(_WORD *)(a1 + 14) || (result = *(_WORD *)(a1 + 12), *(_WORD *)(a1 + 8) != result) )
  {
    v14 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
    v15 = v14;
    v5 = 1;
    if ( v14 < 0 )
    {
      v5 = -1;
      v15 = -v14;
    }
    v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
    v11 = v8;
    v12 = 1;
    if ( v8 < 0 )
    {
      v12 = -1;
      v11 = -v8;
    }
    if ( v15 )
    {
      if ( v11 )
      {
        v13 = 2 * v15;
        v16 = 2 * v11;
        if ( v15 <= v11 )
        {
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          if ( v13 >= v11 )
            *(_WORD *)(a1 + 16) -= (v12 ^ v5) + 1;
          v7 = v13 - v11 - (v5 < 0);
          *(_WORD *)(a1 + 12) = 0;
          while ( v11 )
          {
            *(_WORD *)(a1 + 12) += v12;
            if ( v7 >= 0 )
            {
              v10(a1);
              *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
              *(_WORD *)(a1 + 12) = 0;
              *(_WORD *)(a1 + 10) += v5;
              v7 -= v16;
            }
            v7 += v13;
            --v11;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 12) += v12;
          v10(a1);
          result = a1;
          *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
        }
        else
        {
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          if ( v16 >= v15 )
            *(_WORD *)(a1 + 18) -= (v12 ^ v5) + 1;
          v6 = v16 - v15 - (v12 < 0);
          *(_WORD *)(a1 + 14) = 0;
          while ( v15 )
          {
            *(_WORD *)(a1 + 14) += v5;
            if ( v6 >= 0 )
            {
              v9(a1);
              *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
              *(_WORD *)(a1 + 14) = 0;
              *(_WORD *)(a1 + 8) += v12;
              v6 -= v13;
            }
            v6 += v16;
            --v15;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 14) += v5;
          v9(a1);
          result = a1;
          *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
        }
      }
      else
      {
        *(_WORD *)(a1 + 16) = 1;
        *(_WORD *)(a1 + 18) = 0;
        *(_WORD *)(a1 + 14) = v14;
        if ( a4 & 2 )
          *(_WORD *)(a1 + 14) += v5;
        result = v9(a1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 18) = 1;
      *(_WORD *)(a1 + 12) = v8;
      if ( a4 & 2 )
        *(_WORD *)(a1 + 12) += v12;
      result = (int)v10(a1);
    }
  }
  else if ( a4 & 2 )
  {
    *(_WORD *)(a1 + 12) = 1;
    result = (int)v10(a1);
  }
  return result;
}

//----- (10008940) --------------------------------------------------------
char __cdecl sub_10008940(int a1)
{
  int v1; // eax@3
  int v3; // [sp+0h] [bp-30h]@3
  __int16 v4; // [sp+4h] [bp-2Ch]@1
  char v5; // [sp+8h] [bp-28h]@6
  int v6; // [sp+14h] [bp-1Ch]@1

  v6 = *(_WORD *)(a1 + 10);
  v4 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
  if ( v4 < 0 )
  {
    v6 = *(_WORD *)(a1 + 14);
    v4 = -v4;
  }
  v1 = (signed __int16)(v4 + 1);
  v6 = v1 + (v6 << 16);
  v3 = *(_WORD *)(a1 + 6);
  if ( v3 == 1 )
  {
    LOBYTE(v1) = sub_10008D10(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  else if ( v3 == 3 )
  {
    LOBYTE(v1) = sub_10009200(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  return v1;
}

//----- (100089F0) --------------------------------------------------------
char __cdecl sub_100089F0(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_10009090(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = sub_100099C0(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_10009090(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_10009090(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_10009200(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_10009630(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (10008B60) --------------------------------------------------------
int __cdecl sub_10008B60(int a1)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  result = a1;
  v2 = *(_WORD *)(a1 + 4);
  if ( *(_WORD *)(a1 + 4) && v2 != 2 )
  {
    if ( v2 == 3 )
      result = sub_10009310(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  else
  {
    result = sub_10009110(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  return result;
}

//----- (10008BC0) --------------------------------------------------------
char *__cdecl sub_10008BC0(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_10009180(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_10009400(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_10009770(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_10009180(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_10009B00(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (10008D10) --------------------------------------------------------
unsigned int __cdecl sub_10008D10(int a1, signed int a2, int a3, int a4)
{
  unsigned int result; // eax@1

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  result = sub_10008DD0(a1, a4);
  if ( *(_DWORD *)a4 )
  {
    *(_DWORD *)(a4 + 32) = (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) >> (*(_BYTE *)(a4 + 12) & 0x1F)) | (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) << (32 - (*(_BYTE *)(a4 + 12) & 0x1F)));
    *(_DWORD *)(a4 + 36) = 1;
    result = sub_10008EF0(a1, a4);
  }
  return result;
}

//----- (10008DD0) --------------------------------------------------------
int __cdecl sub_10008DD0(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (10008EF0) --------------------------------------------------------
unsigned int __cdecl sub_10008EF0(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (10009090) --------------------------------------------------------
int __cdecl sub_10009090(int a1, int a2, int a3)
{
  return sub_10007E30(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (10009110) --------------------------------------------------------
int __cdecl sub_10009110(int a1, int a2, int a3)
{
  return sub_10007E30(
           a1,
           (a2 << 16) + *(_WORD *)(a1 + 34) - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           (a3 << 16) + *(_WORD *)(a1 + 32) - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (10009180) --------------------------------------------------------
int __cdecl sub_10009180(int a1, int a2, int a3)
{
  return sub_10007E30(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (10009200) --------------------------------------------------------
char __cdecl sub_10009200(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_10009310(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_10008DD0(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_100686C8 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_100686C8 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (10009310) --------------------------------------------------------
int __cdecl sub_10009310(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (10009400) --------------------------------------------------------
int __cdecl sub_10009400(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_10009500(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (10009500) --------------------------------------------------------
int __cdecl sub_10009500(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10009630) --------------------------------------------------------
char *__cdecl sub_10009630(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_10008DD0(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_10008EF0(a1, (int)v11);
  }
  return result;
}

//----- (10009770) --------------------------------------------------------
char *__cdecl sub_10009770(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_10009500(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (100099C0) --------------------------------------------------------
int __cdecl sub_100099C0(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10009630(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_10009200(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int)v10 + (v8 >> 8);
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (10009B00) --------------------------------------------------------
int __cdecl sub_10009B00(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10009770(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_10009400(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int)v9 + (v8 >> 8);
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (10009C40) --------------------------------------------------------
char sub_10009C40()
{
  char result; // al@2

  if ( !sub_10020BD0() || (result = *(_BYTE *)(dword_101E741C + 812), (unsigned __int8)result >= 0x66u) && result != -1 )
    result = -1;
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10009C60) --------------------------------------------------------
char __cdecl sub_10009C60(_WORD *a1)
{
  char result; // al@3

  if ( sub_10020BD0() )
  {
    if ( *(_DWORD *)(dword_101E741C + 848) )
    {
      sub_10021020();
      *a1 = (*(_DWORD *)(dword_101E741C + 36) - *(_DWORD *)(dword_101E741C + 848) + 500) / 0x3E8u;
      sub_10021010();
      result = 1;
    }
    else
    {
      *a1 = 0;
      result = 0;
    }
  }
  else
  {
    *a1 = 0;
    result = 0;
  }
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10009CD0) --------------------------------------------------------
char __cdecl sub_10009CD0(float *a1)
{
  char result; // al@1

  result = sub_10020BD0();
  if ( result )
  {
    result = dword_101E741C;
    *a1 = *(float *)(dword_101E741C + 920);
  }
  else
  {
    *a1 = 0.0;
  }
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10009D00) --------------------------------------------------------
char __cdecl sub_10009D00(float *a1, float *a2, _BYTE *a3)
{
  char result; // al@2
  char v4; // bl@3

  if ( sub_10020BD0() )
  {
    sub_10021020();
    *a1 = *(float *)(dword_101E741C + 276);
    *a2 = *(float *)(dword_101E741C + 280);
    *a3 = *(_BYTE *)(dword_101E741C + 274);
    v4 = *(_BYTE *)(dword_101E741C + 272);
    sub_10021010();
    result = v4;
  }
  else
  {
    *a1 = 9.9999996e24;
    *a2 = 9.9999996e24;
    *a3 = 0;
    result = 6;
  }
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10009D80) --------------------------------------------------------
void __cdecl sub_10009D80(int a1, int a2, int a3, float *a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@3
  int v7; // ebx@5
  float *v8; // eax@9
  char v9; // [sp+10h] [bp-8h]@5

  v5 = a1;
  *(float *)&a1 = *(double *)a1;
  *(float *)&a1 = *(float *)&a1 - 6.283185005187988;
  a1 &= 0x7FFFFFFFu;
  if ( *(float *)&a1 < 0.1
    || (*(float *)&a1 = *(double *)(v5 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (v6 = a2,
        *(float *)&a1 = *(double *)a2,
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (*(float *)&a1 = *(double *)(a2 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1) )
  {
    v8 = (float *)a5;
    *a4 = 9.9999996e24;
    *v8 = 9.9999996e24;
  }
  else
  {
    sub_100477B0(v5, (int)&v9);
    v7 = a3;
    if ( (_BYTE)a3 )
      *(float *)&a1 = sub_10005A70(a3);
    else
      sub_1001B240(&v9, &a1);
    sub_1000A360(v5, v6, v7, (int)a4, a5, *(float *)&a1);
  }
}
// 1001B240: using guessed type _DWORD __cdecl sub_1001B240(_DWORD, _DWORD);

//----- (10009EB0) --------------------------------------------------------
int __cdecl sub_10009EB0(int a1, float a2, float a3, int a4, int a5)
{
  float v6; // [sp+1Ch] [bp-Ch]@2
  char v7; // [sp+20h] [bp-8h]@1

  sub_100477B0(a1, (int)&v7);
  if ( (_BYTE)a4 )
    v6 = 0.0;
  else
    sub_1001B240(&v7, &v6);
  return sub_1000A9F0(a1, a2, a3, a4, a5, v6);
}
// 1001B240: using guessed type _DWORD __cdecl sub_1001B240(_DWORD, _DWORD);

//----- (10009F20) --------------------------------------------------------
char sub_10009F20()
{
  char result; // al@2

  if ( sub_10020BD0() )
    result = *(_BYTE *)(dword_101E741C + 14);
  else
    result = 0;
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10009F40) --------------------------------------------------------
void *__cdecl sub_10009F40(void *a1)
{
  return memset(a1, 0, 0x1A6Cu);
}

//----- (10009F60) --------------------------------------------------------
bool __cdecl sub_10009F60(char a1)
{
  bool result; // al@2

  if ( a1 )
    result = 1;
  else
    result = sub_10021010();
  return result;
}

//----- (10009F70) --------------------------------------------------------
bool __cdecl sub_10009F70(char a1)
{
  bool result; // al@2

  if ( a1 )
    result = 1;
  else
    result = sub_10021020();
  return result;
}

//----- (10009F80) --------------------------------------------------------
signed int __cdecl sub_10009F80(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // ecx@1
  signed int result; // eax@3

  v2 = sub_1000A0C0(a1);
  if ( v2 && a2 < *(_BYTE *)(v2 + 4) )
  {
    result = sub_1000A020(*(_BYTE *)(180 * a2 + v2 + 608), 0.0);
  }
  else if ( a2 == 100 )
  {
    result = 16744704;
  }
  else
  {
    result = a2 != 101 ? 16744448 : 16745216;
  }
  return result;
}

//----- (10009FE0) --------------------------------------------------------
signed int __cdecl sub_10009FE0(char a1, unsigned __int8 a2)
{
  signed int v2; // edi@1

  v2 = 16744448;
  if ( sub_10009F70(a1) )
  {
    v2 = sub_10009F80(a1, a2);
    sub_10009F60(a1);
  }
  return v2;
}

//----- (1000A020) --------------------------------------------------------
int __cdecl sub_1000A020(char a1, float a2)
{
  double v2; // st7@1
  int result; // eax@6
  float v4; // [sp+10h] [bp+8h]@4

  v2 = a2;
  if ( (LODWORD(a2) & 0x7F800000) == 2139095040 || v2 > 1851074.0 || v2 < -1851074.0 )
  {
    result = 16744448;
  }
  else
  {
    v4 = v2 * 0.0005399567889980972;
    if ( (unsigned __int8)a1 == 254 )
    {
      if ( sub_100477D0(v4) )
        result = 16744960;
      else
        result = 16744704;
    }
    else if ( (unsigned __int8)a1 == 255 )
    {
      result = 16745216;
    }
    else
    {
      result = ((unsigned __int8)a1 << 16) | (unsigned __int16)sub_100477D0(v4);
    }
  }
  return result;
}

//----- (1000A0C0) --------------------------------------------------------
int __cdecl sub_1000A0C0(unsigned __int8 a1)
{
  int result; // eax@2

  if ( a1 < 1u )
  {
    if ( !sub_10020BD0() || a1 )
      result = 0;
    else
      result = dword_101E7410;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E7410: using guessed type int dword_101E7410;

//----- (1000A0E0) --------------------------------------------------------
char __cdecl sub_1000A0E0(float a1, int a2, int a3)
{
  double v3; // st7@1
  unsigned __int8 v4; // bl@1
  float *v5; // esi@1
  int v6; // ebp@1
  unsigned __int8 v7; // cl@1
  char result; // al@1
  int v9; // edx@5
  int v10; // eax@6
  unsigned int v11; // ecx@6
  double v12; // st6@7
  int v13; // eax@10
  int v14; // edi@10
  double v15; // st6@11
  double v16; // st6@13
  double v17; // st7@16
  double v18; // st6@16
  double v19; // rt1@18
  char v20; // bl@22
  double v21; // st6@25
  float v22; // [sp+10h] [bp+4h]@7
  float v23; // [sp+10h] [bp+4h]@7
  float v24; // [sp+10h] [bp+4h]@7
  float v25; // [sp+10h] [bp+4h]@25
  _BYTE *v26; // [sp+14h] [bp+8h]@1

  v3 = 0.0;
  v4 = LOBYTE(a1);
  v5 = (float *)a2;
  *(float *)a2 = 0.0;
  *(_DWORD *)a3 = 0x7FFFFFFF;
  v6 = dword_101E741C;
  v26 = (_BYTE *)(dword_101E741C + 812);
  v7 = *(_BYTE *)(dword_101E741C + 812);
  result = 0;
  if ( LOBYTE(a1) < v7
    || LOBYTE(a1) >= *(_BYTE *)(dword_101E7410 + 4)
    && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_101E741C + 816) != 3) )
  {
    return result;
  }
  v9 = v7 + 1;
  if ( LOBYTE(a1) - v9 + 1 >= 4 )
  {
    v10 = 180 * v9;
    v11 = (((unsigned int)LOBYTE(a1) - v9 - 3) >> 2) + 1;
    v9 += 4 * v11;
    do
    {
      v12 = *(float *)(v10 + dword_101E7410 + 696);
      v10 += 720;
      --v11;
      v22 = v12 + *v5;
      *v5 = v22;
      v23 = v22 + *(float *)(v10 + dword_101E7410 + 156);
      *v5 = v23;
      v24 = v23 + *(float *)(v10 + dword_101E7410 + 336);
      *v5 = v24;
      *v5 = v24 + *(float *)(v10 + dword_101E7410 + 516);
    }
    while ( v11 );
    v6 = dword_101E741C;
  }
  if ( v9 <= v4 )
  {
    v13 = 180 * v9;
    v14 = v4 - v9 + 1;
    do
    {
      v15 = *(float *)(v13 + dword_101E7410 + 696);
      v13 += 180;
      --v14;
      *v5 = v15 + *v5;
    }
    while ( v14 );
    v6 = dword_101E741C;
  }
  v16 = 9.9999996e24;
  if ( 9.9999996e24 == *(float *)(v6 + 316) || 9.9999996e24 == *(float *)(v6 + 332) )
  {
    v18 = 0.0;
    v17 = 9.9999996e24;
    *v5 = 0.0;
  }
  else
  {
    if ( *(_BYTE *)(180 * *v26 + dword_101E7410 + 671) == 21 )
      goto LABEL_19;
    sub_10021000(*(_DWORD *)(v6 + 296));
    *v5 = 0.0 * *(float *)(dword_101E741C + 332) + *(float *)(dword_101E741C + 316) + *v5;
    v17 = 9.9999996e24;
    v18 = 0.0;
  }
  v19 = v18;
  v16 = v17;
  v3 = v19;
LABEL_19:
  *(_DWORD *)v5 = COERCE_UNSIGNED_INT(*v5) & 0x7FFFFFFF;
  if ( (COERCE_UNSIGNED_INT(*v5) & 0x7F800000) == 2139095040 || v16 < *v5 || v3 > *v5 )
  {
    *v5 = v3;
    v20 = 0;
  }
  else
  {
    v20 = 1;
  }
  if ( *(_BYTE *)(dword_101E741C + 660) )
  {
    v25 = *v5 / *(float *)(dword_101E741C + 688) + 0.5;
    v21 = v25;
    if ( (LODWORD(v25) & 0x7F800000) == 2139095040 || v21 > 2147418112.0 || v21 < v3 )
    {
      *(_DWORD *)a3 = 0x7FFFFFFF;
      result = 0;
    }
    else
    {
      *(_DWORD *)a3 = (signed int)v21;
      result = v20;
    }
  }
  else
  {
    result = v20;
  }
  return result;
}
// 10021000: using guessed type _DWORD __cdecl sub_10021000(_DWORD);
// 101E7410: using guessed type int dword_101E7410;
// 101E741C: using guessed type int dword_101E741C;

//----- (1000A340) --------------------------------------------------------
double __cdecl sub_1000A340(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 >= (double)a1 )
    result = a2;
  return result;
}

//----- (1000A360) --------------------------------------------------------
void __cdecl sub_1000A360(int a1, int a2, int a3, int a4, int a5, float a6)
{
  double v6; // st7@4
  int v7; // [sp+18h] [bp+Ch]@6
  float v8; // [sp+18h] [bp+Ch]@6

  sub_1005C150(a1, a2, (float *)a4, (float *)a5);
  if ( (_BYTE)a3 != 1 && *(float *)a4 > 25.0 )
  {
    if ( (_BYTE)a3 )
      v6 = sub_10005A70(a3);
    else
      v6 = a6;
    *(float *)&v7 = v6;
    v8 = *(float *)a5 - *(float *)&v7;
    *(float *)a5 = v8;
    *(float *)a5 = sub_10047770(v8);
  }
}

//----- (1000A3D0) --------------------------------------------------------
void __usercall sub_1000A3D0(int a1@<ebx>, int a2@<edi>, float a3, float a4)
{
  long double v4; // st7@1
  double v5; // st7@4
  double v6; // ST20_8@7
  double v7; // st7@7
  double v8; // st7@7
  long double v9; // st7@7
  signed int v10; // esi@7
  long double v11; // st7@7
  long double v12; // st7@7
  long double v13; // st7@8
  long double v14; // st4@8
  double v15; // st7@8
  long double v16; // st4@8
  double v17; // st5@10
  float v18; // ST20_4@10
  float v19; // [sp+18h] [bp-78h]@1
  double v20; // [sp+18h] [bp-78h]@7
  double v21; // [sp+20h] [bp-70h]@7
  double v22; // [sp+28h] [bp-68h]@8
  double v23; // [sp+30h] [bp-60h]@7
  double v24; // [sp+38h] [bp-58h]@8
  double v25; // [sp+40h] [bp-50h]@7
  double v26; // [sp+48h] [bp-48h]@7
  double v27; // [sp+50h] [bp-40h]@7
  double v28; // [sp+58h] [bp-38h]@7
  double v29; // [sp+60h] [bp-30h]@7
  double v30; // [sp+68h] [bp-28h]@7
  double v31; // [sp+70h] [bp-20h]@7
  double v32; // [sp+78h] [bp-18h]@8
  double v33; // [sp+80h] [bp-10h]@8
  double v34; // [sp+88h] [bp-8h]@7

  v19 = *(float *)a2;
  v4 = v19;
  if ( (LODWORD(v19) & 0x7F800000) == 2139095040 || v4 > 1.570796251296997 )
  {
    v5 = 1.5707963;
    goto LABEL_6;
  }
  if ( v4 < -1.570796251296997 )
  {
    v5 = -1.5707963;
LABEL_6:
    v19 = v5;
    v4 = v19;
  }
  v6 = sin(v4) * 0.9966471893352525 / cos(v19);
  v27 = sin(a4);
  v7 = cos(a4);
  v23 = v7;
  v8 = sub_100478A0(v6, v7);
  v28 = v8 + v8;
  v25 = 1.0 / sqrt(v6 * v6 + 1.0);
  v26 = v6 * v25;
  v34 = v25 * v27;
  v30 = v34 * v34;
  v31 = 1.0 - v30;
  v9 = sqrt(v31 * 0.006739496742276474 + 1.0);
  v10 = 0;
  v11 = (v9 + 1.0 - 2.0) / (v9 + 1.0);
  v29 = (v11 * 0.375 * v11 - 1.0) * v11;
  v12 = a3 / 0.9966471893352525 / 6378137.0 / ((v11 * v11 * 0.25 + 1.0) / (1.0 - v11));
  v21 = v12;
  v20 = v12;
  do
  {
    v22 = sin(v12);
    v24 = cos(v20);
    v13 = cos(v20 + v28);
    v33 = v13;
    ++v10;
    v32 = v13 * v13 + v13 * v13 - 1.0;
    v14 = v29 * (((v32 * v24 + (v32 + v32 - 1.0) * (v22 * v22 * 4.0 - 3.0) * v13 * v29 / 6.0) * v29 * 0.25 - v13) * v22);
    v15 = v20;
    v20 = v14 + v21;
    v16 = v20 - v15;
    v12 = v20;
  }
  while ( fabs(v16) > 0.00000005 && v10 < 20 );
  *(float *)a1 = sub_100478A0(
                   v22 * v25 * v23 + v24 * v26,
                   sqrt((v24 * v25 * v23 - v22 * v26) * (v24 * v25 * v23 - v22 * v26) + v30) * 0.9966471893352525);
  v17 = v31 * ((4.0 - 3.0 * v31) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
  v18 = sub_100478A0(v22 * v27, v24 * v25 - v22 * v26 * v23)
      - 0.00335281066474748 * ((1.0 - v17) * (((v32 * v24 * v17 + v33) * v22 * v17 + v20) * v34))
      + *(float *)(a2 + 4);
  *(float *)(a1 + 4) = sub_10047770(v18);
}

//----- (1000A6C0) --------------------------------------------------------
void __usercall sub_1000A6C0(int a1@<esi>)
{
  double v1; // st7@1
  float v2; // ST04_4@4
  double v3; // st6@4

  v1 = 1.570796370506287;
  while ( *(float *)a1 > v1 || *(float *)a1 < -1.570796370506287 )
  {
    v2 = *(float *)(a1 + 4) + 3.141592741012573;
    *(float *)(a1 + 4) = sub_10047770(v2);
    v1 = 1.570796370506287;
    v3 = *(float *)a1;
    if ( v3 <= 1.570796370506287 )
      *(float *)a1 = -3.141592741012573 - v3;
    else
      *(float *)a1 = 3.141592741012573 - v3;
  }
}

//----- (1000A730) --------------------------------------------------------
void __cdecl sub_1000A730(int a1, float a2, float a3, int a4)
{
  double v4; // st5@4
  double v5; // st5@8
  double v6; // st6@10
  int v7; // ecx@13
  float v8; // edx@13
  double v9; // st7@14
  float i; // [sp+14h] [bp-24h]@16
  char v11; // [sp+18h] [bp-20h]@16
  float v12; // [sp+1Ch] [bp-1Ch]@16
  float v13; // [sp+20h] [bp-18h]@13
  float v14; // [sp+24h] [bp-14h]@8
  int v15; // [sp+28h] [bp-10h]@16
  float v16; // [sp+2Ch] [bp-Ch]@16
  int v17; // [sp+30h] [bp-8h]@13
  float v18; // [sp+34h] [bp-4h]@13

  if ( fabs(a2) < 0.0000009999999974752427 )
  {
    *(_DWORD *)a4 = *(_DWORD *)a1;
    *(_DWORD *)(a4 + 4) = *(_DWORD *)(a1 + 4);
    return;
  }
  if ( fabs(*(float *)a1 - 1.570796370506287) < 0.0000009999999974752427 )
  {
    v4 = 3.1415925;
LABEL_7:
    a3 = v4;
    goto LABEL_8;
  }
  if ( fabs(*(float *)a1 + 1.570796370506287) < 0.0000009999999974752427 )
  {
    v4 = 0.0;
    goto LABEL_7;
  }
LABEL_8:
  v5 = a3;
  v14 = fabs(a3);
  if ( v14 < 0.000001 || 3.1415926535898 - v5 < 0.0000009999999974752427 )
  {
    v6 = v14;
  }
  else
  {
    v6 = v14;
    if ( v5 + 3.1415926535898 >= 0.0000009999999974752427 )
    {
      sub_1000A3D0(a4, a1, a2, a3);
      return;
    }
  }
  v7 = *(_DWORD *)a1;
  v8 = *(float *)(a1 + 4);
  v14 = a2;
  v17 = v7;
  v13 = a3;
  v18 = v8;
  if ( v6 >= 0.000001 )
    v9 = -1.5707964;
  else
    v9 = 1.5707964;
  *(float *)&v15 = v9;
  v16 = v18;
  sub_1005BD80((int)&v17, (int)&v15, &v12, (float *)&v11, (float *)&v11);
  for ( i = a2 - v12; i > 0.0; i = i - v12 )
  {
    v14 = v13 + 3.141592741012573;
    v13 = sub_10047770(v14);
    v14 = v16 + 3.141592741012573;
    v16 = sub_10047770(v14);
    v14 = i;
    v17 = v15;
    *(float *)&v15 = -*(float *)&v15;
    v18 = v16;
    sub_1005BD80((int)&v17, (int)&v15, &v12, (float *)&v11, (float *)&v11);
  }
  sub_1000A3D0(a4, (int)&v17, v14, v13);
}

//----- (1000A940) --------------------------------------------------------
void __cdecl sub_1000A940(int a1, float a2, float a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  double v6; // st7@1
  double v7; // st7@2
  float v8; // [sp+14h] [bp-8h]@1
  int v9; // [sp+18h] [bp-4h]@1

  v4 = a1;
  v8 = cos(*(float *)a1);
  a2 = a2 / 6378137.0;
  sub_10047800(a3, (int)&v9, (int)&a1);
  v5 = a4;
  v6 = a2;
  *(float *)a4 = *(float *)&a1 * a2 + *(float *)v4;
  LODWORD(a2) = LODWORD(v8) & 0x7FFFFFFF;
  if ( COERCE_FLOAT(LODWORD(v8) & 0x7FFFFFFF) <= 0.000001 )
    v7 = *(float *)(v4 + 4);
  else
    v7 = v6 * *(float *)&v9 / v8 + *(float *)(v4 + 4);
  *(float *)(v5 + 4) = v7;
  *(float *)(v5 + 4) = sub_10047770(*(float *)(v5 + 4));
  sub_1000A6C0(v5);
}

//----- (1000A9F0) --------------------------------------------------------
int __cdecl sub_1000A9F0(int a1, float a2, float a3, int a4, int a5, float a6)
{
  double v6; // st7@3
  char v8; // [sp+Ch] [bp-8h]@1
  int v9; // [sp+24h] [bp+10h]@5
  int v10; // [sp+24h] [bp+10h]@5

  sub_100477B0(a1, (int)&v8);
  if ( (_BYTE)a4 != 1 )
  {
    if ( (_BYTE)a4 )
      v6 = sub_10005A70(a4);
    else
      v6 = a6;
    *(float *)&v9 = v6;
    *(float *)&v10 = *(float *)&v9 + a3;
    a3 = sub_10047770(*(float *)&v10);
  }
  sub_1000A730((int)&v8, a2, a3, (int)&v8);
  return sub_10047820((int)&v8, a5);
}

//----- (1000AA80) --------------------------------------------------------
char __cdecl sub_1000AA80(int a1, float a2, int a3, float a4, char a5, int a6)
{
  char v6; // bl@1
  double v7; // st6@2
  double v8; // st7@3
  float v9; // ST2C_4@7
  float v10; // ST08_4@5
  float v11; // ST24_4@5
  double v12; // st7@5
  float v13; // ST24_4@7
  float v14; // ST24_4@7
  float v16; // ST20_4@9
  float v17; // ST1C_4@9
  double v18; // st5@9
  float v19; // ST1C_4@14
  double v20; // st6@15
  float v21; // ST04_4@22
  float v22; // [sp+4h] [bp-38h]@3
  int v23; // [sp+8h] [bp-34h]@3
  float v24; // [sp+18h] [bp-24h]@5
  float v25; // [sp+18h] [bp-24h]@9
  int v26; // [sp+1Ch] [bp-20h]@5
  float v27; // [sp+1Ch] [bp-20h]@7
  float v28; // [sp+20h] [bp-1Ch]@7
  float v29; // [sp+20h] [bp-1Ch]@9
  float v30; // [sp+2Ch] [bp-10h]@1
  float v31; // [sp+30h] [bp-Ch]@1
  double v32; // [sp+34h] [bp-8h]@7

  v6 = 1;
  sub_10006230((float *)a1, (float *)a3, (int)&v30);
  if ( COERCE_FLOAT(LODWORD(v31) & 0x7FFFFFFF) >= 25.0 )
  {
    v7 = v30;
  }
  else
  {
    v7 = v30;
    if ( COERCE_FLOAT(LODWORD(v30) & 0x7FFFFFFF) < 25.0 )
    {
      v23 = a6;
      v22 = a2;
      v8 = a4;
      goto LABEL_22;
    }
  }
  v24 = v7 * v7 + v31 * v31;
  v10 = v7;
  v11 = a2 - sub_10047910(v10, v31);
  v26 = LODWORD(v11) & 0x7FFFFFFF;
  v12 = COERCE_FLOAT(LODWORD(v11) & 0x7FFFFFFF);
  if ( v12 > 3.141592741012573 )
    *(float *)&v26 = 6.283185482025146 - v12;
  v13 = sqrt(v24);
  v32 = v13 * -2.0;
  v14 = cos(*(float *)&v26);
  v28 = v14 * v32;
  v9 = a4 * a4;
  v27 = v28 * v28 - (v24 - v9) * 4.0;
  if ( v27 < 0.0 )
    return 0;
  v16 = sqrt(v27);
  v17 = -v28;
  v18 = v17;
  v25 = (v16 + v17) * 0.5;
  v29 = (v18 - v16) * 0.5;
  if ( a5 )
  {
    v8 = v25;
    if ( COERCE_FLOAT(LODWORD(v29) & 0x7FFFFFFF) < (double)COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) )
      v8 = v29;
  }
  else if ( v29 >= 0.0 || v25 >= 0.0 )
  {
    v20 = v25;
    if ( v29 < 0.0 || v20 >= 0.0 && v20 <= v29 )
      v8 = v25;
    else
      v8 = v29;
  }
  else
  {
    v6 = 0;
    v19 = sub_1000A340(v25, v29);
    v8 = v19;
  }
  v23 = a6;
  v22 = a2;
LABEL_22:
  v21 = v8;
  sub_1000A940(a1, v21, v22, v23);
  return v6;
}

//----- (1000ACE0) --------------------------------------------------------
char __cdecl sub_1000ACE0(int a1, float a2, int a3, float a4, int a5)
{
  char v5; // bl@1
  float v7; // [sp+18h] [bp-2Ch]@2
  int v8; // [sp+1Ch] [bp-28h]@1
  int v9; // [sp+24h] [bp-20h]@1
  int v10; // [sp+2Ch] [bp-18h]@1
  char v11; // [sp+34h] [bp-10h]@2
  char v12; // [sp+3Ch] [bp-8h]@2

  sub_100477B0(a1, (int)&v10);
  sub_100477B0(a3, (int)&v8);
  v5 = sub_1000AA80((int)&v8, a4, (int)&v10, a2, 0, (int)&v9);
  if ( v5 )
  {
    sub_1005C230((int)&v8, COERCE_FLOAT(&v9), &v7, (int)&v12, (float *)&v11);
    sub_1000A730((int)&v8, v7, a4, (int)&v9);
    sub_10047820((int)&v9, a5);
  }
  return v5;
}

//----- (1000AD90) --------------------------------------------------------
int __cdecl sub_1000AD90(int a1)
{
  int result; // eax@1
  __int16 v2; // cx@1

  result = a1;
  v2 = *(_WORD *)a1;
  *(float *)(a1 + 4) = 9.9999996e24;
  *(float *)(a1 + 8) = 6.283185;
  *(_WORD *)a1 = v2 & 0xF806 | 6;
  *(float *)(a1 + 12) = 4.5698152;
  *(_BYTE *)(a1 + 40) = 0;
  *(float *)(a1 + 16) = 9.9999996e24;
  *(float *)(a1 + 20) = 9.9999996e24;
  *(float *)(a1 + 24) = 6.283185;
  *(float *)(a1 + 28) = 6.283185;
  *(float *)(a1 + 32) = 6.283185;
  *(float *)(a1 + 36) = 6.283185;
  *(float *)(a1 + 48) = 0.0;
  *(float *)(a1 + 44) = 0.0;
  return result;
}

//----- (1000AF90) --------------------------------------------------------
char __cdecl sub_1000AF90(void *a1)
{
  void *v1; // ebx@3
  char *v2; // ebp@3
  char *v3; // edi@4
  bool v4; // zf@4
  int v5; // eax@5
  signed int v6; // edx@5
  char *v7; // edi@6
  char result; // al@2
  char *v9; // [sp+4h] [bp+4h]@3

  if ( sub_10020BD0() )
  {
    sub_10021020();
    memcpy_0(a1, dword_101E7418, 0x32ECu);
    result = sub_10021010();
  }
  else
  {
    v1 = a1;
    *((float *)a1 + 2) = 6.283185;
    *((float *)a1 + 1822) = 0.0;
    *((float *)a1 + 1823) = 0.0;
    *((_DWORD *)a1 + 1821) = 16744448;
    *((_DWORD *)a1 + 1827) = 16744448;
    *((float *)a1 + 1824) = 6.283185;
    *((_DWORD *)a1 + 1828) = 16744448;
    *((float *)a1 + 1825) = 6.283185;
    *((float *)a1 + 1829) = 9.9999996e24;
    *((float *)a1 + 1830) = 9.9999996e24;
    *(_BYTE *)a1 = -1;
    *((_BYTE *)a1 + 1) = 0;
    *((_WORD *)a1 + 3) = -1;
    *((_BYTE *)a1 + 2) = -1;
    *((_BYTE *)a1 + 5) = 0;
    *((_BYTE *)a1 + 3) = 0;
    *((_BYTE *)a1 + 4) = 16;
    *((_BYTE *)a1 + 7280) = 0;
    *((_BYTE *)a1 + 7304) = -1;
    *((_BYTE *)a1 + 7305) = 0;
    *((_BYTE *)a1 + 7306) = 0;
    sub_1000AD90((int)a1 + 232);
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    *((_DWORD *)a1 + 5) = 0;
    *((_DWORD *)a1 + 6) = 0;
    *((_DWORD *)a1 + 7) = 0;
    *((_DWORD *)a1 + 8) = 0;
    *((_DWORD *)a1 + 9) = 0;
    *((_DWORD *)a1 + 10) = 0;
    memset((char *)a1 + 44, 0, 0x44u);
    memset((char *)a1 + 112, 0, 0x78u);
    memset((char *)a1 + 7048, 0, 0xE8u);
    v2 = (char *)a1 + 7480;
    v9 = (char *)2;
    do
    {
      memset(v2 - 108, 0, 0xB4u);
      *((float *)v2 - 3) = 0.0;
      *(v2 - 45) = 23;
      *(_DWORD *)v2 = 0x3FFFF;
      *((float *)v2 - 6) = 9.9999996e24;
      *(v2 - 46) = 1;
      *(v2 - 49) = 1;
      *((float *)v2 + 1) = 6.283185;
      *(v2 - 52) = 0;
      *((float *)v2 + 2) = 6.283185;
      *(v2 - 44) = 0;
      *((float *)v2 + 3) = 6.283185;
      *(v2 - 38) = 0;
      *((float *)v2 + 4) = 6.283185;
      v3 = v2 - 104;
      v2 += 180;
      v4 = v9-- == (char *)1;
      qmemcpy(v3, (char *)v1 + 232, 0x34u);
    }
    while ( !v4 );
    v5 = (int)v1 + 7732;
    v6 = 102;
    do
    {
      v7 = (char *)v5;
      v5 += 52;
      --v6;
      qmemcpy(v7, (char *)v1 + 232, 0x34u);
    }
    while ( v6 );
    memset((char *)v1 + 7324, 0, 0x30u);
    result = (unsigned int)sub_10009F40((char *)v1 + 284);
  }
  return result;
}

//----- (1000AFE0) --------------------------------------------------------
int __cdecl sub_1000AFE0(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // esi@1

  v2 = ((a2 & 0x3F) - 46) << 6;
  v3 = *(int *)((char *)&dword_10069328 + v2);
  if ( a2 & 0x40 )
    ++v3;
  return v3 * *((_BYTE *)&unk_101E37E0 + 20 * ((a1 >> 10) & 0xF) + 17)
       + *(int *)((char *)&dword_10069320 + v2) * *((_BYTE *)&unk_101E37E0 + 20 * ((a1 >> 10) & 0xF) + 15)
       + *(_WORD *)(*((_DWORD *)&unk_101E37E0 + 5 * ((a1 >> 10) & 0xF) + 1) + 28)
       * (*(int *)((char *)&dword_10069320 + v2) + v3 - 1);
}
// 10069320: using guessed type int dword_10069320;
// 10069328: using guessed type int dword_10069328;

//----- (1000B040) --------------------------------------------------------
char __cdecl sub_1000B040(signed __int16 *a1, _BYTE *a2)
{
  void *v2; // ecx@0
  signed __int16 v3; // ax@1
  void *v4; // ecx@1
  signed __int16 v5; // dx@7

  LOBYTE(v3) = sub_1001D460(v2);
  if ( (_BYTE)v3 )
  {
    if ( sub_1001D430(v4) )
    {
      *a2 = 35;
      v3 = *a1;
      if ( *a1 < 0x7FFF )
      {
        if ( v3 / 12 & 1 )
          *a2 = 36;
        v3 = *a1 / 12;
        v5 = *a1 % 12;
        *a1 = v5;
        if ( !v5 )
          *a1 = 12;
      }
    }
    else
    {
      LOBYTE(v3) = (_BYTE)a2;
      *a2 = 37;
    }
  }
  else
  {
    *a2 = 38;
  }
  return v3;
}

//----- (1000B0B0) --------------------------------------------------------
__int16 __usercall sub_1000B0B0@<ax>(int a1@<eax>, int a2@<esi>, unsigned int a3)
{
  unsigned int v3; // edx@1
  unsigned int v4; // ecx@1
  unsigned int v5; // ecx@1
  __int16 result; // ax@1

  v3 = a3 % (3600 * (word_10069324[32 * ((*(_BYTE *)(a1 + 8) & 0x3F) - 46)] + 1));
  v4 = v3;
  v3 /= 0xE10u;
  *(_WORD *)a2 = v3;
  v5 = -3600 * (unsigned __int16)v3 + v4;
  *(_BYTE *)(a2 + 2) = v5 / 0x3C;
  result = 60 * (char)(v5 / 0x3C);
  *(_BYTE *)(a2 + 3) = v5 % 0x3C;
  return result;
}
// 10069324: using guessed type __int16 word_10069324[];

//----- (1000B110) --------------------------------------------------------
char *__usercall sub_1000B110@<eax>(int a1@<ebx>, int a2@<edi>, int a3, int a4)
{
  int v4; // esi@1
  void *v5; // ecx@1
  __int16 v6; // ax@2
  char v8; // [sp+4h] [bp-4h]@1
  char v9; // [sp+6h] [bp-2h]@1

  strncpy(&v8, (const char *)(a2 + *(_DWORD *)(a1 + 56) + 69), 2u);
  v9 = 0;
  v4 = a4 + (unsigned __int8)j__atol(&v8);
  if ( sub_1001D430(v5) != 1
    || (v6 = *(_WORD *)(a3 + 8) & 0x3F, v6 == 49)
    || v6 == 48
    || v6 == 47
    || v6 == 50
    || v6 == 51
    || v6 == 46 )
  {
    if ( v4 <= 23 )
    {
      if ( v4 < 0 )
        v4 = 23;
    }
    else
    {
      v4 = 0;
    }
  }
  else if ( v4 <= 12 )
  {
    if ( v4 <= 0 )
      v4 = 12;
  }
  else
  {
    v4 = 1;
  }
  sprintf(&v8, "%02u", v4);
  return strncpy((char *)(a2 + *(_DWORD *)(a1 + 56) + 69), &v8, 2u);
}

//----- (1000B1D0) --------------------------------------------------------
int __usercall sub_1000B1D0@<eax>(unsigned int a1@<eax>, char a2@<cl>)
{
  char v2; // bl@1
  int v3; // ebp@1
  __int16 v4; // bx@1
  int v5; // edi@1
  signed int v6; // esi@6
  char *v7; // eax@7
  int v8; // eax@7

  v2 = a2;
  v3 = *((_DWORD *)sub_10015340(a1) + 1);
  v4 = v2 & 0x3F;
  v5 = 0;
  if ( v4 == 52 || v4 == 53 || v4 == 54 || v4 == 55 || v4 == 56 )
  {
    v6 = 0;
    do
    {
      v7 = sub_10021070(byte_100695B0[v6]);
      v8 = sub_10007120(v3, v7, 0);
      if ( v5 <= v8 )
        v5 = v8;
      ++v6;
    }
    while ( v6 < 4 );
  }
  return v5;
}

//----- (1000B240) --------------------------------------------------------
char __usercall sub_1000B240@<al>(int *a1@<ebx>, int a2@<edi>, _DWORD *a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char v5; // cl@1

  v3 = ((*(_BYTE *)(a2 + 8) & 0x3F) - 46) << 6;
  v4 = *(int *)((char *)&dword_10069328 + v3) + *(int *)((char *)&dword_10069320 + v3);
  *a1 = v4;
  v5 = *(_BYTE *)(a2 + 8) & 0x3F;
  if ( v5 == 52 || (*(_BYTE *)(a2 + 8) & 0x3F) == 54 )
  {
    LOBYTE(v4) = sub_1001D430((void *)v5);
    if ( (_BYTE)v4 == 1 )
      ++*a1;
  }
  if ( byte_1006932D[v3] && *(_BYTE *)(a2 + 8) & 0x40 )
  {
    *a3 = 1;
    ++*a1;
  }
  else
  {
    *a3 = 0;
  }
  return v4;
}
// 10069320: using guessed type int dword_10069320;
// 10069328: using guessed type int dword_10069328;

//----- (1000B2B0) --------------------------------------------------------
char __usercall sub_1000B2B0@<al>(signed int *a1@<ecx>, int a2@<ebx>, int a3, int a4)
{
  int v4; // ebp@1
  signed int v5; // eax@1
  int v6; // edi@3
  void *v7; // ecx@5
  __int16 v8; // ax@6
  signed __int16 v9; // ax@8
  __int16 v10; // cx@16
  __int16 v11; // ax@17
  __int16 v12; // cx@22
  __int16 v13; // ax@26
  int v14; // eax@31
  char result; // al@32
  signed int v16; // [sp+Ch] [bp-8h]@1
  signed int v17; // [sp+10h] [bp-4h]@3

  v4 = a3;
  v5 = 0;
  v16 = 0;
  if ( a1 )
  {
    v5 = *a1;
    v16 = *a1;
  }
  v17 = 1;
  v6 = (*(_BYTE *)(a3 + 8) & 0x3F) - 46;
  if ( v5 < 0 )
  {
    v5 = -v5;
    v16 = v5;
    v17 = -1;
  }
  sub_1000B0B0(a3, (int)&a3, v5);
  if ( sub_1001D430(v7) != 1 || (v8 = *(_WORD *)(v4 + 8) & 0x3F, v8 != 52) && v8 != 54 )
  {
    v9 = a3;
  }
  else
  {
    v9 = a3;
    if ( (_WORD)a3 == 12 )
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -107;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
    else if ( (signed __int16)a3 <= 12 )
    {
      if ( !(_WORD)a3 )
        v9 = 12;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -108;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 90) = -107;
      v9 -= 12;
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 91) = 0;
    }
  }
  v10 = *(_WORD *)(v4 + 8);
  if ( v10 & 0x40 )
  {
    sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), &a03d02u[64 * v6], v17 * v9, BYTE2(a3), BYTE3(a3));
    v11 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( (v11 == 46 || v11 == 47) && !v16 || v17 < 0 )
      *(_BYTE *)(*(_DWORD *)(a2 + 56) + 69) = 45;
  }
  else
  {
    v12 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v12 != 50 && v12 != 51 )
      sprintf((char *)(*(_DWORD *)(a2 + 56) + 69), off_100692F0[16 * v6], v17 * v9, BYTE2(a3), BYTE3(a3));
    else
      sprintf(
        (char *)(*(_DWORD *)(a2 + 56) + 69),
        off_100692F0[16 * v6],
        BYTE2(a3),
        (unsigned __int8)(BYTE3(a3) / 10 + 48),
        (unsigned __int8)((unsigned __int16)(BYTE3(a3) % 10) + 48));
  }
  *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) = 0;
  v13 = *(_WORD *)(v4 + 8) & 0x3F;
  if ( v13 != 46 && v13 != 47 && v13 != 52 && v13 != 48 && v13 != 54
    || (v14 = *(_DWORD *)(a2 + 56), *(_WORD *)(v14 + 240) != a4) )
  {
    *(_BYTE *)(*(_DWORD *)(a2 + 56) + 242) = 1;
    result = 4;
  }
  else
  {
    *(_BYTE *)(v14 + 242) = 2;
    result = 4;
  }
  return result;
}
// 100692F0: using guessed type char *off_100692F0[2];

//----- (1000B4A0) --------------------------------------------------------
char __cdecl sub_1000B4A0(signed __int16 *a1, _BYTE *a2)
{
  void *v2; // ecx@1
  char v3; // bl@1
  char result; // al@4
  char v5[4]; // [sp+8h] [bp-4h]@1

  v3 = sub_10020EC0(v5);
  if ( v3 == 1 )
  {
    if ( sub_1001D460(v2) == 1 )
      sub_100212A0((int *)v5, *(int *)v5);
    sub_100211A0((int)a1, *(unsigned int *)v5);
    sub_1000B040(a1, a2);
    result = 1;
  }
  else
  {
    *a1 = 0x7FFF;
    sub_1000B040(a1, a2);
    result = v3;
  }
  return result;
}

//----- (1000B520) --------------------------------------------------------
char __usercall sub_1000B520@<al>(int a1@<eax>, int a2@<ecx>, signed int *a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  void *v6; // ecx@1
  int v7; // eax@1
  char v8; // bl@1
  unsigned __int16 v9; // ax@4
  __int16 v10; // ax@7
  __int16 v11; // ax@10
  char result; // al@12
  unsigned __int16 v13; // ax@15
  int v14; // ebp@17
  int v15; // eax@18
  __int16 v16; // ax@19
  int v17; // eax@26
  char *v18; // eax@27
  int v19; // ebx@27
  char v20; // dl@28
  char v21; // bl@29
  char *v22; // eax@29
  char v23; // dl@29
  char v24; // cl@30
  __int16 v25; // bp@33
  void *v26; // ecx@34
  __int16 v27; // di@35
  char *v28; // eax@42
  int v29; // edi@42
  char v30; // dl@43
  char v31; // bl@44
  char *v32; // eax@44
  char v33; // dl@44
  char v34; // cl@45
  int v35; // ecx@46
  unsigned int v36; // kr00_4@48
  __int32 v37; // eax@48
  int v38; // ebx@49
  char *v39; // eax@53
  char v40; // dl@54
  char v41; // bl@55
  char *v42; // eax@55
  char v43; // dl@55
  char v44; // cl@56
  int v45; // ecx@57
  __int16 v46; // ax@57
  const char *v47; // ecx@58
  char v48; // kr08_1@58
  char *v49; // eax@58
  char v50; // dl@58
  char v51; // cl@59
  int v52; // ecx@60
  char v53; // cl@62
  int v54; // edx@65
  __int16 v55; // di@75
  bool v56; // zf@79
  unsigned __int16 v57; // ax@82
  __int16 v58; // ax@85
  __int16 v59; // bp@88
  unsigned __int16 v60; // ax@89
  int v61; // ebp@91
  void *v62; // ecx@91
  __int16 v63; // ax@92
  char *v64; // eax@99
  int v65; // edx@99
  char v66; // cl@100
  char v67; // bl@101
  char *v68; // eax@101
  char v69; // bp@101
  char v70; // cl@102
  int v71; // eax@103
  _BYTE *v72; // ecx@103
  __int16 v73; // ax@103
  __int16 v74; // di@109
  signed __int16 v75; // di@114
  const char *v76; // ecx@117
  char *v77; // eax@117
  int v78; // edi@117
  char v79; // dl@118
  __int16 v80; // bp@123
  __int16 v81; // ax@123
  char v82[2]; // [sp+10h] [bp-10h]@33
  char v83; // [sp+12h] [bp-Eh]@34
  char v84; // [sp+13h] [bp-Dh]@33
  int v85; // [sp+14h] [bp-Ch]@1
  int v86; // [sp+18h] [bp-8h]@1
  int v87; // [sp+1Ch] [bp-4h]@1

  v4 = a1;
  v5 = a2;
  v86 = (*(_BYTE *)(a1 + 8) & 0x3F) - 46;
  sub_1000B240(&v87, a1, &v85);
  v7 = *(_DWORD *)(v5 + 56);
  v8 = 1;
  if ( *(_WORD *)(v7 + 240) != -128 )
  {
    if ( *(_WORD *)(a4 + 10) == 84 )
      *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v7 + 69) != 45) + 43;
    v9 = *(_WORD *)(a4 + 14);
    if ( v9 >= 0x41u && v9 <= 0x5Au || v9 == 32 )
    {
      v10 = *(_WORD *)(v4 + 8) & 0x3F;
      if ( (v10 == 52 || v10 == 54) && sub_1001D430(v6) == 1 )
      {
        v11 = *(_WORD *)(a4 + 14);
        goto LABEL_11;
      }
    }
    v13 = *(_WORD *)(a4 + 14);
    if ( v13 >= 0x30u && v13 <= 0x39u )
    {
      v14 = v85;
      if ( *(_BYTE *)(v4 + 8) & 0x40 )
      {
        v15 = *(_DWORD *)(v5 + 56);
        if ( *(_WORD *)(v15 + 240) == v85 - 1 )
        {
          *(_WORD *)(v15 + 240) = v85;
          v16 = *(_WORD *)(v4 + 8) & 0x3F;
          if ( v16 != 46 && v16 != 47 && v16 != 52 && v16 != 48 && v16 != 54 )
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
          else
            *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 2;
        }
      }
      v17 = *(_DWORD *)(v5 + 56);
      if ( *(_BYTE *)(v17 + 242) == 2 )
      {
        *(_WORD *)(v17 + v14 + 69) = 12336;
        v18 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        v19 = *(_DWORD *)(v5 + 56) + 70;
        do
          v20 = *v18++;
        while ( v20 );
        v21 = (_BYTE)v18 - v19;
        v22 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
        v23 = (_BYTE)v22 + 1;
        do
          v24 = *v22++;
        while ( v24 );
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)(v21 - ((_BYTE)v22 - v23)) - 1;
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
      }
      if ( (*(_BYTE *)(v4 + 8) & 0x3F) == 49 )
      {
        strncpy(v82, (const char *)(*(_DWORD *)(v5 + 56) + v85 + 69), 3u);
        v25 = word_10069324[32 * v86];
        v84 = 0;
      }
      else
      {
        strncpy(v82, (const char *)(*(_DWORD *)(v5 + 56) + v14 + 69), 2u);
        v83 = 0;
        if ( sub_1001D430(v26) != 1
          || (v27 = *(_WORD *)(v4 + 8) & 0x3F, v27 == 49)
          || v27 == 48
          || v27 == 47
          || v27 == 50
          || v27 == 51
          || (v25 = 12, v27 == 46) )
        {
          v25 = 23;
        }
      }
      v28 = (char *)(*(_DWORD *)(v5 + 56) + 69);
      v29 = *(_DWORD *)(v5 + 56) + 70;
      do
        v30 = *v28++;
      while ( v30 );
      v31 = (_BYTE)v28 - v29;
      v32 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
      v33 = (_BYTE)v32 + 1;
      do
        v34 = *v32++;
      while ( v34 );
      v35 = *(_DWORD *)(v5 + 56);
      if ( *(_WORD *)(v35 + 240) == (char)(v31 - ((_BYTE)v32 - v33)) - 1 )
      {
        if ( v82[0] == 48 )
        {
          v36 = strlen(v82);
          v37 = j__atol(v82);
          sprintf(v82, "%0*i", v36, 10 * v37);
        }
        v38 = v85;
        v82[*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) - v85] = *(_BYTE *)(a4 + 14);
        if ( j__atol(v82) > v25 )
          *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
        else
          memcpy_0((void *)(*(_DWORD *)(v5 + 56) + v38 + 69), v82, strlen(v82));
        if ( 10 * j__atol((const char *)(*(_DWORD *)(v5 + 56) + v38 + 69)) <= v25 )
        {
LABEL_69:
          if ( *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v5 + 56) + 240) + *(_DWORD *)(v5 + 56) + 69) == 58 )
          {
            ++*(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
            return 2;
          }
          return 2;
        }
        v39 = (char *)(*(_DWORD *)(v5 + 56) + 69);
        do
          v40 = *v39++;
        while ( v40 );
        v41 = (_BYTE)v39 - (*(_BYTE *)(v5 + 56) + 70);
        v42 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
        v43 = (_BYTE)v42 + 1;
        do
          v44 = *v42++;
        while ( v44 );
        v45 = *(_DWORD *)(v5 + 56);
        v46 = (char)(v41 - ((_BYTE)v42 - v43)) + 1;
      }
      else
      {
        v47 = (const char *)(v35 + 69);
        v48 = strlen(v47);
        v49 = strchr(v47, 58);
        v50 = (_BYTE)v49 + 1;
        do
          v51 = *v49++;
        while ( v51 );
        v52 = *(_WORD *)(*(_DWORD *)(v5 + 56) + 240);
        if ( v52 >= (char)(v48 - ((_BYTE)v49 - v50)) - 1 )
        {
          if ( *(_WORD *)(a4 + 14) > (unsigned __int16)(unsigned __int8)*(&byte_100692F8[(v86 << 6) - v85] + v52) )
            goto LABEL_69;
          v53 = *(_BYTE *)(a4 + 14);
        }
        else
        {
          v82[v52 - v85] = *(_BYTE *)(a4 + 14);
          if ( j__atol(v82) > v25 )
            goto LABEL_69;
          v53 = *(_BYTE *)(a4 + 14);
        }
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v5 + 56) + 240))++ + *(_DWORD *)(v5 + 56) + 69) = v53;
        v54 = *(_DWORD *)(v5 + 56);
        LOBYTE(v46) = v87 - 1;
        if ( *(_WORD *)(v54 + 240) < v87 - 1 )
          v46 = *(_WORD *)(v54 + 240);
        v45 = *(_DWORD *)(v5 + 56);
        v46 = (char)v46;
      }
      *(_WORD *)(v45 + 240) = v46;
      goto LABEL_69;
    }
    if ( v13 != 43 && v13 != 45 || !(*(_BYTE *)(v4 + 8) & 0x40) )
      return v8;
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) != v85 - 1 )
      return 2;
    *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v85;
    v55 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v55 == 46 || v55 == 47 || v55 == 52 || v55 == 48 )
      goto LABEL_129;
    v56 = v55 == 54;
LABEL_128:
    if ( v56 )
      goto LABEL_129;
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
    return 2;
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
    *(_WORD *)(a4 + 14) = 45;
  v57 = *(_WORD *)(a4 + 14);
  if ( v57 >= 0x41u && v57 <= 0x5Au || v57 == 32 )
  {
    v58 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( (v58 == 52 || v58 == 54) && sub_1001D430(v6) == 1 )
    {
      v59 = v85;
      sub_1000B2B0(a3, v5, v4, v85);
      *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v59;
      v11 = *(_WORD *)(a4 + 14);
LABEL_11:
      if ( v11 == 80 )
      {
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 90) = -107;
        return 2;
      }
      if ( v11 == 65 )
      {
        result = 2;
        *(_BYTE *)(*(_DWORD *)(v5 + 56) + 90) = -108;
        return result;
      }
      return 2;
    }
  }
  v60 = *(_WORD *)(a4 + 14);
  if ( v60 < 0x30u || v60 > 0x39u )
  {
    if ( v60 != 43 && v60 != 45 || !(*(_BYTE *)(v4 + 8) & 0x40) )
      return v8;
    v80 = v85;
    v86 = 0;
    sub_1000B2B0(&v86, v5, v4, v85);
    *(_BYTE *)(*(_DWORD *)(v5 + 56) + 69) = *(_BYTE *)(a4 + 14);
    *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = v80;
    v81 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v81 == 46 || v81 == 47 || v81 == 52 || v81 == 48 )
    {
LABEL_129:
      result = 2;
      *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 2;
      return result;
    }
    v56 = v81 == 54;
    goto LABEL_128;
  }
  v61 = v85;
  v86 = 0;
  sub_1000B2B0(&v86, v5, v4, v85);
  if ( sub_1001D430(v62) == 1 )
  {
    v63 = *(_WORD *)(v4 + 8) & 0x3F;
    if ( v63 != 49 && v63 != 48 && v63 != 47 && v63 != 50 && v63 != 51 && v63 != 46 )
      *(_WORD *)(*(_DWORD *)(v5 + 56) + v61 + 69) = 12336;
  }
  *(_BYTE *)(*(_DWORD *)(v5 + 56) + 242) = 1;
  v64 = (char *)(*(_DWORD *)(v5 + 56) + 69);
  v65 = *(_DWORD *)(v5 + 56) + 70;
  do
    v66 = *v64++;
  while ( v66 );
  v67 = (_BYTE)v64 - v65;
  v68 = strchr((const char *)(*(_DWORD *)(v5 + 56) + 69), 58);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) - 1;
  v71 = *(_DWORD *)(v5 + 56);
  v72 = (_BYTE *)*(_WORD *)(v71 + 240);
  v72[v71 + 69] = *(_BYTE *)(a4 + 14);
  v73 = *(_WORD *)(v4 + 8) & 0x3F;
  if ( v73 != 46 && v73 != 47 && v73 != 52 && v73 != 48 && v73 != 54 )
    return 2;
  if ( sub_1001D430(v72) != 1
    || (v74 = *(_WORD *)(v4 + 8) & 0x3F, v74 == 49)
    || v74 == 48
    || v74 == 47
    || v74 == 50
    || v74 == 51
    || (v56 = v74 == 46, v75 = 12, v56) )
  {
    v75 = 23;
  }
  if ( 10 * j__atol((const char *)(*(_DWORD *)(v5 + 56) + v85 + 69)) <= v75 )
    return 2;
  v76 = (const char *)(*(_DWORD *)(v5 + 56) + 69);
  v77 = (char *)(*(_DWORD *)(v5 + 56) + 69);
  v78 = *(_DWORD *)(v5 + 56) + 70;
  do
    v79 = *v77++;
  while ( v79 );
  *(_WORD *)(*(_DWORD *)(v5 + 56) + 240) = (char)((_BYTE)v77 - v78 - strlen(strchr(v76, 58))) + 1;
  return 2;
}
// 10069324: using guessed type __int16 word_10069324[];
// 1000B520: using guessed type char var_10[2];

//----- (1000BD10) --------------------------------------------------------
char __usercall sub_1000BD10@<al>(char *a1@<eax>, signed int *a2@<edx>, int a3, _BYTE *a4)
{
  char *v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@1
  signed int v7; // ebp@2
  int v8; // ecx@8
  signed int v9; // esi@8
  int v10; // ebx@10
  _BYTE *v11; // edx@11
  __int16 v12; // dx@12
  int v13; // esi@29
  int v14; // esi@33
  char *v15; // ebx@38
  void *v16; // ecx@41
  const char *v17; // ST18_4@49
  char *v18; // ebx@57
  void *v19; // ecx@60
  char *v20; // ebx@68
  _BYTE *v21; // edx@71
  char v22; // cl@72
  int v24; // [sp-8h] [bp-30h]@21
  signed int v25; // [sp-8h] [bp-30h]@28
  int v26; // [sp-4h] [bp-2Ch]@21
  signed int v27; // [sp-4h] [bp-2Ch]@32
  __int16 v28; // [sp+10h] [bp-18h]@8
  unsigned __int8 v29; // [sp+12h] [bp-16h]@8
  unsigned __int8 v30; // [sp+13h] [bp-15h]@8
  int v31; // [sp+14h] [bp-14h]@1
  int v32; // [sp+18h] [bp-10h]@1
  char *v33; // [sp+1Ch] [bp-Ch]@10
  char v34[4]; // [sp+20h] [bp-8h]@10
  int v35; // [sp+24h] [bp-4h]@1

  v4 = a1;
  v5 = *(_BYTE *)(a3 + 8) & 0x3F;
  LOBYTE(a1) = 0;
  *(_DWORD *)v4 = 0;
  *((_DWORD *)v4 + 1) = 0;
  *((_DWORD *)v4 + 2) = 0;
  *((_DWORD *)v4 + 3) = 0;
  *((_DWORD *)v4 + 4) = 0;
  v35 = v5;
  v6 = v5 - 46;
  v32 = 1;
  LOBYTE(v31) = 31;
  v4[20] = 0;
  if ( v5 == 54 )
    v7 = 0;
  else
    v7 = *a2;
  switch ( v5 )
  {
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
      if ( v7 >= 0x7FFFFFFF )
        goto LABEL_78;
      if ( v7 < 0 )
      {
        v7 = -v7;
        v32 = -1;
      }
      sub_1000B0B0(a3, (int)&v28, v7);
      v8 = v28;
      v9 = v29;
      if ( v30 + 60 * (v29 + 60 * v28) != v7 || v7 >= 0x7FFFFFFF )
      {
LABEL_78:
        v15 = (&off_100692F4)[64 * v6];
        do
        {
          LOBYTE(a1) = *v15;
          *v4++ = *v15++;
        }
        while ( (_BYTE)a1 );
      }
      else
      {
        v10 = v6 << 6;
        v33 = (&off_100692F4)[v10];
        *(_DWORD *)v34 = v4;
        do
        {
          LOBYTE(a1) = *v33;
          v11 = *(_BYTE **)v34;
          ++v33;
          ++*(_DWORD *)v34;
          *v11 = (_BYTE)a1;
        }
        while ( (_BYTE)a1 );
        v12 = *(__int16 *)((char *)word_10069324 + v10);
        if ( v28 <= v12 )
        {
          if ( (a1 = (char *)*(_WORD *)(a3 + 8),
                *(_DWORD *)v34 = a1,
                LOWORD(a1) = (unsigned __int8)a1 & 0x3F,
                (_WORD)a1 != 50)
            && (_WORD)a1 != 51
            || v9 <= v12 )
          {
            if ( v28 || v35 != 47 )
            {
              if ( (_WORD)a1 != 50 && (_WORD)a1 != 51 )
              {
                if ( v35 == 46 || v35 == 47 )
                {
                  v27 = v9;
                  if ( v34[0] & 0x40 )
                  {
                    v14 = v32;
                    LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v32 * v8, v27);
                    if ( !v7 || v14 < 0 )
                      *v4 = 45;
                  }
                  else
                  {
                    LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_100692F0 + v10), v32 * v8, v9);
                  }
                }
                else
                {
                  v25 = v9;
                  if ( v34[0] & 0x40 )
                  {
                    v13 = v32;
                    LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v32 * v8, v25, v30);
                    if ( v13 < 0 )
                      *v4 = 45;
                  }
                  else
                  {
                    LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_100692F0 + v10), v32 * v8, v9, v30);
                  }
                }
              }
              else
              {
                v26 = (unsigned __int8)((unsigned __int16)(v30 % 10) + 48);
                v24 = (unsigned __int8)(v30 / 10 + 48);
                if ( v34[0] & 0x40 )
                {
                  LOBYTE(a1) = sprintf(v4, &a03d02u[v10], v9, v24, v26);
                  if ( !v7 || v32 < 0 )
                    *v4 = 45;
                }
                else
                {
                  LOBYTE(a1) = sprintf(v4, *(char **)((char *)off_100692F0 + v10), v9, v24, v26);
                }
              }
            }
            else
            {
              LOBYTE(a1) = sprintf(
                             v4,
                             "%02u:%c%c",
                             v9,
                             (unsigned __int8)(v30 / 10 + 48),
                             (unsigned __int8)((unsigned __int16)(v30 % 10) + 48));
            }
          }
        }
      }
      break;
    case 55:
      if ( !sub_10020EC0(v34) || v7 >= 86400 )
        goto LABEL_53;
      if ( sub_1001D460(v16) == 1 )
        sub_100212A0((int *)v34, *(int *)v34);
      v7 += 86400
          * (((signed int)(((unsigned __int64)(1037155065i64 * (*(_DWORD *)v34 + v7)) >> 32) - (*(_DWORD *)v34 + v7)) >> 16)
           + ((unsigned int)(((unsigned __int64)(1037155065i64 * (*(_DWORD *)v34 + v7)) >> 32) - (*(_DWORD *)v34 + v7)) >> 31))
          + *(_DWORD *)v34;
      goto LABEL_46;
    case 52:
    case 53:
    case 56:
LABEL_46:
      if ( v7 == -1 || v7 >= 86400 )
      {
LABEL_53:
        v28 = 0x7FFF;
        if ( v5 == 53 || v5 == 56 )
          LOBYTE(v31) = 38;
        else
          sub_1000B040(&v28, &v31);
        v18 = (&off_100692F4)[64 * (v5 - 46)];
        do
        {
          LOBYTE(a1) = *v18;
          *v4++ = *v18++;
        }
        while ( (_BYTE)a1 );
      }
      else
      {
        sub_100211A0((int)&v28, v7);
        if ( v5 == 53 )
        {
          v17 = off_100692F0[16 * (v5 - 46)];
          LOBYTE(v31) = 38;
          LOBYTE(a1) = sprintf(v4, v17, v28, v29, v30);
        }
        else if ( v5 == 56 )
        {
          LOBYTE(v31) = 38;
          LOBYTE(a1) = sprintf(v4, off_100692F0[16 * (v5 - 46)], v28, v29);
        }
        else
        {
          sub_1000B040(&v28, &v31);
          LOBYTE(a1) = sprintf(v4, off_100692F0[16 * (v5 - 46)], v28, v29);
        }
      }
      break;
    case 54:
      if ( sub_1000B4A0(&v28, &v31) )
      {
        if ( sub_1001D430(v19) == 1 )
        {
          if ( v28 && v28 != 12 )
          {
            LOBYTE(a1) = sprintf(v4, "%d:%02d:%02d", v28 % 12, v29, v30);
          }
          else
          {
            sprintf(v4, "%02d:%02d:%02d", 12, v29, v30);
            LOBYTE(a1) = sprintf(v4, "%02d:%02d:%02d", 12, v29, v30);
          }
        }
        else
        {
          LOBYTE(a1) = sprintf(v4, off_100692F0[16 * (v5 - 46)], v28, v29, v30);
        }
      }
      else
      {
        v20 = (&off_100692F4)[64 * (v5 - 46)];
        do
        {
          LOBYTE(a1) = *v20;
          *v4++ = *v20++;
        }
        while ( (_BYTE)a1 );
      }
      break;
    default:
      break;
  }
  if ( ~(unsigned __int8)(*(_WORD *)(a3 + 8) >> 9) & 1 )
  {
    a1 = sub_10021070(v31);
    v21 = a4;
    do
    {
      v22 = *a1;
      *v21++ = *a1++;
    }
    while ( v22 );
  }
  else
  {
    *a4 = 0;
  }
  return (unsigned int)a1;
}
// 100692F0: using guessed type char *off_100692F0[2];
// 100692F4: using guessed type char *off_100692F4;
// 10069324: using guessed type __int16 word_10069324[];

//----- (1000C210) --------------------------------------------------------
char __usercall sub_1000C210@<al>(signed int *a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // ebx@1
  __int16 v5; // cx@1
  int v6; // ebx@2
  __int16 v7; // ax@4
  char v9; // [sp+4h] [bp-24h]@1
  char v10; // [sp+Ch] [bp-1Ch]@1

  v4 = a2;
  sub_1000BD10(&v10, a1, a4, &v9);
  *(_WORD *)(a3 + 438) = *(_WORD *)v4;
  *(_WORD *)(a3 + 436) = *(_WORD *)(v4 + 2);
  v5 = *(_WORD *)(a4 + 8);
  if ( ~((unsigned int)*(_WORD *)(a4 + 8) >> 9) & 1 )
    v6 = sub_1000B1D0(*(_DWORD *)(a4 + 4), v5);
  else
    v6 = 0;
  v7 = *(_WORD *)(a4 + 10) - v6;
  if ( v6 > 0 )
    v7 -= *(_WORD *)(dword_101E37E4[5 * ((*(_DWORD *)(a4 + 4) >> 10) & 0xF)] + 28);
  if ( !*(_WORD *)(a4 + 10) )
    v7 = sub_1000AFE0(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8));
  return sub_10015EA0(a3, &v10, &v9, v7, v6, *(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8));
}
// 101E37E4: using guessed type int dword_101E37E4[];

//----- (1000C2D0) --------------------------------------------------------
char __cdecl sub_1000C2D0(int a1, int a2, int *a3, signed int *a4, int a5)
{
  signed int *v5; // ecx@1
  int v6; // edx@2
  int v7; // ebx@4
  bool v8; // zf@4
  __int16 v9; // ax@8
  _WORD *v10; // esi@8
  unsigned int v11; // ebx@9
  int v12; // eax@9
  int v13; // eax@11
  __int16 v14; // dx@15
  __int16 v15; // cx@15
  __int64 v16; // rax@18
  int v17; // eax@20
  __int16 v18; // bx@20
  signed int v19; // eax@21
  signed int v20; // edx@29
  int v21; // edx@31
  int v22; // edx@32
  int *v23; // ecx@34
  int v24; // esi@34
  signed int v25; // eax@35
  __int16 v26; // ax@37
  int v27; // esi@39
  void *v28; // ecx@39
  signed __int16 v29; // bx@39
  __int16 v30; // ax@41
  int v31; // edi@55
  int v32; // esi@57
  char v33; // al@58
  __int16 v34; // ax@63
  int v35; // edi@67
  char v36; // al@68
  __int16 v37; // ax@75
  int v38; // eax@77
  char v39; // cl@77
  char v40; // al@79
  int v41; // eax@85
  signed int *v42; // edx@85
  const char *v43; // edx@89
  char v44; // kr00_1@89
  char *v45; // eax@89
  char v46; // dl@89
  char v47; // cl@90
  int v48; // ecx@91
  __int16 v49; // ax@92
  int v50; // ebx@97
  __int16 v51; // ax@101
  int v52; // eax@105
  int v53; // esi@105
  __int16 v54; // cx@107
  char v55; // dl@114
  int v56; // edi@120
  int v57; // edi@129
  __int16 v58; // ax@129
  char v59; // al@131
  char v60; // cl@132
  int v61; // ebx@136
  int v62; // ecx@137
  int v63; // edx@137
  unsigned __int8 v64; // al@137
  __int16 v65; // ax@139
  __int16 v66; // ax@146
  int v67; // eax@151
  int v68; // esi@155
  __int16 v69; // cx@156
  signed int *v70; // edx@156
  int v71; // ecx@156
  int v72; // ecx@157
  int v73; // edx@157
  unsigned __int8 v74; // al@157
  __int16 v75; // ax@159
  int v76; // eax@167
  unsigned __int8 v77; // cl@167
  __int16 v78; // ax@171
  int v79; // eax@176
  int v80; // ebx@181
  int *v81; // eax@194
  unsigned __int8 v82; // ST10_1@194
  char *v83; // ebx@194
  int v84; // esi@194
  __int16 v85; // ax@194
  char v87; // [sp+13h] [bp-3Dh]@4
  int v88; // [sp+14h] [bp-3Ch]@5
  int v89; // [sp+18h] [bp-38h]@4
  signed int *v90; // [sp+1Ch] [bp-34h]@1
  int v91; // [sp+20h] [bp-30h]@1
  int *v92; // [sp+24h] [bp-2Ch]@1
  int v93; // [sp+28h] [bp-28h]@4
  int v94; // [sp+2Ch] [bp-24h]@5
  int v95; // [sp+30h] [bp-20h]@85
  char v96[24]; // [sp+34h] [bp-1Ch]@35

  v5 = a4;
  v92 = a3;
  v91 = a2;
  v90 = a4;
  if ( a4 )
    v6 = *a4;
  else
    v6 = 0;
  v7 = (*(_BYTE *)(a2 + 8) & 0x3F) - 46;
  v8 = *(_WORD *)a5 == -32703;
  v89 = v6;
  v87 = 1;
  v93 = v7;
  if ( v8 )
  {
    v88 = 0;
    v94 = 0;
  }
  else
  {
    sub_1000B240(&v94, a2, &v88);
    v5 = v90;
    v6 = v89;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v9 = *(_WORD *)(a2 + 10);
      v10 = (_WORD *)(a1 + 276);
      if ( v9 )
      {
        sub_10015D40(a1 + 276, *v92, *(_DWORD *)(a2 + 4), v9);
      }
      else
      {
        v11 = *(_DWORD *)(a2 + 4);
        v12 = sub_1000AFE0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
        sub_10015D40(a1 + 276, *v92, v11, v12);
      }
      v13 = sub_1000B1D0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
      if ( (!*(_WORD *)(a2 + 10) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v13 > 0 )
      {
        v14 = *(_WORD *)(dword_101E37E4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v13 + v14;
        v15 = *(_WORD *)(a1 + 280);
        if ( *(_WORD *)(a2 + 10) > 0 )
          *v10 += v13 + v14;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v16 = (signed __int16)v13 + (signed int)v14 + 1;
          LODWORD(v16) = ((signed int)v16 - HIDWORD(v16)) >> 1;
          *v10 -= v16;
          *(_WORD *)(a1 + 280) = v15 - v16;
        }
      }
      return 2;
    case 0x8048:
      v17 = *(_DWORD *)(a1 + 56);
      v18 = *(_WORD *)(v17 + 240);
      if ( v18 == -128 )
      {
        v19 = *(_WORD *)(a5 + 10);
        if ( v19 > 84 )
        {
          if ( v19 != 0x2000 )
            return v87;
        }
        else if ( v19 != 84 )
        {
          if ( v19 == 32 )
          {
            v93 = 0;
            v87 = sub_1000B2B0(&v93, a1, a2, v88);
          }
          else if ( v19 == 56 )
          {
            v87 = sub_1000B2B0(v5, a1, a2, v88);
          }
          return v87;
        }
        return sub_1000B520(a2, a1, v5, a5);
      }
      v20 = *(_WORD *)(a5 + 10);
      if ( v20 > 56 )
      {
        if ( v20 == 57 )
        {
          v60 = *(_BYTE *)(a5 + 8);
          if ( v60 < 0 )
          {
            if ( v18 )
            {
              --*(_WORD *)(v17 + 240);
              if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) )
              {
                v61 = v88;
                do
                {
                  v62 = *(_DWORD *)(a1 + 56);
                  v63 = *(_WORD *)(v62 + 240);
                  v64 = *(_BYTE *)(v63 + v62 + 69);
                  if ( v64 >= 0x30u && v64 <= 0x39u )
                  {
                    v65 = *(_WORD *)(a2 + 8) & 0x3F;
                    if ( v65 != 46 && v65 != 47 && v65 != 52 && v65 != 48 && v65 != 54 )
                      break;
                    if ( v63 != v61 + 1 )
                      break;
                  }
                  --*(_WORD *)(v62 + 240);
                }
                while ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) );
              }
              v66 = *(_WORD *)(a2 + 8) & 0x3F;
              v87 = 2;
              if ( v66 != 46 && v66 != 47 && v66 != 52 && v66 != 48 && v66 != 54
                || (v67 = *(_DWORD *)(a1 + 56), *(_WORD *)(v67 + 240) != v88) )
              {
                *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
              }
              else
              {
                *(_BYTE *)(v67 + 242) = 2;
              }
            }
            else
            {
              v87 = 2;
            }
            goto LABEL_127;
          }
          if ( v60 <= 0 )
            return v87;
          v68 = v94 - 1;
          if ( v18 >= v94 - 1 )
            return 0;
          v69 = *(_WORD *)(v17 + 240);
          v70 = (signed int *)v69;
          *(_WORD *)(v17 + 240) = v69 + 1;
          v71 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
          v90 = v70;
          if ( v71 < v68 )
          {
            do
            {
              v72 = *(_DWORD *)(a1 + 56);
              v73 = *(_WORD *)(v72 + 240);
              v74 = *(_BYTE *)(v73 + v72 + 69);
              if ( v74 >= 0x30u && v74 <= 0x39u )
              {
                v75 = *(_WORD *)(a2 + 8) & 0x3F;
                if ( v75 != 46 && v75 != 47 && v75 != 52 && v75 != 48 && v75 != 54 )
                  break;
                if ( v73 != v88 + 1 )
                  break;
              }
              ++*(_WORD *)(v72 + 240);
            }
            while ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v68 );
          }
          if ( byte_1006932C[64 * v93]
            || (v76 = *(_DWORD *)(a1 + 56), v77 = *(_BYTE *)(*(_WORD *)(v76 + 240) + v76 + 69), v77 >= 0x30u)
            && v77 <= 0x39u )
          {
            v87 = 2;
          }
          else
          {
            *(_WORD *)(v76 + 240) = (char)v90;
            v87 = 0;
          }
          v78 = *(_WORD *)(a2 + 8) & 0x3F;
          if ( v78 != 46 && v78 != 47 && v78 != 52 && v78 != 48 && v78 != 54
            || (v79 = *(_DWORD *)(a1 + 56), *(_WORD *)(v79 + 240) != v88) )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
          }
          else
          {
            *(_BYTE *)(v79 + 242) = 2;
          }
        }
        else
        {
          if ( v20 != 84 && v20 != 0x2000 )
            return v87;
          v87 = sub_1000B520(a2, a1, v5, a5);
        }
        if ( v87 != 4 && v87 != 2 )
          return v87;
LABEL_127:
        if ( v89 < 0 )
          v89 = -v89;
        v57 = v91;
        sub_1000B0B0(v91, (int)&v89, v89);
        v58 = *(_WORD *)(v57 + 8) & 0x3F;
        LOBYTE(v88) = 31;
        if ( v58 == 52 || v58 == 54 )
        {
          v59 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90);
          goto LABEL_187;
        }
        goto LABEL_192;
      }
      if ( v20 == 56 )
      {
        v90 = (signed int *)(2 * (*(_BYTE *)(a5 + 8) >= 0) - 1);
        if ( v18 >= v88 )
        {
          v43 = (const char *)(v17 + 69);
          v44 = strlen((const char *)(v17 + 69));
          v45 = strchr(v43, 58);
          v46 = (_BYTE)v45 + 1;
          do
            v47 = *v45++;
          while ( v47 );
          v48 = *(_DWORD *)(a1 + 56);
          if ( *(_WORD *)(v48 + 240) < (signed __int16)(char)(v44 - ((_BYTE)v45 - v46)) )
          {
            v49 = *(_WORD *)(a2 + 8) & 0x3F;
            if ( v49 == 46 || v49 == 47 || v49 == 52 || v49 == 48 || v49 == 54 )
            {
              v50 = v88;
              *(_WORD *)(v48 + 240) = v88;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 2;
              goto LABEL_100;
            }
            *(_BYTE *)(v48 + 242) = 1;
          }
        }
        v50 = v88;
LABEL_100:
        if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != v94 - 1
          || (v51 = *(_WORD *)(a2 + 8) & 0x3F, v51 != 52) && v51 != 54
          || sub_1001D430((void *)(v94 - 1)) != 1 )
        {
          v52 = *(_DWORD *)(a1 + 56);
          v53 = *(_WORD *)(v52 + 240);
          if ( v53 == v50 - 1 )
          {
            v87 = 2;
            *(_BYTE *)(v52 + 69) = 2 * (*(_BYTE *)(v52 + 69) != 45) + 43;
          }
          else
          {
            v54 = *(_WORD *)(a2 + 8) & 0x3F;
            if ( v54 != 46 && v54 != 47 && v54 != 52 && v54 != 48 && v54 != 54 || v53 != v50 )
            {
              v55 = *(_BYTE *)(v53 + v52 + 69);
              if ( v55 != 48 || v90 != (signed int *)-1 )
              {
                if ( *(_BYTE *)(*(_WORD *)(v52 + 240) + v52 + 69) < (unsigned __int8)*(&byte_100692F8[(v93 << 6) - v50]
                                                                                     + *(_WORD *)(v52 + 240))
                  || v90 != (signed int *)1 )
                {
                  v56 = *(_DWORD *)(a1 + 56);
                  *(_BYTE *)(*(_WORD *)(v56 + 240) + v56 + 69) = sub_1001DF60(v55, 0x10u, (char)v90);
                  v87 = 2;
                }
                else
                {
                  *(_BYTE *)(v53 + v52 + 69) = 48;
                  v87 = 2;
                }
              }
              else
              {
                *(_BYTE *)(*(_WORD *)(v52 + 240) + v52 + 69) = *(&byte_100692F8[(v93 << 6) - v50] + *(_WORD *)(v52 + 240));
                v87 = 2;
              }
            }
            else
            {
              sub_1000B110(a1, v50, v91, (int)v90);
              v87 = 2;
            }
          }
        }
        else
        {
          v87 = 2;
          *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) = (*(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) == -108) - 108;
        }
        goto LABEL_127;
      }
      v21 = v20 - 32;
      if ( !v21 )
        goto LABEL_34;
      v22 = v21 - 1;
      if ( v22 )
      {
        if ( v22 != 7 )
          return v87;
LABEL_34:
        v23 = v92;
        v24 = v91;
        *(_WORD *)(v17 + 240) = -128;
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
        sub_1000C210(v90, (int)v23, a1, v24);
        return 6;
      }
      *(_WORD *)(v17 + 240) = -128;
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
      sub_1001E210((int)v96, (_BYTE *)(*(_DWORD *)(a1 + 56) + 69), 21);
      v25 = v94;
      if ( (unsigned int)v94 >= 0x14 )
        v25 = 20;
      v96[v25] = 0;
      v26 = *(_WORD *)(a2 + 8) & 0x3F;
      BYTE3(v89) = 0;
      if ( v26 != 50 && v26 != 51 )
      {
        v27 = v88;
        BYTE2(v89) = 0;
        v29 = j__atol(&v96[v88]);
      }
      else
      {
        v27 = v88;
        BYTE2(v89) = j__atol(&v96[v88]);
        v29 = 0;
      }
      v30 = *(_WORD *)(a2 + 8) & 0x3F;
      LOWORD(v89) = v29;
      if ( v30 != 49
        && v30 != 48
        && v30 != 47
        && v30 != 50
        && v30 != 51
        && v30 != 46
        && v30 != 56
        && v30 != 53
        && sub_1001D430(v28) == 1 )
      {
        if ( !v29 )
        {
          v29 = 12;
LABEL_54:
          LOWORD(v89) = v29;
          goto LABEL_55;
        }
        if ( v29 > 12 )
        {
          v29 -= 12;
          goto LABEL_54;
        }
      }
LABEL_55:
      v31 = v27 + 3;
      if ( word_10069324[32 * v93] <= 99 )
        v31 = v27 + 2;
      v32 = v94;
      if ( v31 < v94 )
      {
        while ( 1 )
        {
          v33 = v96[v31];
          if ( (unsigned __int8)v33 >= 0x30u && (unsigned __int8)v33 <= 0x39u )
            break;
          if ( ++v31 >= v94 )
            goto LABEL_67;
        }
        if ( v31 < v94 )
        {
          v34 = *(_WORD *)(v91 + 8) & 0x3F;
          if ( v34 != 50 && v34 != 51 )
            BYTE2(v89) = j__atol(&v96[v31]);
          else
            BYTE3(v89) = j__atol(&v96[v31]);
        }
      }
LABEL_67:
      v35 = v31 + 2;
      if ( v35 < v32 )
      {
        while ( 1 )
        {
          v36 = v96[v35];
          if ( (unsigned __int8)v36 >= 0x30u && (unsigned __int8)v36 <= 0x39u )
            break;
          if ( ++v35 >= v32 )
            goto LABEL_74;
        }
        if ( v35 < v32 )
          BYTE3(v89) = j__atol(&v96[v35]);
      }
LABEL_74:
      if ( sub_1001D430(v28) == 1 )
      {
        v37 = *(_WORD *)(v91 + 8) & 0x3F;
        if ( v37 == 52 || v37 == 54 )
        {
          v38 = *(_DWORD *)(a1 + 56);
          v39 = *(_BYTE *)(v38 + 90);
          *(_BYTE *)(v38 + 90) = -108;
          if ( v29 )
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90) = v39;
          v40 = *(_BYTE *)(*(_DWORD *)(a1 + 56) + 90);
          if ( v40 == -107 && v29 < 12 )
          {
            v29 += 12;
            LOWORD(v89) = v29;
          }
          if ( v40 == -108 && v29 == 12 )
            LOWORD(v89) = 0;
        }
      }
      sub_100211F0(&v95, v89);
      v41 = v95;
      v42 = v90;
      *v90 = v95;
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 69) == 45 )
        *v42 = -v41;
      sub_1000C210(v42, (int)v92, a1, v91);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v80 = *(_DWORD *)(a1 + 56), *(_WORD *)(v80 + 240) != -128) )
      {
        if ( v6 < 0 )
          v89 = -v6;
        v57 = v91;
        sub_1000B0B0(v91, (int)&v89, v89);
        v58 = *(_WORD *)(v57 + 8) & 0x3F;
        LOBYTE(v88) = 31;
        if ( v58 != 52 && v58 != 54 )
        {
LABEL_192:
          if ( v58 == 56 )
            LOBYTE(v88) = 38;
        }
        else
        {
          v59 = *(_BYTE *)(v80 + 90);
LABEL_187:
          if ( v59 == -108 )
          {
            LOBYTE(v88) = 35;
          }
          else if ( v59 == -107 )
          {
            LOBYTE(v88) = 36;
          }
          else
          {
            sub_1000B040((signed __int16 *)&v89, &v88);
          }
        }
        sprintf(v96, (const char *)(*(_DWORD *)(a1 + 56) + 69));
        v81 = v92;
        *(_WORD *)(a1 + 438) = *(_WORD *)v92;
        v82 = v88;
        *(_WORD *)(a1 + 436) = *((_WORD *)v81 + 1);
        v83 = sub_10021070(v82);
        v84 = sub_1000B1D0(*(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
        v85 = *(_WORD *)(v57 + 10) - v84;
        if ( v84 > 0 )
          v85 -= *(_WORD *)(dword_101E37E4[5 * ((*(_DWORD *)(v57 + 4) >> 10) & 0xF)] + 28);
        if ( !*(_WORD *)(v57 + 10) )
          v85 = sub_1000AFE0(*(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
        sub_10015EA0(a1, v96, v83, v85, v84, *(_DWORD *)(v57 + 4), *(_WORD *)(v57 + 8));
      }
      else
      {
        sub_1000C210(v90, (int)v92, a1, v91);
      }
      return v87;
    default:
      return v87;
  }
}
// 10069324: using guessed type __int16 word_10069324[];
// 101E37E4: using guessed type int dword_101E37E4[];
// 1000C2D0: using guessed type char var_1C[24];

//----- (1000CDD0) --------------------------------------------------------
char *__usercall sub_1000CDD0@<eax>(int a1@<eax>, void *a2@<ecx>, int a3)
{
  char *result; // eax@1
  unsigned int v4; // edx@2
  void *v5; // edi@2
  char v6; // cl@3
  char *v7; // ecx@4
  char v8; // dl@5
  char *v9; // esi@6
  char *v10; // edi@6
  char v11; // cl@7

  result = (char *)sub_10004660(a2, a2, a1);
  if ( result )
  {
    v4 = strlen((const char *)&unk_10069B88) + 1;
    v5 = (void *)(a3 - 1);
    do
    {
      v6 = *((_BYTE *)v5 + 1);
      v5 = (char *)v5 + 1;
    }
    while ( v6 );
    qmemcpy(v5, &unk_10069B88, v4);
    v7 = result;
    do
      v8 = *result++;
    while ( v8 );
    result -= (signed int)v7;
    v9 = v7;
    v10 = (char *)(a3 - 1);
    do
      v11 = (v10++)[1];
    while ( v11 );
    qmemcpy(v10, v9, (unsigned int)result);
  }
  return result;
}

//----- (1000CE50) --------------------------------------------------------
char __usercall sub_1000CE50@<al>(unsigned __int8 a1@<al>, int a2@<ecx>, char a3)
{
  int v3; // edi@1
  char *v4; // eax@3
  char *v5; // edx@3
  char v6; // cl@4
  unsigned int v7; // eax@5
  char *v8; // edi@5
  char v9; // cl@6
  char result; // al@7

  v3 = a2;
  if ( a3 || !sub_10005BB0(a1) )
  {
    result = 0;
  }
  else
  {
    v4 = sub_1001FFA0(0x60u);
    v5 = v4;
    do
      v6 = *v4++;
    while ( v6 );
    v7 = v4 - v5;
    v8 = (char *)(v3 - 1);
    do
      v9 = (v8++)[1];
    while ( v9 );
    qmemcpy(v8, v5, v7);
    result = 1;
  }
  return result;
}

//----- (1000CEB0) --------------------------------------------------------
int __usercall sub_1000CEB0@<eax>(__int16 a1@<ax>, signed __int16 a2@<dx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  int result; // eax@1

  result = a1 & 0xC000;
  *a3 = *a4;
  if ( result == 0x4000 )
  {
    *(_WORD *)a3 -= a2;
  }
  else if ( result == 0x8000 )
  {
    result = a2 / -2;
    *(_WORD *)a3 += result;
  }
  return result;
}

//----- (1000CEE0) --------------------------------------------------------
int __usercall sub_1000CEE0@<eax>(unsigned int a1@<eax>, int a2@<ecx>, int a3, char a4)
{
  int v4; // esi@1
  char v5; // di@1
  int v6; // eax@1
  int v7; // ebx@1
  int v8; // edi@1
  void *v9; // esi@1
  int result; // eax@3

  v4 = a2;
  v5 = a1;
  *(_WORD *)(a2 + 396) = 3;
  *(_WORD *)(a2 + 398) = 3;
  *(_WORD *)(a2 + 426) = 1;
  *(_WORD *)(a2 + 424) = 1;
  *(_WORD *)(a2 + 394) = 1;
  v6 = (a1 >> 5) & 0x1F;
  *(_WORD *)(a2 + 428) = word_1010FC78[v6];
  *(_WORD *)(a2 + 430) = word_1010FC78[v6];
  *(_WORD *)(a2 + 440) = word_1010FC78[v6];
  *(_WORD *)(a2 + 442) = word_1010FC78[v6];
  v7 = a2 + 392;
  sub_1005C3A0(a2 + 392, *(_WORD *)a3, *(_WORD *)(a3 + 2) - 12, 33, 12, 1);
  v8 = v5 & 0x1F;
  *(_WORD *)(v4 + 428) = word_1010FC78[v8];
  *(_WORD *)(v4 + 430) = word_1010FC78[v8];
  *(_WORD *)(v4 + 440) = word_1010FC78[v8];
  *(_WORD *)(v4 + 442) = word_1010FC78[v8];
  v9 = &unk_10069B90;
  do
  {
    if ( a4 )
      result = sub_1005C340(v7, *(_WORD *)a3 + *(_WORD *)v9, *(_WORD *)(a3 + 2) + *((_WORD *)v9 + 1) - 11);
    else
      result = sub_1005C340(v7, *(_WORD *)a3 + *(_WORD *)v9, *(_WORD *)(a3 + 2) - *((_WORD *)v9 + 1));
    v9 = (char *)v9 + 4;
  }
  while ( (signed int)v9 < (signed int)"00000" );
  return result;
}
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (1000D020) --------------------------------------------------------
char __usercall sub_1000D020@<al>(int a1@<ecx>, _WORD *a2@<ebx>, int a3@<edi>, int a4, int a5)
{
  int v5; // esi@1
  char v6; // dl@1
  int v7; // eax@1
  char v8; // al@1
  char v9; // al@3
  float v10; // ST44_4@3
  char v11; // ST40_1@3
  int v12; // ST3C_4@3
  char v13; // al@3
  signed int v14; // eax@7
  unsigned int v15; // ST40_4@7
  int v16; // edi@7
  unsigned int v17; // eax@7
  void *v18; // ecx@7
  unsigned __int8 v19; // al@10
  char result; // al@11
  char v21; // dl@11
  unsigned __int8 v22; // al@17
  signed int v23; // eax@18
  int v24; // eax@18
  void *v25; // ecx@18
  int v26; // eax@23
  int v27; // ecx@25
  char v28; // dl@26
  unsigned int v29; // eax@27
  char *v30; // edi@27
  char v31; // cl@28
  char *v32; // eax@29
  char *v33; // esi@29
  char v34; // cl@30
  unsigned int v35; // eax@31
  char *v36; // edi@31
  char v37; // cl@32
  __int16 v38; // di@33
  __int16 v39; // si@33
  char *v40; // eax@33
  void *v41; // ecx@37
  char *v42; // eax@37
  __int16 v43; // di@37
  int v44; // ecx@37
  int v45; // eax@39
  void *v46; // ecx@39
  __int16 v47; // ax@39
  unsigned int v48; // esi@39
  unsigned int v49; // eax@41
  char *v50; // edi@41
  char v51; // cl@42
  int v52; // eax@43
  void *v53; // ecx@43
  int v54; // edi@45
  __int16 v55; // si@45
  __int16 v56; // ax@45
  int v57; // esi@45
  __int16 v58; // dx@45
  int v59; // eax@47
  char v60; // cl@48
  unsigned int v61; // eax@49
  char *v62; // edi@49
  char v63; // cl@50
  char *v64; // eax@51
  char *v65; // esi@51
  char v66; // cl@52
  unsigned int v67; // eax@53
  char *v68; // edi@53
  char v69; // cl@54
  int v70; // eax@55
  char v71; // cl@56
  __int16 v72; // si@57
  __int16 v73; // ax@57
  int v74; // eax@59
  char v75; // cl@60
  unsigned int v76; // eax@61
  char *v77; // edi@61
  char v78; // cl@62
  char *v79; // eax@63
  char *v80; // esi@63
  char v81; // cl@64
  unsigned int v82; // eax@65
  char *v83; // edi@65
  char v84; // cl@66
  char *v85; // esi@67
  unsigned int v86; // eax@67
  char *v87; // edi@67
  char v88; // cl@68
  int v89; // eax@73
  char v90; // cl@74
  int v91; // eax@76
  char v92; // cl@77
  unsigned int v93; // eax@78
  char *v94; // edi@78
  char v95; // cl@79
  char *v96; // eax@80
  char *v97; // esi@80
  char v98; // cl@81
  unsigned int v99; // eax@82
  char *v100; // edi@82
  char v101; // cl@83
  int v102; // eax@84
  char *v103; // ecx@84
  int v104; // esi@86
  int v105; // eax@88
  char v106; // cl@89
  unsigned int v107; // eax@90
  char *v108; // edi@90
  char v109; // cl@91
  char *v110; // eax@92
  char *v111; // esi@92
  char v112; // cl@93
  unsigned int v113; // eax@94
  char *v114; // edi@94
  char v115; // cl@95
  int v116; // eax@96
  char v117; // cl@97
  int v118; // eax@100
  char v119; // cl@101
  unsigned int v120; // eax@102
  char *v121; // edi@102
  char v122; // cl@103
  char *v123; // eax@104
  char *v124; // esi@104
  char v125; // cl@105
  unsigned int v126; // eax@106
  char *v127; // edi@106
  char v128; // cl@107
  double v129; // st7@108
  int v130; // eax@108
  char *v131; // esi@110
  unsigned int v132; // eax@110
  char *v133; // edi@110
  char v134; // cl@111
  int v135; // eax@114
  void *v136; // ecx@114
  __int16 v137; // ax@34
  int v138; // esi@117
  __int64 v139; // rax@117
  __int16 v140; // ax@117
  void *v141; // ecx@120
  char *v142; // eax@120
  int v143; // eax@122
  char v144; // cl@123
  __int16 v145; // ax@124
  __int16 v146; // di@124
  char *v147; // ecx@126
  int v148; // eax@126
  int v149; // eax@128
  char v150; // cl@129
  unsigned int v151; // eax@130
  char *v152; // edi@130
  char v153; // cl@131
  void *v154; // ecx@134
  int v155; // eax@134
  char v156; // cl@137
  void *v157; // ecx@140
  int v158; // eax@140
  int v159; // eax@142
  char v160; // cl@143
  __int16 v161; // ax@144
  int v162; // edi@144
  int v163; // edx@144
  void *v164; // ecx@151
  int v165; // eax@151
  int v166; // eax@153
  char *v167; // ecx@153
  __int16 v168; // ax@155
  int v169; // esi@155
  __int16 v170; // dx@155
  __int16 v171; // ax@155
  int v172; // eax@157
  char v173; // cl@158
  unsigned int v174; // eax@159
  char *v175; // edi@159
  char v176; // cl@160
  char *v177; // eax@161
  char *v178; // esi@161
  char v179; // cl@162
  unsigned int v180; // eax@163
  char *v181; // edi@163
  char v182; // cl@164
  int v183; // eax@165
  char v184; // cl@166
  __int16 v185; // si@167
  __int16 v186; // ax@167
  int v187; // eax@169
  char v188; // cl@170
  unsigned int v189; // eax@171
  char *v190; // edi@171
  char v191; // cl@172
  char *v192; // eax@173
  char *v193; // esi@173
  char v194; // cl@174
  unsigned int v195; // eax@175
  char *v196; // edi@175
  char v197; // cl@176
  char v198; // cl@178
  int v199; // edx@179
  int v200; // eax@181
  char v201; // cl@182
  unsigned int v202; // eax@183
  char *v203; // edi@183
  char v204; // cl@184
  char *v205; // eax@185
  char *v206; // esi@185
  char v207; // cl@186
  unsigned int v208; // eax@187
  char *v209; // edi@187
  char v210; // cl@188
  int v211; // eax@189
  char v212; // cl@190
  int v213; // eax@193
  char v214; // cl@194
  unsigned int v215; // eax@195
  char *v216; // edi@195
  char v217; // cl@196
  char *v218; // eax@197
  char *v219; // esi@197
  char v220; // cl@198
  unsigned int v221; // eax@199
  char *v222; // edi@199
  char v223; // cl@200
  int v224; // eax@201
  char v225; // cl@202
  int v226; // eax@205
  char v227; // cl@206
  unsigned int v228; // eax@207
  char *v229; // edi@207
  char v230; // cl@208
  char *v231; // eax@209
  char *v232; // esi@209
  char v233; // cl@210
  unsigned int v234; // eax@211
  char *v235; // edi@211
  char v236; // cl@212
  double v237; // st7@213
  int v238; // eax@213
  char v239; // cl@216
  __int16 v240; // ax@86
  int v241; // eax@226
  void *v242; // ecx@226
  __int16 v243; // ax@228
  __int16 v244; // di@228
  int v245; // ecx@228
  char *v246; // ecx@229
  int v247; // eax@229
  int v248; // eax@231
  void *v249; // ecx@231
  __int16 v250; // ax@233
  __int16 v251; // di@233
  int v252; // ecx@233
  int v253; // eax@244
  char v254; // al@245
  double v255; // st7@245
  char *v256; // edi@246
  char v257; // al@247
  char *v258; // edi@249
  char v259; // al@250
  void *v260; // ecx@253
  int v261; // eax@253
  int *v262; // ecx@255
  int v263; // esi@259
  __int16 v264; // ax@259
  __int16 v265; // cx@259
  int v266; // esi@260
  __int16 v267; // ax@260
  int v268; // [sp-8h] [bp-1C4h]@98
  int v269; // [sp+14h] [bp-1A8h]@33
  char v270; // [sp+18h] [bp-1A4h]@7
  int v271; // [sp+1Ah] [bp-1A2h]@7
  float v272; // [sp+20h] [bp-19Ch]@5
  int v273; // [sp+24h] [bp-198h]@1
  int v274; // [sp+28h] [bp-194h]@1
  char v275; // [sp+2Fh] [bp-18Dh]@1
  int v276; // [sp+30h] [bp-18Ch]@7
  int v277; // [sp+34h] [bp-188h]@7
  unsigned int v278; // [sp+38h] [bp-184h]@7
  __int16 v279; // [sp+3Ch] [bp-180h]@7
  __int16 v280; // [sp+3Eh] [bp-17Eh]@7
  int v281; // [sp+40h] [bp-17Ch]@7
  int v282; // [sp+44h] [bp-178h]@7
  int v283; // [sp+58h] [bp-164h]@43
  char v284; // [sp+5Eh] [bp-15Eh]@71
  char v285; // [sp+5Fh] [bp-15Dh]@2
  int v286; // [sp+60h] [bp-15Ch]@7
  float v287; // [sp+64h] [bp-158h]@3
  float v288; // [sp+68h] [bp-154h]@21
  unsigned __int16 v289; // [sp+6Ch] [bp-150h]@238
  char v290; // [sp+73h] [bp-149h]@71
  char v291; // [sp+74h] [bp-148h]@1
  char v292; // [sp+75h] [bp-147h]@1
  char v293; // [sp+80h] [bp-13Ch]@57
  unsigned int v294; // [sp+98h] [bp-124h]@11
  unsigned int v295; // [sp+9Ch] [bp-120h]@41
  float v296; // [sp+A0h] [bp-11Ch]@11
  float v297; // [sp+A4h] [bp-118h]@11
  double v298; // [sp+B0h] [bp-10Ch]@108
  int v299; // [sp+B8h] [bp-104h]@239
  float v300; // [sp+BCh] [bp-100h]@3
  int v301; // [sp+C0h] [bp-FCh]@3
  int v302; // [sp+C4h] [bp-F8h]@7
  unsigned int v303; // [sp+C8h] [bp-F4h]@7
  __int16 v304; // [sp+CCh] [bp-F0h]@7
  __int16 v305; // [sp+CEh] [bp-EEh]@7
  char v306; // [sp+D0h] [bp-ECh]@71
  char v307; // [sp+D4h] [bp-E8h]@1
  char v308; // [sp+D5h] [bp-E7h]@2
  unsigned int v309; // [sp+F8h] [bp-C4h]@37
  int v310; // [sp+110h] [bp-ACh]@7
  unsigned int v311; // [sp+114h] [bp-A8h]@7
  __int16 v312; // [sp+118h] [bp-A4h]@7
  char v313; // [sp+11Ah] [bp-A2h]@7
  char v314; // [sp+11Bh] [bp-A1h]@7
  __int16 v315; // [sp+11Ch] [bp-A0h]@7
  char v316; // [sp+120h] [bp-9Ch]@7
  char v317; // [sp+128h] [bp-94h]@20
  char v318; // [sp+129h] [bp-93h]@9
  char v319; // [sp+144h] [bp-78h]@11
  char v320; // [sp+158h] [bp-64h]@11
  char v321; // [sp+15Ch] [bp-60h]@11
  char v322; // [sp+15Eh] [bp-5Eh]@11
  char v323; // [sp+163h] [bp-59h]@41
  char v324[20]; // [sp+164h] [bp-58h]@18
  char v325[20]; // [sp+177h] [bp-45h]@27
  char v326[20]; // [sp+178h] [bp-44h]@26
  char v327; // [sp+18Ch] [bp-30h]@27
  char v328; // [sp+1A0h] [bp-1Ch]@71
  char v329; // [sp+1A8h] [bp-14h]@71
  char v330; // [sp+1B0h] [bp-Ch]@71

  v5 = a1;
  v6 = *(_BYTE *)(a1 + 1);
  v274 = a5;
  v7 = *(_BYTE *)a1;
  v273 = a1;
  sub_100184C0(v7, v6, &v291);
  v8 = *(_BYTE *)(v5 + 1);
  v275 = v292;
  v307 = 24;
  if ( v8 )
  {
    sub_100184C0(*(_BYTE *)v5, v8 - 1, &v307);
    v285 = v308;
  }
  sub_10018E40(*(_BYTE *)v5, *(_BYTE *)(v5 + 1), &v300, &v287);
  v9 = sub_100061E0();
  v10 = sub_10005A70(v9);
  v11 = *(_BYTE *)(v5 + 1);
  v12 = *(_BYTE *)v5;
  v13 = sub_100061E0();
  sub_10018930(a3, v13, v12, v11, v10, (int)&v301);
  if ( 9.9999996e24 == v287 )
    v287 = 0.0;
  v272 = v287 - *(float *)&v301;
  v287 = sub_10047770(v272);
  v272 = COERCE_FLOAT(sub_10047840(v287));
  if ( v272 == 0.0 )
    LODWORD(v272) = 360;
  v14 = sub_10015380(*(_DWORD *)(v5 + 4));
  v15 = *(_DWORD *)(v5 + 4);
  v282 = v14;
  sub_10015AD0(v15, 0);
  sub_10015310(*(_DWORD *)(v5 + 4));
  v16 = *(_DWORD *)sub_10015340(*(_DWORD *)(v5 + 4));
  v17 = *(_DWORD *)(v5 + 4) & 0xFFFF3FFF;
  v312 = 0;
  v314 = 0;
  v315 = 0;
  v305 = 0;
  v279 = 0;
  v311 = v17;
  v303 = v17;
  v281 = v16;
  v276 = 58;
  v270 = 41;
  v271 = 20;
  v286 = 63;
  v310 = 89;
  v313 = 6;
  v302 = 106;
  v304 = 47;
  v277 = 105;
  v280 = 10;
  v278 = v17 | 0x400000;
  sub_10005F90((int)&v316);
  if ( *(_BYTE *)v5 )
  {
LABEL_35:
    result = v291;
    goto LABEL_36;
  }
  if ( *(_BYTE *)(v5 + 2) && v318 == 3 && (v19 = sub_10009C40(), sub_10009FE0(*(_BYTE *)v5, v19) == 16745216) )
  {
    sub_10016430((float *)&v319, &v321, &v296, &v297, (bool *)&v322, &v320, &v294);
    result = 13;
    v21 = (v275 ^ (v322 == 0)) & 7;
    LOBYTE(v18) = v21 ^ v275;
    v291 = 13;
    v275 ^= v21;
  }
  else
  {
    result = v291;
  }
  if ( !*(_BYTE *)v5 && *(_BYTE *)(v5 + 2) )
  {
    LOBYTE(v18) = v318;
    if ( v318 == 2 )
    {
LABEL_18:
      v23 = sub_10005B00();
      sub_10016730(v23, v324);
      if ( v318 == 2 )
      {
        LOBYTE(v24) = *(_BYTE *)(v5 + 1);
        LOBYTE(v25) = *(_BYTE *)v5;
        sub_1000CDD0(v24, v25, (int)v324);
      }
      sub_1000CE50(*(_BYTE *)(v5 + 1), (int)v324, *(_BYTE *)v5);
      if ( v317 == 1 )
      {
        sub_10009CD0(&v288);
        if ( 9.9999996e24 == v288 )
          v288 = 0.0;
        v26 = sub_10047840(v288);
        if ( !v26 )
          v26 = 360;
        v27 = 0;
        do
        {
          v28 = byte_10069D84[v27];
          v326[v27++] = v28;
        }
        while ( v28 );
        sprintf(&v327, "%03i", v26);
        v29 = strlen(&v327) + 1;
        v30 = v325;
        do
          v31 = (v30++)[1];
        while ( v31 );
        qmemcpy(v30, &v327, v29);
        v32 = sub_10021080(0x28u, 0);
        v33 = v32;
        do
          v34 = *v32++;
        while ( v34 );
        v35 = v32 - v33;
        v36 = v325;
        do
          v37 = (v36++)[1];
        while ( v37 );
        qmemcpy(v36, v33, v35);
        v38 = sub_10007120(v281, v324, v282);
        v39 = sub_10007120(v281, v326, v282);
        sub_1000CEB0(*(_DWORD *)(v273 + 4), v39 + v38 + v271 + 20, &v269, (_DWORD *)v274);
        sub_10012950(a4, (int)&v277, (int)&v269, v326, (int)a2);
        LOWORD(v269) = v39 + v271 + 5 + v269;
        sub_10011400(a4, (int)&v276, (int)&v269, &v270, a2);
        LOWORD(v269) = v269 + 15;
        v40 = v324;
        return sub_10012950(a4, (int)&v277, (int)&v269, v40, (int)a2);
      }
      v137 = sub_10007120(v16, v324, v282);
LABEL_117:
      sub_1000CEB0(*(_DWORD *)(v5 + 4), v137 + 30, &v269, (_DWORD *)v274);
      v138 = v274;
      v139 = *(_WORD *)(v16 + 24) - *(_WORD *)(v16 + 26) + 15;
      HIWORD(v269) = *(_WORD *)(v274 + 2) - (((signed int)v139 - HIDWORD(v139)) >> 1);
      v283 = 46;
      sub_10015170(a4, (int)&v286, (int)&v269, (unsigned __int16 *)&v283, a2);
      v140 = *(_WORD *)(v138 + 2);
      LOWORD(v269) = v269 + 30;
      HIWORD(v269) = v140;
      return sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
    }
    if ( v318 == 3 )
    {
      v22 = sub_10009C40();
      if ( sub_10009FE0(*(_BYTE *)v5, v22) != 16745216 )
        goto LABEL_18;
      goto LABEL_35;
    }
  }
LABEL_36:
  if ( result == 15 )
  {
    sub_10016730(v309, v324);
    LOBYTE(v41) = *(_BYTE *)v5;
    v42 = v324;
    LOBYTE(v42) = *(_BYTE *)(v5 + 1) - 1;
    sub_1000CDD0((int)v42, v41, (int)v324);
    v43 = sub_10007120(v16, v324, v282);
    sub_1000CEB0(*(_DWORD *)(v5 + 4), v43 + v271 + 52, &v269, (_DWORD *)v274);
    sub_10012950(a4, (int)&v277, v44, v324, (int)a2);
    LOWORD(v269) = v43 + v271 + 5 + v269;
    sub_10011400(a4, (int)&v276, (int)&v269, &v270, a2);
    LOWORD(v269) = v269 + 15;
    return sub_1000CEE0(*(_DWORD *)(v5 + 4), a4, (int)&v269, (v275 & 7) == 1);
  }
  if ( v307 == 15 )
  {
    sub_10016730(v294, v324);
    LOBYTE(v45) = *(_BYTE *)(v5 + 1);
    LOBYTE(v46) = *(_BYTE *)v5;
    sub_1000CDD0(v45, v46, (int)v324);
    v47 = sub_10007120(v16, v324, v282);
    v48 = *(_DWORD *)(v5 + 4);
    sub_1000CEB0(v48, v47 + 75, &v269, (_DWORD *)v274);
    sub_1000CEE0(v48, a4, (int)&v269, (v285 & 7) == 1);
    LOWORD(v269) = v269 + 60;
    sub_10011400(a4, (int)&v276, (int)&v269, &v270, a2);
    LOWORD(v269) = v269 + 15;
    return sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
  }
  if ( !result )
  {
    sub_10016730(v295, v324);
    v272 = v296 * 0.0005399568034557236;
    sprintf(v326, "%3.1f", v272);
    v49 = strlen(v326) + 1;
    v50 = &v323;
    do
      v51 = (v50++)[1];
    while ( v51 );
    qmemcpy(v50, v326, v49);
    v283 = ((v275 & 7) != 1) + 44;
    sub_10016730(v294, v326);
    LOBYTE(v52) = *(_BYTE *)(v273 + 1);
    LOBYTE(v53) = *(_BYTE *)v273;
    sub_1000CDD0(v52, v53, (int)v326);
    if ( *(_BYTE *)(v273 + 3) )
      sub_1000CE50(*(_BYTE *)(v273 + 1), (int)v326, *(_BYTE *)v273);
    v54 = v281;
    v55 = sub_10007120(v281, v324, v282);
    v56 = sub_10007120(v281, v326, v282);
    sub_1000CEB0(*(_DWORD *)(v273 + 4), v56 + v55 + 35, &v269, (_DWORD *)v274);
    sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
    LOWORD(v269) = v55 + 5 + v269;
    v57 = v274;
    HIWORD(v269) = *(_WORD *)(v274 + 2) - *(_WORD *)(v54 + 24) + 4;
    sub_10015170(a4, (int)&v286, (int)&v269, (unsigned __int16 *)&v283, a2);
    v58 = *(_WORD *)(v57 + 2);
    LOWORD(v269) = v269 + 30;
    HIWORD(v269) = v58;
    goto LABEL_222;
  }
  if ( result == 1 )
  {
    v59 = 0;
    do
    {
      v60 = byte_10069D50[v59];
      v324[v59++] = v60;
    }
    while ( v60 );
    sprintf(v326, "%03i", v272);
    v61 = strlen(v326) + 1;
    v62 = &v323;
    do
      v63 = (v62++)[1];
    while ( v63 );
    qmemcpy(v62, v326, v61);
    v64 = sub_10021080(0x28u, 0);
    v65 = v64;
    do
      v66 = *v64++;
    while ( v66 );
    v67 = v64 - v65;
    v68 = &v323;
    do
      v69 = (v68++)[1];
    while ( v69 );
    qmemcpy(v68, v65, v67);
    v70 = 0;
    do
    {
      v71 = byte_10069D5C[v70];
      v326[v70++] = v71;
    }
    while ( v71 );
    v72 = sub_10007120(v281, v324, v282);
    v73 = sub_10007120(v281, v326, v282);
    sub_1000CEB0(*(_DWORD *)(v273 + 4), v72 + v73 + v271 + 20, &v269, (_DWORD *)v274);
    sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
    LOWORD(v269) = v72 + v271 + 5 + v269;
    sub_10011400(a4, (int)&v276, (int)&v269, &v270, a2);
    LOWORD(v269) = v269 + 15;
    return sub_100140D0(a4, (int)&v310, &v269, (float *)&v293, (int)a2);
  }
  if ( result == 2 )
  {
    v74 = 0;
    do
    {
      v75 = byte_10069D50[v74];
      v324[v74++] = v75;
    }
    while ( v75 );
    sprintf(v326, "%03i", v272);
    v76 = strlen(v326) + 1;
    v77 = &v323;
    do
      v78 = (v77++)[1];
    while ( v78 );
    qmemcpy(v77, v326, v76);
    v79 = sub_10021080(0x28u, 0);
    v80 = v79;
    do
      v81 = *v79++;
    while ( v81 );
    v82 = v79 - v80;
    v83 = &v323;
    do
      v84 = (v83++)[1];
    while ( v84 );
    qmemcpy(v83, v80, v82);
    sub_10016730(LODWORD(v296), v326);
    v272 = v297 * 0.0005399568034557236;
    sprintf(&v327, "%.1f", v272);
    v85 = &v327;
    v86 = strlen(&v327) + 1;
    v87 = v325;
    do
      v88 = (v87++)[1];
    while ( v88 );
LABEL_179:
    qmemcpy(v87, v85, v86);
    v104 = sub_10007120(v281, v324, v282);
    v199 = v104 + sub_10007120(v281, v326, v282) + v271 + 20;
    sub_1000CEB0(*(_DWORD *)(v273 + 4), v199, &v269, (_DWORD *)v274);
LABEL_220:
    sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
    v163 = v104 + v271 + 5;
LABEL_221:
    LOWORD(v269) = v163 + v269;
    sub_10011400(a4, (int)&v276, (int)&v269, &v270, a2);
    LOWORD(v269) = v269 + 15;
LABEL_222:
    v40 = v326;
    return sub_10012950(a4, (int)&v277, (int)&v269, v40, (int)a2);
  }
  if ( result == 3 )
  {
    sub_10018DF0(*(_BYTE *)v5, (int)&v329, &v290, &v284, (int)&v330, (int)&v328, (float *)&v306);
    if ( v284 != -1 || sub_10018330(*(_BYTE *)v5, *(_BYTE *)(v5 + 1)) != 2 )
    {
      v91 = 0;
      do
      {
        v92 = byte_10069D50[v91];
        v324[v91++] = v92;
      }
      while ( v92 );
    }
    else
    {
      v89 = 0;
      do
      {
        v90 = byte_10069D94[v89];
        v324[v89++] = v90;
      }
      while ( v90 );
    }
    sprintf(v326, "%03i", v272);
    v93 = strlen(v326) + 1;
    v94 = &v323;
    do
      v95 = (v94++)[1];
    while ( v95 );
    qmemcpy(v94, v326, v93);
    v96 = sub_10021080(0x28u, 0);
    v97 = v96;
    do
      v98 = *v96++;
    while ( v98 );
    v99 = v96 - v97;
    v100 = &v323;
    do
      v101 = (v100++)[1];
    while ( v101 );
    qmemcpy(v100, v97, v99);
    sub_10016730(v294, v326);
    LOBYTE(v102) = *(_BYTE *)(v273 + 1);
    v103 = v326;
    LOBYTE(v103) = *(_BYTE *)v273;
    sub_1000CDD0(v102, v103, (int)v326);
    if ( *(_BYTE *)(v273 + 3) )
      sub_1000CE50(*(_BYTE *)(v273 + 1), (int)v326, *(_BYTE *)v273);
    v104 = sub_10007120(v281, v324, v282);
    v240 = sub_10007120(v281, v326, v282);
    goto LABEL_219;
  }
  if ( result == 4 )
  {
    v105 = 0;
    do
    {
      v106 = byte_10069D50[v105];
      v324[v105++] = v106;
    }
    while ( v106 );
    sprintf(v326, "%03i", v272);
    v107 = strlen(v326) + 1;
    v108 = &v323;
    do
      v109 = (v108++)[1];
    while ( v109 );
    qmemcpy(v108, v326, v107);
    v110 = sub_10021080(0x28u, 0);
    v111 = v110;
    do
      v112 = *v110++;
    while ( v112 );
    v113 = v110 - v111;
    v114 = &v323;
    do
      v115 = (v114++)[1];
    while ( v115 );
    qmemcpy(v114, v111, v113);
    v116 = 0;
    do
    {
      v117 = byte_10069D74[v116];
      v326[v116++] = v117;
    }
    while ( v117 );
    v104 = sub_10007120(v281, v324, v282);
    v268 = v282;
    goto LABEL_218;
  }
  if ( result == 5 )
  {
    v118 = 0;
    do
    {
      v119 = byte_10069D50[v118];
      v324[v118++] = v119;
    }
    while ( v119 );
    sprintf(v326, "%03i", v272);
    v120 = strlen(v326) + 1;
    v121 = &v323;
    do
      v122 = (v121++)[1];
    while ( v122 );
    qmemcpy(v121, v326, v120);
    v123 = sub_10021080(0x28u, 0);
    v124 = v123;
    do
      v125 = *v123++;
    while ( v125 );
    v126 = v123 - v124;
    v127 = &v323;
    do
      v128 = (v127++)[1];
    while ( v128 );
    qmemcpy(v127, v124, v126);
    sub_10016730(LODWORD(v296), v326);
    v298 = v297;
    v129 = sub_1001B280(v296);
    v272 = v298 - v129;
    v130 = sub_10047840(v272);
    if ( !v130 )
      v130 = 360;
    sprintf(&v327, "%03i", v130);
    v131 = &v327;
    v132 = strlen(&v327) + 1;
    v133 = v325;
    do
      v134 = (v133++)[1];
    while ( v134 );
LABEL_217:
    qmemcpy(v133, v131, v132);
    v104 = sub_10007120(v281, v324, v282);
    v268 = v282;
LABEL_218:
    v240 = sub_10007120(v281, v326, v268);
LABEL_219:
    sub_1000CEB0(*(_DWORD *)(v273 + 4), v104 + v240 + v271 + 20, &v269, (_DWORD *)v274);
    goto LABEL_220;
  }
  if ( result == 6 )
  {
    sub_10016730(v294, v324);
    LOBYTE(v135) = *(_BYTE *)(v5 + 1);
    LOBYTE(v136) = *(_BYTE *)v5;
    sub_1000CDD0(v135, v136, (int)v324);
    if ( *(_BYTE *)(v5 + 3) )
      sub_1000CE50(*(_BYTE *)(v5 + 1), (int)v324, *(_BYTE *)v5);
    v137 = sub_10007120(v16, v324, v282);
    goto LABEL_117;
  }
  if ( result == 7 )
  {
    sub_10016730(v294, v324);
    LOBYTE(v141) = *(_BYTE *)v5;
    v142 = v324;
    LOBYTE(v142) = *(_BYTE *)(v5 + 1) - 1;
    sub_1000CDD0((int)v142, v141, (int)v324);
    if ( *(_BYTE *)(v5 + 3) )
      sub_1000CE50(*(_BYTE *)(v5 + 1) - 1, (int)v324, *(_BYTE *)v5);
    v143 = 0;
    do
    {
      v144 = byte_10069D5C[v143];
      v326[v143++] = v144;
    }
    while ( v144 );
    v273 = sub_10007120(v16, v324, v282);
    v145 = sub_10007120(v16, v326, v282);
    v146 = v273;
    sub_1000CEB0(*(_DWORD *)(v5 + 4), v273 + v145 + v271 + 20, &v269, (_DWORD *)v274);
    sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
    LOWORD(v269) = v146 + v271 + 5 + v269;
    HIWORD(v269) = *(_WORD *)(v274 + 2);
    sub_10011400(a4, (int)&v276, (int)&v269, &v270, a2);
    LOWORD(v269) = v269 + 15;
    return sub_100140D0(a4, (int)&v310, &v269, (float *)&v293, (int)a2);
  }
  if ( result == 8 )
  {
    sub_10016730(v294, v324);
    v147 = v324;
    LOBYTE(v147) = *(_BYTE *)v5;
    LOBYTE(v148) = *(_BYTE *)(v5 + 1) - 1;
    sub_1000CDD0(v148, v147, (int)v324);
    if ( *(_BYTE *)(v5 + 3) )
      sub_1000CE50(*(_BYTE *)(v5 + 1) - 1, (int)v324, *(_BYTE *)v5);
    v149 = 0;
    do
    {
      v150 = byte_10069D58[v149];
      v326[v149++] = v150;
    }
    while ( v150 );
    v272 = v296 * 0.0005399568034557236;
    sprintf(&v327, "%3.1f", v272);
    v151 = strlen(&v327) + 1;
    v152 = v325;
    do
      v153 = (v152++)[1];
    while ( v153 );
    qmemcpy(v152, &v327, v151);
    v104 = sub_10007120(v281, v324, v282);
    v240 = sub_10007120(v281, v326, v282);
    goto LABEL_219;
  }
  if ( result == 9 )
  {
    sub_10016730(v294, v324);
    LOBYTE(v154) = *(_BYTE *)v5;
    LOBYTE(v155) = *(_BYTE *)(v5 + 1) - 1;
    sub_1000CDD0(v155, v154, (int)v324);
    if ( *(_BYTE *)(v5 + 3) )
      sub_1000CE50(*(_BYTE *)(v5 + 1) - 1, (int)v324, *(_BYTE *)v5);
    sub_10016730(LODWORD(v296), v326);
    v272 = v297 * 0.0005399568034557236;
    sprintf(&v327, "%.1f", v272);
    v85 = &v327;
    v86 = strlen(&v327) + 1;
    v87 = v325;
    do
      v156 = (v87++)[1];
    while ( v156 );
    goto LABEL_179;
  }
  if ( result == 10 )
  {
    sub_10016730(v294, v324);
    LOBYTE(v157) = *(_BYTE *)v5;
    LOBYTE(v158) = *(_BYTE *)(v5 + 1) - 1;
    sub_1000CDD0(v158, v157, (int)v324);
    if ( *(_BYTE *)(v5 + 3) )
      sub_1000CE50(*(_BYTE *)(v5 + 1) - 1, (int)v324, *(_BYTE *)v5);
    v159 = 0;
    do
    {
      v160 = byte_10069D7C[v159];
      v326[v159++] = v160;
    }
    while ( v160 );
    v273 = sub_10007120(v16, v324, v282);
    v161 = sub_10007120(v16, v326, v282);
    v162 = v273;
    sub_1000CEB0(*(_DWORD *)(v5 + 4), v273 + v161 + v271 + 20, &v269, (_DWORD *)v274);
    sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
    v163 = v162 + v271 + 5;
    goto LABEL_221;
  }
  if ( result == 11 || result == 12 || result == 13 )
  {
    if ( !*(_BYTE *)v5 )
    {
      LOBYTE(v18) = *(_BYTE *)(v5 + 1);
      if ( (_BYTE)v18 == v316 )
      {
        if ( *(_BYTE *)(v5 + 2) )
        {
          if ( !LOBYTE(v296) )
            goto LABEL_242;
          if ( sub_10009C60(&v289) )
          {
            v299 = v289;
LABEL_243:
            if ( LOBYTE(v296) )
            {
              v253 = sub_10007120(v16, "00:00", v282);
            }
            else
            {
              v254 = sub_1001D250(v18);
              v255 = v297;
              if ( v254 == 30 )
              {
                v272 = v255 * 0.0005399568034557236;
                sprintf(v324, "%.1f", v272);
                v256 = &v323;
                do
                  v257 = (v256++)[1];
                while ( v257 );
                *(_WORD *)v256 = 136;
              }
              else
              {
                v272 = v255 * 0.001;
                sprintf(v324, "%.1f", v272);
                v258 = &v323;
                do
                  v259 = (v258++)[1];
                while ( v259 );
                *(_WORD *)v258 = 130;
              }
              v253 = sub_10007120(v281, v324, v282);
              v16 = v281;
            }
            v273 = v253;
            sub_10016730(v294, v326);
            LOBYTE(v260) = *(_BYTE *)v5;
            LOBYTE(v261) = *(_BYTE *)(v5 + 1) - 1;
            sub_1000CDD0(v261, v260, (int)v326);
            LODWORD(v298) = sub_10007120(v16, v326, v282);
            LODWORD(v272) = (unsigned __int16)(v273 + LOWORD(v298) + 45);
            if ( v291 == 11 )
              LODWORD(v272) += sub_10007120(v16, "00000", v282);
            sub_1000CEB0(*(_DWORD *)(v5 + 4), SLOWORD(v272), &v269, (_DWORD *)v274);
            if ( LOBYTE(v296) )
              sub_1000C2D0(a4, (int)&v302, v262, &v299, (int)a2);
            else
              sub_10012950(a4, (int)&v277, (int)v262, v324, (int)a2);
            LOWORD(v269) = v273 + 5 + v269;
            v283 = ((v275 & 7) != 1) + 48;
            if ( v291 == 11 )
            {
              sub_10012950(a4, (int)&v277, (int)&v269, v326, (int)a2);
              v263 = v274;
              v264 = *(_WORD *)(v274 + 2);
              LOWORD(v269) = LOWORD(v298) + 5 + v269;
              HIWORD(v269) = v264 - *(_WORD *)(v16 + 24) + 4;
              sub_10015170(a4, (int)&v286, (int)&v269, (unsigned __int16 *)&v283, a2);
              v265 = *(_WORD *)(v263 + 2);
              LOWORD(v269) = v269 + 40;
              HIWORD(v269) = v265;
              v313 = 5;
              result = sub_100140D0(a4, (int)&v310, &v269, (float *)&v293, (int)a2);
            }
            else
            {
              v266 = v274;
              HIWORD(v269) = *(_WORD *)(v274 + 2) - *(_WORD *)(v16 + 24) + 4;
              sub_10015170(a4, (int)&v286, (int)&v269, (unsigned __int16 *)&v283, a2);
              v267 = *(_WORD *)(v266 + 2);
              LOWORD(v269) = v269 + 40;
              HIWORD(v269) = v267;
              result = sub_10012950(a4, (int)&v277, (int)&v269, v326, (int)a2);
            }
            return result;
          }
        }
      }
    }
    if ( LOBYTE(v296) )
    {
      v299 = sub_100477D0(v297);
      goto LABEL_243;
    }
LABEL_242:
    v300 = v297;
    goto LABEL_243;
  }
  if ( result == 14 || result == 17 )
  {
    if ( *(_BYTE *)(v5 + 1) )
    {
      sub_10016730(v309, v324);
      v246 = v324;
      LOBYTE(v246) = *(_BYTE *)v5;
      LOBYTE(v247) = *(_BYTE *)(v5 + 1) - 1;
      sub_1000CDD0(v247, v246, (int)v324);
      if ( *(_BYTE *)(v5 + 3) )
        sub_1000CE50(*(_BYTE *)(v5 + 1) - 1, (int)v324, *(_BYTE *)v5);
      sub_10016730(v294, v326);
      LOBYTE(v248) = *(_BYTE *)(v5 + 1);
      LOBYTE(v249) = *(_BYTE *)v5;
      sub_1000CDD0(v248, v249, (int)v326);
      if ( *(_BYTE *)(v5 + 3) )
        sub_1000CE50(*(_BYTE *)(v5 + 1), (int)v326, *(_BYTE *)v5);
      v273 = sub_10007120(v16, v324, v282);
      v250 = sub_10007120(v16, v326, v282);
      v251 = v273;
      sub_1000CEB0(*(_DWORD *)(v5 + 4), v273 + v250 + v271 + 20, &v269, (_DWORD *)v274);
      sub_10012950(a4, (int)&v277, v252, v324, (int)a2);
      LOWORD(v269) = v251 + v271 + 5 + v269;
      sub_10011400(a4, (int)&v276, (int)&v269, &v270, a2);
      LOWORD(v269) = v269 + 15;
      result = sub_10012950(a4, (int)&v277, (int)&v269, v326, (int)a2);
    }
    else
    {
      sub_10016730(v294, v324);
      LOBYTE(v241) = *(_BYTE *)(v5 + 1);
      LOBYTE(v242) = *(_BYTE *)v5;
      sub_1000CDD0(v241, v242, (int)v324);
      if ( *(_BYTE *)(v5 + 3) )
        sub_1000CE50(*(_BYTE *)(v5 + 1), (int)v324, *(_BYTE *)v5);
      v243 = sub_10007120(v16, v324, v282);
      v244 = v271;
      sub_1000CEB0(*(_DWORD *)(v5 + 4), v243 + v271 + 20, &v269, (_DWORD *)v274);
      LOWORD(v269) = v244 + 5 + v269;
      sub_10011400(a4, (int)&v276, v245, &v270, a2);
      LOWORD(v269) = v269 + 15;
      result = sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
    }
  }
  else if ( result == 16 )
  {
    sub_10016730(v309, v324);
    LOBYTE(v164) = *(_BYTE *)v5;
    LOBYTE(v165) = *(_BYTE *)(v5 + 1) - 1;
    sub_1000CDD0(v165, v164, (int)v324);
    if ( *(_BYTE *)(v5 + 3) )
      sub_1000CE50(*(_BYTE *)(v5 + 1) - 1, (int)v324, *(_BYTE *)v5);
    sub_10016730(v294, v326);
    LOBYTE(v166) = *(_BYTE *)(v5 + 1);
    v167 = v326;
    LOBYTE(v167) = *(_BYTE *)v5;
    sub_1000CDD0(v166, v167, (int)v326);
    if ( *(_BYTE *)(v5 + 3) )
      sub_1000CE50(*(_BYTE *)(v5 + 1), (int)v326, *(_BYTE *)v5);
    v273 = sub_10007120(v16, v324, v282);
    v168 = sub_10007120(v16, v326, v282);
    sub_1000CEB0(*(_DWORD *)(v5 + 4), v168 + v273 + 35, &v269, (_DWORD *)v274);
    sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
    v169 = v274;
    v170 = *(_WORD *)(v274 + 2);
    LOWORD(v269) = v273 + 5 + v269;
    v283 = ((v275 & 7) != 1) + 44;
    HIWORD(v269) = v170 - *(_WORD *)(v16 + 24) + 4;
    sub_10015170(a4, (int)&v286, (int)&v269, (unsigned __int16 *)&v283, a2);
    v171 = *(_WORD *)(v169 + 2);
    LOWORD(v269) = v269 + 30;
    HIWORD(v269) = v171;
    result = sub_10012950(a4, (int)&v277, (int)&v269, v326, (int)a2);
  }
  else
  {
    if ( result != 18 )
    {
      if ( result == 19 )
      {
        v187 = 0;
        do
        {
          v188 = byte_10069D6C[v187];
          v324[v187++] = v188;
        }
        while ( v188 );
        sprintf(v326, "%03i", v272);
        v189 = strlen(v326) + 1;
        v190 = &v323;
        do
          v191 = (v190++)[1];
        while ( v191 );
        qmemcpy(v190, v326, v189);
        v192 = sub_10021080(0x28u, 0);
        v193 = v192;
        do
          v194 = *v192++;
        while ( v194 );
        v195 = v192 - v193;
        v196 = &v323;
        do
          v197 = (v196++)[1];
        while ( v197 );
        qmemcpy(v196, v193, v195);
        sub_10016730(LODWORD(v296), v326);
        v272 = v297 * 0.0005399568034557236;
        sprintf(&v327, "%.1f", v272);
        v85 = &v327;
        v86 = strlen(&v327) + 1;
        v87 = v325;
        do
          v198 = (v87++)[1];
        while ( v198 );
        goto LABEL_179;
      }
      if ( result == 20 )
      {
        v200 = 0;
        do
        {
          v201 = byte_10069D6C[v200];
          v324[v200++] = v201;
        }
        while ( v201 );
        sprintf(v326, "%03i", v272);
        v202 = strlen(v326) + 1;
        v203 = &v323;
        do
          v204 = (v203++)[1];
        while ( v204 );
        qmemcpy(v203, v326, v202);
        v205 = sub_10021080(0x28u, 0);
        v206 = v205;
        do
          v207 = *v205++;
        while ( v207 );
        v208 = v205 - v206;
        v209 = &v323;
        do
          v210 = (v209++)[1];
        while ( v210 );
        qmemcpy(v209, v206, v208);
        v211 = 0;
        do
        {
          v212 = byte_10069D74[v211];
          v326[v211++] = v212;
        }
        while ( v212 );
        v104 = sub_10007120(v281, v324, v282);
        v268 = v282;
        goto LABEL_218;
      }
      if ( result == 21 )
      {
        v213 = 0;
        do
        {
          v214 = byte_10069D6C[v213];
          v324[v213++] = v214;
        }
        while ( v214 );
        sprintf(v326, "%03i", v272);
        v215 = strlen(v326) + 1;
        v216 = &v323;
        do
          v217 = (v216++)[1];
        while ( v217 );
        qmemcpy(v216, v326, v215);
        v218 = sub_10021080(0x28u, 0);
        v219 = v218;
        do
          v220 = *v218++;
        while ( v220 );
        v221 = v218 - v219;
        v222 = &v323;
        do
          v223 = (v222++)[1];
        while ( v223 );
        qmemcpy(v222, v219, v221);
        v224 = 0;
        do
        {
          v225 = byte_10069D7C[v224];
          v326[v224++] = v225;
        }
        while ( v225 );
        v104 = sub_10007120(v281, v324, v282);
        v268 = v282;
        goto LABEL_218;
      }
      if ( result != 22 )
        return result;
      v226 = 0;
      do
      {
        v227 = byte_10069D6C[v226];
        v324[v226++] = v227;
      }
      while ( v227 );
      sprintf(v326, "%03i", v272);
      v228 = strlen(v326) + 1;
      v229 = &v323;
      do
        v230 = (v229++)[1];
      while ( v230 );
      qmemcpy(v229, v326, v228);
      v231 = sub_10021080(0x28u, 0);
      v232 = v231;
      do
        v233 = *v231++;
      while ( v233 );
      v234 = v231 - v232;
      v235 = &v323;
      do
        v236 = (v235++)[1];
      while ( v236 );
      qmemcpy(v235, v232, v234);
      sub_10016730(LODWORD(v296), v326);
      v298 = v297;
      v237 = sub_1001B280(v296);
      v272 = v298 - v237;
      v238 = sub_10047840(v272);
      if ( !v238 )
        v238 = 360;
      sprintf(&v327, "%03i", v238);
      v131 = &v327;
      v132 = strlen(&v327) + 1;
      v133 = v325;
      do
        v239 = (v133++)[1];
      while ( v239 );
      goto LABEL_217;
    }
    v172 = 0;
    do
    {
      v173 = byte_10069D6C[v172];
      v324[v172++] = v173;
    }
    while ( v173 );
    sprintf(v326, "%03i", v272);
    v174 = strlen(v326) + 1;
    v175 = &v323;
    do
      v176 = (v175++)[1];
    while ( v176 );
    qmemcpy(v175, v326, v174);
    v177 = sub_10021080(0x28u, 0);
    v178 = v177;
    do
      v179 = *v177++;
    while ( v179 );
    v180 = v177 - v178;
    v181 = &v323;
    do
      v182 = (v181++)[1];
    while ( v182 );
    qmemcpy(v181, v178, v180);
    v183 = 0;
    do
    {
      v184 = byte_10069D5C[v183];
      v326[v183++] = v184;
    }
    while ( v184 );
    v185 = sub_10007120(v281, v324, v282);
    v186 = sub_10007120(v281, v326, v282);
    sub_1000CEB0(*(_DWORD *)(v273 + 4), v185 + v186 + v271 + 20, &v269, (_DWORD *)v274);
    sub_10012950(a4, (int)&v277, (int)&v269, v324, (int)a2);
    LOWORD(v269) = v185 + v271 + 5 + v269;
    sub_10011400(a4, (int)&v276, (int)&v269, &v270, a2);
    LOWORD(v269) = v269 + 15;
    result = sub_100140D0(a4, (int)&v310, &v269, (float *)&v293, (int)a2);
  }
  return result;
}
// 1000D020: using guessed type char var_58[20];
// 1000D020: using guessed type char var_44[20];

//----- (1000F1F0) --------------------------------------------------------
char __usercall sub_1000F1F0@<al>(int a1@<edi>, int a2, int a3, int a4, int a5, _WORD *a6)
{
  char result; // al@1

  result = 1;
  if ( *a6 == 32802 )
    goto LABEL_9;
  if ( *a6 == 32833 )
  {
    *(_BYTE *)(a5 + 3) = 1;
    return 2;
  }
  if ( *a6 == 32888 )
  {
LABEL_9:
    sub_1000D020(a5, a6, a1, a2, a4);
    result = 2;
  }
  return result;
}

//----- (1000F240) --------------------------------------------------------
char __usercall sub_1000F240@<al>(char a1@<bl>)
{
  char result; // al@6

  if ( a1 == 2 || sub_10009F20() == 1 && (a1 == 1 || a1 == 4 || a1 == 3) )
    result = 39;
  else
    result = -1;
  return result;
}

//----- (1000F270) --------------------------------------------------------
char __usercall sub_1000F270@<al>(int a1@<eax>)
{
  unsigned int v1; // eax@1
  char v2; // cl@1
  char result; // al@1

  v1 = *(_DWORD *)(a1 + 4);
  flt_1010FB6C = -1.0;
  dword_1010FB70 = v1;
  v2 = (v1 >> 5) & 0x1F;
  result = v1 & 0x1F;
  byte_1010FB69 = v2;
  unk_1010FB6A = result;
  byte_1010FB68 = 0;
  return result;
}
// 1010FB68: using guessed type char byte_1010FB68;
// 1010FB69: using guessed type char byte_1010FB69;
// 1010FB6C: using guessed type float flt_1010FB6C;
// 1010FB70: using guessed type int dword_1010FB70;

//----- (1000F2B0) --------------------------------------------------------
int __usercall sub_1000F2B0@<eax>(_DWORD *a1@<esi>, float a2)
{
  int result; // eax@1

  result = sub_10047840(a2);
  *a1 = result;
  if ( !result )
    *a1 = 360;
  return result;
}

//----- (1000F2D0) --------------------------------------------------------
char __cdecl sub_1000F2D0(char a1, const void **a2)
{
  char v2; // al@1
  unsigned __int8 v3; // bl@1
  char *v4; // eax@3
  char v6; // [sp+8h] [bp-40h]@1
  char v7; // [sp+Ch] [bp-3Ch]@4

  v2 = sub_10009C40();
  v3 = v2;
  v6 = v2;
  if ( a1 != 8 )
  {
    v3 = v2 + 1;
    v6 = v2 + 1;
  }
  LOBYTE(v4) = sub_10019280(0);
  if ( v3 < (unsigned __int8)v4 )
  {
    LOBYTE(v4) = sub_100184C0(0, v6, &v7);
    if ( !memcmp(*a2, "Next DTK", 9u) )
    {
      LOBYTE(v4) = v7;
      if ( v7 == 18 || v7 == 19 || v7 == 20 || v7 == 21 || v7 == 22 )
      {
        v4 = sub_1001FFA0(0x12CCu);
        *a2 = v4;
      }
    }
  }
  return (unsigned int)v4;
}

//----- (1000F360) --------------------------------------------------------
unsigned int sub_1000F360()
{
  int v0; // ecx@1
  unsigned int result; // eax@1

  v0 = unk_1010FB6A & 0x1F;
  result = v0 | (dword_1010FB70 | 32 * (byte_1010FB69 & 0x1F)) & 0xFFFFFFE0;
  dword_1010FB70 = v0 | (dword_1010FB70 | 32 * (byte_1010FB69 & 0x1F)) & 0xFFFFFFE0;
  return result;
}
// 1010FB69: using guessed type char byte_1010FB69;
// 1010FB70: using guessed type int dword_1010FB70;

//----- (1000F390) --------------------------------------------------------
char __usercall sub_1000F390@<al>(int a1@<eax>, int a2@<ecx>, char *a3@<edi>)
{
  int v3; // esi@1
  unsigned __int8 v4; // al@2
  char v5; // bl@2
  char *v6; // eax@4
  char *v7; // edx@4
  char v8; // cl@5
  char result; // al@9
  char v10; // al@10
  char v11; // bl@10
  int v12; // eax@11
  double v13; // st7@12
  char *v14; // eax@17
  char *v15; // eax@22
  char *v16; // esi@24
  int v17; // eax@25
  char *v18; // ebp@30
  int v19; // eax@31
  int v20; // esi@33
  int v21; // eax@35
  double v22; // st7@36
  char *v23; // eax@43
  char *v24; // edx@43
  char v25; // cl@44
  char v26; // [sp-8h] [bp-2Ch]@17
  const void **v27; // [sp-4h] [bp-28h]@17
  unsigned __int8 v28; // [sp+13h] [bp-11h]@10
  char *v29; // [sp+14h] [bp-10h]@11
  int v30; // [sp+18h] [bp-Ch]@4
  float v31; // [sp+1Ch] [bp-8h]@10
  float v32; // [sp+20h] [bp-4h]@10

  v3 = a2;
  if ( *(_BYTE *)(a1 + 10) )
  {
    v4 = *(_BYTE *)(*(_DWORD *)a2 + 1);
    v5 = 6;
    if ( v4 < 5u )
    {
      if ( v4 )
      {
        v5 = *(_BYTE *)(*(_DWORD *)a2 + 1);
        LOBYTE(v30) = sub_1000F240(v5);
        v6 = sub_1001FFA0(word_1006A38C[(unsigned __int8)v5]);
        v7 = a3;
        do
        {
          v8 = *v6;
          *v7++ = *v6++;
        }
        while ( v8 );
        if ( byte_1010FB68 != v5 && (_BYTE)v30 != -1 )
          sub_10021330(v30);
      }
    }
    byte_1010FB68 = *(_BYTE *)(*(_DWORD *)v3 + 1);
    return v5;
  }
  v10 = sub_10009D00(&v31, &v32, &v28);
  v11 = v10;
  if ( v10 == 10 )
  {
    v29 = sub_1001FFA0(word_1006A37C[v28]);
    sub_1000F2D0(10, (const void **)&v29);
    sub_1000F2B0(&v30, v31);
    v12 = sub_10015310(dword_1010FB70);
    if ( (_WORD)v12 == HIWORD(v12) || (v13 = flt_1010FB6C, flt_1010FB6C == -1.0) )
    {
      flt_1010FB6C = v32 - 1.0;
      v13 = flt_1010FB6C;
    }
    if ( v13 > 1.0 )
    {
      sprintf(a3, "%s %03d%s in %d seconds", v29, v30, "", (signed int)v13);
      return v11;
    }
    return 6;
  }
  if ( v10 == 9 )
  {
    v14 = sub_1001FFA0(word_1006A37C[v28]);
    v27 = (const void **)&v29;
    v26 = 9;
LABEL_20:
    v29 = v14;
    sub_1000F2D0(v26, v27);
    sub_1000F2B0(&v30, v31);
    sub_1000F360();
    sprintf(a3, "%s %03d%s now", v29, v30, "");
    return v11;
  }
  if ( v10 == 8 )
  {
    v14 = sub_1001FFA0(0x12CBu);
    v27 = (const void **)&v29;
    v26 = 8;
    goto LABEL_20;
  }
  if ( v10 == 7 )
  {
    v15 = sub_1001FFA0(0x14D7u);
    sprintf(a3, "%s in %d seconds", v15, (signed int)v32);
    return 7;
  }
  if ( v10 != 1 )
  {
    if ( v10 != 11 )
    {
      v23 = sub_1001FFA0(word_1006A364[(unsigned __int8)v10]);
      v24 = a3;
      do
      {
        v25 = *v23;
        *v24++ = *v23++;
      }
      while ( v25 );
      flt_1010FB6C = -1.0;
      return v11;
    }
    v18 = sub_1001FFA0(word_1006A384[v28]);
    if ( v31 == 9.9999996e24 )
    {
      v20 = v30;
    }
    else
    {
      v19 = sub_10047840(v31);
      if ( v19 <= 1 )
        v19 = 1;
      v20 = v19;
    }
    v21 = sub_10015310(dword_1010FB70);
    if ( (_WORD)v21 == HIWORD(v21) || (v22 = flt_1010FB6C, flt_1010FB6C == -1.0) )
    {
      flt_1010FB6C = v32 - 1.0;
      v22 = flt_1010FB6C;
    }
    if ( v22 > 1.0 )
    {
      if ( 9.9999996e24 == v31 )
      {
        sprintf(a3, "%s in %d seconds", v18, (signed int)v22);
        result = 11;
      }
      else
      {
        sprintf(a3, "%s %d%s in %d seconds", v18, v20, "", (signed int)v22);
        result = 11;
      }
      return result;
    }
    return 6;
  }
  v16 = sub_1001FFA0(word_1006A384[v28]);
  if ( v31 == 9.9999996e24 )
  {
    sprintf(a3, "%s now", v16);
    result = 1;
  }
  else
  {
    v17 = sub_10047840(v31);
    if ( v17 <= 1 )
      v17 = 1;
    sprintf(a3, "%s %d%s now", v16, v17, "");
    result = 1;
  }
  return result;
}
// 1006A364: using guessed type __int16 word_1006A364[];
// 1006A37C: using guessed type __int16 word_1006A37C[];
// 1006A384: using guessed type __int16 word_1006A384[];
// 1006A38C: using guessed type __int16 word_1006A38C[];
// 1010FB68: using guessed type char byte_1010FB68;
// 1010FB6C: using guessed type float flt_1010FB6C;
// 1010FB70: using guessed type int dword_1010FB70;

//----- (1000F760) --------------------------------------------------------
char __usercall sub_1000F760@<al>(int a1@<ecx>, int a2@<ebx>, int a3@<esi>, int a4)
{
  char result; // al@1
  char *v5; // eax@2
  __int16 v6; // dx@2
  signed int v7; // eax@2
  __int16 v8; // dx@2
  int v9; // eax@2
  int v10; // [sp+8h] [bp-58h]@1
  int v11; // [sp+Ch] [bp-54h]@1
  int v12; // [sp+10h] [bp-50h]@1
  int v13; // [sp+14h] [bp-4Ch]@1
  int v14; // [sp+18h] [bp-48h]@1
  int v15; // [sp+1Ch] [bp-44h]@1
  char v16; // [sp+20h] [bp-40h]@1

  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  result = sub_1000F390(a2, a1, &v16);
  if ( result != 6 )
  {
    v11 = sub_10015380(dword_1010FB70);
    v12 = sub_10015AD0(dword_1010FB70, 0);
    *(int *)((char *)&v13 + 2) = sub_10015310(dword_1010FB70);
    v5 = sub_10015340(dword_1010FB70);
    v6 = *(_WORD *)(a2 + 8);
    v10 = *(_DWORD *)v5;
    LOWORD(v13) = v6;
    v7 = sub_100153B0(dword_1010FB70);
    *(_WORD *)(a3 + 438) = *(_WORD *)a4;
    v8 = *(_WORD *)(a4 + 2);
    v15 = v7;
    v9 = v10;
    *(_WORD *)(a3 + 436) = v8;
    result = sub_10015B30(a3, &v16, &v10, *(_WORD *)(v9 + 30));
  }
  return result;
}
// 1010FB70: using guessed type int dword_1010FB70;

//----- (1000F840) --------------------------------------------------------
bool __cdecl sub_1000F840(int a1, int a2)
{
  char v3; // [sp+4h] [bp-40h]@1

  return sub_1000F390(a1, a2, &v3) != 6;
}

//----- (1000F880) --------------------------------------------------------
char __usercall sub_1000F880@<al>(_WORD *a1@<eax>, int a2@<ebx>, int a3@<esi>, int a4, int a5)
{
  char result; // al@2

  dword_1010FB70 &= 0xFFFFFFE0;
  if ( *a1 == -32747 )
  {
    dword_1010FB70 |= unk_1010FB6A & 0x1F | 32 * (byte_1010FB69 & 0x1F);
    result = sub_1000F760(a5, a2, a3, a4);
  }
  else
  {
    dword_1010FB70 |= byte_1010FB69 & 0x1F | 32 * (byte_1010FB69 & 0x1F);
    result = sub_1000F760(a5, a2, a3, a4);
  }
  return result;
}
// 1010FB69: using guessed type char byte_1010FB69;
// 1010FB6C: using guessed type float flt_1010FB6C;
// 1010FB70: using guessed type int dword_1010FB70;

//----- (1000F8F0) --------------------------------------------------------
char __cdecl sub_1000F8F0(int a1, int a2, int *a3, int a4, _WORD *a5)
{
  char result; // al@2

  switch ( *a5 )
  {
    case 0x8040:
      sub_10015D40(a1 + 276, *a3, *(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8));
      result = 2;
      break;
    case 0x8022:
    case 0x8078:
      sub_1000F760(a4, a2, a1, (int)a3);
      result = 2;
      break;
    case 0x8015:
    case 0x8016:
      sub_1000F880(a5, a2, a1, (int)a3, a4);
      result = 1;
      break;
    case 0x8041:
      sub_1000F270(a2);
      goto LABEL_6;
    default:
LABEL_6:
      result = 1;
      break;
  }
  return result;
}

//----- (1000FA20) --------------------------------------------------------
char __cdecl sub_1000FA20(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char v5; // al@3
  __int16 v6; // dx@4
  __int16 v7; // ax@6
  signed __int16 v8; // cx@6
  __int16 v9; // dx@8
  __int16 v10; // bx@8
  __int16 v11; // bp@8
  __int16 v12; // ST2C_2@8
  int v13; // edx@8
  int v14; // ST28_4@8
  __int16 v16; // [sp+0h] [bp-10h]@6
  __int16 v17; // [sp+4h] [bp-Ch]@4

  if ( *a5 == -32734 || *a5 == -32648 )
  {
    v5 = *(_BYTE *)(a2 + 8);
    if ( v5 & 0x20 )
    {
      v6 = *(_WORD *)(a2 + 6);
      v17 = *(_WORD *)(a2 + 4);
    }
    else
    {
      v17 = *(_WORD *)a3 + *(_WORD *)(a2 + 4);
      v6 = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6);
    }
    v16 = v6;
    v7 = word_1010FC78[(unsigned __int8)sub_100213C0(v5 & 0x1F)];
    v8 = 2;
    if ( (*(_BYTE *)(a2 + 8) & 0xC0) != 64 )
      v8 = 1;
    v9 = *(_WORD *)(a1 + 396);
    v10 = *(_WORD *)(a1 + 426);
    v11 = *(_WORD *)(a1 + 424);
    *(_WORD *)(a1 + 426) = v8;
    v12 = v9;
    v13 = *(_DWORD *)(a1 + 428);
    *(_WORD *)(a1 + 424) = v8;
    *(_WORD *)(a1 + 428) = v7;
    *(_WORD *)(a1 + 430) = v7;
    v14 = v13;
    *(_WORD *)(a1 + 396) = 2;
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_100083F0(a1 + 392, v17, v16, 2);
    *(_WORD *)(a1 + 426) = v10;
    *(_WORD *)(a1 + 424) = v11;
    *(_WORD *)(a1 + 396) = v12;
    *(_WORD *)(a1 + 428) = v14;
    *(_WORD *)(a1 + 430) = HIWORD(v14);
  }
  return 1;
}
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (1000FB70) --------------------------------------------------------
int __cdecl sub_1000FB70(int a1, int a2)
{
  return a2 + 4;
}

//----- (1000FB80) --------------------------------------------------------
char __cdecl sub_1000FB80(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  _BYTE *v5; // ebp@1
  char *v6; // esi@1
  signed int v7; // edi@1
  char result; // al@7
  char *v9; // esi@8
  signed int v10; // ebx@8
  int v11; // ecx@9
  _WORD *v12; // ST10_4@9
  int v13; // eax@9
  int v14; // ecx@9
  int v15; // [sp+10h] [bp-Ch]@2
  char *v16; // [sp+14h] [bp-8h]@2
  int v17; // [sp+18h] [bp-4h]@3

  v5 = a4;
  v6 = *(char **)(a2 + 4);
  v7 = 0;
  if ( *a4 )
  {
    do
    {
      sub_1001D040(v6, &v15, &v16);
      v6 = v16;
      ++v7;
    }
    while ( v7 < *v5 );
  }
  v17 = sub_1000FB70((int)v6, (int)v5);
  sub_1001D040(v6, &v15, 0);
  LOWORD(a4) = *(_WORD *)v15 + *(_WORD *)a3;
  HIWORD(a4) = *(_WORD *)(a3 + 2) + *(_WORD *)(v15 + 2);
  if ( *a5 == 32833 )
  {
    v9 = *(char **)(a2 + 4);
    flt_101E3788 = 9.8999998e24;
    flt_101E3780 = 9.8999998e24;
    flt_101E3778 = 9.8999998e24;
    dword_101E3714 = 0;
    flt_101E3738 = 9.8999998e24;
    dword_101E3740 = 0;
    flt_101E3730 = 9.8999998e24;
    dword_101E372C = 0;
    flt_101E370C = 9.8999998e24;
    dword_101E3724 = 0;
    flt_101E3784 = 9.8999998e24;
    dword_101E3720 = 0;
    flt_101E3718 = 9.8999998e24;
    dword_101E371C = 0;
    flt_101E37A0 = 9.8999998e24;
    dword_101E3774 = 0;
    flt_101E3744 = 9.8999998e24;
    dword_101E3790 = 0;
    flt_101E378C = 9.8999998e24;
    dword_101E3770 = 0;
    flt_101E3728 = 9.8999998e24;
    dword_101E3734 = 0;
    flt_101E3760 = 9.8999998e24;
    dword_101E3798 = 0;
    dword_101E3794 = 0;
    flt_101E3754 = 9.8999998e24;
    dword_101E377C = 0;
    dword_101E3748 = 0;
    dword_101E376C = 0;
    dword_101E375C = 0;
    dword_101E3750 = 0;
    dword_101E3758 = 0;
    dword_101E3764 = 0;
    dword_101E374C = 0x7FFFFFFF;
    dword_101E3768 = 0x7FFFFFFF;
    dword_101E373C = 0x7FFFFFFF;
    dword_101E3710 = 0x7FFFFFFF;
    dword_101E379C = 0x7FFFFFFF;
    v10 = 19;
    do
    {
      sub_1001D040(v9, &v15, &v16);
      LOWORD(a4) = *(_WORD *)v15 + *(_WORD *)a3;
      HIWORD(a4) = *(_WORD *)(a3 + 2) + *(_WORD *)(v15 + 2);
      v11 = *(_DWORD *)v9;
      v12 = a5;
      v13 = sub_1000FB70((int)v9, (int)v5);
      ((void (__cdecl *)(int, char *, _BYTE **, int, _WORD *))dword_101E32A0[2 * v14])(a1, v9, &a4, v13, v12);
      v9 = v16;
      --v10;
    }
    while ( v10 );
    result = 2;
  }
  else
  {
    if ( *a5 == 32888 && *(_BYTE *)(a2 + 8) == 1 )
      sub_10011680(a2, v5);
    result = ((int (__cdecl *)(int, char *, _BYTE **, int, _WORD *))dword_101E32A0[2 * (*(_DWORD *)v6 & 0xFF)])(
               a1,
               v6,
               &a4,
               v17,
               a5);
  }
  return result;
}
// 101E32A0: using guessed type int dword_101E32A0[];
// 101E370C: using guessed type float flt_101E370C;
// 101E3710: using guessed type int dword_101E3710;
// 101E3714: using guessed type int dword_101E3714;
// 101E3718: using guessed type float flt_101E3718;
// 101E371C: using guessed type int dword_101E371C;
// 101E3720: using guessed type int dword_101E3720;
// 101E3724: using guessed type int dword_101E3724;
// 101E3728: using guessed type float flt_101E3728;
// 101E372C: using guessed type int dword_101E372C;
// 101E3730: using guessed type float flt_101E3730;
// 101E3734: using guessed type int dword_101E3734;
// 101E3738: using guessed type float flt_101E3738;
// 101E373C: using guessed type int dword_101E373C;
// 101E3740: using guessed type int dword_101E3740;
// 101E3744: using guessed type float flt_101E3744;
// 101E3748: using guessed type int dword_101E3748;
// 101E374C: using guessed type int dword_101E374C;
// 101E3750: using guessed type int dword_101E3750;
// 101E3754: using guessed type float flt_101E3754;
// 101E3758: using guessed type int dword_101E3758;
// 101E375C: using guessed type int dword_101E375C;
// 101E3760: using guessed type float flt_101E3760;
// 101E3764: using guessed type int dword_101E3764;
// 101E3768: using guessed type int dword_101E3768;
// 101E376C: using guessed type int dword_101E376C;
// 101E3770: using guessed type int dword_101E3770;
// 101E3774: using guessed type int dword_101E3774;
// 101E3778: using guessed type float flt_101E3778;
// 101E377C: using guessed type int dword_101E377C;
// 101E3780: using guessed type float flt_101E3780;
// 101E3784: using guessed type float flt_101E3784;
// 101E3788: using guessed type float flt_101E3788;
// 101E378C: using guessed type float flt_101E378C;
// 101E3790: using guessed type int dword_101E3790;
// 101E3794: using guessed type int dword_101E3794;
// 101E3798: using guessed type int dword_101E3798;
// 101E379C: using guessed type int dword_101E379C;
// 101E37A0: using guessed type float flt_101E37A0;

//----- (1000FDD0) --------------------------------------------------------
char __usercall sub_1000FDD0@<al>(unsigned __int16 *a1@<eax>, int a2@<ebx>, int a3@<edi>, unsigned int a4@<esi>, int a5)
{
  char *v5; // ebp@1
  char *v6; // eax@1
  __int16 v7; // cx@1
  signed int v8; // eax@1
  __int16 v9; // dx@1
  int v10; // ecx@1
  int v12; // [sp+4h] [bp-18h]@1
  int v13; // [sp+8h] [bp-14h]@1
  int v14; // [sp+Ch] [bp-10h]@1
  __int16 v15; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+12h] [bp-Ah]@1
  int v17; // [sp+18h] [bp-4h]@1

  v5 = sub_1001FFA0(*a1);
  v13 = sub_10015380(a4);
  v14 = sub_10015AD0(a4, 0);
  v16 = sub_10015310(a4);
  v6 = sub_10015340(a4);
  v7 = *(_WORD *)(a5 + 8);
  v12 = *(_DWORD *)v6;
  v15 = v7;
  v8 = sub_100153B0(a4);
  v9 = *(_WORD *)a2;
  v10 = v12;
  v17 = v8;
  *(_WORD *)(a3 + 438) = v9;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a2 + 2);
  return sub_10015B30(a3, v5, &v12, *(_WORD *)(v10 + 30));
}

//----- (1000FE60) --------------------------------------------------------
char __cdecl sub_1000FE60(int a1, int a2, int *a3, int a4, _WORD *a5)
{
  int v5; // ebp@1
  char v6; // cl@1
  char v7; // dl@1
  unsigned int v8; // esi@1
  char result; // al@1
  int v10; // edi@2
  int v11; // ecx@3
  int v12; // edx@3
  int v13; // esi@7
  char v14; // bl@9
  char v15; // [sp+14h] [bp+8h]@1

  v5 = a2;
  v6 = (*(_DWORD *)(a2 + 4) >> 5) & 0x1F;
  v7 = *(_BYTE *)(a2 + 4) & 0x1F;
  v8 = *(_DWORD *)(a2 + 4) & 0xFFFFFC00;
  v15 = (*(_DWORD *)(a2 + 4) >> 5) & 0x1F;
  result = 1;
  switch ( *a5 )
  {
    case 0x8015:
      v10 = a4;
      if ( *(_BYTE *)(a4 + 2) )
        return 2;
      v11 = v6 & 0x1F;
      v12 = v7 & 0x1F;
      if ( *(_BYTE *)(a4 + 3) != 1 )
        goto LABEL_14;
      goto LABEL_16;
    case 0x8016:
      v10 = a4;
      if ( !*(_BYTE *)(a4 + 2) )
        goto LABEL_6;
      return 2;
    case 0x8040:
      sub_10015D40(a1 + 276, *a3, *(_DWORD *)(v5 + 4), *(_WORD *)(v5 + 8));
      return 2;
    case 0x8022:
    case 0x8078:
      v10 = a4;
      v14 = *(_BYTE *)(a4 + 2);
      if ( v14 == 2 )
      {
        v13 = v6 & 0x1F | 32 * (v7 & 0x1F) | v8;
        goto LABEL_17;
      }
      if ( v14 == 1 )
        goto LABEL_15;
      if ( byte_101B1070 )
      {
        v11 = v6 & 0x1F;
        v12 = v7 & 0x1F;
        if ( *(_BYTE *)(a4 + 3) != 1 )
        {
LABEL_14:
          v13 = v11 | 32 * v12 | v8;
          goto LABEL_17;
        }
      }
      else
      {
LABEL_6:
        if ( *(_BYTE *)(v10 + 3) == 1 )
        {
          v13 = v15 & 0x1F | 32 * (v15 & 0x1F) | v8;
          goto LABEL_17;
        }
LABEL_15:
        v11 = v6 & 0x1F;
        v12 = v7 & 0x1F;
      }
LABEL_16:
      v13 = v12 | 32 * v11 | v8;
LABEL_17:
      sub_1000FDD0((unsigned __int16 *)v10, (int)a3, a1, v13, v5);
      return 2;
    default:
      return result;
  }
}
// 101B1070: using guessed type char byte_101B1070;

//----- (10010000) --------------------------------------------------------
int __usercall sub_10010000@<eax>(int a1@<eax>, int a2@<ecx>)
{
  int result; // eax@2

  if ( dword_1006BAB0[4 * ((*(_BYTE *)(a1 + 8) & 0x3F) - 38)] != 360
    || (result = *(_DWORD *)(a2 + 56), *(_WORD *)(result + 240)) )
  {
    result = *(_DWORD *)(a2 + 56);
    *(_BYTE *)(result + 242) = 1;
  }
  else
  {
    *(_BYTE *)(result + 242) = 2;
  }
  return result;
}
// 1006BAB0: using guessed type int dword_1006BAB0[];

//----- (10010040) --------------------------------------------------------
char *__usercall sub_10010040@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebx@1
  __int16 v4; // bp@1
  signed int v5; // edi@1
  int v6; // esi@1
  __int32 v7; // ecx@1
  __int32 v8; // eax@2
  __int32 v9; // ebp@2
  char v11; // [sp+10h] [bp-8h]@1
  char v12; // [sp+11h] [bp-7h]@1
  char v13[4]; // [sp+14h] [bp-4h]@1
  __int32 v14; // [sp+1Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_BYTE *)(a1 + 8) & 0x3F;
  v5 = 10 * (signed int)flt_1006BAB4[4 * ((*(_BYTE *)(a1 + 8) & 0x3F) - 38)];
  strncpy(
    v13,
    (const char *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240) + *(_DWORD *)(v3 + 56) + 69),
    *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242));
  v13[*(_BYTE *)(*(_DWORD *)(v3 + 56) + 242)] = 0;
  v6 = a3 + (unsigned __int16)j__atol(v13);
  v11 = *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240)
                 + *(_DWORD *)(v3 + 56)
                 + *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242)
                 + 69);
  v12 = 0;
  v7 = j__atol(&v11);
  v14 = v7;
  if ( v4 == 41 )
  {
    v11 = *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240)
                   + *(_DWORD *)(v3 + 56)
                   + *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242)
                   + 71);
    v8 = j__atol(&v11);
    v7 = v14;
    v9 = v8;
  }
  else
  {
    v9 = 0;
  }
  if ( 100 * v6 > v5 || v9 + 10 * (v7 + 10 * v6) > v5 )
  {
    v6 = 0;
  }
  else if ( v6 < 0 )
  {
    v6 = v5 / 100;
    if ( v9 + 10 * (v7 + 10 * (v5 / 100)) > v5 )
      --v6;
  }
  sprintf(v13, "%0*u", *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242), v6);
  return strncpy(
           (char *)(*(_WORD *)(*(_DWORD *)(v3 + 56) + 240) + *(_DWORD *)(v3 + 56) + 69),
           v13,
           *(_BYTE *)(*(_DWORD *)(v3 + 56) + 242));
}
// 1006BAB4: using guessed type float flt_1006BAB4[];
// 10010040: using guessed type char var_4[4];

//----- (100101B0) --------------------------------------------------------
int __fastcall sub_100101B0(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@1

  v2 = 5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF);
  v3 = (unsigned __int8)byte_1006BAB9[16 * ((*(_BYTE *)(a2 + 8) & 0x3F) - 38)];
  return v3 * *((_BYTE *)&unk_101E37E0 + 4 * v2 + 17) + (v3 - 1) * *(_WORD *)(dword_101E37E4[v2] + 28);
}
// 101E37E4: using guessed type int dword_101E37E4[];

//----- (10010200) --------------------------------------------------------
char __usercall sub_10010200@<al>(int a1@<eax>, int a2@<ecx>)
{
  unsigned __int16 v2; // ax@1

  v2 = *(_BYTE *)(a1 + 8) & 0x3F;
  if ( dword_1006BAB0[4 * (v2 - 38)] != 360 || *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) != 1 )
  {
    if ( v2 == 41 )
    {
      if ( *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) != 3 )
        return 1;
    }
    else if ( v2 != 42 || *(_WORD *)(*(_DWORD *)(a2 + 56) + 240) != 3 )
    {
      return 1;
    }
  }
  return 0;
}
// 1006BAB0: using guessed type int dword_1006BAB0[];

//----- (10010260) --------------------------------------------------------
char __usercall sub_10010260@<al>(int a1@<esi>, int a2, int a3)
{
  __int16 v3; // bx@1
  int v4; // ecx@1
  char *v5; // edi@1
  int v6; // eax@1
  int v7; // edx@1
  bool v8; // zf@3
  int v9; // ecx@3
  const char *v10; // ebp@4
  int v11; // eax@4
  __int32 v12; // eax@8
  float v13; // ST24_4@9
  float v14; // ST2C_4@9
  float v15; // ST24_4@9
  int v16; // eax@13
  int i; // edi@16
  int v19; // ecx@20
  signed int v20; // eax@20
  int v21; // [sp+4h] [bp-20h]@8
  char v22; // [sp+17h] [bp-Dh]@1
  signed int v23; // [sp+1Ch] [bp-8h]@3

  v3 = *(_BYTE *)(a2 + 8) & 0x3F;
  v4 = *(_BYTE *)(a2 + 8) & 0x3F;
  v5 = &byte_1006BAB9[16 * (v4 - 38)];
  v6 = (unsigned __int8)*v5;
  v22 = 0;
  v7 = v6 + 1;
  if ( v3 != 42 )
    v7 = v6 - 1;
  v8 = v4 == 41;
  v9 = *(_DWORD *)(a1 + 56);
  v23 = v7;
  if ( v8 )
  {
    v10 = "%0*.1f";
    v11 = v6 - 3;
  }
  else
  {
    v10 = "%0*d";
    v11 = v6 - 1;
  }
  if ( *(_WORD *)(v9 + 240) == v11 && *(_BYTE *)(v9 + 69) == 48 )
  {
    v22 = 1;
    v12 = j__atol((const char *)(v9 + 69));
    if ( v3 == 41 )
    {
      v13 = (double)v12 * 10.0;
      v14 = sub_10049919((char *)(*(_DWORD *)(a1 + 56) + 72));
      v15 = v14 + v13;
      sprintf((char *)(*(_DWORD *)(a1 + 56) + 69), v10, (unsigned __int8)*v5, v15);
    }
    else
    {
      sprintf((char *)(*(_DWORD *)(a1 + 56) + 69), v10, (unsigned __int8)*v5, 10 * v12, v21);
    }
  }
  *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = *(_BYTE *)(a3 + 14);
  if ( !v22 )
    goto LABEL_16;
  if ( v3 == 39 )
  {
    v16 = *(_DWORD *)(a1 + 56);
    if ( *(_BYTE *)(v16 + 70) == 48 )
    {
      *(_BYTE *)(v16 + 242) = 1;
      return 2;
    }
    goto LABEL_16;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 56) + 69) != 48 )
  {
LABEL_16:
    ++*(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
    for ( i = *(_DWORD *)(a1 + 56); *(_WORD *)(i + 240) < v23; i = *(_DWORD *)(a1 + 56) )
    {
      if ( sub_10010200(a2, a1) )
        break;
      if ( *(_BYTE *)(i + 242) == 2 )
        break;
      ++*(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
    }
    v19 = *(_DWORD *)(a1 + 56);
    v20 = *(_WORD *)(v19 + 240);
    if ( v20 >= v23 )
      LOBYTE(v20) = v23;
    *(_WORD *)(v19 + 240) = (char)v20;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
  return 2;
}

//----- (100103F0) --------------------------------------------------------
char __thiscall sub_100103F0(int this)
{
  char result; // al@1

  result = *(_BYTE *)(this + 1);
  if ( result == 69 )
  {
    *(_BYTE *)(this + 1) = 87;
  }
  else if ( result == 87 )
  {
    *(_BYTE *)(this + 1) = 69;
  }
  return result;
}

//----- (10010410) --------------------------------------------------------
int __usercall sub_10010410@<eax>(int a1@<ecx>, int *a2@<ebx>, int a3@<edi>, int *a4@<esi>, _BYTE *a5, char a6)
{
  char *v6; // eax@3
  int result; // eax@4

  if ( a6 )
  {
    *a4 = 0;
  }
  else
  {
    v6 = sub_10015340(*(_DWORD *)(a3 + 4));
    *a4 = sub_10007120(*((_DWORD *)v6 + 1), a5, 0);
  }
  result = *(_WORD *)(a3 + 10) - *a4;
  *a2 = result;
  if ( *a4 > 0 )
  {
    a1 = dword_101E37E4[5 * ((*(_DWORD *)(a3 + 4) >> 10) & 0xF)];
    result -= *(_WORD *)(a1 + 28);
    *a2 = result;
  }
  if ( !*(_WORD *)(a3 + 10) )
  {
    result = sub_100101B0(a1, a3);
    *a2 = result;
  }
  return result;
}
// 101E37E4: using guessed type int dword_101E37E4[];

//----- (10010480) --------------------------------------------------------
int __usercall sub_10010480@<eax>(_WORD *a1@<edx>, int a2@<ecx>, int a3, char a4, char *a5, int a6, int a7, int a8)
{
  double v8; // st7@1
  __int16 v9; // ax@1
  double v10; // st7@1
  bool v11; // c0@1
  unsigned __int16 v12; // bp@1
  _WORD *v13; // edi@1
  int *v14; // esi@1
  float v15; // ST10_4@3
  double v16; // st7@3
  double v17; // st7@8
  __int16 v18; // cx@11
  char *v19; // edi@13
  char v20; // al@14
  char *v21; // eax@18
  char v22; // cl@19
  char *v23; // edi@25
  char v24; // al@26
  int v25; // ecx@27
  char *v26; // eax@29
  char v27; // cl@30
  char *v28; // edi@33
  char v29; // al@34
  unsigned int v30; // eax@48
  unsigned __int8 v31; // al@51
  char *v32; // eax@43
  int v33; // ecx@43
  _BYTE *v34; // esi@56
  _BYTE *v35; // edx@56
  char v36; // cl@57
  int *v37; // ebx@58
  int result; // eax@58
  const char *v39; // ebp@61
  unsigned int v40; // eax@61
  char *v41; // edi@61
  char v42; // cl@62
  char *v43; // eax@63
  char v44; // [sp+1Bh] [bp-39h]@1
  signed int v45; // [sp+1Ch] [bp-38h]@8
  char v46; // [sp+1Ch] [bp-38h]@43
  bool v47; // [sp+23h] [bp-31h]@1
  int v48; // [sp+24h] [bp-30h]@1
  _WORD *v49; // [sp+28h] [bp-2Ch]@1
  int v50; // [sp+2Ch] [bp-28h]@1
  int *v51; // [sp+30h] [bp-24h]@1
  int *v52; // [sp+34h] [bp-20h]@1
  char *v53; // [sp+38h] [bp-1Ch]@1
  char v54[8]; // [sp+3Ch] [bp-18h]@1
  char v55[8]; // [sp+43h] [bp-11h]@13
  char v56[2]; // [sp+44h] [bp-10h]@11

  v8 = *(float *)a3;
  v9 = *(_WORD *)(a2 + 8);
  v50 = a2;
  *(float *)&v48 = v8;
  v10 = *(float *)&v48;
  v11 = *(float *)&v48 < -3.141592741012573;
  *(_DWORD *)v54 = a1;
  v52 = (int *)a6;
  v12 = v9 & 0x3F;
  v51 = (int *)a7;
  v13 = (_WORD *)a8;
  *(_WORD *)a8 = v9;
  v14 = &dword_1006BAB0[4 * ((v9 & 0x3F) - 38)];
  v53 = a5;
  v49 = (_WORD *)a8;
  v47 = 0;
  v44 = 0;
  if ( v11 || v10 >= 3.141592741012573 )
  {
    if ( v12 == 41 )
      strncpy(a5, "___._", *((_BYTE *)v14 + 9));
    else
      strncpy(a5, "____", *((_BYTE *)v14 + 9));
    a5[*((_BYTE *)v14 + 9)] = 0;
    v47 = 1;
    goto LABEL_40;
  }
  v15 = v10;
  sub_10022550((int)&v48, v15);
  v16 = *(float *)&v48;
  if ( *(float *)&v48 > 180.0 )
  {
    if ( v12 == 42 || v12 == 43 )
    {
      v44 = 1;
      *(float *)&v48 = 360.0 - v16;
      v16 = *(float *)&v48;
    }
    else if ( v12 == 39 )
    {
      *(float *)&v48 = v16 - 360.0 - 1.0;
      v16 = *(float *)&v48;
LABEL_8:
      v17 = v16 + 0.5;
      v45 = (signed int)v17;
      if ( !*((_BYTE *)v14 + 8) && !(signed int)v17 )
        v45 = 360;
      goto LABEL_11;
    }
  }
  if ( v12 != 41 )
    goto LABEL_8;
  *(float *)&v45 = v16;
  if ( v16 < 0.1000000014901161 )
    *(float *)&v45 = 360.0;
LABEL_11:
  v18 = *(_WORD *)a8;
  strcpy(v56, "%");
  if ( v18 & 0x40 && v12 == 39 )
  {
    v19 = v55;
    do
      v20 = (v19++)[1];
    while ( v20 );
    *(_WORD *)v19 = 43;
  }
  if ( v18 & 0x100 )
  {
    if ( v12 != 41 )
    {
      v23 = v55;
      do
        v24 = (v23++)[1];
      while ( v24 );
      v25 = *((_BYTE *)v14 + 9);
      *(_DWORD *)v23 = 6564400;
      sprintf(a5, v56, v25, v45);
      goto LABEL_36;
    }
    v21 = v55;
    do
      v22 = (v21++)[1];
    while ( v22 );
    *(_DWORD *)v21 = 825109040;
    *((_WORD *)v21 + 2) = 102;
  }
  else
  {
    if ( v12 != 41 )
    {
      v28 = v55;
      do
        v29 = (v28++)[1];
      while ( v29 );
      *(_WORD *)v28 = 100;
      sprintf(a5, v56, v45);
      goto LABEL_36;
    }
    v26 = v55;
    do
      v27 = (v26++)[1];
    while ( v27 );
    *(_DWORD *)v26 = 1714499114;
    v26[4] = 0;
  }
  sprintf(a5, v56, *((_BYTE *)v14 + 9), v45);
LABEL_36:
  if ( *(float *)&v45 == 0.0 || v45 == 180 )
    v47 = v12 != 42;
  v13 = v49;
LABEL_40:
  if ( a4 && v47 && (unsigned int)v12 - 42 <= 1 )
  {
    v46 = 5;
    v32 = sub_10021070(5u);
  }
  else
  {
    v30 = *v13;
    if ( v30 & 0x200 )
    {
      v46 = 31;
      v32 = sub_10021070(0x1Fu);
    }
    else
    {
      if ( v12 == 42 )
      {
        v31 = v44 != 0 ? 9 : 6;
      }
      else if ( v12 == 43 )
      {
        v31 = (v44 == 0) + 7;
      }
      else
      {
        v31 = sub_10021410(v30, 0);
      }
      v46 = v31;
      v32 = sub_10021070(v31);
    }
  }
  v34 = *(_BYTE **)v54;
  v35 = *(_BYTE **)v54;
  do
  {
    v36 = *v32;
    *v35++ = *v32++;
  }
  while ( v36 );
  v37 = v52;
  LOBYTE(v33) = (*v13 & 0x200) == 512;
  result = sub_10010410(v33, v52, v50, v51, v34, v33);
  if ( v12 == 43 && v46 == 7 && !(*v49 & 0x200) )
  {
    v39 = v53;
    **(_WORD **)v54 = 145;
    *(_WORD *)v54 = 156;
    v40 = strlen(v39) + 1;
    v41 = (char *)&v53 + 3;
    do
      v42 = (v41++)[1];
    while ( v42 );
    qmemcpy(v41, v39, v40);
    strcpy((char *)v39, v54);
    v43 = sub_10015340(*(_DWORD *)(v50 + 4));
    result = sub_10007120(*((_DWORD *)v43 + 1), "", 0);
    *v51 -= result;
    *v37 += result;
  }
  return result;
}
// 1006BAB0: using guessed type int dword_1006BAB0[];

//----- (100108B0) --------------------------------------------------------
char __usercall sub_100108B0@<al>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, int a4)
{
  __int16 v4; // dx@1
  __int16 v5; // ST18_2@1
  __int16 v6; // dx@1
  char v8; // [sp+0h] [bp-1Ch]@1
  int v9; // [sp+4h] [bp-18h]@1
  int v10; // [sp+8h] [bp-14h]@1
  int v11; // [sp+Ch] [bp-10h]@1
  char v12; // [sp+10h] [bp-Ch]@1

  sub_10010480(&v8, a2, a4, 1, &v12, (int)&v10, (int)&v9, (int)&v11);
  v4 = v11;
  *(_WORD *)(a3 + 438) = *(_WORD *)a1;
  v5 = v4;
  v6 = v10;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a1 + 2);
  return sub_10015EA0(a3, &v12, &v8, v6, v9, *(_DWORD *)(a2 + 4), v5);
}

//----- (10010930) --------------------------------------------------------
char __cdecl sub_10010930(int a1, int a2, _WORD *a3, int *a4, int a5)
{
  int v5; // eax@1
  __int16 v6; // ax@2
  int v7; // edx@2
  int v8; // edx@6
  __int16 v9; // ax@7
  int v10; // eax@8
  __int16 v11; // cx@8
  int v12; // ecx@10
  int v13; // eax@10
  int v14; // esi@10
  __int16 v15; // cx@10
  int v16; // esi@10
  unsigned __int16 v17; // cx@12
  int v18; // esi@14
  int v19; // ecx@15
  int v20; // edx@15
  int v21; // ecx@15
  int v22; // esi@19
  int v23; // edx@23
  int v24; // ecx@23
  int v25; // edx@26
  int v26; // ecx@26
  int v27; // ecx@28
  int v28; // eax@30
  int v29; // edx@30
  int v30; // ecx@30
  int v31; // esi@36
  int v32; // edx@37
  int v33; // eax@37
  signed int v34; // edx@41
  int v35; // edx@43
  int v36; // esi@45
  _WORD *v37; // ebx@55
  char v38; // al@58
  int v39; // eax@59
  int v40; // esi@61
  int v41; // esi@63
  int v42; // esi@67
  int v43; // esi@70
  char v44; // al@70
  unsigned __int16 v45; // cx@75
  _WORD *v46; // eax@80
  _BYTE *v47; // ST1C_4@80
  char v48; // dl@90
  int v49; // esi@97
  int v50; // esi@98
  int v51; // ecx@106
  char v53; // [sp+17h] [bp-31h]@1
  int v54; // [sp+18h] [bp-30h]@2
  int v55; // [sp+1Ch] [bp-2Ch]@10
  int v56; // [sp+20h] [bp-28h]@2
  int v57; // [sp+24h] [bp-24h]@15
  int v58; // [sp+28h] [bp-20h]@15
  int v59; // [sp+2Ch] [bp-1Ch]@15
  int v60; // [sp+30h] [bp-18h]@2
  int v61; // [sp+34h] [bp-14h]@10
  _WORD *v62; // [sp+38h] [bp-10h]@1
  char v63; // [sp+3Ch] [bp-Ch]@2

  v5 = *(_WORD *)a5;
  v62 = a3;
  v53 = 1;
  switch ( v5 )
  {
    case 32832:
      sub_10010480(&v63, a2, (int)a4, 0, &v63, (int)&v54, (int)&v56, (int)&v60);
      v6 = *(_WORD *)(a2 + 10);
      v7 = v54;
      if ( v6 )
        v7 = v6;
      sub_10015D40(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v7);
      if ( !*(_WORD *)(a2 + 10) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000 )
      {
        v8 = v56;
        if ( v56 > 0 )
        {
          v9 = *(_WORD *)(dword_101E37E4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
          *(_WORD *)(a1 + 280) += v56 + v9;
          if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
          {
            v10 = (v9 + v8 + 1) / 2;
            v11 = *(_WORD *)(a1 + 280) - v10;
            *(_WORD *)(a1 + 276) -= v10;
            *(_WORD *)(a1 + 280) = v11;
          }
        }
      }
      return 2;
    case 32840:
      v12 = *(_WORD *)(a2 + 8) & 0x3F;
      v60 = *(_WORD *)(a2 + 8) & 0xFDFF;
      v13 = *(_DWORD *)(a1 + 56);
      v14 = (unsigned __int16)v12;
      v61 = v12;
      v15 = *(_WORD *)(v13 + 240);
      v16 = v14 - 38;
      v55 = v16;
      if ( v15 == -128 )
      {
        if ( *(_WORD *)(a5 + 10) == 0x2000 )
        {
          v17 = *(_WORD *)(a5 + 14);
          if ( v17 >= 0x30u && v17 <= 0x39u && (v18 = 16 * v16, byte_1006BABA[v18]) )
          {
            v19 = *(_DWORD *)(a2 + 4);
            v57 = *(_DWORD *)a2;
            v20 = *(_DWORD *)(a2 + 8);
            v58 = v19;
            v59 = v20;
            LOWORD(v59) = v20 | 0x100;
            sub_10010480(
              (_WORD *)(v13 + 75),
              (int)&v57,
              (int)a4,
              0,
              (char *)(v13 + 69),
              (int)&v54,
              (int)&v56,
              (int)&v60);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, (unsigned __int8)byte_1006BAB9[v18]);
            v21 = *(_DWORD *)(a1 + 56);
            if ( (_WORD)v61 == 41 )
            {
              *(_BYTE *)(v21 + 72) = 46;
              *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 2;
            }
            else
            {
              *(_WORD *)(v21 + 240) = (unsigned __int8)byte_1006BAB9[v18] - 1;
            }
            v53 = sub_10010260(a1, a2, a5);
          }
          else
          {
            v22 = 16 * v55;
            if ( byte_1006BABA[16 * v55] && (_WORD)v61 == 42 && (v17 == 69 || v17 == 87) )
            {
              v23 = *(_DWORD *)(a2 + 4);
              v57 = *(_DWORD *)a2;
              v24 = *(_DWORD *)(a2 + 8);
              v58 = v23;
              v59 = v24;
              LOWORD(v59) = v24 | 0x100;
              sub_10010480(
                (_WORD *)(v13 + 75),
                (int)&v57,
                (int)a4,
                0,
                (char *)(v13 + 69),
                (int)&v54,
                (int)&v56,
                (int)&v60);
              memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, (unsigned __int8)byte_1006BAB9[v22]);
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 76) = *(_BYTE *)(a5 + 14);
              *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = (unsigned __int8)byte_1006BAB9[v22] - 1;
            }
            else if ( v17 == 46 && (_WORD)v61 == 41 )
            {
              v25 = *(_DWORD *)(a2 + 4);
              v57 = *(_DWORD *)a2;
              v26 = *(_DWORD *)(a2 + 8);
              v58 = v25;
              v59 = v26;
              LOWORD(v59) = v26 | 0x100;
              sub_10010480(
                (_WORD *)(v13 + 75),
                (int)&v57,
                (int)a4,
                0,
                (char *)(v13 + 69),
                (int)&v54,
                (int)&v56,
                (int)&v60);
              memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, (unsigned __int8)byte_1006BAB9[v22]);
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 72) = 46;
              *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 4;
            }
          }
          v16 = v55;
        }
        HIWORD(v27) = HIWORD(a5);
        if ( *(_WORD *)(a5 + 10) == 56 )
        {
          if ( byte_1006BABA[16 * v16] )
          {
            v28 = *(_DWORD *)a2;
            v29 = *(_DWORD *)(a2 + 8);
            v55 = *a4;
            v30 = *(_DWORD *)(a2 + 4);
            v57 = v28;
            v59 = v29;
            LOWORD(v59) = v29 | 0x100;
            v58 = v30;
            if ( *(float *)&v55 == 6.283185482025146 || 9.8999998e24 == *(float *)&v55 )
              *(float *)&v55 = 0.0;
            sub_10010480(
              (_WORD *)(*(_DWORD *)(a1 + 56) + 75),
              (int)&v57,
              (int)&v55,
              0,
              (char *)(*(_DWORD *)(a1 + 56) + 69),
              (int)&v54,
              (int)&v56,
              (int)&v60);
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
            sub_10010000(a2, a1);
            v53 = 4;
          }
          else
          {
            v53 = 0;
          }
        }
        if ( *(_WORD *)(a5 + 10) == 32 )
        {
          v31 = 16 * v16;
          if ( byte_1006BABA[v31] )
          {
            v32 = *(_DWORD *)(a2 + 8);
            v33 = *(_DWORD *)a2;
            v58 = *(_DWORD *)(a2 + 4);
            v59 = v32;
            LOWORD(v59) = v32 | 0x100;
            v57 = v33;
            sub_10010480(
              (_WORD *)(*(_DWORD *)(a1 + 56) + 75),
              (int)&v57,
              (int)a4,
              0,
              (char *)(*(_DWORD *)(a1 + 56) + 69),
              (int)&v54,
              (int)&v56,
              (int)&v60);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, (unsigned __int8)byte_1006BAB9[v31]);
            if ( (_WORD)v61 == 41 )
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 72) = 46;
            *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
            sub_10010000(a2, a1);
            sub_100108B0((int)v62, a2, a1, (int)a4);
            v53 = 4;
            goto LABEL_80;
          }
          return 0;
        }
        goto LABEL_78;
      }
      v34 = *(_WORD *)(a5 + 10);
      if ( v34 <= 56 )
      {
        if ( v34 != 56 )
        {
          v35 = v34 - 32;
          if ( v35 )
          {
            if ( v35 == 1 )
            {
              *(_WORD *)(v13 + 240) = -128;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
              *(float *)&v54 = sub_10049919((char *)(*(_DWORD *)(a1 + 56) + 69));
              v36 = 4 * ((*(_BYTE *)(a2 + 8) & 0x3F) - 38);
              v55 = SLODWORD(flt_1006BAB4[v36]);
              if ( *(float *)&v55 <= (double)*(float *)&v54 )
                v54 = v55;
              if ( 0.0 == *(float *)&v54 && !byte_1006BAB8[v36 * 4] )
                v54 = SLODWORD(flt_1006BAB4[v36]);
              if ( *(float *)&v54 >= 360.0 )
                *(float *)&v54 = 0.0;
              sub_10022580((int)a4, *(float *)&v54);
              if ( !strcmp((const char *)(*(_DWORD *)(a1 + 56) + 75), &byte_1006BABB[v36 * 4]) )
                *(float *)a4 = *(float *)a4 * -1.0;
              *(float *)a4 = sub_10047770(*(float *)a4);
              sub_100108B0((int)v62, a2, a1, (int)a4);
              v53 = 3;
            }
          }
          else
          {
            *(_WORD *)(v13 + 240) = -128;
            v37 = v62;
            *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242) = 1;
            sub_100108B0((int)v37, a2, a1, (int)a4);
            v53 = 6;
          }
          return v53;
        }
        if ( v15 == 1 )
          v15 = 0;
        *(_WORD *)(v13 + 240) = v15;
        sub_10010000(a2, a1);
        v38 = *(_BYTE *)(a5 + 8);
        if ( v38 >= 0 )
        {
          if ( v38 <= 0 )
            goto LABEL_72;
          v39 = *(_DWORD *)(a1 + 56);
          if ( *(_BYTE *)(v39 + 242) > 1 )
          {
            sub_10010040(a2, v27, 1);
            v53 = 2;
            goto LABEL_80;
          }
          v42 = 4 * v16;
          if ( *(_WORD *)(v39 + 240) < (signed __int16)(unsigned __int8)byte_1006BAB9[v42 * 4] )
          {
            *(float *)&v55 = COERCE_FLOAT(j__atol((const char *)(v39 + 69)));
            if ( flt_1006BAB4[v42] == (double)v55 )
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 48;
              v53 = 2;
            }
            else
            {
              v43 = *(_DWORD *)(a1 + 56);
              v44 = sub_1001DF60(*(_BYTE *)(*(_WORD *)(v43 + 240) + v43 + 69), 0x10u, 1);
              v27 = *(_WORD *)(v43 + 240);
              *(_BYTE *)(v27 + v43 + 69) = v44;
              v53 = 2;
            }
            goto LABEL_80;
          }
        }
        else
        {
          v39 = *(_DWORD *)(a1 + 56);
          if ( *(_BYTE *)(v39 + 242) > 1 )
          {
            sub_10010040(a2, v27, -1);
            v53 = 2;
            goto LABEL_80;
          }
          v40 = 4 * v16;
          if ( *(_WORD *)(v39 + 240) < (signed __int16)(unsigned __int8)byte_1006BAB9[v40 * 4] )
          {
            *(float *)&v55 = COERCE_FLOAT(j__atol((const char *)(v39 + 69)));
            if ( flt_1006BAB4[v40] != (double)v55 )
            {
              v41 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v41 + 240) + v41 + 69) = sub_1001DF60(
                                                               *(_BYTE *)(*(_WORD *)(v41 + 240) + v41 + 69),
                                                               0x10u,
                                                               -1);
              v53 = 2;
              goto LABEL_80;
            }
LABEL_72:
            v53 = 2;
            goto LABEL_80;
          }
        }
        sub_100103F0(v39 + 75);
        goto LABEL_72;
      }
      if ( v34 == 57 )
      {
        if ( v15 != 1 )
        {
          v48 = *(_BYTE *)(a5 + 8);
          if ( v48 < 0 )
          {
            if ( v15 )
            {
              --*(_WORD *)(v13 + 240);
              for ( ; *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) >= 0; --*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) )
              {
                if ( sub_10010200(a2, a1) )
                  break;
              }
            }
            v53 = 2;
            sub_10010000(a2, a1);
            goto LABEL_80;
          }
          if ( v48 <= 0 )
            return v53;
          v49 = (unsigned __int8)byte_1006BAB9[16 * v16];
          if ( (_WORD)v61 == 42 )
            v50 = v49 + 1;
          else
            v50 = v49 - 1;
          if ( v15 < v50 )
          {
            ++*(_WORD *)(v13 + 240);
            for ( ; *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v50; ++*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) )
            {
              if ( sub_10010200(a2, a1) )
                break;
            }
            sub_10010000(a2, a1);
            v53 = 2;
            goto LABEL_80;
          }
          return 0;
        }
        *(_WORD *)(v13 + 240) = *(_BYTE *)(a5 + 8) < 0 ? 0 : 2;
        sub_10010000(a2, a1);
        v53 = 2;
LABEL_80:
        v46 = v62;
        LOWORD(v27) = *v62;
        *(_WORD *)(a1 + 438) = *v62;
        v47 = (_BYTE *)(*(_DWORD *)(a1 + 56) + 75);
        *(_WORD *)(a1 + 436) = v46[1];
        sub_10010410(v27, &v54, a2, &v56, v47, 0);
        sub_10015EA0(
          a1,
          (char *)(*(_DWORD *)(a1 + 56) + 69),
          (const char *)(*(_DWORD *)(a1 + 56) + 75),
          v54,
          v56,
          *(_DWORD *)(a2 + 4),
          v60);
        return v53;
      }
      if ( v34 != 0x2000 )
        return v53;
      v45 = *(_WORD *)(a5 + 14);
      if ( v45 < 0x30u || v45 > 0x39u )
      {
        if ( (_WORD)v61 != 42 || v45 != 69 && v45 != 87 )
        {
          if ( v45 == 46 && (_WORD)v61 == 41 )
            *(_WORD *)(v13 + 240) = 4;
        }
        else
        {
          *(_BYTE *)(v13 + 76) = *(_BYTE *)(a5 + 14);
        }
        return v53;
      }
      v53 = sub_10010260(a1, a2, a5);
LABEL_78:
      if ( v53 == 4 || v53 == 2 )
        goto LABEL_80;
      return v53;
    case 32802:
    case 32888:
      if ( *(_BYTE *)(a1 + 3) && (v51 = *(_DWORD *)(a1 + 56), *(_WORD *)(v51 + 240) != -128) )
      {
        *(_WORD *)(a1 + 438) = *a3;
        *(_WORD *)(a1 + 436) = a3[1];
        sub_10010410(v51 + 75, &v54, a2, &v56, (_BYTE *)(v51 + 75), 0);
        sub_10015EA0(
          a1,
          (char *)(*(_DWORD *)(a1 + 56) + 69),
          (const char *)(*(_DWORD *)(a1 + 56) + 75),
          v54,
          v56,
          *(_DWORD *)(a2 + 4),
          *(_WORD *)(a2 + 8));
      }
      else
      {
        sub_100108B0((int)a3, a2, a1, (int)a4);
      }
      return v53;
    default:
      return v53;
  }
}
// 1006BAB4: using guessed type float flt_1006BAB4[];
// 101E37E4: using guessed type int dword_101E37E4[];

//----- (100113A0) --------------------------------------------------------
char __cdecl sub_100113A0(char a1)
{
  unsigned int v1; // ecx@0
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // eax@1
  char result; // al@2
  unsigned int v6; // [sp-2h] [bp-4h]@1

  v6 = v1;
  v2 = 6 * sub_1001E3C0(&a1, 1u, (int)&unk_1006C0C0, 12, 8, -1);
  v3 = dword_1006C0C4[2 * v2 / 4u];
  v4 = 2 * v2;
  if ( v3 )
  {
    sub_100051A0(v3, (char *)&v6 + 3, 1, &byte_1006C0C8[v4]);
    result = BYTE3(v6);
    if ( BYTE3(v6) >= 0x12u )
      result = 18;
  }
  else
  {
    result = byte_1006C0C8[v4];
  }
  return result;
}
// 1006C0C4: using guessed type int dword_1006C0C4[];

//----- (10011400) --------------------------------------------------------
char __cdecl sub_10011400(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  _BYTE *v5; // ebp@1
  __int16 v6; // ax@1
  __int16 v7; // si@1
  __int16 v8; // di@1
  char result; // al@1
  int v10; // eax@3
  __int16 v11; // ax@6
  __int16 v12; // cx@10
  __int16 v13; // di@16
  char v14; // [sp+Fh] [bp-15h]@1
  __int16 v15; // [sp+10h] [bp-14h]@1
  __int16 v16; // [sp+14h] [bp-10h]@3
  __int16 v17; // [sp+16h] [bp-Eh]@3
  __int16 v18; // [sp+18h] [bp-Ch]@3
  __int16 v19; // [sp+1Ah] [bp-Ah]@3
  __int16 v20; // [sp+1Ch] [bp-8h]@3
  __int16 v21; // [sp+1Eh] [bp-6h]@3
  __int16 v22; // [sp+20h] [bp-4h]@3
  __int16 v23; // [sp+22h] [bp-2h]@3
  int v24; // [sp+30h] [bp+Ch]@13
  bool v25; // [sp+34h] [bp+10h]@1
  unsigned int v26; // [sp+38h] [bp+14h]@3

  v5 = a4;
  v6 = word_1010FC78[*a4 & 0x1F];
  v14 = *a4 & 0x60;
  v7 = *(_WORD *)(a3 + 2);
  v25 = (*a4 & 0x80) == -128;
  v8 = *(_WORD *)a3;
  v15 = v6;
  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    v10 = sub_10002760(a1, 56);
    *(_WORD *)(a1 + 428) = v15;
    *(_WORD *)(a1 + 430) = v15;
    *(_WORD *)(a1 + 440) = v15;
    *(_WORD *)(a1 + 442) = v15;
    v19 = v7 - 14;
    v21 = v7 - 7;
    v26 = v10;
    *(_WORD *)(a1 + 396) = 3;
    v17 = v7;
    v23 = v7;
    v16 = v8;
    v18 = v8;
    v20 = v8 + 7 * (2 * (v25 == 0) - 1);
    v22 = v8;
    sub_1005C600(a1 + 392, 4, (int)&v16, 56, v10);
    if ( v14 == 32 || v14 == 64 )
    {
      v11 = v25 ? v8 : v8 - *((_WORD *)v5 + 1) + 2;
      sub_1005C3A0(a1 + 392, v11, v7 - 9, *((_WORD *)v5 + 1) - 2, 5, 3);
      if ( v14 == 64 )
      {
        if ( v25 )
          v12 = v8 + *((_WORD *)v5 + 1) - 5;
        else
          v12 = v8 - *((_WORD *)v5 + 1);
        sub_1005C3A0(a1 + 392, v12, v7 - *((_WORD *)v5 + 2) + 2, 5, *((_WORD *)v5 + 2) - 8, 3);
        sub_1005C3A0(a1 + 392, v8 - *((_WORD *)v5 + 1) + 2, v7 - *((_WORD *)v5 + 2), *((_WORD *)v5 + 1) + 5, 5, 3);
        if ( v25 )
          v24 = (unsigned __int16)(v8 + *((_WORD *)v5 + 1) - 2);
        else
          v24 = (unsigned __int16)(v8 - *((_WORD *)v5 + 1) + 1);
        sub_1005C340(a1 + 392, v24, v7 - 6);
        sub_1005C340(a1 + 392, v24, v7 - *((_WORD *)v5 + 2) + 1);
        if ( v25 )
          v13 = v8 + *((_WORD *)v5 + 1) - 6;
        else
          v13 = v8 - *((_WORD *)v5 + 1) + 5;
        sub_1005C340(a1 + 392, v13, v7 - 10);
        sub_1005C340(a1 + 392, v13, v7 - *((_WORD *)v5 + 2) + 5);
      }
    }
    sub_10002420(a1, v26);
    result = 2;
  }
  return result;
}
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (10011680) --------------------------------------------------------
char __cdecl sub_10011680(int a1, _BYTE *a2)
{
  char *v2; // eax@1
  signed int v3; // esi@1
  char v4; // bl@1
  int v5; // esi@3
  char v6; // al@5
  double v7; // st7@7
  float v8; // eax@9
  char v9; // al@13
  double v10; // st7@25
  float v11; // eax@30
  float v12; // eax@34
  double v13; // st7@51
  float v14; // ST0C_4@53
  char v15; // al@75
  double v16; // st7@75
  double v17; // st7@75
  float *v19; // [sp+1Ch] [bp-DCh]@3
  int v20; // [sp+20h] [bp-D8h]@27
  char *v21; // [sp+24h] [bp-D4h]@2
  double v22; // [sp+28h] [bp-D0h]@75
  char v23; // [sp+30h] [bp-C8h]@2
  int v24; // [sp+34h] [bp-C4h]@9
  char v25; // [sp+38h] [bp-C0h]@61
  char v26; // [sp+48h] [bp-B0h]@80
  char v27; // [sp+4Fh] [bp-A9h]@81
  float v28; // [sp+CCh] [bp-2Ch]@80
  int v29; // [sp+DCh] [bp-1Ch]@3
  float v30; // [sp+E8h] [bp-10h]@41

  v2 = *(char **)(a1 + 4);
  v3 = 0;
  v4 = 1;
  if ( *a2 )
  {
    do
    {
      sub_1001D040(v2, (int *)&v23, &v21);
      v2 = v21;
      ++v3;
    }
    while ( v3 < *a2 );
  }
  v19 = (float *)sub_1000FB70((int)v2, (int)a2);
  v5 = sub_10004DF0();
  sub_100161A0((int)&v29);
  switch ( *a2 )
  {
    case 0:
      if ( (unsigned int)(v5 - dword_101E3714) > 0x3E8 )
      {
        dword_101E3714 = v5;
        v6 = sub_100061E0();
        if ( !sub_10005CB0(0, v6, &flt_101E3788) )
        {
          v4 = 0;
          flt_101E3788 = 9.8999998e24;
        }
      }
      v7 = flt_101E3788;
      goto LABEL_88;
    case 1:
      if ( (unsigned int)(v5 - dword_101E3740) > 0x3E8 )
      {
        dword_101E3740 = v5;
        LOBYTE(v8) = sub_10009C40();
        if ( !sub_1005CCF0(v8, (int)&flt_101E3780, (int)&v24) )
        {
          v4 = 0;
          flt_101E3780 = 9.8999998e24;
        }
      }
      v7 = flt_101E3780;
      goto LABEL_88;
    case 2:
      if ( (unsigned int)(v5 - dword_101E372C) > 0x3E8 )
      {
        dword_101E372C = v5;
        v9 = sub_100061E0();
        if ( !sub_10005CB0(1, v9, &flt_101E3778) )
        {
          v4 = 0;
          flt_101E3778 = 9.8999998e24;
        }
      }
      *v19 = flt_101E3778;
      return v4;
    case 3:
      if ( (unsigned int)(v5 - dword_101E3724) > 0x3E8 )
      {
        dword_101E3724 = v5;
        dword_101E374C = sub_1001B030();
      }
      *(_DWORD *)v19 = dword_101E374C;
      return v4;
    case 4:
      if ( (unsigned int)(v5 - dword_101E3720) <= 0x3E8 )
        goto LABEL_23;
      dword_101E3720 = v5;
      if ( v29 == 0x7FFFFFFF )
      {
        dword_101E3768 = 0x7FFFFFFF;
        v4 = 0;
LABEL_23:
        *(_DWORD *)v19 = dword_101E3768;
      }
      else
      {
        dword_101E3768 = v29;
        *(_DWORD *)v19 = v29;
      }
      return v4;
    case 5:
      if ( (unsigned int)(v5 - dword_101E371C) > 0x3E8 )
      {
        dword_101E371C = v5;
        flt_101E3738 = sub_10011E70();
        v10 = 9.8999998e24;
        if ( flt_101E3738 < 9.8999998e24 )
          v10 = flt_101E3738;
        *(float *)&v20 = v10;
        flt_101E3738 = *(float *)&v20;
      }
      *v19 = flt_101E3738;
      return v4;
    case 6:
      if ( (unsigned int)(v5 - dword_101E3774) > 0x3E8 )
      {
        dword_101E3774 = v5;
        LOBYTE(v11) = sub_10009C40();
        if ( !sub_1005CCF0(v11, (int)&v20, (int)&dword_101E373C) )
        {
          dword_101E373C = 0x7FFFFFFF;
          v4 = 0;
        }
      }
      *(_DWORD *)v19 = dword_101E373C;
      return v4;
    case 7:
      if ( (unsigned int)(v5 - dword_101E3790) > 0x3E8 )
      {
        dword_101E3790 = v5;
        LOBYTE(v12) = sub_10009C40();
        if ( !sub_1005CCF0(v12, (int)&v20, (int)&dword_101E3710) )
        {
          dword_101E3710 = 0x7FFFFFFF;
          v4 = 0;
        }
      }
      *(_DWORD *)v19 = dword_101E3710;
      return v4;
    case 8:
      if ( (unsigned int)(v5 - dword_101E3770) > 0x3E8 )
      {
        dword_101E3770 = v5;
        flt_101E3730 = sub_1001B0B0();
      }
      *v19 = flt_101E3730;
      return v4;
    case 9:
      if ( (unsigned int)(v5 - dword_101E3734) > 0x3E8 )
      {
        dword_101E3734 = v5;
        flt_101E370C = v30;
      }
      *v19 = flt_101E370C;
      return v4;
    case 0xA:
      if ( (unsigned int)(v5 - dword_101E3798) > 0x3E8 )
      {
        dword_101E3798 = v5;
        if ( !sub_10020720(&flt_101E3784) )
        {
          v4 = 0;
          flt_101E3784 = 9.8999998e24;
        }
      }
      v7 = flt_101E3784;
      goto LABEL_88;
    case 0xB:
      if ( (unsigned int)(v5 - dword_101E3794) <= 0x3E8 )
        goto LABEL_54;
      *(float *)&v20 = 0.0;
      dword_101E3794 = v5;
      if ( sub_100227D0((float *)&v20) )
      {
        if ( sub_10021410(0x11u, 0) == 4 )
          v13 = 1.0;
        else
          v13 = 0.55555558;
        v14 = v13;
        flt_101E3718 = sub_10022870(*(float *)&v20, flt_101E3718, 40, v14);
LABEL_54:
        v7 = flt_101E3718;
      }
      else
      {
        v4 = 0;
        flt_101E3718 = 9.8999998e24;
        v7 = (float)9.8999998e24;
      }
      goto LABEL_88;
    case 0xC:
      if ( (unsigned int)(v5 - dword_101E377C) <= 0x3E8 )
        goto LABEL_59;
      dword_101E377C = v5;
      if ( v29 == 0x7FFFFFFF )
      {
        dword_101E379C = 0x7FFFFFFF;
        v4 = 0;
LABEL_59:
        *(_DWORD *)v19 = dword_101E379C;
      }
      else
      {
        dword_101E379C = v29;
        *(_DWORD *)v19 = v29;
      }
      return v4;
    case 0xD:
      if ( (unsigned int)(v5 - dword_101E3748) > 0x3E8 )
      {
        dword_101E3748 = v5;
        if ( !sub_100203E0(0, (int)&v25) || !sub_10011D50((int)&v25, &flt_101E37A0) )
        {
          v4 = 0;
          flt_101E37A0 = 9.8999998e24;
        }
      }
      *v19 = flt_101E37A0;
      return v4;
    case 0xE:
      if ( (unsigned int)(v5 - dword_101E376C) > 0x3E8 )
      {
        dword_101E376C = v5;
        if ( !sub_10022740(&flt_101E3744) )
        {
          v4 = 0;
          flt_101E3744 = 9.8999998e24;
        }
      }
      v7 = flt_101E3744;
      goto LABEL_88;
    case 0xF:
      if ( (unsigned int)(v5 - dword_101E375C) > 0x3E8 )
      {
        dword_101E375C = v5;
        if ( !sub_10005CB0(2, 1, &flt_101E378C) )
        {
          v4 = 0;
          flt_101E378C = 9.8999998e24;
        }
      }
      *v19 = flt_101E378C;
      break;
    case 0x10:
      if ( (unsigned int)(v5 - dword_101E3750) > 0x3E8 )
      {
        dword_101E3750 = v5;
        if ( sub_10020670(&flt_101E3728) )
        {
          v22 = flt_101E3728;
          v15 = sub_100061E0();
          v16 = sub_10005A70(v15);
          *(float *)&v22 = v22 - v16;
          v17 = sub_10047770(*(float *)&v22);
        }
        else
        {
          v17 = 9.8999998e24;
          v4 = 0;
        }
        flt_101E3728 = v17;
      }
      *v19 = flt_101E3728;
      break;
    case 0x11:
      if ( (unsigned int)(v5 - dword_101E3758) > 0x3E8 )
      {
        dword_101E3758 = v5;
        sub_10005F40(&v26);
        flt_101E3760 = v28;
        if ( 9.9999996e24 == v28 || v27 == 1 )
          flt_101E3760 = 9.8999998e24;
      }
      *v19 = flt_101E3760;
      break;
    default:
      if ( (unsigned int)(v5 - dword_101E3764) > 0x3E8 )
      {
        dword_101E3764 = v5;
        if ( !sub_10005DF0(2, &flt_101E3754) )
        {
          v4 = 0;
          flt_101E3754 = 9.8999998e24;
        }
      }
      v7 = flt_101E3754;
LABEL_88:
      *v19 = v7;
      break;
  }
  return v4;
}
// 1001B0B0: using guessed type double sub_1001B0B0(void);
// 101E370C: using guessed type float flt_101E370C;
// 101E3710: using guessed type int dword_101E3710;
// 101E3714: using guessed type int dword_101E3714;
// 101E3718: using guessed type float flt_101E3718;
// 101E371C: using guessed type int dword_101E371C;
// 101E3720: using guessed type int dword_101E3720;
// 101E3724: using guessed type int dword_101E3724;
// 101E3728: using guessed type float flt_101E3728;
// 101E372C: using guessed type int dword_101E372C;
// 101E3730: using guessed type float flt_101E3730;
// 101E3734: using guessed type int dword_101E3734;
// 101E3738: using guessed type float flt_101E3738;
// 101E373C: using guessed type int dword_101E373C;
// 101E3740: using guessed type int dword_101E3740;
// 101E3744: using guessed type float flt_101E3744;
// 101E3748: using guessed type int dword_101E3748;
// 101E374C: using guessed type int dword_101E374C;
// 101E3750: using guessed type int dword_101E3750;
// 101E3754: using guessed type float flt_101E3754;
// 101E3758: using guessed type int dword_101E3758;
// 101E375C: using guessed type int dword_101E375C;
// 101E3760: using guessed type float flt_101E3760;
// 101E3764: using guessed type int dword_101E3764;
// 101E3768: using guessed type int dword_101E3768;
// 101E376C: using guessed type int dword_101E376C;
// 101E3770: using guessed type int dword_101E3770;
// 101E3774: using guessed type int dword_101E3774;
// 101E3778: using guessed type float flt_101E3778;
// 101E377C: using guessed type int dword_101E377C;
// 101E3780: using guessed type float flt_101E3780;
// 101E3784: using guessed type float flt_101E3784;
// 101E3788: using guessed type float flt_101E3788;
// 101E378C: using guessed type float flt_101E378C;
// 101E3790: using guessed type int dword_101E3790;
// 101E3794: using guessed type int dword_101E3794;
// 101E3798: using guessed type int dword_101E3798;
// 101E379C: using guessed type int dword_101E379C;
// 101E37A0: using guessed type float flt_101E37A0;

//----- (10011D50) --------------------------------------------------------
char __cdecl sub_10011D50(int a1, float *a2)
{
  int v2; // edx@1
  int v3; // eax@1
  char result; // al@7
  float *v5; // [sp+4h] [bp-4Ch]@1
  int v6; // [sp+8h] [bp-48h]@1
  int v7; // [sp+Ch] [bp-44h]@1
  __int16 *v8; // [sp+10h] [bp-40h]@1
  int v9; // [sp+14h] [bp-3Ch]@1
  int *v10; // [sp+18h] [bp-38h]@1
  int v11; // [sp+1Ch] [bp-34h]@1
  int v12; // [sp+20h] [bp-30h]@1
  float v13; // [sp+24h] [bp-2Ch]@3
  __int16 v14; // [sp+28h] [bp-28h]@1
  int v15; // [sp+2Ch] [bp-24h]@1
  int v16; // [sp+30h] [bp-20h]@1
  int v17; // [sp+34h] [bp-1Ch]@1
  int v18; // [sp+38h] [bp-18h]@1

  v2 = *(_DWORD *)(a1 + 4);
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v15 = *(_DWORD *)a1;
  v3 = *(_DWORD *)(a1 + 8);
  v18 = *(_DWORD *)(a1 + 12);
  v16 = v2;
  v17 = v3;
  v14 = -32766;
  v12 = 4;
  v8 = &v14;
  v9 = 36;
  v10 = (int *)&v5;
  v11 = 400;
  v5 = a2;
  v6 = 4;
  if ( sub_10004EF0(43, (int)&v8)
    || v6 != 4
    || (v13 = *a2, (LODWORD(v13) & 0x7F800000) == 2139095040)
    || 9.9999996e24 != *a2 && (*a2 < -500.0 || *a2 > 30479.6953125) )
  {
    *a2 = 9.9999996e24;
    result = 0;
  }
  else
  {
    result = v7;
  }
  return result;
}

//----- (10011E70) --------------------------------------------------------
double sub_10011E70()
{
  double result; // st7@2
  float v1; // [sp+0h] [bp-4h]@2

  if ( (unsigned __int8)sub_10020B90() )
  {
    sub_10004EC0(100, 60000);
    v1 = *(float *)(dword_101E7420 + 12);
    sub_10004EA0(100);
    result = v1;
    if ( (LODWORD(v1) & 0x7F800000) == 2139095040 )
    {
      result = (float)9.9999996e24;
    }
    else if ( 9.9999996e24 != result )
    {
      if ( v1 >= -500.0 && v1 <= 30479.6953125 )
        result = v1;
      else
        result = (float)9.9999996e24;
    }
  }
  else
  {
    result = 9.9999996e24;
  }
  return result;
}
// 101E7420: using guessed type int dword_101E7420;

//----- (10011F10) --------------------------------------------------------
char __cdecl sub_10011F10(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  char *v6; // edi@4
  signed int v7; // eax@4
  unsigned int v8; // ST1C_4@4
  int v9; // eax@4
  unsigned int v10; // ST18_4@4
  char *v11; // eax@4
  __int16 v12; // dx@4
  int v13; // ST10_4@4
  signed int v14; // eax@4
  __int16 v15; // dx@4
  int v16; // edx@4
  int v17; // eax@6
  int v18; // edi@7
  int v19; // ebx@7
  char *v20; // eax@7
  int v21; // [sp+8h] [bp-18h]@4
  int v22; // [sp+Ch] [bp-14h]@4
  int v23; // [sp+10h] [bp-10h]@4
  __int16 v24; // [sp+14h] [bp-Ch]@4
  int v25; // [sp+16h] [bp-Ah]@4
  int v26; // [sp+1Ch] [bp-4h]@4

  result = 1;
  if ( *a5 == 32802 )
  {
LABEL_4:
    v6 = sub_1001FFA0(*a4);
    v7 = sub_10015380(*(_DWORD *)(a2 + 4));
    v8 = *(_DWORD *)(a2 + 4);
    v22 = v7;
    v9 = sub_10015AD0(v8, 0);
    v10 = *(_DWORD *)(a2 + 4);
    v23 = v9;
    v25 = sub_10015310(v10);
    v11 = sub_10015340(*(_DWORD *)(a2 + 4));
    v12 = *(_WORD *)(a2 + 8);
    v13 = *(_DWORD *)(a2 + 4);
    v21 = *(_DWORD *)v11;
    v24 = v12;
    v14 = sub_100153B0(v13);
    v15 = *(_WORD *)a3;
    v26 = v14;
    *(_WORD *)(a1 + 438) = v15;
    v16 = v21;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    sub_10015B30(a1, v6, &v21, *(_WORD *)(v16 + 30));
    return 2;
  }
  if ( *a5 != 32832 )
  {
    if ( *a5 != 32888 )
      return result;
    goto LABEL_4;
  }
  LOWORD(v17) = *(_WORD *)(a2 + 8);
  if ( (_WORD)v17 )
  {
    v17 = (signed __int16)v17;
  }
  else
  {
    v18 = sub_10015380(*(_DWORD *)(a2 + 4));
    v19 = *(_DWORD *)sub_10015340(*(_DWORD *)(a2 + 4));
    v20 = sub_1001FFA0(*a4);
    v17 = sub_10007120(v19, v20, v18);
  }
  sub_10015D40(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(a2 + 4), v17);
  return 2;
}

//----- (10012040) --------------------------------------------------------
void *__cdecl sub_10012040(int a1, __int16 a2)
{
  void *result; // eax@1

  result = memset((void *)(*(_DWORD *)(a1 + 56) + 69), 95, a2);
  *(_BYTE *)(*(_DWORD *)(a1 + 56) + a2 + 69) = 0;
  return result;
}

//----- (10012070) --------------------------------------------------------
char __cdecl sub_10012070(int a1, int a2, char *a3)
{
  char *v3; // edx@1
  _BYTE *v4; // eax@1
  char v5; // cl@2

  v3 = a3;
  v4 = (_BYTE *)(*(_DWORD *)(a1 + 56) + 69);
  do
  {
    v5 = *v3;
    *v4++ = *v3++;
  }
  while ( v5 );
  sub_1001E1C0((const char *)(*(_DWORD *)(a1 + 56) + 69), 32, 95);
  sub_1001E170((const char *)(*(_DWORD *)(a1 + 56) + 69), *(_WORD *)(a2 + 10), 95);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = 0;
  return 4;
}

//----- (100120D0) --------------------------------------------------------
int __cdecl sub_100120D0(int a1, int a2, int a3, signed int a4, int a5)
{
  int v5; // edi@1
  unsigned int v6; // ecx@1
  char v7; // al@6
  int v8; // eax@8
  __int16 v9; // dx@8
  __int64 v10; // rax@9
  float v11; // ST10_4@9

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(a1 + 4) & 0xC000 )
  {
    if ( (*(_DWORD *)(a1 + 4) & 0xC000) == 0x4000 )
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8);
    else
      LOWORD(a1) = *(_WORD *)a2 + *(_WORD *)(a1 + 8) / 2;
  }
  else
  {
    LOWORD(a1) = *(_WORD *)a2;
  }
  v7 = *(_BYTE *)(v5 + 15);
  if ( *(_BYTE *)(v5 + 15) & 6 )
  {
    if ( (*(_BYTE *)(v5 + 15) & 6) == 2 )
    {
      v10 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
      v11 = 0.5 * (double)(a5 + 1);
      HIWORD(a1) = (signed int)((double)(*(_WORD *)(v5 + 12) / 2
                                       + (((signed int)v10 - HIDWORD(v10)) >> 1)
                                       + *(_WORD *)(a2 + 2)
                                       - 1)
                              + 0.5
                              + (1.0 - v11) * (double)a4);
      return a1;
    }
    v8 = sub_10015AD0(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) + *(_WORD *)(v5 + 12) - a4 * a5 - *(_WORD *)(a3 + 26);
  }
  else
  {
    v8 = sub_10015AD0(v6, (v7 & 1) == 1);
    v9 = *(_WORD *)(a3 + 24) - *(_WORD *)(a3 + 26);
  }
  HIWORD(a1) = BYTE2(v8) + *(_WORD *)(a2 + 2) + v9 - 1;
  return a1;
}

//----- (10012220) --------------------------------------------------------
char __usercall sub_10012220@<al>(char *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4@<esi>)
{
  int v4; // eax@3
  int v5; // ecx@3
  char result; // al@4
  int v7; // eax@5
  int v8; // eax@7

  if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) == -128 )
  {
    sub_10012070(a4, a3, a1);
    sub_10012040(a4, *(_WORD *)(a3 + 10));
  }
  v4 = *(_DWORD *)(a4 + 56);
  v5 = *(_WORD *)(v4 + 240);
  if ( *(_WORD *)(a2 + 10) == 0x2000 )
  {
    *(_BYTE *)(v5 + v4 + 69) = *(_BYTE *)(a2 + 14);
    v7 = *(_DWORD *)(a4 + 56);
    if ( *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) == 32 )
      *(_BYTE *)(*(_WORD *)(v7 + 240) + v7 + 69) = 95;
    ++*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    v8 = *(_WORD *)(a3 + 10) - 1;
    if ( *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) < v8 )
      LOWORD(v8) = *(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) = v8;
    result = 2;
  }
  else
  {
    *(_BYTE *)(v5 + v4 + 69) = 95;
    --*(_WORD *)(*(_DWORD *)(a4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(a4 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a4 + 56) + 240) <= 0) - 1;
    result = 2;
  }
  return result;
}

//----- (100122E0) --------------------------------------------------------
char __usercall sub_100122E0@<al>(unsigned __int16 a1@<di>, int a2)
{
  char v2; // bl@1
  char v3; // al@1
  int v4; // esi@1
  int v5; // eax@1
  char result; // al@2

  v2 = 0;
  v3 = sub_1001DF60(0, a1, 1);
  v4 = (unsigned __int8)v3;
  v5 = (unsigned __int8)sub_1001DF60(v3, a1, 1);
  if ( v4 == a2 )
  {
    result = 1;
  }
  else
  {
    if ( v5 != v4 )
    {
      do
      {
        if ( v5 == a2 )
          v2 = 1;
        v5 = (unsigned __int8)sub_1001DF60(v5, a1, 1);
      }
      while ( (unsigned __int8)v5 != v4 );
    }
    result = v2;
  }
  return result;
}

//----- (10012340) --------------------------------------------------------
signed int __usercall sub_10012340@<eax>(int a1@<edi>, unsigned __int16 a2@<si>, int a3)
{
  char v3; // bl@8
  signed int result; // eax@8
  char v5; // [sp+4h] [bp-4h]@0

  if ( (signed int)a2 <= 177 )
  {
    if ( a2 != 177 )
    {
      switch ( a2 )
      {
        case 0x51u:
        case 0x91u:
          goto LABEL_8;
        case 0x10u:
        case 0x14u:
          goto LABEL_9;
        case 0x92u:
          goto LABEL_11;
        default:
          goto LABEL_12;
      }
      goto LABEL_12;
    }
LABEL_8:
    v3 = 65;
    LOBYTE(result) = sub_1001DF60(65, a2, -1);
    goto LABEL_13;
  }
  if ( (signed int)a2 > 528 )
  {
    if ( a2 != 1043 )
      goto LABEL_12;
LABEL_11:
    v3 = 97;
    LOBYTE(result) = sub_1001DF60(97, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 528 )
  {
LABEL_9:
    v3 = 48;
    LOBYTE(result) = sub_1001DF60(48, a2, -1);
    goto LABEL_13;
  }
  if ( a2 == 178 )
    goto LABEL_11;
  if ( a2 == 273 )
    goto LABEL_8;
LABEL_12:
  v3 = v5;
  LOBYTE(result) = sub_1001DF60(v5, a2, -1);
LABEL_13:
  if ( a3 == 95 )
  {
    if ( a1 > 0 )
      return (unsigned __int8)v3;
  }
  else
  {
    if ( a3 == (unsigned __int8)v3 && a1 < 0 || a3 == (unsigned __int8)result && a1 > 0 )
      return 95;
    do
    {
      LOBYTE(result) = sub_1001DF60(a3, a2, a1);
      LOBYTE(a3) = result;
    }
    while ( (_BYTE)result == 95 );
  }
  return (unsigned __int8)result;
}

//----- (100124A0) --------------------------------------------------------
signed int __cdecl sub_100124A0(int a1, int a2, signed int a3)
{
  __int16 v3; // si@1
  signed int result; // eax@1
  int v5; // edi@1
  int v6; // ebx@2
  bool v7; // zf@2

  v3 = sub_1001D020(*(_DWORD *)(a2 + 4));
  result = a3;
  v5 = 2 * (a3 >= 0) - 1;
  if ( a3 )
  {
    do
    {
      v6 = *(_DWORD *)(a1 + 56);
      result = sub_10012340(v5, v3, *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69));
      v7 = a3 == v5;
      a3 -= v5;
      *(_BYTE *)(*(_WORD *)(v6 + 240) + v6 + 69) = result;
    }
    while ( !v7 );
  }
  return result;
}

//----- (10012500) --------------------------------------------------------
char __cdecl sub_10012500(int a1, int a2, int a3, char *a4)
{
  int v4; // esi@1
  char v5; // bl@1
  bool v6; // zf@1
  signed int v7; // eax@3
  unsigned int v8; // ST24_4@3
  int v9; // eax@3
  int v10; // ST1C_4@3
  __int16 v11; // ax@3
  int v12; // eax@6
  int v13; // eax@6
  char *v14; // ebx@6
  bool v15; // al@9
  int v16; // eax@11
  int v17; // eax@13
  int v18; // eax@13
  int v19; // ST1C_4@18
  int v21; // [sp+10h] [bp-28h]@1
  int v22; // [sp+14h] [bp-24h]@1
  int v23; // [sp+18h] [bp-20h]@1
  int v24; // [sp+1Ch] [bp-1Ch]@6
  int v25; // [sp+20h] [bp-18h]@3
  int v26; // [sp+24h] [bp-14h]@3
  int v27; // [sp+28h] [bp-10h]@3
  __int16 v28; // [sp+2Ch] [bp-Ch]@5
  int v29; // [sp+2Eh] [bp-Ah]@3
  int v30; // [sp+34h] [bp-4h]@3
  int v31; // [sp+40h] [bp+8h]@13

  v4 = a2;
  v5 = 0;
  v6 = *(_BYTE *)a2 == 124;
  LOBYTE(v23) = 0;
  v21 = 0;
  v22 = 0;
  if ( v6 )
  {
    v5 = *(_BYTE *)(a2 + 14);
    LOBYTE(v23) = (*(_BYTE *)(a2 + 15) & 1) == 1;
  }
  v25 = sub_10015360(*(_DWORD *)(a2 + 4));
  v7 = sub_10015380(*(_DWORD *)(a2 + 4));
  v8 = *(_DWORD *)(a2 + 4);
  v26 = v7;
  v27 = sub_10015AD0(v8, v23);
  v9 = sub_10015310(*(_DWORD *)(a2 + 4));
  v10 = *(_DWORD *)(a2 + 4);
  v29 = v9;
  v30 = sub_100153B0(v10);
  v11 = *(_WORD *)(a2 + 8);
  if ( !v11 )
    v11 = sub_10007120(v25, a4, v26);
  v6 = *(_BYTE *)a2 == 124;
  v28 = v11;
  if ( v6 )
  {
    sub_10015E10(a4, *(_DWORD *)(a2 + 4), *(_BYTE *)(a2 + 14), (int)&v24, (int)&v22);
    v23 = v5;
    v12 = sub_1001B480(a4, v25, v27, *(_WORD *)(a2 + 12), v5, &v21);
    v13 = sub_10002760(a1, v12);
    v14 = (char *)v13;
    if ( v21 > 0 )
    {
      v15 = !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128;
      v16 = sub_1001B4F0((int)a4, v25, 0, *(_WORD *)(a2 + 8), v21, v15, v14);
      v22 = v16;
      if ( v16 == -1 )
      {
        v16 = v21;
        v22 = v21;
      }
      v17 = sub_100120D0(a2, a3, v25, v24, v16);
      v6 = *(_BYTE *)(a1 + 3) == 0;
      v31 = v17;
      v18 = v29;
      *(_WORD *)(a1 + 396) = 3;
      if ( !v6 && *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 && (byte_101B1070 || byte_101E3280) )
      {
        *(_WORD *)(a1 + 428) = HIWORD(v18);
        *(_WORD *)(a1 + 430) = v29;
        v18 = *(_DWORD *)(a1 + 428);
      }
      *(_WORD *)(a1 + 440) = v18;
      *(_WORD *)(a1 + 442) = v18;
      sub_10008300(a1 + 392, *(_WORD *)a3 - 1, *(_WORD *)(a3 + 2), *(_WORD *)(v4 + 8) + 2, *(_WORD *)(v4 + 12));
      v19 = v23;
      *(_WORD *)(a1 + 438) = v31;
      *(_WORD *)(a1 + 436) = HIWORD(v31);
      LOBYTE(v13) = sub_10015B30(a1, v14, &v25, v19);
    }
    if ( v14 )
      LOBYTE(v13) = sub_10002420(a1, (unsigned int)v14);
  }
  else
  {
    *(_WORD *)(a1 + 438) = *(_WORD *)a3;
    *(_WORD *)(a1 + 436) = *(_WORD *)(a3 + 2);
    LOBYTE(v13) = sub_10015A90(a1, a4, &v25);
  }
  return v13;
}
// 101B1070: using guessed type char byte_101B1070;
// 101E3280: using guessed type char byte_101E3280;

//----- (10012760) --------------------------------------------------------
char __cdecl sub_10012760(int a1, int a2, int a3, char *a4)
{
  int v4; // ebp@1
  signed __int16 v5; // di@1
  int v6; // ecx@1
  int v7; // eax@1
  int v8; // ecx@4
  char v9; // bl@4
  char result; // al@10
  char v11; // bl@11
  char v12; // al@13
  int v13; // eax@18
  int v14; // eax@19
  int v15; // eax@24
  int v16; // [sp+18h] [bp+8h]@1

  v4 = a2;
  LOWORD(v7) = sub_1001D020(*(_DWORD *)(a2 + 4));
  v5 = *(_WORD *)(a3 + 14);
  v6 = (unsigned __int16)v7;
  LOWORD(v7) = *(_WORD *)(a3 + 10);
  v16 = v6;
  if ( (_WORD)v7 == 0x2000 && v5 == 32 )
    v5 = 95;
  v8 = *(_DWORD *)(a1 + 56);
  v9 = 1;
  if ( *(_WORD *)(v8 + 240) == -128 )
  {
    if ( !(*(_DWORD *)(v4 + 4) & 0x200000) )
    {
      v7 = (unsigned __int16)v7;
      if ( (signed int)(unsigned __int16)v7 <= 73 )
      {
        if ( (unsigned __int16)v7 != 73 )
        {
          if ( v7 == 32 )
          {
            v11 = sub_10012070(a1, v4, a4);
            sub_10012040(a1, *(_WORD *)(v4 + 10));
            return v11;
          }
          if ( v7 == 56 )
            return sub_10012070(a1, v4, a4);
          return v9;
        }
        return sub_10012220(a4, a3, v4, a1);
      }
      if ( v7 == 0x2000 )
      {
        v12 = sub_100122E0(v16, (unsigned __int16)v5);
        goto LABEL_14;
      }
    }
    return v9;
  }
  v7 = (unsigned __int16)v7;
  if ( (signed int)(unsigned __int16)v7 > 57 )
  {
    if ( v7 == 73 )
      return sub_10012220(a4, a3, v4, a1);
    if ( v7 == 0x2000 )
    {
      v12 = sub_100122E0(v16, (unsigned __int16)v5);
LABEL_14:
      if ( v12 )
        return sub_10012220(a4, a3, v4, a1);
    }
    return v9;
  }
  if ( (unsigned __int16)v7 != 57 )
  {
    v13 = v7 - 32;
    if ( !v13 )
    {
      result = 6;
      *(_WORD *)(v8 + 240) = -128;
      return result;
    }
    v14 = v13 - 1;
    if ( !v14 )
    {
      *(_WORD *)(v8 + 240) = -128;
      sub_1001E1C0((const char *)(*(_DWORD *)(a1 + 56) + 69), 95, 32);
      sub_1001E3A0(*(_DWORD *)(a1 + 56) + 69, 0);
      return 3;
    }
    if ( v14 == 23 )
    {
      sub_100124A0(a1, v4, *(_BYTE *)(a3 + 8));
      return 2;
    }
    return v9;
  }
  *(_WORD *)(v8 + 240) += *(_BYTE *)(a3 + 8);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) &= ((signed int)*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) <= 0) - 1;
  v15 = *(_WORD *)(v4 + 10) - 1;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) < v15 )
    LOWORD(v15) = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) = v15;
  return 2;
}

//----- (10012950) --------------------------------------------------------
char __cdecl sub_10012950(int a1, int a2, int a3, char *a4, int a5)
{
  int v5; // esi@1
  __int16 v6; // ax@1
  char *v7; // edi@1
  __int16 v8; // bx@3
  int v9; // ebp@3
  __int16 v10; // di@5
  int v11; // eax@5
  char result; // al@5
  char *v13; // eax@10
  char *v14; // edx@10
  char v15; // cl@11
  int v16; // ecx@14
  char v17; // [sp+13h] [bp-5h]@1
  int v18; // [sp+14h] [bp-4h]@5

  v5 = a2;
  v6 = *(_WORD *)(a2 + 8);
  v7 = a4;
  v17 = 1;
  if ( !v6 )
    v6 = sub_10015960(a4, *(_DWORD *)(a2 + 4));
  v8 = v6;
  v9 = *(_DWORD *)sub_10015340(*(_DWORD *)(v5 + 4));
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      if ( *(_BYTE *)v5 == 124 )
      {
        v10 = sub_10015E10(v7, *(_DWORD *)(v5 + 4), *(_BYTE *)(v5 + 14), (int)&v18, (int)&a2);
        v11 = sub_100120D0(v5, a3, v9, v18, a2);
        sub_10015D40(a1 + 276, v11, *(_DWORD *)(v5 + 4), v8);
        *(_WORD *)(a1 + 282) = v10 + *(_WORD *)(a1 + 278);
        result = 2;
      }
      else
      {
        sub_10015D40(a1 + 276, *(_DWORD *)a3, *(_DWORD *)(v5 + 4), v8);
        result = 2;
      }
      break;
    case 0x8048:
      v17 = sub_10012760(a1, v5, a5, v7);
      switch ( v17 )
      {
        case 2:
        case 4:
          sub_10012500(a1, v5, a3, (char *)(*(_DWORD *)(a1 + 56) + 69));
          result = v17;
          break;
        case 6:
          sub_10012500(a1, v5, a3, v7);
          result = v17;
          break;
        case 3:
          v13 = (char *)(*(_DWORD *)(a1 + 56) + 69);
          v14 = v7;
          do
          {
            v15 = *v13;
            *v14++ = *v13++;
          }
          while ( v15 );
          sub_10012500(a1, v5, a3, v7);
          result = v17;
          break;
        default:
          goto LABEL_18;
      }
      break;
    case 0x8022:
    case 0x8078:
      if ( *(_BYTE *)(a1 + 3) && (v16 = *(_DWORD *)(a1 + 56), *(_WORD *)(v16 + 240) != -128) )
        sub_10012500(a1, v5, a3, (char *)(v16 + 69));
      else
        sub_10012500(a1, v5, a3, v7);
      v17 = 2;
      goto LABEL_18;
    default:
LABEL_18:
      result = v17;
      break;
  }
  return result;
}

//----- (10012BB0) --------------------------------------------------------
char __cdecl sub_10012BB0(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // cx@4
  unsigned int v7; // eax@4
  __int16 v8; // cx@4
  int v9; // eax@4
  int v10; // ecx@8
  __int16 v11; // bp@8
  __int16 *v12; // ebx@9
  char v13; // dl@10
  __int16 v14; // ax@14
  __int16 v15; // cx@16
  int v16; // [sp+4h] [bp-14h]@9
  __int16 v17; // [sp+8h] [bp-10h]@4
  __int16 v18; // [sp+Ch] [bp-Ch]@4
  __int16 v19; // [sp+Eh] [bp-Ah]@4
  __int16 v20; // [sp+10h] [bp-8h]@4
  __int16 v21; // [sp+12h] [bp-6h]@4
  __int16 v22; // [sp+14h] [bp-4h]@4
  __int16 v23; // [sp+16h] [bp-2h]@4
  int v24; // [sp+2Ch] [bp+14h]@9

  result = 1;
  if ( *a5 != 32802 )
  {
    if ( *a5 == 32832 )
    {
      *(_WORD *)(a1 + 276) = *(_WORD *)a3;
      *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
      *(_WORD *)(a1 + 280) = *(_WORD *)a3 + *(_WORD *)(a2 + 4) - 1;
      result = 2;
      *(_WORD *)(a1 + 282) = *(_WORD *)(a3 + 2) + *(_WORD *)(a2 + 6) - 1;
      return result;
    }
    if ( *a5 != 32888 )
      return result;
  }
  v18 = word_1010FC78[1];
  v19 = word_1010FC78[0];
  v20 = word_1010FC78[0];
  v21 = word_1010FC78[0];
  v22 = word_1010FC78[0];
  v6 = word_1010FC78[(unsigned __int8)sub_100213C0(15)];
  v7 = *(_WORD *)(a2 + 8);
  v23 = v6;
  v8 = v7;
  v9 = ((v7 >> 12) & 3) + 1;
  *(_WORD *)(a1 + 426) = v9;
  *(_WORD *)(a1 + 424) = v9;
  v17 = v8 & 0xC00;
  if ( (*(_WORD *)(a2 + 8) & 0xC000) == -32768 )
  {
    *(_WORD *)(a1 + 398) = 1;
    *(_DWORD *)(a1 + 452) = &unk_10061AC0;
    *(_WORD *)(a1 + 440) = 0;
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a1 + 440) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 442) = *(_WORD *)(a4 + 2);
    *(_WORD *)(a1 + 398) = 3;
  }
  v10 = 3 - v9;
  v11 = 0;
  if ( 3 - v9 < 3 )
  {
    v24 = v10 + 1;
    v12 = &v18 + 2 * v10;
    v16 = 3 - v10;
    do
    {
      v13 = 2;
      if ( v24 >= 3 && (*(_WORD *)(a2 + 8) & 0xC000) != 0x4000 )
        v13 = 3;
      if ( v17 == 2048 )
      {
        *(_WORD *)(a1 + 428) = *(_WORD *)a4;
        v14 = *(_WORD *)a4;
      }
      else
      {
        if ( v17 )
        {
          v15 = v12[1];
          v14 = *v12;
        }
        else
        {
          v15 = *v12;
          v14 = v12[1];
        }
        *(_WORD *)(a1 + 428) = v15;
      }
      *(_WORD *)(a1 + 430) = v14;
      sub_1005C3A0(
        a1 + 392,
        v11 + *(_WORD *)a3,
        v11 + *(_WORD *)(a3 + 2),
        *(_WORD *)(a2 + 4) - 2 * v11,
        *(_WORD *)(a2 + 6) - 2 * v11,
        v13);
      ++v24;
      v12 += 2;
      ++v11;
      --v16;
    }
    while ( v16 );
  }
  return 2;
}
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (10012DE0) --------------------------------------------------------
char __cdecl sub_10012DE0(int a1, int a2, int a3, _BYTE *a4, _WORD *a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // ST10_1@2
  __int16 v8; // cx@2
  __int16 v9; // ax@2
  __int16 v11; // [sp+10h] [bp-14h]@4
  __int16 v12; // [sp+12h] [bp-12h]@4
  int v13; // [sp+14h] [bp-10h]@1
  int v14; // [sp+18h] [bp-Ch]@1
  int v15; // [sp+1Ch] [bp-8h]@1

  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 4);
  v13 = *(_DWORD *)a2;
  v14 = v6;
  v15 = v5;
  if ( (_WORD)v5 == -1 )
  {
    v7 = *a4 & 0x1F;
    LOWORD(v15) = *(_WORD *)a4;
    v8 = word_1010FC78[(unsigned __int8)sub_100213C0(v7)];
    v9 = word_1010FC78[((unsigned int)*(_WORD *)a4 >> 5) & 0x1F];
  }
  else
  {
    v8 = word_1010FC78[(unsigned __int8)sub_100213C0(v5 & 0x1F)];
    v9 = word_1010FC78[((unsigned int)*(_WORD *)(a2 + 8) >> 5) & 0x1F];
  }
  v11 = v8;
  v12 = v9;
  return sub_10012BB0(a1, (int)&v13, a3, (int)&v11, a5);
}
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (10012EC0) --------------------------------------------------------
int __cdecl sub_10012EC0(unsigned int a1, char a2, int a3, int a4)
{
  int result; // eax@1

  result = a3 * byte_101E37F1[20 * ((a1 >> 10) & 0xF)]
         + (a3 - 1) * *(_WORD *)(dword_101E37E4[5 * ((a1 >> 10) & 0xF)] + 28);
  if ( a4 > 0 )
  {
    if ( a2 & 0x80 )
      result += *((_BYTE *)&unk_101E37E0 + 20 * ((a1 >> 10) & 0xF) + 15) - byte_101E37F1[20 * ((a1 >> 10) & 0xF)];
  }
  return result;
}
// 101E37E4: using guessed type int dword_101E37E4[];

//----- (10012F20) --------------------------------------------------------
char __cdecl sub_10012F20(int a1, int a2, int a3, double *a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  unsigned int v6; // ecx@1
  int v7; // eax@1
  __int16 v8; // bx@1
  double v9; // st7@3
  __int16 v10; // cx@5
  __int16 v11; // cx@5
  int v12; // ebx@8
  size_t v13; // edi@9
  int v14; // eax@9
  int v15; // edx@14
  __int16 v16; // ax@14
  float v17; // ST4C_4@20
  char *v18; // edi@27
  char v19; // al@28
  char *v20; // edi@30
  char v21; // al@31
  char v22; // al@33
  char *v23; // eax@35
  char v24; // cl@36
  signed int v25; // ecx@37
  char v26; // cl@38
  int v27; // ecx@40
  int v28; // edi@43
  int i; // eax@47
  char v30; // dl@50
  signed int v31; // ecx@52
  char v32; // al@53
  int v33; // eax@63
  signed int v34; // ebx@69
  signed int v35; // eax@69
  unsigned int v36; // ST18_4@71
  char *v37; // eax@71
  int v38; // edi@80
  unsigned int v39; // ebx@80
  __int16 v40; // ax@80
  bool v42; // [sp+2Fh] [bp-59h]@21
  int v43; // [sp+30h] [bp-58h]@1
  int v44; // [sp+30h] [bp-58h]@14
  int v45; // [sp+34h] [bp-54h]@1
  char *v46; // [sp+38h] [bp-50h]@14
  char v47; // [sp+3Ch] [bp-4Ch]@71
  char v48; // [sp+3Dh] [bp-4Bh]@71
  char v49; // [sp+3Eh] [bp-4Ah]@71
  int v50; // [sp+40h] [bp-48h]@3
  int v51; // [sp+44h] [bp-44h]@1
  int v52; // [sp+48h] [bp-40h]@1
  int v53; // [sp+4Ch] [bp-3Ch]@1
  double v54; // [sp+50h] [bp-38h]@5
  char v55[2]; // [sp+58h] [bp-30h]@21
  char v56; // [sp+63h] [bp-25h]@12
  char v57; // [sp+64h] [bp-24h]@9
  char v58; // [sp+65h] [bp-23h]@64

  v4 = a2;
  v5 = *(_BYTE *)a2 == 89;
  v45 = *(_BYTE *)(a2 + 10);
  v6 = *(_WORD *)(a2 + 8);
  v53 = a1;
  v7 = *(_BYTE *)(a2 + 11);
  v8 = v6;
  v52 = a2;
  v51 = (unsigned __int16)v6;
  v43 = v7;
  if ( v5 && 9.899999762399947e24 != *a4 )
  {
    *(float *)&v50 = *a4;
    v9 = sub_10021830(v50, v6);
  }
  else
  {
    *(float *)&v50 = 9.8999998e24;
    v9 = *a4;
  }
  v10 = *(_WORD *)(a2 + 8);
  v54 = v9;
  v11 = v10 & 0x3F;
  if ( v11 == 28 )
  {
    if ( v9 > 1.0 || v9 < 0.0 )
    {
LABEL_8:
      v12 = v53;
LABEL_9:
      v13 = *(_BYTE *)(v4 + 10);
      memset(&v57, 95, v13);
      v14 = v43;
      if ( v43 > 0 )
      {
        if ( (signed int)(v13 - v43) <= 1 )
          v14 = v13 - 2;
        *(&v56 + v13 - v14) = 46;
      }
      *(&v57 + v13) = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( v9 >= 1.0e25 )
      goto LABEL_8;
    if ( v9 <= -1.0e25 )
      goto LABEL_8;
    if ( 9.899999762399947e24 == v9 )
      goto LABEL_8;
    v17 = v9;
    if ( v17 == 9.8999998e24 )
      goto LABEL_8;
  }
  v42 = 1;
  strcpy(v55, "%");
  if ( v8 & 0x800 || v8 & 0x40 || v11 == 27 || v11 == 28 )
  {
    ++v45;
    v18 = (char *)&v54 + 7;
    do
      v19 = (v18++)[1];
    while ( v19 );
    *(_WORD *)v18 = 43;
  }
  else if ( v11 == 7 )
  {
    ++v45;
  }
  v20 = (char *)&v54 + 7;
  if ( v8 & 0x100 )
  {
    do
      v21 = (v20++)[1];
    while ( v21 );
    *(_WORD *)v20 = 48;
  }
  else
  {
    do
      v22 = (v20++)[1];
    while ( v22 );
    *(_WORD *)v20 = 45;
  }
  v23 = (char *)&v54 + 7;
  if ( v11 == 7 )
  {
    do
      v24 = (v23++)[1];
    while ( v24 );
    v25 = 1697263146;
  }
  else
  {
    do
      v26 = (v23++)[1];
    while ( v26 );
    v25 = 1714040362;
  }
  *(_DWORD *)v23 = v25;
  v27 = *(_BYTE *)(a2 + 10);
  v23[4] = 0;
  v12 = _snprintf(&v57, 0x1Eu, v55, v27, *(_BYTE *)(a2 + 11), LODWORD(v9), (_DWORD)(*(unsigned __int64 *)&v9 >> 32));
  if ( v12 > v45 )
  {
    v42 = 0;
    if ( !(v51 & 0x80) && v43 > 0 )
    {
      v28 = v43;
      do
      {
        if ( v42 )
          break;
        v12 = sprintf(&v57, v55, *(_BYTE *)(a2 + 10), --v28, v54);
        v42 = v12 <= v45;
      }
      while ( v28 > 0 );
      v43 = v28;
    }
  }
  for ( i = v12 - 1; i >= 0; --i )
  {
    if ( *(&v57 + i) != 32 )
      break;
    *(&v57 + i) = 0;
    --v12;
  }
  v30 = 1;
  if ( v57 == 45 || v57 == 43 )
  {
    v31 = 1;
    if ( v12 <= 1 )
      goto LABEL_89;
    do
    {
      v32 = *(&v57 + v31);
      if ( v32 != 46 && v32 != 48 && v32 != 101 && v32 != 43 )
      {
        v30 = 0;
        v31 = v12;
      }
      ++v31;
    }
    while ( v31 < v12 );
    if ( v30 )
    {
LABEL_89:
      if ( (*(_WORD *)(a2 + 8) & 0x3F) == 17 && *(_WORD *)(a2 + 8) & 0x40 )
      {
        v57 = 43;
      }
      else
      {
        --v12;
        v33 = 0;
        if ( v12 > 0 )
        {
          qmemcpy(&v57, &v58, v12);
          v4 = v52;
          v33 = v12;
        }
        *(&v57 + v33) = 0;
      }
    }
  }
  if ( !v42 )
    goto LABEL_9;
LABEL_14:
  v46 = sub_10021080(*(_WORD *)(v4 + 8), (float *)&v50);
  v15 = (signed __int16)sub_100159C0(*(_DWORD *)(v4 + 4), *(_WORD *)(v4 + 8), (float *)&v50);
  v16 = *(_WORD *)(v4 + 8) & 0x3F;
  v44 = v15;
  if ( v16 == 27 )
  {
    if ( v57 == 45 )
    {
      v57 = -100;
    }
    else if ( v57 == 43 )
    {
      --v45;
      v34 = v12 - 1;
      v35 = 0;
      if ( v34 > 0 )
      {
        qmemcpy(&v57, &v58, v34);
        v4 = v52;
        v35 = v34;
      }
      *(&v57 + v35) = 0;
      v36 = *(_DWORD *)(v4 + 4);
      v47 = *v46;
      v48 = -99;
      v49 = 0;
      v46 = &v47;
      v37 = sub_10015340(v36);
      v44 += sub_10007120(*((_DWORD *)v37 + 1), "", 0);
    }
  }
  else if ( v16 == 28 && !strncmp(&v57, "+0.", 3u) )
  {
    strncpy(&v57, "M ", 2u);
  }
  if ( v51 & 0x800 )
  {
    if ( v57 == 45 )
    {
      v57 = -92;
    }
    else if ( v57 == 43 )
    {
      v57 = -93;
    }
  }
  v38 = v53;
  *(_WORD *)(v53 + 438) = *(_WORD *)a3;
  *(_WORD *)(v38 + 436) = *(_WORD *)(a3 + 2);
  v39 = *(_DWORD *)(v4 + 4);
  v40 = *(_WORD *)(v4 + 12);
  if ( (*(_DWORD *)(v4 + 4) & 0xC000) != 0x4000 )
  {
    if ( ~(unsigned __int8)(*(_WORD *)(v4 + 8) >> 9) & 1 )
    {
      v40 -= v44;
      if ( v44 > 0 )
        v40 -= *(_WORD *)(dword_101E37E4[5 * ((v39 >> 10) & 0xF)] + 28);
    }
  }
  if ( !*(_WORD *)(v4 + 12) )
    v40 = sub_10012EC0(v39, *(_WORD *)(v4 + 8), v45, *(_BYTE *)(v4 + 11));
  return sub_10015EA0(v38, &v57, v46, v40, v44, v39, v51);
}
// 101E37E4: using guessed type int dword_101E37E4[];

//----- (10013420) --------------------------------------------------------
char __usercall sub_10013420@<al>(float *a1@<ecx>, int a2@<ebx>, int a3@<edi>, int a4)
{
  int v4; // ebp@1
  double v5; // st7@4
  double v6; // st7@6
  __int16 v7; // ax@6
  const char *v8; // esi@8
  int v10; // [sp+14h] [bp+4h]@6
  float v11; // [sp+14h] [bp+4h]@12

  v4 = a4;
  if ( *a1 >= 1.0e25 || *a1 <= -1.0e25 || 9.8999998e24 == *a1 )
    v5 = 0.0;
  else
    v5 = *a1;
  *(float *)&v10 = v5;
  v6 = sub_10021830(v10, *(_WORD *)(a2 + 8));
  v7 = *(_WORD *)(a2 + 8);
  if ( v7 & 0x40 )
  {
    if ( (v7 & 0x3F) == 7 )
      v8 = "%+0*.*e";
    else
      v8 = "%+0*.*f";
  }
  else
  {
    v8 = "%0*.*e";
    if ( (v7 & 0x3F) != 7 )
      v8 = "%0*.*f";
  }
  v11 = v6;
  if ( sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), v11) > a3 )
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v8, a3, *(_BYTE *)(a2 + 11), 0.0);
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = 0;
  return 4;
}

//----- (10013500) --------------------------------------------------------
char __usercall sub_10013500@<al>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi@1
  __int16 v5; // ax@1
  int v6; // edi@1
  __int16 v7; // ax@2
  int v8; // ecx@8
  const char *v9; // ecx@11
  char v10; // bl@11
  char *v11; // eax@11
  char v12; // dl@11
  char v13; // cl@12
  const char *v14; // edx@14
  char *v15; // eax@14
  char v16; // di@14
  char v17; // cl@15
  char v18; // bl@16
  char *v19; // eax@16
  char v20; // dl@16
  char v21; // cl@17
  unsigned __int16 v22; // ax@20
  int v23; // ecx@22
  signed __int16 v24; // di@22
  char *v25; // eax@25
  char v26; // dl@26
  char v27; // bl@27
  char *v28; // eax@27
  char v29; // dl@27
  char v30; // cl@28
  int v31; // ecx@32
  unsigned __int8 v32; // al@32
  char *v33; // eax@36
  char v34; // dl@37
  char v35; // bl@38
  char *v36; // eax@38
  char v37; // dl@38
  char v38; // cl@39
  const char *v39; // ecx@42
  char v40; // bl@42
  char *v41; // eax@42
  char v42; // dl@42
  char v43; // cl@43
  int v44; // eax@47
  unsigned __int16 v45; // ax@53
  const char *v46; // ecx@59
  char v47; // bl@59
  char *v48; // eax@59
  char v49; // dl@59
  char v50; // cl@60
  int v51; // edx@62
  char v52; // al@64
  int v53; // ebp@64
  bool v54; // zf@71
  bool v55; // sf@71
  char *v56; // eax@72
  int v57; // edi@72
  char v58; // dl@73
  char v59; // bl@74
  char *v60; // eax@74
  char v61; // dl@74
  char v62; // cl@75
  int v63; // ecx@81
  unsigned __int8 v64; // al@81
  char *v65; // eax@85
  char v66; // dl@86
  char v67; // bl@87
  char *v68; // eax@87
  char v69; // dl@87
  char v70; // cl@88
  const char *v71; // ecx@93
  char v72; // kr00_1@93
  char *v73; // eax@93
  char v74; // dl@93
  char v75; // cl@94
  signed int v76; // eax@96
  char *v77; // eax@104
  int v78; // edi@104
  char v79; // dl@105
  char v80; // bl@106
  char *v81; // eax@106
  char v82; // dl@106
  char v83; // cl@107
  char *v84; // eax@116
  int v85; // edi@116
  char v86; // dl@117
  char v87; // bl@118
  char *v88; // eax@118
  char v89; // dl@118
  char v90; // cl@119
  char *v91; // eax@122
  int v92; // edi@122
  char v93; // dl@123
  char v94; // bl@124
  char *v95; // eax@124
  char v96; // dl@124
  char v97; // cl@125
  int v98; // ecx@126
  const char *v99; // edx@127
  char *v100; // eax@127
  char v101; // di@127
  char v102; // cl@128
  char v103; // bl@129
  char *v104; // eax@129
  char v105; // di@129
  char v106; // cl@130
  char *v107; // eax@131
  int v108; // ecx@131
  char v109; // dl@132
  char v110; // bl@133
  char *v111; // eax@133
  char v112; // dl@133
  char v113; // cl@134
  int v114; // ebp@142
  int v115; // ecx@147
  const char *v116; // edx@152
  char *v117; // eax@152
  char v118; // di@152
  char v119; // cl@153
  char v120; // bl@154
  char *v121; // eax@154
  char v122; // dl@154
  char v123; // cl@155
  int v124; // edx@158
  signed int v125; // eax@158
  char *v126; // eax@165
  int v127; // edi@165
  char v128; // dl@166
  char v129; // bl@167
  char *v130; // eax@167
  char v131; // dl@167
  char v132; // cl@168
  int v133; // eax@170
  char v135; // [sp+1Bh] [bp-Dh]@1
  float v136; // [sp+1Ch] [bp-Ch]@1
  char *v137; // [sp+20h] [bp-8h]@3
  int v138; // [sp+24h] [bp-4h]@1
  __int32 v139; // [sp+2Ch] [bp+4h]@71
  float v140; // [sp+2Ch] [bp+4h]@76

  v4 = a1;
  v136 = 0.0;
  v5 = *(_WORD *)(a2 + 8);
  v6 = a4;
  v135 = 1;
  v138 = 1;
  if ( v5 & 0x40 )
  {
    v7 = v5 & 0x3F;
    if ( v7 == 7 )
      v137 = "%+0*.*e";
    else
      v137 = "%+0*.*f";
  }
  else
  {
    v7 = v5 & 0x3F;
    v137 = "%0*.*e";
    if ( v7 != 7 )
      v137 = "%0*.*f";
  }
  if ( *(_WORD *)(a4 + 10) == 84 )
  {
    v8 = *(_DWORD *)(v4 + 56);
    if ( *(_WORD *)(v8 + 240) == -128 )
    {
      *(_WORD *)(a4 + 14) = 45;
    }
    else
    {
      if ( v7 != 7 )
        goto LABEL_176;
      v9 = (const char *)(v8 + 69);
      v10 = strlen(v9);
      v11 = strchr(v9, 101);
      v12 = (_BYTE)v11 + 1;
      do
        v13 = *v11++;
      while ( v13 );
      v8 = *(_DWORD *)(v4 + 56);
      if ( *(_WORD *)(v8 + 240) <= (signed __int16)(char)(v10 - ((_BYTE)v11 - v12)) )
      {
LABEL_176:
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)(v8 + 69) != 45) + 43;
      }
      else
      {
        v14 = (const char *)(v8 + 69);
        v15 = (char *)(v8 + 69);
        v16 = v8 + 70;
        do
          v17 = *v15++;
        while ( v17 );
        v18 = (_BYTE)v15 - v16;
        v19 = strchr(v14, 101);
        v20 = (_BYTE)v19 + 1;
        do
          v21 = *v19++;
        while ( v21 );
        v6 = a4;
        *(_WORD *)(a4 + 14) = 2 * (*(_BYTE *)((char)(v18 - ((_BYTE)v19 - v20)) + *(_DWORD *)(v4 + 56) + 70) == 43) + 43;
      }
    }
  }
  v22 = *(_WORD *)(v6 + 14);
  if ( v22 < 0x30u || v22 > 0x39u )
  {
    if ( (*(_WORD *)(a2 + 8) & 0x3F) != 7 || v22 != 69 )
    {
      if ( (v22 == 43 || v22 == 45) && (sub_10021040(*(_WORD *)(a2 + 8)) || *(_BYTE *)(a2 + 8) & 0x40) )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        {
          sub_10013420(&v136, a2, a3, v4);
          if ( *(_BYTE *)(a2 + 11) )
          {
            v84 = (char *)(*(_DWORD *)(v4 + 56) + 69);
            v85 = *(_DWORD *)(v4 + 56) + 70;
            do
              v86 = *v84++;
            while ( v86 );
            v87 = (_BYTE)v84 - v85;
            v88 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
            v89 = (_BYTE)v88 + 1;
            do
              v90 = *v88++;
            while ( v90 );
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v87 - ((_BYTE)v88 - v89)) - 1;
          }
          else
          {
            *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
          }
        }
        if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 )
          goto LABEL_177;
        v91 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v92 = *(_DWORD *)(v4 + 56) + 70;
        do
          v93 = *v91++;
        while ( v93 );
        v94 = (_BYTE)v91 - v92;
        v95 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
        v96 = (_BYTE)v95 + 1;
        do
          v97 = *v95++;
        while ( v97 );
        v98 = *(_DWORD *)(v4 + 56);
        if ( *(_WORD *)(v98 + 240) <= (signed __int16)(char)(v94 - ((_BYTE)v95 - v96)) )
        {
LABEL_177:
          if ( (*(_WORD *)(a4 + 14) != 45 || sub_10049919((char *)(*(_DWORD *)(v4 + 56) + 69)) < 0.0)
            && (*(_WORD *)(a4 + 14) != 43 || sub_10049919((char *)(*(_DWORD *)(v4 + 56) + 69)) > 0.0) )
          {
            v114 = a2;
          }
          else
          {
            v114 = a2;
            if ( *(_BYTE *)(a2 + 8) & 0x40 || *(_WORD *)(a4 + 14) == 45 )
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
            }
            else
            {
              *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 48;
              v135 = 2;
            }
          }
          v115 = *(_DWORD *)(v4 + 56);
          if ( !*(_WORD *)(v115 + 240)
            && (*(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 43
             || *(_BYTE *)(*(_WORD *)(v115 + 240) + v115 + 69) == 45
             || (*(_BYTE *)(v114 + 8) & 0x3F) == 7) )
          {
            if ( (*(_BYTE *)(v114 + 8) & 0x3F) == 7 )
            {
              v116 = (const char *)(v115 + 69);
              v117 = (char *)(v115 + 69);
              v118 = v115 + 70;
              do
                v119 = *v117++;
              while ( v119 );
              v120 = (_BYTE)v117 - v118;
              v121 = strchr(v116, 46);
              v122 = (_BYTE)v121 + 1;
              do
                v123 = *v121++;
              while ( v123 );
              *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v120 - ((_BYTE)v121 - v122)) - 1;
            }
            else
            {
              ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
            }
            v124 = *(_DWORD *)(v4 + 56);
            v125 = a3 - (((unsigned int)*(_WORD *)(v114 + 8) >> 13) & 3) - 1;
            if ( *(_WORD *)(v124 + 240) < v125 )
              LOWORD(v125) = *(_WORD *)(v124 + 240);
            *(_WORD *)(v124 + 240) = (char)v125;
          }
        }
        else
        {
          v99 = (const char *)(v98 + 69);
          v100 = (char *)(v98 + 69);
          v101 = v98 + 70;
          do
            v102 = *v100++;
          while ( v102 );
          v103 = (_BYTE)v100 - v101;
          v104 = strchr(v99, 101);
          v105 = (_BYTE)v104 + 1;
          do
            v106 = *v104++;
          while ( v106 );
          *(_BYTE *)((char)(v103 - ((_BYTE)v104 - v105)) + *(_DWORD *)(v4 + 56) + 70) = *(_BYTE *)(a4 + 14);
          v107 = (char *)(*(_DWORD *)(v4 + 56) + 69);
          v108 = *(_DWORD *)(v4 + 56) + 70;
          do
            v109 = *v107++;
          while ( v109 );
          v110 = (_BYTE)v107 - v108;
          v111 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
          v112 = (_BYTE)v111 + 1;
          do
            v113 = *v111++;
          while ( v113 );
          if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == (char)(v110 - ((_BYTE)v111 - v112)) + 1 )
            ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
          v135 = 2;
        }
      }
      else if ( *(_WORD *)(v6 + 14) == 46 && *(_BYTE *)(a2 + 11) > 0 )
      {
        if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
          sub_10013420(&v136, a2, a3, v4);
        v126 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        v127 = *(_DWORD *)(v4 + 56) + 70;
        do
          v128 = *v126++;
        while ( v128 );
        v129 = (_BYTE)v126 - v127;
        v130 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v131 = (_BYTE)v130 + 1;
        do
          v132 = *v130++;
        while ( v132 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v129 - ((_BYTE)v130 - v131)) + 1;
      }
    }
    else
    {
      if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) == -128 )
        sub_10013420(&v136, a2, a3, v4);
      v77 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v78 = *(_DWORD *)(v4 + 56) + 70;
      do
        v79 = *v77++;
      while ( v79 );
      v80 = (_BYTE)v77 - v78;
      v81 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 101);
      v82 = (_BYTE)v81 + 1;
      do
        v83 = *v81++;
      while ( v83 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v80 - ((_BYTE)v81 - v82)) + 1;
      v135 = 2;
    }
    goto LABEL_170;
  }
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( v24 == -128 )
  {
    sub_10013420(&v136, a2, a3, v4);
    if ( *(_BYTE *)(a2 + 11) )
    {
      v25 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      do
        v26 = *v25++;
      while ( v26 );
      v27 = (_BYTE)v25 - (*(_BYTE *)(v4 + 56) + 70);
      v28 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v29 = (_BYTE)v28 + 1;
      do
        v30 = *v28++;
      while ( v30 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v27 - ((_BYTE)v28 - v29)) - 1;
    }
    else
    {
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = a3 - ((*(_WORD *)(a2 + 8) >> 13) & 3) - 1;
    }
    *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    if ( *(_BYTE *)(a2 + 11) > 0 )
    {
      if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7
        || (v31 = *(_DWORD *)(v4 + 56), v32 = *(_BYTE *)(v31 + 69), v32 > 0x30u)
        || (v32 == 43 || v32 == 45) && *(_BYTE *)(v31 + 70) != 48 )
      {
        v33 = (char *)(*(_DWORD *)(v4 + 56) + 69);
        do
          v34 = *v33++;
        while ( v34 );
        v35 = (_BYTE)v33 - (*(_BYTE *)(v4 + 56) + 70);
        v36 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
        v37 = (_BYTE)v36 + 1;
        do
          v38 = *v36++;
        while ( v38 );
        *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v35 - ((_BYTE)v36 - v37)) + 1;
        v135 = 2;
        goto LABEL_170;
      }
    }
LABEL_99:
    v135 = 2;
    goto LABEL_170;
  }
  if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
  {
    v39 = (const char *)(v23 + 69);
    v40 = strlen(v39);
    v41 = strchr(v39, 101);
    v42 = (_BYTE)v41 + 1;
    do
      v43 = *v41++;
    while ( v43 );
    v23 = *(_DWORD *)(v4 + 56);
    v24 = *(_WORD *)(v23 + 240);
    if ( v24 > (char)(v40 - ((_BYTE)v41 - v42)) )
    {
      if ( a3 - v24 != 2 )
      {
        if ( a3 - v24 != 3 )
        {
          v44 = *(_DWORD *)(v4 + 56);
          if ( a3 - v24 != 4 )
          {
            if ( *(_BYTE *)(*(_WORD *)(v44 + 240) + v44 + 68) < 0x33u || *(_WORD *)(a4 + 14) < 0x38u )
            {
              *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
              v135 = 2;
              goto LABEL_170;
            }
            goto LABEL_99;
          }
          ++*(_WORD *)(v44 + 240);
        }
        ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
      }
      v45 = *(_WORD *)(a4 + 14);
      if ( v45 >= 0x30u
        && v45 <= 0x33u
        && (*(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 70) < 0x38u || v45 < 0x33u) )
      {
        *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
        v135 = 2;
        goto LABEL_170;
      }
      goto LABEL_99;
    }
  }
  if ( *(_BYTE *)(a2 + 11) <= 0 )
    goto LABEL_178;
  v46 = (const char *)(v23 + 69);
  v47 = strlen(v46);
  v48 = strchr(v46, 46);
  v49 = (_BYTE)v48 + 1;
  do
    v50 = *v48++;
  while ( v50 );
  v23 = *(_DWORD *)(v4 + 56);
  v24 = *(_WORD *)(v23 + 240);
  if ( *(_WORD *)(v23 + 240) != (char)(v47 - ((_BYTE)v48 - v49)) - 1 )
  {
LABEL_178:
    v51 = a2;
    if ( !*(_BYTE *)(a2 + 11) )
    {
      if ( v24 == a3 - (((unsigned int)*(_WORD *)(a2 + 8) >> 13) & 3) - 1 )
        goto LABEL_64;
      v51 = a2;
    }
    if ( (*(_BYTE *)(v51 + 8) & 0x3F) == 7 && !v24 )
    {
      v71 = (const char *)(v23 + 69);
      v72 = strlen(v71);
      v73 = strchr(v71, 46);
      v74 = (_BYTE)v73 + 1;
      do
        v75 = *v73++;
      while ( v75 );
      *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v72 - ((_BYTE)v73 - v74)) - 1;
      v51 = a2;
    }
    *(_BYTE *)((*(_WORD *)(*(_DWORD *)(v4 + 56) + 240))++ + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
    v76 = a3 - (((unsigned int)*(_WORD *)(v51 + 8) >> 13) & 3) - 1;
    if ( *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) < v76 )
      LOWORD(v76) = *(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
    *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)v76;
    goto LABEL_99;
  }
LABEL_64:
  v52 = *(_BYTE *)(v23 + 69);
  v53 = a2;
  if ( v52 == 48 && (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || (v52 == 43 || v52 == 45) && *(_BYTE *)(v23 + 70) == 48 )
  {
    if ( v52 == 45 )
    {
      *(_BYTE *)(v23 + 69) = 48;
      v138 = -1;
    }
    v139 = j__atol((const char *)(*(_DWORD *)(v4 + 56) + 69));
    v54 = *(_BYTE *)(v53 + 11) == 0;
    v55 = *(_BYTE *)(v53 + 11) < 0;
    v136 = (double)v139 * 10.0;
    if ( !v55 && !v54 )
    {
      v56 = (char *)(*(_DWORD *)(v4 + 56) + 69);
      v57 = *(_DWORD *)(v4 + 56) + 70;
      do
        v58 = *v56++;
      while ( v58 );
      v59 = (_BYTE)v56 - v57;
      v60 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
      v61 = (_BYTE)v60 + 1;
      do
        v62 = *v60++;
      while ( v62 );
      v140 = sub_10049919((char *)((char)(v59 - ((_BYTE)v60 - v61)) + *(_DWORD *)(v4 + 56) + 69));
      v136 = v140 + v136;
    }
    sprintf((char *)(*(_DWORD *)(v4 + 56) + 69), v137, a3, *(_BYTE *)(v53 + 11), v136);
    if ( v138 == -1 )
      *(_BYTE *)(*(_DWORD *)(v4 + 56) + 69) = 45;
  }
  *(_BYTE *)(*(_WORD *)(*(_DWORD *)(v4 + 56) + 240) + *(_DWORD *)(v4 + 56) + 69) = *(_BYTE *)(a4 + 14);
  if ( *(_BYTE *)(v53 + 11) <= 0 )
    goto LABEL_99;
  if ( (*(_BYTE *)(v53 + 8) & 0x3F) != 7 )
  {
    v63 = *(_DWORD *)(v4 + 56);
    v64 = *(_BYTE *)(v63 + 69);
    if ( v64 <= 0x30u && (v64 != 43 && v64 != 45 || *(_BYTE *)(v63 + 70) == 48) )
      goto LABEL_99;
  }
  v65 = (char *)(*(_DWORD *)(v4 + 56) + 69);
  do
    v66 = *v65++;
  while ( v66 );
  v67 = (_BYTE)v65 - (*(_BYTE *)(v4 + 56) + 70);
  v68 = strchr((const char *)(*(_DWORD *)(v4 + 56) + 69), 46);
  v69 = (_BYTE)v68 + 1;
  do
    v70 = *v68++;
  while ( v70 );
  *(_WORD *)(*(_DWORD *)(v4 + 56) + 240) = (char)(v67 - ((_BYTE)v68 - v69)) + 1;
  v135 = 2;
LABEL_170:
  v133 = *(_DWORD *)(v4 + 56);
  if ( *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 101 || *(_BYTE *)(*(_WORD *)(v133 + 240) + v133 + 69) == 46 )
    ++*(_WORD *)(*(_DWORD *)(v4 + 56) + 240);
  return v135;
}

//----- (10013FD0) --------------------------------------------------------
char __usercall sub_10013FD0@<al>(int a1@<eax>, float *a2@<ecx>, int a3@<ebx>, int a4@<esi>, int a5)
{
  float *v5; // edi@1
  __int16 v6; // ax@1
  unsigned int v7; // edi@1
  int v8; // ebp@1
  __int16 v9; // ax@1
  char *v11; // [sp+8h] [bp-4h]@1

  v5 = a2;
  *(_WORD *)(a3 + 438) = *(_WORD *)a1;
  *(_WORD *)(a3 + 436) = *(_WORD *)(a1 + 2);
  v11 = sub_10021080(*(_WORD *)(a4 + 8), a2);
  v6 = sub_100159C0(*(_DWORD *)(a4 + 4), *(_WORD *)(a4 + 8), v5);
  v7 = *(_DWORD *)(a4 + 4);
  v8 = v6;
  v9 = *(_WORD *)(a4 + 12);
  if ( (*(_DWORD *)(a4 + 4) & 0xC000) != 0x4000 )
  {
    v9 -= v8;
    if ( v8 > 0 )
      v9 -= *(_WORD *)(dword_101E37E4[5 * ((v7 >> 10) & 0xF)] + 28);
  }
  if ( !*(_WORD *)(a4 + 12) )
    v9 = sub_10012EC0(v7, *(_WORD *)(a4 + 8), a5, *(_BYTE *)(a4 + 11));
  return sub_10015EA0(a3, (char *)(*(_DWORD *)(a3 + 56) + 69), v11, v9, v8, v7, *(_WORD *)(a4 + 8));
}
// 101E37E4: using guessed type int dword_101E37E4[];

//----- (10014090) --------------------------------------------------------
char __usercall sub_10014090@<al>(int a1@<edx>, float *a2@<ecx>, int a3, int a4)
{
  double v4; // st7@2
  double v6; // [sp+0h] [bp-8h]@4

  if ( 9.8999998e24 == *a2 )
    v4 = 9.899999762399947e24;
  else
    v4 = *a2;
  v6 = v4;
  return sub_10012F20(a3, a1, a4, &v6);
}

//----- (100140D0) --------------------------------------------------------
char __cdecl sub_100140D0(int a1, int a2, int *a3, float *a4, int a5)
{
  __int16 v5; // cx@2
  __int16 v6; // cx@4
  __int16 v7; // ax@9
  _WORD *v8; // esi@9
  unsigned int v9; // ebp@10
  int v10; // eax@10
  int v11; // edx@12
  __int16 v12; // ax@16
  int v13; // eax@17
  __int16 v14; // cx@17
  int v16; // eax@19
  signed __int16 v17; // si@19
  signed int v18; // eax@20
  char v19; // al@27
  char v20; // al@33
  __int16 v21; // ax@36
  signed int v22; // ecx@40
  int v23; // ecx@42
  int v24; // ecx@43
  int v25; // ecx@45
  int v26; // ecx@47
  int v27; // edi@49
  const char *v28; // eax@50
  char v29; // ST38_1@50
  bool v30; // zf@58
  bool v31; // sf@58
  int v32; // esi@65
  char v33; // dl@68
  bool v34; // zf@73
  bool v35; // sf@73
  bool v36; // zf@80
  bool v37; // sf@80
  char v38; // al@87
  int v39; // esi@94
  double v40; // st7@96
  int v41; // esi@101
  unsigned int v42; // edx@101
  __int16 v43; // bx@101
  unsigned __int8 v44; // cl@103
  int v45; // ecx@109
  _WORD *v46; // eax@109
  char v47; // dl@109
  char *v48; // eax@114
  int v49; // esi@114
  char v50; // dl@115
  char v51; // bl@116
  char *v52; // eax@116
  char v53; // dl@116
  char v54; // cl@117
  char v55; // cl@118
  int v56; // eax@118
  int v57; // edx@118
  char *v58; // eax@120
  int v59; // esi@120
  char v60; // dl@121
  char v61; // bl@122
  char *v62; // eax@122
  char v63; // dl@122
  char v64; // cl@123
  char v65; // cl@124
  int v66; // eax@124
  int v67; // edx@124
  char v68; // [sp-4h] [bp-2Ch]@64
  unsigned __int16 v69; // [sp+0h] [bp-28h]@64
  char v70; // [sp+4h] [bp-24h]@64
  char v71; // [sp+1Bh] [bp-Dh]@1
  size_t v72; // [sp+1Ch] [bp-Ch]@2
  unsigned int v73; // [sp+3Ch] [bp+14h]@50
  int v74; // [sp+3Ch] [bp+14h]@99

  v71 = 1;
  if ( *(_WORD *)a5 == -32703 )
  {
    v72 = 0;
  }
  else
  {
    v72 = *(_BYTE *)(a2 + 10);
    v5 = *(_WORD *)(a2 + 8);
    if ( v5 & 0x40 || *(_WORD *)(a2 + 8) & 0x800 || (v6 = v5 & 0x3F, v6 == 7) || v6 == 28 )
      ++v72;
  }
  switch ( *(_WORD *)a5 )
  {
    case 0x8040:
      v7 = *(_WORD *)(a2 + 12);
      v8 = (_WORD *)(a1 + 276);
      if ( v7 )
      {
        sub_10015D40(a1 + 276, *a3, *(_DWORD *)(a2 + 4), v7);
      }
      else
      {
        v9 = *(_DWORD *)(a2 + 4);
        v10 = sub_10012EC0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), *(_BYTE *)(a2 + 10), *(_BYTE *)(a2 + 11));
        sub_10015D40((int)v8, *a3, v9, v10);
      }
      v11 = (signed __int16)sub_100159C0(*(_DWORD *)(a2 + 4), *(_WORD *)(a2 + 8), a4);
      if ( (!*(_WORD *)(a2 + 12) || (*(_DWORD *)(a2 + 4) & 0xC000) == 0x4000)
        && ~(unsigned __int8)(*(_WORD *)(a2 + 8) >> 9) & 1
        && v11 > 0 )
      {
        v12 = *(_WORD *)(dword_101E37E4[5 * ((*(_DWORD *)(a2 + 4) >> 10) & 0xF)] + 28);
        *(_WORD *)(a1 + 280) += v11 + v12;
        if ( (*(_DWORD *)(a2 + 4) & 0xC000) == 0x8000 )
        {
          v13 = (v12 + v11 + 1) / 2;
          v14 = *(_WORD *)(a1 + 280) - v13;
          *v8 -= v13;
          *(_WORD *)(a1 + 280) = v14;
        }
      }
      return 2;
    case 0x8048:
      v16 = *(_DWORD *)(a1 + 56);
      v17 = *(_WORD *)(v16 + 240);
      if ( v17 == -128 )
      {
        v18 = *(_WORD *)(a5 + 10);
        if ( v18 > 84 )
        {
          if ( v18 != 0x2000 )
            return v71;
        }
        else if ( v18 != 84 )
        {
          if ( v18 == 32 )
          {
            if ( *(_WORD *)(a2 + 8) & 0x400 || (*(_WORD *)(a2 + 8) & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
              return v71;
            v71 = sub_10013420(a4, a2, v72, a1);
            memset((void *)(*(_DWORD *)(a1 + 56) + 69), 48, v72);
            if ( (*(_BYTE *)(a2 + 8) & 0x3F) == 7 )
            {
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + 71) = 46;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 64) = 101;
              *(_BYTE *)(*(_DWORD *)(a1 + 56) + v72 + 65) = 43;
            }
            else
            {
              v20 = *(_BYTE *)(a2 + 11);
              if ( v20 > 0 )
                *(_BYTE *)(*(_DWORD *)(a1 + 56) - v20 + v72 + 68) = 46;
            }
            goto LABEL_132;
          }
          if ( v18 != 56
            || *(_WORD *)(a2 + 8) & 0x400
            || (*(_WORD *)(a2 + 8) & 0x3F) == 27
            || *(_WORD *)(a2 + 8) & 0x800 )
          {
            return v71;
          }
          v19 = sub_10013420(a4, a2, v72, a1);
LABEL_131:
          v71 = v19;
LABEL_132:
          if ( v71 != 4 && v71 != 2 )
            return v71;
          goto LABEL_134;
        }
        v21 = *(_WORD *)(a2 + 8);
        if ( *(_WORD *)(a2 + 8) & 0x400 || (v21 & 0x3F) == 27 || *(_WORD *)(a2 + 8) & 0x800 )
          return v71;
        v19 = sub_10013500(a1, a2, v72, a5);
        goto LABEL_131;
      }
      v22 = *(_WORD *)(a5 + 10);
      if ( v22 > 57 )
      {
        if ( v22 != 84 && v22 != 0x2000 )
          return v71;
        v19 = sub_10013500(a1, a2, v72, a5);
        goto LABEL_131;
      }
      if ( v22 == 57 )
      {
        *(_WORD *)(v16 + 240) += *(_BYTE *)(a5 + 8);
        v41 = *(_DWORD *)(a1 + 56);
        v42 = *(_WORD *)(a2 + 8);
        v43 = *(_WORD *)(v41 + 240);
        v71 = 2;
        if ( v43 >= 0 )
        {
          v44 = *(_BYTE *)(a2 + 10);
          if ( v43 <= (signed int)(v44 - ((v42 >> 13) & 3) - 1) || v42 & 0x40 || (v42 & 0x3F) == 7 )
          {
            if ( v43 <= (signed int)v44 )
            {
              while ( 1 )
              {
                v45 = *(_DWORD *)(a1 + 56);
                v46 = (_WORD *)(v45 + 240);
                v47 = *(_BYTE *)(*(_WORD *)(v45 + 240) + v45 + 69);
                if ( v47 != 46 && v47 != 101 )
                {
                  if ( (*(_BYTE *)(a2 + 8) & 0x3F) != 7 || *(_WORD *)(v45 + 240) <= 0 )
                    break;
                  if ( !strchr((const char *)(v45 + 69), 46) )
                    goto LABEL_142;
                  v48 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                  v49 = *(_DWORD *)(a1 + 56) + 70;
                  do
                    v50 = *v48++;
                  while ( v50 );
                  v51 = (_BYTE)v48 - v49;
                  v52 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46);
                  v53 = (_BYTE)v52 + 1;
                  do
                    v54 = *v52++;
                  while ( v54 );
                  v55 = (_BYTE)v52 - v53;
                  v56 = *(_DWORD *)(a1 + 56);
                  v57 = *(_WORD *)(v56 + 240);
                  v46 = (_WORD *)(v56 + 240);
                  if ( v57 >= (char)(v51 - v55) - 1 )
                  {
LABEL_142:
                    if ( strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 46) )
                      break;
                    v58 = (char *)(*(_DWORD *)(a1 + 56) + 69);
                    v59 = *(_DWORD *)(a1 + 56) + 70;
                    do
                      v60 = *v58++;
                    while ( v60 );
                    v61 = (_BYTE)v58 - v59;
                    v62 = strchr((const char *)(*(_DWORD *)(a1 + 56) + 69), 101);
                    v63 = (_BYTE)v62 + 1;
                    do
                      v64 = *v62++;
                    while ( v64 );
                    v65 = (_BYTE)v62 - v63;
                    v66 = *(_DWORD *)(a1 + 56);
                    v67 = *(_WORD *)(v66 + 240);
                    v46 = (_WORD *)(v66 + 240);
                    if ( v67 >= (char)(v61 - v65) - 1 )
                      break;
                  }
                }
                if ( *(_BYTE *)(a5 + 8) <= 0 )
                  --*v46;
                else
                  ++*v46;
              }
            }
            else
            {
              *(_WORD *)(v41 + 240) = (char)v44;
            }
          }
          else
          {
            *(_WORD *)(v41 + 240) = (char)(v44 - ((v42 >> 13) & 3) - 1);
          }
        }
        else
        {
          *(_WORD *)(v41 + 240) = 0;
        }
        goto LABEL_134;
      }
      v23 = v22 - 32;
      if ( !v23 )
      {
        *(_WORD *)(v16 + 240) = -128;
        sub_10014090(a2, a4, a1, (int)a3);
        return 6;
      }
      v24 = v23 - 1;
      if ( v24 )
      {
        if ( v24 != 23 )
          return v71;
        v25 = *(_WORD *)(a2 + 8);
        if ( v25 & 0x40 && !v17 )
        {
          LOBYTE(v25) = *(_BYTE *)(v16 + 69) != 45;
          v26 = 2 * v25 + 43;
LABEL_48:
          *(_BYTE *)(v16 + 69) = v26;
          v71 = 2;
LABEL_134:
          sub_10013FD0((int)a3, a4, a1, a2, v72);
          return v71;
        }
        v27 = 2 * (*(_BYTE *)(a5 + 8) >= 0) - 1;
        if ( (v25 & 0x3F) != 7
          || (v28 = (const char *)(v16 + 69),
              v73 = strlen(v28),
              v29 = strlen(strchr(v28, 101)),
              v16 = *(_DWORD *)(a1 + 56),
              v17 = *(_WORD *)(v16 + 240),
              v17 <= (char)(v73 - v29))
          && v17 )
        {
          v38 = *(_BYTE *)(v17 + v16 + 69);
          if ( (v38 == 48 && v27 < 0 || v38 == 57 && v27 > 0) && !v17 && sub_10021040(*(_WORD *)(a2 + 8)) )
          {
            *(_BYTE *)(*(_WORD *)(*(_DWORD *)(a1 + 56) + 240) + *(_DWORD *)(a1 + 56) + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
          v39 = *(_DWORD *)(a1 + 56);
          *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69) = sub_1001DF60(
                                                           *(_BYTE *)(*(_WORD *)(v39 + 240) + v39 + 69),
                                                           0x10u,
                                                           v27);
        }
        else
        {
          if ( !v17 )
          {
            v71 = 2;
            *(_BYTE *)(v16 + 69) = *(_BYTE *)(v16 + 69) != 45 ? 45 : 48;
            goto LABEL_134;
          }
          if ( v72 - v17 == 2 )
          {
            v16 += v17;
            if ( *(_BYTE *)(v16 + 70) > 0x37u )
            {
              v34 = v27 == 0;
              v35 = v27 < 0;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 50;
                  v71 = 2;
                  goto LABEL_134;
                }
                v34 = v27 == 0;
                v35 = v27 < 0;
              }
              if ( !v35 && !v34 && *(_BYTE *)(v16 + 69) >= 0x32u )
              {
                *(_BYTE *)(v16 + 69) = 48;
                v71 = 2;
                goto LABEL_134;
              }
LABEL_64:
              v70 = v27;
              v69 = 16;
              v68 = *(_BYTE *)(v16 + 69);
LABEL_65:
              v32 = *(_DWORD *)(a1 + 56);
              *(_BYTE *)(*(_WORD *)(v32 + 240) + v32 + 69) = sub_1001DF60(v68, v69, v70);
              v71 = 2;
              goto LABEL_134;
            }
            v36 = v27 == 0;
            v37 = v27 < 0;
            if ( v27 < 0 )
            {
              if ( *(_BYTE *)(v16 + 69) == 48 )
              {
                *(_BYTE *)(v16 + 69) = 51;
                v71 = 2;
                goto LABEL_134;
              }
              v36 = v27 == 0;
              v37 = v27 < 0;
            }
            if ( !v37 && !v36 && *(_BYTE *)(v16 + 69) >= 0x33u )
            {
              *(_BYTE *)(v16 + 69) = 48;
              v71 = 2;
              goto LABEL_134;
            }
LABEL_66:
            v70 = v27;
            v69 = 16;
            v68 = *(_BYTE *)(v16 + 69);
            goto LABEL_65;
          }
          if ( v72 - v17 != 3 )
          {
            if ( v72 - v17 == 4 )
            {
              v71 = 2;
              *(_BYTE *)(v17 + v16 + 69) = 2 * (*(_BYTE *)(v17 + v16 + 69) != 45) + 43;
              goto LABEL_134;
            }
            v16 += v17;
            if ( *(_BYTE *)(v16 + 68) >= 0x33u )
            {
              v30 = v27 == 0;
              v31 = v27 < 0;
              LOBYTE(v26) = 48;
              if ( v27 < 0 )
              {
                if ( *(_BYTE *)(v16 + 69) == 48 )
                {
                  *(_BYTE *)(v16 + 69) = 55;
                  v71 = 2;
                  goto LABEL_134;
                }
                v30 = v27 == 0;
                v31 = v27 < 0;
              }
              if ( !v31 && !v30 && *(_BYTE *)(v16 + 69) >= 0x37u )
                goto LABEL_48;
              goto LABEL_64;
            }
            goto LABEL_66;
          }
          v33 = *(_BYTE *)(v17 + v16 + 69);
          if ( v33 == 45 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 43;
            v71 = 2;
            goto LABEL_134;
          }
          if ( v33 == 43 )
          {
            *(_BYTE *)(v17 + v16 + 69) = 45;
            v71 = 2;
            goto LABEL_134;
          }
        }
        v71 = 2;
        goto LABEL_134;
      }
      *(_WORD *)(v16 + 240) = -128;
      v40 = sub_10049919((char *)(*(_DWORD *)(a1 + 56) + 69));
      if ( v40 > 1.0e25 || v40 < -1.0e25 )
        v40 = 9.899999762399947e24;
      *(float *)&v74 = v40;
      *a4 = sub_10021E60(v74, *(_WORD *)(a2 + 8));
      sub_10014090(a2, a4, a1, (int)a3);
      return 3;
    case 0x8022:
    case 0x8078:
      if ( !*(_BYTE *)(a1 + 3) || *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) == -128 )
      {
        sub_10014090(a2, a4, a1, (int)a3);
        return v71;
      }
      sub_10013FD0((int)a3, a4, a1, a2, v72);
      return 1;
    default:
      return v71;
  }
}
// 101E37E4: using guessed type int dword_101E37E4[];

//----- (100149C0) --------------------------------------------------------
char __cdecl sub_100149C0(int a1, int a2, int *a3, int a4, int a5)
{
  int v5; // ecx@1
  char result; // al@1
  bool v7; // zf@2
  __int16 v8; // dx@3

  v5 = a4;
  result = 1;
  if ( *(_DWORD *)(a4 + 8) )
  {
    v7 = *(_BYTE *)a4 == 0;
    a4 = *a3;
    if ( !v7 )
    {
      v8 = *(_WORD *)(v5 + 4);
      if ( *(_BYTE *)(v5 + 1) )
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2) + a4;
        HIWORD(a4) += v8;
      }
      else
      {
        LOWORD(a4) = *(_WORD *)(v5 + 2);
        HIWORD(a4) = v8;
      }
    }
    result = ((int (__cdecl *)(int, _DWORD, int *, _DWORD, int))dword_101E32A0[2 * (**(_DWORD **)(v5 + 8) & 0xFF)])(
               a1,
               *(_DWORD *)(v5 + 8),
               &a4,
               *(_DWORD *)(v5 + 12),
               a5);
  }
  return result;
}
// 101E32A0: using guessed type int dword_101E32A0[];

//----- (10014A30) --------------------------------------------------------
int __usercall sub_10014A30@<eax>(int a1@<eax>, int a2@<ecx>, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( a3 )
  {
    do
    {
      sub_1005C3A0(
        v5 + 392,
        v3,
        v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * v3,
        *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * v3,
        0);
      ++v3;
    }
    while ( v3 < a3 );
  }
  *(_WORD *)(v5 + 428) = word_1010FC78[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 430) = word_1010FC78[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 440) = word_1010FC78[*(_BYTE *)(v4 + 4) & 0x1F];
  *(_WORD *)(v5 + 442) = word_1010FC78[*(_BYTE *)(v4 + 4) & 0x1F];
  return sub_1005C3A0(
           v5 + 392,
           a3,
           a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 32) - 2 * a3,
           *(_WORD *)(*(_DWORD *)(v5 + 56) + 34) - 2 * a3,
           1);
}
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (10014B10) --------------------------------------------------------
char __cdecl sub_10014B10(int a1, int a2, int a3, int a4, _WORD *a5)
{
  char result; // al@1
  __int16 v6; // bx@5
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // ebp@8
  int v10; // eax@10
  int v11; // eax@15
  int v12; // eax@15
  int v13; // eax@15
  int v14; // eax@17
  char v15; // al@19
  bool v16; // zf@19
  int v17; // eax@23
  int v18; // eax@28
  int v19; // esi@28

  result = 1;
  if ( *a5 == 32802 || *a5 == 32888 )
  {
    if ( *(_DWORD *)(a1 + 64) == 9 )
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 248) = 1;
    v6 = word_1010FC78[(unsigned __int8)sub_100213C0(*(_BYTE *)(a2 + 4) & 0x1F)];
    v7 = *(_BYTE *)(a2 + 4) & 0xE0;
    if ( !(*(_BYTE *)(a2 + 4) & 0xE0) )
    {
      v17 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 428) = v6;
      *(_WORD *)(a1 + 430) = v6;
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v17 + 25)
        && (*(_WORD *)(v17 + 40) || *(_WORD *)(v17 + 42) || *(_WORD *)(v17 + 44) || *(_WORD *)(v17 + 46)) )
      {
        sub_1005C3A0(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 42), 1);
        sub_1005C3A0(
          a1 + 392,
          0,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v18 = *(_DWORD *)(a1 + 56);
        sub_1005C3A0(
          a1 + 392,
          *(_WORD *)(v18 + 44) + *(_WORD *)(v18 + 40),
          *(_WORD *)(v18 + 42),
          *(_WORD *)(v18 + 32) - *(_WORD *)(v18 + 40) - *(_WORD *)(v18 + 44),
          *(_WORD *)(v18 + 46),
          1);
        v19 = *(_DWORD *)(a1 + 56);
        sub_1005C3A0(
          a1 + 392,
          0,
          *(_WORD *)(v19 + 46) + *(_WORD *)(v19 + 42),
          *(_WORD *)(v19 + 32),
          *(_WORD *)(v19 + 34) - *(_WORD *)(v19 + 42) - *(_WORD *)(v19 + 46),
          1);
        return 2;
      }
      sub_1005C3A0(a1 + 392, 0, 0, *(_WORD *)(v17 + 32), *(_WORD *)(v17 + 34), 1);
      *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      return 2;
    }
    if ( v7 == 32 )
    {
      *(_WORD *)(a1 + 428) = word_1010FC78[(unsigned __int8)sub_100213C0(15)];
      *(_WORD *)(a1 + 430) = word_1010FC78[(unsigned __int8)sub_100213C0(15)];
      *(_WORD *)(a1 + 440) = word_1010FC78[(unsigned __int8)sub_100213C0(15)];
      *(_WORD *)(a1 + 442) = word_1010FC78[(unsigned __int8)sub_100213C0(15)];
      sub_10014A30(a2, a1, 2u);
      return 2;
    }
    if ( v7 != 96 )
    {
      *(_WORD *)(a1 + 428) = word_1010FC78[1];
      *(_WORD *)(a1 + 430) = word_1010FC78[1];
      *(_WORD *)(a1 + 440) = word_1010FC78[1];
      v8 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 442) = word_1010FC78[1];
      sub_1005C3A0(a1 + 392, 0, 0, *(_WORD *)(v8 + 32), *(_WORD *)(v8 + 34), 1);
      *(_WORD *)(a1 + 428) = word_1010FC78[15];
      *(_WORD *)(a1 + 430) = word_1010FC78[14];
      sub_1005C3A0(a1 + 392, 0, 3, *(_WORD *)(*(_DWORD *)(a1 + 56) + 32), *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 6, 2);
      *(_WORD *)(a1 + 428) = word_1010FC78[13];
      *(_WORD *)(a1 + 430) = word_1010FC78[1];
      sub_1005C3A0(
        a1 + 392,
        1,
        4,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2,
        *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 8,
        2);
      *(_WORD *)(a1 + 428) = word_1010FC78[14];
      *(_WORD *)(a1 + 430) = word_1010FC78[12];
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      v9 = 2;
      do
      {
        sub_1005C3A0(
          a1 + 392,
          v9,
          v9 + 3,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 32) - 2 * v9,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 34) - 2 * (v9 + 3),
          2);
        ++v9;
      }
      while ( v9 < 6 );
      v10 = *(_DWORD *)(a1 + 56);
      *(_WORD *)(a1 + 440) = v6;
      *(_WORD *)(a1 + 442) = v6;
      if ( !*(_BYTE *)(v10 + 25)
        && (*(_WORD *)(v10 + 40) || *(_WORD *)(v10 + 42) || *(_WORD *)(v10 + 44) || *(_WORD *)(v10 + 46)) )
      {
        sub_1005C3A0(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 2);
        v11 = *(_DWORD *)(a1 + 56);
        *(_WORD *)(a1 + 428) = v6;
        *(_WORD *)(a1 + 430) = v6;
        sub_1005C3A0(a1 + 392, 6, 9, *(_WORD *)(v11 + 32) - 12, *(_WORD *)(v11 + 42) - 9, 1);
        sub_1005C3A0(
          a1 + 392,
          6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 42),
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 40) - 6,
          *(_WORD *)(*(_DWORD *)(a1 + 56) + 46),
          1);
        v12 = *(_DWORD *)(a1 + 56);
        sub_1005C3A0(
          a1 + 392,
          *(_WORD *)(v12 + 44) + *(_WORD *)(v12 + 40),
          *(_WORD *)(v12 + 42),
          *(_WORD *)(v12 + 32) - *(_WORD *)(v12 + 40) - *(_WORD *)(v12 + 44) - 6,
          *(_WORD *)(v12 + 46),
          1);
        v13 = *(_DWORD *)(a1 + 56);
        sub_1005C3A0(
          a1 + 392,
          6,
          *(_WORD *)(v13 + 46) + *(_WORD *)(v13 + 42),
          *(_WORD *)(v13 + 32) - 12,
          *(_WORD *)(v13 + 34) - *(_WORD *)(v13 + 42) - *(_WORD *)(v13 + 46) - 9,
          1);
      }
      else
      {
        sub_1005C3A0(a1 + 392, 6, 9, *(_WORD *)(v10 + 32) - 12, *(_WORD *)(v10 + 34) - 18, 3);
        *(_BYTE *)(*(_DWORD *)(a1 + 56) + 25) = 0;
      }
      v14 = *(_DWORD *)(a1 + 56);
      if ( *(_BYTE *)(v14 + 247) )
      {
        *(_WORD *)(a1 + 428) = word_1010FC78[15];
        *(_WORD *)(a1 + 430) = word_1010FC78[15];
        *(_WORD *)(a1 + 440) = word_1010FC78[1];
        *(_WORD *)(a1 + 442) = word_1010FC78[1];
        sub_1005C3A0(a1 + 392, 10, 13, *(_WORD *)(v14 + 32) - 20, *(_WORD *)(v14 + 34) - 26, 3);
        return 2;
      }
      return 2;
    }
    *(_WORD *)(a1 + 428) = word_1010FC78[(unsigned __int8)sub_100213C0(15)];
    *(_WORD *)(a1 + 430) = word_1010FC78[(unsigned __int8)sub_100213C0(15)];
    *(_WORD *)(a1 + 440) = word_1010FC78[(unsigned __int8)sub_100213C0(15)];
    v15 = sub_100213C0(15);
    v16 = (*(_BYTE *)(a1 + 22) & 0x1E) == 0;
    *(_WORD *)(a1 + 442) = word_1010FC78[(unsigned __int8)v15];
    if ( v16 )
    {
      sub_10014A30(a2, a1, 2u);
      result = 2;
    }
    else
    {
      sub_10014A30(a2, a1, 5u);
      result = 2;
    }
  }
  return result;
}
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (100150C0) --------------------------------------------------------
unsigned int __usercall sub_100150C0@<eax>(int a1@<ebx>, int a2@<esi>, unsigned __int16 *a3)
{
  int v3; // edi@1
  int v4; // ST38_4@1
  int v5; // eax@1
  __int16 v6; // cx@1
  unsigned int result; // eax@1
  char v8; // [sp+Ch] [bp-204h]@1

  v3 = BMP_get_bm_def(*a3);
  v4 = *(_DWORD *)(a2 + 460);
  v5 = sub_1001B0C0(*a3, *(_BYTE *)(a2 + 3), (int)&v8);
  v6 = *(_WORD *)(a2 + 432);
  *(_DWORD *)(a2 + 460) = v5;
  result = sub_10006420(
             a2 + 392,
             v3,
             0,
             0,
             *(_WORD *)a1 + *(_WORD *)(a2 + 434),
             *(_WORD *)(a1 + 2) + v6,
             *(_WORD *)(v3 + 6),
             *(_WORD *)(v3 + 4));
  *(_DWORD *)(a2 + 460) = v4;
  return result;
}
// 100473C8: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (10015170) --------------------------------------------------------
char __cdecl sub_10015170(int a1, int a2, int a3, unsigned __int16 *a4, _WORD *a5)
{
  char result; // al@1
  int v6; // eax@8
  __int16 v7; // dx@8
  __int16 v8; // si@8

  result = 1;
  if ( *a5 == 32802 )
    goto LABEL_11;
  if ( *a5 == 32832 )
  {
    v6 = BMP_get_bm_def(*a4);
    v7 = *(_WORD *)(v6 + 6);
    v8 = *(_WORD *)(v6 + 4);
    *(_WORD *)(a1 + 276) = *(_WORD *)a3;
    *(_WORD *)(a1 + 278) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a1 + 280) = v7 + *(_WORD *)a3 - 1;
    *(_WORD *)(a1 + 282) = v8 + *(_WORD *)(a3 + 2) - 1;
    return 2;
  }
  if ( *a5 == 32888 )
  {
LABEL_11:
    if ( *a4 != -1 )
      sub_100150C0(a3, a1, a4);
    result = 2;
  }
  return result;
}
// 100473C8: using guessed type int __cdecl BMP_get_bm_def(_DWORD);

//----- (10015210) --------------------------------------------------------
bool __cdecl sub_10015210(int a1, _WORD *a2, char *a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  char *v7; // ebp@1
  int v8; // edi@1
  bool result; // al@1
  _WORD *v10; // ebx@2
  int v11; // eax@4
  bool v12; // al@6
  bool v13; // zf@8
  bool v14; // al@10
  char *v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a1;
  sub_100012C0(a1, *(_DWORD *)(a1 + 56));
  v7 = a3;
  v8 = 0;
  result = sub_1001D040(a3, &v16, &v15);
  if ( result )
  {
    v10 = a2;
    do
    {
      if ( sub_1001CFC0(v6, a5, v8) )
      {
        v11 = *(_DWORD *)(v6 + 56);
        LOWORD(a1) = *(_WORD *)v16 + *(_WORD *)(v11 + 36);
        HIWORD(a1) = *(_WORD *)(v16 + 2) + *(_WORD *)(v11 + 38);
        v12 = v8 == a6 && sub_1001CFF0(v6, v10, v11);
        v13 = v8 == a6;
        *(_BYTE *)(v6 + 3) = v12;
        v14 = v13 && *(_DWORD *)(v6 + 56) == *(_DWORD *)(*(_DWORD *)(v6 + 48) + 4);
        *(_BYTE *)(v6 + 9) = v14;
        ((void (__cdecl *)(int, char *, int *, _DWORD, _WORD *))dword_101E32A0[2 * (*(_DWORD *)v7 & 0xFF)])(
          v6,
          v7,
          &a1,
          *(_DWORD *)(a4 + 4 * v8),
          v10);
      }
      v7 = v15;
      ++v8;
      result = sub_1001D040(v15, &v16, &v15);
    }
    while ( result );
  }
  *(_BYTE *)(v6 + 3) = 0;
  return result;
}
// 101E32A0: using guessed type int dword_101E32A0[];

//----- (10015310) --------------------------------------------------------
int __cdecl sub_10015310(unsigned int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+4h] [bp+4h]@1

  v1 = word_1010FC78[(a1 >> 5) & 0x1F];
  HIWORD(v3) = word_1010FC78[a1 & 0x1F];
  LOWORD(v3) = v1;
  return v3;
}
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (10015340) --------------------------------------------------------
char *__cdecl sub_10015340(unsigned int a1)
{
  return (char *)&unk_101E37E0 + 20 * ((a1 >> 10) & 0xF);
}

//----- (10015360) --------------------------------------------------------
int __cdecl sub_10015360(unsigned int a1)
{
  char *v1; // eax@1
  char v2; // cl@1
  int result; // eax@2

  v1 = sub_10015340(a1);
  if ( v2 & 1 )
    result = *((_DWORD *)v1 + 2);
  else
    result = *((_DWORD *)v1 + 1);
  return result;
}

//----- (10015380) --------------------------------------------------------
signed int __cdecl sub_10015380(__int16 a1)
{
  signed int result; // eax@1

  result = 1073741828;
  if ( a1 & 0xC000 )
  {
    if ( (a1 & 0xC000) == 0x8000 )
      result = 1073741829;
  }
  else
  {
    result = 1073741830;
  }
  return result;
}

//----- (100153B0) --------------------------------------------------------
signed int __cdecl sub_100153B0(int a1)
{
  int v1; // eax@1
  signed int result; // eax@3

  v1 = a1 & 0xC00000;
  if ( a1 & 0xC00000 )
  {
    if ( v1 == 0x400000 )
      result = 1;
    else
      result = v1 != 0x800000 ? 0 : 2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100153E0) --------------------------------------------------------
int __usercall sub_100153E0@<eax>(_BYTE *a1@<eax>)
{
  int result; // eax@5

  if ( !*a1 )
    goto LABEL_9;
  do
  {
    if ( *a1 == 10 )
      break;
    ++a1;
  }
  while ( *a1 );
  if ( *a1 )
  {
    *a1 = 0;
    result = (int)(a1 + 1);
  }
  else
  {
LABEL_9:
    result = 0;
  }
  return result;
}

//----- (10015410) --------------------------------------------------------
char __usercall sub_10015410@<al>(unsigned __int8 a1@<cl>, int a2@<edi>, unsigned __int8 a3)
{
  signed int v3; // ebx@1
  char result; // al@1
  char v5; // al@2
  char v6; // [sp+Bh] [bp-5h]@1
  char v7; // [sp+Ch] [bp-4h]@2
  char v8; // [sp+Dh] [bp-3h]@1

  v3 = a1;
  result = 0;
  v6 = 0;
  v8 = 0;
  if ( a1 <= (signed int)a3 )
  {
    do
    {
      v7 = v3;
      v5 = sub_10007120(a2, &v7, 0);
      if ( v5 > v6 )
        v6 = v5;
      ++v3;
    }
    while ( v3 <= a3 );
    result = v6;
  }
  return result;
}

//----- (10015460) --------------------------------------------------------
char __usercall sub_10015460@<al>(size_t a1@<edx>, signed int a2@<ecx>, int a3@<esi>, const char *a4, int *a5, char a6, char a7)
{
  unsigned int v7; // ecx@1
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // ecx@1
  char *v11; // eax@4
  char v12; // cl@6
  signed __int16 v13; // dx@9
  int v14; // eax@25
  unsigned int v15; // ebx@29
  unsigned __int8 v16; // al@29
  __int16 v17; // dx@37
  __int16 v18; // cx@37
  unsigned int v19; // edi@42
  signed int v20; // ecx@44
  int v21; // edi@46
  unsigned int v22; // edi@52
  __int16 v23; // ax@52
  __int16 v24; // dx@55
  __int16 v25; // cx@55
  int v26; // eax@58
  char result; // al@63
  int v28; // [sp+0h] [bp-6Ch]@0
  int v29; // [sp+Ch] [bp-60h]@1
  char *v30; // [sp+10h] [bp-5Ch]@6
  signed int v31; // [sp+14h] [bp-58h]@1
  int v32; // [sp+18h] [bp-54h]@1
  int v33; // [sp+1Ch] [bp-50h]@1
  int v34; // [sp+20h] [bp-4Ch]@1
  int v35; // [sp+24h] [bp-48h]@1
  int v36; // [sp+28h] [bp-44h]@1
  int v37; // [sp+2Ch] [bp-40h]@1
  int v38; // [sp+30h] [bp-3Ch]@1
  __int16 v39; // [sp+30h] [bp-3Ch]@29
  __int16 v40; // [sp+32h] [bp-3Ah]@29
  int v41; // [sp+34h] [bp-38h]@1
  size_t v42; // [sp+3Ch] [bp-30h]@1
  signed int v43; // [sp+40h] [bp-2Ch]@9
  int v44; // [sp+44h] [bp-28h]@21
  int v45; // [sp+48h] [bp-24h]@15
  unsigned int v46; // [sp+4Ch] [bp-20h]@29
  signed int v47; // [sp+50h] [bp-1Ch]@1
  char v48; // [sp+54h] [bp-18h]@4

  v31 = a2;
  v42 = a1;
  v7 = strlen(a4);
  v34 = a5[2];
  v8 = a5[1];
  v35 = a5[3];
  v9 = v7;
  v36 = a5[4];
  v47 = v7;
  v32 = *a5;
  v33 = v8;
  v37 = a5[5];
  v29 = 0;
  v41 = *(_WORD *)(*a5 + 28);
  v10 = sub_10007120(*a5, a4, v8);
  v38 = v10;
  if ( (signed __int16)v35 <= 0 )
    LOWORD(v35) = v10;
  if ( (unsigned int)v9 >= 0x14 )
    v11 = (char *)sub_10002760(a3, v9 + 1);
  else
    v11 = &v48;
  v12 = *(_BYTE *)(a3 + 3);
  v30 = v11;
  if ( v12 && a6 && v31 > 0 )
  {
    v13 = 1;
    v43 = 1;
  }
  else
  {
    v43 = 0;
    v13 = 1;
  }
  v45 = v12 && (!a6 || v31 >= 0 && v31 + 1 <= v9);
  v44 = *(_BYTE *)(a3 + 3) && a6 && (v31 < 0 || (signed int)(v31 + v42) < v9);
  if ( (v8 & 3) != 2 )
  {
    if ( v8 & 3 )
    {
      *(_WORD *)(a3 + 438) += (signed __int16)v35 / -2;
      v14 = ((signed __int16)v35 - v38) / 2;
    }
    else
    {
      *(_WORD *)(a3 + 438) += v13 - v35;
      v14 = (signed __int16)v35 - v38;
    }
    v8 = v8 & 0xFFFFFFFE | 2;
    v33 = v8;
    if ( v14 > 0 )
      v29 = v14;
  }
  v15 = v8 & 0xFFFFFFF7 | 4;
  v39 = v35 + v41 + *(_WORD *)(a3 + 438);
  v16 = v34;
  v40 = *(_WORD *)(a3 + 436);
  v46 = v8 & 0xFFFFFFF7 | 4;
  if ( !v43 && !v45 && v44 )
    v16 = 0;
  if ( *(_BYTE *)(a3 + 3) && !a6 && (byte_101B1070 || byte_101E3280) )
  {
    v17 = v36;
    v18 = HIWORD(v35);
  }
  else
  {
    v17 = HIWORD(v35);
    v18 = v36;
  }
  *(_WORD *)(a3 + 428) = v17;
  *(_WORD *)(a3 + 430) = v18;
  sub_10007180(a3 + 392, v32, &unk_10065D59, v35, v8 & 0xFFFFFFF7 | 4, v16, v28);
  *(_WORD *)(a3 + 438) += v29;
  if ( *(_BYTE *)(a3 + 3) )
  {
    if ( v43 )
    {
      v19 = v8 & 0xFFFFFFF3;
      if ( a7 )
        --*(_WORD *)(a3 + 438);
      strncpy(v30, a4, v31);
      v20 = v31;
      if ( v31 >= v47 )
        v20 = v47;
      v30[v20] = 0;
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      v21 = sub_10007180(a3 + 392, v32, v30, v35 - v29, v19 | 0x80000000, 0, v37) + v29;
      if ( a7 )
        *(_WORD *)(a3 + 438) += v41 + 1;
      else
        *(_WORD *)(a3 + 438) += v41;
      v15 = v46;
      v29 = v41 + v21;
      v8 = v33;
    }
    if ( v45 )
    {
      if ( a6 )
      {
        v22 = v34 & 0xFFFF0001 | 1;
        strncpy(v30, &a4[v31], v42);
        v30[v42] = 0;
        v23 = 0;
      }
      else
      {
        LOWORD(v22) = (unsigned __int8)v34;
        strcpy(v30, a4);
        v23 = v35 - v29;
      }
      if ( byte_101B1070 || byte_101E3280 )
      {
        v24 = v36;
        v25 = HIWORD(v35);
      }
      else
      {
        v24 = HIWORD(v35);
        v25 = v36;
      }
      *(_WORD *)(a3 + 428) = v24;
      *(_WORD *)(a3 + 430) = v25;
      v26 = sub_10007180(a3 + 392, v32, v30, v23, v15 | 0x80000000, v22, v37);
      v8 = v33;
      *(_WORD *)(a3 + 438) += v41;
      v29 += v41 + v26;
    }
    if ( v44 )
    {
      if ( a7 )
        ++*(_WORD *)(a3 + 438);
      *(_WORD *)(a3 + 428) = HIWORD(v35);
      *(_WORD *)(a3 + 430) = v36;
      sub_10007180(
        a3 + 392,
        v32,
        &a4[((v42 + v31) & 0x80000000) != 0 ? 0 : v42 + v31],
        v35 - v29,
        v8 & 0xFFFFFFF3 | 0x80000000,
        0,
        v37);
    }
  }
  else
  {
    *(_WORD *)(a3 + 428) = HIWORD(v35);
    *(_WORD *)(a3 + 430) = v36;
    sub_10007180(a3 + 392, v32, a4, v35 - v29, v8 | 0x80000000, v34, v37);
  }
  *(_WORD *)(a3 + 436) = v40;
  result = (char)v30;
  *(_WORD *)(a3 + 438) = v39;
  if ( v30 != &v48 )
    result = sub_10002420(a3, (unsigned int)v30);
  return result;
}
// 101B1070: using guessed type char byte_101B1070;
// 101E3280: using guessed type char byte_101E3280;

//----- (10015960) --------------------------------------------------------
__int16 __cdecl sub_10015960(_BYTE *a1, unsigned int a2)
{
  int v2; // edi@1
  __int16 result; // ax@2
  int v4; // ebx@3
  _BYTE *v5; // edx@3
  int v6; // ebp@3
  int v7; // esi@4
  _BYTE *v8; // edx@4
  int v9; // eax@4

  v2 = 0;
  if ( *a1 )
  {
    v4 = sub_10015380(a2);
    v6 = *((_DWORD *)sub_10015340(a2) + 1);
    do
    {
      v7 = sub_100153E0(v5);
      v9 = sub_10007120(v6, v8, v4);
      if ( v2 <= v9 )
        v2 = v9;
      v5 = (_BYTE *)v7;
    }
    while ( v7 );
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100159C0) --------------------------------------------------------
int __cdecl sub_100159C0(unsigned int a1, unsigned int a2, float *a3)
{
  int v3; // esi@1
  char *v4; // eax@1

  v3 = *((_DWORD *)sub_10015340(a1) + 1);
  v4 = sub_10021080(a2, a3);
  return sub_10007120(v3, v4, 0);
}

//----- (100159F0) --------------------------------------------------------
int sub_100159F0()
{
  void *v0; // ebx@1
  unsigned __int8 v1; // al@2
  char *v2; // esi@2
  char v3; // al@2
  int v4; // eax@2
  char v5; // al@2
  int v6; // edi@2
  char v7; // al@2
  int v8; // edi@2
  char v9; // al@2
  int result; // eax@2

  v0 = &unk_1006FA24;
  do
  {
    v1 = *(_BYTE *)v0;
    v2 = (char *)&unk_101E37E0 + 20 * ((*((_DWORD *)v0 - 1) >> 10) & 0xF);
    v2[12] = *(_BYTE *)v0;
    *(_DWORD *)v2 = FNT_get_fnt_hdr(v1);
    v3 = *((_BYTE *)v0 + 1);
    v2[13] = v3;
    v4 = FNT_get_fnt_hdr((unsigned __int8)v3);
    *((_DWORD *)v2 + 1) = v4;
    v5 = sub_10007120(v4, &unk_100613DC, 0);
    v6 = *((_DWORD *)v2 + 1);
    v2[15] = v5;
    v7 = sub_10015410(0x20u, v6, 0x5Fu);
    v8 = *((_DWORD *)v2 + 1);
    v2[16] = v7;
    v2[17] = sub_10015410(0x30u, v8, 0x39u);
    v9 = *((_BYTE *)v0 + 2);
    v2[14] = v9;
    result = FNT_get_fnt_hdr((unsigned __int8)v9);
    v0 = (char *)v0 + 8;
    *((_DWORD *)v2 + 2) = result;
  }
  while ( (signed int)v0 < (signed int)"ib\\adl\\udb_intf_sms.c" );
  return result;
}
// 100473CE: using guessed type int __cdecl FNT_get_fnt_hdr(_DWORD);

//----- (10015A90) --------------------------------------------------------
char __cdecl sub_10015A90(int a1, const char *a2, int *a3)
{
  return sub_10015460(
           *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240),
           a1,
           a2,
           a3,
           *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
           1);
}

//----- (10015AD0) --------------------------------------------------------
int __cdecl sub_10015AD0(unsigned int a1, char a2)
{
  int v2; // eax@1
  int v3; // edx@1
  char v4; // si@1
  signed int v5; // eax@4

  v2 = *((_DWORD *)sub_10015340(a1) + 1);
  v3 = 1;
  v4 = 1;
  if ( !a2 )
  {
    if ( *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24) > 1 )
      v3 = *(_WORD *)(v2 + 22) - *(_WORD *)(v2 + 24);
    v5 = *(_WORD *)(v2 + 26);
    if ( v5 > 1 )
      v4 = v5;
  }
  return (((v3 << 8) | (unsigned __int8)v4) << 16) | 0x101;
}

//----- (10015B30) --------------------------------------------------------
char __cdecl sub_10015B30(int a1, const char *a2, int *a3, int a4)
{
  int v4; // eax@1
  unsigned int v5; // edi@1
  int v6; // ebp@1
  int v7; // esi@1
  int v8; // eax@1
  char *v9; // edi@1
  int v10; // ecx@2
  int v11; // ebp@2
  int v12; // ecx@6
  char v14; // [sp+13h] [bp-11h]@1
  char *v15; // [sp+14h] [bp-10h]@1
  unsigned int v16; // [sp+18h] [bp-Ch]@1
  unsigned int v17; // [sp+1Ch] [bp-8h]@1
  __int16 v18; // [sp+20h] [bp-4h]@1
  signed int v19; // [sp+28h] [bp+4h]@1
  __int16 v20; // [sp+2Ch] [bp+8h]@1
  __int16 v21; // [sp+2Eh] [bp+Ah]@1

  v4 = a3[2];
  v5 = (unsigned int)a3[2] >> 24;
  v6 = ((unsigned int)a3[2] >> 16) & 0xFF;
  v16 = v4 & 0xFFFF0001 | 1;
  v14 = 1;
  v17 = (v4 & 0xFFFFFF ^ ((v5 + a4) << 24)) & 0xFFFF0001 | 1;
  v7 = a1;
  v15 = (char *)sub_10002760(a1, strlen(a2) + 1);
  strcpy(v15, a2);
  v21 = *(_WORD *)(a1 + 436);
  v19 = *(_WORD *)(*(_DWORD *)(a1 + 56) + 240);
  v20 = *(_WORD *)(v7 + 438);
  v8 = v5 + v6 + *(_WORD *)(*a3 + 24) - *(_WORD *)(*a3 + 26);
  v9 = v15;
  v18 = a4 + v8;
  do
  {
    v11 = sub_100153E0(v9);
    *(_WORD *)(v7 + 438) = v20;
    *(_WORD *)(v7 + 436) = v21;
    if ( v11 )
      *(_DWORD *)(v10 + 8) = v17;
    else
      *(_DWORD *)(v10 + 8) = v16;
    if ( *(_BYTE *)(v7 + 3) && (v12 = *(_DWORD *)(v7 + 56), *(_WORD *)(v12 + 240) != -128) )
    {
      if ( v19 >= (signed int)strlen(v9) || v19 < 0 )
      {
        *(_BYTE *)(v7 + 3) = 0;
        sub_10015460(*(_BYTE *)(v12 + 242), -128, v7, v9, a3, 0, 0);
        *(_BYTE *)(v7 + 3) = 1;
      }
      else
      {
        sub_10015460(*(_BYTE *)(v12 + 242), v19, v7, v9, a3, 1, 0);
      }
      v19 -= strlen(v9);
    }
    else
    {
      if ( !v14 )
      {
        LOBYTE(a4) = *(_BYTE *)(v7 + 3);
        *(_BYTE *)(v7 + 3) = 0;
      }
      sub_10015460(
        *(_BYTE *)(*(_DWORD *)(v7 + 56) + 242),
        v19,
        v7,
        v9,
        a3,
        *(_WORD *)(*(_DWORD *)(v7 + 56) + 240) != -128,
        1);
      if ( !v14 )
        *(_BYTE *)(v7 + 3) = a4;
    }
    v21 += v18;
    v9 = (char *)v11;
    v14 = 0;
  }
  while ( v11 );
  return sub_10002420(v7, (unsigned int)v15);
}

//----- (10015D40) --------------------------------------------------------
int __cdecl sub_10015D40(int a1, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // edi@1
  int v5; // eax@1
  unsigned int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@3
  int result; // eax@3
  int v10; // [sp+18h] [bp+Ch]@1

  v4 = a3;
  v10 = sub_10015AD0(a3, 0);
  v5 = *((_DWORD *)sub_10015340(v4) + 1);
  *(_WORD *)(a1 + 2) = HIWORD(a2) + *(_WORD *)(v5 + 26) - BYTE2(v10) - *(_WORD *)(v5 + 24) + 1;
  v7 = v4 & 0xC000;
  *(_WORD *)(a1 + 6) = HIWORD(a2) + *(_WORD *)(v5 + 22) + (v6 >> 24) - *(_WORD *)(v5 + 24) - 1;
  if ( v7 )
  {
    if ( v7 == 0x4000 )
    {
      *(_WORD *)(a1 + 4) = a2 + 1;
      result = a2 + 1 - a4 - 1;
      *(_WORD *)a1 = result;
    }
    else
    {
      v8 = a2 - (a4 + 2) / 2 - 1;
      *(_WORD *)a1 = v8;
      result = v8 + a4 + 2 - 1;
      *(_WORD *)(a1 + 4) = result;
    }
  }
  else
  {
    result = a2 - 1;
    *(_WORD *)(a1 + 4) = a2 - 1 + a4 + 1;
    *(_WORD *)a1 = a2 - 1;
  }
  return result;
}

//----- (10015E10) --------------------------------------------------------
__int16 __cdecl sub_10015E10(char *a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // eax@1
  unsigned int v6; // edi@1
  int v7; // ebp@1
  int v8; // ebx@1
  char *v9; // eax@1
  int v10; // edx@3

  v5 = sub_10015AD0(a2, 0);
  v6 = v5 >> 24;
  v7 = (v5 >> 16) & 0xFF;
  v8 = *((_DWORD *)sub_10015340(a2) + 1);
  v9 = strchr(a1, 10);
  for ( *(_DWORD *)a5 = 1; v9; ++*(_DWORD *)a5 )
    v9 = strchr(v9 + 1, 10);
  v10 = a3 + v6 + v7 + *(_WORD *)(v8 + 24) - *(_WORD *)(v8 + 26);
  *(_DWORD *)a4 = v10;
  return *(_WORD *)a5 * v10 - a3;
}

//----- (10015EA0) --------------------------------------------------------
char __cdecl sub_10015EA0(int a1, char *a2, const char *a3, __int16 a4, __int16 a5, unsigned int a6, __int16 a7)
{
  char *v7; // eax@1
  int v8; // ebx@1
  signed int v9; // edi@1
  signed int v10; // eax@4
  int v11; // ebp@4
  unsigned int v12; // ebx@4
  int v13; // eax@4
  __int16 v14; // cx@4
  int v15; // edx@4
  int v16; // edi@9
  signed int v17; // ecx@12
  __int64 v18; // rax@12
  __int16 v19; // dx@15
  __int16 v20; // dx@15
  int v21; // eax@17
  signed int v22; // edi@17
  int v24; // [sp+10h] [bp-30h]@1
  unsigned int v25; // [sp+14h] [bp-2Ch]@1
  unsigned int v26; // [sp+18h] [bp-28h]@1
  __int16 v27; // [sp+1Ch] [bp-24h]@2
  int v28; // [sp+1Eh] [bp-22h]@1
  int v29; // [sp+24h] [bp-1Ch]@4
  int v30; // [sp+28h] [bp-18h]@4
  unsigned int v31; // [sp+2Ch] [bp-14h]@4
  int v32; // [sp+30h] [bp-10h]@4
  char v33[6]; // [sp+34h] [bp-Ch]@4
  int v34; // [sp+3Ch] [bp-4h]@4

  v28 = sub_10015310(a6);
  v7 = sub_10015340(a6);
  v8 = *((_DWORD *)v7 + 1);
  v24 = *((_DWORD *)v7 + 1);
  v26 = sub_10015AD0(a6, 0) & 0xFFFFFF00;
  v9 = sub_10015380(a6);
  v25 = v9 & 0xFFFFFFFE | 2;
  if ( a7 & 0x200 )
  {
    v27 = 0;
    a3 = (const char *)&unk_10065D59;
  }
  else
  {
    v27 = a5;
  }
  v10 = sub_100153B0(a6);
  v11 = v10;
  v29 = v10;
  *(_DWORD *)&v33[2] = sub_10015310(a6);
  v30 = v8;
  v12 = v9 & 0xFFFFFFFC;
  v34 = v11;
  v32 = sub_10015AD0(a6, 0);
  v31 = v9 & 0xFFFFFFFC;
  *(_WORD *)v33 = a4;
  v13 = sub_10007120(v30, a2, v9 & 0xFFFFFFFC);
  v14 = v27;
  v15 = 0;
  if ( v27 > 0 && a4 > 0 )
    v15 = *(_WORD *)(v30 + 28);
  if ( a6 & 0xC000 )
  {
    if ( (a6 & 0xC000) == 0x8000 )
    {
      if ( v27 && a4 )
      {
        v17 = v15 + v27 + a4;
        v18 = v13 - *(_WORD *)(v30 + 28) - v27 + 1;
        v16 = (((signed int)v18 - HIDWORD(v18)) >> 1) - 1;
        LODWORD(v18) = v17 / 2 + v16 + 1;
        LOWORD(v17) = v17 - *(_WORD *)(v30 + 28);
        *(_WORD *)v33 = v18;
        v14 = v17 - v18;
        v27 = v14;
      }
      else
      {
        LOWORD(v16) = 0;
        v31 = v12 & 0xFFFFFFFD | 1;
        v25 = v25 & 0xFFFFFFFD | 1;
      }
    }
    else
    {
      v16 = -v27;
    }
  }
  else
  {
    if ( a4 > v13 )
    {
      v19 = v15 - *(_WORD *)(v30 + 28);
      *(_WORD *)v33 = v13;
      v20 = a4 + v19 - v13;
      v14 = v20 + v27;
      v27 += v20;
    }
    LOWORD(v16) = *(_WORD *)v33 - 1;
  }
  *(_WORD *)(a1 + 438) += v16;
  v21 = *(_DWORD *)(a1 + 56);
  v22 = *(_WORD *)(v21 + 240);
  if ( *(_WORD *)v33 > 0 )
  {
    LOBYTE(v21) = sub_10015460(*(_BYTE *)(v21 + 242), v22, a1, a2, &v30, *(_WORD *)(v21 + 240) != -128, 1);
    v14 = v27;
  }
  if ( v14 > 0 )
  {
    if ( v22 != -128 )
      v22 -= strlen(a2);
    LOBYTE(v21) = sub_10015460(
                    *(_BYTE *)(*(_DWORD *)(a1 + 56) + 242),
                    v22,
                    a1,
                    a3,
                    &v24,
                    *(_WORD *)(*(_DWORD *)(a1 + 56) + 240) != -128,
                    1);
  }
  return v21;
}

//----- (100160C0) --------------------------------------------------------
char __cdecl sub_100160C0(char a1)
{
  char result; // al@3
  char v2; // [sp+3h] [bp-A5h]@1
  char *v3; // [sp+4h] [bp-A4h]@1
  int v4; // [sp+8h] [bp-A0h]@1
  int v5; // [sp+Ch] [bp-9Ch]@1
  __int16 *v6; // [sp+10h] [bp-98h]@1
  int v7; // [sp+14h] [bp-94h]@1
  int *v8; // [sp+18h] [bp-90h]@1
  int v9; // [sp+1Ch] [bp-8Ch]@1
  int v10; // [sp+20h] [bp-88h]@1
  __int16 v11; // [sp+24h] [bp-84h]@1
  char v12; // [sp+2Ah] [bp-7Eh]@1

  v5 = 0;
  v6 = &v11;
  v12 = a1;
  v11 = -32716;
  v10 = 4;
  v7 = 128;
  v8 = (int *)&v3;
  v9 = 400;
  v3 = &v2;
  v4 = 1;
  if ( sub_10004EF0(21, (int)&v6) || v4 != 1 )
  {
    sub_10004C50("..\\lib\\adl\\udb_intf_sms.c", 724, 0, 0);
    result = -1;
  }
  else
  {
    result = v2;
  }
  return result;
}

//----- (100161A0) --------------------------------------------------------
void __cdecl sub_100161A0(int a1)
{
  unsigned __int8 v1; // bl@1
  int v2; // edi@1
  float v3; // edx@2
  int v4; // eax@7
  char v5; // al@10
  char v6; // al@12
  double v7; // st7@20
  char v8; // [sp+Dh] [bp-9Bh]@1
  char v9; // [sp+Eh] [bp-9Ah]@1
  unsigned __int8 v10; // [sp+Fh] [bp-99h]@1
  float v11; // [sp+10h] [bp-98h]@1
  float v12; // [sp+14h] [bp-94h]@1
  int v13; // [sp+18h] [bp-90h]@1
  int v14; // [sp+1Ch] [bp-8Ch]@1
  float v15; // [sp+20h] [bp-88h]@1
  float v16; // [sp+24h] [bp-84h]@1
  float v17; // [sp+28h] [bp-80h]@1
  int v18; // [sp+2Ch] [bp-7Ch]@1
  int v19; // [sp+30h] [bp-78h]@1
  int v20; // [sp+34h] [bp-74h]@1
  float v21; // [sp+38h] [bp-70h]@1
  int v22; // [sp+3Ch] [bp-6Ch]@1
  char v23; // [sp+40h] [bp-68h]@7
  char v24; // [sp+50h] [bp-58h]@7
  char v25; // [sp+60h] [bp-48h]@7
  char v26; // [sp+80h] [bp-28h]@7

  v15 = sub_100202E0();
  v8 = 1;
  v16 = 6.283185;
  v1 = -1;
  v17 = 6.283185;
  v9 = sub_10020250(&v21);
  LOBYTE(v12) = -1;
  v13 = 0x3FFFF;
  LOBYTE(v11) = -1;
  LOBYTE(v18) = sub_100194A0(0);
  LOBYTE(v22) = sub_10019520(0);
  v2 = sub_10019240(0);
  LOBYTE(v20) = sub_100194E0(0);
  LOBYTE(v19) = sub_10019560(0);
  v14 = sub_10019320(0);
  v10 = sub_100195A0(0);
  if ( sub_10020BD0() )
  {
    sub_10021020();
    v1 = *(_BYTE *)(dword_101E741C + 812);
    v16 = *(float *)(dword_101E741C + 776);
    v3 = *(float *)(dword_101E741C + 780);
    LOBYTE(v11) = v1;
    v17 = v3;
    if ( v1 >= 0x66u && v1 != -1 )
    {
      v1 = -1;
      LOBYTE(v11) = -1;
    }
    sub_10021010();
    sub_1001BB50(v1, &v12, &v13);
  }
  if ( LOBYTE(v12) == -1 )
  {
    sub_1001E210(a1 + 16, "____", 5);
    *(float *)(a1 + 8) = 6.2831855;
    v7 = 9.8999998e24;
    *(_DWORD *)a1 = 0x7FFFFFFF;
    *(float *)(a1 + 4) = 9.8999998e24;
  }
  else
  {
    sub_1001A100(v13, (int)&v25);
    sub_1001E210(a1 + 16, &v26, 5);
    sub_10047820((int)&v16, (int)&v24);
    sub_10016600(0, v13, (double *)&v23);
    LOBYTE(v4) = sub_100061E0();
    sub_10009D80((int)&v24, (int)&v23, v4, (float *)(a1 + 4), a1 + 8);
    if ( v2 != 0x3FFFF && (sub_1001BA80(LOBYTE(v11), v2, v18, v22) || sub_1001BA80(LOBYTE(v11), v14, v20, v19)) )
    {
      v5 = v10;
      if ( v1 > v10 )
        v5 = LOBYTE(v12);
      LOBYTE(v11) = v5;
      v6 = sub_1005CCF0(v11, a1 + 4, a1);
    }
    else
    {
      v6 = sub_1005CCF0(v12, a1 + 4, a1);
    }
    if ( v6 && v9 == 1 && *(_DWORD *)a1 != 0x7FFFFFFF && 9.8999998e24 != v15 && sub_10022950((bool *)&v8) && !v8 )
      v7 = v15 - (double)*(unsigned int *)a1 * v21;
    else
      v7 = 9.8999998e24;
  }
  *(float *)(a1 + 12) = v7;
}
// 101E741C: using guessed type int dword_101E741C;

//----- (10016430) --------------------------------------------------------
bool __cdecl sub_10016430(float *a1, _BYTE *a2, _BYTE *a3, float *a4, bool *a5, _DWORD *a6, _DWORD *a7)
{
  sub_1001B220();
  sub_1000AF90(&unk_101E4120);
  *a7 = dword_101E5F0C;
  *a1 = flt_101E5F30;
  *a3 = byte_101E5F3C;
  *a4 = flt_101E5F38;
  *a2 = byte_101E5F3D;
  *a5 = byte_101E5EE0 == 2;
  *a6 = dword_101E5F34;
  return sub_10004EA0(47) == 0;
}
// 101E5EE0: using guessed type char byte_101E5EE0;
// 101E5F0C: using guessed type int dword_101E5F0C;
// 101E5F30: using guessed type float flt_101E5F30;
// 101E5F34: using guessed type int dword_101E5F34;
// 101E5F38: using guessed type float flt_101E5F38;
// 101E5F3C: using guessed type char byte_101E5F3C;
// 101E5F3D: using guessed type char byte_101E5F3D;

//----- (100164B0) --------------------------------------------------------
void __cdecl sub_100164B0(unsigned int a1, int a2)
{
  __int64 v2; // [sp-4h] [bp-24h]@0
  int v3; // [sp+8h] [bp-18h]@10
  char v4[4]; // [sp+Ch] [bp-14h]@10
  char v5; // [sp+10h] [bp-10h]@10

  if ( a1 >= 0x3E8 )
  {
    switch ( a1 )
    {
      case 0x3FFFFu:
        *(_DWORD *)a2 = 1600085855;
        *(_WORD *)(a2 + 4) = 24415;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      case 0x3FFFEu:
        *(_DWORD *)a2 = 1801678668;
        *(_WORD *)(a2 + 4) = 25701;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      case 0x3FFFDu:
        *(_DWORD *)a2 = 1330654800;
        *(_WORD *)(a2 + 4) = 83;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      default:
        LODWORD(v2) = a1;
        if ( sub_1001B250(v2) == 11 )
        {
          sub_1001B460(a1, &v3, v4);
          sub_10018B10(v3, v4[0], &v5);
          sub_1001E210(a2, &v5, 7);
        }
        else
        {
          sub_10019760(a1, a2);
        }
        break;
    }
  }
  else
  {
    sub_1001C010(a1, a2);
  }
}

//----- (10016600) --------------------------------------------------------
double *__cdecl sub_10016600(char a1, char a2, double *a3)
{
  unsigned int v3; // esi@1
  double *result; // eax@10
  __int64 v5; // [sp-4h] [bp-60h]@0
  int v6; // [sp+4h] [bp-58h]@7
  char v7; // [sp+8h] [bp-54h]@10
  double v8; // [sp+10h] [bp-4Ch]@3
  double v9; // [sp+18h] [bp-44h]@10
  char v10; // [sp+20h] [bp-3Ch]@10

  v3 = a2;
  if ( a2 == 0x3FFFF )
    goto LABEL_11;
  if ( (unsigned int)a2 >= 0x3E8 )
  {
    if ( a2 == 262141 )
    {
      sub_100203E0(a1, (int)&v8);
      goto LABEL_13;
    }
    LODWORD(v5) = a2;
    if ( sub_1001B250(v5) != 11 )
    {
      sub_100199B0(v3, (int)&v8);
      goto LABEL_13;
    }
    sub_1001B460(v3, &v6, &a2);
    if ( (_BYTE)v6 != -1 && a2 != -1 && sub_100192C0(v6, a2) == v3 )
    {
      sub_100184C0(v6, a2, &v10);
      sub_100183D0((int)&v10, (int)&v7);
      sub_10047820((int)&v7, (int)&v8);
      result = a3;
      *a3 = v8;
      result[1] = v9;
      return result;
    }
LABEL_11:
    result = a3;
    v8 = 6.2831853071796;
    v9 = 6.2831853071796;
    *a3 = 6.2831853071796;
    result[1] = v9;
    return result;
  }
  sub_1001C0A0(a2, (int)&v8);
LABEL_13:
  result = a3;
  *a3 = v8;
  result[1] = v9;
  return result;
}

//----- (10016730) --------------------------------------------------------
void __cdecl sub_10016730(unsigned int a1, char *a2)
{
  __int64 v2; // [sp-4h] [bp-10h]@0
  char v3[4]; // [sp+4h] [bp-8h]@2
  int v4; // [sp+8h] [bp-4h]@2

  LODWORD(v2) = a1;
  if ( sub_1001B250(v2) == 11 )
  {
    sub_1001B460(a1, &v4, v3);
    sub_10018B10(v4, v3[0], a2);
  }
  else
  {
    sub_100164B0(a1, (int)a2);
  }
}

//----- (10016790) --------------------------------------------------------
signed int __cdecl sub_10016790(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    switch ( *(_BYTE *)a1 )
    {
      case 0:
      case 0x10:
        result = *(_DWORD *)(a1 + 40);
        break;
      case 2:
      case 5:
      case 9:
      case 0x13:
      case 0x16:
        result = *(_DWORD *)(a1 + 44);
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (100167E0) --------------------------------------------------------
double __cdecl sub_100167E0(int a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  int v4; // [sp+4h] [bp+4h]@1
  int v5; // [sp+4h] [bp+4h]@2
  int v6; // [sp+4h] [bp+4h]@3
  float v7; // [sp+8h] [bp+8h]@2
  float v8; // [sp+8h] [bp+8h]@3

  *(float *)&v4 = (double)(unsigned __int16)a1;
  v2 = *(float *)&v4;
  if ( LOBYTE(a2) )
  {
    *(float *)&v5 = v2 * 100.0;
    v7 = *(float *)&v5 * 0.3048000037670135;
    result = v7;
  }
  else
  {
    *(float *)&v6 = v2 - 1000.0;
    v8 = *(float *)&v6 * 0.3048000037670135;
    result = v8;
  }
  return result;
}

//----- (10016840) --------------------------------------------------------
int __cdecl sub_10016840(char a1, char a2, _DWORD *a3, unsigned __int16 *a4, float *a5, float *a6, _BYTE *a7, _BYTE *a8, _BYTE *a9)
{
  int v9; // ecx@2
  unsigned __int16 *v10; // ecx@2
  char v11; // dl@2
  int v12; // ecx@3
  int result; // eax@3

  *a5 = 0.0;
  *a6 = 0.0;
  *a7 = 4;
  *a8 = 0;
  *a9 = 0;
  if ( a1 )
  {
    *a5 = (double)(*a4 & 0x7FFF);
    *a7 = a2;
    *a8 = (*a4 >> 15) & 1;
    *a5 = sub_100167E0(*a4 & 0x7FFF, COERCE_FLOAT(((unsigned int)*a4 >> 15) & 0xFFFFFF01));
    *a3 += (unsigned __int16)word_101E404A;
    v10 = (unsigned __int16 *)((unsigned __int16)word_101E404A + v9);
    if ( v11 == 3 )
    {
      *a6 = (double)(*v10 & 0x7FFF);
      *a9 = (*v10 >> 15) & 1;
      *a6 = sub_100167E0(*v10 & 0x7FFF, COERCE_FLOAT(((unsigned int)*v10 >> 15) & 0xFFFFFF01));
      *a3 += (unsigned __int16)word_101E404A;
      result = (unsigned __int16)word_101E404A + v12;
    }
    else
    {
      result = (int)v10;
      *a6 = 0.0;
    }
  }
  else
  {
    result = (int)a4;
  }
  return result;
}
// 101E404A: using guessed type __int16 word_101E404A;

//----- (10016950) --------------------------------------------------------
bool __cdecl sub_10016950(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  char v3; // bl@1
  char v4; // cl@1
  unsigned int v5; // eax@5
  unsigned int v6; // edx@5
  unsigned int v7; // ecx@5
  unsigned int v8; // eax@5
  signed int v9; // esi@5
  signed int v10; // ecx@7
  int v11; // edx@7
  unsigned int v12; // eax@8
  float v13; // ST18_4@9
  float v14; // ST18_4@9
  float v15; // ST18_4@9
  int v16; // ecx@11
  char v18; // [sp+Bh] [bp-29h]@1
  float v19; // [sp+Ch] [bp-28h]@1
  float v20; // [sp+14h] [bp-20h]@5
  float v21; // [sp+18h] [bp-1Ch]@5
  float v22; // [sp+1Ch] [bp-18h]@5
  float v23; // [sp+20h] [bp-14h]@5
  int v24; // [sp+24h] [bp-10h]@5
  unsigned int v25; // [sp+28h] [bp-Ch]@5
  unsigned int v26; // [sp+2Ch] [bp-8h]@5
  unsigned int v27; // [sp+30h] [bp-4h]@5
  char v28; // [sp+38h] [bp+4h]@1

  v19 = 0.0;
  v1 = dword_101E4110;
  v2 = a1;
  v3 = ((unsigned int)*(_WORD *)(a1 + 5) >> 15) & 1;
  v4 = ((unsigned int)*(_WORD *)(a1 + 5) >> 14) & 1;
  v18 = 0;
  v28 = ((unsigned int)*(_WORD *)(a1 + 5) >> 14) & 1;
  if ( v3 )
  {
    if ( *(float *)(dword_101E4110 + 20836) >= 0.30000001 && (*(_DWORD *)(v2 + 9) >> 28) & 1 )
      v18 = 1;
    v5 = *(_BYTE *)(v2 + 8);
    v24 = *(_BYTE *)(v2 + 8) & 3;
    v6 = v5 >> 2;
    v7 = v5;
    v27 = v5 >> 6;
    v8 = *(_DWORD *)(v2 + 9);
    v25 = v6 & 3;
    v26 = (v7 >> 4) & 3;
    v20 = (double)(v8 & 0x7F);
    v21 = (double)((v8 >> 7) & 0x7F);
    v22 = (double)((v8 >> 14) & 0x7F);
    v23 = (double)((v8 >> 21) & 0x7F);
    v9 = 0;
    do
    {
      if ( 0.0 != *(float *)((char *)&v20 + v9) )
      {
        v10 = *(int *)((char *)&v24 + v9);
        v11 = 0;
        if ( v10 >= 4 )
        {
          v12 = ((unsigned int)(v10 - 4) >> 2) + 1;
          v11 = 4 * v12;
          do
          {
            --v12;
            v13 = *(float *)((char *)&v20 + v9) * 0.1000000014901161;
            v14 = v13 * 0.1000000014901161;
            v15 = v14 * 0.1000000014901161;
            *(float *)((char *)&v20 + v9) = v15;
          }
          while ( v12 );
        }
        if ( v11 < v10 )
        {
          v16 = v10 - v11;
          do
          {
            --v16;
            *(float *)((char *)&v20 + v9) = *(float *)((char *)&v20 + v9) * 0.1000000014901161;
          }
          while ( v16 );
        }
      }
      if ( *(float *)(v1 + 20836) <= (double)*(float *)((char *)&v20 + v9) )
        v19 = *(float *)((char *)&v20 + v9);
      v9 += 4;
    }
    while ( v9 < 16 );
    v4 = v28;
  }
  return !(*(_WORD *)(v2 + 5) & 0x2000)
      && (!v3 || *(_BYTE *)(v1 + 20832) && 0.0 != v19)
      && (!v4 || *(_BYTE *)(v1 + 20833))
      && !v18;
}
// 101E4110: using guessed type int dword_101E4110;

//----- (10016B40) --------------------------------------------------------
char __cdecl sub_10016B40(_DWORD *a1, unsigned __int8 a2, _BYTE *a3)
{
  char result; // al@2

  if ( !byte_101E37BC )
  {
    result = dword_101E37B0;
    if ( dword_101E37B0 == *a1 )
    {
      result = byte_101E37AC;
      if ( (unsigned __int8)byte_101E37AC <= a2 && a2 != -1 )
      {
        *a3 = byte_101E37AC;
        result = dword_101E37C0;
        *a1 = dword_101E37C0;
        byte_101E37BC = 0;
      }
    }
  }
  return result;
}
// 101E37AC: using guessed type char byte_101E37AC;
// 101E37B0: using guessed type int dword_101E37B0;
// 101E37BC: using guessed type char byte_101E37BC;
// 101E37C0: using guessed type int dword_101E37C0;

//----- (10016B80) --------------------------------------------------------
int __cdecl sub_10016B80(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-Ch]@3
  char v4; // [sp+7h] [bp-9h]@3

  if ( a1 == -1 )
  {
    *(_DWORD *)a2 = 538976288;
    *(_WORD *)(a2 + 4) = 32;
  }
  else
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(
      dword_101E3950 + a1 * (unsigned __int16)word_101E3954,
      5,
      &v3);
    sub_1001B340(&v4, 5, a2);
  }
  return sub_1001E3A0(a2, 5);
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3950: using guessed type int dword_101E3950;
// 101E3954: using guessed type __int16 word_101E3954;

//----- (10016C10) --------------------------------------------------------
int __cdecl sub_10016C10(int *a1)
{
  char v1; // dl@1
  int result; // eax@1
  char v3; // [sp+4h] [bp-10h]@1
  char v4; // [sp+7h] [bp-Dh]@1

  (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(*a1, 14, &v3);
  v1 = v4;
  *a1 += (unsigned __int16)word_101E4008;
  result = *a1;
  if ( (v1 & 0xFu) <= 3 )
    *a1 = result + (unsigned __int16)word_101E400A;
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E4008: using guessed type __int16 word_101E4008;
// 101E400A: using guessed type __int16 word_101E400A;

//----- (10016C60) --------------------------------------------------------
char __cdecl sub_10016C60(int a1, int a2, void *a3)
{
  float *v3; // ebp@1
  char *v4; // ebx@1
  int v5; // eax@1
  char v6; // dl@1
  char *v7; // eax@1
  int v8; // edx@2
  char *v9; // ecx@3
  int v10; // eax@3
  int v11; // edx@7
  double v12; // st7@12
  char *v13; // ecx@14
  unsigned __int16 *v14; // eax@14
  char *v15; // ecx@17
  unsigned __int16 *v16; // eax@17
  int v17; // edx@21
  int v18; // edx@32
  int v19; // edx@42
  int v20; // edx@56
  char v21; // al@60
  unsigned __int8 v22; // al@61
  unsigned __int16 *v24; // [sp-18h] [bp-68h]@9
  float *v25; // [sp-14h] [bp-64h]@9
  float *v26; // [sp-10h] [bp-60h]@9
  float *v27; // [sp-10h] [bp-60h]@56
  char *v28; // [sp-Ch] [bp-5Ch]@9
  char *v29; // [sp-Ch] [bp-5Ch]@56
  char *v30; // [sp-8h] [bp-58h]@9
  char *v31; // [sp-8h] [bp-58h]@56
  char *v32; // [sp-4h] [bp-54h]@9
  char *v33; // [sp-4h] [bp-54h]@56
  char *v34; // [sp+10h] [bp-40h]@3
  char *v35; // [sp+10h] [bp-40h]@14
  char *v36; // [sp+10h] [bp-40h]@17
  char *v37; // [sp+10h] [bp-40h]@22
  char *v38; // [sp+10h] [bp-40h]@25
  char *v39; // [sp+10h] [bp-40h]@33
  char *v40; // [sp+10h] [bp-40h]@36
  char *v41; // [sp+10h] [bp-40h]@43
  char *v42; // [sp+10h] [bp-40h]@46
  char *v43; // [sp+10h] [bp-40h]@51
  float *v44; // [sp+14h] [bp-3Ch]@1
  int v45; // [sp+18h] [bp-38h]@1

  memset(a3, 0, 0x3Cu);
  *((float *)a3 + 3) = 9.9999996e24;
  *((float *)a3 + 4) = 9.9999996e24;
  *((_BYTE *)a3 + 7) = 4;
  v3 = (float *)((char *)a3 + 12);
  v4 = (char *)a3 + 7;
  v44 = (float *)((char *)a3 + 16);
  (*(void (__cdecl **)(_DWORD, signed int, int *))dword_101E37B8)(*(_DWORD *)a1, 50, &v45);
  *(_DWORD *)a1 += (unsigned __int16)word_101E4016;
  v5 = (unsigned __int16)word_101E4016;
  v6 = v45 & 0x1F;
  *(_BYTE *)a2 = 0;
  *(_BYTE *)a3 = v6;
  v7 = (char *)&v45 + v5;
  switch ( v45 & 0x1F )
  {
    case 0:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E401A;
      v8 = (unsigned __int16)word_101E401A;
      goto LABEL_3;
    case 1:
      *(_DWORD *)a1 += (unsigned __int16)word_101E401C;
      *v4 = 1;
      v12 = sub_100167E0(
              *((_WORD *)v7 + 1) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v7 + 1) >> 15) & 0xFFFFFF01));
      goto LABEL_13;
    case 2:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E401E;
      v35 = v7;
      v13 = v7;
      v14 = (unsigned __int16 *)&v7[(unsigned __int16)word_101E401E];
      if ( (*v13 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_101E4048;
        v13 = v35;
        v14 = (unsigned __int16 *)((char *)v14 + (unsigned __int16)word_101E4048);
      }
      sub_10016840(
        *v13 & 1,
        (*((_WORD *)v13 + 2) >> 14) & 3,
        (_DWORD *)a1,
        v14,
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 3:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4020;
      v36 = v7;
      v15 = v7;
      v16 = (unsigned __int16 *)&v7[(unsigned __int16)word_101E4020];
      if ( (*v15 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_101E4048;
        v15 = v36;
        v16 = (unsigned __int16 *)((char *)v16 + (unsigned __int16)word_101E4048);
      }
      sub_10016840(
        *v15 & 1,
        (*((_WORD *)v15 + 2) >> 14) & 3,
        (_DWORD *)a1,
        v16,
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 4:
      *(_DWORD *)a1 += (unsigned __int16)word_101E4022;
      sub_10016840(
        ((unsigned __int8)v7[2] >> 2) & 1,
        v7[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[(unsigned __int16)word_101E4022],
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 5:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4024;
      v17 = (unsigned __int16)word_101E4024;
      goto LABEL_22;
    case 6:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      v38 = v7;
      if ( (*v7 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_101E404C;
        v7 += (unsigned __int16)word_101E404C;
      }
      *(_DWORD *)a1 += (unsigned __int16)word_101E4026;
      sub_10016840(
        *v38 & 1,
        v38[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[(unsigned __int16)word_101E4026],
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 7:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      if ( (*v7 & 0xF0u) <= 0x30 )
        *(_DWORD *)a1 += (unsigned __int16)word_101E4048;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4028;
      *v4 = 1;
      v12 = sub_100167E0(
              *((_WORD *)v7 + 2) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v7 + 2) >> 15) & 0xFFFFFF01));
      goto LABEL_13;
    case 8:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E402A;
      v18 = (unsigned __int16)word_101E402A;
      goto LABEL_33;
    case 9:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E402C;
      v8 = (unsigned __int16)word_101E402C;
      goto LABEL_3;
    case 0xA:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E402E;
      v40 = v7;
      v9 = v7;
      v10 = (int)&v7[(unsigned __int16)word_101E402E];
      if ( (*v9 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_101E404C;
        v9 = v40;
        v10 += (unsigned __int16)word_101E404C;
      }
      v32 = (char *)a3 + 9;
      v30 = (char *)a3 + 8;
      v28 = (char *)a3 + 7;
      v26 = (float *)((char *)a3 + 16);
      v25 = (float *)((char *)a3 + 12);
      v24 = (unsigned __int16 *)v10;
      LOBYTE(v10) = v9[4];
      goto LABEL_10;
    case 0xB:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      if ( (*v7 & 0xF0u) <= 0x30 )
        *(_DWORD *)a1 += (unsigned __int16)word_101E404C;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4030;
      *v4 = 1;
      v12 = sub_100167E0(
              *((_WORD *)v7 + 2) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v7 + 2) >> 15) & 0xFFFFFF01));
      goto LABEL_13;
    case 0xC:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4032;
      v19 = (unsigned __int16)word_101E4032;
      goto LABEL_43;
    case 0xD:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4034;
      v19 = (unsigned __int16)word_101E4034;
LABEL_43:
      v41 = v7;
      v9 = v7;
      v10 = (int)&v7[v19];
      if ( (*v9 & 0xF0u) > 0x30 )
        goto LABEL_9;
      *(_DWORD *)a1 += (unsigned __int16)word_101E404C;
      v11 = (unsigned __int16)word_101E404C;
      v9 = v41;
      goto LABEL_8;
    case 0xE:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      v42 = v7;
      if ( (*v7 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_101E404C;
        v7 += (unsigned __int16)word_101E404C;
      }
      *(_DWORD *)a1 += (unsigned __int16)word_101E4036;
      sub_10016840(
        *v42 & 1,
        v42[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[(unsigned __int16)word_101E4036],
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 0xF:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4038;
      v18 = (unsigned __int16)word_101E4038;
      goto LABEL_33;
    case 0x10:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E403A;
      v8 = (unsigned __int16)word_101E403A;
LABEL_3:
      v34 = v7;
      v9 = v7;
      v10 = (int)&v7[v8];
      if ( (*v9 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_101E4048;
        v9 = v34;
        v10 += (unsigned __int16)word_101E4048;
      }
      if ( (v9[2] & 0xF0u) > 0x30 )
        goto LABEL_9;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4048;
      goto LABEL_7;
    case 0x11:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      v43 = v7;
      if ( (*v7 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_101E404C;
        v7 += (unsigned __int16)word_101E404C;
      }
      *(_DWORD *)a1 += (unsigned __int16)word_101E403C;
      sub_10016840(
        *v43 & 1,
        v43[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[(unsigned __int16)word_101E403C],
        v3,
        v44,
        v4,
        (_BYTE *)a3 + 8,
        (_BYTE *)a3 + 9);
      break;
    case 0x12:
      *(_DWORD *)a1 += (unsigned __int16)word_101E403E;
      *v4 = 1;
      v12 = sub_100167E0(
              *((_WORD *)v7 + 1) & 0x7FFF,
              COERCE_FLOAT(((unsigned int)*((_WORD *)v7 + 1) >> 15) & 0xFFFFFF01));
LABEL_13:
      *v3 = v12;
      break;
    case 0x13:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4040;
      v18 = (unsigned __int16)word_101E4040;
LABEL_33:
      v39 = v7;
      v9 = v7;
      v10 = (int)&v7[v18];
      if ( (*v9 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_101E4048;
        v9 = v39;
LABEL_7:
        v11 = (unsigned __int16)word_101E4048;
LABEL_8:
        v10 += v11;
      }
LABEL_9:
      v32 = (char *)a3 + 9;
      v30 = (char *)a3 + 8;
      v28 = (char *)a3 + 7;
      v26 = (float *)((char *)a3 + 16);
      v25 = (float *)((char *)a3 + 12);
      v24 = (unsigned __int16 *)v10;
      LOWORD(v10) = *((_WORD *)v9 + 2) >> 14;
      goto LABEL_10;
    case 0x14:
      *(_DWORD *)a1 += (unsigned __int16)word_101E4042;
      v33 = (char *)a3 + 9;
      v31 = (char *)a3 + 8;
      v29 = (char *)a3 + 7;
      v27 = (float *)((char *)a3 + 16);
      v20 = (unsigned __int16)word_101E4042;
      goto LABEL_57;
    case 0x15:
      *(_DWORD *)a1 += (unsigned __int16)word_101E4044;
      v33 = (char *)a3 + 9;
      v31 = (char *)a3 + 8;
      v29 = (char *)a3 + 7;
      v27 = (float *)((char *)a3 + 16);
      v20 = (unsigned __int16)word_101E4044;
LABEL_57:
      sub_10016840(
        ((unsigned __int8)v7[2] >> 2) & 1,
        v7[2] & 3,
        (_DWORD *)a1,
        (unsigned __int16 *)&v7[v20],
        v3,
        v27,
        v29,
        v31,
        v33);
      break;
    case 0x16:
      *(_BYTE *)a2 = ((unsigned __int8)*v7 >> 1) & 7;
      *(_DWORD *)a1 += (unsigned __int16)word_101E4046;
      v17 = (unsigned __int16)word_101E4046;
LABEL_22:
      v37 = v7;
      v9 = v7;
      v10 = (int)&v7[v17];
      if ( (*v9 & 0xF0u) <= 0x30 )
      {
        *(_DWORD *)a1 += (unsigned __int16)word_101E404C;
        v9 = v37;
        v10 += (unsigned __int16)word_101E404C;
      }
      v32 = (char *)a3 + 9;
      v30 = (char *)a3 + 8;
      v28 = (char *)a3 + 7;
      v26 = (float *)((char *)a3 + 16);
      v25 = (float *)((char *)a3 + 12);
      v24 = (unsigned __int16 *)v10;
      LOBYTE(v10) = v9[6];
LABEL_10:
      sub_10016840(*v9 & 1, v10 & 3, (_DWORD *)a1, v24, v25, v26, v28, v30, v32);
      break;
    default:
      v21 = v45 & 0x3F;
      *(_BYTE *)a3 = 24;
      LOBYTE(v45) = v21;
      *(_DWORD *)a1 = 0xFFFFFF;
      break;
  }
  v22 = v45;
  if ( v45 & 0x40 )
    *(_DWORD *)a1 += (unsigned __int16)word_101E4018;
  return v22 >> 7;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E4016: using guessed type __int16 word_101E4016;
// 101E4018: using guessed type __int16 word_101E4018;
// 101E401A: using guessed type __int16 word_101E401A;
// 101E401C: using guessed type __int16 word_101E401C;
// 101E401E: using guessed type __int16 word_101E401E;
// 101E4020: using guessed type __int16 word_101E4020;
// 101E4022: using guessed type __int16 word_101E4022;
// 101E4024: using guessed type __int16 word_101E4024;
// 101E4026: using guessed type __int16 word_101E4026;
// 101E4028: using guessed type __int16 word_101E4028;
// 101E402A: using guessed type __int16 word_101E402A;
// 101E402C: using guessed type __int16 word_101E402C;
// 101E402E: using guessed type __int16 word_101E402E;
// 101E4030: using guessed type __int16 word_101E4030;
// 101E4032: using guessed type __int16 word_101E4032;
// 101E4034: using guessed type __int16 word_101E4034;
// 101E4036: using guessed type __int16 word_101E4036;
// 101E4038: using guessed type __int16 word_101E4038;
// 101E403A: using guessed type __int16 word_101E403A;
// 101E403C: using guessed type __int16 word_101E403C;
// 101E403E: using guessed type __int16 word_101E403E;
// 101E4040: using guessed type __int16 word_101E4040;
// 101E4042: using guessed type __int16 word_101E4042;
// 101E4044: using guessed type __int16 word_101E4044;
// 101E4046: using guessed type __int16 word_101E4046;
// 101E4048: using guessed type __int16 word_101E4048;
// 101E404C: using guessed type __int16 word_101E404C;

//----- (100173C0) --------------------------------------------------------
char __cdecl sub_100173C0(int a1, _BYTE *a2)
{
  _BYTE *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-3Ch]@2

  v2 = a2;
  *a2 = 0;
  do
  {
    ++*v2;
    result = sub_10016C60(a1, (int)&a2, &v4);
  }
  while ( result );
  return result;
}

//----- (100173F0) --------------------------------------------------------
int __cdecl sub_100173F0(int a1, char a2, int a3)
{
  int result; // eax@3

  if ( !byte_101E37BC && a1 != 0xFFFFFF )
  {
    result = a3;
    if ( a3 != 0xFFFFFF )
    {
      byte_101E37AC = a2;
      dword_101E37C0 = a3;
      dword_101E37B0 = a1;
      byte_101E37BC = 0;
    }
  }
  return result;
}
// 101E37AC: using guessed type char byte_101E37AC;
// 101E37B0: using guessed type int dword_101E37B0;
// 101E37BC: using guessed type char byte_101E37BC;
// 101E37C0: using guessed type int dword_101E37C0;

//----- (10017430) --------------------------------------------------------
signed int __cdecl sub_10017430(unsigned int a1, int a2)
{
  signed int v2; // esi@1
  char v3; // dl@2
  char v4; // al@3
  char v5; // bl@3
  signed int result; // eax@7
  char v7; // [sp+8h] [bp-18h]@3
  char v8; // [sp+Ch] [bp-14h]@3
  char v9; // [sp+Dh] [bp-13h]@3
  char v10; // [sp+Eh] [bp-12h]@3
  char v11; // [sp+Fh] [bp-11h]@3
  char v12; // [sp+10h] [bp-10h]@3
  char v13; // [sp+11h] [bp-Fh]@3
  char v14; // [sp+14h] [bp-Ch]@4

  v2 = 0x3FFFF;
  if ( (word_10078810[2 * *(_BYTE *)(a2 + 1)] >> 4) & 1 )
  {
    v3 = *(_BYTE *)(a2 + 2);
    if ( (word_10078810[2 * (unsigned __int8)v3] >> 4) & 1 )
    {
      v4 = *(_BYTE *)(a2 + 3);
      v10 = *(_BYTE *)(a2 + 1);
      v8 = 82;
      v9 = 87;
      v11 = v3;
      v12 = v4;
      v13 = 0;
      sub_1001E3A0((int)&v8, 6);
      v5 = sub_1001AB60(a1);
      v7 = 0;
      if ( v5 > 0 )
      {
        while ( 1 )
        {
          v2 = sub_1001A600(a1, v7, 0);
          sub_10019760(v2, (int)&v14);
          if ( !strcmp(&v8, &v14) )
            break;
          v2 = sub_1001A600(a1, v7, 1);
          sub_10019760(v2, (int)&v14);
          if ( !strcmp(&v8, &v14) )
            break;
          if ( ++v7 >= v5 )
            return 0x3FFFF;
        }
      }
    }
    result = v2;
  }
  else
  {
    result = 0x3FFFF;
  }
  return result;
}

//----- (100175C0) --------------------------------------------------------
void __usercall sub_100175C0(int a1@<esi>, int a2, unsigned int a3, _BYTE *a4)
{
  int v4; // ebx@1
  _BYTE *v5; // ebp@1
  float v6; // edi@1
  unsigned __int8 v7; // cl@1
  int v8; // ebx@1
  unsigned __int16 v9; // ax@1
  int v10; // eax@4
  unsigned __int8 v11; // al@7
  unsigned int v12; // ecx@7
  unsigned __int16 v13; // ax@7
  float *v14; // ecx@9
  _BYTE *v15; // eax@9
  float *v16; // edx@9
  signed int v17; // edi@9
  __int16 v18; // di@12
  unsigned __int8 v19; // dl@13
  unsigned int v20; // eax@13
  char v21; // cl@13
  int v22; // eax@13
  int v23; // eax@20
  int v24; // eax@27
  unsigned int v25; // eax@32
  _BYTE *v26; // ebx@32
  int *v27; // ebp@32
  int v28; // edx@34
  int v29; // edi@34
  bool v30; // sf@34
  unsigned __int8 v31; // of@34
  unsigned int v32; // eax@35
  int v33; // edx@38
  int v34; // edi@48
  char v35; // bl@49
  char v36; // al@51
  char v37; // cl@51
  double v38; // st7@60
  signed int v39; // edi@60
  char v40; // cl@61
  signed int v41; // ebp@68
  int v42; // [sp+Eh] [bp-72h]@4
  float v43; // [sp+14h] [bp-6Ch]@5
  float v44; // [sp+18h] [bp-68h]@7
  float v45; // [sp+1Ch] [bp-64h]@68
  float v46; // [sp+20h] [bp-60h]@32
  unsigned __int8 v47; // [sp+24h] [bp-5Ch]@1
  unsigned __int16 v48; // [sp+25h] [bp-5Bh]@7
  unsigned int v49; // [sp+27h] [bp-59h]@1
  char v50; // [sp+2Bh] [bp-55h]@8
  unsigned __int8 v51; // [sp+2Ch] [bp-54h]@13
  unsigned int v52; // [sp+2Dh] [bp-53h]@13
  int v53; // [sp+34h] [bp-4Ch]@32
  unsigned int v54; // [sp+38h] [bp-48h]@32
  unsigned int v55; // [sp+3Ch] [bp-44h]@32
  unsigned int v56; // [sp+40h] [bp-40h]@32
  char v57; // [sp+44h] [bp-3Ch]@51
  float v58; // [sp+50h] [bp-30h]@55

  v4 = a2;
  v5 = a4;
  v6 = *(float *)&a3;
  (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_101E37B8)(a2, 14, &v47);
  v7 = v49;
  v8 = (unsigned __int16)word_101E4008 + v4;
  v9 = v49 & 0xF;
  a2 = v8;
  if ( v9 == 9 )
  {
    *(_DWORD *)(a1 + 24) = 0x3FFFF;
  }
  else
  {
    if ( v9 > 3u )
    {
      v43 = v6;
      HIWORD(v43) = (v9 << 10) | (v49 >> 6) & 0x3FC | BYTE2(v6) & 3;
      v10 = LODWORD(v43);
    }
    else
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v8, 1, (char *)&v42 + 1);
      a2 = (unsigned __int16)word_101E400A + v8;
      v10 = sub_10019950(
              v49 & 0xF,
              ((unsigned int)(unsigned __int16)v49 >> 8) & 0xFC00FF | ((4 * BYTE1(v42) | HIWORD(v49) & 0xC00) << 6));
      v7 = v49;
    }
    *(_DWORD *)(a1 + 24) = v10;
  }
  v11 = v47;
  *(_BYTE *)(a1 + 8) = (v7 >> 7) & 1;
  *(_BYTE *)(a1 + 9) = (v11 >> 6) & 1;
  v12 = *(unsigned int *)((char *)&v49 + 2);
  *(_BYTE *)(a1 + 7) = v11 >> 7;
  LODWORD(v44) = v12 & 0x3FF;
  *(_BYTE *)(a1 + 6) = (v11 >> 1) & 0x1F;
  v13 = v48;
  *(float *)(a1 + 48) = (double)(v12 & 0x3FF) * 0.0001745329209370539;
  *(_BYTE *)(a1 + 10) = (v12 >> 12) & 1;
  sub_10016B80(v13, a1);
  *(_BYTE *)(a1 + 21) = -1;
  if ( (unsigned __int16)word_101E4008 >= 8u )
    *(_BYTE *)(a1 + 21) = v50;
  v14 = (float *)(a1 + 32);
  v15 = (_BYTE *)(a1 + 17);
  v16 = (float *)(a1 + 32);
  v17 = 4;
  do
  {
    *(v15 - 4) = 15;
    *v15 = 63;
    *v16 = 0.0;
    ++v16;
    ++v15;
    --v17;
  }
  while ( v17 );
  if ( (unsigned __int16)word_101E4008 < 0xDu )
  {
    if ( *(_BYTE *)(a1 + 9) )
      *(_BYTE *)(a1 + 13) = 0;
    goto LABEL_47;
  }
  v18 = HIWORD(v49);
  if ( HIWORD(v49) & 0x8000 )
  {
    v53 = v51 & 3;
    v54 = ((unsigned int)v51 >> 2) & 3;
    v56 = (unsigned int)v51 >> 6;
    v25 = v52;
    v55 = ((unsigned int)v51 >> 4) & 3;
    LODWORD(v46) = v52 & 0x7F;
    *v14 = (double)LODWORD(v46);
    LODWORD(v46) = (v25 >> 7) & 0x7F;
    *(float *)(a1 + 36) = (double)LODWORD(v46);
    LODWORD(v46) = (v25 >> 14) & 0x7F;
    *(float *)(a1 + 40) = (double)LODWORD(v46);
    LODWORD(v46) = (v25 >> 21) & 0x7F;
    *(float *)(a1 + 44) = (double)LODWORD(v46);
    v26 = (_BYTE *)(a1 + 13);
    v27 = &v53;
    LODWORD(v43) = 4;
    while ( 1 )
    {
      if ( 0.0 != *v14 )
      {
        v28 = *v27;
        v29 = 0;
        v31 = __OFSUB__(*v27, 4);
        v30 = *v27 - 4 < 0;
        *v26 = 4;
        if ( !(v30 ^ v31) )
        {
          v32 = ((unsigned int)(v28 - 4) >> 2) + 1;
          v29 = 4 * v32;
          do
          {
            --v32;
            v44 = *v14 * 0.1000000014901161;
            v44 = v44 * 0.1000000014901161;
            v44 = v44 * 0.1000000014901161;
            *v14 = v44;
          }
          while ( v32 );
        }
        if ( v29 < v28 )
        {
          v33 = v28 - v29;
          do
          {
            --v33;
            *v14 = *v14 * 0.1000000014901161;
          }
          while ( v33 );
        }
        if ( *(float *)(dword_101E4110 + 20836) <= (double)*v14 )
          goto LABEL_43;
        *v14 = 0.0;
      }
      *v26 = 15;
LABEL_43:
      ++v27;
      ++v14;
      ++v26;
      --LODWORD(v43);
      if ( v43 == 0.0 )
        goto LABEL_47;
    }
  }
  v19 = v51;
  *(_BYTE *)(a1 + 14) = v51 >> 4;
  v20 = v52;
  v21 = v52 & 0xF;
  *(_BYTE *)(a1 + 13) = v19 & 0xF;
  *(_BYTE *)(a1 + 15) = v21;
  *(_BYTE *)(a1 + 16) = (v20 >> 4) & 0xF;
  *(_BYTE *)(a1 + 17) = BYTE1(v20) & 0x3F;
  *(_BYTE *)(a1 + 20) = (v20 >> 26) & 0x3F;
  *(_BYTE *)(a1 + 18) = (v20 >> 14) & 0x3F;
  *(_BYTE *)(a1 + 19) = (v20 >> 20) & 0x3F;
  v22 = 0;
  while ( *(_BYTE *)(a1 + v22 + 13) != 3 )
  {
    if ( ++v22 >= 4 )
      goto LABEL_18;
  }
  *(_BYTE *)(a1 + 9) = 1;
LABEL_18:
  if ( !*v5 )
  {
    if ( v18 & 0x4000 )
    {
      v23 = 0;
      while ( *(_BYTE *)(a1 + v23 + 13) != 15 )
      {
        if ( ++v23 >= 4 )
          goto LABEL_25;
      }
      *(_BYTE *)(v23 + a1 + 13) = 2;
    }
LABEL_25:
    if ( !*v5 && v18 & 0x2000 )
    {
      v24 = 0;
      while ( *(_BYTE *)(a1 + v24 + 13) != 15 )
      {
        if ( ++v24 >= 4 )
          goto LABEL_47;
      }
      *(_BYTE *)(v24 + a1 + 13) = 1;
    }
  }
LABEL_47:
  *(_BYTE *)(a1 + 11) = 0;
  v43 = 9.9999996e24;
  *(_BYTE *)(a1 + 12) = 0;
  v44 = 9.9999996e24;
  do
  {
    v34 = a2;
    (*(void (__cdecl **)(_DWORD, signed int, char *))dword_101E37B8)(a2, 3, (char *)&v42 + 2);
    a2 = (unsigned __int16)word_101E400C + v34;
    if ( BYTE2(v42) & 1 )
    {
      ++*(_BYTE *)(a1 + 11);
      v35 = 1;
    }
    else
    {
      v35 = 0;
    }
    do
    {
      v36 = sub_10016C60((int)&a2, (int)&v42, &v57);
      v37 = v42;
      if ( (_BYTE)v42 == 1 || v35 )
        ++*(_BYTE *)(a1 + 12);
      if ( v37 == 2 )
      {
        v43 = v58;
      }
      else if ( v37 == 3 )
      {
        v44 = v58;
      }
      v35 = 0;
    }
    while ( v36 );
  }
  while ( BYTE2(v42) & 1 );
  v38 = v43;
  v39 = 3;
  do
  {
    v40 = *(_BYTE *)(a1 + v39 + 13);
    LOBYTE(v42) = 1;
    if ( v40 == 3 && (v38 < -304.8 || v38 > 7620.0) )
      LOBYTE(v42) = 0;
    if ( (v40 == 2 || v40 == 1 || v40 == 4)
      && ((v41 = sub_10017430(a3, a1), v45 = sub_1001AC80(v41), v46 = sub_1001AD00(v41), v38 = v43, v43 > 7620.0)
       || v44 > v38
       || v45 > (double)v44
       || v45 < -304.8
       || *(float *)(a1 + 48) <= 0.0
       || *(float *)(a1 + 48) >= 0.1745329251994333
       || v46 < -150.0
       || v46 > 150.0)
      || !(_BYTE)v42 )
    {
      if ( v39 < 3 )
      {
        memcpy((void *)(a1 + v39 + 13), (const void *)(v39 + a1 + 14), 3 - v39);
        memcpy((void *)(a1 + v39 + 17), (const void *)(v39 + a1 + 18), 3 - v39);
        v38 = v43;
      }
      *(_BYTE *)(a1 + 16) = 15;
      *(_BYTE *)(a1 + 20) = 63;
    }
    --v39;
  }
  while ( v39 >= 0 );
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E4008: using guessed type __int16 word_101E4008;
// 101E400A: using guessed type __int16 word_101E400A;
// 101E400C: using guessed type __int16 word_101E400C;
// 101E4110: using guessed type int dword_101E4110;

//----- (10017B80) --------------------------------------------------------
int __cdecl sub_10017B80(__int16 a1, unsigned __int16 a2)
{
  _DWORD *v2; // ecx@0
  int result; // eax@1

  result = 0;
  if ( a1 )
  {
    *v2 += a2;
    result = (unsigned __int16)word_101E3FE2;
  }
  return result;
}
// 101E3FE2: using guessed type __int16 word_101E3FE2;

//----- (10017BA0) --------------------------------------------------------
signed int __cdecl sub_10017BA0(int a1)
{
  signed int result; // eax@1
  int v2; // edi@2
  int v3; // ST4C_4@2
  unsigned int v4; // ebx@2
  int v5; // eax@2
  int v6; // eax@2
  int v7; // edx@2
  int v8; // eax@2
  int v9; // edx@2
  int v10; // eax@2
  int v11; // edx@2
  int v12; // eax@2
  int v13; // edx@2
  int v14; // eax@2
  int v15; // edx@2
  int v16; // eax@2
  int v17; // edx@2
  int v18; // eax@2
  int v19; // edx@2
  int v20; // [sp+8h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_WORD *)(a1 + 4) & 0x400 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_10019B00(a1);
    (*(void (__cdecl **)(int, signed int, int *))dword_101E37B8)(v2, 160, &v20);
    v4 = *(_WORD *)(a1 + 4);
    v5 = sub_10017B80(*(_WORD *)(a1 + 4) & 1, v20);
    v6 = sub_10017B80(((unsigned __int8)v4 >> 1) & 1, *(_WORD *)((char *)&v20 + v5));
    v8 = sub_10017B80(((unsigned __int8)v4 >> 2) & 1, *(_WORD *)(v6 + v7));
    v10 = sub_10017B80(((unsigned __int8)v4 >> 3) & 1, *(_WORD *)(v8 + v9));
    v12 = sub_10017B80(((unsigned __int8)v4 >> 4) & 1, *(_WORD *)(v10 + v11));
    v14 = sub_10017B80(((unsigned __int8)v4 >> 6) & 1, *(_WORD *)(v12 + v13));
    v16 = sub_10017B80(((unsigned __int8)v4 >> 7) & 1, *(_WORD *)(v14 + v15));
    v18 = sub_10017B80(BYTE1(v4) & 1, *(_WORD *)(v16 + v17));
    sub_10017B80((v4 >> 9) & 1, *(_WORD *)(v19 + v18));
    result = v3;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (10017D00) --------------------------------------------------------
signed int __cdecl sub_10017D00(int a1)
{
  signed int result; // eax@1
  int v2; // edi@2
  int v3; // ST40_4@2
  int v4; // eax@2
  unsigned __int8 v5; // dl@2
  unsigned __int8 v6; // dl@2
  unsigned __int16 *v7; // esi@2
  unsigned __int8 v8; // dl@2
  unsigned __int16 *v9; // esi@2
  int v10; // eax@2
  unsigned __int8 v11; // dl@2
  int v12; // [sp+8h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 0x40 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_10019B00(a1);
    (*(void (__cdecl **)(int, signed int, int *))dword_101E37B8)(v2, 160, &v12);
    v4 = sub_10017B80(*(_WORD *)(a1 + 4) & 1, v12);
    v7 = (unsigned __int16 *)((char *)&v12 + v4 + sub_10017B80((v5 >> 1) & 1, *(_WORD *)((char *)&v12 + v4)));
    v9 = (unsigned __int16 *)((char *)v7 + sub_10017B80((v6 >> 2) & 1, *v7));
    v10 = sub_10017B80((v8 >> 3) & 1, *v9);
    sub_10017B80((v11 >> 4) & 1, *(unsigned __int16 *)((char *)v9 + v10));
    result = v3;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (10017DF0) --------------------------------------------------------
char __cdecl sub_10017DF0(_DWORD *a1)
{
  _DWORD *v1; // esi@1
  char result; // al@2
  char v3; // [sp+4h] [bp-4h]@2

  v1 = a1;
  do
  {
    (*(void (__cdecl **)(_DWORD, signed int, char *))dword_101E37B8)(*v1, 3, &v3);
    *v1 += (unsigned __int16)word_101E400C;
    result = sub_100173C0((int)v1, &a1);
  }
  while ( v3 & 1 );
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E400C: using guessed type __int16 word_101E400C;

//----- (10017E40) --------------------------------------------------------
char __usercall sub_10017E40@<al>(signed int *a1@<edi>, signed int a2, signed int a3, unsigned __int8 a4, _BYTE *a5)
{
  unsigned __int8 v5; // al@1
  _BYTE *v6; // ebp@1
  signed int v7; // esi@1
  char v8; // bl@1
  signed int v9; // ecx@2
  char result; // al@6
  bool v11; // zf@21
  signed int v12; // ecx@31
  unsigned __int8 v13; // [sp+Fh] [bp-3Dh]@1
  char v14; // [sp+10h] [bp-3Ch]@1
  char v15; // [sp+11h] [bp-3Bh]@1
  char v16; // [sp+14h] [bp-38h]@1
  char v17; // [sp+15h] [bp-37h]@1
  bool v18; // [sp+1Bh] [bp-31h]@4
  char v19; // [sp+1Dh] [bp-2Fh]@1
  unsigned __int8 v20; // [sp+20h] [bp-2Ch]@8
  int v21; // [sp+21h] [bp-2Bh]@30
  unsigned __int8 v22; // [sp+2Eh] [bp-1Eh]@12
  int v23; // [sp+2Fh] [bp-1Dh]@30
  char v24; // [sp+3Ch] [bp-10h]@30
  char v25; // [sp+42h] [bp-Ah]@30

  v5 = 0;
  v6 = a5;
  v7 = a3;
  v13 = 0;
  v14 = 1;
  v15 = 1;
  *a5 = 0;
  v8 = 0;
  v19 = 0;
  v16 = -1;
  v17 = -1;
  do
  {
    v9 = a2;
    if ( a2 == 0xFFFFFF && v7 == a2 )
      break;
    *a1 = 0xFFFFFF;
    v18 = 1;
    if ( !v14 )
    {
      if ( !v15 )
      {
        *a1 = 0xFFFFFF;
        return -1;
      }
LABEL_10:
      if ( !v19 )
      {
        v17 = -1;
        do
        {
          (*(void (__cdecl **)(signed int, signed int, unsigned __int8 *))dword_101E37B8)(v7, 14, &v22);
          v18 = sub_10016950((int)&v22);
          if ( v18 )
          {
            v17 = (v22 >> 1) & 0x1F;
          }
          else if ( v22 & 1 )
          {
            sub_10016C10(&a3);
            sub_10017DF0(&a3);
            v7 = a3;
          }
          else
          {
            v7 = 0xFFFFFF;
            a3 = 0xFFFFFF;
            v15 = 0;
          }
        }
        while ( v22 & 1 && v17 == -1 );
      }
      goto LABEL_19;
    }
    if ( !v8 )
    {
      (*(void (__cdecl **)(signed int, signed int, unsigned __int8 *))dword_101E37B8)(v9, 14, &v20);
      v16 = (v20 >> 1) & 0x1F;
    }
    if ( v15 )
      goto LABEL_10;
LABEL_19:
    if ( v14 )
    {
      if ( !v15 )
        goto LABEL_31;
    }
    else if ( v15 )
    {
      goto LABEL_21;
    }
    if ( (unsigned __int8)(v16 - 7) > 2u || v17 != 10 )
    {
      if ( (unsigned __int8)(v17 - 7) <= 2u && v16 == 10
        || v16 < v17
        || v16 <= v17 && (sub_10016B80(v21, (int)&v24), sub_10016B80(v23, (int)&v25), strcmp(&v24, &v25) <= 0) )
      {
LABEL_31:
        v12 = a2;
        ++v13;
        v8 = 0;
        *v6 = 0;
        *a1 = v12;
        if ( v18 )
          v19 = 1;
        if ( v20 & 1 )
        {
          sub_10016C10(&a2);
          sub_10017DF0(&a2);
        }
        else
        {
          v14 = 0;
        }
        goto LABEL_37;
      }
    }
LABEL_21:
    ++v13;
    v8 = 1;
    v11 = (v22 & 1) == 0;
    *v6 = 1;
    *a1 = v7;
    v19 = 0;
    if ( v11 )
    {
      v15 = 0;
    }
    else
    {
      sub_10016C10(&a3);
      sub_10017DF0(&a3);
      v7 = a3;
    }
LABEL_37:
    v5 = v13;
  }
  while ( v13 <= a4 );
  if ( *a1 == 0xFFFFFF )
    result = -1;
  else
    result = v5 - 1;
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (100180E0) --------------------------------------------------------
signed int __cdecl sub_100180E0(int a1, unsigned __int8 a2, _BYTE *a3)
{
  int v3; // esi@1
  signed int v4; // eax@1
  signed int v5; // edi@1
  char v7; // al@6
  char v8; // al@9
  int v9; // ebp@9
  bool v10; // bl@13
  int v11; // esi@17
  unsigned __int8 v12; // [sp+13h] [bp-25h]@1
  int v13; // [sp+14h] [bp-24h]@4
  int v14; // [sp+18h] [bp-20h]@4
  char v15; // [sp+1Ch] [bp-1Ch]@13

  v12 = -1;
  *a3 = 0;
  v3 = sub_10017D00(a1);
  v4 = sub_10017BA0(a1);
  v5 = v4;
  if ( v3 == 0xFFFFFF )
  {
    if ( v4 == 0xFFFFFF )
      return 0xFFFFFF;
  }
  else
  {
    v14 = v3;
    v13 = v3;
    if ( v4 == 0xFFFFFF )
      goto LABEL_6;
  }
  *a3 = 1;
  v14 = v4;
  v13 = v4;
LABEL_6:
  sub_10016B40(&v13, a2, &v12);
  v7 = a2;
  if ( v12 == a2 )
  {
    v9 = v13;
    goto LABEL_26;
  }
  if ( *(_WORD *)(a1 + 4) & 0x40 && *(_WORD *)(a1 + 4) & 0x400 )
  {
    v8 = sub_10017E40(&v13, v3, v5, a2, a3);
    v9 = v13;
  }
  else
  {
    if ( v12 == -1 )
      v12 = 0;
    v9 = v13;
    while ( 1 )
    {
      v10 = 1;
      (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v9, 14, &v15);
      if ( !*a3 || (v10 = sub_10016950((int)&v15)) != 0 )
        ++v12;
      if ( !(v15 & 1) )
        break;
      v11 = v12 - 1;
      if ( v11 < a2 )
      {
        sub_10016C10(&v13);
        sub_10017DF0(&v13);
        v9 = v13;
        if ( v11 < a2 && v13 != 0xFFFFFF )
          continue;
      }
      goto LABEL_23;
    }
    if ( !v10 )
      v12 = -1;
LABEL_23:
    v8 = --v12;
  }
  if ( v8 == a2 )
  {
    v7 = a2;
LABEL_26:
    sub_100173F0(v14, v7, v9);
    return v9;
  }
  sub_10004C50("..\\lib\\acl\\adb\\adb_appr_utl.c", 809, 0, 0);
  return 0xFFFFFF;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (10018280) --------------------------------------------------------
void __cdecl sub_10018280(unsigned int a1, unsigned __int8 a2, int a3)
{
  _BYTE *v3; // eax@1
  float *v4; // ecx@1
  signed int v5; // edx@1
  int v6; // eax@3
  char v7; // [sp+Bh] [bp-9h]@1
  char v8; // [sp+Ch] [bp-8h]@3

  *(_DWORD *)a3 = 1600085855;
  *(_BYTE *)(a3 + 4) = 95;
  *(float *)(a3 + 48) = 6.2831855;
  v7 = 0;
  *(_BYTE *)(a3 + 5) = 0;
  *(_BYTE *)(a3 + 6) = -1;
  *(_BYTE *)(a3 + 7) = 0;
  *(_BYTE *)(a3 + 9) = 0;
  *(_BYTE *)(a3 + 11) = -1;
  *(_BYTE *)(a3 + 12) = 0;
  *(_BYTE *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 10) = 1;
  *(_DWORD *)(a3 + 24) = 0x3FFFF;
  *(_BYTE *)(a3 + 21) = -1;
  v3 = (_BYTE *)(a3 + 17);
  v4 = (float *)(a3 + 32);
  v5 = 4;
  do
  {
    *(v3 - 4) = 15;
    *v3 = 63;
    *v4 = 0.0;
    ++v4;
    ++v3;
    --v5;
  }
  while ( v5 );
  sub_1001A380(a1, &v8);
  v6 = sub_100180E0((int)&v8, a2, &v7);
  if ( v6 != 0xFFFFFF )
    sub_100175C0(a3, v6, a1, &v7);
}

//----- (10018330) --------------------------------------------------------
char __cdecl sub_10018330(unsigned __int8 a1, unsigned __int8 a2)
{
  char v2; // bl@1
  int v3; // eax@1

  v2 = 0;
  sub_10004EC0(54, 60000);
  v3 = sub_1001C4F0(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = *(_BYTE *)(84 * a2 + v3 + 154);
  sub_10004EA0(54);
  return v2;
}

//----- (10018380) --------------------------------------------------------
char __cdecl sub_10018380(unsigned __int8 a1, unsigned __int8 a2)
{
  char v2; // bl@1
  int v3; // eax@1

  v2 = 0;
  sub_10004EC0(54, 60000);
  v3 = sub_1001C4F0(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = *(_BYTE *)(84 * a2 + v3 + 125);
  sub_10004EA0(54);
  return v2;
}

//----- (100183D0) --------------------------------------------------------
int __cdecl sub_100183D0(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(float *)a2 = 6.2831855;
  *(float *)(a2 + 4) = 6.2831855;
  switch ( *(_BYTE *)a1 )
  {
    case 1:
    case 4:
    case 0x12:
    case 0x14:
    case 0x15:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 48);
      break;
    case 2:
    case 5:
    case 0x13:
    case 0x16:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 56);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10018440) --------------------------------------------------------
signed int __cdecl sub_10018440(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1
  char v3; // cl@2

  v1 = 0x3FFFF;
  sub_10004EC0(54, 60000);
  v2 = sub_1001C4F0(a1);
  if ( v2 )
  {
    v3 = *(_BYTE *)(v2 + 1);
    if ( v3 )
    {
      if ( *(_BYTE *)(v2 + 90) == -1 || (v1 = *(_DWORD *)(v2 + 104), v1 == 0x3FFFF) )
      {
        if ( *(_BYTE *)(v2 + 60) == 3 || *(_BYTE *)(v2 + 61) == 3 || (v1 = *(_DWORD *)(v2 + 64), v1 == 0x3FFFF) )
          v1 = sub_1001FFE0(84 * (unsigned __int8)(v3 - 1) + v2 + 148);
      }
    }
  }
  sub_10004EA0(54);
  return v1;
}

//----- (100184C0) --------------------------------------------------------
int __cdecl sub_100184C0(int a1, char a2, void *a3)
{
  int v3; // eax@1
  int result; // eax@3

  sub_10004EC0(54, 60000);
  v3 = sub_1001C4F0(a1);
  if ( v3 && (unsigned __int8)a2 < *(_BYTE *)(v3 + 1) )
  {
    qmemcpy(a3, (const void *)(84 * (unsigned __int8)a2 + v3 + 148), 0x3Cu);
    result = sub_10004EA0(54);
  }
  else
  {
    memset(a3, 0, 0x3Cu);
    *(_BYTE *)a3 = 24;
    *((_BYTE *)a3 + 1) = 0;
    *((_BYTE *)a3 + 4) = 0;
    *((_BYTE *)a3 + 6) = 0;
    *((_BYTE *)a3 + 7) = 4;
    result = sub_10004EA0(54);
  }
  return result;
}

//----- (10018540) --------------------------------------------------------
signed int __cdecl sub_10018540(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  v1 = 0x3FFFF;
  sub_10004EC0(54, 60000);
  v2 = sub_1001C4F0(a1);
  if ( v2 )
  {
    if ( *(_BYTE *)(v2 + 1) > 1u )
    {
      if ( *(_BYTE *)(v2 + 20) == 3 || *(_BYTE *)(v2 + 21) == 3 || (v1 = *(_DWORD *)(v2 + 24), v1 == 0x3FFFF) )
        v1 = sub_1001FFE0(v2 + 148);
    }
  }
  sub_10004EA0(54);
  return v1;
}

//----- (100185A0) --------------------------------------------------------
char __cdecl sub_100185A0(int a1)
{
  unsigned __int8 v1; // bl@1
  char result; // al@1
  char v3; // cl@1
  char v4; // dl@2

  v1 = *(_BYTE *)(a1 + 1);
  result = -1;
  v3 = 0;
  if ( v1 )
  {
    while ( 1 )
    {
      v4 = *(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 154);
      if ( v4 == 2 || v4 == 8 )
        break;
      if ( (unsigned __int8)++v3 >= v1 )
        return result;
    }
    result = v3;
  }
  return result;
}

//----- (100185E0) --------------------------------------------------------
char __cdecl sub_100185E0(int a1)
{
  unsigned __int8 v1; // dl@1
  char result; // al@1
  char v3; // cl@1

  v1 = *(_BYTE *)(a1 + 1);
  result = -1;
  v3 = 0;
  if ( v1 )
  {
    while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 2) )
    {
      if ( (unsigned __int8)++v3 >= v1 )
        return result;
    }
    result = v3;
  }
  return result;
}

//----- (10018610) --------------------------------------------------------
int __cdecl sub_10018610(int a1, int a2, _BYTE *a3, _BYTE *a4, int a5, int a6, float *a7)
{
  char v7; // cl@2
  int v8; // edx@3
  int v9; // edx@3
  char v11; // [sp+13h] [bp-21h]@3
  int v12; // [sp+14h] [bp-20h]@3
  int v13; // [sp+18h] [bp-1Ch]@1
  int v14; // [sp+1Ch] [bp-18h]@3
  float *v15; // [sp+20h] [bp-14h]@1
  char v16; // [sp+24h] [bp-10h]@3
  int v17; // [sp+28h] [bp-Ch]@3
  int v18; // [sp+2Ch] [bp-8h]@3

  v13 = a5;
  v15 = a7;
  if ( a1 && (v7 = *(_BYTE *)(a1 + 90), v7 != -1) )
  {
    *a3 = v7;
    v14 = *(_DWORD *)(a1 + 96);
    sub_10022C90(v14, (_BYTE *)&v14 + 3, 5, a2);
    v12 = *(_DWORD *)(a1 + 100);
    sub_10022C90((int)&v12 + 3, (_BYTE *)&v12 + 3, 5, a6);
    v8 = *(_DWORD *)(a1 + 120);
    v17 = *(_DWORD *)(a1 + 116);
    v18 = v8;
    sub_1001B3E0((int)&v17, v13, (int)&v16, &v11);
    *a4 = *(_BYTE *)(a1 + 89);
    v9 = 84 * (unsigned __int8)sub_10019460(a1);
    *v15 = *(float *)(v9 + a1 + 172);
  }
  else
  {
    *(_DWORD *)a2 = 538976288;
    *(_BYTE *)(a2 + 4) = 32;
    *a3 = -1;
  }
  *(_BYTE *)(a6 + 5) = 0;
  sub_1001E3A0(a6, 5);
  *(_BYTE *)(a2 + 5) = 0;
  return sub_1001E3A0(a2, 5);
}

//----- (10018710) --------------------------------------------------------
int __usercall sub_10018710@<eax>(float *a1@<esi>, float a2, float a3, float a4, float a5, int a6)
{
  double v6; // st7@1
  double v7; // st7@6
  int result; // eax@6
  float v9; // [sp+Ch] [bp+8h]@1

  v6 = a2;
  v9 = a3 - a2;
  if ( LOBYTE(a5) == 1 )
  {
    *a1 = v6 - 1.570796370506287;
    if ( v9 > 0.0 )
      v9 = v9 - 6.283185482025146;
  }
  else
  {
    *a1 = v6 + 1.570796370506287;
    if ( v9 < 0.0 )
      v9 = v9 + 6.283185482025146;
  }
  v7 = sub_10047770(*a1);
  result = a6;
  *a1 = v7;
  *(float *)a6 = COERCE_FLOAT(LODWORD(v9) & 0x7FFFFFFF) * a4;
  return result;
}

//----- (100187B0) --------------------------------------------------------
double __usercall sub_100187B0@<st0>(int a1@<eax>, int a2@<ecx>, int a3@<esi>, unsigned int a4)
{
  unsigned int v4; // esi@1
  double v5; // st7@5
  float v6; // ST0C_4@12
  double result; // st7@13
  __int64 v8; // [sp-8h] [bp-10h]@1
  float v9; // [sp+0h] [bp-8h]@1
  float v10; // [sp+0h] [bp-8h]@7
  float v11; // [sp+0h] [bp-8h]@10
  float v12; // [sp+4h] [bp-4h]@1
  float v13; // [sp+4h] [bp-4h]@12

  v12 = *(float *)(a2 + 12);
  HIDWORD(v8) = a3;
  v4 = 0x3FFFF;
  v9 = -1.0;
  if ( !a1 )
    goto LABEL_17;
  if ( *(_BYTE *)(a1 + 7) != 4 )
    v9 = *(float *)(a1 + 12);
  v4 = *(_DWORD *)(a1 + 36);
  if ( v9 > 0.0 )
  {
    v5 = v12 - v9;
  }
  else
  {
LABEL_17:
    LODWORD(v8) = v4;
    if ( sub_1001B250(v8) != 5 || (v10 = sub_1001AC80(v4), 9.9999996e24 == v10) )
      v10 = sub_1001BF20(a4);
    v5 = v12 - v10;
  }
  v11 = v5;
  if ( v11 <= 30.47999954223633 )
    v11 = 30.48;
  v6 = v11 * 3.280839920043945 / 500.0 * 1852.0;
  v13 = v6 + 1.0;
  if ( v13 >= 9260.0 )
    result = (float)9260.0;
  else
    result = v13;
  return result;
}
// 100187B0: could not find valid save-restore pair for esi

//----- (100188B0) --------------------------------------------------------
char __cdecl sub_100188B0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10004EC0(54, 60000);
  v1 = -1;
  v2 = sub_1001C4F0(a1);
  if ( v2 )
    v1 = sub_100185A0(v2);
  sub_10004EA0(54);
  return v1;
}

//----- (100188F0) --------------------------------------------------------
char __cdecl sub_100188F0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10004EC0(54, 60000);
  v1 = -1;
  v2 = sub_1001C4F0(a1);
  if ( v2 )
    v1 = sub_100185E0(v2);
  sub_10004EA0(54);
  return v1;
}

//----- (10018930) --------------------------------------------------------
char __usercall sub_10018930@<al>(int a1@<edi>, char a2, int a3, char a4, float a5, int a6)
{
  int v6; // eax@1
  int v7; // esi@1
  unsigned int v8; // eax@5
  float v9; // esi@6
  char result; // al@11
  signed int v11; // eax@13
  __int64 v12; // [sp-14h] [bp-A4h]@1
  __int64 v13; // [sp-14h] [bp-A4h]@9
  char v14; // [sp+3h] [bp-8Dh]@1
  char v15; // [sp+4h] [bp-8Ch]@18
  char v16; // [sp+Ch] [bp-84h]@18
  char v17; // [sp+1Ch] [bp-74h]@12
  char v18; // [sp+58h] [bp-38h]@6
  char v19; // [sp+60h] [bp-30h]@8
  float v20; // [sp+70h] [bp-20h]@6

  *(float *)a6 = a5;
  HIDWORD(v12) = a1;
  v14 = 1;
  sub_10004EC0(54, 60000);
  v6 = sub_1001C4F0(a3);
  v7 = v6;
  if ( !v6 || (unsigned __int8)a4 >= *(_BYTE *)(v6 + 1) || a2 )
  {
    sub_10004EA0(54);
    result = 1;
  }
  else
  {
    sub_10004EA0(54);
    if ( !(sub_10018380(a3, a4) & 1)
      || (v8 = *(_DWORD *)(v7 + 104), v8 == 0x3FFFF)
      || (sub_10018280(v8, *(_BYTE *)(v7 + 88), (int)&v18),
          v9 = v20,
          (unsigned __int8)a4 <= (unsigned __int8)sub_100194A0(a3))
      && (unsigned __int8)a4 < (unsigned __int8)sub_100188B0(a3)
      || v19
      || (*(float *)&v12 = v9, sub_1001B250(v12) != 3) && (*(float *)&v13 = v9, sub_1001B250(v13) != 8) )
    {
      sub_100184C0(a3, a4, &v17);
      switch ( v17 )
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0xF:
        case 0x10:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x15:
        case 0x16:
          v11 = sub_1001FFE0((int)&v17);
          goto LABEL_16;
        default:
          if ( a4 )
          {
            sub_100184C0(a3, a4 - 1, &v17);
            v11 = sub_1001FFE0((int)&v17);
LABEL_16:
            if ( v11 != 0x3FFFF && v11 != 262142 )
            {
              sub_10016600(0, v11, (double *)&v16);
              sub_100477B0((int)&v16, (int)&v15);
              v14 = 2;
              sub_1001C890((int)&v15, (float *)a6);
            }
          }
          result = v14;
          break;
      }
    }
    else
    {
      *(float *)a6 = sub_1001B280(v9);
      result = 0;
    }
  }
  return result;
}
// 10018930: could not find valid save-restore pair for edi

//----- (10018B10) --------------------------------------------------------
char __cdecl sub_10018B10(int a1, char a2, char *a3)
{
  char result; // al@2
  int v4; // ebx@6
  unsigned int v5; // esi@8
  float v6; // edi@10
  unsigned int v7; // esi@10
  double v8; // ST28_8@10
  int v9; // eax@10
  int v10; // edi@13
  float v11; // [sp+1Ch] [bp-44h]@6
  float v12; // [sp+1Ch] [bp-44h]@13
  char v13; // [sp+24h] [bp-3Ch]@1
  float v14; // [sp+30h] [bp-30h]@5
  int v15; // [sp+48h] [bp-18h]@1
  float v16; // [sp+50h] [bp-10h]@6
  float v17; // [sp+54h] [bp-Ch]@6

  sub_100184C0(a1, a2, &v13);
  if ( v15 == 262142 )
  {
    result = sub_1001E210((int)a3, "Locked", 12);
  }
  else
  {
    switch ( v13 )
    {
      case 0:
        result = sub_1001E210((int)a3, "DME ARC", 12);
        break;
      case 1:
      case 7:
      case 0x12:
        sub_1001E330(a3, 0xCu, "%d", (signed int)(v14 * 3.280839895013123 + 0.5));
        result = sub_1001E360(a3, "", 12);
        break;
      case 2:
      case 9:
      case 0x13:
        v11 = v17 * 0.0005399568034557236;
        sub_100164B0(LODWORD(v16), (int)a3);
        v4 = 3;
        if ( v11 >= 9.9499998 )
          v4 = 4;
        v5 = strlen(a3);
        result = sub_1001DF90(v11, v4, 1, (int)&a3[v5]);
        *(&a3[v4] + v5) = 0;
        break;
      case 4:
      case 0x14:
        result = sub_1001E210((int)a3, "INTRCPT ", 12);
        break;
      case 5:
      case 0x16:
        v6 = v16;
        sub_100164B0(LODWORD(v16), (int)a3);
        v7 = strlen(a3);
        v8 = v17;
        *(float *)&v8 = v8 - sub_1001B280(v6);
        *(float *)&v8 = sub_10047770(*(float *)&v8);
        v9 = sub_10047840(*(float *)&v8);
        if ( !v9 )
          v9 = 360;
        result = sub_1001E330(&a3[v7], 12 - v7, "%03i", v9);
        break;
      case 8:
        v10 = 3;
        v12 = v16 * 0.0005399568034557236;
        if ( v12 >= 9.9499998 )
          v10 = 4;
        *a3 = 68;
        result = sub_1001DF90(v12, v10, 1, (int)(a3 + 1));
        a3[v10 + 1] = 0;
        break;
      case 0xA:
      case 0x15:
        result = sub_1001E210((int)a3, "MANSEQ", 12);
        break;
      case 0xF:
        result = sub_1001E210((int)a3, "PROC. TURN", 12);
        break;
      case 0xB:
      case 0xC:
      case 0xD:
        result = sub_1001E210((int)a3, "HOLD", 12);
        break;
      case 0x10:
        result = sub_1001E210((int)a3, &unk_1007058C, 12);
        break;
      default:
        result = (char)a3;
        *a3 = 0;
        break;
    }
  }
  return result;
}

//----- (10018DF0) --------------------------------------------------------
int __cdecl sub_10018DF0(unsigned __int8 a1, int a2, _BYTE *a3, _BYTE *a4, int a5, int a6, float *a7)
{
  int v7; // eax@1

  sub_10004EC0(54, 60000);
  v7 = sub_1001C4F0(a1);
  sub_10018610(v7, a2, a3, a4, a5, a6, a7);
  return sub_10004EA0(54);
}

//----- (10018E40) --------------------------------------------------------
void __cdecl sub_10018E40(int a1, unsigned __int8 a2, float *a3, float *a4)
{
  signed int v4; // eax@7
  char v5; // al@13
  char v6; // al@13
  double v7; // st6@15
  double v8; // st7@15
  bool v9; // zf@17
  double v10; // st7@17
  double v11; // st7@18
  signed int v12; // eax@23
  signed int v13; // eax@26
  char v14; // di@26
  float v15; // [sp+24h] [bp-DCh]@9
  char v16; // [sp+2Ah] [bp-D6h]@20
  char v17; // [sp+2Bh] [bp-D5h]@20
  int v18; // [sp+2Ch] [bp-D4h]@13
  char v19; // [sp+3Ch] [bp-C4h]@1
  char v20; // [sp+3Dh] [bp-C3h]@3
  char v21; // [sp+42h] [bp-BEh]@20
  float v22; // [sp+64h] [bp-9Ch]@13
  float v23; // [sp+68h] [bp-98h]@3
  float v24; // [sp+6Ch] [bp-94h]@3
  float v25; // [sp+70h] [bp-90h]@3
  int v26; // [sp+78h] [bp-88h]@13
  int v27; // [sp+88h] [bp-78h]@27
  char v28; // [sp+98h] [bp-68h]@11
  float v29; // [sp+C0h] [bp-40h]@28
  float v30; // [sp+C4h] [bp-3Ch]@28
  float v31; // [sp+C8h] [bp-38h]@30
  int v32; // [sp+D4h] [bp-2Ch]@30
  char v33; // [sp+E4h] [bp-1Ch]@20
  char v34; // [sp+ECh] [bp-14h]@20
  char v35; // [sp+F4h] [bp-Ch]@20

  *a3 = 9.9999996e24;
  *a4 = 9.9999996e24;
  sub_100184C0(a1, a2, &v19);
  if ( v19 != 24 )
  {
    switch ( v19 )
    {
      case 0:
      case 0x10:
        sub_10018710(a4, v24, v25, v23, COERCE_FLOAT(v20 & 7), (int)a3);
        return;
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
        goto LABEL_4;
      case 7:
        if ( a2 < (unsigned __int8)sub_100188F0(a1) || a2 >= (unsigned __int8)sub_100194E0(a1) )
          v4 = sub_10018440(a1);
        else
          v4 = sub_10018540(a1);
        v15 = *(float *)&v4;
        if ( v4 == 0x3FFFF || !a2 )
          return;
        sub_100184C0(a1, a2 - 1, &v28);
        *a3 = sub_100187B0((int)&v28, (int)&v19, (int)a4, LODWORD(v15));
        goto LABEL_35;
      case 8:
        goto LABEL_12;
      case 9:
        v5 = sub_1001FFE0((int)&v19);
        sub_10016600(0, v5, (double *)&v18);
        v6 = sub_10016790((int)&v19);
        sub_10016600(0, v6, (double *)&v26);
        if ( sub_1000ACE0((int)&v26, v24, (int)&v18, v22, (int)&v26) )
          sub_10009D80((int)&v18, (int)&v26, 1, a3, (int)a4);
        else
LABEL_4:
          *a3 = 0.0;
        goto LABEL_35;
      case 0xF:
        v15 = v23 - 3704.0;
        v7 = v15;
        *a3 = v15;
        v15 = v7;
        v8 = v15;
        if ( v15 <= 3704.0 )
          v8 = 3704.0;
        v15 = v8;
        v9 = (v20 & 7) == 1;
        *a3 = v15;
        v10 = v22;
        *a4 = v22;
        if ( v9 )
          v11 = v10 - 0.7853981852531433;
        else
          v11 = v10 + 0.7853981852531433;
        goto LABEL_36;
      case 3:
        sub_10018DF0(a1, (int)&v34, &v17, &v16, (int)&v35, (int)&v33, &v15);
        if ( v21 == 2 && a2 != sub_100194A0(a1) && v16 == -1 )
          goto LABEL_23;
LABEL_12:
        *a3 = v23;
        goto LABEL_35;
      default:
LABEL_23:
        v12 = sub_1001FFE0((int)&v19);
        if ( v12 == 0x3FFFF )
          return;
        if ( !a2 || v12 == 262142 )
          goto LABEL_32;
        sub_10016600(0, v12, (double *)&v26);
        sub_100184C0(a1, a2 - 1, &v28);
        v13 = sub_1001FFE0((int)&v28);
        v14 = v13;
        if ( v13 == 0x3FFFF )
          return;
        sub_10016600(0, v13, (double *)&v27);
        if ( v28 == 8 )
        {
          sub_10009EB0((int)&v27, v30, v29, 1, (int)&v18);
        }
        else if ( v28 == 9 )
        {
          sub_10016600(0, SLOBYTE(v30), (double *)&v32);
          if ( !sub_1000ACE0((int)&v32, v31, (int)&v27, v29, (int)&v18) )
            goto LABEL_32;
        }
        else
        {
          sub_10016600(0, v14, (double *)&v18);
        }
        sub_10009D80((int)&v18, (int)&v26, 1, a3, (int)a4);
LABEL_32:
        if ( v19 != 14 && v19 != 17 && v19 != 6 )
        {
LABEL_35:
          v11 = v22;
LABEL_36:
          *a4 = v11;
        }
        break;
    }
  }
}

//----- (10019240) --------------------------------------------------------
signed int __cdecl sub_10019240(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  v1 = 0x3FFFF;
  sub_10004EC0(54, 60000);
  v2 = sub_1001C4F0(a1);
  if ( v2 && *(_BYTE *)(v2 + 90) != -1 )
    v1 = *(_DWORD *)(v2 + 104);
  sub_10004EA0(54);
  return v1;
}

//----- (10019280) --------------------------------------------------------
char __cdecl sub_10019280(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10004EC0(54, 60000);
  v1 = 0;
  v2 = sub_1001C4F0(a1);
  if ( v2 )
    v1 = *(_BYTE *)(v2 + 1);
  sub_10004EA0(54);
  return v1;
}

//----- (100192C0) --------------------------------------------------------
signed int __cdecl sub_100192C0(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  sub_10004EC0(54, 60000);
  v2 = 0x3FFFF;
  v3 = sub_1001C4F0(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_1001FFE0(84 * a2 + v3 + 148);
  sub_10004EA0(54);
  return v2;
}

//----- (10019320) --------------------------------------------------------
signed int __cdecl sub_10019320(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  sub_10004EC0(54, 60000);
  v1 = 0x3FFFF;
  v2 = sub_1001C4F0(a1);
  if ( v2 && *(_BYTE *)(v2 + 60) != 3 && *(_BYTE *)(v2 + 61) != 3 )
    v1 = *(_DWORD *)(v2 + 64);
  sub_10004EA0(54);
  return v1;
}

//----- (10019360) --------------------------------------------------------
char __cdecl sub_10019360(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 1) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (100193A0) --------------------------------------------------------
char __cdecl sub_100193A0(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 4) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (100193E0) --------------------------------------------------------
char __cdecl sub_100193E0(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 1) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (10019420) --------------------------------------------------------
char __cdecl sub_10019420(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 4) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (10019460) --------------------------------------------------------
char __cdecl sub_10019460(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( *(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 154) != 3 )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (100194A0) --------------------------------------------------------
char __cdecl sub_100194A0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10004EC0(54, 60000);
  v1 = -1;
  v2 = sub_1001C4F0(a1);
  if ( v2 )
    v1 = sub_10019360(v2);
  sub_10004EA0(54);
  return v1;
}

//----- (100194E0) --------------------------------------------------------
char __cdecl sub_100194E0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10004EC0(54, 60000);
  v1 = -1;
  v2 = sub_1001C4F0(a1);
  if ( v2 )
    v1 = sub_100193A0(v2);
  sub_10004EA0(54);
  return v1;
}

//----- (10019520) --------------------------------------------------------
char __cdecl sub_10019520(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10004EC0(54, 60000);
  v1 = -1;
  v2 = sub_1001C4F0(a1);
  if ( v2 )
    v1 = sub_100193E0(v2);
  sub_10004EA0(54);
  return v1;
}

//----- (10019560) --------------------------------------------------------
char __cdecl sub_10019560(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10004EC0(54, 60000);
  v1 = -1;
  v2 = sub_1001C4F0(a1);
  if ( v2 )
    v1 = sub_10019420(v2);
  sub_10004EA0(54);
  return v1;
}

//----- (100195A0) --------------------------------------------------------
char __cdecl sub_100195A0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10004EC0(54, 60000);
  v1 = -1;
  v2 = sub_1001C4F0(a1);
  if ( v2 )
    v1 = sub_10019460(v2);
  sub_10004EA0(54);
  return v1;
}

//----- (100195E0) --------------------------------------------------------
char __cdecl sub_100195E0(unsigned __int8 a1, int a2, char a3, int a4)
{
  char result; // al@2

  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, int))dword_101E37B8)(
                          a2 + dword_10072E84[3 * a1] - 3,
                          4,
                          a4) )
  {
    *(_BYTE *)(a4 + 4) = a3;
    *(_BYTE *)a4 &= byte_10070B2C[5 * a1];
    *(_BYTE *)(a4 + 1) &= byte_10070B2D[5 * a1];
    *(_BYTE *)(a4 + 2) &= byte_10070B2E[5 * a1];
    *(_BYTE *)(a4 + 3) &= byte_10070B2F[5 * a1];
    *(_BYTE *)(a4 + 4) &= byte_10070B30[5 * a1];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10072E84: using guessed type int dword_10072E84[];
// 101E37B8: using guessed type int dword_101E37B8;

//----- (10019660) --------------------------------------------------------
char __usercall sub_10019660@<al>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // edi@1
  unsigned int v3; // edi@2
  char v4; // dl@2
  signed int v5; // eax@2
  char result; // al@6
  __int16 v7; // [sp+Ch] [bp-1ECh]@1
  char v8[490]; // [sp+Eh] [bp-1EAh]@3

  v2 = a1;
  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, __int16 *))dword_101E37B8)(
                          dword_101E38C0[3 * (unsigned __int8)byte_10072E7C[12 * a2]],
                          492,
                          &v7) )
  {
    v3 = v2 - *(_DWORD *)(dword_101E4110 + 4 * a2 + 20812);
    v4 = 0;
    v5 = 163;
    do
    {
      if ( *(unsigned __int16 *)((char *)&v7 + 3 * v5) + ((v8[3 * v5] & 3u) << 16) <= v3 )
      {
        v4 = v5;
        v5 = 0;
      }
      --v5;
    }
    while ( v5 >= 0 );
    result = v4 + 4;
  }
  else
  {
    result = -92;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E38C0: using guessed type int dword_101E38C0[];
// 101E4110: using guessed type int dword_101E4110;
// 10019660: using guessed type char var_1EA[490];

//----- (10019700) --------------------------------------------------------
char __usercall sub_10019700@<al>(char a1@<al>)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 0;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 3;
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10019730) --------------------------------------------------------
int __fastcall sub_10019730(int a1, int a2)
{
  int result; // eax@1

  result = ((*(_WORD *)a1 << 9) + (*(_WORD *)(a1 + 5) & 0x1FF)) << 7;
  *(_DWORD *)a2 = (*(_BYTE *)(a1 + 4) + (*(_WORD *)(a1 + 2) << 8)) << 7;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (10019760) --------------------------------------------------------
void __cdecl sub_10019760(unsigned int a1, int a2)
{
  unsigned __int8 v2; // bl@4
  int v3; // ebp@4
  char v4; // ST34_1@4
  char v5; // [sp+Ch] [bp-Ch]@4
  char v6; // [sp+10h] [bp-8h]@5

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_101E4110 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        sub_1001C8B0(a1, a2);
      else
        sub_1001ADF0(a1, a2);
    }
    else
    {
      v2 = sub_1001BDA0(a1);
      v3 = sub_1001BDD0(a1, v2, 1);
      v4 = sub_10019660(a1, v2);
      if ( sub_100195E0(v2, v3, v4, (int)&v5) )
      {
        sub_1001B340(&v6, 6, a2);
        sub_1001E3A0(a2, 6);
      }
      else
      {
        *(_DWORD *)a2 = *(_DWORD *)"______";
        *(_WORD *)(a2 + 4) = *(_WORD *)"__";
        *(_BYTE *)(a2 + 6) = a______[6];
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)"______";
    *(_WORD *)(a2 + 4) = *(_WORD *)"__";
    *(_BYTE *)(a2 + 6) = a______[6];
  }
}
// 101E4110: using guessed type int dword_101E4110;

//----- (100198A0) --------------------------------------------------------
char __cdecl sub_100198A0(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // al@4
  int v4; // eax@4
  char v5; // [sp+4h] [bp-8h]@4

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_101E4110 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        result = sub_1001CA90(a1, a2);
      else
        result = sub_1001AFF0(a1, a2);
    }
    else
    {
      v3 = sub_1001BDA0(a1);
      v4 = sub_1001BDD0(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v4, 7, &v5);
      result = sub_10019730((int)&v5, a2);
    }
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E4110: using guessed type int dword_101E4110;

//----- (10019950) --------------------------------------------------------
int __cdecl sub_10019950(char a1, int a2)
{
  char v2; // al@1
  int v3; // ecx@1
  int result; // eax@2

  v2 = sub_10019700(a1);
  if ( (unsigned __int8)v2 >= 4u )
    result = v3;
  else
    result = a2 + *(_DWORD *)(dword_101E4110 + 4 * (unsigned __int8)v2 + 20812);
  return result;
}
// 101E4110: using guessed type int dword_101E4110;

//----- (10019980) --------------------------------------------------------
void __usercall sub_10019980(int a1@<ecx>, int a2@<esi>)
{
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  sub_10019730(a1, (int)&v2);
  *(double *)a2 = sub_10020000(v2, 24);
  *(double *)(a2 + 8) = sub_10020000(v3, 24);
}

//----- (100199B0) --------------------------------------------------------
char __cdecl sub_100199B0(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // bl@4
  int v4; // eax@4
  unsigned int v5; // ebx@7
  char v6; // bl@13
  int v7; // [sp+4h] [bp-20h]@4
  int v8; // [sp+8h] [bp-1Ch]@10
  unsigned __int8 v9; // [sp+Ch] [bp-18h]@9
  unsigned int v10; // [sp+Eh] [bp-16h]@7
  unsigned int v11; // [sp+14h] [bp-10h]@8

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_101E4110 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
      {
        v6 = sub_1001CA90(a1, (int)&v7);
        if ( v6 )
        {
          sub_100231C0(a2, v7, v8);
          result = v6;
        }
        else
        {
          *(double *)a2 = 6.2831853071796;
          *(double *)(a2 + 8) = 6.2831853071796;
          result = 0;
        }
      }
      else
      {
        result = sub_1001AF80(a1, a2);
      }
    }
    else
    {
      v3 = sub_1001BDA0(a1);
      v4 = sub_1001BDD0(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, int *))dword_101E37B8)(v4, 32, &v7);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          LOBYTE(v5) = v9 >> 1;
        }
        else if ( v3 == 2 )
        {
          v5 = v11 >> 14;
        }
        else
        {
          v5 = v10 >> 23;
        }
      }
      else
      {
        v5 = (unsigned int)v8 >> 29;
      }
      sub_10019980((int)&v7, a2);
      result = v5 & 1;
    }
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
    result = 0;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E4110: using guessed type int dword_101E4110;

//----- (10019AD0) --------------------------------------------------------
char __cdecl sub_10019AD0(unsigned int a1, unsigned int *a2, _BYTE *a3, _BYTE *a4)
{
  char result; // al@1

  *a2 = a1 & 0x3FFFF;
  *a3 = (a1 >> 18) & 0x7F;
  result = (a1 >> 25) & 1;
  *a4 = result;
  return result;
}

//----- (10019B00) --------------------------------------------------------
int __cdecl sub_10019B00(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  unsigned __int16 v3; // [sp+Ch] [bp+4h]@1

  result = 0;
  v3 = *(_WORD *)(a1 + 4);
  v2 = 0;
  do
  {
    if ( v3 & (unsigned __int16)(1 << v2) )
      result += (unsigned __int16)word_101E3FE2;
    ++v2;
  }
  while ( v2 < 16 );
  return result;
}
// 101E3FE2: using guessed type __int16 word_101E3FE2;

//----- (10019B40) --------------------------------------------------------
signed int __usercall sub_10019B40@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // eax@4

  if ( !a3 )
    return 1000;
  if ( a1 != 1000 )
  {
    v4 = 5 * a1;
    goto LABEL_7;
  }
  if ( a2 != 1000 )
  {
    v4 = 5 * a2 - 90;
LABEL_7:
    if ( abs(2 * v4 - a3) > 90 )
      a3 += 180;
  }
  return a3;
}

//----- (10019B80) --------------------------------------------------------
signed int __thiscall sub_10019B80(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 0x10 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_10019B00(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_101E37B8)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_101E3FE2;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_101E3FE2;
    }
    if ( v5 & 4 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_101E3FE2;
    }
    if ( v5 & 8 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3FE2: using guessed type __int16 word_101E3FE2;

//----- (10019C30) --------------------------------------------------------
signed int __usercall sub_10019C30@<eax>(int a1@<edi>)
{
  signed int result; // eax@1
  int v2; // ebx@2
  int v3; // esi@2
  __int16 v4; // ax@2
  char *v5; // ecx@2
  unsigned __int16 v6; // [sp+0h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_10019B00(a1);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_101E37B8)(v2, 160, &v6);
    v4 = *(_WORD *)(a1 + 4);
    v5 = (char *)&v6;
    if ( v4 & 1 )
    {
      v3 += v6;
      v5 = (char *)&v6 + (unsigned __int16)word_101E3FE2;
    }
    if ( v4 & 2 )
      v3 += *(_WORD *)v5;
    result = v3;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3FE2: using guessed type __int16 word_101E3FE2;

//----- (10019CC0) --------------------------------------------------------
signed int __thiscall sub_10019CC0(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 8 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_10019B00(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_101E37B8)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_101E3FE2;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_101E3FE2;
    }
    if ( v5 & 4 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3FE2: using guessed type __int16 word_101E3FE2;

//----- (10019D60) --------------------------------------------------------
char __usercall sub_10019D60@<al>(int a1@<eax>, char a2)
{
  int v2; // ecx@2
  char v3; // cl@2
  int v4; // eax@2
  unsigned int v5; // eax@3
  unsigned int v6; // ecx@3
  int v7; // eax@5

  if ( a2 == 2 )
  {
    v2 = *(_DWORD *)(a1 + 12) >> 22;
    v4 = *(_DWORD *)(a1 + 4) >> 30;
    v3 = v2 & 3;
    LOBYTE(v4) = v4 & 3;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 12);
    v6 = v5 >> 23;
    v4 = v5 >> 22;
    v3 = v6 & 1;
    LOBYTE(v4) = v4 & 1;
  }
  if ( v3 == 1 )
  {
    LOBYTE(v4) = (_BYTE)v4 == 1;
    v7 = 2 * v4 + 1;
  }
  else if ( (_BYTE)v4 == 1 )
  {
    LOBYTE(v7) = 2;
  }
  else if ( v3 == 2 || (_BYTE)v4 == 2 )
  {
    LOBYTE(v7) = 5;
  }
  else
  {
    LOBYTE(v7) = 0;
  }
  return v7;
}

//----- (10019DB0) --------------------------------------------------------
int __usercall sub_10019DB0@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 1 )
    result = *(_DWORD *)a1 + sub_10019B00(a1);
  return result;
}

//----- (10019DD0) --------------------------------------------------------
char __usercall sub_10019DD0@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6)
{
  int *v6; // ebp@1

  v6 = a6;
  *a6 = 1000;
  *(_BYTE *)a1 = 95;
  *a2 = 1000;
  *a3 = 95;
  if ( *(_BYTE *)(a4 + 3) & 0x1F )
  {
    *v6 = *(_BYTE *)(a4 + 3) & 0x1F;
    *(_BYTE *)a1 = byte_10070B68[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    *a2 = (*(_BYTE *)(a4 + 3) & 0x1F) + 18;
    a1 = ((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7;
    *a3 = byte_10070B60[a1];
  }
  if ( *(_BYTE *)(a4 + 5) & 4 )
  {
    (*(void (__cdecl **)(_DWORD, signed int, int **))dword_101E37B8)(*a5, 1, &a6);
    *a5 += (unsigned __int16)word_101E3FE6;
    LOBYTE(a1) = (_BYTE)a6;
    if ( (unsigned __int8)a6 & 0x1F )
    {
      a1 = ((unsigned __int8)a6 & 0x1F) + 18;
      *a2 = a1;
      *a3 = byte_10070B60[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    }
    else
    {
      *a2 = 1000;
      *a3 = 95;
    }
  }
  return a1;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3FE6: using guessed type __int16 word_101E3FE6;

//----- (10019E90) --------------------------------------------------------
void *__usercall sub_10019E90@<eax>(int a1@<eax>, char *a2@<esi>)
{
  int v2; // ST0C_4@2
  int v3; // eax@2
  void *result; // eax@2

  if ( *(_WORD *)(a1 + 10) & 0x8000 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 22);
    HIWORD(v2) = (*(_DWORD *)(a1 + 16) >> 25) & 0x7F;
    v3 = v2 + dword_101E3944;
    *(_DWORD *)a2 = v2 + dword_101E3944;
    result = (void *)(*(int (__cdecl **)(int, signed int, char *, int))dword_101E37B8)(v3, 2, a2 + 4, v2);
    *(_DWORD *)a2 += (unsigned __int16)word_101E3948;
  }
  else
  {
    result = memcpy(a2, &unk_10070B70, 6u);
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3944: using guessed type int dword_101E3944;
// 101E3948: using guessed type __int16 word_101E3948;

//----- (10019EF0) --------------------------------------------------------
int __usercall sub_10019EF0@<eax>(int a1@<ecx>, _BYTE *a2@<ebx>)
{
  int v2; // edi@1
  int *v3; // edx@1
  int v4; // esi@4
  int result; // eax@4
  char v6; // cl@4
  char v7; // [sp+Ch] [bp-34h]@3
  char v8; // [sp+30h] [bp-10h]@2
  int v9; // [sp+3Ch] [bp-4h]@1

  v2 = a1;
  *a2 = 0;
  v3 = &v9;
  do
  {
    if ( v3 > (int *)&v8 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v2, 48, &v7);
      v3 = (int *)&v7;
    }
    ++*a2;
    v2 += (unsigned __int16)word_101E3FE4;
    v4 = (unsigned __int16)word_101E3FE4;
    result = *(_WORD *)((char *)v3 + 5);
    v6 = *((_BYTE *)v3 + 2) >> 7;
    if ( result & 4 )
    {
      v2 += (unsigned __int16)word_101E3FE6;
      v4 = (unsigned __int16)word_101E3FE6 + (unsigned __int16)word_101E3FE4;
    }
    if ( result & 8 )
    {
      v2 += (unsigned __int16)word_101E3FE8;
      v4 += (unsigned __int16)word_101E3FE8;
    }
    if ( result & 0x10 )
    {
      result = (unsigned __int16)word_101E3FEA;
      v2 += (unsigned __int16)word_101E3FEA;
      v4 += (unsigned __int16)word_101E3FEA;
    }
    v3 = (int *)((char *)v3 + v4);
  }
  while ( v6 );
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3FE4: using guessed type __int16 word_101E3FE4;
// 101E3FE6: using guessed type __int16 word_101E3FE6;
// 101E3FE8: using guessed type __int16 word_101E3FE8;
// 101E3FEA: using guessed type __int16 word_101E3FEA;

//----- (10019F90) --------------------------------------------------------
__int16 __usercall sub_10019F90@<ax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // edi@2
  int v6; // ecx@6
  int v7; // edx@10
  char v8; // cl@10
  unsigned int v9; // eax@10
  int v10; // edx@16
  int v12; // [sp+0h] [bp-20h]@0
  __int16 v13; // [sp+Ch] [bp-14h]@2
  __int16 v14; // [sp+Eh] [bp-12h]@6
  int v15; // [sp+10h] [bp-10h]@2

  v3 = a1;
  sub_100198A0(a3 & 0x3FFFF, v12);
  *(_DWORD *)a2 >>= 7;
  *(_DWORD *)(a2 + 4) >>= 7;
  LOWORD(v4) = HIWORD(a3) >> 10;
  if ( HIWORD(a3) >> 10 != 5 )
  {
    if ( (_WORD)v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E37B8)(v3, 9, &v13);
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned int)(unsigned __int8)v15 >> 4;
    }
    else
    {
      if ( (_WORD)v4 == 7 )
      {
        (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E37B8)(v3, 11, &v13);
      }
      else
      {
        if ( (_WORD)v4 != 8 )
          return v4;
        (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101E37B8)(v3, 15, &v13);
      }
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned __int8)v15 >> 4;
    }
    *(_DWORD *)a2 = (v7 - (v8 & 0xF)) << 7;
    v10 = *(_DWORD *)(a2 + 4) - v9;
    v4 = 16 * v13;
    *(_DWORD *)(a2 + 4) = (v10 - v4) << 7;
    return v4;
  }
  (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101E37B8)(v3, 7, &v13);
  LOWORD(v4) = v15;
  v5 = (unsigned __int16)word_101E3FE4 + v3;
  if ( BYTE1(v15) & 8 )
  {
    if ( BYTE1(v15) & 4 )
      v5 += (unsigned __int16)word_101E3FE6;
    (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E37B8)(v5, 19, &v13);
    if ( (HIWORD(a3) & 0x3FCu) > 0x1FC )
    {
      v4 = (signed __int16)v15;
      *(_DWORD *)a2 -= SHIWORD(v15);
      *(_DWORD *)(a2 + 4) -= v4;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
    else
    {
      LOWORD(v4) = v14;
      v6 = v13;
      *(_DWORD *)a2 -= v14;
      *(_DWORD *)(a2 + 4) -= v6;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0x7FFFFFFF;
    *(_DWORD *)(a2 + 4) = 0x7FFFFFFF;
  }
  return v4;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3FE4: using guessed type __int16 word_101E3FE4;
// 101E3FE6: using guessed type __int16 word_101E3FE6;

//----- (1001A100) --------------------------------------------------------
char __cdecl sub_1001A100(unsigned int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebp@1
  __int64 v4; // ST00_8@1
  char result; // al@1
  int v6; // eax@2
  unsigned int v7; // edi@2
  unsigned int v8; // ecx@2
  unsigned __int8 v9; // al@2
  char v10; // dl@2
  unsigned __int8 v11; // cl@3
  char v12; // dl@3
  char v13; // cl@3
  unsigned int v14; // ebp@4
  unsigned __int8 v15; // cl@4
  unsigned int v16; // eax@5
  char v17; // [sp+14h] [bp-20h]@2
  unsigned int v18; // [sp+18h] [bp-1Ch]@2
  int v19; // [sp+1Eh] [bp-16h]@2
  unsigned int v20; // [sp+24h] [bp-10h]@2
  unsigned int v21; // [sp+28h] [bp-Ch]@2
  __int16 v22; // [sp+2Dh] [bp-7h]@8
  unsigned __int8 v23; // [sp+2Fh] [bp-5h]@3
  unsigned __int8 v24; // [sp+30h] [bp-4h]@3
  unsigned __int8 v25; // [sp+3Ch] [bp+8h]@1
  int v26; // [sp+3Ch] [bp+8h]@8

  v2 = a2;
  v3 = a2 + 32;
  memcpy((void *)(a2 + 32), "______", 7u);
  *(double *)a2 = 6.2831853071796;
  *(double *)(a2 + 8) = 6.2831853071796;
  *(float *)(a2 + 16) = 9.9999996e24;
  *(_BYTE *)(a2 + 62) = byte_101E38B0;
  *(_BYTE *)(a2 + 58) = 0;
  *(_BYTE *)(a2 + 63) = 0;
  *(_BYTE *)(a2 + 64) = 0;
  *(_BYTE *)(a2 + 65) = 0;
  *(_BYTE *)(a2 + 66) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 28) = 0x3FFFF;
  *(_DWORD *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 67) = 2;
  *(_BYTE *)(a2 + 59) = 0;
  *(_BYTE *)(a2 + 60) = 0;
  *(_BYTE *)(a2 + 61) = 0;
  sub_1001E210(a2 + 39, word_10060D0C, 9);
  sub_1001E210(a2 + 52, word_10060D0C, 6);
  sub_1001E210(a2 + 48, word_10060D0C, 4);
  LODWORD(v4) = a1;
  v25 = sub_10022E00();
  result = sub_1001BE80(v4);
  if ( !result )
  {
    sub_10019760(a1, v3);
    sub_100199B0(a1, v2);
    v6 = sub_1001BE50(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v6, 29, &v17);
    v7 = v18;
    v8 = v21 >> 13;
    v9 = (v18 >> 26) & 7;
    v10 = (v20 >> 23) & 1;
    *(float *)(v2 + 16) = (double)((v19 & 0x7FFF) - 5000) * 0.3048000037670135;
    *(_BYTE *)(v2 + 62) = v9;
    *(_BYTE *)(v2 + 58) = v10;
    *(_BYTE *)(v2 + 63) = v8 & 7;
    if ( v25 == 2 )
    {
      v11 = v24;
      *(_BYTE *)(v2 + 65) = v24 & 7;
      *(_BYTE *)(v2 + 66) = (v23 >> 4) & 7;
      *(_BYTE *)(v2 + 67) = (*(unsigned int *)((char *)&v19 + 2) >> 29) & 3;
      *(_BYTE *)(v2 + 59) = (v11 >> 3) & 1;
      v12 = v11 >> 4;
      v13 = v11 >> 5;
    }
    else
    {
      v14 = *(int *)((char *)&v19 + 2);
      *(_BYTE *)(v2 + 65) = (*(unsigned int *)((char *)&v19 + 2) >> 30) & 3;
      *(_BYTE *)(v2 + 66) = (v7 >> 30) & 3;
      *(_BYTE *)(v2 + 67) = (v14 >> 29) & 1;
      v15 = v23;
      *(_BYTE *)(v2 + 59) = (v23 >> 2) & 1;
      v12 = v15 >> 3;
      v13 = v15 >> 4;
    }
    *(_BYTE *)(v2 + 61) = v13 & 1;
    *(_BYTE *)(v2 + 60) = v12 & 1;
    sub_1001E210(v2 + 39, (_BYTE *)(dword_101E4110 + 25 * (v9 + 64)), 9);
    sub_1001E210(v2 + 52, (_BYTE *)(dword_101E4110 + 25 * (*(_BYTE *)(v2 + 66) + 128)), 6);
    sub_1001E210(v2 + 48, (_BYTE *)(dword_101E4110 + 25 * (*(_BYTE *)(v2 + 65) + 192)), 4);
    v16 = (*(unsigned int *)((char *)&v19 + 2) >> 24) & 0x1F;
    *(_DWORD *)(v2 + 20) = v16;
    if ( v16 != 31 )
      *(_DWORD *)(v2 + 20) = 12 - v16;
    *(_DWORD *)(v2 + 24) = v21 & 0x1FFF;
    result = sub_10019D60((int)&v17, v25);
    *(_BYTE *)(v2 + 64) = result;
    if ( (unsigned __int16)word_101E3924 >= 0x1Cu )
    {
      result = v22;
      HIWORD(v26) = v23 & 3;
      LOWORD(v26) = v22;
      *(_DWORD *)(v2 + 28) = v26;
    }
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E38B0: using guessed type char byte_101E38B0;
// 101E3924: using guessed type __int16 word_101E3924;
// 101E4110: using guessed type int dword_101E4110;

//----- (1001A380) --------------------------------------------------------
void *__cdecl sub_1001A380(unsigned int a1, char *a2)
{
  int v2; // eax@2
  __int64 v4; // [sp-4h] [bp-24h]@0
  char v5; // [sp+4h] [bp-1Ch]@2
  __int16 v6; // [sp+Eh] [bp-12h]@1

  v6 &= 0x7FFFu;
  LODWORD(v4) = a1;
  if ( !sub_1001BE80(v4) )
  {
    v2 = sub_1001BE50(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v2, 28, &v5);
  }
  return sub_10019E90((int)&v5, a2);
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (1001A3D0) --------------------------------------------------------
signed int __cdecl sub_1001A3D0(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-10h]@3
  int v6; // [sp+Eh] [bp-6h]@3

  result = sub_10019B80(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_101E37B8)(v3, 15, &v5);
        if ( !(v6 & 0x400) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_101E3FEC;
        if ( v6 & 0x200 )
          v3 += (unsigned __int16)word_101E3FEE;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3FEC: using guessed type __int16 word_101E3FEC;
// 101E3FEE: using guessed type __int16 word_101E3FEE;

//----- (1001A450) --------------------------------------------------------
signed int __usercall sub_1001A450@<eax>(int a1@<edi>, unsigned __int8 a2)
{
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  char v6; // [sp+9h] [bp-7h]@3

  result = sub_10019C30(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_101E37B8)(v3, 9, &v5);
        if ( !(v6 & 1) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_101E4004;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E4004: using guessed type __int16 word_101E4004;

//----- (1001A4C0) --------------------------------------------------------
signed int __cdecl sub_1001A4C0(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  int v6; // [sp+Ch] [bp-4h]@3

  result = sub_10019CC0(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_101E37B8)(v3, 11, &v5);
        if ( !(v6 & 0x8000) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_101E4006;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E4006: using guessed type __int16 word_101E4006;

//----- (1001A530) --------------------------------------------------------
int __usercall sub_1001A530@<eax>(int a1@<eax>, char a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // [sp+4h] [bp-8h]@3
  char v6; // [sp+6h] [bp-6h]@3
  char v7; // [sp+9h] [bp-3h]@4

  result = sub_10019DB0(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v3, 7, &v5);
        if ( !(v6 & 0x80) )
          break;
        v3 += (unsigned __int16)word_101E3FE4;
        ++v4;
        if ( v7 & 4 )
          v3 += (unsigned __int16)word_101E3FE6;
        if ( v7 & 8 )
          v3 += (unsigned __int16)word_101E3FE8;
        if ( v7 & 0x10 )
          v3 += (unsigned __int16)word_101E3FEA;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3FE4: using guessed type __int16 word_101E3FE4;
// 101E3FE6: using guessed type __int16 word_101E3FE6;
// 101E3FE8: using guessed type __int16 word_101E3FE8;
// 101E3FEA: using guessed type __int16 word_101E3FEA;

//----- (1001A5C0) --------------------------------------------------------
void __usercall sub_1001A5C0(int a1@<edi>, int a2, int a3)
{
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@1

  sub_10019F90(a3, (int)&v3, a2);
  *(double *)a1 = sub_10020000(v3, 24);
  *(double *)(a1 + 8) = sub_10020000(v4, 24);
}

//----- (1001A600) --------------------------------------------------------
signed int __cdecl sub_1001A600(unsigned int a1, char a2, char a3)
{
  int v3; // esi@2
  signed int result; // eax@4
  int v5; // [sp+Ch] [bp-8h]@1

  sub_1001A380(a1, (char *)&v5);
  if ( sub_1001A530((int)&v5, a2) == 0xFFFFFF )
  {
    result = 0x3FFFF;
  }
  else
  {
    v5 = a1;
    v3 = (a1 >> 16) & 3;
    HIWORD(v5) = v3 | 4 * ((unsigned __int8)a2 | 0x500);
    if ( a3 )
      HIWORD(v5) = v3 | 4 * ((unsigned __int8)a2 | 0x500) | 0x200;
    result = v5;
  }
  return result;
}

//----- (1001A680) --------------------------------------------------------
__int16 __cdecl sub_1001A680(unsigned int a1, char a2, int a3)
{
  int v3; // ebp@1
  __int16 v4; // bx@1
  unsigned int v5; // eax@1
  double v6; // st7@1
  unsigned int v7; // esi@1
  signed int v8; // eax@3
  unsigned __int16 v9; // dx@3
  int v10; // edx@3
  int v11; // eax@3
  int v12; // edx@3
  int v13; // ecx@3
  int v14; // edi@3
  int v15; // ecx@3
  double v16; // st7@3
  unsigned __int16 v17; // cx@3
  __int16 v18; // ax@3
  __int16 v19; // dx@3
  __int16 v20; // ax@3
  unsigned int v21; // edx@6
  __int16 v22; // cx@7
  double v23; // st5@8
  char v24; // al@12
  char v25; // cl@12
  unsigned int v26; // ecx@25
  unsigned int v27; // ecx@25
  unsigned __int16 v28; // dx@25
  float v30; // [sp+Ch] [bp-3Ch]@3
  char v31; // [sp+10h] [bp-38h]@1
  int v32; // [sp+18h] [bp-30h]@3
  int v33; // [sp+1Ch] [bp-2Ch]@3
  unsigned int v34; // [sp+20h] [bp-28h]@25
  unsigned int v35; // [sp+24h] [bp-24h]@25
  unsigned __int16 v36; // [sp+28h] [bp-20h]@2
  char v37; // [sp+2Ah] [bp-1Eh]@3
  unsigned __int16 v38; // [sp+2Bh] [bp-1Dh]@3
  unsigned __int16 v39; // [sp+2Dh] [bp-1Bh]@2
  __int16 v40; // [sp+34h] [bp-14h]@3
  __int16 v41; // [sp+36h] [bp-12h]@3
  __int16 v42; // [sp+38h] [bp-10h]@3
  __int16 v43; // [sp+3Ah] [bp-Eh]@3
  unsigned __int16 v44; // [sp+3Ch] [bp-Ch]@3
  unsigned __int8 v45; // [sp+3Eh] [bp-Ah]@3
  __int16 v46; // [sp+3Fh] [bp-9h]@7
  unsigned int v47; // [sp+41h] [bp-7h]@6
  unsigned __int16 v48; // [sp+45h] [bp-3h]@24

  v3 = a3;
  v4 = 0;
  *(_BYTE *)(a3 + 2) = 0;
  sub_1001A380(a1, &v31);
  v5 = sub_1001A530((int)&v31, a2);
  v6 = 9.9999996e24;
  v7 = v5;
  if ( v5 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(unsigned int, signed int, unsigned __int16 *))dword_101E37B8)(v5, 12, &v36);
    LOWORD(v5) = word_101E3FE4;
    a3 = (unsigned __int16)word_101E3FE4 + v7;
    if ( v39 & 8 )
    {
      *(_BYTE *)(v3 + 2) = 1;
      sub_10019DD0(v3 + 7, (unsigned int *)(v3 + 16), (_BYTE *)(v3 + 8), (int)&v36, &a3, (int *)(v3 + 12));
      v8 = sub_10019B40(*(_DWORD *)(v3 + 12), *(_DWORD *)(v3 + 16), (unsigned int)v38 >> 8);
      v9 = v39;
      *(_DWORD *)(v3 + 20) = v8;
      LOBYTE(v8) = v37 & 0xF;
      *(_WORD *)(v3 + 10) = v9 >> 5;
      v10 = a3;
      *(_BYTE *)(v3 + 9) = v8;
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E37B8)(v10, 19, &v40);
      sub_100198A0(a1, (int)&v32);
      v11 = v32 >> 7;
      v12 = v40;
      v13 = v33 >> 7;
      *(_DWORD *)(v3 + 24) = ((v32 >> 7) - v41) << 7;
      v14 = v13 - v12;
      v32 = v11;
      *(_DWORD *)(v3 + 32) = (v11 - v43) << 7;
      v33 = v13;
      v15 = (v13 - v42) << 7;
      *(_DWORD *)(v3 + 28) = v14 << 7;
      *(_DWORD *)(v3 + 36) = v15;
      v16 = sub_1001BF20(a1);
      v17 = v44;
      v30 = v16;
      a3 = (signed __int16)((signed __int16)(16 * v44) >> 4);
      v18 = 16 * v45;
      v19 = ((signed __int16)(16 * v44) >> 4) & 0xF00F;
      *(float *)(v3 + 40) = (double)a3 * 0.3048000037670135 + v30;
      v20 = (v17 >> 12) | (v19 | v18) & 0xFFF0;
      LOWORD(a3) = v20;
      if ( v20 & 0x800 )
        LOWORD(v5) = v5 | 0xF000;
      else
        LOWORD(v5) = v5 & 0xFFF;
      a3 = (signed __int16)v5;
      v21 = v47;
      *(_BYTE *)(v3 + 3) = 0;
      *(_BYTE *)(v3 + 4) = 0;
      *(_BYTE *)(v3 + 5) = 0;
      *(_BYTE *)(v3 + 6) = 0;
      *(float *)(v3 + 56) = v30 + 0.3048000037670135 * (double)(signed __int16)v5;
      v6 = 9.9999996e24;
      *(float *)(v3 + 44) = 9.9999996e24;
      *(float *)(v3 + 60) = 9.9999996e24;
      *(float *)(v3 + 52) = 9.9999996e24;
      *(float *)(v3 + 68) = 9.9999996e24;
      *(float *)(v3 + 76) = 9.9999996e24;
      *(float *)(v3 + 72) = 9.9999996e24;
      if ( (unsigned __int16)word_101E3FE8 >= 0xBu )
      {
        v22 = v46;
        LOWORD(v5) = v46 & 0x3FFF;
        if ( (v46 & 0x3FFF) != 0x3FFF )
        {
          a3 = (unsigned __int16)v5;
          LOWORD(v5) = (unsigned __int8)v21;
          *(float *)&a3 = (double)a3 / 10.0 - 350.0;
          v23 = *(float *)&a3;
          a3 = (unsigned __int8)v21;
          *(float *)(v3 + 44) = v23;
          *(float *)&a3 = (double)a3 / 10.0;
          if ( v22 & 0x8000 )
            *(float *)&a3 = -*(float *)&a3;
          *(float *)(v3 + 60) = v23 + *(float *)&a3;
        }
      }
      if ( (unsigned __int16)word_101E3FE8 < 0x13u )
      {
        *(float *)(v3 + 48) = 9.9999996e24;
        *(_BYTE *)v3 = 0;
        *(float *)(v3 + 64) = 9.9999996e24;
        *(_BYTE *)(v3 + 1) = 0;
        goto LABEL_33;
      }
      v24 = (v21 >> 18) & 1;
      v25 = (v21 >> 20) & 1;
      *(_BYTE *)v3 = v24;
      *(_BYTE *)(v3 + 1) = v25;
      if ( v24 )
      {
        a3 = (v21 >> 8) & 0x3FF;
        *(float *)(v3 + 48) = (double)(unsigned int)a3 / 100.0;
      }
      else
      {
        *(float *)(v3 + 48) = 9.9999996e24;
      }
      if ( v25 )
      {
        a3 = v21 >> 22;
        *(float *)(v3 + 64) = (double)(v21 >> 22) / 100.0;
      }
      else
      {
        *(float *)(v3 + 64) = 9.9999996e24;
      }
      if ( v24 && !(v21 & 0x80000) )
        *(float *)(v3 + 48) = *(float *)(v3 + 48) * -1.0;
      if ( v25 && !(v21 & 0x200000) )
        *(float *)(v3 + 64) = -1.0 * *(float *)(v3 + 64);
      LOWORD(v5) = v48;
      if ( v48 == -1 )
        goto LABEL_33;
      (*(void (__cdecl **)(int, signed int, unsigned int *))dword_101E37B8)(
        dword_101E3D04 + (unsigned __int16)word_101E3D08 * v48,
        8,
        &v34);
      v5 = v34;
      v26 = v34 >> 31;
      *(_BYTE *)(v3 + 3) = (v34 >> 15) & 1;
      *(_BYTE *)(v3 + 4) = v26 & 1;
      v27 = v35;
      *(_BYTE *)(v3 + 5) = (v35 >> 15) & 1;
      *(_BYTE *)(v3 + 6) = (v27 >> 31) & 1;
      v28 = v36;
      if ( v5 & 0x4000 )
      {
        a3 = v36 - (v5 & 0x3FFF);
        *(float *)(v3 + 52) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v5 & 0x40000000 )
      {
        v5 = (v5 >> 16) & 0x3FFF;
        a3 = v28 - v5;
        *(float *)(v3 + 68) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v27 & 0x4000 )
      {
        v5 = v27 & 0x3FFF;
        a3 = v28 - v5;
        *(float *)(v3 + 76) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v27 & 0x40000000 )
      {
        a3 = v28 - ((v27 >> 16) & 0x3FFF);
        *(float *)(v3 + 72) = 0.3048 * (double)(unsigned int)a3;
        v6 = 9.9999996e24;
LABEL_33:
        v4 = 0;
        goto LABEL_34;
      }
      v4 = 0;
    }
    v6 = 9.9999996e24;
  }
LABEL_34:
  if ( *(_BYTE *)(v3 + 2) == (_BYTE)v4 )
  {
    *(_BYTE *)v3 = v4;
    *(_BYTE *)(v3 + 1) = v4;
    *(_DWORD *)(v3 + 12) = 1000;
    *(_DWORD *)(v3 + 16) = 1000;
    *(_DWORD *)(v3 + 20) = 1000;
    *(_WORD *)(v3 + 10) = v4;
    *(_BYTE *)(v3 + 7) = 95;
    *(_BYTE *)(v3 + 8) = 95;
    LOBYTE(v5) = byte_101E410C;
    *(float *)(v3 + 40) = v6;
    *(float *)(v3 + 44) = v6;
    *(_BYTE *)(v3 + 9) = v5;
    *(float *)(v3 + 56) = v6;
    LOWORD(v5) = -1;
    *(float *)(v3 + 60) = v6;
    *(float *)(v3 + 48) = v6;
    *(_BYTE *)(v3 + 3) = v4;
    *(float *)(v3 + 64) = v6;
    *(_BYTE *)(v3 + 4) = v4;
    *(float *)(v3 + 52) = v6;
    *(_BYTE *)(v3 + 5) = v4;
    *(float *)(v3 + 68) = v6;
    *(_BYTE *)(v3 + 6) = v4;
    *(float *)(v3 + 76) = v6;
    *(_DWORD *)(v3 + 24) = 0x7FFFFFFF;
    *(float *)(v3 + 72) = v6;
    *(_DWORD *)(v3 + 28) = 0x7FFFFFFF;
    *(_DWORD *)(v3 + 32) = 0x7FFFFFFF;
    *(_DWORD *)(v3 + 36) = 0x7FFFFFFF;
  }
  return v5;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3D04: using guessed type int dword_101E3D04;
// 101E3D08: using guessed type __int16 word_101E3D08;
// 101E3FE4: using guessed type __int16 word_101E3FE4;
// 101E3FE8: using guessed type __int16 word_101E3FE8;
// 101E410C: using guessed type char byte_101E410C;

//----- (1001AB60) --------------------------------------------------------
char __cdecl sub_1001AB60(unsigned int a1)
{
  __int64 v1; // ST00_8@1
  int v2; // esi@1
  char result; // al@3
  char v4; // [sp+Fh] [bp-9h]@1
  char v5; // [sp+10h] [bp-8h]@1

  v4 = 0;
  sub_1001A380(a1, &v5);
  LODWORD(v1) = a1;
  v2 = sub_10019DB0((int)&v5);
  if ( sub_1001BE80(v1) )
  {
    result = 0;
  }
  else if ( v2 == 0xFFFFFF )
  {
    result = 0;
  }
  else
  {
    sub_10019EF0(v2, &v4);
    result = v4;
  }
  return result;
}

//----- (1001ABD0) --------------------------------------------------------
int __cdecl sub_1001ABD0(__int64 a1)
{
  int result; // eax@2
  char v2; // [sp+0h] [bp-8h]@1

  sub_1001A380(a1 & 0x3FFFF, &v2);
  switch ( (unsigned int)WORD1(a1) >> 10 )
  {
    case 5u:
      result = sub_1001A530((int)&v2, (*(_DWORD *)((char *)&a1 + 2) >> 2) & 0x7F);
      break;
    case 6u:
      result = sub_1001A450((int)&v2, *(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 7u:
      result = sub_1001A4C0(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 8u:
      result = sub_1001A3D0(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    default:
      result = 0xFFFFFF;
      break;
  }
  return result;
}

//----- (1001AC80) --------------------------------------------------------
double __cdecl sub_1001AC80(unsigned int a1)
{
  __int64 v2; // [sp-4h] [bp-64h]@0
  char v3; // [sp+7h] [bp-59h]@2
  float v4; // [sp+8h] [bp-58h]@1
  unsigned int v5; // [sp+Ch] [bp-54h]@2
  char v6; // [sp+10h] [bp-50h]@2
  float v7; // [sp+38h] [bp-28h]@4
  float v8; // [sp+48h] [bp-18h]@3

  v4 = 9.9999996e24;
  LODWORD(v2) = a1;
  if ( sub_1001BE80(v2) == 5 )
  {
    sub_10019AD0(a1, &v5, &v4, &v3);
    sub_1001A680(v5, SLOBYTE(v4), (int)&v6);
    if ( v3 )
    {
      v4 = v8;
      return v8;
    }
    v4 = v7;
  }
  return v4;
}

//----- (1001AD00) --------------------------------------------------------
double __cdecl sub_1001AD00(unsigned int a1)
{
  __int64 v2; // [sp-4h] [bp-64h]@0
  char v3; // [sp+7h] [bp-59h]@2
  float v4; // [sp+8h] [bp-58h]@1
  unsigned int v5; // [sp+Ch] [bp-54h]@2
  char v6; // [sp+10h] [bp-50h]@2
  float v7; // [sp+3Ch] [bp-24h]@4
  float v8; // [sp+4Ch] [bp-14h]@3

  v4 = 9.9999996e24;
  LODWORD(v2) = a1;
  if ( sub_1001BE80(v2) == 5 )
  {
    sub_10019AD0(a1, &v5, &v4, &v3);
    sub_1001A680(v5, SLOBYTE(v4), (int)&v6);
    if ( v3 )
    {
      v4 = v8;
      return v8;
    }
    v4 = v7;
  }
  return v4;
}

//----- (1001AD80) --------------------------------------------------------
double __cdecl sub_1001AD80(int a1)
{
  __int64 v1; // ST08_8@1
  int v2; // eax@1
  float v4; // [sp+0h] [bp-14h]@1
  char v5; // [sp+4h] [bp-10h]@2
  __int16 v6; // [sp+Eh] [bp-6h]@2

  LODWORD(v1) = a1;
  *((float *)&v1 + 1) = 6.2831855;
  v2 = sub_1001ABD0(v1);
  if ( v2 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v2, 15, &v5);
    v4 = (double)(signed __int16)((signed __int16)(v6 << 7) >> 7) * 0.01745329238474369 * 0.5;
  }
  return v4;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (1001ADF0) --------------------------------------------------------
int __cdecl sub_1001ADF0(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  __int16 v4; // ax@2
  signed int v5; // eax@4
  char v6; // bl@4
  __int64 v7; // [sp-4h] [bp-58h]@0
  char v8; // [sp+Eh] [bp-46h]@3
  char v9; // [sp+Fh] [bp-45h]@3
  int v10; // [sp+10h] [bp-44h]@3
  int v11; // [sp+14h] [bp-40h]@3
  int v12; // [sp+18h] [bp-3Ch]@3
  char v13; // [sp+1Ch] [bp-38h]@3
  char v14; // [sp+23h] [bp-31h]@12
  char v15; // [sp+24h] [bp-30h]@10

  *(_DWORD *)a2 = 1600085855;
  *(_WORD *)(a2 + 4) = 24415;
  LODWORD(v7) = a1;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_1001ABD0(v7);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = HIWORD(a1) >> 10;
    if ( HIWORD(a1) >> 10 == 5 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v3, 12, &v13);
      v10 = (unsigned __int16)word_101E3FE4 + v3;
      sub_10019DD0((unsigned int)&v9, (unsigned int *)&v12, &v8, (int)&v13, &v10, &v11);
      if ( (HIWORD(a1) & 0x3FCu) <= 0x1FC )
      {
        v6 = v9;
        v5 = v11;
      }
      else
      {
        v5 = v12;
        v6 = v8;
      }
      *(_BYTE *)a2 = 82;
      *(_BYTE *)(a2 + 1) = 87;
      if ( sub_1001E100(v5, 2, (_BYTE *)(a2 + 2)) )
      {
        *(_BYTE *)(a2 + 4) = v6;
        *(_BYTE *)(a2 + 6) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 2) = 1600085855;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
    else if ( v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v3, 9, &v13);
      sub_1001B340(&v15, 5, a2);
      *(_BYTE *)(a2 + 5) = 0;
    }
    else if ( v4 == 7 )
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101E37B8)(v3, 11, &v13);
      sub_1001B340(&v14, 3, a2);
      *(_BYTE *)(a2 + 3) = 0;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_101E37B8)(v3, 15, &v13);
      sub_1001B340(&v14, 4, a2);
      *(_BYTE *)(a2 + 4) = 0;
    }
    result = sub_1001E3A0(a2, 0);
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3FE4: using guessed type __int16 word_101E3FE4;

//----- (1001AF80) --------------------------------------------------------
char __cdecl sub_1001AF80(int a1, int a2)
{
  char v2; // bl@1
  int v3; // ebp@1
  int v4; // eax@2
  __int64 v6; // [sp-4h] [bp-30h]@0
  char v7; // [sp+10h] [bp-1Ch]@2
  unsigned int v8; // [sp+14h] [bp-18h]@2

  *(double *)a2 = 6.2831853071796;
  LODWORD(v6) = a1;
  *(double *)(a2 + 8) = 6.2831853071796;
  v2 = 0;
  v3 = sub_1001ABD0(v6);
  if ( v3 != 0xFFFFFF )
  {
    v4 = sub_1001BE50(a1 & 0x3FFFF);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v4, 28, &v7);
    v2 = (v8 >> 29) & 1;
    sub_1001A5C0(a2, a1, v3);
  }
  return v2;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (1001AFF0) --------------------------------------------------------
__int16 __cdecl sub_1001AFF0(int a1, int a2)
{
  int v2; // eax@1
  __int64 v4; // [sp-4h] [bp-Ch]@0

  LODWORD(v4) = a1;
  *(_DWORD *)a2 = 2147483648;
  *(_DWORD *)(a2 + 4) = 2147483648;
  v2 = sub_1001ABD0(v4);
  if ( v2 != 0xFFFFFF )
    LOWORD(v2) = sub_10019F90(v2, a2, a1);
  return v2;
}

//----- (1001B030) --------------------------------------------------------
signed int sub_1001B030()
{
  char v0; // bl@1
  double v1; // st7@2
  signed int result; // eax@4
  float v3; // [sp+8h] [bp-10h]@1
  float v4; // [sp+Ch] [bp-Ch]@1
  __int64 v5; // [sp+10h] [bp-8h]@4

  v0 = sub_10020250(&v4);
  v3 = sub_100202E0();
  if ( v0 && (v1 = v3, v3 < 3785.411865234375) && v4 > 0.0001051503277267329 )
  {
    v5 = (signed __int64)(v1 / v4);
    result = v5;
  }
  else
  {
    result = 0x7FFFFFFF;
  }
  return result;
}

//----- (1001B0C0) --------------------------------------------------------
int __cdecl sub_1001B0C0(unsigned __int16 a1, char a2, int a3)
{
  int result; // eax@1
  int v4; // ebp@1
  char v5; // cl@2
  signed int v6; // edi@2
  unsigned __int16 v7; // si@3
  int v8; // ecx@4
  char v9; // dl@5
  int v10; // esi@10
  int v11; // ecx@11
  __int16 v12; // dx@12
  char v13; // bl@13

  result = BMP_get_xfrm(a1);
  v4 = result;
  if ( a2 )
  {
    v5 = *(_BYTE *)(BMP_get_bm_def(a1) + 8);
    result = a3;
    v6 = 1 << v5;
    if ( v4 )
    {
      v10 = 0;
      if ( v6 > 0 )
      {
        v11 = 0;
        do
        {
          v12 = *(_WORD *)(v4 + 2 * v11);
          if ( (unsigned __int16)v12 < 0x100u )
          {
            v13 = byte_1010FCA0[(unsigned __int16)v12];
            if ( v13 != 127 )
              v12 = word_1010FC78[(unsigned __int8)byte_100716E0[(unsigned __int8)v13]];
          }
          ++v10;
          *(_WORD *)(a3 + 2 * v11) = v12;
          v11 = (unsigned __int16)v10;
        }
        while ( (unsigned __int16)v10 < v6 );
      }
    }
    else
    {
      v7 = 0;
      if ( v6 > 0 )
      {
        v8 = 0;
        do
        {
          v9 = byte_1010FCA0[v8];
          if ( v9 == 127 )
            *(_WORD *)(a3 + 2 * v8) = v7;
          else
            *(_WORD *)(a3 + 2 * v8) = word_1010FC78[(unsigned __int8)byte_100716E0[(unsigned __int8)v9]];
          v8 = ++v7;
        }
        while ( v7 < v6 );
      }
    }
  }
  return result;
}
// 100473C8: using guessed type int __cdecl BMP_get_bm_def(_DWORD);
// 100473D4: using guessed type int __cdecl BMP_get_xfrm(_DWORD);
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (1001B190) --------------------------------------------------------
int sub_1001B190()
{
  int v0; // ebx@1
  void *v1; // esi@1
  int result; // eax@2

  memset(byte_1010FCA0, 127, 0x100u);
  v0 = 0;
  v1 = &unk_100716A5;
  do
  {
    LOBYTE(result) = j_HWM_pvg_get_color(*((char *)v1 - 1), *(_BYTE *)v1, *((_BYTE *)v1 + 1));
    word_1010FC78[v0] = (unsigned __int8)result;
    result = (unsigned __int8)result;
    byte_1010FCA0[(unsigned __int8)result] = v0;
    v1 = (char *)v1 + 3;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)&unk_100716DE );
  return result;
}
// 10005510: using guessed type int __cdecl j_HWM_pvg_get_color(_DWORD, _DWORD, _DWORD);
// 1010FC78: using guessed type __int16 word_1010FC78[];

//----- (1001B1F0) --------------------------------------------------------
void sub_1001B1F0()
{
  dword_101E37A4 = -15;
}
// 101E37A4: using guessed type int dword_101E37A4;

//----- (1001B200) --------------------------------------------------------
signed int sub_1001B200()
{
  return sub_1005B6D0((int)&off_10071710);
}
// 10071710: using guessed type char *off_10071710;

//----- (1001B220) --------------------------------------------------------
bool sub_1001B220()
{
  return sub_10004EC0(47, 5000) == 0;
}

//----- (1001B250) --------------------------------------------------------
char __cdecl sub_1001B250(__int64 a1)
{
  char result; // al@5

  if ( (unsigned int)a1 < 0x3E8 || (_DWORD)a1 == 262141 )
  {
    result = 4;
  }
  else if ( (_DWORD)a1 == 0x3FFFF || (_DWORD)a1 == 262142 )
  {
    result = 9;
  }
  else
  {
    result = sub_1001BE80(a1);
  }
  return result;
}

//----- (1001B280) --------------------------------------------------------
double __cdecl sub_1001B280(float a1)
{
  unsigned int v1; // esi@1
  char v2; // al@1
  char v3; // al@2
  double result; // st7@2
  __int64 v5; // [sp-4h] [bp-20h]@0
  char v6; // [sp+4h] [bp-18h]@9
  char v7; // [sp+Ch] [bp-10h]@9

  v1 = LODWORD(a1);
  *(float *)&v5 = a1;
  v2 = sub_1001B250(v5);
  if ( v1 == 262141 )
  {
    v3 = sub_100061E0();
    a1 = sub_10005A70(v3);
    result = a1;
  }
  else
  {
    switch ( v2 )
    {
      case 9:
        a1 = 6.2831855;
        result = (float)6.2831855;
        break;
      case 8:
        a1 = sub_1001AD80(v1);
        result = a1;
        break;
      case 3:
        a1 = sub_1001C440(v1);
        result = a1;
        break;
      default:
        sub_10016600(0, v1, (double *)&v7);
        sub_100477B0((int)&v7, (int)&v6);
        sub_1001C890((int)&v6, &a1);
        result = a1;
        break;
    }
  }
  return result;
}

//----- (1001B340) --------------------------------------------------------
void __cdecl sub_1001B340(_BYTE *a1, signed int a2, int a3)
{
  signed int v3; // esi@1
  _BYTE *v4; // ecx@2
  unsigned int v5; // edx@2
  unsigned int v6; // eax@6
  unsigned __int16 v7; // ax@7
  char v8; // al@10

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = a1;
    v5 = a2;
    do
    {
      if ( v3 & 3 )
      {
        if ( (v3 & 3) == 1 )
        {
          v6 = v5 >> 4;
        }
        else
        {
          --v4;
          if ( (v3 & 3) == 2 )
          {
            HIBYTE(v7) = v4[1];
            LOBYTE(v7) = *v4;
            v5 = v7;
            v6 = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(v6) = v5;
          }
        }
      }
      else
      {
        BYTE1(v5) = *v4--;
        LOBYTE(v5) = *v4;
        v5 = (unsigned __int16)v5;
        LOWORD(v6) = (unsigned __int16)v5 >> 10;
      }
      v8 = v6 & 0x3F;
      if ( v8 )
      {
        if ( (unsigned __int8)(v8 - 1) > 0x19u )
        {
          if ( (unsigned __int8)(v8 - 32) <= 9u )
            v8 += 16;
        }
        else
        {
          v8 += 64;
        }
        *(_BYTE *)(v3 + a3) = v8;
      }
      else
      {
        *(_BYTE *)(v3 + a3) = 32;
      }
      ++v3;
    }
    while ( v3 < a2 );
  }
}

//----- (1001B3E0) --------------------------------------------------------
int __cdecl sub_1001B3E0(int a1, int a2, int a3, _BYTE *a4)
{
  __int16 v4; // ax@1
  int result; // eax@1
  int v6; // [sp+10h] [bp-10h]@1
  __int16 v7; // [sp+14h] [bp-Ch]@1
  __int16 v8; // [sp+16h] [bp-Ah]@1

  sub_10022C90((int)&v6, (_BYTE *)(a1 + 6), 8, (int)&v6);
  v4 = v7;
  *(_DWORD *)a2 = v6;
  *(_WORD *)(a2 + 4) = v4;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_1001E3A0(a2, 6);
  *(_WORD *)a3 = v8;
  *(_BYTE *)(a3 + 2) = 0;
  *a4 = *(_BYTE *)a1 & 0xF;
  return result;
}

//----- (1001B460) --------------------------------------------------------
unsigned int __cdecl sub_1001B460(unsigned int a1, _BYTE *a2, _BYTE *a3)
{
  unsigned int result; // eax@1

  *a2 = a1;
  result = a1 >> 8;
  *a3 = BYTE1(a1);
  return result;
}

//----- (1001B480) --------------------------------------------------------
unsigned int __cdecl sub_1001B480(const char *a1, int a2, signed int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // esi@2

  v6 = (a3 >> 24) + *(_WORD *)(a2 + 24) + ((a3 >> 16) & 0xFF) - *(_WORD *)(a2 + 26);
  v7 = 0;
  if ( v6 <= a4 )
  {
    v8 = v6 + a5;
    do
    {
      v6 += v8;
      ++v7;
    }
    while ( v6 <= a4 );
  }
  *a6 = v7;
  return strlen(a1) + 2 * (v7 - 1 <= 0 ? 0 : v7 - 1) + 1;
}

//----- (1001B4F0) --------------------------------------------------------
int __cdecl sub_1001B4F0(int a1, int a2, int a3, int a4, int a5, char a6, char *a7)
{
  char *v7; // eax@1
  char *v8; // esi@1
  char *v9; // edx@2
  char v10; // cl@3
  int v11; // ebx@7
  signed int v12; // edi@7
  signed int i; // edx@9
  int v14; // ebp@13
  int v15; // eax@13
  int v16; // ebp@13
  int v17; // edi@13
  char *v18; // eax@14
  char *v19; // ebp@14
  unsigned int v20; // eax@15
  int v21; // ebx@17
  int v22; // eax@17
  int v23; // edi@21
  int j; // ebp@21
  int v25; // ST14_4@22
  int v26; // ST0C_4@22
  char v27; // al@26
  int v28; // edi@29
  char v29; // al@32
  char v30; // al@40
  int v31; // edx@45
  int v32; // ecx@45
  int v33; // edi@55
  char *v34; // eax@58
  char v35; // dl@59
  int v36; // eax@61
  int v37; // edi@61
  int v38; // ecx@67
  char v39; // al@67
  char *v40; // edi@67
  char *v41; // eax@72
  int v42; // edx@72
  char v43; // cl@73
  _BYTE *v44; // ebp@74
  char *v45; // ST2C_4@78
  char v47; // [sp+13h] [bp-25h]@1
  int v48; // [sp+14h] [bp-24h]@14
  char *v49; // [sp+18h] [bp-20h]@26
  int v50; // [sp+1Ch] [bp-1Ch]@1
  signed int v51; // [sp+20h] [bp-18h]@7
  int v52; // [sp+24h] [bp-14h]@21
  int v53; // [sp+24h] [bp-14h]@26
  int v54; // [sp+28h] [bp-10h]@13
  int v55; // [sp+2Ch] [bp-Ch]@1
  signed int v56; // [sp+2Ch] [bp-Ch]@21
  int v57; // [sp+2Ch] [bp-Ch]@26
  int v58; // [sp+30h] [bp-8h]@29
  int v59; // [sp+34h] [bp-4h]@28

  v7 = (char *)a1;
  v8 = a7;
  v47 = 0;
  v55 = 0;
  v50 = 1;
  if ( a7 != (char *)a1 )
  {
    v9 = &a7[-a1];
    do
    {
      v10 = *v7;
      v7[(_DWORD)v9] = *v7;
      ++v7;
    }
    while ( v10 );
  }
  if ( a4 < 1 || a5 < 1 )
  {
    v47 = 1;
    v50 = 0;
    *v8 = 0;
  }
  v11 = a3;
  v12 = (((unsigned int)a3 >> 16) & 0x3F) - 1;
  v51 = v12;
  if ( v12 < 0 )
  {
    v12 = *(_WORD *)(a2 + 28);
    v51 = *(_WORD *)(a2 + 28);
  }
  for ( i = 0; i < (signed int)strlen(v8); ++i )
  {
    if ( v8[i] == 10 )
      ++v55;
  }
  LOWORD(a1) = 10;
  v14 = v12 + sub_10007120(a2, &a1, a3);
  v15 = sub_10007120(a2, v8, v11);
  v16 = v55 * v14;
  v17 = a5 * a4 - v16 - v15;
  v54 = a5 * a4 - v16 - v15;
  if ( v47 )
    return -1;
  while ( 1 )
  {
    v18 = strchr(v8, 10);
    v19 = v18;
    v48 = (int)v18;
    if ( v18 )
    {
      LOBYTE(a7) = 1;
      *v18 = 0;
    }
    else
    {
      LOBYTE(a7) = 0;
      v20 = strlen(v8);
      v19 = &v8[v20];
      v48 = (int)&v8[v20];
    }
    v21 = sub_10007120(a2, v8, a3);
    v22 = a4;
    if ( v21 > a4 )
    {
      if ( v50 >= a5 )
        goto LABEL_79;
      v52 = 0;
      v23 = a4;
      v56 = strlen(v8) - 1;
      for ( j = v56 / 2; ; j = (v56 + j + 1) / 2 )
      {
        while ( 1 )
        {
          v25 = a3;
          LOBYTE(a1) = v8[j + 1];
          v26 = a2;
          v8[j + 1] = 0;
          v21 = sub_10007120(v26, v8, v25);
          v8[j + 1] = a1;
          if ( v21 <= v23 )
            break;
          v56 = j;
          j = (v52 + j) / 2;
        }
        if ( v51 + v21 + sub_10007120(a2, &a1, a3) > v23 )
          break;
        v52 = j + 1;
      }
      v57 = v23 - v21;
      v49 = &v8[j];
      v27 = v8[j + 1];
      v53 = j;
      if ( v27 == 32 )
        goto LABEL_67;
      if ( !v27 )
        goto LABEL_67;
      v59 = v54 - v57;
      if ( v54 - v57 <= 0 )
        goto LABEL_67;
      v58 = 0;
      v28 = j;
      if ( j >= 0 )
      {
        while ( 1 )
        {
          if ( !isalnum((unsigned __int8)v8[v28]) || v8[v28] == 45 )
          {
            v29 = v8[v28];
            if ( v29 != 39 && v29 != 40 && v29 != 41 && v29 != 34 )
            {
              if ( v28 <= 0 )
                break;
              if ( v8[v28 - 1] != 32 )
              {
                if ( !isdigit((unsigned __int8)v8[v28 + 1]) || !isdigit((unsigned __int8)v8[v28 - 1]) )
                  break;
                v30 = v8[v28];
                if ( (v30 != 32 || v8[v28 + 2] != 47) && v30 != 47 )
                  break;
              }
            }
          }
          if ( --v28 < 0 )
            goto LABEL_48;
        }
        v31 = a3;
        LOBYTE(a1) = v49[1];
        v32 = a2;
        v49[1] = 0;
        v58 = v51 + sub_10007120(v32, &v8[v28 + 1], v31);
        v49[1] = a1;
        if ( v8[v28] == 32 && v28 > 0 )
          --v28;
      }
LABEL_48:
      if ( v28 == -1 || v28 == j || v58 > v59 )
      {
        if ( !isalpha((unsigned __int8)*v49) || !isalpha((unsigned __int8)v49[1]) || !a6 )
          goto LABEL_67;
        LOBYTE(a1) = 45;
        v33 = v51 + sub_10007120(a2, &a1, a3);
        if ( v33 + v21 <= a4 )
        {
          if ( (_BYTE)a7 )
            *(_BYTE *)v48 = 10;
          v34 = v49 + 1;
          do
            v35 = *v34++;
          while ( v35 );
          memcpy(v49 + 2, v49 + 1, v34 - (v49 + 2) + 1);
          v21 += v33;
          *(_BYTE *)(v48++ + 1) = 0;
          v49[1] = 45;
          v53 = j + 1;
          goto LABEL_67;
        }
        LOBYTE(a1) = *v49;
        v36 = v51 + sub_10007120(a2, &a1, a3);
        v37 = v21 + v33 - v36;
        if ( v37 > a4 || v59 < v36 )
        {
LABEL_67:
          v38 = v53;
          v54 -= v57;
          v39 = v8[v53 + 1];
          v40 = &v8[v53 + 1];
          if ( v39 )
          {
            if ( v39 == 32 )
              v38 = v53++ + 1;
            if ( (_BYTE)a7 )
              *(_BYTE *)v48 = 10;
            v40 = &v8[v38 + 1];
            v41 = &v8[v38 + 1];
            v42 = (int)&v8[v38 + 2];
            do
              v43 = *v41++;
            while ( v43 );
            memcpy(&v8[v53 + 2], v40, (size_t)&v41[-v42 + 1]);
            v44 = (_BYTE *)(v48 + 1);
            *v40 = 10;
            *(_BYTE *)(v48 + 1) = 0;
          }
          else
          {
            v44 = (_BYTE *)v48;
          }
          if ( (_BYTE)a7 )
          {
            LOBYTE(a7) = 0;
            *v44 = 10;
          }
          v22 = a4;
          v45 = v40;
          v17 = v54;
          v19 = v45;
          goto LABEL_79;
        }
        if ( (_BYTE)a7 )
          *(_BYTE *)v48 = 10;
        strcpy(v49 + 1, v49);
        *(_BYTE *)(v48++ + 1) = 0;
        *v49 = 45;
        v21 = v37;
      }
      else
      {
        v53 = v28;
        v21 -= v58;
      }
      v57 = a4 - v21;
      goto LABEL_67;
    }
    if ( !(_BYTE)a7 )
      return v50;
    v17 += v21 - a4;
    v54 = v17;
LABEL_79:
    if ( (_BYTE)a7 )
      *v19 = 10;
    if ( v50 >= a5 )
      break;
    if ( !*v19 )
      goto LABEL_85;
    ++v50;
    v8 = v19 + 1;
  }
  if ( *v19 )
  {
LABEL_86:
    *v19 = 0;
    return -1;
  }
LABEL_85:
  if ( v21 > v22 )
    goto LABEL_86;
  return v50;
}

//----- (1001BA80) --------------------------------------------------------
char __cdecl sub_1001BA80(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  char result; // al@1

  result = 0;
  if ( a2 != 0x3FFFF && a1 != -1 && a1 >= a3 && a1 <= a4 )
    result = 1;
  return result;
}

//----- (1001BAB0) --------------------------------------------------------
char __usercall sub_1001BAB0@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6)
{
  signed int v6; // esi@3
  int v7; // ebx@6
  int v8; // edi@6
  signed int v9; // esi@7
  __int64 v11; // [sp-Ch] [bp-14h]@6
  __int64 v12; // [sp-4h] [bp-Ch]@0

  *a5 = 0x3FFFF;
  *a6 = -1;
  if ( (_BYTE)a1 == -1 || a2 )
  {
    HIDWORD(v11) = a3;
    v7 = a2;
    v8 = (unsigned __int8)a1;
    if ( a2 >= (signed int)(unsigned __int8)a1 )
    {
      while ( 1 )
      {
        a1 = sub_100192C0(a4, v7);
        v9 = a1;
        if ( a1 != 0x3FFFF )
        {
          LODWORD(v11) = a1;
          LOBYTE(a1) = sub_1001BE80(v11);
          if ( !(_BYTE)a1 )
            break;
        }
        if ( --v7 < v8 )
          return a1;
      }
      LOBYTE(a1) = (_BYTE)a5;
      *a6 = v7;
      *a5 = v9;
    }
  }
  else
  {
    a1 = sub_100192C0(a4, 0);
    v6 = a1;
    if ( a1 != 0x3FFFF )
    {
      LODWORD(v12) = a1;
      LOBYTE(a1) = sub_1001BE80(v12);
      if ( !(_BYTE)a1 )
      {
        LOBYTE(a1) = (_BYTE)a6;
        *a6 = 0;
        *a5 = v6;
      }
    }
  }
  return a1;
}
// 1001BAB0: could not find valid save-restore pair for edi

//----- (1001BB50) --------------------------------------------------------
char __usercall sub_1001BB50@<al>(int a1@<ebx>, _BYTE *a2, int *a3)
{
  int v3; // ebp@1
  signed int v4; // esi@1
  int *v5; // esi@4
  _BYTE *v6; // edi@4
  signed int v7; // eax@4
  char v8; // bl@5
  unsigned __int8 v9; // dl@15
  char v10; // cl@20
  unsigned __int8 v11; // cl@26
  unsigned __int8 v13; // [sp-10h] [bp-38h]@23
  signed int *v14; // [sp-Ch] [bp-34h]@23
  __int64 v15; // [sp-8h] [bp-30h]@5
  _BYTE *v16; // [sp-8h] [bp-30h]@23
  char v17; // [sp+Ch] [bp-1Ch]@1
  char v18; // [sp+Dh] [bp-1Bh]@1
  char v19; // [sp+Eh] [bp-1Ah]@2
  char v20; // [sp+Fh] [bp-19h]@15
  int v21; // [sp+10h] [bp-18h]@1
  unsigned __int8 v22; // [sp+14h] [bp-14h]@1
  int v23; // [sp+18h] [bp-10h]@5
  unsigned __int8 v24; // [sp+1Ch] [bp-Ch]@1
  unsigned __int8 v25; // [sp+20h] [bp-8h]@1
  unsigned __int8 v26; // [sp+24h] [bp-4h]@1
  char v27; // [sp+2Ch] [bp+4h]@5
  unsigned __int8 v28; // [sp+30h] [bp+8h]@5
  char v29; // [sp+30h] [bp+8h]@15

  v18 = sub_10019280(0);
  v25 = sub_100194A0(0);
  v26 = sub_10019520(0);
  v3 = sub_10019240(0);
  v24 = sub_100194E0(0);
  v22 = sub_10019560(0);
  v4 = sub_10019320(0);
  v21 = v4;
  v17 = sub_100195A0(0);
  if ( v3 != 0x3FFFF || (v19 = 0, v4 != 0x3FFFF) )
    v19 = 1;
  v5 = a3;
  v6 = a2;
  *a3 = 0x3FFFF;
  *a2 = -1;
  LOBYTE(v7) = sub_10020BD0();
  if ( (_BYTE)v7 )
  {
    HIDWORD(v15) = a1;
    sub_10021020();
    v8 = *(_BYTE *)(dword_101E741C + 812);
    v27 = *(_BYTE *)(dword_101E741C + 816);
    v23 = *(_DWORD *)(dword_101E741C + 840);
    v28 = v8;
    if ( (unsigned __int8)v8 >= 0x66u && v8 != -1 )
    {
      v8 = -1;
      v28 = -1;
    }
    if ( ((unsigned __int8)v8 > (unsigned __int8)v18
       || *(_BYTE *)(dword_101E7410 + 4) != v18
       || *(_DWORD *)(dword_101E7410 + 264) != v3
       || *(_DWORD *)(dword_101E7410 + 604) != v21)
      && *(_BYTE *)(dword_101E741C + 816) != 3 )
    {
      v8 = -1;
      v28 = -1;
    }
    LOBYTE(v7) = sub_10021010();
    if ( v8 != -1 )
    {
      v29 = sub_1001BA80(v28, v3, v25, v26);
      LOBYTE(v7) = sub_1001BA80(v9, v21, v24, v22);
      v20 = v7;
      if ( v27 == 3 )
      {
        LODWORD(v15) = v23;
        if ( !sub_1001BE80(v15) )
        {
          LOBYTE(v7) = v23;
          *v5 = v23;
          *v6 = v8;
          return v7;
        }
        LOBYTE(v7) = v20;
LABEL_29:
        if ( v29 == 1 )
        {
          LOBYTE(v7) = v17;
          if ( (unsigned __int8)v8 > (unsigned __int8)v17 )
          {
            v11 = v26;
LABEL_37:
            v16 = v6;
            v14 = v5;
            LOBYTE(v7) = v8;
            v13 = 0;
            goto LABEL_38;
          }
          *v5 = v3;
          *v6 = v17;
          goto LABEL_39;
        }
LABEL_33:
        if ( (_BYTE)v7 == 1 )
        {
          if ( v3 == 0x3FFFF )
          {
            v11 = v22;
            goto LABEL_37;
          }
          *v5 = v3;
          *v6 = v17;
        }
LABEL_39:
        if ( v27 != 3 && *v5 == 0x3FFFF && *v6 == -1 )
        {
          if ( v3 == 0x3FFFF )
          {
            LOBYTE(v7) = v21;
            if ( v21 != 0x3FFFF )
            {
              *v5 = v21;
              LOBYTE(v7) = v22;
              *v6 = v22;
            }
          }
          else
          {
            *v5 = v3;
            *v6 = v17;
          }
        }
        return v7;
      }
      if ( v27 != 2 && v27 != 1 )
        goto LABEL_29;
      v10 = v18;
      if ( !v18 || v29 )
        goto LABEL_29;
      if ( (_BYTE)v7 )
        goto LABEL_33;
      v16 = v6;
      v14 = v5;
      LOBYTE(v7) = v8;
      v13 = 0;
      if ( v19 == 1 )
      {
        if ( v21 == 0x3FFFF )
        {
          v11 = v25 - 1;
          goto LABEL_38;
        }
        v10 = v24;
      }
      v11 = v10 - 1;
LABEL_38:
      LOBYTE(v7) = sub_1001BAB0(v7, v11, (int)v6, v13, v14, v16);
      goto LABEL_39;
    }
  }
  return v7;
}
// 1001BB50: could not find valid save-restore pair for ebx
// 101E7410: using guessed type int dword_101E7410;
// 101E741C: using guessed type int dword_101E741C;

//----- (1001BDA0) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001BDA0(unsigned int a1)
{
  unsigned __int8 result; // al@1

  result = 0;
  do
  {
    if ( a1 < *(_DWORD *)(dword_101E4110 + 4 * result + 20816) )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}
// 101E4110: using guessed type int dword_101E4110;

//----- (1001BDD0) --------------------------------------------------------
int __cdecl sub_1001BDD0(unsigned int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // esi@2
  char v4; // bl@4
  int result; // eax@5

  if ( a2 >= 4u )
  {
    result = 0xFFFFFF;
  }
  else
  {
    v3 = a1;
    if ( a3 )
      v3 = a1 - *(_DWORD *)(dword_101E4110 + 4 * a2 + 20812);
    v4 = byte_10072E80[12 * a2];
    if ( sub_10020040(v3, (unsigned __int8)byte_10072E80[12 * a2]) )
      result = dword_101E38C0[3 * (unsigned __int8)v4] + v3 * (unsigned __int16)word_101E38C4[6 * (unsigned __int8)v4];
    else
      result = 0xFFFFFF;
  }
  return result;
}
// 101E38C0: using guessed type int dword_101E38C0[];
// 101E38C4: using guessed type __int16 word_101E38C4[];
// 101E4110: using guessed type int dword_101E4110;

//----- (1001BE50) --------------------------------------------------------
int __cdecl sub_1001BE50(unsigned int a1)
{
  unsigned __int8 v1; // ST14_1@1

  v1 = sub_1001BDA0(a1);
  return sub_1001BDD0(a1, v1, 1);
}

//----- (1001BE80) --------------------------------------------------------
char __cdecl sub_1001BE80(__int64 a1)
{
  char v1; // bl@1
  char result; // al@3
  unsigned __int16 v3; // ax@7

  v1 = 9;
  if ( (unsigned int)a1 < 0x3E8 )
  {
LABEL_13:
    result = v1;
  }
  else
  {
    switch ( sub_1001BDA0(a1) )
    {
      case 0u:
        result = 0;
        break;
      case 1u:
        result = 1;
        break;
      case 2u:
        result = 2;
        break;
      case 3u:
        result = 3;
        break;
      default:
        v3 = WORD1(a1) >> 10;
        if ( (unsigned __int16)(WORD1(a1) >> 10) >= 0xBu && v3 < 0xDu
          || v3 >= 5u && v3 <= 8u && (unsigned __int16)(a1 - 1000) < (unsigned int)sub_10020080(8u) )
        {
          v1 = (*(_DWORD *)((char *)&a1 + 2) >> 10) & 0x3F;
        }
        goto LABEL_13;
    }
  }
  return result;
}

//----- (1001BF20) --------------------------------------------------------
double __cdecl sub_1001BF20(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-28h]@0
  float v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@2
  int v6; // [sp+12h] [bp-12h]@2

  v4 = 9.9999996e24;
  LODWORD(v3) = a1;
  if ( !sub_1001BE80(v3) )
  {
    v1 = sub_1001BE50(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v1, 28, &v5);
    v4 = (double)((v6 & 0x7FFF) - 5000) * 0.3048000037670135;
  }
  return v4;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (1001BF90) --------------------------------------------------------
char __usercall sub_1001BF90@<al>(unsigned __int16 a1@<ax>, void *a2)
{
  unsigned __int16 v2; // si@1
  char result; // al@4

  v2 = a1;
  if ( (unsigned __int8)sub_1001B200() && v2 < 0x3E8u && *(_WORD *)(dword_101E37A4 + 56 * v2 + 880428) == v2 )
  {
    qmemcpy(a2, (const void *)(dword_101E37A4 + 56 * (v2 + 15721)), 0x38u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E37A4: using guessed type int dword_101E37A4;

//----- (1001BFF0) --------------------------------------------------------
int __usercall sub_1001BFF0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(double *)result = (double)*(signed int *)a2 * 0.000000001462918079267163;
  *(double *)(result + 8) = 0.000000001462918079267163 * (double)*(signed int *)(a2 + 4);
  return result;
}

//----- (1001C010) --------------------------------------------------------
int __cdecl sub_1001C010(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+8h] [bp-38h]@3

  sub_10004EC0(58, 60000);
  if ( sub_1001BF90(a1, &v3) )
  {
    sub_1001B340(&v4, 6, a2);
    sub_1001E3A0(a2, 6);
  }
  else
  {
    *(_DWORD *)a2 = 1600085855;
    *(_WORD *)(a2 + 4) = 24415;
    *(_BYTE *)(a2 + 6) = 0;
  }
  return sub_10004EA0(58);
}

//----- (1001C0A0) --------------------------------------------------------
int __cdecl sub_1001C0A0(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+Ch] [bp-34h]@3

  sub_10004EC0(58, 60000);
  if ( sub_1001BF90(a1, &v3) )
  {
    sub_1001BFF0(a2, (int)&v4);
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
  }
  return sub_10004EA0(58);
}

//----- (1001C110) --------------------------------------------------------
char *__cdecl sub_1001C110(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_101E38C0[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_101E38C8];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_101E38C4];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_101E38C8];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_101E37B8)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E38C0: using guessed type int dword_101E38C0[];
// 101E38C4: using guessed type __int16 word_101E38C4[];
// 101E38C8: using guessed type int dword_101E38C8[];
// 1001C110: using guessed type char var_20[28];

//----- (1001C1D0) --------------------------------------------------------
signed int sub_1001C1D0()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_101E37BC = 0;
  dword_101E37C0 = 0xFFFFFF;
  byte_101E37AC = 0;
  dword_101E37B0 = 0xFFFFFF;
  return result;
}
// 101E37AC: using guessed type char byte_101E37AC;
// 101E37B0: using guessed type int dword_101E37B0;
// 101E37BC: using guessed type char byte_101E37BC;
// 101E37C0: using guessed type int dword_101E37C0;

//----- (1001C1F0) --------------------------------------------------------
int sub_1001C1F0()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_101E37B8 + 16))();
  byte_101E37B4 = (_BYTE)result == 0;
  return result;
}
// 101E37B4: using guessed type char byte_101E37B4;
// 101E37B8: using guessed type int dword_101E37B8;

//----- (1001C250) --------------------------------------------------------
int sub_1001C250()
{
  int result; // eax@1

  *(_DWORD *)(dword_101E4110 + 20812) = 1000;
  *(_DWORD *)(dword_101E4110 + 20816) = dword_101E3928 + *(_DWORD *)(dword_101E4110 + 20812);
  *(_DWORD *)(dword_101E4110 + 20820) = dword_101E3988 + *(_DWORD *)(dword_101E4110 + 20816);
  *(_DWORD *)(dword_101E4110 + 20824) = dword_101E39B8 + *(_DWORD *)(dword_101E4110 + 20820);
  result = dword_101E4110;
  *(_DWORD *)(dword_101E4110 + 20828) = dword_101E3A00 + *(_DWORD *)(dword_101E4110 + 20824);
  return result;
}
// 101E3928: using guessed type int dword_101E3928;
// 101E3988: using guessed type int dword_101E3988;
// 101E39B8: using guessed type int dword_101E39B8;
// 101E3A00: using guessed type int dword_101E3A00;
// 101E4110: using guessed type int dword_101E4110;

//----- (1001C2C0) --------------------------------------------------------
char *sub_1001C2C0()
{
  sub_1001C110(0x40u);
  sub_1001C110(0x39u);
  sub_1001C110(0x33u);
  sub_1001C110(0x31u);
  sub_1001C110(0x32u);
  sub_1001C110(0x4Eu);
  sub_1001C110(0x4Fu);
  sub_1001C110(0x3Du);
  sub_1001C110(0x3Eu);
  sub_1001C110(0x45u);
  return sub_1001C110(0x38u);
}
// 101E4110: using guessed type int dword_101E4110;

//----- (1001C390) --------------------------------------------------------
int __cdecl sub_1001C390(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_10115208, a1, 0x1Cu);
  dword_101E37B8 = (int)dword_10115208;
  dword_101E4110 = (int)&unk_10115228;
  memset(&unk_10115228, 0, 0x516Cu);
  dword_10115208[5](dword_101E4110 + 20832, dword_101E4110 + 20833, dword_101E4110 + 20836);
  (*(void (__cdecl **)(int))(dword_101E37B8 + 24))(dword_101E4110 + 20840);
  sub_10023090();
  sub_10022B60();
  sub_10022ED0();
  sub_10022C30();
  sub_1001C2C0();
  sub_1001C1D0();
  sub_1001CE10();
  sub_1001C530();
  sub_1001C1F0();
  sub_1001C250();
  *(_DWORD *)(dword_101E4110 + 20800) = 0;
  *(_DWORD *)(dword_101E4110 + 20804) = dword_101E3AA8;
  result = dword_101E4110;
  *(_DWORD *)(dword_101E4110 + 20808) = dword_101E3AB4 + *(_DWORD *)(dword_101E4110 + 20804);
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3AA8: using guessed type int dword_101E3AA8;
// 101E3AB4: using guessed type int dword_101E3AB4;
// 101E4110: using guessed type int dword_101E4110;

//----- (1001C440) --------------------------------------------------------
double __cdecl sub_1001C440(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-44h]@0
  float v4; // [sp+4h] [bp-3Ch]@1
  char v5; // [sp+8h] [bp-38h]@5
  char v6; // [sp+10h] [bp-30h]@5
  char v7; // [sp+20h] [bp-20h]@2
  unsigned int v8; // [sp+24h] [bp-1Ch]@2
  int v9; // [sp+2Eh] [bp-12h]@4

  v4 = 6.2831855;
  LODWORD(v3) = a1;
  if ( sub_1001BE80(v3) == 3 )
  {
    v1 = sub_1001BE50(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v1, 29, &v7);
    if ( v8 >> 29 != 2 && v8 >> 29 != 6 )
      return (float)((double)(v9 >> 23) * 0.01745329238474369 * 0.5);
    sub_100199B0(a1, (int)&v6);
    sub_100477B0((int)&v6, (int)&v5);
    sub_1001C890((int)&v5, &v4);
  }
  return v4;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (1001C4F0) --------------------------------------------------------
int __cdecl sub_1001C4F0(unsigned __int8 a1)
{
  int v1; // eax@3
  bool v2; // zf@3
  int result; // eax@3

  if ( a1 >= 0x67u
    || !(unsigned __int8)sub_1001B200()
    || (v1 = 8524 * a1, v2 = a1 == *(_BYTE *)(v1 + dword_101E37A4 + 2004), result = v1 + dword_101E37A4 + 2004, !v2) )
  {
    result = 0;
  }
  return result;
}
// 101E37A4: using guessed type int dword_101E37A4;

//----- (1001C530) --------------------------------------------------------
int sub_1001C530()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_10020040(0x4Du, 1u) )
  {
    result = dword_101E3C5C;
    dword_1011A428 = dword_101E3C5C;
    if ( dword_101E3C5C )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_101E37B8)(dword_101E3C5C, 8, &v1);
      word_1011A420 = v1;
      result = v3 & 0x1FF;
      dword_1011A428 += (unsigned __int16)word_101E3C60;
      word_1011A424 = v2 & 0x1FF;
      word_1011A41C = v3 & 0x1FF;
    }
  }
  else
  {
    word_1011A420 = 6;
    word_1011A424 = 6;
    result = dword_101E3ADC;
    word_1011A41C = 60;
    dword_1011A428 = dword_101E3ADC;
  }
  return result;
}
// 1011A41C: using guessed type __int16 word_1011A41C;
// 1011A420: using guessed type __int16 word_1011A420;
// 1011A424: using guessed type __int16 word_1011A424;
// 1011A428: using guessed type int dword_1011A428;
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3ADC: using guessed type int dword_101E3ADC;
// 101E3C5C: using guessed type int dword_101E3C5C;
// 101E3C60: using guessed type __int16 word_101E3C60;

//----- (1001C5D0) --------------------------------------------------------
char __cdecl sub_1001C5D0(float *a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char v3; // bl@1
  char v4; // al@1
  float v5; // ST44_4@4
  double v6; // st6@4
  signed __int16 v7; // si@4
  signed int v8; // eax@4
  signed __int16 v9; // di@4
  float v10; // ST44_4@7
  __int16 v11; // cx@8
  __int16 v12; // ax@8
  signed int v13; // edi@8
  __int16 v14; // bp@8
  int v15; // esi@8
  __int16 v16; // bx@8
  signed int v17; // esi@8
  int *v18; // edi@8
  signed int v19; // ecx@10
  __int64 v20; // rax@11
  __int16 v21; // si@16
  float v23; // [sp+Ch] [bp-1Ch]@8
  float v24; // [sp+10h] [bp-18h]@4
  float v25; // [sp+10h] [bp-18h]@8
  int v26; // [sp+18h] [bp-10h]@8
  int v27; // [sp+1Ch] [bp-Ch]@8

  *a1 = 0.0;
  v2 = v1;
  v3 = 0;
  v4 = sub_10023370(v1, 0);
  if ( dword_1011A428 && v4 && sub_10020040(0, 0x2Du) )
  {
    v24 = (*(float *)v2 + 1.570796370506287) * 57.29578018188477;
    v5 = 57.29578018188477 * (*(float *)(v2 + 4) + 3.141592741012573);
    v6 = v5;
    v7 = (signed int)v24;
    v8 = (signed int)v5;
    v9 = v8;
    if ( v7 > 179 )
      v7 = 179;
    if ( v9 >= 360 )
    {
      v9 = v8 - 360;
      v10 = v6 - 360.0;
      v6 = v10;
    }
    v11 = v7 / word_1011A420;
    v12 = v9 / word_1011A424;
    v13 = (signed __int16)(v7 / word_1011A420);
    v14 = v7 / word_1011A420 + 1;
    v23 = v24 / (double)word_1011A420 - (double)v13;
    v15 = v12;
    v25 = v6 / (double)word_1011A424 - (double)v12;
    v16 = (v12 + 1) % word_1011A41C;
    (*(void (__cdecl **)(int, signed int, int *))dword_101E37B8)(
      dword_1011A428 + (unsigned __int16)word_101E3AE0 * (v12 + v11 * word_1011A41C),
      2,
      &v26);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(
      dword_1011A428 + (unsigned __int16)word_101E3AE0 * (v16 + v13 * word_1011A41C),
      2,
      (char *)&v26 + 2);
    (*(void (__cdecl **)(int, signed int, int *))dword_101E37B8)(
      dword_1011A428 + (unsigned __int16)word_101E3AE0 * (v15 + v14 * word_1011A41C),
      2,
      &v27);
    (*(void (__cdecl **)(int, _DWORD, char *))dword_101E37B8)(
      dword_1011A428 + (unsigned __int16)word_101E3AE0 * (v16 + v14 * word_1011A41C),
      2,
      (char *)&v27 + 2);
    v3 = 1;
    v17 = 1;
    v18 = &v26;
    do
    {
      if ( !v3 )
        break;
      v19 = v17;
      if ( v17 < 4 )
      {
        while ( 1 )
        {
          v20 = (signed __int16)(*(_WORD *)v18 - *((_WORD *)&v26 + v19));
          if ( (signed int)((HIDWORD(v20) ^ v20) - HIDWORD(v20)) > 1820 )
            break;
          if ( ++v19 >= 4 )
            goto LABEL_15;
        }
        v3 = 0;
      }
LABEL_15:
      ++v17;
      v18 = (int *)((char *)v18 + 2);
    }
    while ( v17 - 1 < 3 );
    v21 = v26 + (signed int)((double)(signed __int16)(v27 - v26) * v23);
    *a1 = (double)(signed __int16)(v21
                                 + (signed int)((double)(signed __int16)(HIWORD(v26)
                                                                       + (signed int)(v23
                                                                                    * (double)(signed __int16)(HIWORD(v27) - HIWORD(v26)))
                                                                       - v21)
                                              * v25))
        * 0.0000958738019107841;
  }
  return v3;
}
// 1011A41C: using guessed type __int16 word_1011A41C;
// 1011A420: using guessed type __int16 word_1011A420;
// 1011A424: using guessed type __int16 word_1011A424;
// 1011A428: using guessed type int dword_1011A428;
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3AE0: using guessed type __int16 word_101E3AE0;

//----- (1001C890) --------------------------------------------------------
char __cdecl sub_1001C890(int a1, float *a2)
{
  return sub_1001C5D0(a2);
}

//----- (1001C8B0) --------------------------------------------------------
void __cdecl sub_1001C8B0(unsigned int a1, int a2)
{
  unsigned int v2; // ebx@3
  unsigned int v3; // ebp@4
  unsigned int v4; // eax@5
  int v5; // ecx@5
  int v6; // eax@6
  char v7; // dl@10
  char v8; // cl@10
  char v9; // al@10
  char v10; // cl@11
  char v11; // dl@11
  char v12; // dl@13
  char v13; // cl@13
  char v14; // al@13
  char v15; // cl@14
  char v16; // dl@14
  char v17; // cl@14
  char v18; // [sp+4h] [bp-10h]@5
  char v19; // [sp+5h] [bp-Fh]@10
  char v20; // [sp+6h] [bp-Eh]@10
  char v21; // [sp+8h] [bp-Ch]@5
  char v22; // [sp+Ah] [bp-Ah]@10
  char v23; // [sp+Bh] [bp-9h]@10

  if ( a2 )
  {
    if ( (a1 & 0xFC000000) != 805306368 || (v2 = a1 & 0x1FF, v2 > 0x168) || (v3 = (a1 >> 9) & 0x1FF, v3 > 0x168) )
    {
      *(_DWORD *)a2 = *(_DWORD *)"______";
      *(_WORD *)(a2 + 4) = *(_WORD *)"__";
      *(_BYTE *)(a2 + 6) = a______[6];
    }
    else
    {
      sub_1001E330(&v18, 4u, "%+03d", (signed int)(v2 - 180) / 2);
      sub_1001E330(&v21, 5u, "%+04d", v3 - 180);
      v4 = (v3 - 180) >> 31;
      v5 = (v3 - 180 - v4) ^ ((signed int)(v3 - 180 - v4) >> 31);
      if ( v2 < 0xB4 )
      {
        LOBYTE(v4) = v3 < 0xB4;
        v6 = 4 * v4 + 83;
      }
      else
      {
        LOBYTE(v6) = v3 < 0xB4 ? 78 : 69;
      }
      *(_BYTE *)(a2 + 5) = 0;
      if ( a1 & 1 )
      {
        if ( v5 >= 100 )
        {
          v10 = v22;
          *(_BYTE *)a2 = v19;
          v11 = v23;
          *(_BYTE *)(a2 + 1) = v6;
          *(_BYTE *)(a2 + 2) = v20;
          *(_BYTE *)(a2 + 3) = v10;
          *(_BYTE *)(a2 + 4) = v11;
        }
        else
        {
          v7 = v20;
          *(_BYTE *)(a2 + 1) = v19;
          v8 = v23;
          *(_BYTE *)a2 = v6;
          v9 = v22;
          *(_BYTE *)(a2 + 2) = v7;
          *(_BYTE *)(a2 + 3) = v9;
          *(_BYTE *)(a2 + 4) = v8;
        }
      }
      else if ( v5 < 100 )
      {
        v15 = v20;
        *(_BYTE *)a2 = v19;
        v16 = v22;
        *(_BYTE *)(a2 + 1) = v15;
        v17 = v23;
        *(_BYTE *)(a2 + 2) = v16;
        *(_BYTE *)(a2 + 3) = v17;
        *(_BYTE *)(a2 + 4) = v6;
      }
      else
      {
        v12 = v20;
        *(_BYTE *)a2 = v19;
        v13 = v23;
        *(_BYTE *)(a2 + 2) = v6;
        v14 = v22;
        *(_BYTE *)(a2 + 1) = v12;
        *(_BYTE *)(a2 + 3) = v14;
        *(_BYTE *)(a2 + 4) = v13;
      }
    }
  }
}

//----- (1001CA90) --------------------------------------------------------
char __cdecl sub_1001CA90(unsigned int a1, int a2)
{
  char result; // al@1
  unsigned int v3; // edx@3
  unsigned int v4; // ecx@4

  result = 0;
  if ( a2 )
  {
    if ( (a1 & 0xFC000000) == 805306368 )
    {
      v3 = a1 & 0x1FF;
      if ( v3 <= 0x168 )
      {
        v4 = (a1 >> 9) & 0x1FF;
        if ( v4 <= 0x168 )
        {
          *(_DWORD *)a2 = (signed int)(11930464 * (v3 - 180)) / 2;
          *(_DWORD *)(a2 + 4) = 11930464 * (v4 - 180);
          result = 1;
        }
      }
    }
  }
  return result;
}

//----- (1001CB00) --------------------------------------------------------
int __cdecl sub_1001CB00(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_10020080(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (1001CB30) --------------------------------------------------------
int sub_1001CB30()
{
  return (*(int (**)(void))(dword_101E37B8 + 8))();
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (1001CB40) --------------------------------------------------------
int __fastcall sub_1001CB40(unsigned __int8 a1)
{
  return dword_101E3AC4 + a1 * (unsigned __int16)word_101E3AC8;
}
// 101E3AC4: using guessed type int dword_101E3AC4;
// 101E3AC8: using guessed type __int16 word_101E3AC8;

//----- (1001CB60) --------------------------------------------------------
int __fastcall sub_1001CB60(unsigned __int8 a1)
{
  return dword_101E3AD0 + a1 * (unsigned __int16)word_101E3AD4;
}
// 101E3AD0: using guessed type int dword_101E3AD0;
// 101E3AD4: using guessed type __int16 word_101E3AD4;

//----- (1001CB80) --------------------------------------------------------
void *__cdecl sub_1001CB80(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_1001CB00(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_1001CB40(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_101E37B8)(v3, 22, &v7);
      result = (void *)sub_10022C90(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (1001CC50) --------------------------------------------------------
int __cdecl sub_1001CC50(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_1001CB40(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(v2, 22, &v22);
    sub_10022C90((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_1001CB60(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_101E37B8)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_10022C90((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_101E37B8 + 12))(a1);
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (1001CE10) --------------------------------------------------------
char sub_1001CE10()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_1001CB30();
  sub_1001CB00(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_1001CB80(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_10020080(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_1001CB80(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_1001CC50((int)&v8);
  }
  return v0;
}

//----- (1001CF70) --------------------------------------------------------
_DWORD *__cdecl sub_1001CF70(_DWORD *a1)
{
  _DWORD *result; // eax@1

  result = a1;
  *a1 = 0;
  return result;
}

//----- (1001CF80) --------------------------------------------------------
int __cdecl sub_1001CF80(int *a1, int a2)
{
  int result; // eax@1
  int i; // esi@1

  result = (int)a1;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    result = (*(int (__cdecl **)(int, int))i)(i, a2);
  return result;
}

//----- (1001CFB0) --------------------------------------------------------
_DWORD *__cdecl sub_1001CFB0(_DWORD *a1, int a2)
{
  _DWORD *result; // eax@1

  result = a1;
  *(_DWORD *)(a2 + 4) = *a1;
  *a1 = a2;
  return result;
}

//----- (1001CFC0) --------------------------------------------------------
char __cdecl sub_1001CFC0(int a1, int a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( **(_WORD **)(a1 + 52) == -32744 || !a2 || *(_BYTE *)(a2 + a3) & 2 )
    result = 1;
  return result;
}

//----- (1001CFF0) --------------------------------------------------------
char __cdecl sub_1001CFF0(int a1, _WORD *a2, int a3)
{
  char result; // al@1

  result = 0;
  if ( *a2 == -32665 || !*(_BYTE *)(a1 + 5) && a3 && *(_DWORD *)(a1 + 48) == a3 )
    result = 1;
  return result;
}

//----- (1001D020) --------------------------------------------------------
__int16 __cdecl sub_1001D020(unsigned int a1)
{
  return word_100758E4[(a1 >> 17) & 0xF];
}
// 100758E4: using guessed type __int16 word_100758E4[];

//----- (1001D040) --------------------------------------------------------
bool __cdecl sub_1001D040(char *a1, int *a2, _DWORD *a3)
{
  int v3; // ecx@1
  bool v4; // zf@1
  int v5; // eax@2

  v3 = *(_DWORD *)a1 & 0xFF;
  v4 = v3 == 141;
  if ( v3 != 141 )
  {
    v5 = (int)&a1[dword_101E32A4[8 * v3]];
    if ( a2 )
      *a2 = v5;
    if ( a3 )
      *a3 = v5 + 4;
    v4 = v3 == 141;
  }
  return !v4;
}

//----- (1001D090) --------------------------------------------------------
char __cdecl sub_1001D090(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebp@3
  signed int v5; // ebx@3
  char result; // al@3
  _WORD *v7; // ST2C_4@6

  v3 = a2;
  if ( !a2 )
    sub_10004C50("..\\lib\\adl\\cdp_fld_utl.c", 323, 1, a2);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = (unsigned __int8)v3[230];
  result = 1;
  if ( (*(_BYTE *)(v4 + 26) || v4 != *(_DWORD *)(a1 + 48)) && v5 < (unsigned __int8)v3[68] )
  {
    v7 = (_WORD *)a3;
    *(_DWORD *)(a1 + 56) = v3;
    *(_BYTE *)(a1 + 3) = sub_1001CFF0(a1, v7, (int)v3);
    sub_1001D040(*(char **)(*((_DWORD *)v3 + 14) + 4 * v5), (int *)&a2, 0);
    sub_100012C0(a1, (int)v3);
    result = ((int (__cdecl *)(int, _DWORD, char *, _DWORD, int))dword_101E32A0[2
                                                                              * (**(_DWORD **)(*((_DWORD *)v3 + 14)
                                                                                             + 4 * v5) & 0xFF)])(
               a1,
               *(_DWORD *)(*((_DWORD *)v3 + 14) + 4 * v5),
               a2,
               *(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5),
               a3);
    *(_DWORD *)(a1 + 56) = v4;
    *(_BYTE *)(a1 + 3) = 0;
  }
  return result;
}
// 101E32A0: using guessed type int dword_101E32A0[];

//----- (1001D140) --------------------------------------------------------
int __cdecl sub_1001D140(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  char v4; // [sp+4h] [bp-68h]@3

  v1 = sub_1001E3C0(&a1, 4u, (int)&unk_10075F28, 8, 20, -1);
  v2 = v1;
  if ( v1 < 0 || (unsigned int)v1 >= 0x14 )
  {
    sprintf(&v4, "UNKNOWN EVENT %lu\n", a1);
    sub_10004C50(".\\cdp_evnt_map.c", 328, 1, &v4);
  }
  return (int)*(&off_10075F2C + 2 * v2);
}
// 10075F2C: using guessed type void *off_10075F2C;

//----- (1001D1C0) --------------------------------------------------------
void sub_1001D1C0()
{
  float v0; // ST00_4@1

  v0 = sub_1001EBF0();
  sub_1005C310(v0);
}
// 1001EBF0: using guessed type double sub_1001EBF0(void);

//----- (1001D1E0) --------------------------------------------------------
char __thiscall sub_1001D1E0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 12;
  sub_100051A0(3000, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001D210) --------------------------------------------------------
char __thiscall sub_1001D210(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( sub_10005070(3137, (int)&v2 + 3, 1) )
  {
    sub_100054D0(86, (_BYTE *)&v2 + 3);
    sub_10005140(3137, (int)&v2 + 3, 1);
  }
  return BYTE3(v2);
}

//----- (1001D250) --------------------------------------------------------
char __thiscall sub_1001D250(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 30;
  sub_100051A0(3001, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001D280) --------------------------------------------------------
char __fastcall sub_1001D280(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_100054D0(3, (_BYTE *)&v2 + 2);
  BYTE2(v2) = byte_10076635[2 * sub_1001E3C0((int *)((char *)&v2 + 2), 1u, (int)&unk_10076634, 2, 5, -1)];
  if ( sub_10005070(3002, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10005160(3002, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1001D2F0) --------------------------------------------------------
char __thiscall sub_1001D2F0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_100051A0(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001D320) --------------------------------------------------------
char __fastcall sub_1001D320(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_100054D0(3, (_BYTE *)&v2 + 2);
  if ( sub_10005070(3003, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10005160(3003, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1001D370) --------------------------------------------------------
char sub_1001D370()
{
  return 18;
}

//----- (1001D380) --------------------------------------------------------
char __thiscall sub_1001D380(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 18;
  sub_100051A0(3005, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001D3B0) --------------------------------------------------------
char __thiscall sub_1001D3B0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 23;
  sub_100051A0(3006, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001D3E0) --------------------------------------------------------
char __fastcall sub_1001D3E0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_100054D0(5, (_BYTE *)&v2 + 2);
  if ( sub_10005070(3007, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10005160(3007, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1001D430) --------------------------------------------------------
char __thiscall sub_1001D430(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_100051A0(3011, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001D460) --------------------------------------------------------
char __thiscall sub_1001D460(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_100051A0(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001D490) --------------------------------------------------------
int sub_1001D490()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_100051A0(3012, &v2, 4, &v1);
  return v2;
}

//----- (1001D4C0) --------------------------------------------------------
char __thiscall sub_1001D4C0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 11;
  sub_100051A0(3009, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1001D4F0) --------------------------------------------------------
char __fastcall sub_1001D4F0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_100054D0(42, (_BYTE *)&v2 + 2);
  if ( sub_10005070(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10005160(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1001D540) --------------------------------------------------------
char __cdecl sub_1001D540(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047B2E: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);

//----- (1001D560) --------------------------------------------------------
int __cdecl sub_1001D560(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10004C50("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10004C50("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 10047B34: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (1001D5C0) --------------------------------------------------------
int __cdecl sub_1001D5C0(char *a1, char *a2)
{
  sub_1001D560(0, a1);
  return sub_1001D560(2, a2);
}

//----- (1001D5E0) --------------------------------------------------------
char __thiscall sub_1001D5E0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1001D560(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001D600) --------------------------------------------------------
int __thiscall sub_1001D600(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1001D560(29, (char *)&v2);
  return (int)v2;
}

//----- (1001D620) --------------------------------------------------------
char __thiscall sub_1001D620(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1001D560(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001D640) --------------------------------------------------------
char __thiscall sub_1001D640(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1001D560(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001D660) --------------------------------------------------------
char sub_1001D660()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 0;
  sub_1001D560(48, &v1);
  return v1;
}

//----- (1001D680) --------------------------------------------------------
int __cdecl sub_1001D680(char a1)
{
  return sub_1001D560(56, &a1);
}

//----- (1001D690) --------------------------------------------------------
char __cdecl sub_1001D690(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1001D6D0) --------------------------------------------------------
char __cdecl sub_1001D6D0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10004C50("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1001D740) --------------------------------------------------------
signed int __cdecl sub_1001D740(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10004C50("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1001D7C0) --------------------------------------------------------
char __cdecl sub_1001D7C0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10004C50("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1001D830) --------------------------------------------------------
char __cdecl sub_1001D830(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10004C50("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1001D8E0) --------------------------------------------------------
char __cdecl sub_1001D8E0(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10004C50("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1001D9E0) --------------------------------------------------------
char __thiscall sub_1001D9E0(void *this)
{
  int v1; // eax@1

  v1 = sub_1001FF60(this);
  return sub_1001D8E0(v1);
}

//----- (1001D9F0) --------------------------------------------------------
int __cdecl sub_1001D9F0(int *a1)
{
  int result; // eax@1

  result = sub_100273A0((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_10004DF0();
    result = sub_100271E0();
  }
  return result;
}

//----- (1001DA20) --------------------------------------------------------
char __usercall sub_1001DA20@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_10004EC0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_10028460("%i %i\r\n", 13, v2);
    sub_10027A00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_10004EA0(*(_DWORD *)(a1 + 4));
    v6 = sub_10028460("%i %i\r\n", 14, v5);
    sub_10027A00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_100770FC, (int)v6);
    result = 1;
  }
  else
  {
    sub_10004C50(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (1001DAC0) --------------------------------------------------------
int __cdecl sub_1001DAC0(const char *a1)
{
  int result; // eax@1

  result = sub_10025500();
  if ( a1 )
    result = sub_100273D0(dword_1011A434[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 1011A434: using guessed type int dword_1011A434[];

//----- (1001DB00) --------------------------------------------------------
char __cdecl sub_1001DB00(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_10027320((char *)a1 + 4);
  v1 = sub_1002DD80();
  sub_100272C0((int)v1, 0, 0);
  dword_1011A434[sub_10025500()] = (int)a1;
  v2 = sub_1002DD40((int)sub_1001DAC0);
  return sub_100273F0(v2);
}
// 1011A434: using guessed type int dword_1011A434[];

//----- (1001DB50) --------------------------------------------------------
signed int __cdecl sub_1001DB50(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_10004DF0();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10004F40(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_10004DF0() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10004FD0(&v23);
          }
          while ( sub_10004DF0() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_10004DD0(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10004E10((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_10028460("The %s task is loaded.", &v24);
            sub_10027A00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_10028460("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10027A00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_10028460("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10027A00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_10028460(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10027A00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10004D60(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_10028460("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10027A00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_10028460("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10027A00(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10027A00(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_10004E50(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_1002DD40((int)sub_1001DAC0);
        sub_10027AD0((int)v15);
        v16 = sub_1002F120((int)sub_1001DAC0);
        sub_10027AD0((int)v16);
        v17 = sub_1002F120((int)sub_1001DAC0);
        sub_100273F0(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_1002DD40((int)sub_1001DAC0);
        sub_10027AD0((int)v18);
        v19 = sub_1002F120((int)sub_1001DAC0);
        sub_10027AD0((int)v19);
        v20 = sub_1002DD40((int)sub_1001DAC0);
        sub_100273F0(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_1001DA20(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (1001DEF0) --------------------------------------------------------
char **sub_1001DEF0()
{
  return off_100770E8;
}
// 100770E8: using guessed type char *off_100770E8[3];

//----- (1001DF10) --------------------------------------------------------
int __cdecl sub_1001DF10(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1011A448 = a1;
  return result;
}
// 1011A448: using guessed type int dword_1011A448;

//----- (1001DF20) --------------------------------------------------------
int __cdecl sub_1001DF20(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1011A44C = a1;
  return result;
}
// 1011A44C: using guessed type int dword_1011A44C;

//----- (1001DF30) --------------------------------------------------------
#error "1001DF35: call analysis failed (funcsize=28)"

//----- (1001DF60) --------------------------------------------------------
char __cdecl sub_1001DF60(char a1, unsigned __int16 a2, char a3)
{
  char result; // al@1

  result = a1;
  do
    result += a3;
  while ( !(a2 & (unsigned __int16)word_10078810[(unsigned __int8)result]) && result != a1 );
  return result;
}
// 10078810: using guessed type __int16 word_10078810[];

//----- (1001DF90) --------------------------------------------------------
bool __cdecl sub_1001DF90(float a1, int a2, int a3, int a4)
{
  int v4; // edi@2
  int v5; // esi@3
  int v6; // ecx@8
  unsigned int v7; // eax@9
  float v8; // ST14_4@10
  float v9; // ST14_4@10
  float v10; // ST14_4@10
  float v11; // ST14_4@10
  float v12; // ST14_4@10
  float v13; // ST14_4@10
  float v14; // ST14_4@10
  int v15; // eax@12
  float v16; // ST14_4@14
  signed int v17; // ebx@14
  bool result; // al@19
  int v19; // [sp+8h] [bp-8h]@5

  if ( a4 && (v4 = a3, a3 <= 9) && (v5 = a2, a2 > 0) && a3 <= a2 - 2 )
  {
    v19 = 0;
    if ( a1 < 0.0 )
    {
      v4 = a3 - 1;
      a1 = fabs(a1);
      *(_BYTE *)a4 = 45;
      v19 = 1;
      if ( a3 == 1 )
        v4 = -1;
    }
    v6 = 0;
    if ( v4 >= 8 )
    {
      v7 = ((unsigned int)(v4 - 8) >> 3) + 1;
      v6 = 8 * v7;
      do
      {
        --v7;
        v8 = a1 * 10.0;
        v9 = v8 * 10.0;
        v10 = v9 * 10.0;
        v11 = v10 * 10.0;
        v12 = v11 * 10.0;
        v13 = v12 * 10.0;
        v14 = v13 * 10.0;
        a1 = v14 * 10.0;
      }
      while ( v7 );
    }
    if ( v6 < v4 )
    {
      v15 = v4 - v6;
      do
      {
        --v15;
        a1 = a1 * 10.0;
      }
      while ( v15 );
    }
    v16 = a1 + 0.5;
    v17 = (signed int)v16;
    if ( a2 > v19 )
    {
      do
      {
        if ( --v5 == a2 - v4 - 1 )
        {
          *(_BYTE *)(v5 + a4) = 46;
        }
        else
        {
          *(_BYTE *)(v5 + a4) = v17 % 10 + 48;
          v17 /= 10;
        }
      }
      while ( v5 > v19 );
    }
    result = v17 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001E100) --------------------------------------------------------
bool __cdecl sub_1001E100(signed int a1, signed int a2, _BYTE *a3)
{
  bool result; // al@2
  signed int v4; // ebx@3
  signed int v5; // edi@3
  signed int i; // esi@5

  if ( a3 )
  {
    v4 = a1;
    v5 = 0;
    if ( a1 < 0 )
    {
      v4 = -a1;
      *a3 = 45;
      v5 = 1;
    }
    for ( i = a2; i > v5; v4 /= 10 )
      a3[--i] = v4 % 10 + 48;
    result = v4 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001E170) --------------------------------------------------------
void __cdecl sub_1001E170(const char *a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax@2

  if ( a1 )
  {
    v3 = strlen(a1);
    if ( v3 < a2 )
      memset((void *)&a1[v3], a3, a2 - v3);
    a1[a2] = 0;
  }
}

//----- (1001E1C0) --------------------------------------------------------
void __cdecl sub_1001E1C0(const char *a1, char a2, char a3)
{
  unsigned int v3; // esi@4
  unsigned int v4; // ecx@4

  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        v3 = strlen(a1);
        v4 = 0;
        if ( v3 )
        {
          do
          {
            if ( a1[v4] == a2 )
              a1[v4] = a3;
            ++v4;
          }
          while ( v4 < v3 );
        }
      }
    }
  }
}

//----- (1001E210) --------------------------------------------------------
int __cdecl sub_1001E210(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (1001E260) --------------------------------------------------------
int __cdecl sub_1001E260(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (1001E290) --------------------------------------------------------
int __cdecl sub_1001E290(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (1001E2F0) --------------------------------------------------------
int __cdecl sub_1001E2F0(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1001E330) --------------------------------------------------------
int sub_1001E330(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_1001E2F0(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (1001E360) --------------------------------------------------------
int __cdecl sub_1001E360(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_1001E210((int)&a1[v3], a2, a3 - v3);
}

//----- (1001E3A0) --------------------------------------------------------
int __cdecl sub_1001E3A0(int a1, int a2)
{
  return sub_1001E290(a1, "_ ", a2);
}

//----- (1001E3C0) --------------------------------------------------------
int __cdecl sub_1001E3C0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (1001E550) --------------------------------------------------------
int __cdecl sub_1001E550(_DWORD *a1, unsigned int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int result; // eax@1
  int v7; // ebx@1
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  unsigned int v21; // edx@23
  char *i; // ecx@23
  int v23; // [sp+20h] [bp+14h]@1

  v5 = a5;
  result = a5 - 1;
  v7 = a3 + a4 * (a5 - 1);
  v23 = a5 - 1;
  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && v5 > 0 )
  {
    if ( result > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v23;
        if ( v20 )
        {
          v7 -= a4;
          result = v23 - 1;
          v23 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a2;
    for ( i = (char *)v7; v21 >= 4; i += 4 )
    {
      if ( *(_DWORD *)&i[(_DWORD)a1 - v7] != *(_DWORD *)i )
        break;
      v21 -= 4;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001E670) --------------------------------------------------------
signed int sub_1001E670()
{
  signed int result; // eax@3

  if ( (unsigned __int8)byte_1011A450 > 2u )
    sub_10004C50("..\\lib\\adl\\iop_ap_intf.c", 958, 0, 0);
  result = (unsigned __int8)byte_1011A450;
  if ( (unsigned __int8)byte_1011A450 >= 2u )
    result = 2;
  byte_1011A450 = result;
  return result;
}
// 1011A450: using guessed type char byte_1011A450;

//----- (1001E6B0) --------------------------------------------------------
char __thiscall sub_1001E6B0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10005110(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (1001E6D0) --------------------------------------------------------
char __cdecl sub_1001E6D0(char a1)
{
  char result; // al@2
  char v2; // [sp+2h] [bp-2h]@1
  char v3; // [sp+3h] [bp-1h]@1

  v3 = 1;
  v2 = 1;
  if ( a1 )
  {
    sub_100050D0(9420, &v2, 1, &v3);
    result = v2;
  }
  else
  {
    sub_100050D0(9419, &v2, 1, &v3);
    result = v2;
  }
  return result;
}

//----- (1001E720) --------------------------------------------------------
char sub_1001E720()
{
  char v1; // [sp+2h] [bp-2h]@1
  char v2; // [sp+3h] [bp-1h]@1

  v2 = 0;
  v1 = 0;
  sub_100050D0(9155, &v1, 1, &v2);
  return v1;
}

//----- (1001E750) --------------------------------------------------------
char __thiscall sub_1001E750(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_100054D0(78, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1001E770) --------------------------------------------------------
char __thiscall sub_1001E770(void *this)
{
  char result; // al@3
  unsigned int v2; // [sp-2h] [bp-4h]@1

  v2 = (unsigned int)this;
  if ( sub_1001F8E0(1, 43, (char *)&v2 + 3) && !sub_10023620((unsigned __int8 *)&v2 + 3) )
    result = BYTE3(v2);
  else
    result = 0;
  return result;
}

//----- (1001E7B0) --------------------------------------------------------
char sub_1001E7B0()
{
  char v1; // [sp+2h] [bp-2h]@1
  char v2; // [sp+3h] [bp-1h]@1

  v1 = 0;
  v2 = 0;
  sub_100050D0(6888, &v1, 1, &v2);
  return v1;
}

//----- (1001E7E0) --------------------------------------------------------
char sub_1001E7E0()
{
  char result; // al@1

  byte_1011A450 = 2;
  result = sub_1001FE70(4);
  if ( result )
  {
    byte_1011A450 = 0;
  }
  else
  {
    result = sub_1001FE70(7);
    if ( result )
      byte_1011A450 = 1;
  }
  return result;
}
// 1011A450: using guessed type char byte_1011A450;

//----- (1001E820) --------------------------------------------------------
double __cdecl sub_1001E820(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_10023210(v1);
  if ( sub_1001E6B0(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_10005110(2015, (int)&v5, 12);
      return v6;
    }
    sub_10005110(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_10005110(2015, (int)&v5, 12);
      return v6;
    }
    sub_10005110(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (1001E8A0) --------------------------------------------------------
int __cdecl sub_1001E8A0(unsigned __int8 a1)
{
  void *v1; // ecx@0

  return dword_100798A0[(unsigned __int8)sub_10023210(v1) + 2 * a1];
}
// 100798A0: using guessed type int dword_100798A0[];

//----- (1001E8C0) --------------------------------------------------------
bool __usercall sub_1001E8C0@<al>(int a1@<esi>)
{
  signed int v1; // edx@1
  signed int v2; // eax@1
  void *v3; // ecx@5
  int v4; // eax@7
  int v5; // eax@9
  int v6; // edx@11
  bool v7; // zf@13

  v1 = 0x20000000;
  v2 = 178956970;
  if ( *(_BYTE *)(a1 + 1) )
    v1 = 357913941;
  if ( *(_BYTE *)(a1 + 2) )
    v2 = 0x20000000;
  v3 = *(void **)(a1 + 8);
  if ( (signed int)v3 >= v2 )
    v3 = (void *)v2;
  v4 = -v2;
  *(_DWORD *)(a1 + 8) = v3;
  if ( (signed int)v3 > v4 )
    v4 = (int)v3;
  *(_DWORD *)(a1 + 8) = v4;
  v5 = *(_DWORD *)(a1 + 4);
  if ( v5 >= v1 )
    v5 = v1;
  v6 = -v1;
  *(_DWORD *)(a1 + 4) = v5;
  if ( v5 <= v6 )
    v5 = v6;
  v7 = *(_BYTE *)a1 == 0;
  *(_DWORD *)(a1 + 4) = v5;
  return v7 && sub_1001FF60(v3) & *(_DWORD *)(a1 + 24);
}

//----- (1001E930) --------------------------------------------------------
bool __usercall sub_1001E930@<al>(int a1@<eax>)
{
  signed int v1; // eax@17
  bool result; // al@19

  result = 0;
  if ( *(_BYTE *)(a1 + 2) < 3u
    && *(_BYTE *)(a1 + 10) < 3u
    && *(_BYTE *)a1 < 8u
    && *(_BYTE *)(a1 + 1) < 0xBu
    && *(_BYTE *)(a1 + 3) < 0xFu
    && *(_BYTE *)(a1 + 4) < 0xDu
    && *(_BYTE *)(a1 + 5) < 6u
    && *(_BYTE *)(a1 + 24) < 0xDu
    && *(_BYTE *)(a1 + 6) < 7u
    && *(_BYTE *)(a1 + 25) < 0xDu
    && *(_BYTE *)(a1 + 7) < 0xEu
    && *(_BYTE *)(a1 + 8) < 0xDu
    && *(_BYTE *)(a1 + 9) < 8u
    && *(_BYTE *)(a1 + 26) < 0xDu
    && *(_BYTE *)(a1 + 11) < 0x13u
    && *(_BYTE *)(a1 + 12) < 0xDu )
  {
    v1 = *(_DWORD *)(a1 + 20);
    if ( v1 >= 0 && v1 <= 357913941 )
      result = 1;
  }
  return result;
}

//----- (1001E9A0) --------------------------------------------------------
char __cdecl sub_1001E9A0(char *a1)
{
  char *v1; // edi@1
  char v2; // bl@1
  signed int v3; // ebp@1
  char *v4; // esi@1
  char v5; // al@2
  bool v6; // al@4
  char result; // al@13
  char v8; // dh@15
  bool v9; // al@16
  bool v10; // bl@20
  void *v11; // ecx@22
  char v12; // al@23
  int v13; // eax@23
  __int16 v14; // [sp+10h] [bp-88h]@1
  int v15; // [sp+14h] [bp-84h]@1
  char *v16; // [sp+18h] [bp-80h]@1
  char v17; // [sp+1Ch] [bp-7Ch]@27
  char v18; // [sp+20h] [bp-78h]@16
  char v19; // [sp+3Eh] [bp-5Ah]@29
  char v20; // [sp+58h] [bp-40h]@1
  char v21; // [sp+5Ch] [bp-3Ch]@19
  char v22; // [sp+7Ah] [bp-1Eh]@31

  v16 = a1;
  v15 = 3342386;
  v1 = 0;
  v2 = sub_1001E670();
  v14 = 0;
  v3 = 1;
  v4 = &v20;
  do
  {
    v5 = sub_1001F8E0(1, *((_WORD *)&v15 + v3), v4);
    *((_BYTE *)&v14 + v3) = v5;
    v6 = v5 && !sub_100251D0((unsigned __int8 *)v4);
    *((_BYTE *)&v14 + v3) = v6;
    if ( v6 && *v4 == v2 )
      v1 = v4;
    --v3;
    v4 -= 60;
  }
  while ( v3 >= 0 );
  if ( !v1 )
    return 0;
  if ( v2 )
  {
    if ( v2 != 1 )
      return 0;
    goto LABEL_34;
  }
  v8 = HIBYTE(v14);
  if ( !(_BYTE)v14 || (v9 = sub_1001E930((int)&v18), LOBYTE(v14) = 1, !v9) )
    LOBYTE(v14) = 0;
  v10 = v8 && sub_1001E930((int)&v21);
  if ( sub_1001E7B0() )
  {
    v12 = sub_10023210(v11);
    LOBYTE(v15) = v12;
    v13 = (unsigned __int8)sub_1001E6D0(v12) - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0;
      goto LABEL_32;
    }
    if ( !(_BYTE)v14 )
      return 0;
LABEL_27:
    result = 1;
    qmemcpy(v16, &v17, 0x3Cu);
    return result;
  }
  if ( (_BYTE)v14 && (v19 || !v10 || !v22) )
    goto LABEL_27;
LABEL_32:
  if ( !v10 )
    return 0;
  v1 = &v20;
LABEL_34:
  result = 1;
  qmemcpy(v16, v1, 0x3Cu);
  return result;
}

//----- (1001EB20) --------------------------------------------------------
char __cdecl sub_1001EB20(void *a1)
{
  char v1; // al@1
  void *v2; // ecx@2
  char v3; // ST10_1@3
  int v4; // eax@3
  int v5; // eax@4
  char v6; // al@6
  char v8; // [sp+8h] [bp-40h]@7
  unsigned __int8 v9; // [sp+16h] [bp-32h]@8

  v1 = sub_1001E670();
  if ( v1 )
  {
    if ( v1 != 1 || !sub_1001F8E0(1, 52, a1) )
      return 0;
    goto LABEL_15;
  }
  if ( sub_1001E7B0() )
  {
    v3 = sub_10023210(v2);
    v4 = (unsigned __int8)sub_1001E6D0(v3);
  }
  else
  {
    if ( !sub_1001E9A0(&v8) )
      return 0;
    v4 = v9;
  }
  v5 = v4 - 1;
  if ( !v5 )
  {
    v6 = sub_1001F8E0(1, 52, a1);
    goto LABEL_10;
  }
  if ( v5 != 1 )
    return 0;
  v6 = sub_1001F8E0(1, 53, a1);
LABEL_10:
  if ( !v6 || !sub_1001E8C0((int)a1) )
    return 0;
LABEL_15:
  if ( sub_10024C90((int)a1) )
    return 0;
  return 1;
}

//----- (1001EBF0) --------------------------------------------------------
void sub_1001EBF0()
{
  sub_1001E820(0);
}

//----- (1001EC00) --------------------------------------------------------
char __fastcall sub_1001EC00(int a1)
{
  int v1; // eax@1
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = a1;
  HIWORD(v3) = 0;
  v1 = sub_1001E8A0(0);
  sub_100050D0(v1, (char *)&v3 + 2, 1, (char *)&v3 + 3);
  result = BYTE2(v3);
  if ( BYTE2(v3) >= 3u )
    result = 0;
  return result;
}

//----- (1001EC40) --------------------------------------------------------
int __cdecl sub_1001EC40(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1007A75C[a1];
  return result;
}
// 1007A75C: using guessed type __int16 word_1007A75C[];

//----- (1001EC60) --------------------------------------------------------
signed int sub_1001EC60()
{
  signed int result; // eax@1

  result = -15;
  dword_1011A470 = -15;
  dword_1011A47C = -15;
  dword_1011A458 = -15;
  dword_1011A480 = -15;
  dword_1011A46C = -15;
  dword_1011A45C = -15;
  dword_1011A454 = -15;
  dword_1011A468 = -15;
  dword_1011A478 = -15;
  dword_1011A474 = -15;
  dword_1011A464 = -15;
  dword_1011A460 = -15;
  return result;
}
// 1011A454: using guessed type int dword_1011A454;
// 1011A458: using guessed type int dword_1011A458;
// 1011A45C: using guessed type int dword_1011A45C;
// 1011A460: using guessed type int dword_1011A460;
// 1011A464: using guessed type int dword_1011A464;
// 1011A468: using guessed type int dword_1011A468;
// 1011A46C: using guessed type int dword_1011A46C;
// 1011A470: using guessed type int dword_1011A470;
// 1011A474: using guessed type int dword_1011A474;
// 1011A478: using guessed type int dword_1011A478;
// 1011A47C: using guessed type int dword_1011A47C;
// 1011A480: using guessed type int dword_1011A480;

//----- (1001ECB0) --------------------------------------------------------
signed int __usercall sub_1001ECB0@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_1005B6D0((int)&off_1007A77C);
      break;
    case 0:
      result = sub_1005B6D0((int)&off_1007A790);
      break;
    case 1:
      result = sub_1005B6D0((int)&off_1007A7A4);
      break;
    case 2:
      result = sub_1005B6D0((int)&off_1007A7CC);
      break;
    case 3:
      result = sub_1005B6D0((int)&off_1007A7B8);
      break;
    case 5:
      result = sub_1005B6D0((int)&off_1007A7E0);
      break;
    default:
      result = sub_1005B6D0(a2);
      break;
  }
  return result;
}
// 1007A77C: using guessed type char *off_1007A77C;
// 1007A790: using guessed type char *off_1007A790;
// 1007A7A4: using guessed type char *off_1007A7A4;
// 1007A7B8: using guessed type char *off_1007A7B8;
// 1007A7CC: using guessed type char *off_1007A7CC;
// 1007A7E0: using guessed type char *off_1007A7E0;

//----- (1001ED50) --------------------------------------------------------
int __usercall sub_1001ED50@<eax>(char a1@<al>)
{
  return sub_10004EA0(dword_1007A2AC[a1]);
}
// 1007A2AC: using guessed type int dword_1007A2AC[];

//----- (1001ED70) --------------------------------------------------------
int __usercall sub_1001ED70@<eax>(char a1@<al>)
{
  return sub_10004EC0(dword_1007A2AC[a1], 10);
}
// 1007A2AC: using guessed type int dword_1007A2AC[];

//----- (1001ED90) --------------------------------------------------------
signed __int16 __usercall sub_1001ED90@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_1001ECB0(a1, a1) )
        {
          sub_10004C50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_1011A470 + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_32;
      }
      sub_10004C50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10004C50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_1001ECB0(a1, a1) )
      {
        result = *(_WORD *)(dword_1011A47C + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_1001D540(15000) )
        goto LABEL_6;
      sub_10004C50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10004C50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1001ECB0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_1011A458 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10004C50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1001ECB0(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_1011A480 + 2 * a2 + 356016);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10004C50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_1001ECB0(a1, a1) )
      {
        sub_10004C50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_1011A46C + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_1001ECB0(a1, a1) )
        {
          result = *(_WORD *)(dword_1011A45C + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 1011A458: using guessed type int dword_1011A458;
// 1011A45C: using guessed type int dword_1011A45C;
// 1011A46C: using guessed type int dword_1011A46C;
// 1011A470: using guessed type int dword_1011A470;
// 1011A47C: using guessed type int dword_1011A47C;
// 1011A480: using guessed type int dword_1011A480;

//----- (1001EFD0) --------------------------------------------------------
char __cdecl sub_1001EFD0(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_1001ED90(a1, a2);
  if ( v3 != -1 && !sub_1001ED70(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1011A470);
        sub_1001ED50(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1011A47C);
        sub_1001ED50(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_1011A458;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1011A480);
        sub_1001ED50(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_1011A46C);
        sub_1001ED50(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_1011A45C;
LABEL_16:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_1001ED50(a1);
        return 1;
      default:
LABEL_17:
        sub_1001ED50(a1);
        break;
    }
  }
  return 0;
}
// 1011A458: using guessed type int dword_1011A458;
// 1011A45C: using guessed type int dword_1011A45C;
// 1011A46C: using guessed type int dword_1011A46C;
// 1011A470: using guessed type int dword_1011A470;
// 1011A47C: using guessed type int dword_1011A47C;
// 1011A480: using guessed type int dword_1011A480;

//----- (1001F130) --------------------------------------------------------
char __cdecl sub_1001F130(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_1001ED90(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1001ECB0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011A470 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_1001ECB0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011A47C + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_1001ECB0(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011A458 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_1001ECB0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011A480 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_1001ECB0(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011A46C + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_1001ECB0(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_1011A45C + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 1011A458: using guessed type int dword_1011A458;
// 1011A45C: using guessed type int dword_1011A45C;
// 1011A46C: using guessed type int dword_1011A46C;
// 1011A470: using guessed type int dword_1011A470;
// 1011A47C: using guessed type int dword_1011A47C;
// 1011A480: using guessed type int dword_1011A480;

//----- (1001F2B0) --------------------------------------------------------
char __cdecl sub_1001F2B0(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_1001ED90(a1, a2);
  if ( v3 != -1 && !sub_1001ED70(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011A470 + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011A47C + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011A458 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011A480 + 24 * ((unsigned __int16)v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011A46C + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_1001ECB0(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_1011A45C + 24 * (unsigned __int16)v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_1001ED50(a1);
        return 1;
      default:
LABEL_17:
        sub_1001ED50(a1);
        break;
    }
  }
  return 0;
}
// 1011A458: using guessed type int dword_1011A458;
// 1011A45C: using guessed type int dword_1011A45C;
// 1011A46C: using guessed type int dword_1011A46C;
// 1011A470: using guessed type int dword_1011A470;
// 1011A47C: using guessed type int dword_1011A47C;
// 1011A480: using guessed type int dword_1011A480;

//----- (1001F410) --------------------------------------------------------
char __cdecl sub_1001F410(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_1001ECB0(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_1001ED90(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_1001F130(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy_0(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_10004DF0();
      v13 = 0;
      LOBYTE(v7) = sub_100300B0(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (1001F550) --------------------------------------------------------
char __cdecl sub_1001F550(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_1001ED90(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_100300B0(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (1001F630) --------------------------------------------------------
char __cdecl sub_1001F630(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10004DF0();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_1001ED90(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_1001ECB0(a1, v7) )
            goto LABEL_30;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_1011A470 + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_1011A470 + 210116;
          v12 = dword_1011A470 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_1001ECB0(a1, v7) )
            goto LABEL_30;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_1011A47C + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_1011A47C + 257156;
          v12 = dword_1011A47C + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_1001ECB0(a1, v7) )
            goto LABEL_30;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_1011A458 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_1011A458 + 321708;
          v12 = dword_1011A458 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_1001ECB0(a1, v7) )
            goto LABEL_30;
          v16 = 3 * (unsigned __int16)v8 + 72;
          v10 = dword_1011A480 + 14328;
          v11 = 52 * (unsigned __int16)v8 + dword_1011A480 + 326220;
          v12 = dword_1011A480 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_1001ECB0(a1, v7) )
            goto LABEL_30;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_1011A46C + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_1011A46C + 18832;
          v12 = dword_1011A46C + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_1001ECB0(a1, v7) )
            goto LABEL_30;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_1011A45C + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_1011A45C + 1596;
          v12 = dword_1011A45C + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_1001ED70(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy_0(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_1001ED50(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1011A454: using guessed type int dword_1011A454;
// 1011A458: using guessed type int dword_1011A458;
// 1011A45C: using guessed type int dword_1011A45C;
// 1011A468: using guessed type int dword_1011A468;
// 1011A46C: using guessed type int dword_1011A46C;
// 1011A470: using guessed type int dword_1011A470;
// 1011A478: using guessed type int dword_1011A478;
// 1011A47C: using guessed type int dword_1011A47C;
// 1011A480: using guessed type int dword_1011A480;

//----- (1001F8B0) --------------------------------------------------------
char __cdecl sub_1001F8B0(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_1001F630(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (1001F8E0) --------------------------------------------------------
char __cdecl sub_1001F8E0(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_1001F630(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (1001F910) --------------------------------------------------------
char __cdecl sub_1001F910(char a1, int a2, void *a3, int a4)
{
  return sub_1001F630(a1, a2, 0, 0, a3, a4);
}

//----- (1001F940) --------------------------------------------------------
char __cdecl sub_1001F940(unsigned __int8 a1, _BYTE *a2)
{
  char result; // al@1
  char v3; // [sp+4h] [bp-58h]@1
  char v4[82]; // [sp+6h] [bp-56h]@2

  result = sub_1001F8E0(2, 361, &v3);
  if ( result )
    *a2 = v4[4 * a1];
  return result;
}
// 1001F940: using guessed type char var_56[82];

//----- (1001F990) --------------------------------------------------------
bool __cdecl sub_1001F990(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_10030640(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_1001EC40(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_1001F8E0(v5[0], v6, a2) && !sub_100301F0(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (1001FA10) --------------------------------------------------------
char __cdecl sub_1001FA10(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_10030640(a1, 0, &v4, &v3) != 1 && sub_10030640(a1, 1u, &v4, &v3) != 1
    || (result = sub_1001EFD0(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (1001FA80) --------------------------------------------------------
bool __cdecl sub_1001FA80(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_10023210(v2) != 0;
  return sub_1001F990(a1, a2, v3);
}

//----- (1001FAB0) --------------------------------------------------------
signed int __cdecl sub_1001FAB0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_10030AD0(v1) )
  {
    v2 = sub_10005070(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_10025230(v8);
      if ( (v4 & sub_1001D600(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_1002F6F0(v8, v9);
    v6 = 0;
    while ( !sub_1001FC70(v8, byte_1007AF2D[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 1001FAB0: using guessed type char var_1AE[426];
// 1001FAB0: using guessed type char var_1B0[2];
// 1001FAB0: using guessed type char var_24C[68];

//----- (1001FBE0) --------------------------------------------------------
char __thiscall sub_1001FBE0(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_1011A698 = sub_1001D620(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_1011A6A0, 0, 0x1540u);
  memset(&unk_1011BBE0, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_1011A6A0;
  do
  {
    sub_10030870(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_1011BBE0 );
  v3 = 0;
  v4 = &unk_1011BBE0;
  do
  {
    result = sub_100308F0(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&unk_1011D590 );
  return result;
}
// 1011A698: using guessed type int dword_1011A698;

//----- (1001FC70) --------------------------------------------------------
char __cdecl sub_1001FC70(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1011A698 != 1379255385;
  v7 = 0;
  v8 = dword_1011A698 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10005040(86, 10);
      memset((char *)&unk_1011A6A0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10030870(a1, (int)&unk_1011A6A0 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_1011A978[v6] == a2 || byte_1011A979[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10005010(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1011A698: using guessed type int dword_1011A698;

//----- (1001FD30) --------------------------------------------------------
char __cdecl sub_1001FD30(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_1011A698 != 1379255385;
  v7 = 0;
  v8 = dword_1011A698 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10005040(86, 10);
      memset((char *)&unk_1011A6A0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10030870(a1, (int)&unk_1011A6A0 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_1011A998[v6] == a2 || byte_1011A999[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10005010(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1011A698: using guessed type int dword_1011A698;

//----- (1001FDF0) --------------------------------------------------------
char __cdecl sub_1001FDF0(char a1, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int8 v4; // [sp+8h] [bp-8h]@1
  char v5; // [sp+Ch] [bp-4h]@2

  v2 = 0;
  v4 = 0;
  while ( 1 )
  {
    sub_1002FD20(a1, v4, (int)&v5);
    if ( v5 == a2 )
      break;
    v4 = ++v2;
    if ( v2 >= 2u )
      return 0;
  }
  return 1;
}

//----- (1001FE40) --------------------------------------------------------
char __cdecl sub_1001FE40(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001FC70(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001FE70) --------------------------------------------------------
char __cdecl sub_1001FE70(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001FD30(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1001FEA0) --------------------------------------------------------
char __cdecl sub_1001FEA0(char a1)
{
  char result; // al@1
  unsigned __int8 v2; // bl@1
  char v3; // [sp+8h] [bp-4h]@1

  result = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1001FDF0(v3, a1);
    v3 = ++v2;
  }
  while ( v2 < 3u );
  return result;
}

//----- (1001FEE0) --------------------------------------------------------
char __cdecl sub_1001FEE0(char a1, _BYTE *a2)
{
  int v2; // esi@1

  *a2 = 19;
  v2 = 0;
  while ( a1 != 3 && a1 != byte_1007B485[2 * v2] || !sub_1001FEA0(byte_1007B484[2 * v2]) )
  {
    if ( (unsigned int)++v2 >= 0xF )
      return 0;
  }
  *a2 = byte_1007B484[2 * v2];
  return 1;
}

//----- (1001FF30) --------------------------------------------------------
char __thiscall sub_1001FF30(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_1001D560(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 100479F6: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (1001FF60) --------------------------------------------------------
int __thiscall sub_1001FF60(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1001D560(46, (char *)&v2);
  return (int)v2;
}

//----- (1001FF80) --------------------------------------------------------
int __cdecl sub_1001FF80(unsigned __int16 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 > 0x1C8Au && a1 < 0x1C8Bu )
    result = (unsigned __int16)(a1 - 7307);
  return result;
}

//----- (1001FFA0) --------------------------------------------------------
char *__cdecl sub_1001FFA0(unsigned __int16 a1)
{
  bool v1; // cf@1
  bool v2; // zf@1
  char *result; // eax@1

  v1 = a1 < 0x1C8Au;
  v2 = a1 == 7306;
  result = (char *)&unk_1007BA00;
  if ( a1 < 0x1C8Au )
  {
    if ( a1 != -1 )
      return (char *)TXT_get_static_string();
    v1 = 0;
    v2 = 0;
  }
  if ( !v1 && !v2 && a1 < 0x1C8Bu )
    result = &byte_101E7428[(unsigned __int16)sub_1001FF80(a1)];
  return result;
}
// 100473DA: using guessed type int TXT_get_static_string(void);

//----- (1001FFE0) --------------------------------------------------------
signed int __cdecl sub_1001FFE0(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 < 0x17u )
      result = *(_DWORD *)(a1 + 36);
  }
  return result;
}

//----- (10020000) --------------------------------------------------------
double __cdecl sub_10020000(signed int a1, char a2)
{
  return (double)(a1 >> (31 - a2)) / (double)(1 << a2) * 3.1415926535898;
}

//----- (10020040) --------------------------------------------------------
bool __cdecl sub_10020040(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_101E38C8[v2 / 4] && word_101E38C4[v2 / 2] && dword_101E38C0[v2 / 4] )
      result = 1;
  }
  return result;
}
// 101E38C0: using guessed type int dword_101E38C0[];
// 101E38C4: using guessed type __int16 word_101E38C4[];
// 101E38C8: using guessed type int dword_101E38C8[];

//----- (10020080) --------------------------------------------------------
int __cdecl sub_10020080(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_10020040(0, a1) )
    result = dword_101E38C8[3 * v1];
  else
    result = 0;
  return result;
}
// 101E38C8: using guessed type int dword_101E38C8[];

//----- (100200B0) --------------------------------------------------------
int __cdecl sub_100200B0(char *a1, char *a2)
{
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  char v4; // al@2
  int result; // eax@4

  v2 = strstr(a1, a2);
  v3 = strlen(a2);
  result = 0;
  if ( v2 )
  {
    v4 = v2[v3];
    if ( !v4 || v4 == 44 )
      result = 1;
  }
  return result;
}

//----- (100200F0) --------------------------------------------------------
double sub_100200F0()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_100050D0(10002, &v2, 4, &v1);
  return v2;
}

//----- (10020120) --------------------------------------------------------
char __usercall sub_10020120@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3)
{
  double v3; // st7@8
  char result; // al@10
  char v5; // [sp+7h] [bp-29h]@3
  float v6; // [sp+8h] [bp-28h]@1
  float v7; // [sp+Ch] [bp-24h]@3
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  float v12[4]; // [sp+20h] [bp-10h]@1

  v6 = 0.0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_100050D0(6117, v12, 16, &v8) )
    sub_10004C50("..\\lib\\adl\\iop_eis_intf.c", 2716, 0, 0);
  sub_1001EFD0(1, 0x50u, &v5);
  if ( sub_10005110(6354, (int)&v7, 4) )
    sub_10004C50("..\\lib\\adl\\iop_eis_intf.c", 2735, 0, 0);
  if ( (sub_10030EE0(a2) || v5) && sub_10030DC0(a2, &v6) )
  {
    v6 = v12[2 * a3] * v6;
    v3 = v6;
    *a1 = v6;
    if ( v7 > v3 )
      *a1 = 0.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10020120: using guessed type float var_10[4];

//----- (10020210) --------------------------------------------------------
char __cdecl sub_10020210(float *a1)
{
  return sub_10020120(a1, 0x14u, 0);
}

//----- (10020230) --------------------------------------------------------
char __cdecl sub_10020230(float *a1)
{
  return sub_10020120(a1, 0x2Du, 1u);
}

//----- (10020250) --------------------------------------------------------
char __cdecl sub_10020250(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10020210(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10020230(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else if ( v1 )
  {
    result = v1;
    *a1 = v4;
  }
  else
  {
    *a1 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (100202E0) --------------------------------------------------------
double sub_100202E0()
{
  int v0; // eax@1
  double result; // st7@1
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  double v4; // [sp+8h] [bp-8h]@2

  v3 = 9.8999998e24;
  v0 = sub_100050D0(10009, &v2, 4, &v3);
  result = v2;
  if ( !v0 )
  {
    v4 = v2;
    v2 = v4 - sub_100200F0();
    if ( v2 >= 0.0 )
    {
      result = v2;
    }
    else
    {
      v2 = 0.0;
      result = (float)0.0;
    }
  }
  return result;
}

//----- (10020340) --------------------------------------------------------
int __cdecl sub_10020340(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10020390) --------------------------------------------------------
void sub_10020390()
{
  dword_101E7424 = -15;
}
// 101E7424: using guessed type int dword_101E7424;

//----- (100203A0) --------------------------------------------------------
signed int sub_100203A0()
{
  return sub_1005B6D0((int)&off_10080D18);
}
// 10080D18: using guessed type char *off_10080D18;

//----- (100203B0) --------------------------------------------------------
signed int sub_100203B0()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_100203A0() )
    v0 = *(_BYTE *)(dword_101E7424 + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 101E7424: using guessed type int dword_101E7424;

//----- (100203E0) --------------------------------------------------------
bool __cdecl sub_100203E0(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_10005070(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_100203A0() )
  {
    sub_10004EC0(101, 10000);
    v3 = 0.0;
    v4 = dword_101E7424;
    v2 = *(_WORD *)(dword_101E7424 + 1456) > 1u;
    if ( *(_BYTE *)(dword_101E7424 + 1296) )
    {
      v14 = sub_10031140(*(_DWORD *)(dword_101E7424 + 1292));
      v4 = dword_101E7424;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_10020340(6.2831853071796, -6.2831853071796);
      sub_10020340(6.2831853071796, -6.2831853071796);
      sub_100479D0(v14, dword_101E7424 + 1512, (int)&v17);
      v4 = dword_101E7424;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_100479A0((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_101E7424;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_101E7424 + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_10004EA0(101);
    sub_10023270(a2);
  }
  return v2;
}
// 101E7424: using guessed type int dword_101E7424;

//----- (10020600) --------------------------------------------------------
char sub_10020600()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_100203A0() )
  {
    sub_10004EC0(101, 10000);
    if ( !*(_BYTE *)(dword_101E7424 + 1444)
      || !*(_BYTE *)(dword_101E7424 + 1451)
      || (v0 = 1, *(_WORD *)(dword_101E7424 + 1456) <= 1u)
      || *(float *)(dword_101E7424 + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_10004EA0(101);
  }
  return v0;
}
// 101E7424: using guessed type int dword_101E7424;

//----- (10020670) --------------------------------------------------------
bool __cdecl sub_10020670(float *a1)
{
  bool v1; // bl@1
  double v2; // st7@3

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_100203A0() )
  {
    sub_10004EC0(101, 10000);
    if ( *(_BYTE *)(dword_101E7424 + 1444) )
      v2 = (double)(unsigned int)(sub_10004DF0() - *(_DWORD *)(dword_101E7424 + 1292))
         / 1000.0
         * *(float *)(dword_101E7424 + 1488)
         + *(float *)(dword_101E7424 + 1484);
    else
      v2 = *(float *)(dword_101E7424 + 1484);
    *a1 = v2;
    *a1 = sub_10047770(*a1);
    v1 = *(_WORD *)(dword_101E7424 + 1456) > 1u;
    sub_10004EA0(101);
  }
  return v1;
}
// 101E7424: using guessed type int dword_101E7424;

//----- (10020720) --------------------------------------------------------
bool __cdecl sub_10020720(float *a1)
{
  bool v1; // bl@1
  int v2; // eax@2

  *a1 = 0.0;
  v1 = 0;
  if ( (unsigned __int8)sub_100203A0() )
  {
    sub_10004EC0(101, 60000);
    v2 = dword_101E7424;
    if ( *(_BYTE *)(dword_101E7424 + 1451) )
    {
      *a1 = *(float *)(dword_101E7424 + 1480);
      v2 = dword_101E7424;
    }
    v1 = *(_WORD *)(v2 + 1456) > 1u;
    sub_10004EA0(101);
  }
  return v1;
}
// 101E7424: using guessed type int dword_101E7424;

//----- (10020780) --------------------------------------------------------
#error "10020780: call analysis failed (funcsize=2)"

//----- (10020790) --------------------------------------------------------
#error "1002079F: call analysis failed (funcsize=5)"

//----- (100207B0) --------------------------------------------------------
BOOL __cdecl sub_100207B0(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_10004DF0();
  for ( i = sub_1005B7A0(6, 0, 1, (int)&v4); i == 12; i = sub_1005B7A0(6, 0, 1, (int)&v4) )
  {
    if ( sub_10004DF0() - v1 >= a1 )
      break;
    sub_10004F40(100);
  }
  return i == 12;
}

//----- (10020820) --------------------------------------------------------
char __thiscall sub_10020820(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_100054D0(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10020840) --------------------------------------------------------
void __cdecl sub_10020840(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_100054D0(120, a1);
  sub_100054D0(124, a2);
  sub_100054D0(121, a3);
}

//----- (10020870) --------------------------------------------------------
int __cdecl sub_10020870(int a1)
{
  return sub_10005070(3025, a1, 84);
}

//----- (10020890) --------------------------------------------------------
signed int sub_10020890()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_1005B7E0(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (100208C0) --------------------------------------------------------
void __cdecl sub_100208C0(_BYTE *a1)
{
  sub_100054D0(129, a1);
}

//----- (100208E0) --------------------------------------------------------
char __cdecl sub_100208E0(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_1005B7A0(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10020920) --------------------------------------------------------
int __cdecl sub_10020920(int a1)
{
  return sub_10005140(3025, a1, 84);
}

//----- (10020940) --------------------------------------------------------
char __fastcall sub_10020940(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_101E4114 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_100208E0(147, 0xCu, &v38);
  sub_100208E0(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_100050D0(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_1001FF30(a1);
  if ( !result || result == 3 )
    result = sub_1001D680(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_10005140(2000, (int)&v20, 29);
  }
  return result;
}
// 101E4114: using guessed type char byte_101E4114;

//----- (10020B60) --------------------------------------------------------
char sub_10020B60()
{
  int *v0; // ecx@1

  sub_100207B0(0x9C40u);
  sub_1001C390(&off_10081810);
  return sub_10020940(v0);
}
// 10081810: using guessed type int (__cdecl *off_10081810)(int, size_t, void *);

//----- (10020B80) --------------------------------------------------------
void sub_10020B80()
{
  dword_101E7420 = -15;
}
// 101E7420: using guessed type int dword_101E7420;

//----- (10020B90) --------------------------------------------------------
signed int sub_10020B90()
{
  return sub_1005B6D0((int)&off_10081844);
}
// 10081844: using guessed type char *off_10081844;

//----- (10020BA0) --------------------------------------------------------
int sub_10020BA0()
{
  int result; // eax@1

  result = 0;
  dword_10126F60 = -15;
  dword_101E741C = 0;
  dword_101E7410 = 0;
  dword_101E7414 = 0;
  dword_101E7418 = 0;
  return result;
}
// 10126F60: using guessed type int dword_10126F60;
// 101E7410: using guessed type int dword_101E7410;
// 101E7414: using guessed type int dword_101E7414;
// 101E741C: using guessed type int dword_101E741C;

//----- (10020BD0) --------------------------------------------------------
char sub_10020BD0()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_1005B6D0((int)&off_10081870);
  if ( v0 )
  {
    dword_101E741C = dword_10126F60;
    v1 = *(_BYTE *)(dword_10126F60 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_101E741C + 36) < (unsigned int)sub_10004DF0() )
      v0 = 0;
    dword_101E7418 = (void *)(dword_10126F60 + 56116);
    result = v0;
    dword_101E7410 = dword_10126F60 + 1516;
    dword_101E7414 = dword_10126F60 + 20484;
  }
  else
  {
    dword_101E741C = 0;
    dword_101E7410 = 0;
    dword_101E7414 = 0;
    dword_101E7418 = 0;
    result = 0;
  }
  return result;
}
// 10081870: using guessed type char *off_10081870;
// 10126F60: using guessed type int dword_10126F60;
// 101E7410: using guessed type int dword_101E7410;
// 101E7414: using guessed type int dword_101E7414;
// 101E741C: using guessed type int dword_101E741C;

//----- (10020C70) --------------------------------------------------------
void sub_10020C70()
{
  dword_101E411C = -15;
}
// 101E411C: using guessed type int dword_101E411C;

//----- (10020C80) --------------------------------------------------------
char __cdecl sub_10020C80(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_10023210(v1);
  v3 = sub_10031420(v2);
  if ( sub_10005070(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 10020C80: using guessed type char var_48[68];

//----- (10020CE0) --------------------------------------------------------
signed int sub_10020CE0()
{
  return sub_1005B6D0((int)&off_100818A4);
}
// 100818A4: using guessed type char *off_100818A4;

//----- (10020CF0) --------------------------------------------------------
char __usercall sub_10020CF0@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_10020CE0()
    || sub_10004EC0(33, 10) )
  {
    sub_10004C50("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_10004DF0()
                         - *(_DWORD *)(dword_101E411C + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_101E411C + 37) )
  {
    memcpy_0(
      a3,
      (const void *)(dword_101E411C + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_101E411C + 2 * v3 + 62));
    sub_10004EA0(33);
    result = 1;
  }
  else
  {
    sub_10004EA0(33);
    result = 0;
  }
  return result;
}
// 101E411C: using guessed type int dword_101E411C;

//----- (10020DD0) --------------------------------------------------------
char __cdecl sub_10020DD0(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_10020CF0(a1, a2, a3);
    }
    else
    {
      v4 = sub_10031550(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_1001EC40(*(_BYTE *)v5)) )
      {
        result = sub_1001F8E0(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 10031550: using guessed type _DWORD __cdecl sub_10031550(char);

//----- (10020E50) --------------------------------------------------------
char __cdecl sub_10020E50(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_10020C80(a1);
  return sub_10020DD0(a1, v2, a2);
}

//----- (10020E70) --------------------------------------------------------
int __cdecl sub_10020E70(int a1, int a2)
{
  byte_101E7428[0] = 0;
  return nullsub_1(a1, a2);
}

//----- (10020E90) --------------------------------------------------------
signed int sub_10020E90()
{
  return 1000;
}

//----- (10020EB0) --------------------------------------------------------
int sub_10020EB0()
{
  return sub_10030070((int)off_10081DF8);
}
// 10081DF8: using guessed type int (*off_10081DF8[4])();

//----- (10020EC0) --------------------------------------------------------
char __cdecl sub_10020EC0(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_1001D560(13, (char *)&v3 + 3);
  sub_1001D560(12, a1);
  return BYTE3(v3);
}

//----- (10020F30) --------------------------------------------------------
signed int __cdecl sub_10020F30(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10031560(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_10032480(v4, a4, 0) == a4 )
      result = sub_10032420(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10020F90) --------------------------------------------------------
signed int __cdecl sub_10020F90(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10031560(a1);
  return sub_10032480(v3, a2, a3);
}

//----- (10020FB0) --------------------------------------------------------
int __cdecl sub_10020FB0(_BYTE *a1)
{
  return sub_10030590(a1, 0, 0xFFFFFFFu, 0, 0);
}

//----- (10020FD0) --------------------------------------------------------
int __cdecl sub_10020FD0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10021010) --------------------------------------------------------
bool sub_10021010()
{
  return sub_10004EA0(99) == 0;
}

//----- (10021020) --------------------------------------------------------
bool sub_10021020()
{
  return sub_10004EC0(99, 10000) == 0;
}

//----- (10021040) --------------------------------------------------------
bool __cdecl sub_10021040(char a1)
{
  int v1; // eax@1

  v1 = a1 & 0x3F;
  return !(a1 & 0x3F) || v1 == 6 || v1 == 7 || v1 == 21 || v1 == 9 || v1 == 16 || v1 == 20;
}

//----- (10021070) --------------------------------------------------------
char *__cdecl sub_10021070(unsigned __int8 a1)
{
  return off_10097640[2 * a1];
}
// 10097640: using guessed type char *off_10097640[42];

//----- (10021080) --------------------------------------------------------
char *__cdecl sub_10021080(unsigned int a1, float *a2)
{
  unsigned __int8 v2; // ST0C_1@1

  v2 = sub_10021410(a1, a2);
  return sub_10021070(v2);
}

//----- (100210B0) --------------------------------------------------------
int __cdecl sub_100210B0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= LOWORD((&off_10097834)[2 * *(_BYTE *)a1 + 2]) );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - LOBYTE((&off_10097834)[2 * *(_BYTE *)a1 + 2]);
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}
// 10097834: using guessed type char *;

//----- (100211A0) --------------------------------------------------------
__int16 __cdecl sub_100211A0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (100211F0) --------------------------------------------------------
int __cdecl sub_100211F0(int *a1, unsigned int a2)
{
  int result; // eax@1

  result = (a2 >> 24) + 60 * ((unsigned __int8)(a2 >> 16) + 60 * (unsigned __int16)a2);
  *a1 = result;
  return result;
}

//----- (10021220) --------------------------------------------------------
__int16 __cdecl sub_10021220(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_100211A0((int)&v5, *a1);
  sub_100210B0((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (100212A0) --------------------------------------------------------
int __cdecl sub_100212A0(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_101E38AC)();
  *a1 = result;
  return result;
}
// 101E38AC: using guessed type int dword_101E38AC;

//----- (100212C0) --------------------------------------------------------
char __cdecl sub_100212C0(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32746;
  qmemcpy(&v3, a1, 0x11Cu);
  return sub_100301D0((int)&v2);
}

//----- (10021330) --------------------------------------------------------
int __cdecl sub_10021330(unsigned __int8 a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  char v4; // [sp+8h] [bp-120h]@1
  char v5; // [sp+27h] [bp-101h]@1

  memset(&v4, 0, 0x11Cu);
  sub_10030830(a1, (int)&v4);
  v5 = 0;
  sub_100212C0(&v4);
  v2 = sub_1001D210(v1);
  sub_10032610(a1, SIM_intf + 24);
  *(_BYTE *)(SIM_intf + 320) = v2;
  return SIM_proc_rqst(49);
}
// 10032610: using guessed type _DWORD __cdecl sub_10032610(_DWORD, _DWORD);
// 100479F6: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (100213C0) --------------------------------------------------------
char __cdecl sub_100213C0(char a1)
{
  char v1; // bl@1
  char result; // al@4

  v1 = a1;
  sub_100054D0(69, &a1);
  if ( a1 && (v1 == 15 || v1 == 13) )
    result = 17;
  else
    result = v1;
  return result;
}

//----- (100213F0) --------------------------------------------------------
char __cdecl sub_100213F0(char a1)
{
  char result; // al@3

  if ( a1 == 1 )
  {
    result = 2;
  }
  else if ( a1 == 3 )
  {
    result = 3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10021410) --------------------------------------------------------
char __cdecl sub_10021410(unsigned int a1, float *a2)
{
  __int16 v2; // si@1
  int v3; // edx@1
  char v4; // al@1
  char v5; // cl@1
  char result; // al@3
  float *v7; // edi@37
  int v8; // esi@37
  char v9; // al@51

  v2 = a1;
  v3 = a1 & 0x3F;
  v4 = (a1 >> 12) & 1;
  v5 = 31;
  LOBYTE(a1) = 31;
  switch ( v3 )
  {
    case 0:
    case 1:
      if ( v4 )
      {
        sub_100054D0(44, &a1);
        result = a1;
      }
      else
      {
        result = sub_1001D1E0((void *)31);
      }
      break;
    case 2:
    case 27:
      if ( v4 )
      {
        sub_100054D0(77, &a1);
        result = a1;
      }
      else
      {
        result = sub_1001D250((void *)31);
      }
      break;
    case 3:
      result = sub_1001D250((void *)31) != 30 ? 29 : 12;
      break;
    case 4:
      v5 = sub_1001D250((void *)31);
      if ( v5 == 21 )
      {
        if ( !a2 || *a2 >= 1000.0 )
          goto LABEL_60;
        result = 29;
      }
      else
      {
        if ( !a2 || *a2 >= 185.2 )
          goto LABEL_60;
        result = 12;
      }
      break;
    case 5:
      result = 18;
      break;
    case 10:
      result = 32;
      break;
    case 11:
      result = sub_1001D380((void *)31);
      break;
    case 12:
      if ( v4 )
      {
        sub_100054D0(17, &a1);
        result = a1;
      }
      else
      {
        result = 33;
      }
      break;
    case 13:
    case 14:
      result = sub_1001D370();
      break;
    case 15:
      if ( v4 )
      {
        sub_100054D0(49, &a1);
        result = a1;
      }
      else
      {
        result = sub_1001D3B0((void *)31);
      }
      break;
    case 16:
    case 17:
      if ( v4 )
      {
        sub_100054D0(14, &a1);
        result = a1;
      }
      else
      {
        result = sub_1001D3E0(31);
      }
      break;
    case 18:
      result = 49;
      break;
    case 19:
      result = 39;
      break;
    case 20:
      if ( v4 )
      {
        sub_100054D0(45, &a1);
        result = a1;
      }
      else
      {
        result = sub_1001D4C0((void *)31);
      }
      break;
    case 21:
      if ( v4 )
      {
        sub_100054D0(15, &a1);
        result = a1;
      }
      else
      {
        result = sub_1001D320(31);
      }
      break;
    case 36:
      v7 = a2;
      v8 = v2 & 0x1000;
      switch ( (unsigned __int8)sub_10021410(v8 | 0x15, a2) )
      {
        case 0xDu:
          result = (unsigned __int8)sub_10021410(v8 | 2, v7) != 21 ? 45 : 57;
          break;
        case 0x18u:
          result = (unsigned __int8)sub_10021410(v8 | 2, v7) != 21 ? 54 : 59;
          break;
        case 0x10u:
          result = (unsigned __int8)sub_10021410(v8 | 2, v7) != 21 ? 53 : 58;
          break;
        case 0x13u:
          result = (unsigned __int8)sub_10021410(v8 | 2, v7) != 21 ? 55 : 60;
          break;
        default:
          result = 4 * ((unsigned __int8)sub_10021410(v8 | 2, v7) == 21) + 52;
          break;
      }
      break;
    case 22:
      if ( v4 )
      {
        sub_100054D0(16, &a1);
        result = a1;
      }
      else
      {
        result = sub_1001D280(31);
      }
      break;
    case 23:
      result = 50;
      break;
    case 24:
      result = 0;
      break;
    case 25:
      result = 34;
      break;
    case 26:
      result = 1;
      break;
    case 38:
    case 39:
    case 42:
    case 43:
      result = 5;
      break;
    case 40:
    case 41:
      v9 = sub_100061E0();
      result = sub_100213F0(v9);
      break;
    case 29:
      result = 41;
      break;
    case 30:
      result = 42;
      break;
    case 31:
      result = 43;
      break;
    case 32:
      result = sub_1001D4F0(31);
      break;
    case 33:
      result = 46;
      break;
    case 34:
      result = 47;
      break;
    case 35:
      result = 48;
      break;
    case 37:
      v5 = (sub_1001D4F0(31) != 19) + 61;
      goto LABEL_60;
    default:
LABEL_60:
      result = v5;
      break;
  }
  return result;
}

//----- (10021830) --------------------------------------------------------
double __cdecl sub_10021830(int a1, unsigned int a2)
{
  __int16 v2; // si@1
  char v3; // al@1
  void *v4; // ecx@1
  double result; // st7@3
  int v6; // eax@26
  int v7; // eax@27
  int v8; // eax@33
  int v9; // eax@34
  double v10; // st7@42
  float v11; // ST0C_4@44
  int v12; // eax@48
  int v13; // eax@49
  int v14; // eax@55
  int v15; // eax@56
  float v16; // [sp+Ch] [bp-4h]@1

  v2 = a2;
  v16 = 1.0;
  v3 = sub_10021410(a2, (float *)&a1);
  v4 = (void *)(v2 & 0x3F);
  switch ( v4 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 4u:
    case 0x1Bu:
      switch ( v3 )
      {
        case 0xC:
          *(float *)&a1 = (float)3.2808399 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)0.00053995679 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)39.370079 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_67;
        default:
          goto LABEL_69;
      }
      goto LABEL_69;
    case 0xAu:
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v3 != 15 )
        goto LABEL_8;
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_8:
      *(float *)&a1 = (float)0.00029530001 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v3 == 40 )
      {
        *(float *)&a1 = (float)0.0000099999997 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0001450377 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v3 == 22 )
      {
        *(float *)&a1 = (float)3.5999999 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)1.9438444 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v3 == 28 )
      {
        *(float *)&a1 = (float)60.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)196.85039 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v3 != 10 )
        goto LABEL_69;
      sub_10032860((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v3 != 10 )
        goto LABEL_68;
      *(float *)&a1 = (float)1.8 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v3 )
      {
        case 0xD:
          *(float *)&a1 = (float)0.26417205 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)0.21997361 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v6 = (unsigned __int8)sub_1001D2F0(v4);
          if ( (_BYTE)v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                *(float *)&a1 = (float)0.77890778 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.84999973 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.80407244 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.71895844 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v8 = (unsigned __int8)sub_1001D2F0(v4);
          if ( (_BYTE)v8 )
          {
            v9 = v8 - 1;
            if ( v9 )
            {
              if ( v9 == 1 )
              {
                *(float *)&a1 = (float)1.7171981 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.8756201 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.7726756 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.5850322 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_69;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v3 < 0x38u || (unsigned __int8)v3 > 0x3Cu )
        v10 = 0.00053995679;
      else
        v10 = 0.001;
      v11 = v10;
      *(float *)&a1 = v11 * *(float *)&a1;
      *(float *)&a1 = sub_10021E60(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v3 )
      {
        case 0xE:
          *(float *)&a1 = (float)951.01935 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)791.90497 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v12 = (unsigned __int8)sub_1001D2F0(v4);
          if ( (_BYTE)v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              if ( v13 == 1 )
              {
                *(float *)&a1 = (float)2804.0679 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)3059.999 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)2894.6609 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)2588.2505 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v14 = (unsigned __int8)sub_1001D2F0(v4);
          if ( (_BYTE)v14 )
          {
            v15 = v14 - 1;
            if ( v15 )
            {
              if ( v15 == 1 )
              {
                *(float *)&a1 = (float)6181.9131 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)6752.2324 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)6381.6323 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)5706.1162 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)3600.0 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v3 == 19 )
        goto LABEL_67;
      *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v3 == 61 )
      {
LABEL_67:
        v16 = 0.001;
LABEL_68:
        *(float *)&a1 = v16 * *(float *)&a1;
LABEL_69:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.0022046 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_69;
  }
}

//----- (10021E60) --------------------------------------------------------
double __cdecl sub_10021E60(int a1, unsigned int a2)
{
  __int16 v2; // di@1
  unsigned int v3; // esi@1
  void *v4; // ecx@1
  char v5; // bl@1
  double result; // st7@5
  int v7; // eax@28
  int v8; // eax@29
  int v9; // eax@35
  int v10; // eax@36
  double v11; // st7@44
  float v12; // ST1C_4@46
  int v13; // eax@50
  int v14; // eax@51
  int v15; // eax@57
  int v16; // eax@58
  float v17; // [sp+14h] [bp-4h]@1

  v17 = 1.0;
  v2 = a2;
  v3 = a2 & 0x3F;
  v5 = sub_10021410(a2, 0);
  if ( v3 == 4 )
    sub_10004C50("..\\lib\\adl\\cdp_cnvt.c", 1174, 1, 0);
  switch ( v3 )
  {
    case 0u:
    case 1u:
    case 2u:
    case 3u:
    case 0x1Bu:
      switch ( v5 )
      {
        case 0xC:
          *(float *)&a1 = (float)0.3048 * *(float *)&a1;
          return *(float *)&a1;
        case 0x1E:
          *(float *)&a1 = (float)1852.0 * *(float *)&a1;
          return *(float *)&a1;
        case 0x12:
          *(float *)&a1 = (float)0.0254 * *(float *)&a1;
          return *(float *)&a1;
        case 0x15:
          goto LABEL_69;
        default:
          goto LABEL_71;
      }
      goto LABEL_71;
    case 0xAu:
      *(float *)&a1 = (float)0.0099999998 * *(float *)&a1;
      return *(float *)&a1;
    case 0xBu:
      if ( v5 != 15 )
        goto LABEL_10;
      *(float *)&a1 = (float)100.0 * *(float *)&a1;
      return *(float *)&a1;
    case 0xDu:
    case 0xEu:
LABEL_10:
      *(float *)&a1 = (float)3386.3867 * *(float *)&a1;
      return *(float *)&a1;
    case 0xCu:
      if ( v5 == 40 )
      {
        *(float *)&a1 = (float)100000.0 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)6894.7593 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0xFu:
      if ( v5 == 22 )
      {
        *(float *)&a1 = (float)0.27777779 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.51444447 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x14u:
      if ( v5 == 11 )
      {
        *(float *)&a1 = (float)0.00508 * *(float *)&a1;
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)0.016666668 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    case 0x10u:
      if ( v5 != 10 )
        goto LABEL_71;
      sub_10032880((int)&a1, *(float *)&a1);
      return *(float *)&a1;
    case 0x11u:
      if ( v5 != 10 )
        goto LABEL_70;
      *(float *)&a1 = (float)0.55555558 * *(float *)&a1;
      return *(float *)&a1;
    case 0x15u:
      switch ( v5 )
      {
        case 0xD:
          *(float *)&a1 = (float)3.7854118 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x10:
          *(float *)&a1 = (float)4.546 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x13:
          v7 = (unsigned __int8)sub_1001D2F0(v4);
          if ( (_BYTE)v7 )
          {
            v8 = v7 - 1;
            if ( v8 )
            {
              if ( v8 == 1 )
              {
                *(float *)&a1 = (float)1.283849 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)1.176471 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)1.243669 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)1.390901 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x18:
          v9 = (unsigned __int8)sub_1001D2F0(v4);
          if ( (_BYTE)v9 )
          {
            v10 = v9 - 1;
            if ( v10 )
            {
              if ( v10 == 1 )
              {
                *(float *)&a1 = (float)0.582344 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.53315699 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.56411898 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.63090199 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          goto LABEL_71;
      }
      return result;
    case 0x24u:
      if ( (unsigned __int8)v5 < 0x38u || (unsigned __int8)v5 > 0x3Cu )
        v11 = 1852.0;
      else
        v11 = 1000.0;
      v12 = v11;
      *(float *)&a1 = v12 * *(float *)&a1;
      *(float *)&a1 = sub_10021830(a1, v2 & 0x1000 | 0x15u);
      return *(float *)&a1;
    case 0x16u:
      switch ( v5 )
      {
        case 0xE:
          *(float *)&a1 = (float)0.0010515032 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x11:
          *(float *)&a1 = (float)0.0012627778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
        case 0x14:
          v13 = (unsigned __int8)sub_1001D2F0(v4);
          if ( (_BYTE)v13 )
          {
            v14 = v13 - 1;
            if ( v14 )
            {
              if ( v14 == 1 )
              {
                *(float *)&a1 = (float)0.00035662472 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00032679751 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00034546363 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00038636138 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        case 0x19:
          v15 = (unsigned __int8)sub_1001D2F0(v4);
          if ( (_BYTE)v15 )
          {
            v16 = v15 - 1;
            if ( v16 )
            {
              if ( v16 == 1 )
              {
                *(float *)&a1 = (float)0.00016176222 * *(float *)&a1;
                result = *(float *)&a1;
              }
              else
              {
                *(float *)&a1 = (float)0.00014809916 * *(float *)&a1;
                result = *(float *)&a1;
              }
            }
            else
            {
              *(float *)&a1 = (float)0.00015669972 * *(float *)&a1;
              result = *(float *)&a1;
            }
          }
          else
          {
            *(float *)&a1 = (float)0.00017525055 * *(float *)&a1;
            result = *(float *)&a1;
          }
          break;
        default:
          *(float *)&a1 = (float)0.00027777778 * *(float *)&a1;
          result = *(float *)&a1;
          break;
      }
      return result;
    case 0x20u:
      if ( v5 == 19 )
        goto LABEL_69;
      *(float *)&a1 = (float)453.59241 * *(float *)&a1;
      return *(float *)&a1;
    case 0x25u:
      if ( v5 == 61 )
      {
LABEL_69:
        v17 = 1000.0;
LABEL_70:
        *(float *)&a1 = v17 * *(float *)&a1;
LABEL_71:
        result = *(float *)&a1;
      }
      else
      {
        *(float *)&a1 = (float)453.59241 * *(float *)&a1;
        result = *(float *)&a1;
      }
      return result;
    default:
      goto LABEL_71;
  }
}

//----- (10022550) --------------------------------------------------------
void __cdecl sub_10022550(int a1, float a2)
{
  float v2; // [sp+8h] [bp+8h]@1

  v2 = a2 / 0.01745329238474369;
  *(float *)a1 = v2;
  if ( v2 < 0.0 )
    *(float *)a1 = v2 + 360.0;
}

//----- (10022580) --------------------------------------------------------
void __cdecl sub_10022580(int a1, float a2)
{
  float v2; // [sp+10h] [bp+8h]@1

  v2 = a2 * 0.01745329238474369;
  *(float *)a1 = v2;
  *(float *)a1 = sub_10047770(v2);
}

//----- (100225B0) --------------------------------------------------------
bool __cdecl sub_100225B0(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  char v6; // al@3
  bool result; // al@6
  int v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_1001D600(v1);
  v10 = 0;
  v5 = &unk_10099348;
  do
  {
    if ( v8 & *v5 )
    {
      v6 = sub_10031500(v10, 0);
      if ( sub_10020DD0(3, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (10022650) --------------------------------------------------------
int sub_10022650()
{
  int result; // eax@1

  sub_10005110(6361, (int)&unk_101346B0, 4);
  result = sub_10005110(6362, (int)&unk_101346B4, 4);
  dword_101346B8 = 1379255385;
  return result;
}
// 101346B8: using guessed type int dword_101346B8;

//----- (10022680) --------------------------------------------------------
char __cdecl sub_10022680(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10020E50(7, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39950.746
     || *(float *)a1 < -39950.746) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (100226E0) --------------------------------------------------------
char __cdecl sub_100226E0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10020E50(2, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 512.0 || *(float *)a1 < -512.0) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10022740) --------------------------------------------------------
char __cdecl sub_10022740(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10020E50(56, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 1053.5823
     || *(float *)a1 < -1053.5823) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (100227A0) --------------------------------------------------------
char __cdecl sub_100227A0(float *a1)
{
  float *v1; // esi@1
  char v2; // bl@1

  v1 = a1;
  *a1 = 0.0;
  v2 = sub_10022680(&a1);
  if ( v2 )
    *v1 = sub_1001D1C0() + *(float *)&a1;
  return v2;
}
// 1001D1C0: using guessed type double sub_1001D1C0(void);

//----- (100227D0) --------------------------------------------------------
char __cdecl sub_100227D0(float *a1)
{
  float *v1; // esi@1
  char result; // al@4
  float v3; // [sp+8h] [bp-4h]@1

  v1 = a1;
  *a1 = 9.8999998e24;
  if ( sub_100226E0(&v3) && sub_100227A0((float *)&a1) )
  {
    *(float *)&a1 = *(float *)&a1 * 3.280839920043945;
    if ( *(float *)&a1 < 36089.0 )
    {
      result = 1;
      *v1 = v3 - (15.0 - *(float *)&a1 / 1000.0 * 1.981199979782104);
    }
    else
    {
      result = 1;
      *v1 = v3 - -56.5;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10022870) --------------------------------------------------------
double __cdecl sub_10022870(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_100475D0(a1, a4);
  *(float *)&v16 = sub_10047530(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (10022950) --------------------------------------------------------
char __cdecl sub_10022950(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_100203B0() > 1u;
  v1 = 0;
  v12 = sub_100225B0(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_10099940;
  if ( sub_1001FA10(0x2E6u) || sub_1001FA10(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_10099938;
  v3 = 4;
  do
  {
    if ( sub_1001FA10(*v2) && sub_1001FA80(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_10099948[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_10020600() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_1001D620(v4) == 2 || sub_1001D620(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (10022A90) --------------------------------------------------------
int __cdecl sub_10022A90(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_101E4114 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_101E37B8)(146, 1, a1);
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E4114: using guessed type char byte_101E4114;

//----- (10022AC0) --------------------------------------------------------
char __cdecl sub_10022AC0(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_101E4114 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_101E37B8)(dword_101E3BE4, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3BE4: using guessed type int dword_101E3BE4;
// 101E4114: using guessed type char byte_101E4114;

//----- (10022B10) --------------------------------------------------------
char __cdecl sub_10022B10(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_101E4114 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_101E37B8)(dword_101E3BE4, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E3BE4: using guessed type int dword_101E3BE4;
// 101E4114: using guessed type char byte_101E4114;

//----- (10022B60) --------------------------------------------------------
int sub_10022B60()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_101E38C0, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_101E37A8)(512, &v6);
  v1 = 0;
  do
  {
    word_101E38C4[v1 / 2] = 0;
    dword_101E38C8[v1 / 4] = 0;
    dword_101E38C0[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_101E38CC = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_101E38D0 = v7;
    dword_101E38D4 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_101E38D8;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_101E37A8)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_101E38D0;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 101E37A8: using guessed type int dword_101E37A8;
// 101E38C0: using guessed type int dword_101E38C0[];
// 101E38C4: using guessed type __int16 word_101E38C4[];
// 101E38C8: using guessed type int dword_101E38C8[];
// 101E38CC: using guessed type int dword_101E38CC;
// 101E38D0: using guessed type int dword_101E38D0;
// 101E38D4: using guessed type int dword_101E38D4;
// 101E38D8: using guessed type int dword_101E38D8;

//----- (10022C30) --------------------------------------------------------
__int16 sub_10022C30()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_101E38DC;
  v1 = dword_101E38E0;
  v2 = 1;
  v3 = dword_101E38D8;
  if ( (unsigned int)dword_101E38E0 >= 1 )
  {
    v4 = (unsigned __int16)word_101E38DC;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_101E37B8)(v3, 2, &v5);
      result = v5;
      word_101E3FE0[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;
// 101E38D8: using guessed type int dword_101E38D8;
// 101E38DC: using guessed type __int16 word_101E38DC;
// 101E38E0: using guessed type int dword_101E38E0;
// 101E3FE0: using guessed type __int16 word_101E3FE0[];

//----- (10022C90) --------------------------------------------------------
int __usercall sub_10022C90@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (10022D10) --------------------------------------------------------
signed int __cdecl sub_10022D10(int a1)
{
  signed int result; // eax@1
  char v2; // [sp+8h] [bp-10h]@3
  char v3; // [sp+13h] [bp-5h]@3

  result = 538976288;
  *(_DWORD *)a1 = 538976288;
  *(_DWORD *)(a1 + 4) = 538976288;
  *(_DWORD *)(a1 + 8) = 538976288;
  *(_DWORD *)(a1 + 12) = 538976288;
  if ( byte_101E4114 )
  {
    LOBYTE(dword_10134724) = 0;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else if ( (_BYTE)dword_10134724 )
  {
    *(_DWORD *)a1 = dword_10134724;
    *(_DWORD *)(a1 + 4) = dword_10134728;
    *(_DWORD *)(a1 + 8) = dword_1013472C;
    result = dword_10134730;
    *(_DWORD *)(a1 + 12) = dword_10134730;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else
  {
    (*(void (__cdecl **)(signed int, signed int, char *))dword_101E37B8)(147, 12, &v2);
    sub_10022C90((int)&v3, &v3, 16, a1);
    dword_10134724 = *(_DWORD *)a1;
    dword_10134728 = *(_DWORD *)(a1 + 4);
    result = *(_DWORD *)(a1 + 8);
    dword_1013472C = *(_DWORD *)(a1 + 8);
    dword_10134730 = *(_DWORD *)(a1 + 12);
    byte_10134734 = *(_BYTE *)(a1 + 16);
    *(_BYTE *)(a1 + 16) = 0;
  }
  return result;
}
// 10134724: using guessed type int dword_10134724;
// 10134728: using guessed type int dword_10134728;
// 1013472C: using guessed type int dword_1013472C;
// 10134730: using guessed type int dword_10134730;
// 10134734: using guessed type char byte_10134734;
// 101E37B8: using guessed type int dword_101E37B8;
// 101E4114: using guessed type char byte_101E4114;

//----- (10022E00) --------------------------------------------------------
unsigned __int8 sub_10022E00()
{
  unsigned __int8 result; // al@1
  unsigned int v1; // edx@2
  char *v2; // ecx@2
  char *v3; // esi@2
  int v4; // edi@6
  int v5; // edx@7
  _BYTE *v6; // ecx@7
  _BYTE *v7; // esi@7
  int v8; // edx@9
  _BYTE *v9; // ecx@9
  _BYTE *v10; // esi@9
  _BYTE *v11; // ecx@11
  _BYTE *v12; // esi@11
  signed int v13; // ecx@13
  char v14; // [sp+0h] [bp-18h]@1

  sub_10022D10((int)&v14);
  result = 0;
  do
  {
    v1 = 10;
    v2 = &a006D0170[11 * result];
    v3 = &v14;
    do
    {
      if ( *(_DWORD *)v3 != *(_DWORD *)v2 )
        goto LABEL_6;
      v1 -= 4;
      v2 += 4;
      v3 += 4;
    }
    while ( v1 >= 4 );
    if ( !v1 )
    {
LABEL_15:
      v13 = 0;
      goto LABEL_16;
    }
LABEL_6:
    v4 = (unsigned __int8)*v3 - (unsigned __int8)*v2;
    if ( (unsigned __int8)*v3 == (unsigned __int8)*v2 )
    {
      v5 = v1 - 1;
      v6 = v2 + 1;
      v7 = v3 + 1;
      if ( !v5 )
        goto LABEL_15;
      v4 = *v7 - *v6;
      if ( *v7 == *v6 )
      {
        v8 = v5 - 1;
        v9 = v6 + 1;
        v10 = v7 + 1;
        if ( !v8 )
          goto LABEL_15;
        v4 = *v10 - *v9;
        if ( *v10 == *v9 )
        {
          v11 = v9 + 1;
          v12 = v10 + 1;
          if ( v8 == 1 )
            goto LABEL_15;
          v4 = *v12 - *v11;
          if ( *v12 == *v11 )
            goto LABEL_15;
        }
      }
    }
    v13 = 1;
    if ( v4 <= 0 )
      v13 = -1;
LABEL_16:
    if ( !v13 )
      break;
    ++result;
  }
  while ( result < 3u );
  return result;
}

//----- (10022ED0) --------------------------------------------------------
char sub_10022ED0()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_101E4114 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_101E37B8)(147, 12, &v17);
  byte_101E4114 = 1;
  dword_10134724 = 0;
  dword_10134728 = 0;
  dword_1013472C = 0;
  dword_10134730 = 0;
  byte_10134734 = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_101E38C0, 0, 0x708u);
  sub_10022C90((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_101E38C0, 0, 0x708u);
  }
  byte_101E4114 = 0;
  sub_10022A90(&v16);
  if ( v16 != 101 )
  {
    byte_101E4114 = 2;
    return (unsigned int)memset(dword_101E38C0, 0, 0x708u);
  }
  if ( byte_101E4114 )
    return (unsigned int)memset(dword_101E38C0, 0, 0x708u);
  sub_10022B10(&unk_101E3FC8, &byte_101E410D);
  byte_101E410C = byte_101E410D - 1;
  if ( byte_101E4114 )
    return (unsigned int)memset(dword_101E38C0, 0, 0x708u);
  result = sub_10022AC0(&unk_101E3FC9, &unk_101E3FCA);
  byte_101E38B0 = 0;
  if ( byte_101E4114 )
    return (unsigned int)memset(dword_101E38C0, 0, 0x708u);
  return result;
}
// 10134724: using guessed type int dword_10134724;
// 10134728: using guessed type int dword_10134728;
// 1013472C: using guessed type int dword_1013472C;
// 10134730: using guessed type int dword_10134730;
// 10134734: using guessed type char byte_10134734;
// 101E37B8: using guessed type int dword_101E37B8;
// 101E38B0: using guessed type char byte_101E38B0;
// 101E38C0: using guessed type int dword_101E38C0[];
// 101E410C: using guessed type char byte_101E410C;
// 101E410D: using guessed type char byte_101E410D;
// 101E4114: using guessed type char byte_101E4114;

//----- (10023090) --------------------------------------------------------
int (__cdecl *(*sub_10023090())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_101E37A8 = (int)off_100AC5D0;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_101E37B8)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_10022C90((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_10099ED0)[8 * v1];
      v3 = strlen((&off_10099ED0)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_10099ED4)[v1];
        dword_101E37A8 = (int)(&off_10099ED4)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 10099ED0: using guessed type char *off_10099ED0;
// 10099ED4: using guessed type int (__cdecl *(*off_10099ED4)[2])(int, int);
// 100AC5D0: using guessed type int (__cdecl *off_100AC5D0[2])(int, int);
// 101E37A8: using guessed type int dword_101E37A8;
// 101E37B8: using guessed type int dword_101E37B8;

//----- (100231C0) --------------------------------------------------------
int __cdecl sub_100231C0(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (100231E0) --------------------------------------------------------
char __cdecl sub_100231E0(char a1)
{
  char result; // al@1

  result = sub_10032B70();
  if ( result == 2 )
    result = byte_1009A44C[8 * sub_1001E3C0(&a1, 4u, (int)&unk_1009A448, 8, 7, 7)];
  return result;
}

//----- (10023210) --------------------------------------------------------
char __thiscall sub_10023210(void *this)
{
  char v1; // al@1

  v1 = sub_1001FF60(this);
  return sub_100231E0(v1);
}

//----- (10023270) --------------------------------------------------------
int __cdecl sub_10023270(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_10047750(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (10023370) --------------------------------------------------------
signed int __cdecl sub_10023370(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10023410) --------------------------------------------------------
int __cdecl sub_10023410(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 0xDu, 0xDu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10023440) --------------------------------------------------------
int __cdecl sub_10023440(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 8u, 8u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10023470) --------------------------------------------------------
int __cdecl sub_10023470(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 9u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100234A0) --------------------------------------------------------
int __cdecl sub_100234A0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 5u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100234D0) --------------------------------------------------------
int __cdecl sub_100234D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 8u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10023500) --------------------------------------------------------
int __cdecl sub_10023500(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 0x14u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10023530) --------------------------------------------------------
int __cdecl sub_10023530(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 6u, 6u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10023560) --------------------------------------------------------
int __cdecl sub_10023560(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 7u, 7u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10023590) --------------------------------------------------------
int __cdecl sub_10023590(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 0xFu, 0xFu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100235C0) --------------------------------------------------------
int __cdecl sub_100235C0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 0xEu, 0xEu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100235F0) --------------------------------------------------------
int __cdecl sub_100235F0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 0xBu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10023620) --------------------------------------------------------
int __cdecl sub_10023620(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 3u, 3u, 0);
}

//----- (10023640) --------------------------------------------------------
int __cdecl sub_10023640(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 3u, 3u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10023670) --------------------------------------------------------
int __cdecl sub_10023670(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 0x13u, 0x13u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100236A0) --------------------------------------------------------
int __cdecl sub_100236A0(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 2u, 2u, 0);
}

//----- (100236C0) --------------------------------------------------------
int __cdecl sub_100236C0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 2u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (100236F0) --------------------------------------------------------
unsigned int __cdecl sub_100236F0(char *a1)
{
  return sub_10030330(a1, -100, 100, 0, 0);
}

//----- (10023710) --------------------------------------------------------
int __cdecl sub_10023710(_BYTE *a1)
{
  return sub_10030590(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (10023730) --------------------------------------------------------
int __cdecl sub_10023730(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 1u, 1u, 0);
}

//----- (10023750) --------------------------------------------------------
int __cdecl sub_10023750(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_100304A0(a1, 0, 3u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10023780) --------------------------------------------------------
unsigned int __cdecl sub_10023780(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100301F0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_100304A0((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_100301F0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100304A0((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100304A0((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10023AB0) --------------------------------------------------------
unsigned int __cdecl sub_10023AB0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_100301F0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030330((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10023EF0) --------------------------------------------------------
unsigned int __cdecl sub_10023EF0(_BYTE *a1)
{
  return sub_10030380(a1, -1, 5, -1, 0);
}

//----- (10023F10) --------------------------------------------------------
int __cdecl sub_10023F10(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 5u, 0, 0);
}

//----- (10023F30) --------------------------------------------------------
int __cdecl sub_10023F30(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 4u, 2u, 0);
}

//----- (10023F50) --------------------------------------------------------
int __cdecl sub_10023F50(_BYTE *a1)
{
  return sub_10030590(a1, 0, 2u, 0, 0);
}

//----- (10023F70) --------------------------------------------------------
int __cdecl sub_10023F70(int a1)
{
  return sub_10030240(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (10023FC0) --------------------------------------------------------
int __cdecl sub_10023FC0(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_10023F70((int)(a1 + 4));
  if ( !result )
    result = sub_10023F30(a1);
  return result;
}

//----- (10023FE0) --------------------------------------------------------
int __cdecl sub_10023FE0(int a1)
{
  int result; // eax@1

  result = sub_10023F10((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_10023F10((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_10023F10((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10032C00((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_100301F0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_100301F0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_100301F0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_100301F0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10024070) --------------------------------------------------------
unsigned int __cdecl sub_10024070(int a1)
{
  unsigned int result; // eax@1

  result = sub_10023EF0((_BYTE *)a1);
  if ( !result )
    result = sub_10023EF0((_BYTE *)(a1 + 4));
  return result;
}

//----- (10024090) --------------------------------------------------------
signed int __cdecl sub_10024090(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_100301F0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_100301F0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (100240E0) --------------------------------------------------------
unsigned int __cdecl sub_100240E0(int a1)
{
  unsigned int result; // eax@1

  result = sub_10023EF0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10023EF0((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_10023EF0((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_10023EF0((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_100301F0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (10024140) --------------------------------------------------------
int __cdecl sub_10024140(_BYTE *a1)
{
  return sub_10030590(a1, 0, 0x20u, 2u, 0);
}

//----- (10024160) --------------------------------------------------------
unsigned int __cdecl sub_10024160(_BYTE *a1)
{
  return sub_10030380(a1, -1, 4, -1, 0);
}

//----- (10024180) --------------------------------------------------------
int __cdecl sub_10024180(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 9u, 0, 0);
}

//----- (100241A0) --------------------------------------------------------
int __cdecl sub_100241A0(_BYTE *a1)
{
  return sub_10030590(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (100241C0) --------------------------------------------------------
signed int __cdecl sub_100241C0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10030590(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100241F0) --------------------------------------------------------
int __cdecl sub_100241F0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_100304F0(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10024230) --------------------------------------------------------
signed int __cdecl sub_10024230(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_100304F0(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10024260) --------------------------------------------------------
int __cdecl sub_10024260(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_100241C0((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_100241F0((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100241F0((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10020FD0((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100241F0((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100242F0) --------------------------------------------------------
int __cdecl sub_100242F0(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 2u, 0, 0);
}

//----- (10024310) --------------------------------------------------------
int __cdecl sub_10024310(int a1)
{
  int result; // eax@1

  result = sub_100304A0((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_100304A0((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (10024340) --------------------------------------------------------
int __cdecl sub_10024340(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 3u, 1u, 0);
}

//----- (10024360) --------------------------------------------------------
unsigned int __cdecl sub_10024360(int a1)
{
  unsigned int result; // eax@1

  result = sub_10030380((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_10030380((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (10024390) --------------------------------------------------------
int __cdecl sub_10024390(int a1)
{
  int result; // eax@1

  result = sub_10030240(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_10030240(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10030240(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_10030240(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_10030240(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10024480) --------------------------------------------------------
int __cdecl sub_10024480(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100301F0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_100304A0((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_10024360(a1 + 36);
        if ( !result )
        {
          result = sub_10030240(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_10024390(a1 + 8);
            if ( !result )
            {
              result = sub_10024360(a1 + 28);
              if ( !result )
              {
                result = sub_100304F0((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_100242F0((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_10024310(a1 + 57);
                    if ( !result )
                    {
                      result = sub_100301F0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_10024340((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (10024590) --------------------------------------------------------
signed int __cdecl sub_10024590(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_100304A0(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (100245C0) --------------------------------------------------------
signed int __cdecl sub_100245C0(int a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@9

  v2 = 0;
  if ( sub_10024590((unsigned __int8 *)(a1 + 15), a2) == 1 )
    v2 = 1;
  if ( sub_10024590((unsigned __int8 *)(a1 + 34), a2) == 1 )
    v2 = 1;
  if ( sub_10024590((unsigned __int8 *)(a1 + 38), a2) == 1 )
    v2 = 1;
  if ( sub_10024590((unsigned __int8 *)(a1 + 36), a2) == 1 )
    v2 = 1;
  result = sub_100301F0((_BYTE *)(a1 + 33), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023440((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023410((unsigned __int8 *)(a1 + 48), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100234D0((unsigned __int8 *)(a1 + 46), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023410((unsigned __int8 *)(a1 + 47), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023500((unsigned __int8 *)(a1 + 45), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023470((unsigned __int8 *)(a1 + 44), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023410((unsigned __int8 *)(a1 + 28), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023750((unsigned __int8 *)(a1 + 51), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100235F0((unsigned __int8 *)(a1 + 31), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10032CC0((_BYTE *)(a1 + 20), a2) == 1 )
    v2 = 1;
  result = sub_100234A0((unsigned __int8 *)(a1 + 50), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023410((unsigned __int8 *)(a1 + 24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023530((unsigned __int8 *)(a1 + 5), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023410((unsigned __int8 *)(a1 + 25), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023560((unsigned __int8 *)(a1 + 6), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023410((unsigned __int8 *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023590((unsigned __int8 *)(a1 + 3), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030240(a1 + 40, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023410((unsigned __int8 *)(a1 + 26), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023440((unsigned __int8 *)(a1 + 9), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023410((unsigned __int8 *)(a1 + 8), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100235C0((unsigned __int8 *)(a1 + 7), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100235F0((unsigned __int8 *)(a1 + 1), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023640((unsigned __int8 *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023640((unsigned __int8 *)(a1 + 10), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 37), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023670((unsigned __int8 *)(a1 + 11), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023410((unsigned __int8 *)(a1 + 12), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100301F0((_BYTE *)(a1 + 32), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_100234A0((unsigned __int8 *)(a1 + 49), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030240(a1 + 16, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10023640((unsigned __int8 *)(a1 + 35), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10024AD0) --------------------------------------------------------
int __cdecl sub_10024AD0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10030590(a1, 0, 0x3FFFFu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10024B00) --------------------------------------------------------
signed int __cdecl sub_10024B00(_BYTE *a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@1

  v2 = 0;
  result = sub_100301F0(a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10030240((int)(a1 + 4), -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (10024B70) --------------------------------------------------------
int __cdecl sub_10024B70(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 0x64u, 0x64u, 0);
}

//----- (10024BD0) --------------------------------------------------------
int __cdecl sub_10024BD0(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_100301F0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_10024B70((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (10024BE0) --------------------------------------------------------
signed int __cdecl sub_10024BE0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10030590(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10024C10) --------------------------------------------------------
int __cdecl sub_10024C10(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_100304A0((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_100304A0((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (10024C90) --------------------------------------------------------
int __cdecl sub_10024C90(int a1)
{
  int result; // eax@1

  result = sub_100236A0((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_10020FB0((_BYTE *)(a1 + 24));
    if ( !result )
    {
      result = sub_100301F0((_BYTE *)(a1 + 1), 0, 0);
      if ( !result )
      {
        result = sub_100301F0((_BYTE *)(a1 + 2), 0, 0);
        if ( !result )
          result = sub_10030240(a1 + 20, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (10024D10) --------------------------------------------------------
unsigned int __cdecl sub_10024D10(int a1)
{
  unsigned int result; // eax@1

  result = sub_100236F0((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_100236F0((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_100236F0((char *)a1);
      if ( !result )
        result = sub_100236F0((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (10024D50) --------------------------------------------------------
unsigned int __cdecl sub_10024D50(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_10024D10(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_100242F0((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_10023730((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (10024DA0) --------------------------------------------------------
int __cdecl sub_10024DA0(int a1)
{
  int result; // eax@1

  result = sub_10023710((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_100304F0((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (10024DD0) --------------------------------------------------------
int __cdecl sub_10024DD0(int a1)
{
  int result; // eax@1

  result = sub_10023F50((_BYTE *)a1);
  if ( !result )
    result = sub_100241A0((_BYTE *)(a1 + 4));
  return result;
}

//----- (10024E00) --------------------------------------------------------
unsigned int __cdecl sub_10024E00(int a1)
{
  unsigned int result; // eax@1

  result = sub_10023EF0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10023EF0((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_10024160((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (10024E30) --------------------------------------------------------
unsigned int __cdecl sub_10024E30(int a1)
{
  unsigned int result; // eax@1

  result = sub_10023EF0((_BYTE *)a1);
  if ( !result )
    result = sub_10024180((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (10024E50) --------------------------------------------------------
unsigned int __cdecl sub_10024E50(int a1)
{
  unsigned int result; // eax@1

  result = sub_10023EF0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_100304A0((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_10024160((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (10024E90) --------------------------------------------------------
void __cdecl __noreturn sub_10024E90(int a1)
{
  exit(a1 + 4);
}

//----- (10025000) --------------------------------------------------------
signed int __cdecl sub_10025000(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_10024590((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_10024230((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_10024590((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (10025050) --------------------------------------------------------
int __cdecl sub_10025050(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_10024AD0((_BYTE *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10024B00((_BYTE *)(a1 + 4), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (100250B0) --------------------------------------------------------
int __usercall sub_100250B0@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>)
{
  unsigned __int8 *v2; // esi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_100236C0(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( *v2 == 1 )
    result = sub_10025050((int)(v2 + 4), a2);
  else
    result = sub_100245C0((int)(v2 + 4), a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (10025100) --------------------------------------------------------
signed int __usercall sub_10025100@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_10025000(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_100304A0((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_100301F0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_10023AB0(v2 + 5, a2);
    else
      result = sub_10023780(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_10024BE0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (100251D0) --------------------------------------------------------
int __cdecl sub_100251D0(unsigned __int8 *a1)
{
  return sub_100250B0(a1, 0);
}

//----- (100251E0) --------------------------------------------------------
signed int __cdecl sub_100251E0(int a1)
{
  return sub_10025100(a1, 0);
}

//----- (100251F0) --------------------------------------------------------
char __cdecl sub_100251F0(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10004C50("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10025230) --------------------------------------------------------
signed int __cdecl sub_10025230(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_10004C50("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (10025270) --------------------------------------------------------
int __cdecl sub_10025270(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 1005B7D0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (100252E0) --------------------------------------------------------
bool __cdecl sub_100252E0(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_1001D9E0(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_1009D818[(unsigned __int8)v4](v3) )
    {
      sub_10025270((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10025490(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_1001EC40(2) )
    result = 0;
  else
    result = sub_1001F8E0(2, v5, a2) == 1 && !sub_10032CF0(a2);
  return result;
}
// 1009D818: using guessed type int (__cdecl *off_1009D818[3])(char);

//----- (100253A0) --------------------------------------------------------
char __cdecl sub_100253A0(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_100252E0(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10025470(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (10025460) --------------------------------------------------------
signed int __fastcall sub_10025460(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10025470) --------------------------------------------------------
char __cdecl sub_10025470(unsigned __int8 a1)
{
  return byte_1009D83C[6 * sub_10025460(a1)];
}

//----- (10025490) --------------------------------------------------------
__int16 __cdecl sub_10025490(unsigned __int8 a1)
{
  return word_1009D838[3 * sub_10025460(a1)];
}
// 1009D838: using guessed type __int16 word_1009D838[];

//----- (100254B0) --------------------------------------------------------
char *__cdecl sub_100254B0(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_10065D59;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10025500) --------------------------------------------------------
int sub_10025500()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10004D80();
  result = 0;
  while ( 1 )
  {
    v3 = dword_10134964[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_10134964[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 10134964: using guessed type int dword_10134964[];

//----- (10025540) --------------------------------------------------------
int __cdecl sub_10025540(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100255B0) --------------------------------------------------------
signed int __cdecl sub_100255B0(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10025650) --------------------------------------------------------
int __usercall sub_10025650@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_100255B0(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10025680) --------------------------------------------------------
signed int __usercall sub_10025680@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_100255B0((_BYTE *)a3, (int)(&off_1009E180)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_1009E184[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_1004A2F9(a3, (int)"%ld", (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_1004A2F9(a3, (int)"%lu", (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_1004A2F9(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 1009E180: using guessed type char *off_1009E180;

//----- (10025850) --------------------------------------------------------
char *__usercall sub_10025850@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, word_10060D0C, 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (100258B0) --------------------------------------------------------
int __usercall sub_100258B0@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_100255B0((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10025940) --------------------------------------------------------
int __usercall sub_10025940@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10025650(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10025990) --------------------------------------------------------
char **__usercall sub_10025990@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_100254B0(v6);
      if ( !sub_100255B0((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (100259F0) --------------------------------------------------------
const char *__usercall sub_100259F0@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10025A10) --------------------------------------------------------
int __usercall sub_10025A10@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_10134950[sub_10025500()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10134950: using guessed type int dword_10134950[];

//----- (10025A50) --------------------------------------------------------
int __usercall sub_10025A50@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10025680(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10025AE0) --------------------------------------------------------
int __usercall sub_10025AE0@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10025C30) --------------------------------------------------------
int __usercall sub_10025C30@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_10027980(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_10026510(v3, v6, 0);
        v7 = -*v3;
        sub_10027980(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_10027980(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_1009DE38);
      sub_10032D50(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_1009DE38);
      sub_10027980(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10025CD0) --------------------------------------------------------
int __usercall sub_10025CD0@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10025D10) --------------------------------------------------------
char *__cdecl sub_10025D10(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10025850(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10025850(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10025850(result, v5, (int)&v20);
      v10 = (const char *)&unk_10065D59;
    }
    LOBYTE(v9) = 0;
    sub_10025850(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10025850(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10025850(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10025850(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10027910(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10025D10: using guessed type int var_61C[6];

//----- (10025EC0) --------------------------------------------------------
int __usercall sub_10025EC0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_100254B0((char **)a1);
  result = sub_100279A0(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_1009DE38);
  return result;
}

//----- (10025EF0) --------------------------------------------------------
int __usercall sub_10025EF0@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_1009DE38);
  v2 = (unsigned int)sub_100254B0((char **)a1);
  return sub_10027980(10, v2);
}

//----- (10025F20) --------------------------------------------------------
void __cdecl sub_10025F20(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_100254B0(v5);
            v7 = sub_100254B0((char **)v3);
            if ( !sub_10025540(v7, (int)v6) )
            {
              v8 = sub_100254B0((char **)v3);
              sub_10027A40(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_100254B0((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_100254B0((char **)v3);
        sub_10027A40(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_100259F0(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_10028460("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_100254B0((char **)v3);
            sub_10027A80(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_10025540(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_100259F0(v18);
                  v25 = sub_10028460("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_100254B0((char **)v3);
                  sub_10027A80(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_100254B0((char **)v3);
                  sub_10027A80(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_100254B0((char **)v3);
              sub_10027A80(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_100254B0((char **)v3);
              sub_10027A80(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_100254B0((char **)v3);
              sub_10027A80(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_10025F20(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_100254B0((char **)v3);
            sub_10027A80(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_100254B0((char **)v3);
            sub_10027A80(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_100254B0((char **)v3);
          sub_10027A80(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_100254B0((char **)v3);
        sub_10027A80(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_100254B0(a2);
      sub_10027A40(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10026390) --------------------------------------------------------
int sub_10026390()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_10134950[sub_10025500()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_10025F20(i, 0, &v2);
  }
  return v2;
}
// 10134950: using guessed type int dword_10134950[];

//----- (100263E0) --------------------------------------------------------
void *sub_100263E0()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_10134950[0] = 0;
  dword_10134954 = 0;
  dword_10134958 = 0;
  dword_1013495C = 0;
  dword_10134960 = 0;
  result = &unk_10134978;
  dword_10134964[0] = -1;
  dword_10134968 = -1;
  dword_1013496C = -1;
  dword_10134970 = -1;
  dword_10134974 = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10025CD0((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 10134950: using guessed type int dword_10134950[];
// 10134954: using guessed type int dword_10134954;
// 10134958: using guessed type int dword_10134958;
// 1013495C: using guessed type int dword_1013495C;
// 10134960: using guessed type int dword_10134960;
// 10134964: using guessed type int dword_10134964[];
// 10134968: using guessed type int dword_10134968;
// 1013496C: using guessed type int dword_1013496C;
// 10134970: using guessed type int dword_10134970;
// 10134974: using guessed type int dword_10134974;

//----- (10026440) --------------------------------------------------------
char *sub_10026440()
{
  return (char *)&unk_10134978 + 56 * sub_10025500();
}

//----- (10026460) --------------------------------------------------------
char sub_10026460()
{
  return sub_10026440()[33];
}

//----- (10026470) --------------------------------------------------------
char __cdecl sub_10026470(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_10026440();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_10027500(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (100264B0) --------------------------------------------------------
int *__usercall sub_100264B0@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_10026440() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_100255B0((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (10026500) --------------------------------------------------------
char **sub_10026500()
{
  return &off_1009E1E8;
}
// 1009E1E8: using guessed type char *off_1009E1E8;

//----- (10026510) --------------------------------------------------------
int __cdecl sub_10026510(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1002C6D0();
  v3 = sub_10026440();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10026390();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10025EC0(a2);
    if ( a3 )
    {
      v7 = sub_10025C30(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10025C30(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10025EF0(a2);
        return v7;
      }
    }
    sub_10025EF0(a2);
    result = v7;
  }
  return result;
}

//----- (100265C0) --------------------------------------------------------
int __cdecl sub_100265C0(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10025850(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10025850(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10025850(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10027910(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10025850(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10025850(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10025850(v14, "group-begin", (int)&v29);
          sub_10027910(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_100254B0(v15);
          sub_100265C0(v16[2], v16[3], v16[4], v17, a4);
          sub_100254B0(v16);
          v18 = sub_10025D10((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10025850(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10025850(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10025850(v20, "group-end", (int)&v29);
          result = sub_10027910(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10025850(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10025850(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10025850(v21, a4, (int)&v28);
          v23 = (const char *)&unk_10065D59;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10025850(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10025850(v24, *(const char **)v5, (int)&v30);
        result = sub_10027910(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 100265C0: using guessed type int var_414[4];

//----- (100267D0) --------------------------------------------------------
char *__usercall sub_100267D0@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10025850(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10025850(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10027910(2, (int)v11, 2);
  if ( a6 )
  {
    sub_100265C0(a3, (int)a4, a5, a2, 0);
    result = sub_10025D10(a3, a4, a5, 0);
  }
  return result;
}
// 100267D0: using guessed type int var_20C[2];

//----- (10026890) --------------------------------------------------------
char *__cdecl sub_10026890(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_10134950[sub_10025500()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_100254B0((char **)v2);
    sub_100267D0("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_10026440() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_100267D0(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 10134950: using guessed type int dword_10134950[];

//----- (10026930) --------------------------------------------------------
int *__cdecl sub_10026930(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_10134950[sub_10025500()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_100254B0(v2);
      if ( !sub_100255B0(a1, (int)v4) )
      {
        v5 = sub_100254B0(v3);
        sub_100267D0("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_10026440();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_100255B0(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_100267D0(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 10134950: using guessed type int dword_10134950[];

//----- (100269F0) --------------------------------------------------------
int __usercall sub_100269F0@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10025A10(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_10026510((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10025A10(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_10026510((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10025EC0(v5);
        sub_10025C30(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10025EF0(v8);
          v10 = sub_10025A10(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10026B50) --------------------------------------------------------
signed int __usercall sub_10026B50@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_10134950[sub_10025500()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_10026510((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 10134950: using guessed type int dword_10134950[];

//----- (10026BC0) --------------------------------------------------------
int __cdecl sub_10026BC0(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_10026440();
  switch ( a1 )
  {
    case 9:
      sub_10027980(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_100255B0((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_100255B0(v6, (int)"-q") )
            {
              sub_10026930(v6);
              v9 = sub_10026390();
              sub_10027980(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10026890(0);
              v8 = sub_10026390();
              sub_10027980(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10026890(1);
            v7 = sub_10026390();
            sub_10027980(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10027A00(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_10027980(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10026890(0);
        v4 = sub_10026390();
        sub_10027980(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_10027980(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_10134950[sub_10025500()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10026BC0 )
              v12(2, (int)&unk_1009DE38);
          }
        }
      }
      sub_1002C6D0();
      v3[34] = 0;
      return 0;
    case 3:
      sub_10027980(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_10134950[sub_10025500()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10027A00(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_100269F0((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10027A00(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10026B50((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10027A00(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10026BC0 )
          v15(3, (int)&unk_1009DE38);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10026BC0: using guessed type int __cdecl sub_10026BC0(int, int);
// 10134950: using guessed type int dword_10134950[];

//----- (10026EA0) --------------------------------------------------------
char **sub_10026EA0()
{
  return off_1009DFDC;
}
// 1009DFDC: using guessed type char *off_1009DFDC[3];

//----- (10026EB0) --------------------------------------------------------
int __usercall sub_10026EB0@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10025940(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10025A50(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_10026EA0();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (10026FA0) --------------------------------------------------------
int __cdecl sub_10026FA0(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_10026440();
  *a1 = 0;
  v4 = sub_10028460("Processing command '%s'", v2);
  sub_10027A00(3, (int)&unk_1009E988, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10025AE0(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_100269F0((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10026B50((int)v3);
    v11 = 0;
    v6 = sub_10025500();
    v7 = sub_10025990((int (**)(void))dword_10134950[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_100258B0((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_100258B0((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10026510(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10026510(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_10026EB0(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_100264B0(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_10026EB0(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_10026EA0();
        result = sub_10026EB0(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 10134950: using guessed type int dword_10134950[];
// 10026FA0: using guessed type char var_2D4[720];

//----- (100271E0) --------------------------------------------------------
int sub_100271E0()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_10026FA0(&v4);
  if ( !sub_10026440()[32] )
    sub_10027980(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_10028460("%s %i, %s", "Command status:", v0, &v4);
    sub_10027A00(3, (int)&unk_1009E988, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_10028460("%s %i", "Command status:", v0);
    sub_10027A00(3, (int)&unk_1009E988, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (100272C0) --------------------------------------------------------
int __cdecl sub_100272C0(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_10134950[sub_10025500()] = a1;
  sub_10026440()[32] = a3;
  sub_1002C6D0();
  sub_10032F60(a2);
  v3 = sub_10026500();
  sub_100273F0(v3);
  return sub_100271E0();
}
// 10134950: using guessed type int dword_10134950[];

//----- (10027310) --------------------------------------------------------
int __cdecl sub_10027310(int a1)
{
  return a1 + 9;
}

//----- (10027320) --------------------------------------------------------
int __cdecl sub_10027320(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10004D80();
  memset(a1, 0, 0xDCu);
  sub_1001E330((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_10027310(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_100330F0((int)a1, (int)v3);
}

//----- (100273A0) --------------------------------------------------------
int __cdecl sub_100273A0(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_10033300(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (100273D0) --------------------------------------------------------
signed int __cdecl sub_100273D0(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_1005B8D0(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_10004DF0();
    }
    else if ( v6 != -57 || (unsigned int)(sub_10004DF0() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_100330F0(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (100273F0) --------------------------------------------------------
char __cdecl sub_100273F0(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_10026440() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10032DA0("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_100271E0() )
          v7 = 0;
      }
      v5 = sub_10032DA0("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_100271E0() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (10027500) --------------------------------------------------------
char __cdecl sub_10027500(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (10027530) --------------------------------------------------------
bool __cdecl sub_10027530(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (10027560) --------------------------------------------------------
bool __cdecl sub_10027560(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10027590) --------------------------------------------------------
bool __cdecl sub_10027590(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (100275C0) --------------------------------------------------------
bool __cdecl sub_100275C0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (100275F0) --------------------------------------------------------
bool __cdecl sub_100275F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (10027620) --------------------------------------------------------
bool __cdecl sub_10027620(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (10027660) --------------------------------------------------------
bool __cdecl sub_10027660(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (100276A0) --------------------------------------------------------
bool __cdecl sub_100276A0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (100276D0) --------------------------------------------------------
bool __cdecl sub_100276D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (10027700) --------------------------------------------------------
char __cdecl sub_10027700(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (10027730) --------------------------------------------------------
bool __cdecl sub_10027730(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (10027760) --------------------------------------------------------
bool __cdecl sub_10027760(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10027790) --------------------------------------------------------
bool __cdecl sub_10027790(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (100277C0) --------------------------------------------------------
bool __cdecl sub_100277C0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (100277F0) --------------------------------------------------------
bool __cdecl sub_100277F0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_1009E988, 9u);
}

//----- (10027820) --------------------------------------------------------
bool __cdecl sub_10027820(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10027850) --------------------------------------------------------
bool __cdecl sub_10027850(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (10027880) --------------------------------------------------------
bool __cdecl sub_10027880(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (100278B0) --------------------------------------------------------
bool __cdecl sub_100278B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (100278E0) --------------------------------------------------------
bool __cdecl sub_100278E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10027910) --------------------------------------------------------
int __cdecl sub_10027910(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_10026440() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10027980) --------------------------------------------------------
int __cdecl sub_10027980(int a1, char a2)
{
  return sub_10027910(a1, (int)&a2, 1);
}

//----- (100279A0) --------------------------------------------------------
int __cdecl sub_100279A0(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10027910(a1, (int)&v4, 2);
}

//----- (100279D0) --------------------------------------------------------
int __cdecl sub_100279D0(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10027910(a1, (int)&v5, 3);
}

//----- (10027A00) --------------------------------------------------------
int __cdecl sub_10027A00(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10027910(a1, (int)&v6, 4);
}

//----- (10027A40) --------------------------------------------------------
int __cdecl sub_10027A40(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10027910(a1, (int)&v7, 5);
}

//----- (10027A80) --------------------------------------------------------
int __cdecl sub_10027A80(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10027910(a1, (int)&v8, 6);
}

//----- (10027AD0) --------------------------------------------------------
char __cdecl sub_10027AD0(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_10026440();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10027B00) --------------------------------------------------------
char __cdecl sub_10027B00(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10027B10) --------------------------------------------------------
char __cdecl sub_10027B10(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = (const char *)&unk_10065D59;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_10033420(v16) )
        sub_10033400((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10033430((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 10033420: using guessed type _DWORD __cdecl sub_10033420(_DWORD);
// 10027B10: using guessed type char var_104[255];

//----- (10027C90) --------------------------------------------------------
signed int __cdecl sub_10027C90(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (10027CD0) --------------------------------------------------------
signed int __cdecl sub_10027CD0(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10027D70) --------------------------------------------------------
char __cdecl sub_10027D70(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (10027DD0) --------------------------------------------------------
char __cdecl sub_10027DD0(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_100333E0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (10027E40) --------------------------------------------------------
char *__cdecl sub_10027E40(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_10134A90, v1, v2);
  *(&byte_10134A90 + v2) = 0;
  return &byte_10134A90;
}

//----- (10027EE0) --------------------------------------------------------
int __cdecl sub_10027EE0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (10027F50) --------------------------------------------------------
bool __cdecl sub_10027F50(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_1004A2F9(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_1004A2F9(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (10027FE0) --------------------------------------------------------
char __cdecl sub_10027FE0(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (10028090) --------------------------------------------------------
char __cdecl sub_10028090(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (100280A0) --------------------------------------------------------
char __cdecl sub_100280A0(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_100333E0(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (10028120) --------------------------------------------------------
int (__cdecl *__cdecl sub_10028120(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_100334B0((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (10028170) --------------------------------------------------------
signed int __cdecl sub_10028170(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_100280A0(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (100281C0) --------------------------------------------------------
char *__cdecl sub_100281C0(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10032DA0("CFG_ActDir", (int)&unk_10065D59);
      v10 = sub_10032DA0("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10032DA0("CFG_ExpDir", (int)&unk_10065D59);
      v10 = sub_10032DA0("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10032DA0("CFG_ActDir", (int)&unk_10065D59);
      break;
    case 4:
      v10 = sub_10032DA0("CFG_ExpDir", (int)&unk_10065D59);
      break;
    default:
      v10 = (char *)&unk_10065D59;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = (const char *)&unk_10065D59;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 100281C0: using guessed type char var_104[256];

//----- (10028340) --------------------------------------------------------
int sub_10028340()
{
  return dword_10139780[sub_10025500()];
}
// 10139780: using guessed type int dword_10139780[];

//----- (10028350) --------------------------------------------------------
const char *__cdecl sub_10028350(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_1009EBB0[a1];
  return result;
}
// 1009EBB0: using guessed type char *off_1009EBB0[7];

//----- (10028370) --------------------------------------------------------
int __cdecl sub_10028370(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10027A40(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (10028420) --------------------------------------------------------
int __cdecl sub_10028420(int a1)
{
  int result; // eax@1

  result = sub_10025500();
  dword_1013B88C[result] = a1;
  return result;
}
// 1013B88C: using guessed type int dword_1013B88C[];

//----- (10028440) --------------------------------------------------------
int __cdecl sub_10028440(int a1)
{
  int result; // eax@1

  result = sub_10025500();
  dword_10139780[result] = a1;
  return result;
}
// 10139780: using guessed type int dword_10139780[];

//----- (10028460) --------------------------------------------------------
char *sub_10028460(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10025500() << 8;
  _vsnprintf(&byte_10134B90[v1], 0x100u, a1, va);
  result = &byte_10134B90[v1];
  byte_10134C8E[v1] = 42;
  byte_10134C8F[v1] = 0;
  return result;
}

//----- (100284A0) --------------------------------------------------------
char *__usercall sub_100284A0@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_1009EBC4[a1 & 1];
  else
    result = off_1009EBBC[a2];
  return result;
}
// 1009EBBC: using guessed type char *off_1009EBBC[4];
// 1009EBC4: using guessed type char *off_1009EBC4[2];

//----- (100284C0) --------------------------------------------------------
char __usercall sub_100284C0@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10025500();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_10028340() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_1013CE80[v6];
      v12 = dword_1013CE94[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_10139794[v6];
      v12 = dword_1013B878[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 10139794: using guessed type int dword_10139794[];
// 1013B878: using guessed type int dword_1013B878[];
// 1013CE80: using guessed type int dword_1013CE80[];
// 1013CE94: using guessed type int dword_1013CE94[];

//----- (100286A0) --------------------------------------------------------
int sub_100286A0()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370");
  return 0;
}

//----- (100286C0) --------------------------------------------------------
int sub_100286C0()
{
  return nullsub_1("..\\lib\\utf\\utf_verify.c", "2396");
}

//----- (100286E0) --------------------------------------------------------
int __cdecl sub_100286E0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10025500();
  dword_1013B878[result] = a1;
  if ( a2 >= 0 )
  {
    dword_10139794[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_10028460(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10027A00(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_10139794[result] = 8;
  }
  return result;
}
// 10139794: using guessed type int dword_10139794[];
// 1013B878: using guessed type int dword_1013B878[];

//----- (10028740) --------------------------------------------------------
int __cdecl sub_10028740(int a1)
{
  return sub_100286E0(0, a1);
}

//----- (10028750) --------------------------------------------------------
int __cdecl sub_10028750(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10025500();
  dword_1013CE94[result] = a1;
  if ( a2 >= 0 )
  {
    dword_1013CE80[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_10028460(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10027A00(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_1013CE80[result] = 8;
  }
  return result;
}
// 1013CE80: using guessed type int dword_1013CE80[];
// 1013CE94: using guessed type int dword_1013CE94[];

//----- (100287B0) --------------------------------------------------------
int __cdecl sub_100287B0(int a1)
{
  return sub_10028750(0, a1);
}

//----- (100287C0) --------------------------------------------------------
bool __cdecl sub_100287C0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10026460() )
    v8 = v8 == 0;
  v9 = off_1009EB94[a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_1009EB84[v8 != 0];
  v19 = off_1009EB8C[a1];
  v18 = v10;
  v21 = sub_100284A0(0, a6);
  v22 = sub_100284A0(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_10033690();
  sub_10027910(7, (int)&v14, v11);
  sub_100336A0(v12);
  return v8;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (10028900) --------------------------------------------------------
bool __cdecl sub_10028900(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_10025500();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10026460() )
    v16 = v16 == 0;
  sub_100284C0((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_10135B80[v11], 0x400u, &v30, a6);
  byte_10135F7E[v11] = 42;
  byte_10135F7F[v11] = 0;
  v17 = sub_100284C0((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v11], 0x400u, &v30, a7);
  byte_1013637E[v11] = 42;
  byte_1013637F[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_10136380[v11];
    byte_10136380[v11] = 0;
  }
  else
  {
    v17 = sub_100284C0((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_10136380[v11];
    _snprintf(&byte_10136380[v11], 0x400u, &v30, 0);
    byte_1013677E[v11] = 42;
    byte_1013677F[v11] = 0;
  }
  v19 = off_1009EB94[a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_10135B80[v11];
  v27 = &byte_10135F80[v11];
  v13 = off_1009EB8C[a1];
  v23 = off_1009EB84[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_10033690();
  sub_10027910(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v14);
  return v16;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (10028CB0) --------------------------------------------------------
bool __cdecl sub_10028CB0(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10025500();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10026460() )
    v20 = v20 == 0;
  sub_100284C0((int)&v34, (char *)&unk_1009EE78, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_10135B80[v12], 0x400u, &v34);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v21 = sub_100284C0((int)&v34, (char *)&unk_1009EE78, 3, 0xCu, a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v34, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v13 = &byte_10136380[v12];
    v21 = sub_100284C0((int)&v34, (char *)&unk_1009EE78, 3, 0xCu, v10);
    _snprintf(&byte_10136380[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v23 = off_1009EB94[a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_10135B80[v12];
  v32 = v13;
  v17 = off_1009EB8C[a1];
  v27 = off_1009EB84[v20 != 0];
  v28 = v17;
  v31 = &byte_10135F80[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_10033690();
  sub_10027910(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v18);
  return v20;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (10029100) --------------------------------------------------------
bool __cdecl sub_10029100(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_10025500();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10026460() )
    v25 = v25 == 0;
  sub_100284C0((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_10135B80[v20], 0x400u, &v40);
  byte_10135F7E[v20] = 42;
  byte_10135F7F[v20] = 0;
  v26 = sub_100284C0((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_10135F80[v20], 0x400u, &v40, a7);
  byte_1013637E[v20] = 42;
  byte_1013637F[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_10136380[v20];
    byte_10136380[v20] = 0;
  }
  else
  {
    v21 = &byte_10136380[v20];
    v26 = sub_100284C0((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_10136380[v20], 0x400u, &v40, v28);
    byte_1013677E[v20] = 42;
    byte_1013677F[v20] = 0;
  }
  v29 = off_1009EB94[a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_10135B80[v20];
  v37 = &byte_10135F80[v20];
  v38 = v21;
  v22 = off_1009EB84[v25 != 0];
  v34 = off_1009EB8C[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_10033690();
  sub_10027910(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v23);
  return v25;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (100295C0) --------------------------------------------------------
bool __cdecl sub_100295C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v18 = sub_100284C0((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_10136380[v12];
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_1009EEAC;
  v27 = &byte_10135B80[v12];
  v28 = &byte_10135F80[v12];
  v29 = v13;
  v14 = off_1009EB84[v17 != 0];
  v25 = off_1009EB8C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (10029980) --------------------------------------------------------
bool __cdecl sub_10029980(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v13 = &byte_10136380[v12];
    v18 = sub_100284C0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10135B80[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_10135F80[v12];
  v29 = v13;
  v14 = off_1009EB8C[a1];
  v24 = off_1009EB84[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (10029D80) --------------------------------------------------------
bool __cdecl sub_10029D80(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v18 = sub_100284C0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_10136380[v12];
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_10135B80[v12];
  v28 = &byte_10135F80[v12];
  v29 = v13;
  v14 = off_1009EB84[v17 != 0];
  v25 = off_1009EB8C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002A140) --------------------------------------------------------
bool __cdecl sub_1002A140(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_10025500();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10026460() )
        v18 = v18 == 0;
      sub_100284C0((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_10135B80[3072 * v21], 0x400u, &v33, a6);
      byte_10135F7E[v13] = 42;
      byte_10135F7F[v13] = 0;
      v19 = sub_100284C0((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_10135F80[3072 * v21], 0x400u, &v33, a7);
      byte_1013637E[v13] = 42;
      byte_1013637F[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_10136380[v13];
        byte_10136380[v13] = 0;
      }
      else
      {
        v19 = sub_100284C0((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_10136380[v13];
        _snprintf(&byte_10136380[v13], 0x400u, &v33, a8);
        byte_1013677E[v13] = 42;
        byte_1013677F[v13] = 0;
      }
      v22 = off_1009EB94[a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_10135B80[3072 * v21];
      v30 = &byte_10135F80[3072 * v21];
      v15 = off_1009EB8C[a1];
      v26 = off_1009EB84[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_10033690();
      sub_10027910(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(a3, a4);
        sub_10027A00(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_100336A0(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002A680) --------------------------------------------------------
bool __cdecl sub_1002A680(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v13 = &byte_10136380[v12];
    v18 = sub_100284C0((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10135B80[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_10135F80[v12];
  v29 = v13;
  v14 = off_1009EB8C[a1];
  v24 = off_1009EB84[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002AA60) --------------------------------------------------------
bool __cdecl sub_1002AA60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%ld", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%ld", 4, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v18 = sub_100284C0((int)&v31, "%ld", 4, 0xCu, (double)a8);
    v13 = &byte_10136380[v12];
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_10135B80[v12];
  v28 = &byte_10135F80[v12];
  v29 = v13;
  v14 = off_1009EB84[v17 != 0];
  v25 = off_1009EB8C[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002AE20) --------------------------------------------------------
bool __cdecl sub_1002AE20(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v18 = sub_100284C0((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_10136380[v12];
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_1009EB84[v17 != 0];
  v25 = off_1009EB8C[a1];
  v24 = v14;
  v27 = &byte_10135B80[v12];
  v28 = &byte_10135F80[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002B1C0) --------------------------------------------------------
bool __cdecl sub_1002B1C0(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v13 = &byte_10136380[v12];
    v18 = sub_100284C0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10135B80[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_10135F80[v12];
  v29 = v13;
  v14 = off_1009EB8C[a1];
  v24 = off_1009EB84[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002B5C0) --------------------------------------------------------
bool __cdecl sub_1002B5C0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v18 = sub_100284C0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_10136380[v12];
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_1009EB84[v17 != 0];
  v25 = off_1009EB8C[a1];
  v24 = v14;
  v27 = &byte_10135B80[v12];
  v28 = &byte_10135F80[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002B960) --------------------------------------------------------
bool __cdecl sub_1002B960(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_10025500();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10026460() )
        v19 = v19 == 0;
      sub_100284C0((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_10135B80[3072 * v22];
      _snprintf(&byte_10135B80[3072 * v22], 0x400u, &v35, a6);
      byte_10135F7E[v13] = 42;
      byte_10135F7F[v13] = 0;
      v20 = sub_100284C0((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_10135F80[3072 * v22];
      _snprintf(&byte_10135F80[v13], 0x400u, &v35, a7);
      byte_1013637E[v13] = 42;
      byte_1013637F[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_10136380[v13];
        byte_10136380[v13] = 0;
      }
      else
      {
        v20 = sub_100284C0((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_10136380[v13];
        _snprintf(&byte_10136380[v13], 0x400u, &v35, a8);
        byte_1013677E[v13] = 42;
        byte_1013677F[v13] = 0;
      }
      v24 = off_1009EB94[a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_1009EB8C[a1];
      v28 = off_1009EB84[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_10033690();
      sub_10027910(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(a3, a4);
        sub_10027A00(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_100336A0(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002BF40) --------------------------------------------------------
bool __cdecl sub_1002BF40(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v13 = &byte_10136380[v12];
    v18 = sub_100284C0((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10135B80[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_10135F80[v12];
  v29 = v13;
  v14 = off_1009EB8C[a1];
  v24 = off_1009EB84[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002C330) --------------------------------------------------------
bool __cdecl sub_1002C330(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10025500();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10026460() )
    v17 = v17 == 0;
  sub_100284C0((int)&v31, "%lu", 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10135B80[v12], 0x400u, &v31, a6);
  byte_10135F7E[v12] = 42;
  byte_10135F7F[v12] = 0;
  v18 = sub_100284C0((int)&v31, "%lu", 4, 0xCu, (double)a7);
  _snprintf(&byte_10135F80[v12], 0x400u, &v31, a7);
  byte_1013637E[v12] = 42;
  byte_1013637F[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10136380[v12];
    byte_10136380[v12] = 0;
  }
  else
  {
    v18 = sub_100284C0((int)&v31, "%lu", 4, 0xCu, (double)a8);
    v13 = &byte_10136380[v12];
    _snprintf(&byte_10136380[v12], 0x400u, &v31, a8);
    byte_1013677E[v12] = 42;
    byte_1013677F[v12] = 0;
  }
  v20 = off_1009EB94[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_1009EB84[v17 != 0];
  v25 = off_1009EB8C[a1];
  v24 = v14;
  v27 = &byte_10135B80[v12];
  v28 = &byte_10135F80[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10033690();
  sub_10027910(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(a3, a4);
    sub_10027A00(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_100336A0(v15);
  return v17;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002C6D0) --------------------------------------------------------
int sub_1002C6D0()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10025500();
  sub_10028420(1);
  sub_100287B0(-1);
  result = sub_10028740(-1);
  dword_10139780[v0] = 0;
  return result;
}
// 10139780: using guessed type int dword_10139780[];

//----- (1002C700) --------------------------------------------------------
BOOL __usercall sub_1002C700@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10025500();
  sub_100336D0((int)&v13);
  sub_100336D0((int)&v14);
  sub_100336D0((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10034320((int (__cdecl *)(unsigned int))sub_100286A0, v7, (int)&v13) )
  {
    if ( sub_10034320((int (__cdecl *)(unsigned int))sub_100286A0, a2, (int)&v14) )
    {
      v9 = sub_10034190(
             dword_1013B88C[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_100286A0,
             (void (__cdecl *)(_DWORD))sub_100286C0,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_100345C0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_100337A0((void (__cdecl *)(_DWORD))sub_100286C0, (int)&v12);
  sub_100337A0((void (__cdecl *)(_DWORD))sub_100286C0, (int)&v13);
  sub_100337A0((void (__cdecl *)(_DWORD))sub_100286C0, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 1013B88C: using guessed type int dword_1013B88C[];

//----- (1002C870) --------------------------------------------------------
bool __usercall sub_1002C870@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10025500();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10026460() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1002AE20(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10026460() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_10135B80[3072 * v24], 0x400u, "%s", v9);
  byte_10135F7E[v15] = 42;
  byte_10135F7F[v15] = 0;
  _snprintf(&byte_10135F80[3072 * v24], 0x400u, "%s", v22);
  v16 = off_1009EB94[a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_1013637E[v15] = 42;
  v17 = off_1009EB84[v14 != 0];
  v18 = off_1009EB8C[a3];
  byte_1013637F[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_10135B80[3072 * v24];
  v34 = &byte_10135F80[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_10033690();
  sub_10027910(7, (int)&v26, v19);
  sub_100336A0(v20);
  return v14;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];

//----- (1002CAE0) --------------------------------------------------------
char __cdecl sub_1002CAE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10025500();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_1013B88C[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_1013CEA8[v10];
  sub_100281C0(a3, 1, a6, 0x230u, &byte_1013CEA8[v10]);
  v27 = &byte_101397A8[v10];
  sub_100281C0(a3, 2, a7, 0x230u, &byte_101397A8[v10]);
  v24 = &byte_1013AD88[v10];
  sub_100281C0(a3, 3, a6, 0x230u, &byte_1013AD88[v10]);
  v26 = &byte_1013B8A0[v10];
  sub_100281C0(a3, 4, a7, 0x230u, &byte_1013B8A0[v10]);
  _snprintf(&byte_1013C390[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_1013C390[v10];
  byte_1013C5BF[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_100281C0(a3, 0, v25, 560 - (v11 - &byte_1013C390[v10 + 1]), &byte_1013C390[v10] + v11 - &byte_1013C390[v10 + 1]);
  v13 = &byte_1013C390[v10];
  byte_1013C5BF[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_1013C38C[v10] + v13 - &byte_1013C390[v10 + 1]) = 0;
  sub_100281C0(a3, 1, (int)&byte_1013C390[v10], 0x230u, &byte_10135090[v10]);
  sub_100281C0(a3, 1, (int)&byte_1013C390[v10], 0x230u, &byte_1013A298[v10]);
  v15 = sub_1002C700(v22, v27, v21, a2 == 1, (int)&byte_10135090[v10], (const char **)&v22);
  if ( sub_10026460() )
    v15 = v15 == 0;
  v30 = off_1009EB94[a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_1009EB8C[a1];
  v34 = off_1009EB84[v15 != 0];
  v17 = dword_1013B88C[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_10033690();
  sub_10027910(7, (int)&v30, v18);
  sub_100336A0(v19);
  return v15;
}
// 1009EB84: using guessed type char *off_1009EB84[18];
// 1009EB8C: using guessed type char *off_1009EB8C[16];
// 1009EB94: using guessed type char *off_1009EB94[14];
// 1013B88C: using guessed type int dword_1013B88C[];

//----- (1002CDE0) --------------------------------------------------------
bool __cdecl sub_1002CDE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_100295C0(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (1002CE90) --------------------------------------------------------
bool __cdecl sub_1002CE90(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_1002C870(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (1002CED0) --------------------------------------------------------
const char *__cdecl sub_1002CED0(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1002CF10) --------------------------------------------------------
char __cdecl sub_1002CF10(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  void *v39; // ebx@106
  void *v40; // edi@109
  void *v41; // esi@112
  const char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  void *v51; // [sp+18h] [bp-314h]@94
  void *v52; // [sp+1Ch] [bp-310h]@97
  void *v53; // [sp+20h] [bp-30Ch]@103
  void *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10025500();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_1013D9A0 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_10028170((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_10027C90((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_10028170((int)v6, 0);
      return v5;
    case 4:
      sub_10027B10((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_10027E40((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_10028120((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_10027B00((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_10027500((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1002CED0((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_10028120((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_10028120((int)v6, v55);
        if ( v48 )
          sub_10028120((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_10028120((int)v6, v55);
        if ( v48 )
          sub_10028120((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], &word_1006E364, 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_10028120((int)v6, v55);
              if ( v48 )
                sub_10028120((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = *((_BYTE *)&v54 + v14 + 3);
          if ( v16 != 10 && v16 != 13 )
            break;
          *((_BYTE *)&v54 + --v14 + 4) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_10028120((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_10028120((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_10028120((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_10028120((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_10027D70((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_10027820((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_100278E0((const void **)a2, a3)
          || (LOBYTE(v5) = sub_10027730((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &unk_10065D59;
          else
            v51 = (void *)a2[8];
          if ( a3 <= 7 )
            v52 = &unk_10065D59;
          else
            v52 = (void *)a2[7];
          if ( a3 <= 6 )
            v54 = &unk_10065D59;
          else
            v54 = (void *)a2[6];
          if ( a3 <= 5 )
            v53 = &unk_10065D59;
          else
            v53 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &unk_10065D59;
          }
          else
          {
            v38 = a2;
            v39 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &unk_10065D59;
          else
            v40 = (void *)v38[3];
          if ( a3 )
            v41 = (void *)*v38;
          else
            v41 = &unk_10065D59;
          v10 = sub_100277F0((const void **)a2, a3) == 0;
          v42 = (const char *)&unk_10065D59;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_10027530((const void **)a2, a3) )
      {
        dword_1013D998 = 2;
        sub_10028120((int)v6, (const char *)&word_1009FE94);
        sub_10028120((int)v6, "   Command Format:\r\n");
        sub_10028120(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_10028120(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_10028120(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_10028120(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_10028120((int)v6, "                                         strings depending upon the command\r\n");
        sub_10028120((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_10028120(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_10028120(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_10028120((int)v6, (const char *)&word_1009FE94);
        sub_10028120((int)v6, "   Notes:\r\n");
        sub_10028120((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_10028120((int)v6, (const char *)&word_1009FE94);
        sub_10028120(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_10028120(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_10028120(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_10028120((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_10028120((int)v6, (const char *)&word_1009FE94);
        sub_10028120(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_10028120(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_10028120((int)v6, "       without a test suite name.\r\n");
        sub_10028120((int)v6, (const char *)&word_1009FE94);
        sub_10028120((int)v6, "   Examples:\r\n");
        sub_10028120(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_10028120((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_10028120(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_10028120(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_10028120(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_10028120(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_10028120(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_10028120(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_10028120((int)v6, (const char *)&word_1009FE94);
        sub_10028120((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_10028120(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_100275C0((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, (const char *)&word_1009FE94);
        return v5;
      }
      if ( sub_10027590((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_1013D998,
          &unk_10065D59,
          &v58,
          6 - dword_1013D998,
          word_10060D0C,
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, v55);
        return v5;
      }
      if ( sub_100275F0((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_10027620((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_1013D998 += 2;
          return v5;
        }
        if ( sub_10027660((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_1013D998 < 2 )
            dword_1013D998 = 0;
          else
            dword_1013D998 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_1013D998,
          &unk_10065D59,
          a2[2],
          6 - dword_1013D998,
          word_10060D0C,
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, v55);
        return v5;
      }
      if ( sub_10027560((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_1013D998,
          &unk_10065D59,
          a2[3],
          6 - dword_1013D998,
          word_10060D0C,
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_100276D0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, v55);
      }
      else if ( sub_100276A0((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1002CED0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_10028120((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_10028120((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_10028120((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1002CED0((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_10028120((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_10028120((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_10028120((int)v6, v55);
      }
      LOBYTE(v5) = sub_10027DD0((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_100280A0((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_10028120((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 1006E364: using guessed type __int16 word_1006E364;
// 1009FE94: using guessed type __int16 word_1009FE94;
// 1013D998: using guessed type int dword_1013D998;
// 1002CF10: using guessed type char var_304[508];

//----- (1002DCC0) --------------------------------------------------------
signed int __cdecl sub_1002DCC0(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_1013D9A0 + 580 * sub_10025500();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_10027CD0(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (1002DD40) --------------------------------------------------------
char **__cdecl sub_1002DD40(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_1013D9A0 + 580 * sub_10025500();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_10027EE0((int)v1, a1, (int)".txt");
  return &off_1009F260;
}
// 1009F260: using guessed type char *off_1009F260;

//----- (1002DD80) --------------------------------------------------------
int (**sub_1002DD80())()
{
  return off_1009FF50;
}
// 1009FF50: using guessed type int (*off_1009FF50[2])();

//----- (1002DD90) --------------------------------------------------------
int (__cdecl *__cdecl sub_1002DD90(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10025500();
  return sub_10028120((int)&unk_1013E4F8 + 1812 * v1, a1);
}

//----- (1002DDB0) --------------------------------------------------------
const char *sub_1002DDB0()
{
  return "See version control for test execution date";
}

//----- (1002DDC0) --------------------------------------------------------
__int64 sub_1002DDC0()
{
  return 0i64;
}

//----- (1002DDD0) --------------------------------------------------------
const char *sub_1002DDD0()
{
  return "Not Available";
}

//----- (1002DDE0) --------------------------------------------------------
int __usercall sub_1002DDE0@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (1002DE30) --------------------------------------------------------
signed int __cdecl sub_1002DE30(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10025500();
  return sub_10027CD0(a1, a2, (int)&unk_1013E4F8 + 1812 * v2);
}

//----- (1002DF80) --------------------------------------------------------
int __usercall sub_1002DF80@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_1003BFB0((int)&a2[151 * (*a2 + 1)], (int)sub_1002DD90, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_1002DDC0();
  v4 = sub_10032DA0("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_1003C400((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10032DA0("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_1003C400((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_1003C400((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_1003C380((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_1003C210((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10032DA0("CFG_OutputTestRevision", (int)"False");
  if ( !sub_100255B0(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_1003C450((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_1003C450((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_1003C380((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_1003C380((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_1003C450((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_10027E40(v3);
  sub_1003C450((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_1003C300((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_10032D60(i, &v15, &v16); ++i )
  {
    sub_1003C380((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_1003C450((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_1003C450((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_1003C300((int)&a2[151 * (*a2 + 1)]);
  }
  sub_1003C300((int)&a2[151 * (*a2 + 1)]);
  sub_1003C380((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_1003C210((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 1002DF80: using guessed type char var_103[253];

//----- (1002E300) --------------------------------------------------------
char __cdecl sub_1002E300(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  const char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10025500();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_1013E4F8 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_10027880(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_1002DDE0(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_1003C380(v8, (int)"Req");
            sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_10027850(a2, a3) )
      {
        if ( sub_10027FE0((int)v5, 3, 1, 0) )
          sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_1003C300(v12);
          sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_1003C210(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10027790(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1003C450(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_100278B0(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1003C450(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10027820(a2, a3) )
      {
        if ( sub_10027FE0((int)v5, 3, 1, 0) )
          sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10027F50((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_100277C0(a2, a3) )
      {
        sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_1003C210(v13, (int)"success", (unsigned __int8 *)&word_1006E364);
          sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_1003C210(v13, (int)"success", (unsigned __int8 *)&unk_10074DBC);
        }
        if ( v5[309] )
        {
          sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_10027FE0((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_10027760(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_10028090((int)v5) )
            sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_1003C450((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_10027FE0((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_10027B10((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_1002DF80((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_10027B00((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_1003C450(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_1003C450(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_1003C450((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_10028090((int)v5) )
        sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_10027700((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_1003C2B0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_1003C450((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_10027500((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_1003C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_1003C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_1003C260((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, "NE", 3u) )
              v44 = (const char *)&unk_10065D59;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], &word_1006E364, 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_1003C380(v19, (int)"Expected");
          sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_10027FE0((int)v5, 8, 1, 0) )
        sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_10027D70((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_10027DD0((int)v5, (void (__cdecl *)(int))sub_1002DE60);
      return v4;
    case 0:
    case 11:
      sub_10028170((int)v5, (void (__cdecl *)(int))sub_1002DE60);
      goto LABEL_139;
    case 1:
      sub_10027C90((int)v5);
      goto LABEL_139;
    case 12:
      sub_100280A0((int)v5, (void (__cdecl *)(int))sub_1002DE60);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_1003C380((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_1003C210((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_10027FE0((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_1003C300((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 1002DE60: using guessed type int sub_1002DE60();
// 1006E364: using guessed type __int16 word_1006E364;
// 1002E300: using guessed type char var_104[255];

//----- (1002F120) --------------------------------------------------------
char **__cdecl sub_1002F120(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_1013E4F8 + 1812 * sub_10025500();
  *((_DWORD *)v1 + 146) = 0;
  sub_10027EE0((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_1003BFB0(v2, (int)sub_1002DD90, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_100A0000;
}
// 100A0000: using guessed type char *off_100A0000;

//----- (1002F190) --------------------------------------------------------
char __thiscall sub_1002F190(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10140860 = sub_1001D620(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10140868, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_10140868;
  do
  {
    result = sub_10030870(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 10140860: using guessed type int dword_10140860;

//----- (1002F200) --------------------------------------------------------
char __usercall sub_1002F200@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_1001F8B0(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_1001F8B0(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (1002F240) --------------------------------------------------------
void *__usercall sub_1002F240@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_10140860 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10005040(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_10140868 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10030870(a1, (int)&unk_10140868 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy_0(
               a4,
               (char *)&unk_10140868 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2,
               (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_10140860 != 1379255385 )
    result = (void *)sub_10005010(v4, 86);
  return result;
}
// 10140860: using guessed type int dword_10140860;

//----- (1002F2E0) --------------------------------------------------------
char __cdecl sub_1002F2E0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_1002F200(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (1002F320) --------------------------------------------------------
bool __cdecl sub_1002F320(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_1002F240(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (1002F380) --------------------------------------------------------
char __cdecl sub_1002F380(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_1002F200(a2, 1, a3, a1);
  return result;
}

//----- (1002F3C0) --------------------------------------------------------
char __cdecl sub_1002F3C0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_1002F240(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1002F3F0) --------------------------------------------------------
char __cdecl sub_1002F3F0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_1002F200(a2 + 10, 1, a3, a1);
  return result;
}

//----- (1002F430) --------------------------------------------------------
char __cdecl sub_1002F430(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_1002F240(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (1002F470) --------------------------------------------------------
char __cdecl sub_1002F470(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_1002F200(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (1002F4B0) --------------------------------------------------------
bool __cdecl sub_1002F4B0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_1002F240(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (1002F500) --------------------------------------------------------
char __cdecl sub_1002F500(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_1002F200(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (1002F540) --------------------------------------------------------
bool __cdecl sub_1002F540(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_1002F240(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (1002F580) --------------------------------------------------------
char __cdecl sub_1002F580(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_1002F200(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (1002F5C0) --------------------------------------------------------
bool __cdecl sub_1002F5C0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_1002F240(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (1002F600) --------------------------------------------------------
char __cdecl sub_1002F600(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002F200(1229, 1, a2, a1);
  return result;
}

//----- (1002F630) --------------------------------------------------------
char __cdecl sub_1002F630(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002F240(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (1002F660) --------------------------------------------------------
char __cdecl sub_1002F660(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002F200(1212, 16, a2, a1);
  return result;
}

//----- (1002F690) --------------------------------------------------------
char __cdecl sub_1002F690(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002F240(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002F6C0) --------------------------------------------------------
char __cdecl sub_1002F6C0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002F200(2400, 65, a2, a1);
  return result;
}

//----- (1002F6F0) --------------------------------------------------------
char __cdecl sub_1002F6F0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002F240(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002F720) --------------------------------------------------------
char __cdecl sub_1002F720(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_1002F200(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (1002F760) --------------------------------------------------------
char __cdecl sub_1002F760(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10004C50("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_1002F240(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (1002F7B0) --------------------------------------------------------
char __cdecl sub_1002F7B0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_1002F200(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (1002F7F0) --------------------------------------------------------
char __cdecl sub_1002F7F0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_1002F240(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (1002F820) --------------------------------------------------------
char __cdecl sub_1002F820(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002F200(22, 1, a2, a1);
  return result;
}

//----- (1002F850) --------------------------------------------------------
char __cdecl sub_1002F850(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_1002F200(832, 4, a2, a1);
  return result;
}

//----- (1002F880) --------------------------------------------------------
char __cdecl sub_1002F880(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_1002F240(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (1002F8B0) --------------------------------------------------------
char __cdecl sub_1002F8B0(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100251F0(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_1002F760(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1002F720(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_1002F7F0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_1002F7B0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_1002F320(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002F2E0(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_1002F540(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002F500(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_1002F5C0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002F580(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_1002F3C0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002F380(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_1002F430(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002F3F0(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_1002F820(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_1002F690(v6, a5);
        else
          result = sub_1002F660(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_1002F4B0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_1002F470(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1002F6F0(v6, a5);
        else
          result = sub_1002F6C0(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1002F630(v6, a5);
        else
          result = sub_1002F600(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_1002F880(v6, a5);
        else
          result = sub_1002F850(v6, a5);
        break;
      default:
        sub_10004C50("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10005540: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1002FC50) --------------------------------------------------------
bool __cdecl sub_1002FC50(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_10141DA8 != 1379255385 )
    {
      sub_10030850(a1, (int)&byte_10141DB0[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_10141DB5[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10141DB4[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 10141DA8: using guessed type int dword_10141DA8;

//----- (1002FCC0) --------------------------------------------------------
bool __cdecl sub_1002FCC0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_10141DA8 != 1379255385 )
      sub_10030850(a1, (int)&byte_10141DB0[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_10141DC4[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10141DA8: using guessed type int dword_10141DA8;
// 10141DC4: using guessed type int dword_10141DC4[];

//----- (1002FD20) --------------------------------------------------------
bool __cdecl sub_1002FD20(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_10141DA8 != 1379255385 )
    {
      sub_10030850(a1, (int)&byte_10141DB0[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_10141DBC[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 10141DA8: using guessed type int dword_10141DA8;
// 10141DBC: using guessed type int dword_10141DBC[];

//----- (1002FD90) --------------------------------------------------------
char __cdecl sub_1002FD90(char a1, _BYTE *a2)
{
  if ( dword_10141DA8 != 1379255385 )
    sub_10030850(a1, (int)&byte_10141DB0[24 * (unsigned __int8)a1]);
  *a2 = byte_10141DB0[24 * (unsigned __int8)a1];
  return 1;
}
// 10141DA8: using guessed type int dword_10141DA8;

//----- (1002FDD0) --------------------------------------------------------
char __thiscall sub_1002FDD0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10141DA8 = sub_1001D620(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_10141DB0, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_10141DB0;
  do
  {
    result = sub_10030850(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 10141DA8: using guessed type int dword_10141DA8;

//----- (1002FE40) --------------------------------------------------------
char __cdecl sub_1002FE40(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1001D740(a1);
  v3 = sub_1005BA40(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (1002FE70) --------------------------------------------------------
char __cdecl sub_1002FE70(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1001D740(a1);
  v3 = sub_1005BAB0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (1002FEA0) --------------------------------------------------------
char __cdecl sub_1002FEA0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_1001D830(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_1002FD20(v7, *a4, (int)a5);
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_1002FC50(v7, *a4, (int)a5);
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_1002FCC0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_1002FD90(v7, a5);
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_1002FE70(v7, (int)a5);
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_1002FE40(v7, (int)a5);
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10004C50("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10030070) --------------------------------------------------------
int __cdecl sub_10030070(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10141DF8 = *(_DWORD *)a1;
  dword_10141DFC = *(_DWORD *)(a1 + 4);
  dword_10141E00 = *(_DWORD *)(a1 + 8);
  dword_10141E04 = *(_DWORD *)(a1 + 12);
  dword_101E38AC = (int)&dword_10141DF8;
  return result;
}
// 10141DF8: using guessed type int dword_10141DF8;
// 10141DFC: using guessed type int dword_10141DFC;
// 10141E00: using guessed type int dword_10141E00;
// 10141E04: using guessed type int dword_10141E04;
// 101E38AC: using guessed type int dword_101E38AC;

//----- (100300B0) --------------------------------------------------------
char __cdecl sub_100300B0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_1001E3C0((_DWORD *)a2, 2u, (int)&unk_100A19D0, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100A19D4[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10004EF0(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10004D80();
        sub_1001E330(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10004C50("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100A19D4: using guessed type int dword_100A19D4[];

//----- (100301D0) --------------------------------------------------------
char __cdecl sub_100301D0(int a1)
{
  return sub_100300B0(29, a1);
}

//----- (100301E0) --------------------------------------------------------
char __cdecl sub_100301E0(int a1)
{
  return sub_100300B0(31, a1);
}

//----- (100301F0) --------------------------------------------------------
signed int __cdecl sub_100301F0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10030240) --------------------------------------------------------
int __cdecl sub_10030240(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10030330) --------------------------------------------------------
unsigned int __cdecl sub_10030330(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10030380) --------------------------------------------------------
unsigned int __cdecl sub_10030380(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10030440) --------------------------------------------------------
unsigned int __cdecl sub_10030440(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_1001E260(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (100304A0) --------------------------------------------------------
int __cdecl sub_100304A0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (100304F0) --------------------------------------------------------
int __cdecl sub_100304F0(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10030590) --------------------------------------------------------
int __cdecl sub_10030590(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10030640) --------------------------------------------------------
char __cdecl sub_10030640(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_10004C50("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100CAF58[8 * a1];
  *a4 = word_100CAF5A[a2 + 4 * a1];
  return 1;
}
// 100CAF5A: using guessed type __int16 word_100CAF5A[];

//----- (100306A0) --------------------------------------------------------
signed int __cdecl sub_100306A0(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_100A1D98;
    v6 = &unk_100A1D98;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_100A1DB0;
    v6 = &unk_100A1DB0;
    v5 = &a1;
  }
  v3 = sub_1001E3C0(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10030700) --------------------------------------------------------
int __cdecl sub_10030700(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E3C0(&a1, 1u, (int)&unk_100A1DF8, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100A1DFC[2 * v1];
  return result;
}
// 100A1DFC: using guessed type int dword_100A1DFC[];

//----- (10030740) --------------------------------------------------------
signed int __cdecl sub_10030740(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_100A1E08;
    v7 = &unk_100A1E08;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_100A1E20;
    v7 = &unk_100A1E20;
    v6 = &a1;
  }
  v4 = sub_1001E3C0(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (100307B0) --------------------------------------------------------
int __cdecl sub_100307B0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E3C0(&a1, 1u, (int)&unk_100A1E38, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_100A1E3C[2 * v1];
  return result;
}
// 100A1E3C: using guessed type int dword_100A1E3C[];

//----- (100307F0) --------------------------------------------------------
int __cdecl sub_100307F0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E3C0(&a1, 1u, (int)&unk_100A1E50, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100A1E54[2 * v1];
  return result;
}
// 100A1E54: using guessed type int dword_100A1E54[];

//----- (10030830) --------------------------------------------------------
char __cdecl sub_10030830(int a1, int a2)
{
  return sub_10005090(a1 + 37000, a2, 284);
}

//----- (10030850) --------------------------------------------------------
char __cdecl sub_10030850(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100306A0(a1, 11);
  return sub_10005090(v2, a2, 24);
}

//----- (10030870) --------------------------------------------------------
char __cdecl sub_10030870(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10030700(a1);
  return sub_10005090(v2, a2, 2720);
}

//----- (100308A0) --------------------------------------------------------
char __cdecl sub_100308A0(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10030740(a1, 11, 1);
  sub_10005090(v2, a2, 36);
  v3 = sub_10030740(a1, 11, 0);
  return sub_10005090(v3, a2 + 36, 32);
}

//----- (100308F0) --------------------------------------------------------
char __cdecl sub_100308F0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100307B0(a1);
  return sub_10005090(v2, a2, 2192);
}

//----- (10030920) --------------------------------------------------------
char __cdecl sub_10030920(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100307F0(a1);
  return sub_10005090(v2, a2, 60);
}

//----- (10030940) --------------------------------------------------------
char __cdecl sub_10030940(int a1)
{
  return sub_10005090(6453, a1, 5);
}

//----- (10030960) --------------------------------------------------------
char __cdecl sub_10030960(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_1001F8E0(2, 363, a1);
}

//----- (10030980) --------------------------------------------------------
char __cdecl sub_10030980(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_10005070(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10030AD0) --------------------------------------------------------
bool __thiscall sub_10030AD0(void *this)
{
  return (sub_1001D600(this) & 0x8000) == 0x8000;
}

//----- (10030AF0) --------------------------------------------------------
char __cdecl sub_10030AF0(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_10030980(a5);
      else
        result = sub_10030960(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_10030980(&unk_10141E08);
      else
        v7 = sub_10030960(&unk_10141E08);
      v8 = v7;
      memcpy_0(a5, (char *)&unk_10141E08 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_10030980(&unk_10141E08);
      else
        v9 = sub_10030960(&unk_10141E08);
      v10 = v9;
      memcpy_0(a5, (char *)&unk_10144D10 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_10030980(&unk_10141E08);
      else
        v11 = sub_10030960(&unk_10141E08);
      v12 = v11;
      memcpy_0(a5, (char *)&unk_10145210 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_10030980(&unk_10141E08);
      else
        v13 = sub_10030960(&unk_10141E08);
      v14 = v13;
      memcpy_0(a5, &unk_101452B8, a6);
      result = v14;
      break;
    default:
      sub_10004C50("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10030C90) --------------------------------------------------------
char __cdecl sub_10030C90(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1001FE40(11);
  }
  else
  {
    result = sub_1001FE40(5);
  }
  return result;
}

//----- (10030CC0) --------------------------------------------------------
char sub_10030CC0()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_1001F8E0(1, 1309, &v1) )
    sub_10024E90((int)&v1);
  return 0;
}

//----- (10030D60) --------------------------------------------------------
BOOL __cdecl sub_10030D60(int a1, int a2)
{
  return sub_10005070(6455, a2, 252) == 0;
}

//----- (10030D80) --------------------------------------------------------
char __cdecl sub_10030D80(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10030D60(a1, a5);
  }
  else
  {
    result = sub_10030CC0();
  }
  return result;
}

//----- (10030DC0) --------------------------------------------------------
char __cdecl sub_10030DC0(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_100310E0(a1, v4, &v6) == 1 )
  {
    v2 = sub_1001EC40(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_10004C50("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_1001F8E0(v4[0], v6, &v5) && !sub_10030240((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10030EE0) --------------------------------------------------------
char __cdecl sub_10030EE0(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_100310E0(a1, &v5, &v4) && sub_1001EFD0(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_10005110(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 10030EE0: using guessed type char var_408[1028];

//----- (10030F80) --------------------------------------------------------
char __cdecl sub_10030F80(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003D020(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1003CE20(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1003CEA0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1003CF20(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_1003CFA0(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (10031090) --------------------------------------------------------
int __cdecl sub_10031090(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E3C0(&a1, 1u, (int)&unk_100A5A98, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10004C50("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100A5A9C[2 * v1];
  }
  return result;
}
// 100A5A9C: using guessed type int dword_100A5A9C[];

//----- (100310E0) --------------------------------------------------------
char __cdecl sub_100310E0(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_100A5AE0[4 * a1];
    *a3 = word_100A5AE2[2 * a1];
    result = 1;
  }
  else
  {
    sub_10004C50("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 100A5AE2: using guessed type __int16 word_100A5AE2[];

//----- (10031140) --------------------------------------------------------
double __cdecl sub_10031140(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_101E38AC + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_101E38AC + 12))() * v1);
}
// 101E38AC: using guessed type int dword_101E38AC;

//----- (10031190) --------------------------------------------------------
char __thiscall sub_10031190(void *this)
{
  int v1; // eax@1
  char result; // al@3

  v1 = sub_1001FF60(this) - 2;
  if ( v1 )
  {
    if ( v1 == 2 )
      result = 2;
    else
      result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100311B0) --------------------------------------------------------
_DWORD *__usercall sub_100311B0@<eax>(int a1@<eax>, int a2@<esi>, char *a3, char *a4)
{
  _DWORD *result; // eax@1

  sub_1003D0C0(a2, a1);
  result = (_DWORD *)sub_100200B0(a3, a4);
  if ( (_BYTE)result )
    result = sub_10001760(a2);
  return result;
}

//----- (10031290) --------------------------------------------------------
char __cdecl sub_10031290(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // eax@5
  char v7; // al@4
  int v8; // ecx@14
  char v9; // al@17
  char *v10; // eax@22
  char v12; // [sp+4h] [bp-10h]@20
  char v13; // [sp+8h] [bp-Ch]@11
  char v14; // [sp+Ch] [bp-8h]@18
  char v15; // [sp+10h] [bp-4h]@15
  char v16; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 52);
  if ( *(_WORD *)v3 != -32696 )
    return v3;
  v4 = (void *)*(_WORD *)(v3 + 10);
  if ( (unsigned __int16)v4 & 0xC000 )
    return v3;
  v5 = *(_DWORD *)(v3 + 4);
  v16 = -1;
  if ( v5 )
  {
    v7 = sub_1003D1B0(*(int (__cdecl **)(int))(v5 + 8));
LABEL_7:
    v16 = v7;
    goto LABEL_8;
  }
  v6 = *(_DWORD *)(v2 + 48);
  if ( v6 )
  {
    v7 = sub_1003D1B0(*(int (__cdecl **)(int))(v6 + 8));
    goto LABEL_7;
  }
LABEL_8:
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 1 )
    goto LABEL_26;
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 2 )
  {
    v13 = 8;
    goto LABEL_14;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v2 + 52) + 16) == 4 )
  {
LABEL_26:
    v13 = 7;
    goto LABEL_14;
  }
  v13 = sub_10031190(v4);
LABEL_14:
  v8 = *(_DWORD *)(v2 + 52);
  if ( *(_WORD *)(v8 + 10) == 0x2000 )
    v15 = *(_BYTE *)(v8 + 14) - 92;
  else
    v15 = *(_BYTE *)(v8 + 10);
  v9 = *(_BYTE *)(v8 + 8);
  if ( v9 >= 0 )
  {
    v14 = 0;
  }
  else
  {
    v14 = 1;
    v9 = -v9;
  }
  v12 = v9;
  if ( *(_WORD *)(v8 + 12) )
    v12 = v9 * *(_BYTE *)(v8 + 12);
  v10 = sub_1003D1E0(v16);
  LOBYTE(v3) = sub_1003D0E0(v13, v16, v15, v12, v14, *(_DWORD *)(v2 + 64), 0, 0, v10);
  return v3;
}

//----- (10031390) --------------------------------------------------------
_DWORD *sub_10031390()
{
  char v1; // [sp+4h] [bp-104h]@1

  sub_10005110(6463, (int)&v1, 256);
  sub_100311B0((int)sub_10031240, (int)&unk_101452EC, &v1, "PAGE_INIT");
  sub_100311B0((int)sub_100311E0, (int)&unk_101452DC, &v1, "PAGE_SET_FOCUS");
  return sub_100311B0((int)sub_10031290, (int)&unk_101452E4, &v1, "KEY_PRESS");
}
// 100311E0: using guessed type int sub_100311E0();
// 10031240: using guessed type int sub_10031240();

//----- (10031420) --------------------------------------------------------
int __cdecl sub_10031420(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (10031430) --------------------------------------------------------
int __usercall sub_10031430@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_1003D210(a2, a1);
}

//----- (10031440) --------------------------------------------------------
char __usercall sub_10031440@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_10031430((char *)&v5, a2);
  v2 = sub_10031420(a1);
  if ( sub_10005070(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 10031440: using guessed type char var_48[68];

//----- (10031500) --------------------------------------------------------
char __cdecl sub_10031500(char a1, char a2)
{
  return sub_10031440(a1, a2);
}

//----- (10031520) --------------------------------------------------------
int __cdecl sub_10031520(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E3C0(&a1, 1u, (int)&unk_100A6F88, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_100A6F8C + 2 * v1);
  return result;
}
// 100A6F8C: using guessed type void *off_100A6F8C;

//----- (10031560) --------------------------------------------------------
unsigned int __cdecl sub_10031560(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10031580) --------------------------------------------------------
bool __cdecl sub_10031580(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10031650) --------------------------------------------------------
int __cdecl sub_10031650(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10031670) --------------------------------------------------------
int __cdecl sub_10031670(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10031650(a1 + 20);
  return result;
}

//----- (100316B0) --------------------------------------------------------
signed int __cdecl sub_100316B0(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_10005310(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_10005310(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10031770) --------------------------------------------------------
int __cdecl sub_10031770(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (100317B0) --------------------------------------------------------
int __usercall sub_100317B0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_10040E30(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_100053F0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_10005410(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 10005430: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10031860) --------------------------------------------------------
signed int __usercall sub_10031860@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_10005440(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10041280((void *)(v2 + 555), v7);
  }
  else
  {
    sub_100316B0(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_10005310(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_10005310(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_10041150(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_10005440(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_10005440(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10031A30) --------------------------------------------------------
char __usercall sub_10031A30@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_10040DE0(a2, a3, a1 + 212);
}

//----- (10031A40) --------------------------------------------------------
int __usercall sub_10031A40@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_100317B0(result + 148, result);
  return result;
}

//----- (10031A60) --------------------------------------------------------
char __usercall sub_10031A60@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10031A80) --------------------------------------------------------
int __usercall sub_10031A80@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_100473E0(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_100473E0(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10031AC0) --------------------------------------------------------
int __fastcall sub_10031AC0(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10031AE0) --------------------------------------------------------
int __usercall sub_10031AE0@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_10005490(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_10005410(v4, v3, 0);
}
// 10005430: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10031B20) --------------------------------------------------------
signed int __usercall sub_10031B20@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10031AC0(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_10047400(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10031A30(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_10043030(a2 + 28, 4);
      else
        v22 = sub_10043030(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy_0(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10031A30(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 10005430: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10031D30) --------------------------------------------------------
int __cdecl sub_10031D30(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10031A40(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10020EC0(&v23);
    sub_10021220((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10031670(v1, (int)&v24);
  v13 = sub_100053F0(v31);
  if ( v3 == v31 )
  {
    result = sub_10005260(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_10005490(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_10005260(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_10005490(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10031650(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10031AE0(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_100053F0(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 10005430: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10031FA0) --------------------------------------------------------
signed int __cdecl sub_10031FA0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_10005490(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10031B20(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10032040) --------------------------------------------------------
int __usercall sub_10032040@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_10031A60(a1);
  *v3 ^= v2;
  return sub_10031A80(v1, *v3);
}

//----- (10032060) --------------------------------------------------------
int __usercall sub_10032060@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10032040(a2);
  return result;
}

//----- (10032090) --------------------------------------------------------
signed int __usercall sub_10032090@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10031A80(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_10005310(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10032180) --------------------------------------------------------
char __usercall sub_10032180@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_10040D90(a1, a2, a3 + 212);
  else
    result = sub_10032060(a2, a3 + 148);
  return result;
}

//----- (100321B0) --------------------------------------------------------
signed int __usercall sub_100321B0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10031860(v3, v1);
  else
    result = sub_10032090(v3, v1);
  return result;
}

//----- (100321E0) --------------------------------------------------------
signed int __cdecl sub_100321E0(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10031770(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_10044AA0(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_100321B0(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10032230) --------------------------------------------------------
signed int __cdecl sub_10032230(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_10005310(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10032180(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_10005310(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_10040E30(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10031AC0(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_10045E60(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_10047400(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy_0(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_10047400(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10032420) --------------------------------------------------------
signed int __cdecl sub_10032420(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10032230(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10031580(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10032480) --------------------------------------------------------
signed int __cdecl sub_10032480(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_100321E0(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10031770(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_100321E0(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10032420(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10032620) --------------------------------------------------------
char __cdecl sub_10032620(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_1001F8E0(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_1001F8E0(0, 183, a2);
  }
  return result;
}

//----- (10032670) --------------------------------------------------------
unsigned __int8 __cdecl sub_10032670(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1

  result = a2;
  if ( a2 + 1 >= 1 && a2 <= 0x3Fu )
  {
    result = a1;
    if ( (unsigned __int8)(a1 - 3) <= 1u )
      result = sub_10005140(dword_100AA868[a1], (int)&a2, 1);
  }
  return result;
}
// 100AA868: using guessed type int dword_100AA868[];

//----- (100326B0) --------------------------------------------------------
int __cdecl sub_100326B0(char a1, _DWORD *a2)
{
  int result; // eax@1
  char v3; // [sp+4h] [bp-18h]@1
  int v4; // [sp+8h] [bp-14h]@1

  LOBYTE(result) = sub_10032620(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (100326F0) --------------------------------------------------------
char __cdecl sub_100326F0(char a1)
{
  return byte_100AB729[2 * (unsigned __int8)sub_1001E3C0(&a1, 1u, (int)&unk_100AB728, 2, 4, 3)];
}

//----- (10032720) --------------------------------------------------------
char __cdecl sub_10032720(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_1001F8E0(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_100328A0(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_1001F8E0(1, 538, a2);
  }
  if ( !v4 || sub_10024DA0((int)v3) )
    return 0;
  return 1;
}

//----- (100327A0) --------------------------------------------------------
int __cdecl sub_100327A0(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_10032720(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (100327F0) --------------------------------------------------------
void __cdecl sub_100327F0(char a1, char a2)
{
  if ( (unsigned __int8)a2 <= 0x3Fu )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        sub_10005140(2011, (int)&a2, 1);
      }
      else
      {
        if ( a1 == 2 )
          sub_10032910(a2);
        sub_10004C50("..\\lib\\acl\\iop\\iop_com_intf.c", 658, 0, 0);
      }
    }
    else
    {
      sub_10005140(2010, (int)&a2, 1);
    }
  }
}

//----- (10032860) --------------------------------------------------------
int __cdecl sub_10032860(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = a2 * 1.799999952316284 + 32.0;
  return result;
}

//----- (10032880) --------------------------------------------------------
int __cdecl sub_10032880(int a1, float a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(float *)a1 = (a2 - 32.0) * 0.5555555820465088;
  return result;
}

//----- (100328A0) --------------------------------------------------------
bool __cdecl sub_100328A0(void *a1)
{
  char v1; // cl@1

  v1 = sub_1001F8E0(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_10024DA0((int)a1);
}

//----- (100328E0) --------------------------------------------------------
char __cdecl sub_100328E0(char a1)
{
  sub_1001F410(1, 1672, &a1, 0, 1, 1);
  return sub_1001F550(1, 0x688u, 0xFFFFFFF);
}

//----- (10032910) --------------------------------------------------------
char __cdecl sub_10032910(char a1)
{
  int v1; // eax@1

  v1 = sub_10005140(10028, (int)&a1, 1);
  if ( !v1 )
    LOBYTE(v1) = sub_100328E0(a1);
  return v1;
}

//----- (10032940) --------------------------------------------------------
char __cdecl sub_10032940(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_101E37B8)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (10032990) --------------------------------------------------------
char __cdecl sub_10032990(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_101E37B8)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (10032A40) --------------------------------------------------------
char __cdecl sub_10032A40(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_101E37B8)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (10032AA0) --------------------------------------------------------
char __cdecl sub_10032AA0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_101E37B8)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 101E37B8: using guessed type int dword_101E37B8;

//----- (10032B70) --------------------------------------------------------
char sub_10032B70()
{
  return 2;
}

//----- (10032B80) --------------------------------------------------------
char sub_10032B80()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10005110(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10032B80: using guessed type int var_1C[7];

//----- (10032C00) --------------------------------------------------------
int __cdecl sub_10032C00(unsigned __int8 *a1)
{
  return sub_100304A0(a1, 0, 0, 0, 0);
}

//----- (10032C20) --------------------------------------------------------
unsigned int __cdecl sub_10032C20(void *a1)
{
  return sub_10030440(a1, 0xCu, 0);
}

//----- (10032C40) --------------------------------------------------------
unsigned int __cdecl sub_10032C40(void *a1)
{
  return sub_10030440(a1, 0x20u, 0);
}

//----- (10032C60) --------------------------------------------------------
unsigned int __cdecl sub_10032C60(void *a1)
{
  return sub_10030440(a1, 0x1Cu, 0);
}

//----- (10032C80) --------------------------------------------------------
unsigned int __cdecl sub_10032C80(void *a1)
{
  return sub_10030440(a1, 0x10u, 0);
}

//----- (10032CA0) --------------------------------------------------------
unsigned int __cdecl sub_10032CA0(void *a1)
{
  return sub_10030440(a1, 8u, 0);
}

//----- (10032CC0) --------------------------------------------------------
signed int __cdecl sub_10032CC0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10030380(a1, 2147483648, 0x7FFFFFFF, 0x7FFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (10032CF0) --------------------------------------------------------
unsigned int __cdecl sub_10032CF0(void *a1)
{
  unsigned int result; // eax@1

  result = sub_10032C40((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10032C60((char *)a1 + 36);
    if ( !result )
    {
      result = sub_10032C80(a1);
      if ( !result )
      {
        result = sub_10032C20((char *)a1 + 96);
        if ( !result )
        {
          result = sub_10032C20((char *)a1 + 24);
          if ( !result )
            result = sub_10032CA0((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (10032D50) --------------------------------------------------------
int __cdecl sub_10032D50(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (10032D60) --------------------------------------------------------
char __cdecl sub_10032D60(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_101A5048[592 * a1]) || byte_101A5098[v3]) )
  {
    *a2 = &byte_101A5048[v3];
    *a3 = &byte_101A5098[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032DA0) --------------------------------------------------------
char *__cdecl sub_10032DA0(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_101A5048;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_101A5098[592 * v2];
}

//----- (10032E10) --------------------------------------------------------
char *__usercall sub_10032E10@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (10032E40) --------------------------------------------------------
void __cdecl sub_10032E40(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10032DA0(v2 + 3, (int)&unk_10065D59);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_10032E40(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (10032F00) --------------------------------------------------------
void __cdecl sub_10032F00(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_101A5040 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_101A5040;
    v4 = (char *)(&byte_101A5048[592 * dword_101A5040] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_101A5098[v3];
    v8 = (char *)(&byte_101A5098[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_10032E40(v7);
    ++dword_101A5040;
  }
}
// 101A5040: using guessed type int dword_101A5040;

//----- (10032F60) --------------------------------------------------------
void *__cdecl sub_10032F60(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_101A5048, 0, 0x73A0u);
  dword_101A5040 = 0;
  if ( a1 )
  {
    v2 = sub_10033430(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_10033610((int)&v11, 512, v2) )
      {
        do
        {
          sub_10032E10(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_10032F00((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_10032F00(&v11, v4 + 1);
          }
        }
        while ( sub_10033610((int)&v11, 512, v3) );
      }
      result = (void *)sub_100333E0(v3);
    }
    else
    {
      result = (void *)sub_10027A80(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 101A5040: using guessed type int dword_101A5040;

//----- (100330F0) --------------------------------------------------------
int __cdecl sub_100330F0(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 1005B840: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 1005B850: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 1005B860: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 1005B870: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 1005B920: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (10033230) --------------------------------------------------------
char __usercall sub_10033230@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (10033300) --------------------------------------------------------
signed int __cdecl sub_10033300(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_1005B880(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_10033230(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_100330F0(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 1005B930: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (100333E0) --------------------------------------------------------
BOOL __cdecl sub_100333E0(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10005200(a1) == 0;
}
// 100051F0: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (10033400) --------------------------------------------------------
BOOL __cdecl sub_10033400(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 10005240: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10033430) --------------------------------------------------------
unsigned int __cdecl sub_10033430(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 100052C0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10033490) --------------------------------------------------------
signed int __cdecl sub_10033490(void *a1, int a2, unsigned int a3)
{
  return sub_100052D0(a3, a1, a2);
}

//----- (100334B0) --------------------------------------------------------
int __cdecl sub_100334B0(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 10005430: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100334D0) --------------------------------------------------------
char __cdecl sub_100334D0(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10033430((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_10033430((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_10033490(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_100334B0((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_10033490(&v8, 512, v3);
        }
        v2 = i;
        sub_100333E0(v4);
      }
      sub_100333E0(v3);
    }
    return v2;
  }
  return 1;
}

//----- (10033610) --------------------------------------------------------
int __cdecl sub_10033610(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_10033490(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (10033690) --------------------------------------------------------
int sub_10033690()
{
  return 0;
}

//----- (100336A0) --------------------------------------------------------
void __cdecl sub_100336A0(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (100336D0) --------------------------------------------------------
int __cdecl sub_100336D0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (100336F0) --------------------------------------------------------
bool __cdecl sub_100336F0(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10033720) --------------------------------------------------------
void *__cdecl sub_10033720(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10033760) --------------------------------------------------------
unsigned int __usercall sub_10033760@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10033780) --------------------------------------------------------
int __usercall sub_10033780@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (100337A0) --------------------------------------------------------
char __cdecl sub_100337A0(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_100336F0(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_100336D0(a2);
  }
  return result;
}

//----- (100337D0) --------------------------------------------------------
signed int __cdecl sub_100337D0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_10033760(v5, v7, v9);
          v11 = (_BYTE *)sub_10033760(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10033760(a4, v7, v9);
            sub_10033780(v16, (int)&unk_100AE21C);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (100338B0) --------------------------------------------------------
void __cdecl sub_100338B0(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10033760((int)v3, v4, v6);
          v8 = sub_10033760(a2, v4, v6);
          v9 = sub_10033760(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10033960) --------------------------------------------------------
void *__usercall sub_10033960@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10033760(a1, v31, v4);
      v6 = sub_10033760(a2, 0, 0);
      sub_10033780(v5, v6);
      v7 = sub_10033760(a1, v33, v4);
      v8 = sub_10033760(a2, *(_DWORD *)a2 - 1, 0);
      sub_10033780(v7, v8);
      v9 = sub_10033760(a1, v31, v34 - v4 - 1);
      v10 = sub_10033760(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10033780(v9, v10);
      v11 = sub_10033760(a1, v33, v34 - v4 - 1);
      v12 = sub_10033760(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10033780(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10033760(a2, 0, 1);
    v16 = (void *)sub_10033760(a1, v13, a3 + 1);
    memcpy_0(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10033760(a1, a3 + i, v18);
      v20 = sub_10033760(a2, i, 0);
      sub_10033780(v19, v20);
      v21 = sub_10033760(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10033760(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10033780(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10033760(a2, i, 1);
    v25 = (void *)sub_10033760(a1, a3 + i, a3 + 1);
    memcpy_0(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10033760(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10033760(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy_0(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (10033BE0) --------------------------------------------------------
void __cdecl sub_10033BE0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10033760(a1, v2, v4);
          v6 = sub_10033760(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (10033CB0) --------------------------------------------------------
char __cdecl sub_10033CB0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_100336F0(a1);
  if ( result )
  {
    result = sub_100336F0(a4);
    if ( result )
    {
      sub_100337A0(a3, a4);
      sub_10033720(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy_0(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10033D20) --------------------------------------------------------
int __usercall sub_10033D20@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10033720(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10033960((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10033760((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10033760(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_100337A0((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_10033CB0(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10034080) --------------------------------------------------------
int __usercall sub_10034080@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10033720(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_100338B0(v8, a3, (int)&v16);
  sub_10033720(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10033D20(9u, v7, (int)&v16, (int)&unk_100AE1F8, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10033760((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10033760(a6, v9, v11);
            sub_10033780(v13, (int)&unk_100AE21C);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_100337A0(a5, (int)&v15);
  sub_100337A0(a5, (int)&v16);
  return v10;
}

//----- (10034190) --------------------------------------------------------
int __cdecl sub_10034190(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10033720(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_10033BE0(a3, a8);
  if ( a1 )
    result = sub_10034080(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_100337D0((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10034320) --------------------------------------------------------
char __cdecl sub_10034320(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10033430((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_10033490(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_10033490(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_10033720(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_10033490(v6, v7, v12) == v7 && (!v9 || sub_10033490(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_100333E0(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10034470) --------------------------------------------------------
char __usercall sub_10034470@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_10033430(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_100334B0((int)&v14, 14, v9) == 14 && sub_100334B0((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_100334B0(v12, v6, v10) == v6 && (!v7 || sub_100334B0((int)&unk_100AE3C0, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_100333E0(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_100333E0(v10);
  }
  return v30;
}

//----- (100345C0) --------------------------------------------------------
char __cdecl sub_100345C0(int a1, int a2)
{
  char result; // al@2

  if ( sub_100336F0(a1) )
    result = sub_10034470(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10034600) --------------------------------------------------------
signed int __cdecl sub_10034600(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_101AC3E9 = 1;
    byte_101AC3E8 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_101AC3E8 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_101AC3E9 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 101AC3E8: using guessed type char byte_101AC3E8;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10034660) --------------------------------------------------------
bool __cdecl sub_10034660(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_100279D0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100C5FB8, (int)"failing_subroutine( depth-1 )");
    sub_10034660(a1 - 1);
    exit_0(14);
  }
  return sub_1002CE90(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (100346D0) --------------------------------------------------------
int sub_100346D0()
{
  const char *v0; // eax@1

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_101AC3E8 )
  {
    sub_1002CE90(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_100279D0(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_10034660(1);
    exit_0(14);
  }
  return sub_10027A00(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (100349F0) --------------------------------------------------------
char sub_100349F0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101AC3E8 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100AF02C + v2) )
      {
        sub_100281C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100AF034[v2], 0x100u, &v11);
        sub_100281C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100AF02C + v2), 0x100u, &v12);
        sub_100334D0(&v12, &v11);
      }
      if ( byte_100AF028[v2] )
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_100AF030[v2 / 4];
        v4 = *(char **)&off_100AF034[v2];
        v5 = sub_10028460(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100AF034[v2],
               off_100AF030[v2 / 4]);
        v6 = sub_1002CAE0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_100287C0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_100AF030[v2 / 4];
        v8 = *(char **)&off_100AF034[v2];
        v9 = sub_10028460(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100AF034[v2],
               off_100AF030[v2 / 4]);
        v10 = sub_1002CAE0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_100287C0(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100AF02C: using guessed type void *off_100AF02C;
// 100AF030: using guessed type char *off_100AF030[2];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10034C10) --------------------------------------------------------
char sub_10034C10()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_101AC3E8 )
  {
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_100287C0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_100287C0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_100287C0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_100287C0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_100287C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10034E10) --------------------------------------------------------
char sub_10034E10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100AF0BC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_100AF0B9[v2 * 4];
        v4 = byte_100AF0B8[v2 * 4];
        v5 = sub_10028460(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + dword_100AF0BC[v2])],
               (&off_100AF0C0)[v2 * 4]);
        v6 = sub_10028900(
               0,
               *(&dword_100AF00C + dword_100AF0BC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10028460(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100AF0BC[v2]],
               (&off_100AF0C0)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AF0BC: using guessed type int dword_100AF0BC[];
// 100AF0C0: using guessed type char *off_100AF0C0;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10034F90) --------------------------------------------------------
char sub_10034F90()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100AF340[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100AF338[v2 / 8];
        v4 = dbl_100AF330[v2 / 8];
        v5 = dbl_100AF328[v2 / 8];
        v6 = sub_10028460(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100AF344)[v2]);
        v7 = sub_10028CB0(
               0,
               *(&dword_100AF00C + dword_100AF340[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100AF340[v2 / 4]],
               (&off_100AF344)[v2]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AF328: using guessed type double dbl_100AF328[];
// 100AF330: using guessed type double dbl_100AF330[];
// 100AF338: using guessed type double dbl_100AF338[];
// 100AF340: using guessed type int dword_100AF340[];
// 100AF344: using guessed type char *off_100AF344;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10035110) --------------------------------------------------------
char sub_10035110()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100AFF54[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100AFF50[v2];
        v4 = flt_100AFF4C[v2];
        v5 = flt_100AFF48[v2];
        v6 = sub_10028460(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100AFF58[v2 * 4]);
        v7 = sub_10029100(
               0,
               *(&dword_100AF00C + dword_100AFF54[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100AFF54[v2]],
               *(_DWORD *)&off_100AFF58[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100AFF48: using guessed type float flt_100AFF48[];
// 100AFF4C: using guessed type float flt_100AFF4C[];
// 100AFF50: using guessed type float flt_100AFF50[];
// 100AFF54: using guessed type int dword_100AFF54[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10035280) --------------------------------------------------------
char sub_10035280()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101AC3E8 )
  {
    sub_1002CDE0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_10035280,
      (int)sub_10035280,
      (int)"This test is expected to fail");
    sub_1002CDE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_10035280,
      0,
      (int)"This test is expected to fail");
    result = sub_1002CDE0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10035280,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10035380) --------------------------------------------------------
char sub_10035380()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B06FC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B06F8[v2];
        v4 = dword_100B06F4[v2];
        v5 = dword_100B06F0[v2];
        v6 = sub_10028460(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B0700)[v2 * 4]);
        v7 = sub_100295C0(
               0,
               *(&dword_100AF00C + dword_100B06FC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B06FC[v2]],
               (&off_100B0700)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B06F0: using guessed type int dword_100B06F0[];
// 100B06F4: using guessed type int dword_100B06F4[];
// 100B06F8: using guessed type int dword_100B06F8[];
// 100B06FC: using guessed type int dword_100B06FC[];
// 100B0700: using guessed type char *off_100B0700;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (100354E0) --------------------------------------------------------
char sub_100354E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B0E90[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100B0E8C[v2 / 2];
        v4 = word_100B0E8A[v2 / 2];
        v5 = word_100B0E88[v2 / 2];
        v6 = sub_10028460(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B0E94)[v2]);
        v7 = sub_10029980(
               0,
               *(&dword_100AF00C + dword_100B0E90[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B0E90[v2 / 4]],
               (&off_100B0E94)[v2]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B0E88: using guessed type __int16 word_100B0E88[];
// 100B0E8A: using guessed type __int16 word_100B0E8A[];
// 100B0E8C: using guessed type __int16 word_100B0E8C[];
// 100B0E90: using guessed type int dword_100B0E90[];
// 100B0E94: using guessed type char *off_100B0E94;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10035640) --------------------------------------------------------
char sub_10035640()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B14A4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B14A0[v2];
        v4 = dword_100B149C[v2];
        v5 = dword_100B1498[v2];
        v6 = sub_10028460(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B14A8[v2 * 4]);
        v7 = sub_10029D80(
               0,
               *(&dword_100AF00C + dword_100B14A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B14A4[v2]],
               *(_DWORD *)&off_100B14A8[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B1498: using guessed type int dword_100B1498[];
// 100B149C: using guessed type int dword_100B149C[];
// 100B14A0: using guessed type int dword_100B14A0[];
// 100B14A4: using guessed type int dword_100B14A4[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (100357A0) --------------------------------------------------------
char sub_100357A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B1C48[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100B1C44[v2];
        LODWORD(v3) = dword_100B1C40[v2];
        HIDWORD(v4) = dword_100B1C3C[v2];
        LODWORD(v4) = dword_100B1C38[v2];
        HIDWORD(v5) = dword_100B1C34[v2];
        LODWORD(v5) = dword_100B1C30[v2];
        v6 = sub_10028460(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B1C4C[v2 * 4]);
        v7 = sub_1002A140(
               0,
               *(&dword_100AF00C + dword_100B1C48[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B1C48[v2]],
               *(_DWORD *)&off_100B1C4C[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B1C30: using guessed type int dword_100B1C30[];
// 100B1C34: using guessed type int dword_100B1C34[];
// 100B1C38: using guessed type int dword_100B1C38[];
// 100B1C3C: using guessed type int dword_100B1C3C[];
// 100B1C40: using guessed type int dword_100B1C40[];
// 100B1C44: using guessed type int dword_100B1C44[];
// 100B1C48: using guessed type int dword_100B1C48[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10035910) --------------------------------------------------------
char sub_10035910()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B2854[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100B2852[v2 * 4];
        v4 = byte_100B2851[v2 * 4];
        v5 = byte_100B2850[v2 * 4];
        v6 = sub_10028460(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B2858)[v2 * 4]);
        v7 = sub_1002A680(
               0,
               *(&dword_100AF00C + dword_100B2854[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B2854[v2]],
               (&off_100B2858)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B2854: using guessed type int dword_100B2854[];
// 100B2858: using guessed type char *off_100B2858;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10035A70) --------------------------------------------------------
char sub_10035A70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B2CEC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B2CE8[v2];
        v4 = dword_100B2CE4[v2];
        v5 = dword_100B2CE0[v2];
        v6 = sub_10028460(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B2CF0)[v2 * 4]);
        v7 = sub_1002AA60(
               0,
               *(&dword_100AF00C + dword_100B2CEC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B2CEC[v2]],
               (&off_100B2CF0)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B2CE0: using guessed type int dword_100B2CE0[];
// 100B2CE4: using guessed type int dword_100B2CE4[];
// 100B2CE8: using guessed type int dword_100B2CE8[];
// 100B2CEC: using guessed type int dword_100B2CEC[];
// 100B2CF0: using guessed type char *off_100B2CF0;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10035BD0) --------------------------------------------------------
char sub_10035BD0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101AC3E8 )
  {
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_1002CE90(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10065D59,
           (int)"This test is expected to fail");
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_1002CE90(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10065D59,
           "a",
           (int)"This test is expected to fail");
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_1002CE90(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10065D59,
           (const char *)&unk_10065D59,
           (int)"This test is expected to fail");
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_1002CE90(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_100287C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10035DF0) --------------------------------------------------------
char sub_10035DF0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B3484[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B3480[v2];
        v4 = dword_100B347C[v2];
        v5 = dword_100B3478[v2];
        v6 = sub_10028460(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B3488[v2 * 4]);
        v7 = sub_1002AE20(
               0,
               *(&dword_100AF00C + dword_100B3484[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B3484[v2]],
               *(_DWORD *)&off_100B3488[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B3478: using guessed type int dword_100B3478[];
// 100B347C: using guessed type int dword_100B347C[];
// 100B3480: using guessed type int dword_100B3480[];
// 100B3484: using guessed type int dword_100B3484[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10035F50) --------------------------------------------------------
char sub_10035F50()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B37F0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100B37EC[v2 / 2];
        v4 = word_100B37EA[v2 / 2];
        v5 = word_100B37E8[v2 / 2];
        v6 = sub_10028460(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B37F4)[v2]);
        v7 = sub_1002B1C0(
               0,
               *(&dword_100AF00C + dword_100B37F0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B37F0[v2 / 4]],
               (&off_100B37F4)[v2]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B37E8: using guessed type __int16 word_100B37E8[];
// 100B37EA: using guessed type __int16 word_100B37EA[];
// 100B37EC: using guessed type __int16 word_100B37EC[];
// 100B37F0: using guessed type int dword_100B37F0[];
// 100B37F4: using guessed type char *off_100B37F4;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (100360B0) --------------------------------------------------------
char sub_100360B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B3AB4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B3AB0[v2];
        v4 = dword_100B3AAC[v2];
        v5 = dword_100B3AA8[v2];
        v6 = sub_10028460(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B3AB8[v2 * 4]);
        v7 = sub_1002B5C0(
               0,
               *(&dword_100AF00C + dword_100B3AB4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B3AB4[v2]],
               *(_DWORD *)&off_100B3AB8[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B3AA8: using guessed type int dword_100B3AA8[];
// 100B3AAC: using guessed type int dword_100B3AAC[];
// 100B3AB0: using guessed type int dword_100B3AB0[];
// 100B3AB4: using guessed type int dword_100B3AB4[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10036210) --------------------------------------------------------
char sub_10036210()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B3E30[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100B3E2C[v2];
        LODWORD(v3) = dword_100B3E28[v2];
        HIDWORD(v4) = dword_100B3E24[v2];
        LODWORD(v4) = dword_100B3E20[v2];
        HIDWORD(v5) = dword_100B3E1C[v2];
        LODWORD(v5) = dword_100B3E18[v2];
        v6 = sub_10028460(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B3E34[v2 * 4]);
        v7 = sub_1002B960(
               0,
               *(&dword_100AF00C + dword_100B3E30[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B3E30[v2]],
               *(_DWORD *)&off_100B3E34[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B3E18: using guessed type int dword_100B3E18[];
// 100B3E1C: using guessed type int dword_100B3E1C[];
// 100B3E20: using guessed type int dword_100B3E20[];
// 100B3E24: using guessed type int dword_100B3E24[];
// 100B3E28: using guessed type int dword_100B3E28[];
// 100B3E2C: using guessed type int dword_100B3E2C[];
// 100B3E30: using guessed type int dword_100B3E30[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10036380) --------------------------------------------------------
char sub_10036380()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B439C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100B439A[v2 * 4];
        v4 = byte_100B4399[v2 * 4];
        v5 = byte_100B4398[v2 * 4];
        v6 = sub_10028460(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B43A0)[v2 * 4]);
        v7 = sub_1002BF40(
               0,
               *(&dword_100AF00C + dword_100B439C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B439C[v2]],
               (&off_100B43A0)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B439C: using guessed type int dword_100B439C[];
// 100B43A0: using guessed type char *off_100B43A0;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (100364E0) --------------------------------------------------------
char sub_100364E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B45B4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B45B0[v2];
        v4 = dword_100B45AC[v2];
        v5 = dword_100B45A8[v2];
        v6 = sub_10028460(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B45B8[v2 * 4]);
        v7 = sub_1002C330(
               0,
               *(&dword_100AF00C + dword_100B45B4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B45B4[v2]],
               *(_DWORD *)&off_100B45B8[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B45A8: using guessed type int dword_100B45A8[];
// 100B45AC: using guessed type int dword_100B45AC[];
// 100B45B0: using guessed type int dword_100B45B0[];
// 100B45B4: using guessed type int dword_100B45B4[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10036640) --------------------------------------------------------
char sub_10036640()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101AC3E8 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100B491C + v2) )
      {
        sub_100281C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100B4924[v2], 0x100u, &v11);
        sub_100281C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100B491C + v2), 0x100u, &v12);
        sub_100334D0(&v12, &v11);
      }
      if ( byte_100B4918[v2] )
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_100B4920[v2 / 4];
        v4 = *(char **)&off_100B4924[v2];
        v5 = sub_10028460(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B4924[v2],
               off_100B4920[v2 / 4]);
        v6 = sub_1002CAE0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_100287C0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_100B4920[v2 / 4];
        v8 = *(char **)&off_100B4924[v2];
        v9 = sub_10028460(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100B4924[v2],
               off_100B4920[v2 / 4]);
        v10 = sub_1002CAE0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_100287C0(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100B491C: using guessed type void *off_100B491C;
// 100B4920: using guessed type char *off_100B4920[2];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10036860) --------------------------------------------------------
char sub_10036860()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_101AC3E8 )
  {
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_100287C0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_100287C0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_100287C0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_100287C0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_100287C0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10036A60) --------------------------------------------------------
char sub_10036A60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B49AC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100B49A9[v2 * 4];
        v4 = byte_100B49A8[v2 * 4];
        v5 = sub_10028460(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + dword_100B49AC[v2])],
               (&off_100B49B0)[v2 * 4]);
        v6 = sub_10028900(
               1,
               *(&dword_100AF00C + dword_100B49AC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_10028460(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B49AC[v2]],
               (&off_100B49B0)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B49AC: using guessed type int dword_100B49AC[];
// 100B49B0: using guessed type char *off_100B49B0;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10036BE0) --------------------------------------------------------
char sub_10036BE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B4C30[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100B4C28[v2 / 8];
        v4 = dbl_100B4C20[v2 / 8];
        v5 = dbl_100B4C18[v2 / 8];
        v6 = sub_10028460(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B4C34[v2]);
        v7 = sub_10028CB0(
               1,
               *(&dword_100AF00C + dword_100B4C30[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B4C30[v2 / 4]],
               *(_DWORD *)&off_100B4C34[v2]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B4C18: using guessed type double dbl_100B4C18[];
// 100B4C20: using guessed type double dbl_100B4C20[];
// 100B4C28: using guessed type double dbl_100B4C28[];
// 100B4C30: using guessed type int dword_100B4C30[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10036D60) --------------------------------------------------------
char sub_10036D60()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B5844[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100B5840[v2];
        v4 = flt_100B583C[v2];
        v5 = flt_100B5838[v2];
        v6 = sub_10028460(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B5848[v2 * 4]);
        v7 = sub_10029100(
               1,
               *(&dword_100AF00C + dword_100B5844[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B5844[v2]],
               *(_DWORD *)&off_100B5848[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B5838: using guessed type float flt_100B5838[];
// 100B583C: using guessed type float flt_100B583C[];
// 100B5840: using guessed type float flt_100B5840[];
// 100B5844: using guessed type int dword_100B5844[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10036ED0) --------------------------------------------------------
char sub_10036ED0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101AC3E8 )
  {
    sub_1002CDE0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10036ED0,
      (int)sub_10036ED0,
      0);
    sub_1002CDE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10036ED0,
      0,
      0);
    result = sub_1002CDE0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10036ED0,
               0);
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10036FC0) --------------------------------------------------------
char sub_10036FC0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B5FDC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B5FD8[v2];
        v4 = dword_100B5FD4[v2];
        v5 = dword_100B5FD0[v2];
        v6 = sub_10028460(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B5FE0)[v2 * 4]);
        v7 = sub_100295C0(
               1,
               *(&dword_100AF00C + dword_100B5FDC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B5FDC[v2]],
               (&off_100B5FE0)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B5FD0: using guessed type int dword_100B5FD0[];
// 100B5FD4: using guessed type int dword_100B5FD4[];
// 100B5FD8: using guessed type int dword_100B5FD8[];
// 100B5FDC: using guessed type int dword_100B5FDC[];
// 100B5FE0: using guessed type char *off_100B5FE0;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10037120) --------------------------------------------------------
char sub_10037120()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B6770[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100B676C[v2 / 2];
        v4 = word_100B676A[v2 / 2];
        v5 = word_100B6768[v2 / 2];
        v6 = sub_10028460(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B6774)[v2]);
        v7 = sub_10029980(
               1,
               *(&dword_100AF00C + dword_100B6770[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B6770[v2 / 4]],
               (&off_100B6774)[v2]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B6768: using guessed type __int16 word_100B6768[];
// 100B676A: using guessed type __int16 word_100B676A[];
// 100B676C: using guessed type __int16 word_100B676C[];
// 100B6770: using guessed type int dword_100B6770[];
// 100B6774: using guessed type char *off_100B6774;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10037280) --------------------------------------------------------
char sub_10037280()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B6D84[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B6D80[v2];
        v4 = dword_100B6D7C[v2];
        v5 = dword_100B6D78[v2];
        v6 = sub_10028460(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B6D88[v2 * 4]);
        v7 = sub_10029D80(
               1,
               *(&dword_100AF00C + dword_100B6D84[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B6D84[v2]],
               *(_DWORD *)&off_100B6D88[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B6D78: using guessed type int dword_100B6D78[];
// 100B6D7C: using guessed type int dword_100B6D7C[];
// 100B6D80: using guessed type int dword_100B6D80[];
// 100B6D84: using guessed type int dword_100B6D84[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (100373E0) --------------------------------------------------------
char sub_100373E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B7528[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100B7524[v2];
        LODWORD(v3) = dword_100B7520[v2];
        HIDWORD(v4) = dword_100B751C[v2];
        LODWORD(v4) = dword_100B7518[v2];
        HIDWORD(v5) = dword_100B7514[v2];
        LODWORD(v5) = dword_100B7510[v2];
        v6 = sub_10028460(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B752C[v2 * 4]);
        v7 = sub_1002A140(
               1,
               *(&dword_100AF00C + dword_100B7528[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B7528[v2]],
               *(_DWORD *)&off_100B752C[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B7510: using guessed type int dword_100B7510[];
// 100B7514: using guessed type int dword_100B7514[];
// 100B7518: using guessed type int dword_100B7518[];
// 100B751C: using guessed type int dword_100B751C[];
// 100B7520: using guessed type int dword_100B7520[];
// 100B7524: using guessed type int dword_100B7524[];
// 100B7528: using guessed type int dword_100B7528[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10037550) --------------------------------------------------------
char sub_10037550()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B8134[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100B8132[v2 * 4];
        v4 = byte_100B8131[v2 * 4];
        v5 = byte_100B8130[v2 * 4];
        v6 = sub_10028460(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B8138)[v2 * 4]);
        v7 = sub_1002A680(
               1,
               *(&dword_100AF00C + dword_100B8134[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B8134[v2]],
               (&off_100B8138)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B8134: using guessed type int dword_100B8134[];
// 100B8138: using guessed type char *off_100B8138;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (100376B0) --------------------------------------------------------
char sub_100376B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B85CC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B85C8[v2];
        v4 = dword_100B85C4[v2];
        v5 = dword_100B85C0[v2];
        v6 = sub_10028460(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B85D0)[v2 * 4]);
        v7 = sub_1002AA60(
               1,
               *(&dword_100AF00C + dword_100B85CC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B85CC[v2]],
               (&off_100B85D0)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B85C0: using guessed type int dword_100B85C0[];
// 100B85C4: using guessed type int dword_100B85C4[];
// 100B85C8: using guessed type int dword_100B85C8[];
// 100B85CC: using guessed type int dword_100B85CC[];
// 100B85D0: using guessed type char *off_100B85D0;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10037810) --------------------------------------------------------
char sub_10037810()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101AC3E8 )
  {
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_1002CE90(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10065D59,
           0);
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_1002CE90(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10065D59,
           "a",
           0);
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_1002CE90(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10065D59,
           (const char *)&unk_10065D59,
           0);
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_1002CE90(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_100287C0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10037A10) --------------------------------------------------------
char sub_10037A10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B8D64[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B8D60[v2];
        v4 = dword_100B8D5C[v2];
        v5 = dword_100B8D58[v2];
        v6 = sub_10028460(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B8D68[v2 * 4]);
        v7 = sub_1002AE20(
               1,
               *(&dword_100AF00C + dword_100B8D64[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B8D64[v2]],
               *(_DWORD *)&off_100B8D68[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B8D58: using guessed type int dword_100B8D58[];
// 100B8D5C: using guessed type int dword_100B8D5C[];
// 100B8D60: using guessed type int dword_100B8D60[];
// 100B8D64: using guessed type int dword_100B8D64[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10037B70) --------------------------------------------------------
char sub_10037B70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B90D0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100B90CC[v2 / 2];
        v4 = word_100B90CA[v2 / 2];
        v5 = word_100B90C8[v2 / 2];
        v6 = sub_10028460(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B90D4)[v2]);
        v7 = sub_1002B1C0(
               1,
               *(&dword_100AF00C + dword_100B90D0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B90D0[v2 / 4]],
               (&off_100B90D4)[v2]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B90C8: using guessed type __int16 word_100B90C8[];
// 100B90CA: using guessed type __int16 word_100B90CA[];
// 100B90CC: using guessed type __int16 word_100B90CC[];
// 100B90D0: using guessed type int dword_100B90D0[];
// 100B90D4: using guessed type char *off_100B90D4;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10037CD0) --------------------------------------------------------
char sub_10037CD0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B9394[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B9390[v2];
        v4 = dword_100B938C[v2];
        v5 = dword_100B9388[v2];
        v6 = sub_10028460(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B9398[v2 * 4]);
        v7 = sub_1002B5C0(
               1,
               *(&dword_100AF00C + dword_100B9394[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B9394[v2]],
               *(_DWORD *)&off_100B9398[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B9388: using guessed type int dword_100B9388[];
// 100B938C: using guessed type int dword_100B938C[];
// 100B9390: using guessed type int dword_100B9390[];
// 100B9394: using guessed type int dword_100B9394[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10037E30) --------------------------------------------------------
char sub_10037E30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B9710[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100B970C[v2];
        LODWORD(v3) = dword_100B9708[v2];
        HIDWORD(v4) = dword_100B9704[v2];
        LODWORD(v4) = dword_100B9700[v2];
        HIDWORD(v5) = dword_100B96FC[v2];
        LODWORD(v5) = dword_100B96F8[v2];
        v6 = sub_10028460(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B9714[v2 * 4]);
        v7 = sub_1002B960(
               1,
               *(&dword_100AF00C + dword_100B9710[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B9710[v2]],
               *(_DWORD *)&off_100B9714[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B96F8: using guessed type int dword_100B96F8[];
// 100B96FC: using guessed type int dword_100B96FC[];
// 100B9700: using guessed type int dword_100B9700[];
// 100B9704: using guessed type int dword_100B9704[];
// 100B9708: using guessed type int dword_100B9708[];
// 100B970C: using guessed type int dword_100B970C[];
// 100B9710: using guessed type int dword_100B9710[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10037FA0) --------------------------------------------------------
char sub_10037FA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B9C7C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100B9C7A[v2 * 4];
        v4 = byte_100B9C79[v2 * 4];
        v5 = byte_100B9C78[v2 * 4];
        v6 = sub_10028460(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               (&off_100B9C80)[v2 * 4]);
        v7 = sub_1002BF40(
               1,
               *(&dword_100AF00C + dword_100B9C7C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B9C7C[v2]],
               (&off_100B9C80)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B9C7C: using guessed type int dword_100B9C7C[];
// 100B9C80: using guessed type char *off_100B9C80;
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10038100) --------------------------------------------------------
char sub_10038100()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_101AC3E8 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100B9E94[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100B9E90[v2];
        v4 = dword_100B9E8C[v2];
        v5 = dword_100B9E88[v2];
        v6 = sub_10028460(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * *(&dword_100AF00C + v0)],
               *(_DWORD *)&off_100B9E98[v2 * 4]);
        v7 = sub_1002C330(
               1,
               *(&dword_100AF00C + dword_100B9E94[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_10028460(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100B9E94[v2]],
               *(_DWORD *)&off_100B9E98[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100B9E88: using guessed type int dword_100B9E88[];
// 100B9E8C: using guessed type int dword_100B9E8C[];
// 100B9E90: using guessed type int dword_100B9E90[];
// 100B9E94: using guessed type int dword_100B9E94[];
// 101AC3E8: using guessed type char byte_101AC3E8;

//----- (10038260) --------------------------------------------------------
char sub_10038260()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_101AC3E9 )
  {
    sub_1002CE90(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10027A00(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_100295C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10026460() )
      v1 = 3;
    sub_100295C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10026460();
    sub_100295C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10027A00(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_100295C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10038800) --------------------------------------------------------
char sub_10038800()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101AC3E9 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100BA1FC + v2) )
      {
        sub_100281C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100BA204[v2], 0x100u, &v13);
        sub_100281C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100BA1FC + v2), 0x100u, &v14);
        sub_100334D0(&v14, &v13);
      }
      if ( byte_100BA1F8[v2] )
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = *(int *)((char *)&off_100BA200 + v2);
        v4 = *(char **)&off_100BA204[v2];
        v5 = sub_10028460(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100BA204[v2],
               *(void **)((char *)&off_100BA200 + v2));
        v12 = 1;
        v11 = sub_1002CAE0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2114", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = *(int *)((char *)&off_100BA200 + v2);
        v7 = *(char **)&off_100BA204[v2];
        v8 = sub_10028460(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100BA204[v2],
               *(void **)((char *)&off_100BA200 + v2));
        v12 = 1;
        v11 = sub_1002CAE0(0, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2123", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BA1FC: using guessed type void *off_100BA1FC;
// 100BA200: using guessed type void *off_100BA200;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10038A10) --------------------------------------------------------
char sub_10038A10()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_101AC3E9 )
  {
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_100287C0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_100287C0(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_100287C0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_100287C0(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_100287C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10038C00) --------------------------------------------------------
char sub_10038C00()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100BA24C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100BA249[v2 * 4];
        v4 = byte_100BA248[v2 * 4];
        v5 = sub_10028460(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * dword_100BA24C[v2]],
               (&off_100BA250)[v2 * 4]);
        v6 = sub_10028900(0, dword_100BA24C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_10028460(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100BA24C[v2]],
               (&off_100BA250)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100BA24C: using guessed type int dword_100BA24C[];
// 100BA250: using guessed type char *off_100BA250;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10038D70) --------------------------------------------------------
char sub_10038D70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100BA4C8[v2 / 2];
      v4 = dbl_100BA4C0[v2 / 2];
      v5 = dbl_100BA4B8[v2 / 2];
      v6 = sub_10028460(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BA4D0[v2]],
             *(_DWORD *)&off_100BA4D4[v2 * 4]);
      v7 = sub_10028CB0(0, dword_100BA4D0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BA4D0[v2]],
             *(_DWORD *)&off_100BA4D4[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BA4B8: using guessed type double dbl_100BA4B8[];
// 100BA4C0: using guessed type double dbl_100BA4C0[];
// 100BA4C8: using guessed type double dbl_100BA4C8[];
// 100BA4D0: using guessed type int dword_100BA4D0[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10038EE0) --------------------------------------------------------
char sub_10038EE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100BB0E0[v2];
      v4 = flt_100BB0DC[v2];
      v5 = flt_100BB0D8[v2];
      v6 = sub_10028460(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BB0E4[v2]],
             *(_DWORD *)&off_100BB0E8[v2 * 4]);
      v7 = sub_10029100(0, dword_100BB0E4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BB0E4[v2]],
             *(_DWORD *)&off_100BB0E8[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BB0D8: using guessed type float flt_100BB0D8[];
// 100BB0DC: using guessed type float flt_100BB0DC[];
// 100BB0E0: using guessed type float flt_100BB0E0[];
// 100BB0E4: using guessed type int dword_100BB0E4[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039040) --------------------------------------------------------
char sub_10039040()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101AC3E9 )
  {
    sub_1002CDE0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_10039040,
      (int)sub_10039040,
      0);
    sub_1002CDE0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_10039040,
      0,
      0);
    result = sub_1002CDE0(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10039040,
               0);
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039130) --------------------------------------------------------
char sub_10039130()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100BB878[v2];
      v4 = dword_100BB874[v2];
      v5 = dword_100BB870[v2];
      v6 = sub_10028460(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BB87C[v2]],
             (&off_100BB880)[v2 * 4]);
      v7 = sub_100295C0(0, dword_100BB87C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BB87C[v2]],
             (&off_100BB880)[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BB870: using guessed type int dword_100BB870[];
// 100BB874: using guessed type int dword_100BB874[];
// 100BB878: using guessed type int dword_100BB878[];
// 100BB87C: using guessed type int dword_100BB87C[];
// 100BB880: using guessed type char *off_100BB880;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039290) --------------------------------------------------------
char sub_10039290()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100BC00C[v2 / 2];
      v4 = word_100BC00A[v2 / 2];
      v5 = word_100BC008[v2 / 2];
      v6 = sub_10028460(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BC010[v2 / 4]],
             (&off_100BC014)[v2]);
      v7 = sub_10029980(
             0,
             dword_100BC010[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BC010[v2 / 4]],
             (&off_100BC014)[v2]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BC008: using guessed type __int16 word_100BC008[];
// 100BC00A: using guessed type __int16 word_100BC00A[];
// 100BC00C: using guessed type __int16 word_100BC00C[];
// 100BC010: using guessed type int dword_100BC010[];
// 100BC014: using guessed type char *off_100BC014;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (100393F0) --------------------------------------------------------
char sub_100393F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100BC620[v2];
      v4 = dword_100BC61C[v2];
      v5 = dword_100BC618[v2];
      v6 = sub_10028460(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BC624[v2]],
             *(_DWORD *)&off_100BC628[v2 * 4]);
      v7 = sub_10029D80(0, dword_100BC624[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BC624[v2]],
             *(_DWORD *)&off_100BC628[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BC618: using guessed type int dword_100BC618[];
// 100BC61C: using guessed type int dword_100BC61C[];
// 100BC620: using guessed type int dword_100BC620[];
// 100BC624: using guessed type int dword_100BC624[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039550) --------------------------------------------------------
char sub_10039550()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100BCDC4[v2];
      LODWORD(v3) = dword_100BCDC0[v2];
      HIDWORD(v4) = dword_100BCDBC[v2];
      LODWORD(v4) = dword_100BCDB8[v2];
      HIDWORD(v5) = dword_100BCDB4[v2];
      LODWORD(v5) = dword_100BCDB0[v2];
      v6 = sub_10028460(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BCDC8[v2]],
             *(_DWORD *)&off_100BCDCC[v2 * 4]);
      v7 = sub_1002A140(0, dword_100BCDC8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BCDC8[v2]],
             *(_DWORD *)&off_100BCDCC[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BCDB0: using guessed type int dword_100BCDB0[];
// 100BCDB4: using guessed type int dword_100BCDB4[];
// 100BCDB8: using guessed type int dword_100BCDB8[];
// 100BCDBC: using guessed type int dword_100BCDBC[];
// 100BCDC0: using guessed type int dword_100BCDC0[];
// 100BCDC4: using guessed type int dword_100BCDC4[];
// 100BCDC8: using guessed type int dword_100BCDC8[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (100396C0) --------------------------------------------------------
char sub_100396C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100BD9D2[v2 * 4];
      v4 = byte_100BD9D1[v2 * 4];
      v5 = byte_100BD9D0[v2 * 4];
      v6 = sub_10028460(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BD9D4[v2]],
             (&off_100BD9D8)[v2 * 4]);
      v7 = sub_1002A680(0, dword_100BD9D4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BD9D4[v2]],
             (&off_100BD9D8)[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BD9D4: using guessed type int dword_100BD9D4[];
// 100BD9D8: using guessed type char *off_100BD9D8;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039820) --------------------------------------------------------
char sub_10039820()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100BDE68[v2];
      v4 = dword_100BDE64[v2];
      v5 = dword_100BDE60[v2];
      v6 = sub_10028460(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BDE6C[v2]],
             (&off_100BDE70)[v2 * 4]);
      v7 = sub_1002AA60(0, dword_100BDE6C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BDE6C[v2]],
             (&off_100BDE70)[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BDE60: using guessed type int dword_100BDE60[];
// 100BDE64: using guessed type int dword_100BDE64[];
// 100BDE68: using guessed type int dword_100BDE68[];
// 100BDE6C: using guessed type int dword_100BDE6C[];
// 100BDE70: using guessed type char *off_100BDE70;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039980) --------------------------------------------------------
char sub_10039980()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101AC3E9 )
  {
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_1002CE90(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10065D59,
           (const char *)&unk_10065D59,
           0);
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_1002CE90(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_1002CE90(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10065D59,
           0);
    sub_100287C0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_1002CE90(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_100287C0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039B80) --------------------------------------------------------
char sub_10039B80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100BE600[v2];
      v4 = dword_100BE5FC[v2];
      v5 = dword_100BE5F8[v2];
      v6 = sub_10028460(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BE604[v2]],
             *(_DWORD *)&off_100BE608[v2 * 4]);
      v7 = sub_1002AE20(0, dword_100BE604[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BE604[v2]],
             *(_DWORD *)&off_100BE608[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BE5F8: using guessed type int dword_100BE5F8[];
// 100BE5FC: using guessed type int dword_100BE5FC[];
// 100BE600: using guessed type int dword_100BE600[];
// 100BE604: using guessed type int dword_100BE604[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039CE0) --------------------------------------------------------
char sub_10039CE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100BE96C[v2 / 2];
      v4 = word_100BE96A[v2 / 2];
      v5 = word_100BE968[v2 / 2];
      v6 = sub_10028460(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BE970[v2 / 4]],
             (&off_100BE974)[v2]);
      v7 = sub_1002B1C0(
             0,
             dword_100BE970[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BE970[v2 / 4]],
             (&off_100BE974)[v2]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BE968: using guessed type __int16 word_100BE968[];
// 100BE96A: using guessed type __int16 word_100BE96A[];
// 100BE96C: using guessed type __int16 word_100BE96C[];
// 100BE970: using guessed type int dword_100BE970[];
// 100BE974: using guessed type char *off_100BE974;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039E40) --------------------------------------------------------
char sub_10039E40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100BEC30[v2];
      v4 = dword_100BEC2C[v2];
      v5 = dword_100BEC28[v2];
      v6 = sub_10028460(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BEC34[v2]],
             *(_DWORD *)&off_100BEC38[v2 * 4]);
      v7 = sub_1002B5C0(0, dword_100BEC34[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BEC34[v2]],
             *(_DWORD *)&off_100BEC38[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BEC28: using guessed type int dword_100BEC28[];
// 100BEC2C: using guessed type int dword_100BEC2C[];
// 100BEC30: using guessed type int dword_100BEC30[];
// 100BEC34: using guessed type int dword_100BEC34[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (10039FA0) --------------------------------------------------------
char sub_10039FA0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100BEFAC[v2];
      LODWORD(v3) = dword_100BEFA8[v2];
      HIDWORD(v4) = dword_100BEFA4[v2];
      LODWORD(v4) = dword_100BEFA0[v2];
      HIDWORD(v5) = dword_100BEF9C[v2];
      LODWORD(v5) = dword_100BEF98[v2];
      v6 = sub_10028460(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BEFB0[v2]],
             *(_DWORD *)&off_100BEFB4[v2 * 4]);
      v7 = sub_1002B960(0, dword_100BEFB0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BEFB0[v2]],
             *(_DWORD *)&off_100BEFB4[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BEF98: using guessed type int dword_100BEF98[];
// 100BEF9C: using guessed type int dword_100BEF9C[];
// 100BEFA0: using guessed type int dword_100BEFA0[];
// 100BEFA4: using guessed type int dword_100BEFA4[];
// 100BEFA8: using guessed type int dword_100BEFA8[];
// 100BEFAC: using guessed type int dword_100BEFAC[];
// 100BEFB0: using guessed type int dword_100BEFB0[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003A110) --------------------------------------------------------
char sub_1003A110()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100BF51A[v2 * 4];
      v4 = byte_100BF519[v2 * 4];
      v5 = byte_100BF518[v2 * 4];
      v6 = sub_10028460(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BF51C[v2]],
             (&off_100BF520)[v2 * 4]);
      v7 = sub_1002BF40(0, dword_100BF51C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BF51C[v2]],
             (&off_100BF520)[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BF51C: using guessed type int dword_100BF51C[];
// 100BF520: using guessed type char *off_100BF520;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003A270) --------------------------------------------------------
char sub_1003A270()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100BF730[v2];
      v4 = dword_100BF72C[v2];
      v5 = dword_100BF728[v2];
      v6 = sub_10028460(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BF734[v2]],
             *(_DWORD *)&off_100BF738[v2 * 4]);
      v7 = sub_1002C330(0, dword_100BF734[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BF734[v2]],
             *(_DWORD *)&off_100BF738[v2 * 4]);
      result = sub_100287C0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BF728: using guessed type int dword_100BF728[];
// 100BF72C: using guessed type int dword_100BF72C[];
// 100BF730: using guessed type int dword_100BF730[];
// 100BF734: using guessed type int dword_100BF734[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003A3D0) --------------------------------------------------------
char sub_1003A3D0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_101AC3E9 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100BFA9C + v2) )
      {
        sub_100281C0((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100BFAA4[v2], 0x100u, &v13);
        sub_100281C0((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100BFA9C + v2), 0x100u, &v14);
        sub_100334D0(&v14, &v13);
      }
      if ( byte_100BFA98[v2] )
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = *(int *)((char *)&off_100BFAA0 + v2);
        v4 = *(char **)&off_100BFAA4[v2];
        v5 = sub_10028460(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100BFAA4[v2],
               *(void **)((char *)&off_100BFAA0 + v2));
        v12 = 1;
        v11 = sub_1002CAE0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2745", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = *(int *)((char *)&off_100BFAA0 + v2);
        v7 = *(char **)&off_100BFAA4[v2];
        v8 = sub_10028460(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100BFAA4[v2],
               *(void **)((char *)&off_100BFAA0 + v2));
        v12 = 1;
        v11 = sub_1002CAE0(1, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2754", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BFA9C: using guessed type void *off_100BFA9C;
// 100BFAA0: using guessed type void *off_100BFAA0;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003A5E0) --------------------------------------------------------
char sub_1003A5E0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_101AC3E9 )
  {
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_100287C0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_100287C0(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_100287C0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_100287C0(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_100287C0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003A7D0) --------------------------------------------------------
char sub_1003A7D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      v0 = dword_100BFAEC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100BFAE9[v2 * 4];
        v4 = byte_100BFAE8[v2 * 4];
        v5 = sub_10028460(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100AEFF0[4 * dword_100BFAEC[v2]],
               (&off_100BFAF0)[v2 * 4]);
        v6 = sub_10028900(1, dword_100BFAEC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_10028460(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100AEFF0[4 * dword_100BFAEC[v2]],
               (&off_100BFAF0)[v2 * 4]);
        LOBYTE(v0) = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10027A00(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100BFAEC: using guessed type int dword_100BFAEC[];
// 100BFAF0: using guessed type char *off_100BFAF0;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003A940) --------------------------------------------------------
char sub_1003A940()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100BFD68[v2 / 2];
      v4 = dbl_100BFD60[v2 / 2];
      v5 = dbl_100BFD58[v2 / 2];
      v6 = sub_10028460(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BFD70[v2]],
             *(_DWORD *)&off_100BFD74[v2 * 4]);
      v7 = sub_10028CB0(1, dword_100BFD70[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100BFD70[v2]],
             *(_DWORD *)&off_100BFD74[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100BFD58: using guessed type double dbl_100BFD58[];
// 100BFD60: using guessed type double dbl_100BFD60[];
// 100BFD68: using guessed type double dbl_100BFD68[];
// 100BFD70: using guessed type int dword_100BFD70[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003AAB0) --------------------------------------------------------
char sub_1003AAB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100C0980[v2];
      v4 = flt_100C097C[v2];
      v5 = flt_100C0978[v2];
      v6 = sub_10028460(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C0984[v2]],
             *(_DWORD *)&off_100C0988[v2 * 4]);
      v7 = sub_10029100(1, dword_100C0984[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C0984[v2]],
             *(_DWORD *)&off_100C0988[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C0978: using guessed type float flt_100C0978[];
// 100C097C: using guessed type float flt_100C097C[];
// 100C0980: using guessed type float flt_100C0980[];
// 100C0984: using guessed type int dword_100C0984[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003AC10) --------------------------------------------------------
char sub_1003AC10()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_101AC3E9 )
  {
    sub_1002CDE0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_1003AC10,
      (int)sub_1003AC10,
      0);
    sub_1002CDE0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_1003AC10,
      0,
      0);
    result = sub_1002CDE0(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1003AC10,
               0);
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003AD00) --------------------------------------------------------
char sub_1003AD00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100C1118[v2];
      v4 = dword_100C1114[v2];
      v5 = dword_100C1110[v2];
      v6 = sub_10028460(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C111C[v2]],
             (&off_100C1120)[v2 * 4]);
      v7 = sub_100295C0(1, dword_100C111C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C111C[v2]],
             (&off_100C1120)[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C1110: using guessed type int dword_100C1110[];
// 100C1114: using guessed type int dword_100C1114[];
// 100C1118: using guessed type int dword_100C1118[];
// 100C111C: using guessed type int dword_100C111C[];
// 100C1120: using guessed type char *off_100C1120;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003AE60) --------------------------------------------------------
char sub_1003AE60()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100C18AC[v2 / 2];
      v4 = word_100C18AA[v2 / 2];
      v5 = word_100C18A8[v2 / 2];
      v6 = sub_10028460(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C18B0[v2 / 4]],
             (&off_100C18B4)[v2]);
      v7 = sub_10029980(
             1,
             dword_100C18B0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C18B0[v2 / 4]],
             (&off_100C18B4)[v2]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C18A8: using guessed type __int16 word_100C18A8[];
// 100C18AA: using guessed type __int16 word_100C18AA[];
// 100C18AC: using guessed type __int16 word_100C18AC[];
// 100C18B0: using guessed type int dword_100C18B0[];
// 100C18B4: using guessed type char *off_100C18B4;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003AFC0) --------------------------------------------------------
char sub_1003AFC0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100C1EC0[v2];
      v4 = dword_100C1EBC[v2];
      v5 = dword_100C1EB8[v2];
      v6 = sub_10028460(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C1EC4[v2]],
             *(_DWORD *)&off_100C1EC8[v2 * 4]);
      v7 = sub_10029D80(1, dword_100C1EC4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C1EC4[v2]],
             *(_DWORD *)&off_100C1EC8[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C1EB8: using guessed type int dword_100C1EB8[];
// 100C1EBC: using guessed type int dword_100C1EBC[];
// 100C1EC0: using guessed type int dword_100C1EC0[];
// 100C1EC4: using guessed type int dword_100C1EC4[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003B120) --------------------------------------------------------
char sub_1003B120()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100C2664[v2];
      LODWORD(v3) = dword_100C2660[v2];
      HIDWORD(v4) = dword_100C265C[v2];
      LODWORD(v4) = dword_100C2658[v2];
      HIDWORD(v5) = dword_100C2654[v2];
      LODWORD(v5) = dword_100C2650[v2];
      v6 = sub_10028460(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C2668[v2]],
             *(_DWORD *)&off_100C266C[v2 * 4]);
      v7 = sub_1002A140(1, dword_100C2668[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C2668[v2]],
             *(_DWORD *)&off_100C266C[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C2650: using guessed type int dword_100C2650[];
// 100C2654: using guessed type int dword_100C2654[];
// 100C2658: using guessed type int dword_100C2658[];
// 100C265C: using guessed type int dword_100C265C[];
// 100C2660: using guessed type int dword_100C2660[];
// 100C2664: using guessed type int dword_100C2664[];
// 100C2668: using guessed type int dword_100C2668[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003B290) --------------------------------------------------------
char sub_1003B290()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100C3272[v2 * 4];
      v4 = byte_100C3271[v2 * 4];
      v5 = byte_100C3270[v2 * 4];
      v6 = sub_10028460(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C3274[v2]],
             (&off_100C3278)[v2 * 4]);
      v7 = sub_1002A680(1, dword_100C3274[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C3274[v2]],
             (&off_100C3278)[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C3274: using guessed type int dword_100C3274[];
// 100C3278: using guessed type char *off_100C3278;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003B3F0) --------------------------------------------------------
char sub_1003B3F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100C3708[v2];
      v4 = dword_100C3704[v2];
      v5 = dword_100C3700[v2];
      v6 = sub_10028460(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C370C[v2]],
             (&off_100C3710)[v2 * 4]);
      v7 = sub_1002AA60(1, dword_100C370C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C370C[v2]],
             (&off_100C3710)[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C3700: using guessed type int dword_100C3700[];
// 100C3704: using guessed type int dword_100C3704[];
// 100C3708: using guessed type int dword_100C3708[];
// 100C370C: using guessed type int dword_100C370C[];
// 100C3710: using guessed type char *off_100C3710;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003B550) --------------------------------------------------------
char sub_1003B550()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10027A00(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_10028350(0);
  sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10027A00(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_101AC3E9 )
  {
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_1002CE90(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10065D59,
           (const char *)&unk_10065D59,
           0);
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_1002CE90(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_1002CE90(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10065D59,
           0);
    sub_100287C0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_1002CE90(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_100287C0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003B750) --------------------------------------------------------
char sub_1003B750()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100C3EA0[v2];
      v4 = dword_100C3E9C[v2];
      v5 = dword_100C3E98[v2];
      v6 = sub_10028460(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C3EA4[v2]],
             *(_DWORD *)&off_100C3EA8[v2 * 4]);
      v7 = sub_1002AE20(1, dword_100C3EA4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C3EA4[v2]],
             *(_DWORD *)&off_100C3EA8[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C3E98: using guessed type int dword_100C3E98[];
// 100C3E9C: using guessed type int dword_100C3E9C[];
// 100C3EA0: using guessed type int dword_100C3EA0[];
// 100C3EA4: using guessed type int dword_100C3EA4[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003B8B0) --------------------------------------------------------
char sub_1003B8B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100C420C[v2 / 2];
      v4 = word_100C420A[v2 / 2];
      v5 = word_100C4208[v2 / 2];
      v6 = sub_10028460(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C4210[v2 / 4]],
             (&off_100C4214)[v2]);
      v7 = sub_1002B1C0(
             1,
             dword_100C4210[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C4210[v2 / 4]],
             (&off_100C4214)[v2]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C4208: using guessed type __int16 word_100C4208[];
// 100C420A: using guessed type __int16 word_100C420A[];
// 100C420C: using guessed type __int16 word_100C420C[];
// 100C4210: using guessed type int dword_100C4210[];
// 100C4214: using guessed type char *off_100C4214;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003BA10) --------------------------------------------------------
char sub_1003BA10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100C44D0[v2];
      v4 = dword_100C44CC[v2];
      v5 = dword_100C44C8[v2];
      v6 = sub_10028460(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C44D4[v2]],
             *(_DWORD *)&off_100C44D8[v2 * 4]);
      v7 = sub_1002B5C0(1, dword_100C44D4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C44D4[v2]],
             *(_DWORD *)&off_100C44D8[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C44C8: using guessed type int dword_100C44C8[];
// 100C44CC: using guessed type int dword_100C44CC[];
// 100C44D0: using guessed type int dword_100C44D0[];
// 100C44D4: using guessed type int dword_100C44D4[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003BB70) --------------------------------------------------------
char sub_1003BB70()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100C484C[v2];
      LODWORD(v3) = dword_100C4848[v2];
      HIDWORD(v4) = dword_100C4844[v2];
      LODWORD(v4) = dword_100C4840[v2];
      HIDWORD(v5) = dword_100C483C[v2];
      LODWORD(v5) = dword_100C4838[v2];
      v6 = sub_10028460(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C4850[v2]],
             *(_DWORD *)&off_100C4854[v2 * 4]);
      v7 = sub_1002B960(1, dword_100C4850[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C4850[v2]],
             *(_DWORD *)&off_100C4854[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C4838: using guessed type int dword_100C4838[];
// 100C483C: using guessed type int dword_100C483C[];
// 100C4840: using guessed type int dword_100C4840[];
// 100C4844: using guessed type int dword_100C4844[];
// 100C4848: using guessed type int dword_100C4848[];
// 100C484C: using guessed type int dword_100C484C[];
// 100C4850: using guessed type int dword_100C4850[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003BCE0) --------------------------------------------------------
char sub_1003BCE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100C4DBA[v2 * 4];
      v4 = byte_100C4DB9[v2 * 4];
      v5 = byte_100C4DB8[v2 * 4];
      v6 = sub_10028460(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C4DBC[v2]],
             (&off_100C4DC0)[v2 * 4]);
      v7 = sub_1002BF40(1, dword_100C4DBC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C4DBC[v2]],
             (&off_100C4DC0)[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C4DBC: using guessed type int dword_100C4DBC[];
// 100C4DC0: using guessed type char *off_100C4DC0;
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003BE40) --------------------------------------------------------
char sub_1003BE40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_101AC3E9 )
  {
    sub_10027A00(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_10028350(0);
    sub_10027A00(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10027A00(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_10028440(0);
    v2 = 0;
    do
    {
      sub_10028370((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100C4FD0[v2];
      v4 = dword_100C4FCC[v2];
      v5 = dword_100C4FC8[v2];
      v6 = sub_10028460(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C4FD4[v2]],
             *(_DWORD *)&off_100C4FD8[v2 * 4]);
      v7 = sub_1002C330(1, dword_100C4FD4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_10028460(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100AEFF0[4 * dword_100C4FD4[v2]],
             *(_DWORD *)&off_100C4FD8[v2 * 4]);
      result = sub_100287C0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10027A00(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100C4FC8: using guessed type int dword_100C4FC8[];
// 100C4FCC: using guessed type int dword_100C4FCC[];
// 100C4FD0: using guessed type int dword_100C4FD0[];
// 100C4FD4: using guessed type int dword_100C4FD4[];
// 101AC3E9: using guessed type char byte_101AC3E9;

//----- (1003BFA0) --------------------------------------------------------
char **sub_1003BFA0()
{
  return off_100B06DC;
}
// 100B06DC: using guessed type char *off_100B06DC[3];

//----- (1003BFB0) --------------------------------------------------------
int __cdecl sub_1003BFB0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (1003BFD0) --------------------------------------------------------
int (__cdecl *__usercall sub_1003BFD0@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (1003BFE0) --------------------------------------------------------
int __usercall sub_1003BFE0@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (1003C210) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003C210(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1003BFD0(a1, (int)word_10060D0C);
  sub_1003BFD0(a1, a2);
  sub_1003BFD0(a1, (int)&unk_100C922C);
  v3 = sub_1003BFE0(a3, a1);
  sub_1003BFD0(a1, v3);
  return sub_1003BFD0(a1, (int)&unk_100C9228);
}

//----- (1003C260) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003C260(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1003BFD0(a1, (int)word_10060D0C);
  sub_1003BFD0(a1, a2);
  sub_1003BFD0(a1, (int)&unk_100C9234);
  v3 = sub_1003BFE0(a3, a1);
  sub_1003BFD0(a1, v3);
  return sub_1003BFD0(a1, (int)&unk_100C9230);
}

//----- (1003C2B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003C2B0(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_1003BFD0(a1, (int)&unk_100C9238);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_1003BFE0(a2, a1);
    result = sub_1003BFD0(a1, v3);
  }
  return result;
}

//----- (1003C300) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003C300(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100C9240;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_1003BFD0(a1, dword_100C9194[(signed int)result]);
      sub_1003BFD0(a1, (int)&unk_100C923C);
      sub_1003BFD0(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100C9238;
    }
    result = sub_1003BFD0(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_1003BFD0(a1, (int)&word_1009FE94);
  }
  return result;
}
// 1009FE94: using guessed type __int16 word_1009FE94;
// 100C9194: using guessed type int dword_100C9194[];

//----- (1003C380) --------------------------------------------------------
int __cdecl sub_1003C380(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_1003BFD0(a1, (int)&unk_100C9238);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_1003BFD0(a1, *((_DWORD *)&off_100C9198 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_1003BFD0(a1, (int)&unk_100C9244);
  sub_1003BFD0(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (1003C400) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003C400(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_1003BFE0(a2, a1);
    sub_1003BFD0(a1, v3);
    result = sub_1003BFD0(a1, (int)&word_1009FE94);
  }
  else
  {
    sub_1003BFD0(a1, (int)a2);
    result = sub_1003BFD0(a1, (int)&word_1009FE94);
  }
  return result;
}
// 1009FE94: using guessed type __int16 word_1009FE94;

//----- (1003C450) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003C450(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_1003C380(a1, a2);
  if ( a3 && *a3 )
    sub_1003C2B0(a1, a3);
  return sub_1003C300(a1);
}

//----- (1003C490) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003C490(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_1003C450(a1, a2, (unsigned __int8 *)&v4);
}

//----- (1003C4F0) --------------------------------------------------------
int __cdecl sub_1003C4F0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001E3C0(&a1, 1u, (int)&unk_100CACB8, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100CACBC[2 * v1];
  }
  else
  {
    sub_10004C50("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100CACBC: using guessed type int dword_100CACBC[];

//----- (1003C540) --------------------------------------------------------
bool __cdecl sub_1003C540(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_1001E3C0(&a2, 4u, (int)&dword_100CEAD8, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_10005070((unsigned __int16)word_100CEADC[a1 + 6 * v3], a3, (unsigned __int16)word_100CEAE0[6 * v3]) == 0;
  }
  else
  {
    sub_10004C50("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100CEAD8: using guessed type int dword_100CEAD8;
// 100CEADC: using guessed type __int16 word_100CEADC[];
// 100CEAE0: using guessed type __int16 word_100CEAE0[];

//----- (1003C5D0) --------------------------------------------------------
bool __cdecl sub_1003C5D0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_1003C670(a1);
  v6 = sub_1001E3C0(&a3, 1u, (int)&unk_100CEAFC, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_1001E3C0(&dword_100CEB00[2 * v6], 4u, (int)&dword_100CEAD8, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100CEAE0[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_1003C540(v11, *(int *)((char *)&dword_100CEAD8 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100CEAD8: using guessed type int dword_100CEAD8;
// 100CEAE0: using guessed type __int16 word_100CEAE0[];

//----- (1003C670) --------------------------------------------------------
char __cdecl sub_1003C670(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10004C50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1003C6F0) --------------------------------------------------------
char __cdecl sub_1003C6F0(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_10030920(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_10005070(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10030940((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1003C860) --------------------------------------------------------
int __usercall sub_1003C860@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1003C6F0(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1003C860: using guessed type int var_2C[10];

//----- (1003C8A0) --------------------------------------------------------
int __usercall sub_1003C8A0@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1003C6F0(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1003C8A0: using guessed type int var_14[4];

//----- (1003C8E0) --------------------------------------------------------
signed int sub_1003C8E0()
{
  return sub_1005B6D0((int)&off_100D09A0);
}
// 100D09A0: using guessed type char *off_100D09A0;

//----- (1003C8F0) --------------------------------------------------------
char __cdecl sub_1003C8F0(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1003C8E0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101E38A8 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101E38A8 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_101E38A8);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E38A8: using guessed type int dword_101E38A8;

//----- (1003C950) --------------------------------------------------------
char __cdecl sub_1003C950(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1003C8E0() )
  {
    if ( (sub_10030C90(a1)
       || *(_BYTE *)(dword_101E38A8 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_101E38A8 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_101E38A8 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E38A8 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E38A8 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E38A8 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E38A8 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E38A8 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E38A8 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_101E38A8 + 176))
      && *(_BYTE *)(dword_101E38A8 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_101E38A8 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101E38A8 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_101E38A8 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_101E38A8 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E38A8: using guessed type int dword_101E38A8;

//----- (1003CA70) --------------------------------------------------------
char __cdecl sub_1003CA70(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1003C8E0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_101E38A8 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_101E38A8 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_101E38A8 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_101E38A8 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_101E38A8);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101E38A8: using guessed type int dword_101E38A8;

//----- (1003CAF0) --------------------------------------------------------
char __cdecl sub_1003CAF0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10004C50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1003C8A0(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_1003CA70(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1003C860(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1003C8F0(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1003C6F0(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1003C950(v6, a5);
        }
      }
      else
      {
        sub_10004C50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10004C50("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1003CCA0) --------------------------------------------------------
int __cdecl sub_1003CCA0(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100D174C[2 * sub_1001E3C0(&a1, 1u, (int)&unk_100D1748, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100D178C[2 * sub_1001E3C0(&a2, 1u, (int)&unk_100D1788, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100D17BC[2 * sub_1001E3C0(&a2, 1u, (int)&unk_100D17B8, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100D1764[2 * sub_1001E3C0(&a2, 1u, (int)&unk_100D1760, 8, 5, 5)];
  }
  return result;
}
// 100D174C: using guessed type int dword_100D174C[];
// 100D1764: using guessed type int dword_100D1764[];
// 100D178C: using guessed type int dword_100D178C[];
// 100D17BC: using guessed type int dword_100D17BC[];

//----- (1003CD50) --------------------------------------------------------
bool __usercall sub_1003CD50@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100DA32F[44 * a1] - (unsigned __int8)byte_100DA32A[44 * a1];
}

//----- (1003CD80) --------------------------------------------------------
char __usercall sub_1003CD80@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_1003CD50(a1, a4, a5) )
  {
    v6 = a3
       + sub_1003CCA0(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100DA32A[44 * a1] - (unsigned __int8)byte_100DA32F[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy_0(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_1003CCA0(a1, a4);
    memcpy_0(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (1003CE20) --------------------------------------------------------
char __cdecl sub_1003CE20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10031090(a1);
  sub_10005090(v5, (int)&v7, 3684);
  return sub_1003CD80(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (1003CEA0) --------------------------------------------------------
char __cdecl sub_1003CEA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10031090(a1);
  sub_10005090(v5, (int)&v7, 3684);
  return sub_1003CD80(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (1003CF20) --------------------------------------------------------
char __cdecl sub_1003CF20(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10031090(a1);
  sub_10005090(v5, (int)&v7, 3684);
  return sub_1003CD80(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (1003CFA0) --------------------------------------------------------
char __cdecl sub_1003CFA0(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10031090(a1);
  sub_10005090(v5, (int)&v7, 3684);
  return sub_1003CD80(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (1003D020) --------------------------------------------------------
char __cdecl sub_1003D020(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10004C50("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1003D0C0) --------------------------------------------------------
int __cdecl sub_1003D0C0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (1003D0E0) --------------------------------------------------------
char __cdecl sub_1003D0E0(char a1, char a2, char a3, char a4, char a5, int a6, char a7, __int16 a8, char *a9)
{
  char *v9; // eax@1
  char v10; // cl@2
  __int16 v12; // [sp+0h] [bp-52Ch]@1
  char v13; // [sp+4h] [bp-528h]@1
  char v14; // [sp+5h] [bp-527h]@1
  char v15; // [sp+6h] [bp-526h]@1
  char v16; // [sp+7h] [bp-525h]@1
  char v17; // [sp+8h] [bp-524h]@1
  char v18; // [sp+9h] [bp-523h]@1
  __int16 v19; // [sp+Ah] [bp-522h]@1
  int v20; // [sp+Ch] [bp-520h]@1
  char v21[1300]; // [sp+14h] [bp-518h]@2

  memset(&v12, 0, 0x528u);
  v15 = a4;
  v20 = a6;
  v16 = a3;
  v13 = a1;
  v9 = a9;
  v17 = a5;
  v14 = a2;
  v12 = -32708;
  v18 = a7;
  v19 = a8;
  if ( a9 )
  {
    do
    {
      v10 = *v9;
      v9[v21 - a9] = *v9;
      ++v9;
    }
    while ( v10 );
  }
  return sub_100301E0((int)&v12);
}
// 1003D0E0: using guessed type char var_518[1300];

//----- (1003D1B0) --------------------------------------------------------
signed int __cdecl sub_1003D1B0(int (__cdecl *a1)(int))
{
  signed int result; // eax@1
  int (__cdecl **v2)(int); // ecx@1

  result = 0;
  v2 = &off_100636EC;
  do
  {
    if ( *v2 == a1 )
      break;
    ++result;
    v2 += 14;
  }
  while ( result < 1 );
  if ( result == 1 )
    result = -1;
  return result;
}
// 100636EC: using guessed type int (__cdecl *off_100636EC)(int);

//----- (1003D1E0) --------------------------------------------------------
char *__cdecl sub_1003D1E0(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( (signed int)a1 >= 1 )
    result = (char *)&unk_10065D59;
  else
    result = &aStatus[56 * a1];
  return result;
}

//----- (1003D210) --------------------------------------------------------
int __cdecl sub_1003D210(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_1001E3C0(&a1, 1u, (int)&unk_100D2368, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_100D2369 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (1003D260) --------------------------------------------------------
signed int __usercall sub_1003D260@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100D3078[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100D2478[2 * (unsigned __int8)v68] ^ dword_100D2878[2 * BYTE1(v65)] ^ dword_100D2C78[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100D3078[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100D3078[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100D3078[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100D3078[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100D3078[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100D3078[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100D3078[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100D3078[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100D3078[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100D3478[(unsigned __int8)v57] ^ dword_100D4078[v58 >> 24] ^ dword_100D3878[BYTE1(v59)] ^ dword_100D3C78[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100D3478[(unsigned __int8)v59] ^ dword_100D3C78[(unsigned __int8)(v58 >> 16)] ^ dword_100D4078[v57 >> 24] ^ dword_100D3878[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100D3478[(unsigned __int8)v60] ^ dword_100D3878[BYTE1(v58)] ^ dword_100D3C78[(unsigned __int8)(v57 >> 16)] ^ dword_100D4078[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100D3478[(unsigned __int8)v58] ^ dword_100D3878[BYTE1(v57)] ^ dword_100D3C78[(unsigned __int8)(v59 >> 16)] ^ dword_100D4078[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100D3078[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100D3078[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100D3078[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100D3078[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100D3078[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100D2478[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100D2878[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100D2C78[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100D3078[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100D3478: using guessed type int dword_100D3478[];
// 100D3878: using guessed type int dword_100D3878[];
// 100D3C78: using guessed type int dword_100D3C78[];
// 100D4078: using guessed type int dword_100D4078[];

//----- (1003E310) --------------------------------------------------------
int __usercall sub_1003E310@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_1003D260(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (1003E370) --------------------------------------------------------
signed int __usercall sub_1003E370@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100D4078[(unsigned __int8)v9] ^ dword_100D3478[BYTE1(v9)] ^ dword_100D3878[(unsigned __int8)(v9 >> 16)] ^ dword_100D3C78[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100D4078[(unsigned __int8)v129] ^ dword_100D3478[BYTE1(v129)] ^ dword_100D3878[(unsigned __int8)(v129 >> 16)] ^ dword_100D3C78[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100D4078[(unsigned __int8)v133] ^ dword_100D3478[BYTE1(v133)] ^ dword_100D3878[(unsigned __int8)(v133 >> 16)] ^ dword_100D3C78[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100D4078[(unsigned __int8)v137] ^ dword_100D3478[BYTE1(v137)] ^ dword_100D3878[(unsigned __int8)(v137 >> 16)] ^ dword_100D3C78[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100D4078[(unsigned __int8)v141] ^ dword_100D3478[BYTE1(v141)] ^ dword_100D3878[(unsigned __int8)(v141 >> 16)] ^ dword_100D3C78[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100D4078[(unsigned __int8)v145] ^ dword_100D3478[BYTE1(v145)] ^ dword_100D3878[(unsigned __int8)(v145 >> 16)] ^ dword_100D3C78[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100D4078[(unsigned __int8)v149] ^ dword_100D3478[BYTE1(v149)] ^ dword_100D3878[(unsigned __int8)(v149 >> 16)] ^ dword_100D3C78[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100D4078[(unsigned __int8)v153] ^ dword_100D3478[BYTE1(v153)] ^ dword_100D3878[(unsigned __int8)(v153 >> 16)] ^ dword_100D3C78[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100D4078[(unsigned __int8)v157] ^ dword_100D3478[BYTE1(v157)] ^ dword_100D3878[(unsigned __int8)(v157 >> 16)] ^ dword_100D3C78[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100D4078[(unsigned __int8)v161] ^ dword_100D3478[BYTE1(v161)] ^ dword_100D3878[(unsigned __int8)(v161 >> 16)] ^ dword_100D3C78[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100D4078[(unsigned __int8)v77] ^ dword_100D3478[BYTE1(v77)] ^ dword_100D3878[(unsigned __int8)(v77 >> 16)] ^ dword_100D3C78[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100D4078[(unsigned __int8)v82] ^ dword_100D3478[BYTE1(v82)] ^ dword_100D3878[(unsigned __int8)(v82 >> 16)] ^ dword_100D3C78[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100D4078[(unsigned __int8)v89] ^ dword_100D3478[BYTE1(v89)] ^ dword_100D3878[(unsigned __int8)(v89 >> 16)] ^ dword_100D3C78[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100D4078[(unsigned __int8)v94] ^ dword_100D3478[BYTE1(v94)] ^ dword_100D3878[(unsigned __int8)(v94 >> 16)] ^ dword_100D3C78[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100D4078[(unsigned __int8)v100] ^ dword_100D3478[BYTE1(v100)] ^ dword_100D3878[(unsigned __int8)(v100 >> 16)] ^ dword_100D3C78[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100D4078[(unsigned __int8)v100] ^ dword_100D3478[BYTE1(v100)] ^ dword_100D3878[(unsigned __int8)(v100 >> 16)] ^ dword_100D3C78[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100D4078[(unsigned __int8)v108] ^ dword_100D3478[BYTE1(v108)] ^ dword_100D3878[(unsigned __int8)(v108 >> 16)] ^ dword_100D3C78[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100D4078[(unsigned __int8)v114] ^ dword_100D3478[BYTE1(v114)] ^ dword_100D3878[(unsigned __int8)(v114 >> 16)] ^ dword_100D3C78[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100D4078[(unsigned __int8)v120] ^ dword_100D3478[BYTE1(v120)] ^ dword_100D3878[(unsigned __int8)(v120 >> 16)] ^ dword_100D3C78[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100D4078[(unsigned __int8)v19] ^ dword_100D3478[BYTE1(v19)] ^ dword_100D3878[(unsigned __int8)(v19 >> 16)] ^ dword_100D3C78[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100D3478[(unsigned __int8)v23] ^ dword_100D3878[BYTE1(v23)] ^ dword_100D3C78[(unsigned __int8)(v23 >> 16)] ^ dword_100D4078[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100D4078[(unsigned __int8)v26] ^ dword_100D3478[BYTE1(v26)] ^ dword_100D3878[(unsigned __int8)(v26 >> 16)] ^ dword_100D3C78[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100D3478[(unsigned __int8)v31] ^ dword_100D3878[BYTE1(v31)] ^ dword_100D3C78[(unsigned __int8)(v31 >> 16)] ^ dword_100D4078[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100D4078[(unsigned __int8)v35] ^ dword_100D3478[BYTE1(v35)] ^ dword_100D3878[(unsigned __int8)(v35 >> 16)] ^ dword_100D3C78[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100D3478[(unsigned __int8)v41] ^ dword_100D3878[BYTE1(v41)] ^ dword_100D3C78[(unsigned __int8)(v41 >> 16)] ^ dword_100D4078[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100D4078[(unsigned __int8)v43] ^ dword_100D3478[BYTE1(v43)] ^ dword_100D3878[(unsigned __int8)(v43 >> 16)] ^ dword_100D3C78[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100D3478[(unsigned __int8)v47] ^ dword_100D3878[BYTE1(v47)] ^ dword_100D3C78[(unsigned __int8)(v47 >> 16)] ^ dword_100D4078[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100D4078[(unsigned __int8)v52] ^ dword_100D3478[BYTE1(v52)] ^ dword_100D3878[(unsigned __int8)(v52 >> 16)] ^ dword_100D3C78[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100D3478[(unsigned __int8)v58] ^ dword_100D3878[BYTE1(v58)] ^ dword_100D3C78[(unsigned __int8)(v58 >> 16)] ^ dword_100D4078[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100D4078[(unsigned __int8)v60] ^ dword_100D3478[BYTE1(v60)] ^ dword_100D3878[(unsigned __int8)(v60 >> 16)] ^ dword_100D3C78[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100D3478[(unsigned __int8)v66] ^ dword_100D3878[BYTE1(v66)] ^ dword_100D3C78[(unsigned __int8)(v66 >> 16)] ^ dword_100D4078[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100D4078[(unsigned __int8)v69] ^ dword_100D3478[BYTE1(v69)] ^ dword_100D3878[(unsigned __int8)(v69 >> 16)] ^ dword_100D3C78[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100D3478: using guessed type int dword_100D3478[];
// 100D3878: using guessed type int dword_100D3878[];
// 100D3C78: using guessed type int dword_100D3C78[];
// 100D4078: using guessed type int dword_100D4078[];

//----- (1003F0F0) --------------------------------------------------------
void *__usercall sub_1003F0F0@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (1003F110) --------------------------------------------------------
unsigned int __cdecl sub_1003F110(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10004DF0();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 10004E40: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (1003F170) --------------------------------------------------------
int __usercall sub_1003F170@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (1003F1B0) --------------------------------------------------------
int __usercall sub_1003F1B0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (100408D0) --------------------------------------------------------
unsigned int __usercall sub_100408D0@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100D44A0[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100D44B0[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_1003F1B0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_1003F1B0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100D44A0: using guessed type int dword_100D44A0[];
// 100D44B0: using guessed type int dword_100D44B0[];

//----- (100409D0) --------------------------------------------------------
void *__usercall sub_100409D0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy_0((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_1003F1B0(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy_0((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10040A50) --------------------------------------------------------
void *__usercall sub_10040A50@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_100408D0(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_1003F170(v3 + 64);
    result = sub_100409D0(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_100409D0(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10040AF0) --------------------------------------------------------
int __usercall sub_10040AF0@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10040A50(a1, 0, 0);
  sub_100408D0(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_1003F170(a1 + 64);
  sub_100409D0(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_100409D0(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_100408D0(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy_0((void *)a2, &v5, a3);
  return result;
}

//----- (10040BB0) --------------------------------------------------------
int __usercall sub_10040BB0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy_0((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_1003F170(a2 + 64);
    sub_100409D0(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_100409D0(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10040C10) --------------------------------------------------------
int __usercall sub_10040C10@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy_0(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy_0(&v19[v6], a1, 64 - v6);
    sub_1003F1B0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10040C10: using guessed type char var_40[64];

//----- (10040CD0) --------------------------------------------------------
int __usercall sub_10040CD0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10040C10((char *)a1);
  return sub_10040C10(v8);
}

//----- (10040D90) --------------------------------------------------------
char __cdecl sub_10040D90(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10040A50(a3 + 296, a2, a1);
    sub_1003E310(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10040DE0) --------------------------------------------------------
char __cdecl sub_10040DE0(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1003E310(a3, (int)a1, a2);
    sub_10040A50(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10040E30) --------------------------------------------------------
bool __cdecl sub_10040E30(int a1, int a2)
{
  if ( a2 )
    sub_10040AF0(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (10040E60) --------------------------------------------------------
int __usercall sub_10040E60@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_1003F0F0(&v24);
  sub_10040BB0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10040A50((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10040A50((int)&v23, v12, (char *)&v31);
          sub_10040AF0((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 10040E60: using guessed type char var_14[16];

//----- (10041070) --------------------------------------------------------
int __usercall sub_10041070@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_10040CD0(v2);
  v3 = 20;
  do
  {
    sub_10040C10((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_10040CD0(v2);
}

//----- (100410C0) --------------------------------------------------------
char *__cdecl sub_100410C0(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy_0(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10040CD0(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (10041150) --------------------------------------------------------
signed int __cdecl sub_10041150(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_10040E60(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_1003E370(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_1003F0F0((void *)(a6 + 296));
      sub_10040BB0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 10041150: using guessed type char var_40[8];
// 10041150: using guessed type __int16 var_38[26];

//----- (10041280) --------------------------------------------------------
bool __cdecl sub_10041280(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_10041070(&v4, (int)sub_1003F110);
  if ( v2 )
    sub_100410C0(a2, (int)&v4);
  return v2;
}

//----- (10041300) --------------------------------------------------------
BOOL __usercall sub_10041300@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100D4CB8[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100D4BB8[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100D4AB8[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (100413A0) --------------------------------------------------------
int __usercall sub_100413A0@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (10041430) --------------------------------------------------------
unsigned int __fastcall sub_10041430(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (10041450) --------------------------------------------------------
int __usercall sub_10041450@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (100414E0) --------------------------------------------------------
int __usercall sub_100414E0@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100D4CB8[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100D4CB8[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100D44C0[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100D4DB8[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100D4BB8[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100D4AB8[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100D4548[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100D4E30[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100D44C0: using guessed type int dword_100D44C0[];
// 100D4548: using guessed type int dword_100D4548[];
// 100D4DB8: using guessed type int dword_100D4DB8[];
// 100D4E30: using guessed type int dword_100D4E30[];

//----- (10041960) --------------------------------------------------------
int __usercall sub_10041960@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_10041450(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10041A10) --------------------------------------------------------
void *__usercall sub_10041A10@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy_0(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10041A70) --------------------------------------------------------
int __usercall sub_10041A70@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10041C40) --------------------------------------------------------
signed int __usercall sub_10041C40@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_10041430(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (10041CC0) --------------------------------------------------------
_WORD *__fastcall sub_10041CC0(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10041D30) --------------------------------------------------------
unsigned int __usercall sub_10041D30@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10041EE0) --------------------------------------------------------
unsigned int __usercall sub_10041EE0@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (10041FB0) --------------------------------------------------------
int __usercall sub_10041FB0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (10042060) --------------------------------------------------------
int __usercall sub_10042060@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (100420A0) --------------------------------------------------------
unsigned int __usercall sub_100420A0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_10043E70(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy_0(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10042100) --------------------------------------------------------
signed int __usercall sub_10042100@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (100421E0) --------------------------------------------------------
int __usercall sub_100421E0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (10042780) --------------------------------------------------------
int __usercall sub_10042780@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_100413A0(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_100413A0(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_100413A0(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (100429C0) --------------------------------------------------------
int __usercall sub_100429C0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_10041960(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_10041960(a1, a3, a4);
  }
  return result;
}

//----- (10042A60) --------------------------------------------------------
signed int __usercall sub_10042A60@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_10041FB0(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_10041FB0(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_10041FB0(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10041A70(a1, a2);
  return sub_10041C40(a1, v16, v5);
}

//----- (10042C40) --------------------------------------------------------
unsigned int __usercall sub_10042C40@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy_0(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_100420A0(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (10042D80) --------------------------------------------------------
int __usercall sub_10042D80@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100D4534[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_100421E0(a1, a1 + 2936, a2 - 1);
  return sub_100421E0(v24, v24 + 5228, a3 - 1);
}

//----- (10043030) --------------------------------------------------------
signed int __cdecl sub_10043030(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_10042060(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_10042060(v9, *(_WORD *)(a1 + 30));
      sub_10042060(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_10043E70(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10041A10(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100D4EB0 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_10042780(v2);
    }
    else
    {
      sub_100429C0(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10041A10(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_10042060(v2, *(_WORD *)(a1 + 30));
    sub_10042060(v13, *(_WORD *)(a1 + 28));
    sub_10041A10(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100D4EB0: using guessed type int (__cdecl *off_100D4EB0)(int, int);

//----- (100432F0) --------------------------------------------------------
signed int __usercall sub_100432F0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_10042100(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_10042100(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10042A60(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100D4534[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100D4533[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100D4532[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100D4531[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (100433C0) --------------------------------------------------------
_WORD *__usercall sub_100433C0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10042A60(a2, a2 + 5628);
  sub_10042A60(v4, v4 + 5640);
  v8 = sub_100432F0(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_100429C0(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_100414E0(v4, (int)&unk_100D45C0, (int)&unk_100D4A40);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_10042D80(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_100414E0(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_10041CC0(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_10041450(v4);
  return result;
}

//----- (100435E0) --------------------------------------------------------
signed int __cdecl sub_100435E0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10042C40(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10041D30(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_10041EE0(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_10041300(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_10041300(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_100433C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10041A10(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_100433C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10041A10(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (100438F0) --------------------------------------------------------
signed int __cdecl sub_100438F0(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10042C40(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10041D30(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_10041EE0(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_10041300(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_100433C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10041A10(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_10041300(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_100433C0(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10041A10(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_10041300(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_100433C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10041A10(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (10043D00) --------------------------------------------------------
signed int __cdecl sub_10043D00(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_10042C40(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_100433C0(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10041A10(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_100433C0(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10041A10(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_100433C0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10041A10(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10043E70) --------------------------------------------------------
int __cdecl sub_10043E70(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (10043F70) --------------------------------------------------------
signed int __cdecl sub_10043F70(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10043F90) --------------------------------------------------------
signed int __usercall sub_10043F90@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 10043F90: using guessed type int var_78[14];
// 10043F90: using guessed type int var_3C[15];

//----- (10044430) --------------------------------------------------------
int (__cdecl *__usercall sub_10044430@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (10044480) --------------------------------------------------------
int __usercall sub_10044480@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (100444A0) --------------------------------------------------------
signed int __cdecl sub_100444A0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100D5098[a1];
  v51 = dword_100D5098[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100D5098[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100D5098[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100D5098[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100D5098[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100D5098: using guessed type int dword_100D5098[];

//----- (10044850) --------------------------------------------------------
int __usercall sub_10044850@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy_0(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy_0(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (10044990) --------------------------------------------------------
signed int __usercall sub_10044990@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_10043F90(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (100449E0) --------------------------------------------------------
signed int __usercall sub_100449E0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_10043F90(a7, a6, a4, 257, (int)&unk_100D5130, (int)&unk_100D51B0, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_10043F90(a8, &a6[a4], a5, 0, (int)&unk_100D5230, (int)&unk_100D52A8, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10044A80) --------------------------------------------------------
int __usercall sub_10044A80@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100D5320;
  *a4 = &unk_100D6320;
  return 0;
}

//----- (10044AA0) --------------------------------------------------------
signed int __cdecl sub_10044AA0(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_10044430(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10044AB0) --------------------------------------------------------
int __usercall sub_10044AB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_100444A0(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100D5098[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100D5098[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100D5098[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100D5098[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_10044850(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_10044850(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_10044850(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_10044850(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100D5098: using guessed type int dword_100D5098[];

//----- (10045150) --------------------------------------------------------
int __usercall sub_10045150@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_10044A80(&v67, &v69, &v66, &v68);
          sub_10044480(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_10044850(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy_0(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100D50E0[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100D50E0[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_10044990(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_100449E0(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_10044480(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_10044AB0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_10044850(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_10044850(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_10044850(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100D5098[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100D5098[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_10044850(v7, v3, v58);
}
// 100D5098: using guessed type int dword_100D5098[];
// 100D50E0: using guessed type int dword_100D50E0[];

//----- (10045B30) --------------------------------------------------------
signed int __usercall sub_10045B30@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_10045150(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_10044430((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (10045E60) --------------------------------------------------------
signed int __cdecl sub_10045E60(int a1, int a2)
{
  return sub_10045B30(a1, a2);
}

//----- (10045E80) --------------------------------------------------------
BOOL __cdecl sub_10045E80(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (10045E90) --------------------------------------------------------
BOOL __usercall sub_10045E90@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_10045E80(a1) && *v2 < 3u && a2 == 24;
}

//----- (10045EC0) --------------------------------------------------------
bool __cdecl sub_10045EC0(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_10045E80(a1) )
    {
      v6 = 10 * v5;
      if ( sub_100253A0((unsigned __int8)byte_100D7298[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_1001F8E0(1, (unsigned __int16)word_100D7290[v6], &Tm.tm_mon) || sub_10024D50((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_100327A0(a1, &v15) || v15 != dword_100D72B0[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_1001F8E0(1, (unsigned __int16)word_100D7294[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 100D7290: using guessed type __int16 word_100D7290[];
// 100D7294: using guessed type __int16 word_100D7294[];
// 100D72B0: using guessed type int dword_100D72B0[];

//----- (10046070) --------------------------------------------------------
bool __cdecl sub_10046070(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_10045E80(a1) )
    result = sub_10005070((unsigned __int16)word_100D729A[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 100D729A: using guessed type __int16 word_100D729A[];

//----- (100460B0) --------------------------------------------------------
bool __cdecl sub_100460B0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_100326F0(a1);
  if ( !(unsigned __int8)sub_10045E90(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10045EC0(v9, a3, *a4, (int)a5);
  if ( sub_100253A0((unsigned __int8)byte_100D7298[20 * v6], (bool *)&v8) && v8 && sub_10046070(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 100460B0: using guessed type int var_20[7];

//----- (100461A0) --------------------------------------------------------
int __cdecl sub_100461A0(char a1)
{
  return sub_1001E3C0(&a1, 1u, (int)&unk_100D72D4, 8, 2, 2);
}

//----- (100461C0) --------------------------------------------------------
BOOL __cdecl sub_100461C0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_1003C4F0(a1);
  return sub_1001F8E0(0, 604, a2) && sub_1001F2B0(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (10046220) --------------------------------------------------------
int __usercall sub_10046220@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_100461A0(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100D72D8[2 * v1];
  return result;
}
// 100D72D8: using guessed type int dword_100D72D8[];

//----- (10046250) --------------------------------------------------------
BOOL __cdecl sub_10046250(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10046220(a1);
  return sub_10005070(v2, a2, 16) == 0;
}

//----- (10046280) --------------------------------------------------------
int __cdecl sub_10046280(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_10046250(a1, (int)a5);
  else
    result = sub_100461C0(a1, a5);
  return result;
}

//----- (100462B0) --------------------------------------------------------
char __cdecl sub_100462B0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_1001F910(1, 1947, a1, (int)&v3);
}

//----- (100462D0) --------------------------------------------------------
BOOL __cdecl sub_100462D0(int a1)
{
  return sub_10005070(6792, a1, 284) == 0;
}

//----- (100462F0) --------------------------------------------------------
char __cdecl sub_100462F0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_100462D0((int)a5);
  else
    result = sub_100462B0(a5);
  return result;
}

//----- (10046320) --------------------------------------------------------
bool __cdecl sub_10046320(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_10005070((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (10046360) --------------------------------------------------------
signed int __usercall sub_10046360@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (10046380) --------------------------------------------------------
bool __cdecl sub_10046380(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  int v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_10046360(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_1001F2B0(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_1001F910(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_10046320(a1, a2);
  }
  else
  {
    v9 = sub_1001FF60(v4);
    v8 = 1708;
    sub_1001F410(1, 0, &v8, 0, 8, 1);
    sub_1001F550(1, 0, v2);
    result = 0;
  }
  return result;
}
// 10005520: using guessed type int j_HWM_pvg_hsdb_get_lrus_online(void);
// 10005540: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10046470) --------------------------------------------------------
bool __cdecl sub_10046470(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_10046320(a1, a5);
  else
    result = sub_10046380(a1, a5);
  return result;
}

//----- (100464A0) --------------------------------------------------------
char __cdecl sub_100464A0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_101AEC90, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10004C50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_100308F0(a1, (int)byte_101AEC90);
    v3 = 4 * a2 - 64;
    v4 = byte_101AEC91[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_101AEC90[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (10046540) --------------------------------------------------------
bool __cdecl sub_10046540(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_101AEC90, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10004C50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_100308F0(a1, (int)byte_101AEC90);
    v3 = (char *)&unk_101AED30 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (100465C0) --------------------------------------------------------
char __cdecl sub_100465C0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101AEC90, 0, 0x890u);
  sub_100308F0(a1, (int)byte_101AEC90);
  if ( a2 > 0x10u )
  {
    sub_10004C50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_101AF000[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101AF004[2 * a2];
    result = 1;
  }
  return result;
}
// 101AF000: using guessed type int dword_101AF000[];
// 101AF004: using guessed type int dword_101AF004[];

//----- (10046630) --------------------------------------------------------
char __cdecl sub_10046630(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_1001F8E0(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_1001F8E0(0, 572, a2);
    }
    else
    {
      sub_10004C50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_1001F8E0(0, 226, a2);
  }
  return result;
}

//----- (100466B0) --------------------------------------------------------
char __cdecl sub_100466B0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_101AEC90, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10004C50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10046630(a1, byte_101AEC90);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_101AEC91[v4];
    *(_BYTE *)a3 = byte_101AEC90[v4];
  }
  return result;
}

//----- (10046730) --------------------------------------------------------
char __cdecl sub_10046730(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_101AEC90, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10004C50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10046630(a1, byte_101AEC90);
    v4 = (char *)&unk_101AED30 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (100467B0) --------------------------------------------------------
char __cdecl sub_100467B0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_101AEC90, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10046630(a1, byte_101AEC90);
    *(_DWORD *)a3 = dword_101AF000[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_101AF004[2 * a2];
  }
  else
  {
    sub_10004C50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 101AF000: using guessed type int dword_101AF000[];
// 101AF004: using guessed type int dword_101AF004[];

//----- (10046820) --------------------------------------------------------
char __cdecl sub_10046820(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10047370(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_100465C0(v6, *a4, a5);
    else
      result = sub_100467B0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_100464A0(v6, *a4, a5);
    else
      result = sub_100466B0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10004C50("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_10046540(v6, *a4, a5);
    else
      result = sub_10046730(v6, *a4, a5);
  }
  return result;
}

//----- (10046930) --------------------------------------------------------
char __cdecl sub_10046930(char a1, void *a2)
{
  return sub_1001F8E0(6, (unsigned __int16)word_100D8312[8 * (unsigned __int8)a1], a2);
}
// 100D8312: using guessed type __int16 word_100D8312[];

//----- (10046950) --------------------------------------------------------
bool __cdecl sub_10046950(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_10005070(dword_100D8318[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100D8318: using guessed type int dword_100D8318[];

//----- (10046990) --------------------------------------------------------
char __cdecl sub_10046990(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100473B0(a1);
  if ( a2 )
    result = sub_10046950(v6, (char *)a5);
  else
    result = sub_10046930(v6, a5);
  return result;
}

//----- (100469D0) --------------------------------------------------------
BOOL sub_100469D0()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_100252E0(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10046A30) --------------------------------------------------------
char __cdecl sub_10046A30(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_1001F8E0(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_100469D0() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_10024480((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (10046B20) --------------------------------------------------------
BOOL __cdecl sub_10046B20(int a1, int a2)
{
  return sub_10005070(6200, a2, 60) == 0;
}

//----- (10046B40) --------------------------------------------------------
char __cdecl sub_10046B40(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10046B20(a1, (int)a5);
  }
  else
  {
    result = sub_10046A30(a1, a5);
  }
  return result;
}

//----- (10046B80) --------------------------------------------------------
char __cdecl sub_10046B80(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_1001F8E0(2, 284, &v6) || sub_10024BD0((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10046C30) --------------------------------------------------------
BOOL __cdecl sub_10046C30(int a1, int a2)
{
  return sub_10005070(6169, a2, 40) == 0;
}

//----- (10046C50) --------------------------------------------------------
char __cdecl sub_10046C50(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10046C30(a1, a5);
  }
  else
  {
    result = sub_10046B80(a1, a5);
  }
  return result;
}

//----- (10046C90) --------------------------------------------------------
char __cdecl sub_10046C90(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10004C50("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10046CD0) --------------------------------------------------------
__int16 __usercall sub_10046CD0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100DA034[a1];
}
// 100DA034: using guessed type __int16 word_100DA034[];

//----- (10046CE0) --------------------------------------------------------
char __cdecl sub_10046CE0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_10046CD0(a1);
    if ( sub_1001F910(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10046DB0) --------------------------------------------------------
char __cdecl sub_10046DB0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10046C90(a1);
  if ( a3 != 11 )
  {
    sub_10004C50("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_10046CE0(v7, a5);
  }
  else
  {
    sub_10004C50("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10046E30) --------------------------------------------------------
char __cdecl sub_10046E30(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10004C50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_1001F910(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_1001F910(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_100251E0((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_101AF528, (char *)&v6 + 1, 0x20u);
      byte_101AF520 = 1;
      byte_101AF521 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_101AF548, (char *)&v6 + 1, 0x20u);
    byte_101AF521 = 1;
    byte_101AF522 = 1;
    return result;
  }
  return 0;
}
// 101AF520: using guessed type char byte_101AF520;
// 101AF521: using guessed type char byte_101AF521;
// 101AF522: using guessed type char byte_101AF522;

//----- (10046F60) --------------------------------------------------------
char __cdecl sub_10046F60(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_100308A0(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10004C50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (10046FE0) --------------------------------------------------------
bool __cdecl sub_10046FE0(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_101AF520 == 0;
    qmemcpy(a1, &unk_101AF528, 0x40u);
    result = !v1 && byte_101AF522;
  }
  else
  {
    sub_10004C50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 101AF520: using guessed type char byte_101AF520;
// 101AF522: using guessed type char byte_101AF522;

//----- (10047030) --------------------------------------------------------
char __cdecl sub_10047030(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10004C50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_1001FE40(15);
    v3 = 555;
  }
  else
  {
    result = sub_1001FE40(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_101AF521 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_1001F410(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10005540: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101AF521: using guessed type char byte_101AF521;

//----- (10047110) --------------------------------------------------------
__int16 __usercall sub_10047110@<ax>(unsigned __int8 a1@<al>)
{
  return word_100DA140[a1];
}
// 100DA140: using guessed type __int16 word_100DA140[];

//----- (10047120) --------------------------------------------------------
char __cdecl sub_10047120(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_10047110(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_1001F410(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_1001F550(1, v3, 0xFFFFFFF);
}

//----- (100471B0) --------------------------------------------------------
char __cdecl sub_100471B0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10004C50("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_101AF521 != 0 ? 25 : 11;
      sub_10047120(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10047120(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 101AF521: using guessed type char byte_101AF521;

//----- (10047270) --------------------------------------------------------
bool __cdecl sub_10047270(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10046F60(a1, (int)a5);
    return 1;
  }
  if ( byte_101AF521 )
  {
    if ( sub_10046E30(a1, &v6, 1) )
    {
LABEL_14:
      byte_101AF523 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_101AF523 >= 5u )
    {
      byte_101AF520 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_10046E30(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_101AF523 >= 5u )
    {
      byte_101AF522 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10046F60(a1, (int)&v6);
    sub_10047030(a1, (int)&v6);
  }
  sub_100471B0(a1, 11);
  return sub_10046FE0(a5);
}
// 10005540: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 101AF520: using guessed type char byte_101AF520;
// 101AF521: using guessed type char byte_101AF521;
// 101AF522: using guessed type char byte_101AF522;
// 101AF523: using guessed type char byte_101AF523;

//----- (10047370) --------------------------------------------------------
char __cdecl sub_10047370(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10004C50("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (100473B0) --------------------------------------------------------
char __cdecl sub_100473B0(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100473E0) --------------------------------------------------------
int __cdecl sub_100473E0(unsigned __int8 a1, unsigned int a2)
{
  return dword_100DF990[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100DF990: using guessed type int dword_100DF990[];

//----- (10047400) --------------------------------------------------------
unsigned int __cdecl sub_10047400(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100DF990[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100DF990[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100DF990[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100DF990[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100DF990[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100DF990[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100DF990[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100DF990[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100DF990[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100DF990[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100DF990: using guessed type int dword_100DF990[];

//----- (10047530) --------------------------------------------------------
double __cdecl sub_10047530(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100475D0) --------------------------------------------------------
double __cdecl sub_100475D0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10047670) --------------------------------------------------------
double __cdecl sub_10047670(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (100476D0) --------------------------------------------------------
double __cdecl sub_100476D0(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (10047750) --------------------------------------------------------
void __cdecl sub_10047750(double a1)
{
  sub_10047670(a1, 3.1415926535898);
}

//----- (10047770) --------------------------------------------------------
double __cdecl sub_10047770(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_100476D0(a1, 3.1415927);
  return result;
}

//----- (100477B0) --------------------------------------------------------
int __cdecl sub_100477B0(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (100477D0) --------------------------------------------------------
int __cdecl sub_100477D0(float a1)
{
  double v1; // st7@1
  int result; // eax@2

  v1 = a1;
  if ( a1 >= 0.0 )
    result = (signed int)(v1 + 0.5);
  else
    result = (signed int)(v1 - 0.5);
  return result;
}

//----- (10047800) --------------------------------------------------------
int __cdecl sub_10047800(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (10047820) --------------------------------------------------------
int __cdecl sub_10047820(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(double *)a2 = *(float *)a1;
  *(double *)(a2 + 8) = *(float *)(a1 + 4);
  return result;
}

//----- (10047840) --------------------------------------------------------
int __cdecl sub_10047840(float a1)
{
  double v1; // st7@1
  int result; // eax@3
  float v3; // [sp+8h] [bp+4h]@1
  float v4; // [sp+8h] [bp+4h]@2
  float v5; // [sp+8h] [bp+4h]@3

  v3 = sub_10047770(a1);
  v1 = v3;
  if ( v3 < 0.0 )
  {
    v4 = v1 + 6.283185482025146;
    v1 = v4;
  }
  v5 = v1 * 180.0 / 3.1415926535898;
  result = (signed int)(v5 + 0.5);
  if ( result >= 360 )
    result = 0;
  return result;
}

//----- (100478A0) --------------------------------------------------------
double __cdecl sub_100478A0(double a1, double a2)
{
  double result; // st7@1

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707963267949;
      else
        result = 1.5707963267949;
    }
  }
  else
  {
    result = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      result = result + 3.1415926535898;
      sub_10047750(result);
    }
  }
  return result;
}

//----- (10047910) --------------------------------------------------------
double __cdecl sub_10047910(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_10047770(v4);
    }
    result = v3;
  }
  return result;
}

//----- (100479A0) --------------------------------------------------------
int __cdecl sub_100479A0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (100479D0) --------------------------------------------------------
int __cdecl sub_100479D0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (10049919) --------------------------------------------------------
double __cdecl sub_10049919(char *String)
{
  return _atof_l(String, 0);
}

//----- (1004A2F9) --------------------------------------------------------
int __cdecl sub_1004A2F9(int a1, int a2, char a3)
{
  return vscan_fn(sub_10052527, a2, 0, &a3);
}
// 1004A291: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004B812) --------------------------------------------------------
signed int __cdecl sub_1004B812(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_101B0930 )
  {
    *a1 = dword_101B0930;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1004E294: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101B0930: using guessed type int dword_101B0930;

//----- (1004B849) --------------------------------------------------------
signed int __cdecl sub_1004B849(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_101B0930 )
  {
    *a1 = dword_101B093C;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1004E294: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101B0930: using guessed type int dword_101B0930;
// 101B093C: using guessed type int dword_101B093C;

//----- (1004C48F) --------------------------------------------------------
void sub_1004C48F()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_101E8480;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_101E8580 );
}
// 101E8480: using guessed type int dword_101E8480[];
// 101E8580: using guessed type int dword_101E8580;

//----- (1004C93C) --------------------------------------------------------
int (*sub_1004C93C())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100EE6F0;
  v1 = (int (**)(void))&unk_100EE6F0;
  if ( &unk_100EE6F0 < &unk_100EE6F0 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100EE6F0 );
  }
  return result;
}

//----- (1004C960) --------------------------------------------------------
void __cdecl sub_1004C960()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100EE6F8;
  if ( &unk_100EE6F8 < &unk_100EE6F8 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100EE6F8 );
  }
}

//----- (1004E18E) --------------------------------------------------------
int __cdecl sub_1004E18E(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101B0A98 = a1;
  return result;
}
// 101B0A98: using guessed type int dword_101B0A98;

//----- (1004F9E5) --------------------------------------------------------
int __cdecl sub_1004F9E5(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_10057701() + 8 && (void **)v2 != sub_10057701() + 16 || !sub_100576A3((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100F02A8;
      else
        v9 = (_BYTE *)(dword_101E8480[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_10057583((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_10057583((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 1005765F: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101E8480: using guessed type int dword_101E8480[];

//----- (10052527) --------------------------------------------------------
int __cdecl sub_10052527(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100F02A8;
  }
  else
  {
    v6 = &dword_101E8480[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100F02A8) : (v8 = &dword_101E8480[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_10058FCC(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_10058FCC(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_10058FCC(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_10058FCC(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_10058FCC(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100F028C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_10058FCC(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_10058FCC(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_10058FCC(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_10058FCC(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 1004BB48: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1004E294: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100524EC: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 10052502: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 100F028C: using guessed type int (*off_100F028C[3])();
// 101E8480: using guessed type int dword_101E8480[];
// 10052527: using guessed type char var_24[11];

//----- (10053804) --------------------------------------------------------
#error "10053809: positive sp value has been found (funcsize=0)"

//----- (1005380F) --------------------------------------------------------
#error "10053814: positive sp value has been found (funcsize=0)"

//----- (1005381A) --------------------------------------------------------
#error "1005381F: positive sp value has been found (funcsize=0)"

//----- (10053820) --------------------------------------------------------
#error "10053825: positive sp value has been found (funcsize=0)"

//----- (10053826) --------------------------------------------------------
#error "1005382B: positive sp value has been found (funcsize=0)"

//----- (1005382C) --------------------------------------------------------
#error "10053831: positive sp value has been found (funcsize=0)"

//----- (10053832) --------------------------------------------------------
#error "1005384D: positive sp value has been found (funcsize=0)"

//----- (10053853) --------------------------------------------------------
#error "10053868: positive sp value has been found (funcsize=0)"

//----- (1005386E) --------------------------------------------------------
#error "10053889: positive sp value has been found (funcsize=0)"

//----- (1005388A) --------------------------------------------------------
#error "10053899: positive sp value has been found (funcsize=0)"

//----- (1005389A) --------------------------------------------------------
#error "100538AD: positive sp value has been found (funcsize=0)"

//----- (100538AE) --------------------------------------------------------
#error "100538BD: positive sp value has been found (funcsize=0)"

//----- (100538BE) --------------------------------------------------------
#error "100538DD: positive sp value has been found (funcsize=0)"

//----- (100538E3) --------------------------------------------------------
#error "100538FC: positive sp value has been found (funcsize=0)"

//----- (10053902) --------------------------------------------------------
#error "10053921: positive sp value has been found (funcsize=0)"

//----- (10053922) --------------------------------------------------------
#error "10053935: positive sp value has been found (funcsize=0)"

//----- (10053936) --------------------------------------------------------
#error "1005394D: positive sp value has been found (funcsize=0)"

//----- (1005394E) --------------------------------------------------------
#error "10053961: positive sp value has been found (funcsize=0)"

//----- (10053962) --------------------------------------------------------
#error "10053981: positive sp value has been found (funcsize=0)"

//----- (10053987) --------------------------------------------------------
#error "100539A0: positive sp value has been found (funcsize=0)"

//----- (100539A6) --------------------------------------------------------
#error "100539C5: positive sp value has been found (funcsize=0)"

//----- (100539C6) --------------------------------------------------------
#error "100539D9: positive sp value has been found (funcsize=0)"

//----- (100539DA) --------------------------------------------------------
#error "100539F1: positive sp value has been found (funcsize=0)"

//----- (100539F2) --------------------------------------------------------
#error "10053A05: positive sp value has been found (funcsize=0)"

//----- (10053A06) --------------------------------------------------------
#error "10053A25: positive sp value has been found (funcsize=0)"

//----- (10053A2B) --------------------------------------------------------
#error "10053A44: positive sp value has been found (funcsize=0)"

//----- (10053A4A) --------------------------------------------------------
#error "10053A69: positive sp value has been found (funcsize=0)"

//----- (10053A6A) --------------------------------------------------------
#error "10053A7D: positive sp value has been found (funcsize=0)"

//----- (10053A7E) --------------------------------------------------------
#error "10053A95: positive sp value has been found (funcsize=0)"

//----- (10053A96) --------------------------------------------------------
#error "10053AA9: positive sp value has been found (funcsize=0)"

//----- (10053AAA) --------------------------------------------------------
#error "10053AC9: positive sp value has been found (funcsize=0)"

//----- (10053ACF) --------------------------------------------------------
#error "10053AE8: positive sp value has been found (funcsize=0)"

//----- (10053AEE) --------------------------------------------------------
#error "10053B0D: positive sp value has been found (funcsize=0)"

//----- (10053B0E) --------------------------------------------------------
#error "10053B21: positive sp value has been found (funcsize=0)"

//----- (10053B22) --------------------------------------------------------
#error "10053B39: positive sp value has been found (funcsize=0)"

//----- (10053B3A) --------------------------------------------------------
#error "10053B4D: positive sp value has been found (funcsize=0)"

//----- (10053B4E) --------------------------------------------------------
#error "10053B6D: positive sp value has been found (funcsize=0)"

//----- (10053B73) --------------------------------------------------------
#error "10053B8C: positive sp value has been found (funcsize=0)"

//----- (10053B92) --------------------------------------------------------
#error "10053BB1: positive sp value has been found (funcsize=0)"

//----- (10053BB2) --------------------------------------------------------
#error "10053BC5: positive sp value has been found (funcsize=0)"

//----- (10053BC6) --------------------------------------------------------
#error "10053BDD: positive sp value has been found (funcsize=0)"

//----- (10053BDE) --------------------------------------------------------
#error "10053BF1: positive sp value has been found (funcsize=0)"

//----- (10053BF2) --------------------------------------------------------
#error "10053C11: positive sp value has been found (funcsize=0)"

//----- (10053C17) --------------------------------------------------------
#error "10053C30: positive sp value has been found (funcsize=0)"

//----- (10053C36) --------------------------------------------------------
#error "10053C55: positive sp value has been found (funcsize=0)"

//----- (10053C56) --------------------------------------------------------
#error "10053C69: positive sp value has been found (funcsize=0)"

//----- (10053C6A) --------------------------------------------------------
#error "10053C81: positive sp value has been found (funcsize=0)"

//----- (10053C82) --------------------------------------------------------
#error "10053C95: positive sp value has been found (funcsize=0)"

//----- (1005446B) --------------------------------------------------------
int __cdecl sub_1005446B(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10058029((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10051131: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10054511) --------------------------------------------------------
int __cdecl sub_10054511(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1005856B((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 10051131: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10054982) --------------------------------------------------------
void sub_10054982()
{
  dword_101E845C = 0;
}
// 101E845C: using guessed type int dword_101E845C;

//----- (10054AD5) --------------------------------------------------------
int sub_10054AD5()
{
  dword_101E8598 = _get_sse2_info();
  return 0;
}
// 10054A75: using guessed type int _get_sse2_info(void);
// 101E8598: using guessed type int dword_101E8598;

//----- (10054FD2) --------------------------------------------------------
int sub_10054FD2()
{
  return _decode_pointer(dword_101B0F60);
}
// 1004BB48: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 101B0F60: using guessed type int dword_101B0F60;

//----- (1005518F) --------------------------------------------------------
int __cdecl sub_1005518F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101B0F6C = a1;
  return result;
}
// 101B0F6C: using guessed type int dword_101B0F6C;

//----- (10055199) --------------------------------------------------------
int __cdecl sub_10055199(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101B0F78 = a1;
  return result;
}
// 101B0F78: using guessed type int dword_101B0F78;

//----- (100551A3) --------------------------------------------------------
int __cdecl sub_100551A3(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101B0F7C = a1;
  return result;
}
// 101B0F7C: using guessed type int dword_101B0F7C;

//----- (10055282) --------------------------------------------------------
int __cdecl sub_10055282(int a1)
{
  int result; // eax@1

  result = a1;
  dword_101B0F80 = a1;
  return result;
}
// 101B0F80: using guessed type int dword_101B0F80;

//----- (100565E0) --------------------------------------------------------
int sub_100565E0()
{
  return 0;
}

//----- (10056DC5) --------------------------------------------------------
DWORD __cdecl sub_10056DC5(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_1005A45C(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_101E8480[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 10048D06: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101E8480: using guessed type int dword_101E8480[];

//----- (10056F61) --------------------------------------------------------
_WORD *__cdecl sub_10056F61(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_101E8480[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_101E8480[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_10056DC5(a1, 0, 0, 2u);
  if ( sub_100576A3(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 10048D06: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1004BD64: using guessed type int _getptd(void);
// 1004E294: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101E8480: using guessed type int dword_101E8480[];
// 10056F61: using guessed type CHAR var_410[688];

//----- (10057583) --------------------------------------------------------
_WORD *__cdecl sub_10057583(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_101E8480[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_10056F61(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_1005A56D(a1);
  return v6;
}
// 1004E294: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1005A4CD: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 101E8480: using guessed type int dword_101E8480[];

//----- (100576A3) --------------------------------------------------------
int __cdecl sub_100576A3(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_101E8480[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1004E294: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101E8480: using guessed type int dword_101E8480[];

//----- (10057701) --------------------------------------------------------
void **sub_10057701()
{
  return &off_100F0F00;
}
// 100F0F00: using guessed type void *off_100F0F00;

//----- (10057707) --------------------------------------------------------
signed int sub_10057707()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_101E8440;
  if ( !dword_101E8440 )
  {
    v0 = 512;
LABEL_5:
    dword_101E8440 = v0;
    goto LABEL_6;
  }
  if ( dword_101E8440 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_101E742C = v1;
  if ( v1 || (dword_101E8440 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_101E742C = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100F0F00;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&off_100F1180 )
        break;
      v1 = dword_101E742C;
    }
    v5 = 0;
    v6 = &unk_100F0F10;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_101E8480[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100F0F70 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 1004C158: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100F0F00: using guessed type void *off_100F0F00;
// 100F1180: using guessed type wchar_t *off_100F1180;
// 101E8440: using guessed type int dword_101E8440;
// 101E8480: using guessed type int dword_101E8480[];

//----- (10058029) --------------------------------------------------------
signed int __cdecl sub_10058029(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100F1298 - 1;
    v64 = v3;
    v65 = dword_100F1298 / 32;
    v9 = dword_100F1298 % 32;
    v10 = (int *)(&v60 + dword_100F1298 / 32);
    v66 = 31 - dword_100F1298 % 32;
    if ( (1 << (31 - dword_100F1298 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100F1294 - dword_100F1298 )
    {
      if ( v3 > dword_100F1294 )
      {
        if ( v3 < dword_100F1290 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100F12A4 + v3;
          v50 = dword_100F129C / 32;
          v51 = dword_100F129C % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100F129C % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100F129C / 32;
          v44 = dword_100F129C % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100F129C % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100F12A4 + dword_100F1290;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100F1294 - v64) / 32;
      v62 = v59;
      v18 = (dword_100F1294 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100F1298 - 1;
      v25 = dword_100F1298 / 32;
      v65 = dword_100F1298 / 32;
      v26 = (int *)(&v60 + dword_100F1298 / 32);
      v64 = 31 - dword_100F1298 % 32;
      if ( (1 << (31 - dword_100F1298 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100F1298 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100F129C + 1) / 32;
      v37 = (dword_100F129C + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100F129C));
  if ( dword_100F12A0 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100F12A0 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100F1290: using guessed type int dword_100F1290;
// 100F1294: using guessed type int dword_100F1294;
// 100F1298: using guessed type int dword_100F1298;
// 100F129C: using guessed type int dword_100F129C;
// 100F12A0: using guessed type int dword_100F12A0;
// 100F12A4: using guessed type int dword_100F12A4;

//----- (1005856B) --------------------------------------------------------
signed int __cdecl sub_1005856B(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100F12B0 - 1;
    v64 = v3;
    v65 = dword_100F12B0 / 32;
    v9 = dword_100F12B0 % 32;
    v10 = (int *)(&v60 + dword_100F12B0 / 32);
    v66 = 31 - dword_100F12B0 % 32;
    if ( (1 << (31 - dword_100F12B0 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100F12AC - dword_100F12B0 )
    {
      if ( v3 > dword_100F12AC )
      {
        if ( v3 < dword_100F12A8 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100F12BC + v3;
          v50 = dword_100F12B4 / 32;
          v51 = dword_100F12B4 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100F12B4 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100F12B4 / 32;
          v44 = dword_100F12B4 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100F12B4 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100F12BC + dword_100F12A8;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100F12AC - v64) / 32;
      v62 = v59;
      v18 = (dword_100F12AC - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100F12B0 - 1;
      v25 = dword_100F12B0 / 32;
      v65 = dword_100F12B0 / 32;
      v26 = (int *)(&v60 + dword_100F12B0 / 32);
      v64 = 31 - dword_100F12B0 % 32;
      if ( (1 << (31 - dword_100F12B0 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100F12B0 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100F12B4 + 1) / 32;
      v37 = (dword_100F12B4 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100F12B4));
  if ( dword_100F12B8 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100F12B8 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100F12A8: using guessed type int dword_100F12A8;
// 100F12AC: using guessed type int dword_100F12AC;
// 100F12B0: using guessed type int dword_100F12B0;
// 100F12B4: using guessed type int dword_100F12B4;
// 100F12B8: using guessed type int dword_100F12B8;
// 100F12BC: using guessed type int dword_100F12BC;

//----- (10058EAC) --------------------------------------------------------
int __cdecl sub_10058EAC(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100F02A8;
    }
    else
    {
      v7 = &dword_101E8480[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1004E294: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1005765F: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101E8480: using guessed type int dword_101E8480[];

//----- (10058FCC) --------------------------------------------------------
int __cdecl sub_10058FCC(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100F02A8;
    }
    else
    {
      v2 = &dword_101E8480[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100F02A8) : (v4 = &dword_101E8480[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1004E294: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1005765F: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 101E8480: using guessed type int dword_101E8480[];

//----- (10059F0B) --------------------------------------------------------
int __cdecl sub_10059F0B(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_101B0F9C )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_101B0F9C = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_101B0FA0 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_101B0FA4 = _encode_pointer(v7);
    if ( sub_1004B812(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_101B0FAC = _encode_pointer(v8);
      if ( dword_101B0FAC )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_101B0FA8 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_101B0FA8 == v23
    || dword_101B0FAC == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_101B0FA8),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_101B0FAC),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_101B0FA0 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_101B0FA0);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_101B0FA4 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_101B0FA4);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_1004B849(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_101B0F9C);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1004BAD1: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 1004BB3F: using guessed type int _encoded_null(void);
// 1004BB48: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1004E198: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101B0F9C: using guessed type int dword_101B0F9C;
// 101B0FA0: using guessed type int dword_101B0FA0;
// 101B0FA4: using guessed type int dword_101B0FA4;
// 101B0FA8: using guessed type int dword_101B0FA8;
// 101B0FAC: using guessed type int dword_101B0FAC;

//----- (1005A3DB) --------------------------------------------------------
signed int __cdecl sub_1005A3DB(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_101E8480[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_101B0604 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 101B0604: using guessed type int dword_101B0604;
// 101E8480: using guessed type int dword_101E8480[];

//----- (1005A45C) --------------------------------------------------------
signed int __cdecl sub_1005A45C(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_101E8480[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1004E294: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 101E8480: using guessed type int dword_101E8480[];

//----- (1005A56D) --------------------------------------------------------
void __cdecl sub_1005A56D(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_101E8480[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 101E8480: using guessed type int dword_101E8480[];

//----- (1005A86E) --------------------------------------------------------
int sub_1005A86E()
{
  return flsall(1);
}
// 1005A794: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (1005B1B1) --------------------------------------------------------
signed int __cdecl sub_1005B1B1(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_1005A45C(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_101E8480[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_101E8480[0] + 68) & 1)
    && (v1 = sub_1005A45C(2), sub_1005A45C(1) == v1)
    || (v2 = (void *)sub_1005A45C(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_1005A3DB(a1);
  *(_BYTE *)(dword_101E8480[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10048D06: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 101E8480: using guessed type int dword_101E8480[];

//----- (1005B350) --------------------------------------------------------
int __cdecl sub_1005B350(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 1005BB50: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1005B3B0) --------------------------------------------------------
int __usercall sub_1005B3B0@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_10005490(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_100054B0(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_1005B350((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10004DF0();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_100052D0(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_10005440(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10005200(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10005200(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 100052B0: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100052C0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10005390: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (1005B6B0) --------------------------------------------------------
int __usercall sub_1005B6B0@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 1005BB50: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1005B6D0) --------------------------------------------------------
signed int __cdecl sub_1005B6D0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10004C50("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10005040(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10005010(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_1005B6B0(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_1005B3B0((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10005010(v6, 81);
  return (unsigned __int8)v2;
}

//----- (1005B7A0) --------------------------------------------------------
__int16 __cdecl sub_1005B7A0(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 1005CD98: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1005B7E0) --------------------------------------------------------
__int16 __cdecl sub_1005B7E0(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 1005B7D0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1005B880) --------------------------------------------------------
int __cdecl sub_1005B880(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 1005CDBC: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (1005B8D0) --------------------------------------------------------
int __cdecl sub_1005B8D0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10047A44: using guessed type int SYS_exit_krnl(void);
// 10047A4A: using guessed type int SYS_enter_krnl(void);
// 1005CDC2: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (1005B940) --------------------------------------------------------
int __cdecl sub_1005B940(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1001FF60(v1);
  a1 = v2;
  v3 = sub_1001E3C0(&a1, 4u, (int)&unk_100EE540, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100EE544[2 * v3];
}
// 100EE544: using guessed type int dword_100EE544[];

//----- (1005B980) --------------------------------------------------------
int __cdecl sub_1005B980(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1001FF60(v1);
  a1 = v2;
  v3 = sub_1001E3C0(&a1, 4u, (int)&unk_100EE578, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100EE57C[2 * v3];
}
// 100EE57C: using guessed type int dword_100EE57C[];

//----- (1005B9C0) --------------------------------------------------------
int __cdecl sub_1005B9C0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1001FF60(v1);
  a1 = v2;
  v3 = sub_1001E3C0(&a1, 4u, (int)&unk_100EE5B0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100EE5B4[2 * v3];
}
// 100EE5B4: using guessed type int dword_100EE5B4[];

//----- (1005BA00) --------------------------------------------------------
int __cdecl sub_1005BA00(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1001FF60(v1);
  a1 = v2;
  v3 = sub_1001E3C0(&a1, 4u, (int)&unk_100EE5E8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100EE5EC[2 * v3];
}
// 100EE5EC: using guessed type int dword_100EE5EC[];

//----- (1005BA40) --------------------------------------------------------
int __cdecl sub_1005BA40(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_1005B980(a4);
    result = sub_10005070(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_10005070(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_1005B940(a4);
      result = sub_10005070(v6, a3, 6);
    }
  }
  return result;
}

//----- (1005BAB0) --------------------------------------------------------
int __cdecl sub_1005BAB0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_1005BA00(a3);
    result = sub_10005070(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10004F40(100);
      v5 = sub_1005BA00(a3);
      result = sub_10005070(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_1005B9C0(a3);
    result = sub_10005070(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10004F40(100);
      v7 = sub_1005B9C0(a3);
      result = sub_10005070(v7, a2, 8);
    }
  }
  return result;
}

//----- (1005BB60) --------------------------------------------------------
void __cdecl sub_1005BB60(float *a1, float *a2, float *a3, int a4)
{
  float v4; // [sp+0h] [bp-4h]@1

  sub_10006230(a1, a2, a4);
  v4 = sqrt(sub_100062F0(a4, a4));
  *a3 = v4;
  if ( v4 >= 0.1000000014901161 )
  {
    *(float *)a4 = *(float *)a4 / v4;
    *(float *)(a4 + 4) = *(float *)(a4 + 4) / *a3;
  }
  else
  {
    *(float *)(a4 + 4) = 1.0;
    *(float *)a4 = 0.0;
  }
}

//----- (1005BBC0) --------------------------------------------------------
int __cdecl sub_1005BBC0(float a1, float a2, int a3)
{
  float v3; // ST00_4@1
  float v4; // ST04_4@1
  float v5; // ST00_4@1
  float v6; // ST04_4@1
  double v7; // ST08_8@1
  float v8; // ST04_4@1
  float v9; // ST00_4@1
  float v10; // ST04_4@1
  float v11; // ST04_4@1
  double v12; // ST08_8@1
  float v13; // ST04_4@1
  float v14; // ST00_4@1
  float v15; // ST04_4@1
  float v16; // ST04_4@1
  double v17; // ST08_8@1
  float v18; // ST04_4@1
  float v19; // ST00_4@1
  float v20; // ST04_4@1
  float v21; // ST04_4@1
  double v22; // ST08_8@1
  float v23; // ST04_4@1
  float v24; // ST00_4@1
  float v25; // ST04_4@1
  int result; // eax@1
  float v27; // ST04_4@1
  float v28; // ST04_4@1
  float v29; // [sp+18h] [bp+8h]@1
  float v30; // [sp+18h] [bp+8h]@1

  v3 = sin(a2 * 4.0);
  v4 = v3;
  v5 = sin(a1 * 4.0);
  v6 = v4 - v5;
  v7 = v6 * 0.00001062759019987425 * 0.25;
  v8 = sin(a2 + a2);
  v9 = v8;
  v10 = sin(a1 + a1);
  v11 = v9 - v10;
  v12 = v7 - v11 * 0.00506310909986496 * 0.5;
  v13 = sin(a2 * 6.0);
  v14 = v13;
  v15 = sin(a1 * 6.0);
  v16 = v14 - v15;
  v17 = v12 - v16 * 0.00000002082037831030448 / 6.0;
  v18 = sin(a2 * 8.0);
  v19 = v18;
  v20 = sin(a1 * 8.0);
  v21 = v19 - v20;
  v22 = v21 * 3.932370748471747e-11 * 0.125 + v17;
  v23 = sin(a2 * 10.0);
  v24 = v23;
  v25 = sin(a1 * 10.0);
  result = a3;
  v27 = v24 - v25;
  v28 = v22 - v27 * 7.108452959288594e-14 / 10.0;
  v29 = a2 - a1;
  v30 = v29 * 1.005052447319031;
  *(float *)a3 = fabs((v28 + v30) * 6335439.327292892);
  return result;
}

//----- (1005BD80) --------------------------------------------------------
void __cdecl sub_1005BD80(int a1, int a2, float *a3, float *a4, float *a5)
{
  float v5; // ST38_4@1
  float v6; // ST38_4@1
  long double v7; // ST38_8@5
  long double v8; // ST48_8@5
  long double v9; // st7@5
  signed int v10; // ebx@5
  long double v11; // st5@5
  long double v12; // st7@5
  long double v13; // st7@6
  double v14; // st7@6
  double v15; // st4@6
  double v16; // st3@6
  double v17; // st2@8
  double v18; // STB8_8@8
  double v19; // ST60_8@10
  double v20; // ST50_8@10
  long double v21; // st7@10
  long double v22; // st7@10
  double v23; // [sp+40h] [bp-90h]@6
  double v24; // [sp+48h] [bp-88h]@6
  double v25; // [sp+50h] [bp-80h]@5
  double v26; // [sp+58h] [bp-78h]@5
  double v27; // [sp+60h] [bp-70h]@5
  double v28; // [sp+68h] [bp-68h]@6
  double v29; // [sp+70h] [bp-60h]@6
  double v30; // [sp+78h] [bp-58h]@5
  double v31; // [sp+80h] [bp-50h]@6
  double v32; // [sp+88h] [bp-48h]@6
  double v33; // [sp+90h] [bp-40h]@5
  double v34; // [sp+98h] [bp-38h]@5
  double v35; // [sp+A0h] [bp-30h]@8
  double v36; // [sp+A8h] [bp-28h]@6
  double v37; // [sp+B0h] [bp-20h]@5
  double v38; // [sp+C0h] [bp-10h]@5

  v5 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v6 = fabs(sub_10047770(v5));
  if ( v6 >= 0.000001 )
  {
    v7 = sin(*(float *)a1) * 0.9966471893352525 / cos(*(float *)a1);
    v8 = sin(*(float *)a2) * 0.9966471893352525 / cos(*(float *)a2);
    v33 = 1.0 / sqrt(v7 * v7 + 1.0);
    v9 = 1.0 / sqrt(v8 * v8 + 1.0);
    v10 = 0;
    v37 = v9;
    v34 = v33 * v9;
    v25 = v34 * v8;
    v27 = v25 * v7;
    v26 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
    v11 = v9;
    v12 = v26;
    v30 = v11 * (v33 * v7);
    v38 = v27 + v27;
    do
    {
      v29 = sin(v12);
      v13 = cos(v26);
      v32 = v13;
      v24 = v25 - v13 * v30;
      v36 = sqrt(v29 * v37 * (v29 * v37) + v24 * v24);
      v28 = v13 * v34 + v27;
      v23 = sub_100478A0(v36, v28);
      v14 = v29 * v34 / v36;
      v15 = 1.0 - v14 * v14;
      v16 = v38;
      v31 = v38;
      if ( v15 > 0.0 )
      {
        v16 = v28 - v38 / v15;
        v31 = v16;
      }
      ++v10;
      v35 = v16 * v16 + v16 * v16 - 1.0;
      v17 = v15 * ((4.0 - v15 * 3.0) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
      v18 = v26;
      v12 = 0.00335281066474748 * ((1.0 - v17) * (v14 * (v36 * (v16 + v35 * v28 * v17) * v17 + v23)))
          + *(float *)(a2 + 4)
          - *(float *)(a1 + 4);
      v26 = v12;
    }
    while ( fabs(v18 - v12) > 0.00000005 && v10 < 20 );
    v19 = sub_100478A0(v29 * v37, v24);
    v20 = sub_100478A0(v29 * v33, v32 * v25 - v30);
    v21 = sqrt(v15 * 0.006739496742276252 + 1.0);
    v22 = (v21 + 1.0 - 2.0) / (v21 + 1.0);
    *a3 = (0.25 * (v22 * v22) + 1.0)
        / (1.0 - v22)
        * ((v22 * 0.375 * v22 - 1.0)
         * v22
         * (v36
          * (v31
           + ((1.0 - v35 - v35) * (v36 * v36 * 4.0 - 3.0) * v31 * ((v22 * 0.375 * v22 - 1.0) * v22) / 6.0 - v35 * v28)
           * ((v22 * 0.375 * v22 - 1.0)
            * v22)
           * 0.25))
         + v23)
        * 6378137.0
        * 0.9966471893352525;
    *a4 = v19;
    *a5 = v20;
  }
  else
  {
    sub_1005BBC0(*(float *)a1, *(float *)a2, (int)a3);
    if ( *(float *)a1 >= (double)*(float *)a2 )
    {
      *a4 = 3.1415925;
      *a5 = 3.1415925;
    }
    else
    {
      *a4 = 0.0;
      *a5 = 0.0;
    }
  }
}

//----- (1005C150) --------------------------------------------------------
void __cdecl sub_1005C150(int a1, int a2, float *a3, float *a4)
{
  float v4; // ST14_4@1
  float v5; // ST14_4@1
  float v6; // [sp+Ch] [bp-1Ch]@1
  float v7; // [sp+10h] [bp-18h]@1
  float v8; // [sp+14h] [bp-14h]@1
  float v9; // [sp+18h] [bp-10h]@1
  float v10; // [sp+1Ch] [bp-Ch]@1
  float v11; // [sp+20h] [bp-8h]@3
  float v12; // [sp+24h] [bp-4h]@3

  sub_100477B0(a1, (int)&v9);
  sub_100477B0(a2, (int)&v7);
  v4 = v10 - v8;
  v6 = sub_10047770(v4);
  v5 = v9 - v7;
  if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) >= 0.0014486233 || COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF) >= 0.0014486233 )
  {
    sub_1005BD80((int)&v9, (int)&v7, a3, a4, &v6);
  }
  else
  {
    sub_1005BB60(&v9, &v7, a3, (int)&v11);
    *a4 = sub_10047910(v11, v12);
  }
}

//----- (1005C230) --------------------------------------------------------
int __cdecl sub_1005C230(int a1, float a2, float *a3, int a4, float *a5)
{
  float *v5; // esi@1
  float *v6; // edi@1
  int v7; // ebx@3
  int result; // eax@3

  v5 = (float *)a1;
  v6 = (float *)LODWORD(a2);
  *(float *)&a1 = *(float *)(a1 + 4) - *(float *)(LODWORD(a2) + 4);
  a2 = sub_10047770(*(float *)&a1);
  *(float *)&a1 = *v5 - *v6;
  a1 &= 0x7FFFFFFFu;
  if ( *(float *)&a1 >= 0.0014486233
    || (a1 = LODWORD(a2) & 0x7FFFFFFF, COERCE_FLOAT(LODWORD(a2) & 0x7FFFFFFF) >= 0.0014486233) )
  {
    sub_1005BD80((int)v5, (int)v6, a3, (float *)&a1, &a2);
    sub_10047800(*(float *)&a1, a4, a4 + 4);
    result = sub_10047800(a2, (int)a5, (int)(a5 + 1));
  }
  else
  {
    v7 = a4;
    sub_1005BB60(v5, v6, a3, a4);
    result = (int)a5;
    *a5 = *(float *)v7;
    *(float *)(result + 4) = *(float *)(v7 + 4);
  }
  return result;
}

//----- (1005C310) --------------------------------------------------------
double __cdecl sub_1005C310(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (1005C340) --------------------------------------------------------
int __cdecl sub_1005C340(int a1, __int16 a2, __int16 a3)
{
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 46) + *(_WORD *)(a1 + 42);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 44) + *(_WORD *)(a1 + 40);
  return sub_10008B60(a1);
}

//----- (1005C3A0) --------------------------------------------------------
int __cdecl sub_1005C3A0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5, char a6)
{
  int result; // eax@1
  __int16 v7; // ST1C_2@8
  int v8; // [sp+0h] [bp-14h]@4
  int v9; // [sp+Ch] [bp-8h]@4
  __int16 v10; // [sp+10h] [bp-4h]@8
  __int16 v11; // [sp+28h] [bp+14h]@8
  __int16 v12; // [sp+2Ch] [bp+18h]@8

  result = a4;
  if ( a4 > 0 && a5 > 0 )
  {
    v8 = *(_DWORD *)(a1 + 36);
    v9 = *(_DWORD *)(a1 + 36);
    if ( a6 & 1 )
      sub_10008300(a1, a2, a3, a4, a5);
    if ( !(a6 & 2) )
      LOWORD(v9) = HIWORD(v9);
    v12 = a5 - 1;
    v11 = a4 - 1;
    v10 = a2;
    v10 = *(_WORD *)(a1 + 42) + a2;
    v7 = *(_WORD *)(a1 + 40) + a3;
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100EE680[0]);
    *(_WORD *)(a1 + 10) = byte_100EE680[1] + v10;
    *(_WORD *)(a1 + 8) = v7;
    *(_WORD *)(a1 + 14) = byte_100EE680[2] + v11 - byte_100EE680[1] + 1;
    sub_100089F0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100EE680[3]);
    *(_WORD *)(a1 + 8) = byte_100EE680[4] + v7;
    *(_WORD *)(a1 + 10) = v11 + v10;
    *(_WORD *)(a1 + 12) = byte_100EE680[5] + v12 - byte_100EE680[4] + 1;
    sub_10008BC0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100EE680[6]);
    *(_WORD *)(a1 + 10) = byte_100EE680[8] + v11 + v10;
    *(_WORD *)(a1 + 8) = v12 + v7;
    *(_WORD *)(a1 + 14) = byte_100EE680[7] - (byte_100EE680[8] + v11) - 1;
    sub_100089F0(a1);
    *(_WORD *)(a1 + 38) = *((_WORD *)&v9 + byte_100EE680[9]);
    *(_WORD *)(a1 + 8) = byte_100EE680[11] + v12 + v7;
    *(_WORD *)(a1 + 10) = v10;
    *(_WORD *)(a1 + 12) = byte_100EE680[10] - (byte_100EE680[11] + v12) - 1;
    sub_10008BC0(a1);
    result = v8;
    *(_DWORD *)(a1 + 36) = v8;
  }
  return result;
}

//----- (1005C600) --------------------------------------------------------
int __cdecl sub_1005C600(int a1, signed int a2, int a3, int a4, int a5)
{
  int result; // eax@3
  __int16 v6; // ST14_2@11
  __int16 v7; // ST18_2@11
  __int16 v8; // ST5C_2@11
  int v9; // edx@47
  int v10; // eax@50
  int v11; // ecx@50
  int v12; // ecx@51
  __int16 v13; // [sp+4h] [bp-6Ch]@55
  __int16 v14; // [sp+Ah] [bp-66h]@11
  __int16 v15; // [sp+Eh] [bp-62h]@11
  signed __int16 j; // [sp+10h] [bp-60h]@6
  unsigned __int16 l; // [sp+10h] [bp-60h]@18
  signed __int16 ii; // [sp+10h] [bp-60h]@47
  unsigned __int16 v19; // [sp+14h] [bp-5Ch]@22
  unsigned __int16 v20; // [sp+18h] [bp-58h]@24
  char *v21; // [sp+20h] [bp-50h]@1
  __int16 k; // [sp+28h] [bp-48h]@15
  int v23; // [sp+2Ch] [bp-44h]@47
  int v24; // [sp+30h] [bp-40h]@47
  int v25; // [sp+34h] [bp-3Ch]@47
  int v26; // [sp+38h] [bp-38h]@15
  int v27; // [sp+3Ch] [bp-34h]@4
  int v28; // [sp+40h] [bp-30h]@11
  __int16 v29; // [sp+44h] [bp-2Ch]@13
  signed __int16 v30; // [sp+48h] [bp-28h]@11
  int v31; // [sp+4Ch] [bp-24h]@11
  signed __int16 v32; // [sp+54h] [bp-1Ch]@11
  __int16 v33; // [sp+5Ch] [bp-14h]@57
  signed __int16 i; // [sp+60h] [bp-10h]@4
  unsigned __int16 m; // [sp+60h] [bp-10h]@36
  signed __int16 n; // [sp+60h] [bp-10h]@44
  unsigned __int16 jj; // [sp+60h] [bp-10h]@53
  __int16 v38; // [sp+64h] [bp-Ch]@11
  __int16 v39; // [sp+68h] [bp-8h]@4
  unsigned __int16 v40; // [sp+6Ch] [bp-4h]@17
  int v41; // [sp+84h] [bp+14h]@1

  v21 = (char *)(a5 + (-a5 & 3));
  v41 = a4 - (-a5 & 3) - (((_BYTE)a4 - (-(char)a5 & 3)) & 3);
  if ( a2 >= 2 && 2 * a2 <= v41 )
  {
    v39 = *(_WORD *)(a1 + 4);
    *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 6);
    v27 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
    *(_WORD *)v21 = 0;
    for ( i = 1; (unsigned __int16)i < a2; ++i )
    {
      for ( j = i;
            j
         && *(_WORD *)(a3 + 4 * *(_WORD *)&v21[2 * (unsigned __int16)j - 2] + 2) > (signed int)*(_WORD *)(a3 + 4 * (unsigned __int16)i + 2);
            --j )
      {
        *(_WORD *)&v21[2 * (unsigned __int16)j] = *(_WORD *)&v21[2 * (unsigned __int16)j - 2];
      }
      *(_WORD *)&v21[2 * (unsigned __int16)j] = i;
    }
    v30 = 0;
    v32 = 0;
    v28 = 2 * a2 + (-2 * a2 & 3);
    v31 = (int)&v21[v28];
    v6 = *(_WORD *)(a1 + 26);
    v7 = *(_WORD *)(a1 + 30);
    v15 = *(_WORD *)(a1 + 28);
    v8 = *(_WORD *)(a1 + 42);
    v14 = *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 40);
    v38 = *(_WORD *)(a3 + 4 * *(_WORD *)v21 + 2);
    if ( v38 < v14 )
      v38 = *(_WORD *)(a1 + 24) - *(_WORD *)(a1 + 40);
    v29 = *(_WORD *)(a3 + 4 * *(_WORD *)&v21[2 * a2 - 2] + 2);
    if ( v29 > v15 + v14 )
      v29 = v15 + v14;
    v26 = 0;
    for ( k = v38; k < v29; ++k )
    {
      while ( 1 )
      {
        v40 = *(_WORD *)&v21[2 * v26];
        if ( *(_WORD *)(a3 + 4 * v40 + 2) > k )
          break;
        for ( l = 0; (signed int)l < 2; ++l )
        {
          if ( l )
          {
            if ( v40 == a2 - 1 )
              v19 = 0;
            else
              v19 = v40 + 1;
            v20 = v40;
          }
          else
          {
            if ( v40 )
              v19 = v40 - 1;
            else
              v19 = a2 - 1;
            v20 = v19;
          }
          if ( *(_WORD *)(a3 + 4 * v19 + 2) <= k )
          {
            if ( *(_WORD *)(a3 + 4 * v19 + 2) < k )
            {
              for ( m = 0; m < (signed int)(unsigned __int16)v30 && *(_WORD *)(v31 + 12 * m) != v20; ++m )
                ;
              if ( (unsigned __int16)v30 - m > 0 )
                memcpy((void *)(v31 + 12 * m), (const void *)(v31 + 12 * (m + 1)), 12 * ((unsigned __int16)--v30 - m));
            }
          }
          else
          {
            if ( (unsigned __int16)v30 == (unsigned __int16)((v41 - v28) / 0xCu) )
            {
              v32 = -1;
              goto LABEL_63;
            }
            *(_WORD *)(v31 + 12 * (unsigned __int16)v30) = v20;
            *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 4) = ((*(_WORD *)(a3 + 4 * v19)
                                                                - (signed int)*(_WORD *)(a3 + 4 * v40)) << 16)
                                                              / (*(_WORD *)(a3 + 4 * v19 + 2)
                                                               - (signed int)*(_WORD *)(a3 + 4 * v40 + 2));
            *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 8) = (*(_WORD *)(a3 + 4 * v40) << 16)
                                                              + *(_DWORD *)(v31 + 12 * (unsigned __int16)v30 + 4)
                                                              * (k - *(_WORD *)(a3 + 4 * v40 + 2));
            if ( (unsigned __int16)++v30 > (signed int)(unsigned __int16)v32 )
              v32 = v30;
          }
        }
        ++v26;
      }
      for ( n = 1; (unsigned __int16)n < (signed int)(unsigned __int16)v30; ++n )
      {
        if ( *(_DWORD *)(v31 + 12 * ((unsigned __int16)n - 1) + 8) > *(_DWORD *)(v31 + 12 * (unsigned __int16)n + 8) )
        {
          v9 = v31 + 12 * (unsigned __int16)n;
          v23 = *(_DWORD *)v9;
          v24 = *(_DWORD *)(v9 + 4);
          v25 = *(_DWORD *)(v9 + 8);
          for ( ii = n; ii && *(_DWORD *)(v31 + 12 * ((unsigned __int16)ii - 1) + 8) > v25; --ii )
          {
            v10 = v31 + 12 * ((unsigned __int16)ii - 1);
            v11 = v31 + 12 * (unsigned __int16)ii;
            *(_DWORD *)v11 = *(_DWORD *)v10;
            *(_DWORD *)(v11 + 4) = *(_DWORD *)(v10 + 4);
            *(_DWORD *)(v11 + 8) = *(_DWORD *)(v10 + 8);
          }
          v12 = v31 + 12 * (unsigned __int16)ii;
          *(_DWORD *)v12 = v23;
          *(_DWORD *)(v12 + 4) = v24;
          *(_DWORD *)(v12 + 8) = v25;
        }
      }
      for ( jj = 0; jj < (unsigned __int16)v30 - 1; jj += 2 )
      {
        v13 = *(_DWORD *)(v31 + 12 * jj + 8) >> 16;
        if ( *(_WORD *)(v31 + 12 * jj + 8) )
          ++v13;
        v33 = *(_DWORD *)(v31 + 12 * (jj + 1) + 8) >> 16;
        if ( !*(_WORD *)(v31 + 12 * (jj + 1) + 8) )
          --v33;
        if ( v13 <= v33 )
        {
          *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + v13;
          *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + k;
          *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + v33;
          sub_10008940(a1);
        }
        *(_DWORD *)(v31 + 12 * jj + 8) += *(_DWORD *)(v31 + 12 * jj + 4);
        *(_DWORD *)(v31 + 12 * (jj + 1) + 8) += *(_DWORD *)(v31 + 12 * (jj + 1) + 4);
      }
    }
LABEL_63:
    *(_WORD *)(a1 + 4) = v39;
    *(_DWORD *)(a1 + 36) = v27;
    if ( (unsigned __int16)v32 == 0xFFFF )
      result = -1;
    else
      result = v31 + 12 * (unsigned __int16)v32 - a5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005CCF0) --------------------------------------------------------
char __cdecl sub_1005CCF0(float a1, int a2, int a3)
{
  char v3; // bl@8
  char result; // al@8
  unsigned __int8 v5; // [sp+Ch] [bp-28h]@1
  unsigned __int8 v6; // [sp+18h] [bp-1Ch]@2
  char v7; // [sp+1Ah] [bp-1Ah]@6

  sub_10005F90((int)&v5);
  if ( LOBYTE(a1) < v5
    || LOBYTE(a1) >= v6 && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_101E741C + 816) != 3)
    || LOBYTE(a1) >= 0x66u
    || v7
    || sub_10005B40(1) )
  {
    result = 0;
  }
  else
  {
    sub_10021020();
    v3 = sub_1000A0E0(a1, a2, a3);
    sub_10021010();
    result = v3;
  }
  return result;
}
// 101E741C: using guessed type int dword_101E741C;

#error "There were 52 decompilation failure(s) on 1359 function(s)"
