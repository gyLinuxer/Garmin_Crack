/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char **sub_10001000();
double __cdecl sub_10001010(float a1, float a2);
double __cdecl sub_10001130(float a1);
// bool __usercall sub_10001170@<al>(unsigned __int8 a1@<al>, char a2@<bl>, signed int a3, signed int a4, char a5);
// char __usercall sub_10001370@<al>(float *a1@<esi>);
// char __usercall sub_100013E0@<al>(float *a1@<esi>);
// char __usercall sub_10001450@<al>(float *a1@<esi>);
// bool *__usercall sub_100014C0@<eax>(unsigned __int16 a1@<ax>, bool *a2);
// char __usercall sub_10001500@<al>(size_t a1@<edi>, int a2@<esi>, __int16 a3, void *a4);
// BOOL __usercall sub_10001550@<eax>(_BYTE *a1@<esi>, unsigned __int8 a2);
int __cdecl sub_100015B0(float); // idb
char __cdecl sub_10001690(int a1);
// char __usercall sub_100016D0@<al>(int a1@<eax>, char *a2);
char __cdecl sub_100016F0(_BYTE *a1);
BOOL __cdecl sub_100017C0(char *a1);
char __cdecl sub_10001900(char *a1);
// char __usercall sub_10001A80@<al>(_DWORD *a1@<edi>);
// char __usercall sub_10001B90@<al>(int a1@<ecx>, float *a2@<edx>, double a3@<st0>);
// __int16 __usercall sub_100036F0@<ax>(double st7_0@<st0>, int a1, char a2, int a3, int a4, int a5, char a6);
// int __usercall sub_10004230@<eax>(double st7_0@<st0>, int a1, int a2, int a3, int a4);
__int16 __cdecl sub_100042E0(int a1, unsigned __int16 a2);
int __cdecl sub_100043C0(char a1);
// int __usercall sub_10004460@<eax>(_WORD *a1@<eax>, int a2);
// signed int __usercall sub_10004490@<eax>(unsigned __int16 a1@<ax>);
char __cdecl sub_100044C0(char a1, _DWORD *a2);
// char __usercall sub_10004510@<al>(int a1@<eax>, int a2@<edx>, double st7_0@<st0>, char a3, char a4);
// char __usercall sub_100045C0@<al>(unsigned __int16 a1@<ax>, int a2);
// char __usercall sub_10004600@<al>(char a1@<al>, unsigned __int16 a2@<cx>);
// char __usercall sub_10004650@<al>(unsigned __int16 a1@<ax>, char a2);
// char __usercall sub_100046D0@<al>(int a1@<eax>, int a2@<ecx>, char a3@<bl>, int a4, char a5, _BYTE *a6);
// char __usercall sub_10004840@<al>(unsigned __int16 a1@<ax>, int a2@<edi>);
char __cdecl sub_10004890(char a1);
// char __usercall sub_10004940@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, double st7_0@<st0>, __int16 a4, unsigned __int16 a5, int a6, char a7);
// char __usercall sub_10004F80@<al>(unsigned __int16 a1@<ax>, char a2@<dl>, int a3@<ecx>, int a4);
// char __usercall sub_10005020@<al>(double st7_0@<st0>, int a1, int a2, unsigned __int8 a3, unsigned __int16 a4, char a5);
// int __usercall sub_10005290@<eax>(int a1@<edi>, double st7_0@<st0>, int a2, int a3, int a4, char a5, __int16 a6, _BYTE *a7, _BYTE *a8, _BYTE *a9, _BYTE *a10);
// char __usercall sub_100053D0@<al>(double st7_0@<st0>, int a1, signed __int16 a2, int a3, int a4, int a5, int a6);
char __cdecl sub_10005A40(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_10005BD0(unsigned __int8 a1, int a2, int a3);
signed __int16 __cdecl sub_10005C10(unsigned __int8 a1);
signed int __cdecl sub_10005D20(unsigned __int8 a1, unsigned __int16 a2, char a3);
int sub_10005E20();
unsigned int __cdecl sub_10005E60(char a1);
double __cdecl sub_100061C0(float a1, int a2);
int __cdecl sub_10006210(unsigned __int8 a1);
char __cdecl sub_10006340(int a1, unsigned int *a2);
int __cdecl sub_100065D0(unsigned __int16 a1, unsigned __int8 a2);
// int __usercall sub_10006790@<eax>(void *a1@<ecx>, _DWORD *a2@<ebx>, size_t a3, char a4, int a5);
// int __usercall sub_100068E0@<eax>(int a1@<ecx>, char *a2@<edi>, char a3, size_t a4);
unsigned int __fastcall sub_10006B60(unsigned __int8 a1);
// void *__usercall sub_10006CC0@<eax>(int a1@<esi>);
// int __usercall sub_10006D00@<eax>(unsigned int a1@<eax>, int a2@<esi>, unsigned __int8 a3, int a4);
// void *__usercall sub_10006DB0@<eax>(size_t a1@<eax>, int a2@<edx>, void *a3@<edi>, size_t a4@<esi>, _DWORD *a5, void *a6, char a7);
char sub_10006DF0();
unsigned int *__cdecl sub_10006EA0(unsigned int *a1);
int sub_10007170();
char __cdecl sub_100071C0(int a1);
char __cdecl sub_10007310(int a1, int a2, void *a3, size_t a4);
int __cdecl sub_10007390(unsigned __int8 a1, unsigned __int16 a2, char a3);
// int __usercall sub_100074C0@<eax>(int@<ecx>, void *@<edx>, char, int, int); idb
// void *__usercall sub_10007B70@<eax>(double st7_0@<st0>, char a1, char a2);
// void *__usercall sub_10008160@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned __int8 a4, int a5, int a6, int a7, int a8, int a9, int a10);
// signed int __usercall sub_10008D10@<eax>(int a1@<edx>, int a2@<ecx>, char a3@<bl>, double st7_0@<st0>, int a4, _WORD *a5, int a6, int a7, int a8, int a9, int a10);
// signed int __usercall sub_10009A50@<eax>(unsigned __int16 a1@<ax>, unsigned __int8 a2@<cl>, char a3);
int sub_1000A010();
// char __usercall sub_1000A4F0@<al>(double st7_0@<st0>, unsigned __int16 a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
char sub_1000A880();
void *sub_1000A950();
void *__cdecl sub_1000AAB0(unsigned __int16 a1);
// char __usercall sub_1000AC40@<al>(unsigned int a1@<eax>, unsigned __int16 a2@<cx>, unsigned int a3@<ebx>, unsigned __int8 a4, int a5);
char __cdecl sub_1000B140(unsigned int a1, unsigned __int8 a2, unsigned __int16 a3, int a4);
char __cdecl sub_1000B1A0(unsigned __int8 a1, int a2);
char __cdecl sub_1000B200(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1000B260(unsigned __int8 a1, int a2);
bool __cdecl sub_1000B300(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1000B370(unsigned __int8 a1, int a2);
char __cdecl sub_1000B430(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1000B490(unsigned __int8 a1, int a2);
char __cdecl sub_1000B550(unsigned __int8 a1, unsigned __int16 a2, int a3);
int __cdecl sub_1000B5B0(int, int, char *); // idb
int __cdecl sub_1000B8C0(unsigned __int8 a1, unsigned __int16 a2, unsigned int a3, unsigned int a4);
int __cdecl sub_1000C860(unsigned __int8 a1, unsigned __int16 a2, int a3, char a4);
int sub_1000CA00();
int sub_1000CA10();
signed int sub_1000CA20();
// char __usercall sub_1000CA80@<al>(double st7_0@<st0>, __int16 a1, __int16 a2, char a3, unsigned __int8 a4);
// void __usercall sub_1000CBB0(double a1@<st0>);
// int __usercall sub_1000D630@<eax>(double st7_0@<st0>, int a1, _DWORD *a2);
int __cdecl sub_1000D660(void *); // idb
char **sub_1000D780();
bool sub_1000D790();
bool sub_1000D7C0();
int (**sub_1000D7F0())();
// int __usercall sub_1000D810@<eax>(size_t a1@<ebx>, char *a2@<esi>);
char __cdecl sub_1000D960(unsigned __int16 a1, float *a2);
int sub_1000D980();
// signed int __usercall sub_1000DA70@<eax>(unsigned int a1@<eax>, char *a2, signed int a3);
// void __usercall sub_1000DBC0(void *a1@<ecx>, _DWORD a2@<esi>);
int sub_1000E190();
signed int __thiscall sub_1000E280(void *this);
char __thiscall sub_1000E450(void *this);
// signed int __usercall sub_1000E820@<eax>(signed int a1@<eax>, char *a2@<ecx>);
signed int sub_1000E8C0();
void sub_1000EA30();
int sub_1000EAB0();
__int16 __cdecl sub_1000EB00(int a1, int a2, int a3, int a4, void *a5, int a6, int a7, int a8, __int16 a9, __int16 a10, __int16 a11, int a12, void *a13);
_DWORD sub_1000F100(); // weak
int __cdecl sub_1000F150(int a1);
int __cdecl sub_1000F170(int a1, int a2, int a3);
int __cdecl sub_1000F190(int a1, int a2);
void __cdecl sub_1000F1B0(int a1, char a2, signed int a3);
void __cdecl sub_1000F290(int a1, unsigned int a2, signed int *a3, signed int *a4);
void __cdecl sub_1000F7D0(unsigned int a1, int a2);
double *__cdecl sub_1000F920(char a1, char a2, double *a3);
void __cdecl sub_1000FA50(unsigned int a1, char *a2);
// void __usercall sub_1000FAB0(int ebx0@<ebx>, unsigned __int8 a1, int *a2, float *a3, float *a4);
void sub_1000FCD0();
signed int sub_1000FCE0();
char __cdecl sub_1000FCF0(unsigned __int8 a1, int a2, char a3, int a4);
// char __usercall sub_1000FD70@<al>(int a1@<eax>, unsigned __int8 a2);
int __fastcall sub_1000FE10(int a1, int a2);
void __cdecl sub_1000FE40(unsigned int a1, int a2);
char __cdecl sub_1000FF80(unsigned int a1, int a2);
// void __usercall sub_10010030(int a1@<ecx>, int a2@<esi>);
char __cdecl sub_10010060(unsigned int a1, int a2);
int __cdecl sub_10010180(int a1, int a2);
int __cdecl sub_100101F0(int, char, void *); // idb
char __cdecl sub_10010270(int a1, char a2, char *a3);
void __cdecl sub_10010550(_BYTE *a1, signed int a2, int a3);
unsigned int __cdecl sub_100105F0(unsigned int a1, _BYTE *a2, _BYTE *a3);
char __cdecl sub_10010610(__int64 a1);
double __cdecl sub_10010640(float a1);
// char __usercall sub_10010700@<al>(unsigned __int16 a1@<ax>, void *a2);
// int __usercall sub_10010760@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_10010780(unsigned __int16 a1, int a2);
int __cdecl sub_10010810(unsigned __int16 a1, int a2);
signed int __cdecl sub_10010880(unsigned __int8 a1, unsigned __int8 a2);
double sub_100108E0();
void __cdecl sub_10010940(unsigned int a1, char *a2, float *a3, int a4, char a5);
void __cdecl sub_10010C80(signed int a1, char *a2);
int __cdecl sub_10010CC0(unsigned __int8 a1);
int __cdecl sub_10010D00(int a1);
signed int __thiscall sub_10010D40(int this);
// signed int __usercall sub_10010DF0@<eax>(int a1@<edi>);
signed int __thiscall sub_10010E80(int this);
// int __usercall sub_10010F20@<eax>(int a1@<esi>);
// char __usercall sub_10010F40@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6);
// void *__usercall sub_10011000@<eax>(int a1@<eax>, char *a2@<esi>);
// __int16 __usercall sub_10011060@<ax>(int a1@<eax>, int a2@<esi>, int a3);
void *__cdecl sub_100111D0(unsigned int a1, char *a2);
signed int __cdecl sub_10011220(unsigned __int8 a1);
// signed int __usercall sub_100112A0@<eax>(int a1@<edi>, unsigned __int8 a2);
signed int __cdecl sub_10011310(unsigned __int8 a1);
// int __usercall sub_10011380@<eax>(int a1@<eax>, char a2);
// void __usercall sub_10011410(int a1@<edi>, int a2, int a3);
int __cdecl sub_10011450(__int64 a1);
double __cdecl sub_10011500(int a1);
int __cdecl sub_10011570(int a1, int a2);
char __cdecl sub_10011700(int a1, int a2);
__int16 __cdecl sub_10011770(int a1, int a2);
char *__cdecl sub_100117B0(unsigned __int8 a1);
signed int sub_10011870();
int sub_10011890();
int sub_100118F0();
char *sub_10011960();
int __cdecl sub_10011A30(const void *a1);
unsigned __int8 __cdecl sub_10011AE0(unsigned int a1);
unsigned int __cdecl sub_10011B10(unsigned int a1, unsigned __int8 a2, char a3);
unsigned int __cdecl sub_10011B90(unsigned int a1);
char __cdecl sub_10011BC0(__int64 a1);
void __cdecl sub_10011C60(unsigned int a1, int a2);
char __cdecl sub_10011E40(unsigned int a1, int a2);
int sub_10011EB0();
char __cdecl sub_10011F50(float *a1);
char __cdecl sub_10012210(int a1, float *a2);
double __cdecl sub_10012230(unsigned int a1);
_BYTE *__cdecl sub_100122E0(_BYTE *a1, _BYTE *a2);
int sub_10012310();
int __fastcall sub_10012320(unsigned __int8 a1);
int __fastcall sub_10012340(unsigned __int8 a1);
void *__cdecl sub_10012360(char a1, void *a2);
int __cdecl sub_10012430(int a1);
char sub_100125F0();
_DWORD __cdecl sub_10012750(_DWORD, _DWORD); // weak
char *__cdecl sub_10012760(int a1, char *a2, int a3, char *a4, int a5);
char sub_10012890();
char __cdecl sub_100128A0(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_100129A0(char *a1, int a2, char a3, char *a4);
int __cdecl sub_10012A10(char a1);
signed int sub_10012A30();
// signed int __usercall sub_10012A80@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10012B20@<eax>(char a1@<al>);
// int __usercall sub_10012B40@<eax>(char a1@<al>);
// unsigned __int16 __usercall sub_10012B60@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_10012DA0(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_10012F00(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10013080(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_100131E0(int a1, int a2, void *a3, char a4, __int16 a5, char a6);
char __cdecl sub_10013320(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10013400(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10013680(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_100136B0(char a1, unsigned __int16 a2, _DWORD *a3);
char __cdecl sub_100136E0(char a1, int a2, void *a3);
char __cdecl sub_10013710(char a1, int a2, void *a3, int a4);
char __cdecl sub_10013740(_DWORD *a1);
char __cdecl sub_10013780(int a1, int a2);
char __cdecl sub_100137B0(int a1, int a2, int a3);
char __cdecl sub_100137E0(int a1);
char __cdecl sub_10013800(int a1);
char __cdecl sub_10013820(__int16 a1);
char __cdecl sub_10013880(__int16 a1, char a2);
char __cdecl sub_100138F0(int a1);
char __cdecl sub_10013910(int a1);
int __cdecl sub_10013930(int a1, int a2, int a3);
int __cdecl sub_10013960(int a1);
int __cdecl sub_100139C0(int a1, int a2);
int __cdecl sub_10013A30(int a1, int a2, int a3);
int __cdecl sub_10013A80(int a1);
char __cdecl sub_10013AC0(int a1, void *a2);
char __cdecl sub_10013B10(int a1, void *a2);
char __cdecl sub_10013B60(int a1, void *a2);
char __cdecl sub_10013B80(int a1, void *a2);
char __cdecl sub_10013BA0(unsigned __int8 a1, _WORD *a2);
char __cdecl sub_10013C20(unsigned __int8 a1, unsigned __int8 a2);
char sub_10013C70();
char sub_10013DB0();
BOOL __cdecl sub_10013EF0(int a1);
char __cdecl sub_10013F10(char a1, _DWORD *a2);
// __int16 __usercall sub_10013F50@<ax>(int a1@<edi>, char a2);
// signed __int16 __usercall sub_100140F0@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>);
char __cdecl sub_10014340(signed __int16 a1);
char __cdecl sub_100143D0(unsigned __int16 a1);
char __cdecl sub_10014470(char a1, int a2);
bool __cdecl sub_10014490(float *a1);
int sub_10014530();
// char __usercall sub_10014560@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4);
char __cdecl sub_100145C0(void *a1);
char __cdecl sub_10014620(float *a1);
char __cdecl sub_10014720(void *a1);
char __cdecl sub_10014780(void *a1);
char __cdecl sub_100147E0(void *a1);
char __cdecl sub_10014840(void *a1);
char __cdecl sub_10014920(float *a1);
char __cdecl sub_10014950(float *a1);
int __cdecl sub_100149F0(void *); // idb
char __cdecl sub_10014A20(float *a1);
char __cdecl sub_10014A90(float *a1);
char __cdecl sub_10014B00(bool *a1);
int __cdecl sub_10014C40(int a1, unsigned int a2);
int __cdecl sub_10014D30(int *a1, unsigned int a2);
__int16 __cdecl sub_10014E20(int a1, unsigned int a2);
int __cdecl sub_10014E70(int *a1, unsigned int a2);
__int16 __cdecl sub_10014EA0(unsigned int *a1, _WORD *a2, _WORD *a3);
int __cdecl sub_10014F20(unsigned __int64 a1);
int __cdecl sub_10014FB0(void *); // idb
char __cdecl sub_10015020(int a1, void *a2);
char __fastcall sub_10015180(int a1);
char __cdecl sub_100151D0(unsigned int a1);
char __cdecl sub_10015240(char a1);
char __cdecl sub_10015290(char a1);
char __cdecl sub_100152C0(char a1);
// char __usercall sub_100152F0@<al>(unsigned __int8 a1@<al>, _BYTE *a2);
char __cdecl sub_10015320(void *a1, int a2);
char __cdecl sub_100155D0(void *a1);
signed int sub_100155F0();
int sub_10015600();
char sub_10015630();
char __cdecl sub_10015670(char a1);
int __cdecl sub_10015700(int a1, signed int a2, signed int a3);
int __cdecl sub_10015720(int, double, double); // idb
int __cdecl sub_10015800(double, double); // idb
void sub_10015850();
signed int sub_10015860();
// char __usercall sub_10015870@<al>(float *a1@<esi>);
signed int sub_100158E0();
int __cdecl sub_10015910(int a1);
bool __cdecl sub_100159B0(char a1, int a2);
char __cdecl sub_10015BD0(float *a1);
char __cdecl sub_10015C30(float *a1);
char sub_10015C70();
bool __cdecl sub_10015CE0(float *a1);
bool __cdecl sub_10015D90(float *a1);
char __cdecl sub_10015DF0(float *a1, float *a2);
// void __usercall sub_10015E60(double a1@<st0>);
char __thiscall sub_10015E80(void *this);
char __thiscall sub_10015EB0(void *this);
signed int __cdecl sub_10015EE0(char a1);
char __thiscall sub_10015EF0(void *this);
char __thiscall sub_10015F20(void *this);
int sub_10015F50();
char __fastcall sub_10015F80(int a1);
char __cdecl sub_10015FD0(int a1);
int __cdecl sub_10015FF0(int, char *); // idb
char __thiscall sub_10016050(void *this);
char __thiscall sub_10016070(void *this);
char __thiscall sub_10016090(void *this);
void *__thiscall sub_100160B0(void *this);
char __thiscall sub_100160D0(void *this);
char __thiscall sub_100160F0(void *this);
BOOL sub_10016110();
int __cdecl sub_10016130(char a1);
void __cdecl sub_10016140(float a1, float a2, char a3);
void __cdecl sub_10016280(float a1);
void sub_10016320();
char __cdecl sub_10016500(int a1, void *a2);
// void *__usercall sub_10016560@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_100165B0();
char __cdecl sub_100183B0(int a1, float *a2);
// char __usercall sub_10018410@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5);
// double __usercall sub_10018520@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4);
unsigned __int8 __cdecl sub_10018620(int a1, int a2, char a3, void *a4);
char __cdecl sub_100187B0(unsigned __int16 a1, void *a2);
double __cdecl sub_10018810(float a1, float a2, int a3, float a4);
char __cdecl sub_100188F0(unsigned __int16 a1, float *a2);
double __cdecl sub_10018A10(float a1);
// char __usercall sub_10018A70@<al>(int a1@<esi>, unsigned __int16 a2, float *a3);
char __cdecl sub_10018FB0(char a1, bool *a2);
char __cdecl sub_10019010(char a1, bool *a2);
char __cdecl sub_10019070(float *a1);
double sub_10019310();
double sub_10019340();
// void __usercall sub_10019370(int a1@<esi>, int a2, float a3);
// char __usercall sub_100194D0@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3);
// char __usercall sub_100195C0@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4);
char __cdecl sub_100198A0(float *a1);
char __cdecl sub_10019910(float *a1);
char __cdecl sub_10019930(float *a1);
char __cdecl sub_10019950(float *a1);
char __cdecl sub_100199E0(float *a1);
char __cdecl sub_10019A50(float *a1);
char __cdecl sub_10019B20(float *a1);
char __cdecl sub_10019BF0(float *a1);
char __cdecl sub_10019CC0(float *a1);
char __cdecl sub_10019D60(float *a1);
double sub_10019DD0();
char __cdecl sub_10019E30(float *a1);
char __cdecl sub_10019ED0(float a1, int a2);
char __cdecl sub_10019F70(char *a1);
char __cdecl sub_10019FA0(int a1);
char __cdecl sub_10019FF0(int a1);
bool __cdecl sub_1001A040(int a1, void *a2, int a3);
char __cdecl sub_1001A0C0(unsigned __int16 a1);
char __cdecl sub_1001A130(unsigned __int16 a1, char a2);
bool __cdecl sub_1001A1A0(int a1, void *a2);
signed int sub_1001A1D0();
char __thiscall sub_1001A210(void *this);
char __cdecl sub_1001A230(char a1);
char sub_1001A280();
char sub_1001A2B0();
double __cdecl sub_1001A2F0(char a1);
int __cdecl sub_1001A370(unsigned __int8 a1);
// bool __usercall sub_1001A390@<al>(int a1@<esi>);
// bool __usercall sub_1001A400@<al>(int a1@<eax>);
char __cdecl sub_1001A470(char *a1);
char __cdecl sub_1001A5F0(void *a1);
void sub_1001A6C0();
char __fastcall sub_1001A6D0(int a1);
int __thiscall sub_1001A710(void *this);
signed int __cdecl sub_1001A7A0(_BYTE *a1, char a2, int a3);
int __cdecl sub_1001A7F0(int, float, float, int, int); // idb
unsigned int __cdecl sub_1001A8E0(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_1001A930(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5);
unsigned int __cdecl sub_1001A9D0(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
signed int __cdecl sub_1001AA90(void *a1, size_t a2, int a3);
int __cdecl sub_1001AAF0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_1001AB40(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_1001ABE0(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
char __cdecl sub_1001AC90(int a1, int a2, void *a3);
char __cdecl sub_1001AF30(unsigned __int16 a1, void *a2);
bool sub_1001AF80();
signed int sub_1001AFD0();
signed int sub_1001AFE0();
signed int sub_1001AFF0();
char __cdecl sub_1001B000(char a1, int a2, void *a3);
char __cdecl sub_1001B0B0(unsigned __int16 a1, unsigned __int16 a2);
char __cdecl sub_1001B160(char a1, int a2, void *a3);
char __cdecl sub_1001B210(int a1, int a2, char a3, bool *a4, char *a5);
char __cdecl sub_1001B2E0(int a1);
char sub_1001B310();
unsigned __int8 __cdecl sub_1001B390(unsigned __int16 a1);
__int16 __cdecl sub_1001B3C0(unsigned __int16 a1, unsigned __int8 a2);
bool sub_1001B450();
char __cdecl sub_1001B4F0(unsigned int a1);
double __fastcall sub_1001B530(int a1, int a2);
void *__cdecl sub_1001B590(__int16 a1);
// char __usercall sub_1001B900@<al>(unsigned __int16 a1@<ax>, int a2, char *a3);
// char __usercall sub_1001B970@<al>(int a1@<eax>, unsigned __int16 a2@<di>, char *a3@<esi>);
int sub_1001BAB0();
void *sub_1001BC00();
char __cdecl sub_1001BC80(int a1, int a2, int a3, int a4, int a5, int a6, char *a7);
// char __usercall sub_1001C0C0@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int8 a3, int a4, int a5, int a6);
bool __cdecl sub_1001C6C0(int a1, int a2, int a3, int a4, char *a5, char a6);
bool __cdecl sub_1001C900(int a1, char *a2);
int __cdecl sub_1001CD60(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1001CEF0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5);
char __cdecl sub_1001D010(char a1);
char __cdecl sub_1001D050(char a1);
signed int __cdecl sub_1001D0C0(char a1);
char __cdecl sub_1001D140(char a1);
char __cdecl sub_1001D1B0(char a1);
char __cdecl sub_1001D260(int a1);
char __cdecl sub_1001D370(int a1);
char __thiscall sub_1001D470(void *this);
char __thiscall sub_1001D480(void *this);
void *__thiscall sub_1001D4B0(void *this);
bool __cdecl sub_1001D4D0(char a1);
bool __cdecl sub_1001D540(float a1, int a2, int a3, int a4);
bool __cdecl sub_1001D6B0(signed int a1, signed int a2, _BYTE *a3);
int __cdecl sub_1001D720(int a1, _BYTE *a2, int a3);
int __cdecl sub_1001D770(void *, size_t); // idb
int __cdecl sub_1001D7A0(int, char *, int); // idb
int __cdecl sub_1001D800(char *, size_t, char *, va_list); // idb
int sub_1001D840(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_1001D870(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_1001D8B0(int a1, int a2);
// void *__usercall sub_1001D8D0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4);
void *__cdecl sub_1001D900(void *a1);
char __cdecl sub_1001D930(const void *a1);
void sub_1001D9A0();
BOOL __fastcall sub_1001D9B0(int a1);
signed int sub_1001D9E0();
char __cdecl sub_1001D9F0(char *a1);
char __cdecl sub_1001DA70(__int16 a1);
char __cdecl sub_1001DAC0(unsigned __int8 a1, int a2);
void sub_1001DB60();
char __cdecl sub_1001DB70(unsigned __int8 a1, __int16 a2, char a3);
signed int sub_1001DC20();
int __cdecl sub_1001DC30(int *a1);
// char __usercall sub_1001DC60@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1001DD10(const char *a1);
char __cdecl sub_1001DD50(void *a1);
signed int __cdecl sub_1001DDA0(unsigned int a1, int a2);
char **sub_1001E140();
int sub_1001E150(void); // weak
char *__cdecl sub_1001E180(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1001E300();
const char *__cdecl sub_1001E310(unsigned int a1);
int __cdecl sub_1001E330(int a1, int a2, int a3, int a4);
int __cdecl sub_1001E3E0(int a1);
int __cdecl sub_1001E400(int a1);
char *sub_1001E420(char *a1, ...);
// char *__usercall sub_1001E460@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1001E480@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1001E660();
int sub_1001E680();
int __cdecl sub_1001E6A0(int a1, int a2);
int __cdecl sub_1001E700(int a1);
int __cdecl sub_1001E710(int a1, int a2);
int __cdecl sub_1001E770(int a1);
bool __cdecl sub_1001E780(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001E8C0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1001EC70(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1001F0C0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1001F580(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1001F940(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1001FD40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10020100(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_10020640(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_10020A20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_10020DE0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_10021180(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_10021580(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_10021920(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_10021F00(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_100222F0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_10022690();
// BOOL __usercall sub_100226C0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_10022830@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_10022AA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_10022DA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_10022E50(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
signed int __cdecl sub_10022E90(int a1, int a2);
bool __cdecl sub_10022EF0(signed int a1);
int sub_10022F60();
char sub_10023280();
char sub_100234A0();
char sub_100236A0();
char sub_10023820();
char sub_100239A0();
char sub_10023B10();
char sub_10023C10();
char sub_10023D70();
char sub_10023ED0();
char sub_10024030();
char sub_100241A0();
char sub_10024300();
char sub_10024460();
char sub_10024680();
char sub_100247E0();
char sub_10024940();
char sub_10024AA0();
char sub_10024C10();
char sub_10024D70();
char sub_10024ED0();
char sub_100250F0();
char sub_100252F0();
char sub_10025470();
char sub_100255F0();
char sub_10025760();
char sub_10025850();
char sub_100259B0();
char sub_10025B10();
char sub_10025C70();
char sub_10025DE0();
char sub_10025F40();
char sub_100260A0();
char sub_100262A0();
char sub_10026400();
char sub_10026560();
char sub_100266C0();
char sub_10026830();
char sub_10026990();
char sub_10026AF0();
char sub_10027090();
char sub_100272A0();
char sub_10027490();
char sub_10027600();
char sub_10027770();
char sub_100278D0();
char sub_100279C0();
char sub_10027B20();
char sub_10027C80();
char sub_10027DE0();
char sub_10027F50();
char sub_100280B0();
char sub_10028210();
char sub_10028410();
char sub_10028570();
char sub_100286D0();
char sub_10028830();
char sub_100289A0();
char sub_10028B00();
char sub_10028C60();
char sub_10028E70();
char sub_10029060();
char sub_100291D0();
char sub_10029340();
char sub_100294A0();
char sub_10029590();
char sub_100296F0();
char sub_10029850();
char sub_100299B0();
char sub_10029B20();
char sub_10029C80();
char sub_10029DE0();
char sub_10029FE0();
char sub_1002A140();
char sub_1002A2A0();
char sub_1002A400();
char sub_1002A570();
char sub_1002A6D0();
char **sub_1002A830();
char __cdecl sub_1002A840(void *a1);
char __cdecl sub_1002A850(void *a1);
BOOL sub_1002A860();
// int __usercall sub_1002A890@<eax>(char a1@<al>, int a2@<ecx>);
char __cdecl sub_1002A8C0(void *a1);
char __cdecl sub_1002A920(void *a1);
char __thiscall sub_1002A980(void *this);
char __thiscall sub_1002A9E0(void *this);
char __cdecl sub_1002AA50(char a1, char a2, int *a3);
char __cdecl sub_1002AC00(char a1, int *a2, char a3);
char __cdecl sub_1002AC70(char a1, int *a2);
int __cdecl sub_1002ACA0(int *a1, int a2);
char __cdecl sub_1002ACC0(unsigned __int16 a1);
char __cdecl sub_1002AD60(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_1002AE70(char a1);
BOOL __cdecl sub_1002AEC0(char a1, int a2);
char __thiscall sub_1002AF30(void *this);
int __cdecl sub_1002AF60(char a1, int a2, int *a3);
int __cdecl sub_1002B060(char a1, int a2);
int __cdecl sub_1002B0D0(int a1);
int __cdecl sub_1002B0F0(signed int a1, char a2);
char __cdecl sub_1002B2B0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_1002B310(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
signed int sub_1002B380();
int sub_1002B3A0();
BOOL __cdecl sub_1002B3B0(unsigned int a1);
char __thiscall sub_1002B420(void *this);
void __cdecl sub_1002B440(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_1002B470(int a1);
signed int sub_1002B490();
void __cdecl sub_1002B4C0(_BYTE *a1);
char __cdecl sub_1002B4E0(int a1, size_t a2, void *a3);
int __cdecl sub_1002B520(int a1);
char __fastcall sub_1002B540(int *a1);
char sub_1002B760();
void sub_1002B780();
int __cdecl sub_1002B790(char, int, __int16, __int16, void *); // idb
signed int sub_1002B7A0();
int sub_1002B7B0();
int sub_1002B7C0();
void sub_1002B7E0();
double __cdecl sub_1002B7F0(_DWORD);
int sub_1002B800();
char sub_1002B830();
void sub_1002B8D0();
char __cdecl sub_1002B8E0(unsigned __int8 a1);
signed int sub_1002B940();
// char __usercall sub_1002B950@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_1002BA30(int a1, char a2, void *a3);
char __cdecl sub_1002BAB0(int a1, void *a2);
signed int __cdecl sub_1002BAD0(int a1);
double __cdecl sub_1002BAF0(signed int a1, char a2);
bool __cdecl sub_1002BB30(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_1002BB70(unsigned __int16 a1);
_BYTE *__cdecl sub_1002BBA0(_BYTE *a1);
char __cdecl sub_1002BBD0(_BYTE *a1, _BYTE *a2);
char __cdecl sub_1002BC20(_BYTE *a1, _BYTE *a2);
unsigned int sub_1002BC70();
__int16 sub_1002BD40();
// int __usercall sub_1002BDA0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
char sub_1002BE20();
int (__cdecl *(*sub_1002BFE0())[2])(int, int);
void __cdecl sub_1002C110(int a1);
signed int __cdecl sub_1002C210(int a1, int a2);
double __cdecl sub_1002C2B0(_DWORD); // weak
bool sub_1002C2C0();
bool sub_1002C2D0();
int __cdecl sub_1002C2F0(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C320(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C350(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C380(unsigned __int8 *a1, int a2);
signed int __cdecl sub_1002C3B0(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C3E0(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C410(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C440(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C470(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C4A0(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C4D0(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C500(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C530(unsigned __int8 *a1);
int __cdecl sub_1002C550(unsigned __int8 *a1, int a2);
int __cdecl sub_1002C580(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_1002C5B0(char *a1);
int __cdecl sub_1002C5D0(unsigned __int8 *a1);
int __cdecl sub_1002C5F0(_BYTE *a1);
int __cdecl sub_1002C610(unsigned __int8 *a1);
int __cdecl sub_1002C630(_BYTE *a1, int a2);
int __cdecl sub_1002C660(_BYTE *a1, int a2);
int __cdecl sub_1002C690(unsigned __int8 *a1, int a2);
unsigned int __cdecl sub_1002C6C0(int a1, int a2);
unsigned int __cdecl sub_1002C9F0(int a1, int a2);
unsigned int __cdecl sub_1002CE30(_BYTE *a1);
int __cdecl sub_1002CE50(unsigned __int8 *a1);
int __cdecl sub_1002CE70(unsigned __int8 *a1);
int __cdecl sub_1002CE90(_BYTE *a1);
int __cdecl sub_1002CEB0(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_1002CF00(unsigned __int8 *a1);
int __cdecl sub_1002CF20(int a1);
unsigned int __cdecl sub_1002CFB0(int a1);
signed int __cdecl sub_1002CFD0(int a1);
unsigned int __cdecl sub_1002D020(int a1);
int __cdecl sub_1002D080(_BYTE *a1);
unsigned int __cdecl sub_1002D0A0(_BYTE *a1);
int __cdecl sub_1002D0C0(unsigned __int8 *a1);
int __cdecl sub_1002D0E0(_BYTE *a1);
signed int __cdecl sub_1002D100(_BYTE *a1, int a2);
int __cdecl sub_1002D130(_BYTE *a1);
int __cdecl sub_1002D150(_BYTE *a1, int a2);
signed int __cdecl sub_1002D190(_BYTE *a1, int a2);
int __cdecl sub_1002D1C0(int a1, int a2);
int __cdecl sub_1002D250(int a1);
int __cdecl sub_1002D280(unsigned __int8 *a1);
unsigned int __cdecl sub_1002D2A0(int a1);
int __cdecl sub_1002D2D0(int a1);
int __cdecl sub_1002D3C0(int a1);
int __cdecl sub_1002D4D0(int a1);
signed int __cdecl sub_1002D500(int a1, int a2);
int __cdecl sub_1002DA10(_BYTE *a1, int a2);
signed int __cdecl sub_1002DA40(_BYTE *a1, int a2);
int __cdecl sub_1002DAB0(unsigned __int8 *a1);
int __cdecl sub_1002DB10(int a1);
int __cdecl sub_1002DB20(unsigned __int8 *a1, int a2);
int __cdecl sub_1002DB50(unsigned __int8 *a1, int a2);
int __cdecl sub_1002DB80(unsigned __int8 *a1, int a2);
signed int __cdecl sub_1002DBB0(_BYTE *a1, int a2);
int __cdecl sub_1002DBE0(int a1, int a2);
int __cdecl sub_1002DC80(int a1);
_DWORD __cdecl sub_1002DD00(_DWORD); // weak
int __cdecl sub_1002DD10(int a1);
unsigned int __cdecl sub_1002DD90(int a1);
unsigned int __cdecl sub_1002DDD0(int a1);
int __cdecl sub_1002DE20(int a1);
int __cdecl sub_1002DE50(int a1);
unsigned int __cdecl sub_1002DE80(int a1);
unsigned int __cdecl sub_1002DEB0(int a1);
unsigned int __cdecl sub_1002DED0(int a1);
void __cdecl __noreturn sub_1002DF10(int a1);
signed int __cdecl sub_1002E080(int a1, int a2);
int __cdecl sub_1002E0D0(int a1, int a2);
int __cdecl sub_1002E120(_BYTE *a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// int __usercall sub_1002E140@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>);
// signed int __usercall sub_1002E190@<eax>(int a1@<eax>, int a2@<edi>);
// int __usercall sub_1002E260@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>);
int __cdecl sub_1002E350(unsigned __int8 *a1);
int __cdecl sub_1002E360(unsigned __int8 *a1);
signed int __cdecl sub_1002E370(int a1);
char __cdecl sub_1002E380(char a1);
int __cdecl sub_1002E3C0(char *a1, char a2);
bool __cdecl sub_1002E430(int a1, void *a2);
char __cdecl sub_1002E4F0(int a1, bool *a2);
char __thiscall sub_1002E5B0(void *this);
char __cdecl sub_1002E640(char a1);
char __cdecl sub_1002E6B0(int a1, char a2);
char __cdecl sub_1002E770(int a1, char a2);
char __cdecl sub_1002E830(char a1);
char __cdecl sub_1002E860(char a1);
char __cdecl sub_1002E890(char a1);
char __thiscall sub_1002E8C0(void *this);
char __cdecl sub_1002E8D0(char a1, void *a2);
char __cdecl sub_1002E980(char a1);
char __cdecl sub_1002E9E0(int a1, int a2);
char __cdecl sub_1002EB00(int a1);
char __cdecl sub_1002EB10(int a1);
int __cdecl sub_1002EB20(char a1);
// int __usercall sub_1002EB30@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_1002EB40@<al>(char a1@<bl>, char a2);
char __cdecl sub_1002EC00(char a1, char a2);
int __cdecl sub_1002EC20(void *, void *, size_t, int, int); // idb
int __cdecl sub_1002ECD0(unsigned __int16 a1);
// int __usercall sub_1002ED10@<eax>(unsigned __int16 a1@<di>);
int __cdecl sub_1002ED50(unsigned __int16 a1);
bool __cdecl sub_1002ED80(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_1002EE10(char a1, char a2, void *a3);
bool __cdecl sub_1002EE90(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
signed int sub_1002EF30();
char __cdecl sub_1002EF40(void *a1);
bool sub_1002EF90();
char __cdecl sub_1002EFD0(char a1);
char __cdecl sub_1002F050(unsigned __int16 a1, _WORD *a2);
char __cdecl sub_1002F0B0(char a1, int a2);
// int __usercall sub_1002F220@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_1002F260@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_1002F2A0();
char __cdecl sub_1002F2B0(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_1002F310(char a1, void *a2);
char __cdecl sub_1002F430(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1002F4B0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
double __cdecl sub_1002F660(int a1);
// char __usercall sub_1002F6B0@<al>(void *a1@<esi>);
// char __usercall sub_1002F6F0@<al>(float *a1@<esi>);
char __cdecl sub_1002F710(float *a1);
char __cdecl sub_1002F770(float *a1);
char __cdecl sub_1002F7D0(float *a1);
// char __usercall sub_1002F830@<al>(int a1@<esi>);
char __cdecl sub_1002F8D0(float *a1);
char __cdecl sub_1002F920(float *a1);
char __cdecl sub_1002F970(float *a1);
char __cdecl sub_1002F9D0(float *a1);
// char __usercall sub_1002FA30@<al>(float *a1@<esi>, char a2);
char __cdecl sub_1002FB20(float a1, int a2);
// char __usercall sub_1002FB90@<al>(float *a1@<esi>);
char __cdecl sub_1002FC10(float *a1);
char __cdecl sub_1002FC70(float *a1);
char __cdecl sub_1002FD00(float *a1);
// char __usercall sub_1002FD90@<al>(float *a1@<esi>);
// char __usercall sub_10030130@<al>(float *a1@<esi>);
// char __usercall sub_100301A0@<al>(float *a1@<esi>);
// char __usercall sub_100301C0@<al>(float *a1@<esi>);
// void __usercall sub_10030250(float *a1@<esi>);
char __cdecl sub_100302E0(float *a1);
// char __usercall sub_10030400@<al>(float *a1@<esi>, float a2);
// char __usercall sub_10030600@<al>(float *a1@<esi>, float a2);
// char __usercall sub_10030690@<al>(float *a1@<eax>);
// char __usercall sub_100306A0@<al>(float *a1@<eax>);
// char __usercall sub_100306B0@<al>(float *a1@<eax>);
// char __usercall sub_100306C0@<al>(float *a1@<eax>);
// int __usercall sub_100306D0@<eax>(char a1@<dl>, int a2@<ecx>, float *a3);
// char __usercall sub_10030700@<al>(float *a1@<esi>);
// char __usercall sub_100307A0@<al>(float *a1@<esi>);
char __cdecl sub_10030880(float *a1);
// char __usercall sub_100308D0@<al>(float *a1@<esi>);
// char __usercall sub_100309B0@<al>(float *a1@<esi>);
// char __usercall sub_10030A90@<al>(float *a1@<esi>);
// char __usercall sub_10030B30@<al>(float *a1@<esi>);
// char __usercall sub_10030BD0@<al>(float *a1@<esi>);
// char __usercall sub_10030C70@<al>(float *a1@<esi>);
char __cdecl sub_10030D50(float *a1);
bool __cdecl sub_10030DF0(float *a1);
// char __usercall sub_10030EA0@<al>(float *a1@<esi>);
// char __usercall sub_10030F20@<al>(float *a1@<esi>);
// char __usercall sub_10030FB0@<al>(float *a1@<esi>);
int __cdecl sub_10031020(float *a1);
int __cdecl sub_10031250(float *a1);
int __cdecl sub_10031480(float *a1);
int __cdecl sub_100316B0(float *a1);
// char __usercall sub_100318E0@<al>(float *a1@<esi>);
// char __usercall sub_10031970@<al>(float *a1@<esi>);
bool __cdecl sub_100319E0(float *a1);
char __cdecl sub_10031A40(float a1, void *a2);
int __cdecl sub_100322F0(int a1);
char __cdecl sub_10032330(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
signed int __cdecl sub_10032390(char a1, char a2);
int __cdecl sub_100323F0(char a1);
signed int __cdecl sub_10032430(char a1, char a2, char a3);
int __cdecl sub_100324A0(char a1);
int __cdecl sub_100324E0(char a1);
char __cdecl sub_10032520(char a1, int a2);
char __cdecl sub_10032540(char a1, int a2);
char __cdecl sub_10032570(char a1, int a2);
char __cdecl sub_100325C0(char a1, int a2);
char __cdecl sub_100325F0(char a1, int a2);
char __cdecl sub_10032610(int a1);
int __cdecl sub_10032630(_BYTE *a1);
int __cdecl sub_10032650(unsigned __int8 *a1);
int __cdecl sub_10032670(unsigned __int8 *a1);
int __cdecl sub_10032690(unsigned __int8 *a1);
int __cdecl sub_100326B0(unsigned __int8 *a1);
_DWORD __cdecl sub_100326D0(_DWORD); // weak
int __cdecl sub_100326E0(int a1);
int __cdecl sub_10032720(int a1);
signed int __fastcall sub_10032740(unsigned __int8 a1);
char __cdecl sub_10032750(unsigned __int8 a1);
__int16 __cdecl sub_10032770(unsigned __int8 a1);
int __cdecl sub_10032790(char a1);
char __cdecl sub_100327E0(int a1, int a2, int a3, int a4, int a5, int a6);
char sub_10032850();
BOOL __cdecl sub_100328F0(int a1, int a2);
char __cdecl sub_10032910(int a1, char a2, int a3, int a4, int a5);
char *__cdecl sub_10032950(char **a1);
int sub_100329A0();
int __cdecl sub_100329E0(_BYTE *a1, int a2);
signed int __cdecl sub_10032A50(_BYTE *a1, int a2);
// int __usercall sub_10032AF0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10032B20@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10032CF0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// unsigned int __usercall sub_10032D50@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10032DE0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10032E30@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10032E90@<eax>(int a1@<eax>);
// int __usercall sub_10032EB0@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10032EF0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10032F80@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_100330D0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10033170@<eax>(int result@<eax>);
char *__cdecl sub_100331B0(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10033360@<eax>(int a1@<eax>);
// int __usercall sub_10033390@<eax>(int a1@<esi>);
void __cdecl sub_100333C0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10033830();
void *sub_10033880();
char *sub_100338E0();
char sub_10033900();
char __cdecl sub_10033910(int a1, int a2, unsigned int a3);
// int *__usercall sub_10033950@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_100339A0();
int __cdecl sub_100339B0(_DWORD *a1, int a2, int a3);
int __cdecl sub_10033A60(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10033C70@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10033D30(char a1);
int *__cdecl sub_10033DD0(_BYTE *a1);
// int __usercall sub_10033E90@<eax>(int a1@<eax>);
// signed int __usercall sub_10033FF0@<eax>(int a1@<esi>);
int __cdecl sub_10034060(int, int); // weak
char **sub_10034340();
// int __usercall sub_10034350@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_10034440(char *a1);
int sub_10034680();
int __cdecl sub_10034760(int a1, int a2, char a3);
int __cdecl sub_100347B0(int a1);
int __cdecl sub_100347C0(void *); // idb
int __cdecl sub_10034840(int a1, int a2);
signed int __cdecl sub_10034870(int a1, int a2, int a3);
char __cdecl sub_10034890(_DWORD *a1);
char __cdecl sub_100349A0(int a1, unsigned int a2);
bool __cdecl sub_100349D0(const void **a1, int a2);
bool __cdecl sub_10034A00(const void **a1, int a2);
bool __cdecl sub_10034A30(const void **a1, int a2);
bool __cdecl sub_10034A60(const void **a1, int a2);
bool __cdecl sub_10034A90(const void **a1, int a2);
bool __cdecl sub_10034AC0(int a1, int a2);
bool __cdecl sub_10034B00(int a1, int a2);
bool __cdecl sub_10034B40(const void **a1, int a2);
bool __cdecl sub_10034B70(const void **a1, int a2);
char __cdecl sub_10034BA0(int a1, unsigned int a2);
bool __cdecl sub_10034BD0(const void **a1, int a2);
bool __cdecl sub_10034C00(const void **a1, int a2);
bool __cdecl sub_10034C30(const void **a1, int a2);
bool __cdecl sub_10034C60(const void **a1, int a2);
bool __cdecl sub_10034C90(const void **a1, int a2);
bool __cdecl sub_10034CC0(const void **a1, int a2);
bool __cdecl sub_10034CF0(const void **a1, int a2);
bool __cdecl sub_10034D20(const void **a1, int a2);
bool __cdecl sub_10034D50(const void **a1, int a2);
bool __cdecl sub_10034D80(const void **a1, int a2);
int __cdecl sub_10034DB0(int a1, int a2, int a3);
// void __cdecl __noreturn exit_0(int);
int __cdecl sub_10034E20(int a1, char a2);
int __cdecl sub_10034E40(int a1, int a2, int a3);
int __cdecl sub_10034E70(int a1, int a2, int a3, int a4);
int __cdecl sub_10034EA0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10034EE0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10034F20(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_10034F70(int a1);
char __cdecl sub_10034FA0(int a1);
char __cdecl sub_10034FB0(int a1, int a2);
signed int __cdecl sub_10035130(int a1);
signed int __cdecl sub_10035170(int a1, int a2, int a3);
char __cdecl sub_10035210(int a1);
// char __usercall sub_10035270@<al>(int a1@<edx>, int a2, void (__cdecl *a3)(int));
char *__cdecl sub_100352E0(char *a1);
int __cdecl sub_10035380(int a1, int a2, int a3);
bool __cdecl sub_100353F0(int a1, unsigned int a2, int a3);
char __cdecl sub_10035480(int a1, int a2, char a3, char a4);
char __cdecl sub_10035530(int a1);
// char __usercall sub_10035540@<al>(int a1@<edx>, int a2, void (__cdecl *a3)(int));
int (__cdecl *__cdecl sub_100355C0(int a1, const char *a2))(const char *);
// signed int __usercall sub_10035610@<eax>(int a1@<edx>, int a2, void (__cdecl *a3)(int));
const char *__cdecl sub_10035660(int a1, int a2);
char __cdecl sub_100356A0(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_10036450(int a1, int a2);
char **__cdecl sub_100364D0(int a1);
int (__cdecl *__cdecl sub_10036510(const char *a1))(const char *);
const char *sub_10036530();
__int64 sub_10036540();
const char *sub_10036550();
// int __usercall sub_10036560@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_100365B0(int a1, int a2);
int (__cdecl *__cdecl sub_100365E0(_DWORD *a1))(int);
// int __usercall sub_10036700@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10036A80(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_100378A0(int a1);
char __thiscall sub_10037910(void *this);
// char __usercall sub_10037980@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_100379C0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10037A60(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10037AA0(char a1, char a2, void *a3);
char __cdecl sub_10037B00(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10037B40(char a1, char a2, void *a3);
char __cdecl sub_10037B70(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10037BB0(char a1, char a2, void *a3);
char __cdecl sub_10037BF0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10037C30(char a1, char a2, void *a3);
char __cdecl sub_10037C80(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10037CC0(char a1, char a2, void *a3);
char __cdecl sub_10037D00(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10037D40(char a1, char a2, void *a3);
char __cdecl sub_10037D80(char a1, void *a2);
char __cdecl sub_10037DB0(char a1, void *a2);
char __cdecl sub_10037DE0(char a1, void *a2);
char __cdecl sub_10037E10(char a1, void *a2);
char __cdecl sub_10037E40(char a1, void *a2);
char __cdecl sub_10037E70(char a1, void *a2);
char __cdecl sub_10037EA0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10037EE0(char a1, char a2, void *a3);
char __cdecl sub_10037F30(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10037F70(char a1, char a2, void *a3);
char __cdecl sub_10037FA0(char a1, void *a2);
char __cdecl sub_10037FD0(char a1, void *a2);
char __cdecl sub_10038000(char a1, void *a2);
char __cdecl sub_10038030(int a1, char a2, char a3, int a4, void *a5);
bool __cdecl sub_100383D0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10038440(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100384A0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10038510(char a1, _BYTE *a2);
char __thiscall sub_10038550(void *this);
char __cdecl sub_100385C0(char a1, int a2);
char __cdecl sub_100385F0(char a1, int a2);
char __cdecl sub_10038620(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
char __cdecl sub_100387F0(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_10038830(const char *a1, int a2);
// char *__usercall sub_100388A0@<eax>(char *result@<eax>);
void __cdecl sub_100388D0(char *a1);
void __cdecl sub_10038990(char *a1, char *a2);
void *__cdecl sub_100389F0(int a1);
int sub_10038B80();
void __cdecl sub_10038B90(int a1);
int __cdecl sub_10038BC0(int a1);
bool __cdecl sub_10038BE0(int a1);
void *__cdecl sub_10038C10(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_10038C50@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_10038C70@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_10038C90(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_10038CC0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_10038DA0(int a1, int a2, int a3);
// void *__usercall sub_10038E50@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_100390D0(int a1, int a2);
char __cdecl sub_100391A0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_10039210@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_10039570@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_10039680(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_10039810(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_10039960@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_10039AB0(int a1, int a2);
// BOOL __usercall sub_10039AF0@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3);
BOOL __cdecl sub_10039B10(int a1);
_DWORD __cdecl sub_10039B30(_DWORD); // weak
unsigned int __cdecl sub_10039B40(int a1, char a2);
signed int __cdecl sub_10039BA0(void *a1, int a2, unsigned int a3);
int __cdecl sub_10039BC0(int a1, int a2, int a3);
char __cdecl sub_10039BE0(const char *a1, const char *a2);
int __cdecl sub_10039D20(int a1, int a2, unsigned int a3);
char __cdecl sub_10039DA0(_DWORD *a1);
int __cdecl sub_10039E10(char a1, char a2);
// bool __usercall sub_10039EC0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_10039EF0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_10039F90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003A010(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003A090(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003A110(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1003A190(char a1);
char __cdecl sub_1003A230(char a1, void *a2);
char __cdecl sub_1003A290(char a1, void *a2);
bool __cdecl sub_1003A2E0(void *a1);
int __cdecl sub_1003A320(char a1);
char __cdecl sub_1003A370(char a1);
char __cdecl sub_1003A3A0(char a1, void *a2);
int __cdecl sub_1003A420(char a1, _DWORD *a2);
int __cdecl sub_1003A470(char a1);
_DWORD __cdecl sub_1003A4A0(char); // weak
char __cdecl sub_1003A4B0(int a1, int a2);
char __cdecl sub_1003A500(int a1, int a2);
char __cdecl sub_1003A5B0(int a1, int a2);
char __cdecl sub_1003A610(int a1, int a2);
int __cdecl sub_1003A6E0(unsigned __int8 *a1);
signed int __cdecl sub_1003A700(void *a1);
signed int __cdecl sub_1003A720(void *a1);
signed int __cdecl sub_1003A740(void *a1);
signed int __cdecl sub_1003A760(void *a1);
signed int __cdecl sub_1003A780(void *a1);
int __cdecl sub_1003A7A0(int a1);
signed int __cdecl sub_1003A7F0(_BYTE *a1, int a2);
int __cdecl sub_1003A820(void *); // idb
signed int __cdecl sub_1003A8F0(void *a1);
int __cdecl sub_1003A950(_BYTE *a1);
signed int __cdecl sub_1003A970(_BYTE *a1, int a2);
signed int __cdecl sub_1003A9A0(unsigned __int8 *a1, int a2);
int __cdecl sub_1003A9D0(unsigned __int8 *a1, int a2);
int __cdecl sub_1003AA00(unsigned __int8 *a1);
int __cdecl sub_1003AA20(unsigned __int8 *a1, int a2);
int __cdecl sub_1003AA50(unsigned __int8 *a1);
// signed int __usercall sub_1003AA70@<eax>(void *a1@<eax>, int a2@<esi>);
signed int __cdecl sub_1003ABD0(void *a1, int a2);
char sub_1003ABE0();
int __cdecl sub_1003ABF0(char a1, char *a2);
int __cdecl sub_1003AC40(char, float, int, int, int); // idb
double sub_1003B290();
double __cdecl sub_1003B2C0(int a1, float a2, float a3);
char __cdecl sub_1003B300(float *a1, float *a2, float *a3, char a4);
int __cdecl sub_1003B890(char a1);
int __cdecl sub_1003B8B0(int, void *); // idb
// int __usercall sub_1003B910@<eax>(char a1@<al>);
BOOL __cdecl sub_1003B940(char a1, int a2);
int __cdecl sub_1003B970(int, char, int, int, void *); // idb
char __cdecl sub_1003B9A0(void *a1);
BOOL __cdecl sub_1003B9C0(int a1);
char __cdecl sub_1003B9E0(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_1003BA10(char a1, void *a2);
// signed int __usercall sub_1003BA50@<eax>(char a1@<al>);
bool __cdecl sub_1003BA70(char a1, void *a2);
bool __cdecl sub_1003BB60(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_1003BB90(unsigned __int8 a1);
// BOOL __usercall sub_1003BBA0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_1003BBD0(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_1003BD80(unsigned __int8 a1, int a2);
bool __cdecl sub_1003BDC0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char __cdecl sub_1003BEB0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_1003BF50(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003BFD0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003C040(char a1, void *a2);
char __cdecl sub_1003C0C0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003C140(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003C1C0(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_1003C230(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_1003C340(char a1, void *a2);
bool __cdecl sub_1003C360(unsigned __int8 a1, char *a2);
char __cdecl sub_1003C3A0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_1003C3E0();
char __cdecl sub_1003C440(int a1, char *a2);
BOOL __cdecl sub_1003C530(int a1, int a2);
char __cdecl sub_1003C550(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_1003C590(int a1, int a2);
BOOL __cdecl sub_1003C640(int a1, int a2);
char __cdecl sub_1003C660(int a1, char a2, int a3, int a4, int a5);
char __cdecl sub_1003C6A0(void *a1);
char __cdecl sub_1003C6C0(void *a1);
char __cdecl sub_1003C810(int a1, char a2, char a3, int a4, void *a5, size_t a6);
char __cdecl sub_1003C9B0(char a1);
// __int16 __usercall sub_1003C9F0@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1003CA00(unsigned __int8 a1, char *a2);
char __cdecl sub_1003CAD0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_1003CB50(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_1003CC80(char a1, int a2);
bool __cdecl sub_1003CD00(void *a1);
char __cdecl sub_1003CD50(char a1, int a2);
// __int16 __usercall sub_1003CE30@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_1003CE40(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_1003CED0(unsigned __int8 a1, char a2);
bool __cdecl sub_1003CF90(__int16 a1, char a2, int a3, int a4, void *a5);
int __cdecl sub_1003D090(int a1);
int __cdecl sub_1003D0A0(int a1, int a2);
// char __usercall sub_1003D1E0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_1003D2B0(_DWORD *a1, char *a2);
int __cdecl sub_1003D390(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_1003D3B0@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_1003D3C0@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_1003D5F0(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1003D640(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1003D690(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_1003D6E0(int a1))(int);
int __cdecl sub_1003D760(int a1, int a2);
int (__cdecl *__cdecl sub_1003D7E0(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_1003D830(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1003D870(int a1, int a2, int a3))(int);
int __cdecl sub_1003D8D0(_BYTE *a1, int a2);
double __cdecl sub_1003D900(float a1);
char __cdecl sub_1003D980(char a1);
char __cdecl sub_1003D9C0(char a1);
void __cdecl sub_1003D9E0(int a1, int a2, int a3, float *a4, int a5);
void __cdecl sub_1003DB10(int a1, int a2, int a3, int a4, int a5, float a6);
void __cdecl sub_1003DB80(int a1, _BYTE *a2);
int __cdecl sub_1003DBB0(int a1, int a2);
int __cdecl sub_1003DBD0(int a1);
int sub_1003DBF0();
int __cdecl sub_1003DC10(int a1, int a2);
__int16 __cdecl sub_1003DC40(int a1);
int __cdecl sub_1003DC60(int a1, int a2);
int sub_1003DC90();
int __cdecl sub_1003DCB0(int a1, int a2, int a3, int a4);
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_1003DCF0(int a1, int a2, int a3, int a4);
int __cdecl sub_1003DD20(int a1);
double __cdecl sub_1003DD40(_DWORD); // weak
signed int __cdecl sub_1003DD60(int a1, int a2);
int __cdecl sub_1003DDA0(int a1, int a2);
int __cdecl sub_1003DDD0(int a1, int a2);
int __cdecl sub_1003DE00(int a1, int a2);
signed int __cdecl sub_1003DE30(int a1, int a2);
int __cdecl sub_1003DE80(int a1);
char __cdecl sub_1003DEA0(int a1, int a2);
int __cdecl sub_1003DF10(_BYTE *a1);
int __cdecl sub_1003DF50(int a1, int a2);
int __cdecl sub_1003DF80(int a1, int a2);
bool __cdecl sub_1003DFA0(int a1);
int __cdecl sub_1003DFC0(int a1);
int __cdecl sub_1003E000(int a1, int a2, int a3);
int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_reg_get_tag_info(_DWORD, _DWORD); // weak
int __cdecl sub_1003E040(int a1, int a2, int a3);
char __cdecl sub_1003E060(int a1, int a2, int a3);
int __cdecl sub_1003E0A0(int, void *, int, void *); // idb
int __cdecl sub_1003E0E0(int a1, int a2, int a3);
int __cdecl sub_1003E110(int a1, int a2, int a3);
int __cdecl sub_1003E130(int a1, int a2, int a3);
int __cdecl sub_1003E190(int a1, int a2, int a3);
char __cdecl sub_1003E1D0(int a1, int a2, int a3);
int __cdecl sub_1003E210(int a1, unsigned __int8 a2);
int __cdecl sub_1003E2F0(int, void *, int, void *); // idb
int j_HWM_pvg_hsdb_get_lrus_online();
int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int __cdecl j_HWM_pvg_wait_for_power(_DWORD, _DWORD); // weak
int __fastcall j_FIL_vfs_clean_invalidate_cache(_DWORD, _DWORD); // weak
signed int __cdecl sub_1003E3A0(unsigned int a1);
signed int __cdecl sub_1003E3E0(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1003E430(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD);
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_1003E4B0(unsigned int a1, void *a2, int a3);
int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_1003E500(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_rmdir(_DWORD); // weak
signed int __cdecl sub_1003E5A0(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_1003E5F0(int a1);
int __cdecl sub_1003E610(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_1003E640(int a1, int a2, int a3, char a4);
char __cdecl sub_1003E660(int a1);
char __cdecl sub_1003E690(int a1);
int __cdecl sub_1003E6C0(unsigned int a1, unsigned int a2);
int __cdecl sub_1003E710(int a1, int a2, int a3);
signed int __cdecl sub_1003E730(unsigned int a1, int a2, int a3);
int __cdecl sub_1003E750(int a1, int a2, int a3);
int __cdecl sub_1003E770(const char *a1);
int __cdecl sub_1003E940(int a1, unsigned int a2);
int __cdecl sub_1003E970(int a1, int a2);
signed int __cdecl sub_1003E9D0(int a1);
// unsigned int __usercall sub_1003EA50@<eax>(const char **a1@<esi>);
// int __usercall sub_1003ED50@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_1003ED70(int a1);
unsigned int __cdecl sub_1003EE40(LONG Value);
int sub_1003EED0(void); // weak
__int16 __cdecl sub_1003EEE0(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_1003EF20(int a1, _DWORD *a2, _BYTE *a3);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_1003EFC0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_1003F010(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int __cdecl sub_1003F080(int a1);
int __cdecl sub_1003F0C0(int a1);
int __cdecl sub_1003F100(int a1);
int __cdecl sub_1003F140(int a1);
int __cdecl sub_1003F180(int a1, int a2, int a3, int a4);
int __cdecl sub_1003F1F0(int a1, int a2, int a3);
void __cdecl sub_1003F290(__int16 a1, _BYTE *a2);
int sub_1003F2C0(void); // weak
int __cdecl sub_1003F2D0(int, void *); // idb
unsigned int __cdecl sub_1003F590(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_1003F740@<eax>(int a1@<esi>);
int __cdecl sub_1003F7F0(int a1, unsigned __int64 a2);
// int __usercall sub_1003F8A0@<eax>(int a1@<ebx>, unsigned __int64 a2);
int __cdecl sub_1003F930(int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
int __cdecl sub_1003FA90(float, float, float); // idb
double __cdecl sub_1003FAE0(char a1);
signed int __cdecl sub_1003FB70(char a1);
signed int sub_1003FB90();
char __cdecl sub_1003FBB0(float *a1);
bool __cdecl sub_1003FD20(float *a1, float *a2, float *a3, _BYTE *a4, _BYTE *a5, _BYTE *a6);
char __cdecl sub_1003FEA0(int a1);
char __cdecl sub_1003FEF0(char a1);
char __cdecl sub_10040000(char a1, char a2, float *a3);
char __cdecl sub_10040140(char a1, float *a2);
bool __cdecl sub_10040290(float *a1, _BYTE *a2);
char __cdecl sub_100402E0(void *a1);
char sub_10040330();
char __cdecl sub_10040380(int a1);
void __cdecl sub_100405D0(float *a1, float *a2, float *a3, int a4);
int __cdecl sub_10040630(float, float, int); // idb
void __cdecl sub_100407F0(int a1, int a2, float *a3, float *a4, float *a5);
void __cdecl sub_10040BC0(int a1, int a2, float *a3, float *a4);
double __cdecl sub_10040CA0(float a1);
void __cdecl sub_10040CD0(float *a1, float *a2, int a3);
double __cdecl sub_10040D90(int a1, int a2);
bool __cdecl sub_10040DB0(unsigned __int8 a1, float *a2);
int __cdecl sub_10040EB0(float, float); // idb
double __cdecl sub_10040F00(_BYTE *a1);
char __cdecl sub_10041040(float *a1);
char __cdecl sub_10041270(float *a1);
double __cdecl sub_100413E0(float a1);
char __cdecl sub_10041450(float *a1);
char __cdecl sub_100415F0(float *a1);
unsigned int __cdecl sub_100417A0(char a1, _BYTE *a2, float *a3);
double __cdecl sub_10041990(float a1, float a2);
int __cdecl sub_10041A30(signed int a1, signed int a2);
double __cdecl sub_10041A70(float a1, float a2);
double __cdecl sub_10041B10(double a1, double a2);
double __cdecl sub_10041B70(float a1, float a2);
void __cdecl sub_10041BF0(double a1);
double __cdecl sub_10041C10(float a1);
int __cdecl sub_10041C50(int a1, int a2);
double __cdecl sub_10041C70(float a1, float a2);
int __cdecl sub_10041CE0(float, int, int); // idb
int __cdecl sub_10041D00(int a1, int a2);
int __cdecl sub_10041D20(float); // idb
double __cdecl sub_10041D80(float a1);
double __cdecl sub_10041DD0(double a1, double a2);
double __cdecl sub_10041E40(float a1, float a2);
unsigned int __cdecl sub_10041ED0(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_10041EF0(unsigned int *a1, signed int a2, unsigned int a3);
int __cdecl sub_10042020(int a1, int a2, int a3);
int __cdecl sub_10042050(float, int, int); // idb
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int __cdecl SYS_exit_krnl();
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_alrt_get_hdr(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_get_hdr_text(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_acked(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_data(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_queued(_DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_queue(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_queue_flush(_DWORD); weak
// int __cdecl SYS_pvg_alrt_set(_DWORD); weak
// int __cdecl SYS_pvg_trig_update(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_ack(_DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_clr(_DWORD); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int __cdecl TSK_pvg_get_smphr_stats(_DWORD, _DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reply_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_tag_dflt(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int HWM_pvg_hsdb_get_lrus_online(void); weak
// int FIL_vfs_close(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memset(void *, int, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10042AEC(int a1, int a2, char a3);
// char *__cdecl strstr(const char *, const char *);
// int __cdecl strncmp(const char *, const char *, size_t);
// int _snprintf(char *, size_t, const char *, ...);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isprint(int);
// char *__cdecl strchr(const char *, int);
// char *__cdecl strrchr(const char *, int);
// int sprintf(char *, const char *, ...);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// double __cdecl floor(double);
// char *__cdecl strncat(char *, const char *, size_t);
// char *__cdecl strpbrk(const char *, const char *);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
int __cdecl sub_10046CA4(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_10046EEA(FILE *, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_10047B37(int, FILE *); // idb
signed int __cdecl sub_10048775(_DWORD *a1);
signed int __cdecl sub_100487AC(_DWORD *a1);
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// void __cdecl free(void *);
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_100493F2();
int (*sub_1004989F())(void);
void __cdecl sub_100498C3(); // idb
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl isleadbyte(int);
int __cdecl sub_1004E87B(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_1004E921(int, int, struct localeinfo_struct *); // idb
// int _get_sse2_info(void); weak
int sub_1004EE42();
void sub_1004EE4F();
int __cdecl sub_1004F12C(FILE *); // idb
int __cdecl sub_1004F24C(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
// int __cdecl _fileno(FILE *);
signed int __cdecl sub_1004F4C1(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_1004F65D(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_1004FC7F(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1004FD9F(signed int a1);
void **sub_1004FDFD();
signed int sub_1004FE03();
int sub_100506B2();
int __cdecl sub_1005086F(int a1);
int __cdecl sub_10050879(int a1);
int __cdecl sub_10050883(int a1);
int __cdecl sub_10050962(int a1);
signed int __cdecl sub_10052039(int a1, int a2);
signed int __cdecl sub_1005257B(int a1, int a2);
int sub_10052EBC();
// int __cdecl _read(int, void *, unsigned int);
signed int __cdecl sub_10054A56(signed int a1);
signed int __cdecl sub_10054AD7(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_10054BE8(signed int a1);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// _DWORD __cdecl flsall(_DWORD); weak
int sub_10054EE9();
int __cdecl sub_10054EF2(int a1, int a2, int a3);
signed int __cdecl sub_10055641(signed int a1);
signed int __cdecl sub_10055820(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_10055880(unsigned int a1, int a2, int a3);
unsigned int __cdecl sub_100558A0(unsigned int a1);
bool __cdecl sub_100558C0(int a1);
int __cdecl sub_10055990(int a1);
int __cdecl sub_100559B0(int a1, int a2);
signed int __cdecl sub_100559F0(int a1, void *a2, unsigned __int16 a3, __int16 a4);
int __cdecl sub_10055AB0(int a1);
// int __usercall sub_10055AF0@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10055BA0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_10055D70@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_10055D80@<eax>(int result@<eax>);
// char __usercall sub_10055DA0@<al>(int a1@<eax>);
// unsigned int __usercall sub_10055DC0@<eax>(int a1@<esi>, unsigned __int8 a2);
int __fastcall sub_10055E00(int a1, int a2);
// int __usercall sub_10055E20@<eax>(int a1@<esi>);
// signed int __usercall sub_10055E60@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10056070(int a1);
signed int __cdecl sub_100562E0(unsigned int a1, int a2, int a3);
// unsigned int __usercall sub_10056380@<eax>(int a1@<eax>);
// unsigned int __usercall sub_100563A0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_100563D0@<eax>(int a1@<eax>, int a2@<ebx>);
// void __cdecl __noreturn exit_1(int);
// char __usercall sub_100564C0@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_100564F0@<eax>(int a1@<eax>);
signed int __cdecl sub_10056520(unsigned int a1);
signed int __cdecl sub_10056570(int a1, int a2);
signed int __cdecl sub_10056760(unsigned int a1, int a2, int a3);
signed int __cdecl sub_100567C0(unsigned int a1, int a2, int a3);
// signed int __usercall sub_10056950@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10057A00@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_10057A60@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_100587E0@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10058800(int a1, unsigned int a2);
// int __usercall sub_10058860@<eax>(int result@<eax>);
// int __usercall sub_100588A0@<eax>(int result@<eax>);
// unsigned int __usercall sub_10059FC0@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_1005A0C0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_1005A140@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_1005A1E0@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_1005A2A0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_1005A300@<eax>(char *a1@<edi>);
// int __usercall sub_1005A3C0@<eax>(int a1@<ebx>);
char __cdecl sub_1005A480(char *a1, size_t a2, int a3);
char __cdecl sub_1005A4D0(char *a1, unsigned int a2, int a3);
bool __cdecl sub_1005A520(int a1, int a2);
// unsigned int __usercall sub_1005A550@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_1005A760@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_1005A7B0(int a1, int a2);
signed int __cdecl sub_1005A840(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_1005A970(void *a1, int a2);
// BOOL __usercall sub_1005A9F0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1005AA90@<eax>(int result@<eax>);
unsigned int __fastcall sub_1005AB20(unsigned int a1, int a2);
// int __usercall sub_1005AB40@<eax>(int result@<eax>);
// int __usercall sub_1005ABD0@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_1005B050@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_1005B100@<eax>(int a1@<edi>);
// int __usercall sub_1005B160@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_1005B330@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_1005B3B0(int a1, int a2);
// unsigned int __usercall sub_1005B420@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_1005B5D0@<eax>(int a1@<esi>, int a2);
// int __usercall sub_1005B6A0@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_1005B750@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_1005B790@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_1005B7F0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1005B8D0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_1005BE70@<eax>(int a1@<eax>);
// int __usercall sub_1005C0B0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_1005C150@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_1005C330@<eax>(int a1@<edi>);
// int __usercall sub_1005C470@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_1005C720(int a1, int a2);
// signed int __usercall sub_1005C9E0@<eax>(int a1@<eax>);
// _WORD *__usercall sub_1005CAB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_1005CCD0(int a1, int a2);
signed int __cdecl sub_1005CFE0(int a1, int a2);
signed int __cdecl sub_1005D3F0(int a1, int a2);
_BYTE *__cdecl sub_1005D560(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_1005D660(int a1);
// signed int __usercall sub_1005D680@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_1005DB20@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_1005DB70@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_1005DB90(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1005DF40@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_1005E080@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_1005E0D0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_1005E170@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_1005E190(int a1);
// int __usercall sub_1005E1A0@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_1005E840@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_1005F220@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_1005F550(int a1, int a2);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);
// int HWM_pvg_hsdb_get_lrus_online(void); weak

//-------------------------------------------------------------------------
// Data declarations

char *off_10060E3C[3] = { "LOG_test.c", "$Id$", &off_10060E14 }; // weak
_UNKNOWN unk_10060EA8; // weak
__int16 word_10061658[] = { 1 }; // weak
int dword_10061664[] = { 4294967295 }; // weak
char byte_10062E54[] = { '\0' }; // weak
_UNKNOWN unk_10062E60; // weak
_UNKNOWN unk_10062E64; // weak
_UNKNOWN unk_100632A0; // weak
char aInactive_0[9] = "INACTIVE"; // weak
char byte_100632F4[] = { '\0' }; // weak
_UNKNOWN unk_10063AA0; // weak
_DWORD off_10063AA4[2] = { 268840424, 1 }; // idb
char byte_10063AF0[] = { '\0' }; // weak
_UNKNOWN unk_10063AF8; // weak
_DWORD off_10063AFC[2] = { 268840332, 1 }; // idb
_UNKNOWN unk_10063B28; // weak
_DWORD off_10063B2C[2] = { 268840332, 1 }; // idb
char byte_10063B48[] = { '\0' }; // weak
_UNKNOWN unk_10063B4C; // weak
_DWORD off_10063B50[2] = { 268840252, 1 }; // idb
_UNKNOWN unk_10063B64; // weak
_DWORD off_10063B68[2] = { 268840216, 1 }; // idb
_UNKNOWN unk_10063B7C; // weak
_DWORD off_10063B80[2] = { 268840192, 1 }; // idb
_UNKNOWN unk_10063BA4; // weak
char aInactive[9] = "INACTIVE"; // weak
int dword_10063BE8[] = { 0 }; // weak
double dbl_10063BEC[] = {  1.0 }; // weak
int dword_10063BF4[] = { 0 }; // weak
_UNKNOWN unk_10064668; // weak
_UNKNOWN unk_10064674; // weak
_UNKNOWN unk_100646D0; // weak
_UNKNOWN unk_100646E0; // weak
_UNKNOWN unk_100646E8; // weak
_UNKNOWN unk_100646E9; // weak
_UNKNOWN unk_10064710; // weak
int dword_10064714[] = { 4 }; // weak
_UNKNOWN unk_10064984; // weak
char *off_100652E0 = "/shr_mem/mon_log_intf.shr"; // weak
_UNKNOWN unk_10065FA8; // weak
_UNKNOWN unk_10065FAC; // weak
char *off_10066DB8[3] = { "mon_log_main.c", "$Id$", &off_10066D68 }; // weak
int (*off_10067620[3])() = { &sub_1002A830, &sub_1001E140, &sub_10001000 }; // weak
_UNKNOWN off_100680CC; // idb
_UNKNOWN off_10068144; // idb
_UNKNOWN unk_100681E0; // weak
_UNKNOWN unk_100681E1; // weak
_UNKNOWN unk_100681F0; // weak
_UNKNOWN unk_100681F4; // weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
char byte_1006A497[] = { '\x01' }; // weak
char *off_1006ABC4 = "/shr_mem/udb_intf.shr"; // weak
char byte_1006ABD8[] = { '\0' }; // weak
char byte_1006ABD9[] = { '\0' }; // weak
char byte_1006ABDA[] = { '\xFF' }; // weak
char byte_1006ABDB[] = { '\xFF' }; // weak
char byte_1006ABDC[] = { '\xFF' }; // weak
_UNKNOWN unk_1006B144; // weak
_UNKNOWN unk_1006B1B8; // weak
_UNKNOWN unk_1006B248; // weak
char byte_1006B798[] = { ' ' }; // weak
char byte_1006B7A0[] = { ' ' }; // weak
_UNKNOWN unk_1006B7A8; // weak
char byte_1006B7D8[] = { '\x05' }; // weak
char byte_1006B7DC[] = { '\b' }; // weak
int dword_1006B7E0[] = { 9 }; // weak
char aWgs84[21] = "WGS 84              "; // weak
_UNKNOWN unk_1006C380; // weak
int dword_1006F9BC[] = { 88 }; // weak
__int16 word_1006FE6C[] = { 836 }; // weak
char *off_1006FE8C = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1006FEA0 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1006FEB4 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1006FEC8 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1006FEDC = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1006FEF0 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
_UNKNOWN unk_10071918; // weak
_UNKNOWN unk_10071F80; // weak
_UNKNOWN unk_10071F88; // weak
char byte_10071F90[] = { '\x01' }; // weak
_UNKNOWN unk_10071FA0; // weak
_BYTE word_10071FA6[110] =
{
  169,
  63,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  74,
  75,
  76,
  77,
  80,
  81,
  82,
  83,
  0,
  0,
  93,
  0,
  90,
  0,
  87,
  0,
  96,
  0,
  1,
  0,
  94,
  0,
  91,
  0,
  88,
  0,
  97,
  0,
  2,
  0,
  95,
  0,
  92,
  0,
  89,
  0,
  98,
  0,
  0,
  0,
  0,
  0,
  226,
  0,
  228,
  0,
  224,
  0,
  1,
  0,
  227,
  0,
  229,
  0,
  225,
  0,
  2,
  0,
  60,
  2,
  61,
  2,
  59,
  2,
  0,
  0,
  220,
  0,
  1,
  0,
  222,
  0,
  2,
  0,
  58,
  2
}; // idb
__int16 word_10072060[] = { 100 }; // weak
_UNKNOWN unk_10072F10; // weak
__int16 word_10072F12[] = { 492 }; // weak
char byte_10072F20[] = { '@' }; // weak
char byte_10072F21[] = { '\x04' }; // weak
char *off_10073674 = "/shr_mem/iop_gma_dig_intf.shr"; // weak
char *off_100736C8 = "/shr_mem/pvt_intf.shr"; // weak
__int16 word_10077C8C[] = { 464 }; // weak
_UNKNOWN unk_1007937C; // weak
wchar_t a___0[8] = L":;<=>?@"; // weak
wchar_t aAbcde_0[6] = L"ABCDE"; // weak
int dword_1007AA80[] = { 9032 }; // weak
__int16 word_1007AB08[] = { 241 }; // weak
char *off_1007B358 = "/shr_mem/mon_log_intf.shr"; // weak
char *off_1007B36C = "/shr_mem/mon_main_intf.shr"; // weak
__int16 word_1007D760[] = { 0 }; // weak
__int16 word_1007D762[] = { 999 }; // weak
__int16 word_1007D764[] = { 1000 }; // weak
__int16 word_1007D766[] = { 1500 }; // weak
float flt_1007D768[] = {  3000.0 }; // weak
int dword_1007D784[] = { 14000 }; // weak
char aAhrs1Tas[12] = "\aAHRS1 TAS"; // weak
char aAhrs1NotReceiv[36] = "AHRS1 not receiving valid airspeed."; // weak
_BYTE byte_1007FFBC[21] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
_BYTE byte_1007FFD1[21] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
char byte_1007FFE6[] = { '\x03' }; // weak
char byte_1007FFE7[] = { '\x01' }; // weak
int dword_1007FFE8[] = { 1000 }; // weak
__int16 word_1007FFEC[] = { 0 }; // weak
char byte_1007FFEE[] = { '\x01' }; // weak
char byte_1007FFEF[] = { '\x01' }; // weak
char byte_1007FFF0[] = { '\xFF' }; // weak
char byte_1007FFF1[] = { '\xFF' }; // weak
__int16 word_1007FFF2[] = { 0 }; // weak
int dword_1007FFF4[] = { 0 }; // weak
int dword_1007FFF8[] = { 0 }; // weak
__int16 word_1007FFFC[] = { 0 }; // weak
int dword_10080000[] = { 0 }; // weak
_UNKNOWN unk_1008FC50; // weak
_UNKNOWN unk_1008FC52; // weak
int dword_1008FC54 = 9429; // idb
_UNKNOWN unk_10090948; // weak
int dword_1009094C[] = { 9826 }; // weak
_UNKNOWN unk_10090950; // weak
_UNKNOWN unk_10090AC8; // weak
__int16 word_10090ACA[] = { 301 }; // weak
__int16 word_10090ACC[] = { 302 }; // weak
__int16 word_10090ACE[] = { 303 }; // weak
__int16 word_10090AD0[] = { 304 }; // weak
__int16 word_10090AD2[] = { 305 }; // weak
__int16 word_10090AD4[] = { 306 }; // weak
__int16 word_10090AD6[] = { 307 }; // weak
_UNKNOWN unk_10090EF0; // weak
_UNKNOWN off_10090EF4; // idb
_UNKNOWN unk_10091BE8; // weak
_UNKNOWN unk_100927DC; // weak
char *off_100928A0 = "/shr_mem/iop_atn_log_intf.shr"; // weak
char *off_10093818 = "/shr_mem/iop_log_intf.shr"; // weak
char *off_10093C18[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_10093A88 }; // weak
_UNKNOWN unk_10093C2C; // weak
char *off_100942EC[7] =
{
  "/dev/sd_card0",
  "/dev/sd_card1",
  "/dev/sd_card2",
  "/mnt/card0",
  "/mnt/card1",
  "/mnt/card2",
  "/mnt/sys_nand0"
}; // weak
char *off_100942F8[4] = { "/mnt/card0", "/mnt/card1", "/mnt/card2", "/mnt/sys_nand0" }; // weak
char *off_10094428[18] =
{
  "FAIL",
  "PASS",
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_10094430[16] =
{
  "normal",
  "robust",
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_10094438[14] =
{
  "EQ",
  "NE",
  "LE",
  "LT",
  "GT",
  "GE",
  "NEAR",
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_10094454[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_10094460[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_10094468[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_10094738; // weak
_UNKNOWN unk_10094784; // weak
char off_10095520[] = { '\x04', 'D', '\t', '\x10' }; // idb
int dword_1009553C = 1; // idb
char byte_10095558[] = { '\x01' }; // weak
void *off_1009555C = &unk_1006C380; // weak
char *off_10095560[2] = { "2", "fail_normal_1" }; // weak
char off_10095564[8] = { '\b', 'U', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100955E8[] = { '\0' }; // weak
char byte_100955E9[] = { '\0' }; // weak
int dword_100955EC[] = { 0 }; // weak
char *off_100955F0 = "0, 0, 0"; // weak
double dbl_10095858[] = {  0.0 }; // weak
double dbl_10095860[] = {  0.0 }; // weak
double dbl_10095868[] = {  0.0 }; // weak
int dword_10095870[] = { 0 }; // weak
char off_10095874[32] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_10096478[] = {  0.0 }; // weak
float flt_1009647C[] = {  0.0 }; // weak
float flt_10096480[] = {  0.0 }; // weak
int dword_10096484[] = { 0 }; // weak
char off_10096488[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_10096C0C[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100AB868
}; // weak
int dword_10096C20[] = { 0 }; // weak
int dword_10096C24[] = { 0 }; // weak
int dword_10096C28[] = { 0 }; // weak
int dword_10096C2C[] = { 0 }; // weak
char *off_10096C30 = "0, 0, 0"; // weak
__int16 word_100973B8[] = { 0 }; // weak
__int16 word_100973BA[] = { 0 }; // weak
__int16 word_100973BC[] = { 0 }; // weak
int dword_100973C0[] = { 0 }; // weak
char *off_100973C4 = "0, 0, 0"; // weak
int dword_100979C8[] = { 0 }; // weak
int dword_100979CC[] = { 0 }; // weak
int dword_100979D0[] = { 0 }; // weak
int dword_100979D4[] = { 0 }; // weak
char off_100979D8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_10098160[] = { 0 }; // weak
int dword_10098164[] = { 0 }; // weak
int dword_10098168[] = { 0 }; // weak
int dword_1009816C[] = { 0 }; // weak
int dword_10098170[] = { 0 }; // weak
int dword_10098174[] = { 0 }; // weak
int dword_10098178[] = { 0 }; // weak
char off_1009817C[32] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_10098D80[] = { '\0' }; // weak
char byte_10098D81[] = { '\0' }; // weak
char byte_10098D82[] = { '\0' }; // weak
int dword_10098D84[] = { 0 }; // weak
char *off_10098D88 = "0, 0, 0"; // weak
int dword_10099210[] = { 0 }; // weak
int dword_10099214[] = { 0 }; // weak
int dword_10099218[] = { 0 }; // weak
int dword_1009921C[] = { 0 }; // weak
char *off_10099220 = "0, 0, 0"; // weak
int dword_100999A8[] = { 0 }; // weak
int dword_100999AC[] = { 0 }; // weak
int dword_100999B0[] = { 0 }; // weak
int dword_100999B4[] = { 0 }; // weak
char off_100999B8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_10099D18[] = { 0 }; // weak
__int16 word_10099D1A[] = { 0 }; // weak
__int16 word_10099D1C[] = { 0 }; // weak
int dword_10099D20[] = { 0 }; // weak
char *off_10099D24 = "0, 0, 0"; // weak
int dword_10099FD8[] = { 0 }; // weak
int dword_10099FDC[] = { 0 }; // weak
int dword_10099FE0[] = { 0 }; // weak
int dword_10099FE4[] = { 0 }; // weak
char off_10099FE8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1009A348[] = { 0 }; // weak
int dword_1009A34C[] = { 0 }; // weak
int dword_1009A350[] = { 0 }; // weak
int dword_1009A354[] = { 0 }; // weak
int dword_1009A358[] = { 0 }; // weak
int dword_1009A35C[] = { 0 }; // weak
int dword_1009A360[] = { 0 }; // weak
char *off_1009A364 = "0, 0, 0"; // weak
char byte_1009A8C8[] = { '\0' }; // weak
char byte_1009A8C9[] = { '\0' }; // weak
char byte_1009A8CA[] = { '\0' }; // weak
int dword_1009A8CC[] = { 0 }; // weak
char *off_1009A8D0 = "0, 0, 0"; // weak
int dword_1009AAD8[] = { 0 }; // weak
int dword_1009AADC[] = { 0 }; // weak
int dword_1009AAE0[] = { 0 }; // weak
int dword_1009AAE4[] = { 0 }; // weak
char off_1009AAE8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1009AE48[] = { '\x01' }; // weak
void *off_1009AE4C = &unk_1006C380; // weak
char *off_1009AE50[2] = { "2", "fail_robust_1" }; // weak
char off_1009AE54[8] = { '', 'P', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_1009AED8[] = { '\0' }; // weak
char byte_1009AED9[] = { '\0' }; // weak
int dword_1009AEDC[] = { 0 }; // weak
char *off_1009AEE0 = "0, 0, 0"; // weak
double dbl_1009B148[] = {  0.0 }; // weak
double dbl_1009B150[] = {  0.0 }; // weak
double dbl_1009B158[] = {  0.0 }; // weak
int dword_1009B160[] = { 0 }; // weak
char *off_1009B164 = "0, 0, 0"; // weak
float flt_1009BD68[] = {  0.0 }; // weak
float flt_1009BD6C[] = {  0.0 }; // weak
float flt_1009BD70[] = {  0.0 }; // weak
int dword_1009BD74[] = { 0 }; // weak
char off_1009BD78[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1009C500[] = { 0 }; // weak
int dword_1009C504[] = { 0 }; // weak
int dword_1009C508[] = { 0 }; // weak
int dword_1009C50C[] = { 0 }; // weak
char *off_1009C510 = "0, 0, 0"; // weak
__int16 word_1009CC98[] = { 0 }; // weak
__int16 word_1009CC9A[] = { 0 }; // weak
__int16 word_1009CC9C[] = { 0 }; // weak
int dword_1009CCA0[] = { 0 }; // weak
char *off_1009CCA4 = "0, 0, 0"; // weak
int dword_1009D2A8[] = { 0 }; // weak
int dword_1009D2AC[] = { 0 }; // weak
int dword_1009D2B0[] = { 0 }; // weak
int dword_1009D2B4[] = { 0 }; // weak
char off_1009D2B8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1009DA40[] = { 0 }; // weak
int dword_1009DA44[] = { 0 }; // weak
int dword_1009DA48[] = { 0 }; // weak
int dword_1009DA4C[] = { 0 }; // weak
int dword_1009DA50[] = { 0 }; // weak
int dword_1009DA54[] = { 0 }; // weak
int dword_1009DA58[] = { 0 }; // weak
char off_1009DA5C[32] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_1009E660[] = { '\0' }; // weak
char byte_1009E661[] = { '\0' }; // weak
char byte_1009E662[] = { '\0' }; // weak
int dword_1009E664[] = { 0 }; // weak
char *off_1009E668 = "0, 0, 0"; // weak
int dword_1009EAF0[] = { 0 }; // weak
int dword_1009EAF4[] = { 0 }; // weak
int dword_1009EAF8[] = { 0 }; // weak
int dword_1009EAFC[] = { 0 }; // weak
char *off_1009EB00 = "0, 0, 0"; // weak
int dword_1009F288[] = { 0 }; // weak
int dword_1009F28C[] = { 0 }; // weak
int dword_1009F290[] = { 0 }; // weak
int dword_1009F294[] = { 0 }; // weak
char off_1009F298[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_1009F5F8[] = { 0 }; // weak
__int16 word_1009F5FA[] = { 0 }; // weak
__int16 word_1009F5FC[] = { 0 }; // weak
int dword_1009F600[] = { 0 }; // weak
char *off_1009F604 = "0, 0, 0"; // weak
int dword_1009F8B8[] = { 0 }; // weak
int dword_1009F8BC[] = { 0 }; // weak
int dword_1009F8C0[] = { 0 }; // weak
int dword_1009F8C4[] = { 0 }; // weak
char off_1009F8C8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_1009FC28[] = { 0 }; // weak
int dword_1009FC2C[] = { 0 }; // weak
int dword_1009FC30[] = { 0 }; // weak
int dword_1009FC34[] = { 0 }; // weak
int dword_1009FC38[] = { 0 }; // weak
int dword_1009FC3C[] = { 0 }; // weak
int dword_1009FC40[] = { 0 }; // weak
char *off_1009FC44 = "0, 0, 0"; // weak
char byte_100A01A8[] = { '\0' }; // weak
char byte_100A01A9[] = { '\0' }; // weak
char byte_100A01AA[] = { '\0' }; // weak
int dword_100A01AC[] = { 0 }; // weak
char *off_100A01B0 = "0, 0, 0"; // weak
int dword_100A03B8[] = { 0 }; // weak
int dword_100A03BC[] = { 0 }; // weak
int dword_100A03C0[] = { 0 }; // weak
int dword_100A03C4[] = { 0 }; // weak
char off_100A03C8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A0728[] = { '\x01' }; // weak
void *off_100A072C = &unk_1006C380; // weak
void *off_100A0730 = &unk_1006C380; // weak
char off_100A0734[8] = { '', 'O', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100A0778[] = { '\0' }; // weak
char byte_100A0779[] = { '\0' }; // weak
int dword_100A077C[] = { 0 }; // weak
char *off_100A0780 = "0, 0, 0"; // weak
double dbl_100A09E8[] = {  0.0 }; // weak
double dbl_100A09F0[] = {  0.0 }; // weak
double dbl_100A09F8[] = {  0.0 }; // weak
int dword_100A0A00[] = { 0 }; // weak
char *off_100A0A04 = "0, 0, 0"; // weak
float flt_100A1608[] = {  0.0 }; // weak
float flt_100A160C[] = {  0.0 }; // weak
float flt_100A1610[] = {  0.0 }; // weak
int dword_100A1614[] = { 0 }; // weak
char off_100A1618[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A1DA0[] = { 0 }; // weak
int dword_100A1DA4[] = { 0 }; // weak
int dword_100A1DA8[] = { 0 }; // weak
int dword_100A1DAC[] = { 0 }; // weak
char *off_100A1DB0 = "0, 0, 0"; // weak
__int16 word_100A2538[] = { 0 }; // weak
__int16 word_100A253A[] = { 0 }; // weak
__int16 word_100A253C[] = { 0 }; // weak
int dword_100A2540[] = { 0 }; // weak
char *off_100A2544 = "0, 0, 0"; // weak
int dword_100A2B48[] = { 0 }; // weak
int dword_100A2B4C[] = { 0 }; // weak
int dword_100A2B50[] = { 0 }; // weak
int dword_100A2B54[] = { 0 }; // weak
char off_100A2B58[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A32E0[] = { 0 }; // weak
int dword_100A32E4[] = { 0 }; // weak
int dword_100A32E8[] = { 0 }; // weak
int dword_100A32EC[] = { 0 }; // weak
int dword_100A32F0[] = { 0 }; // weak
int dword_100A32F4[] = { 0 }; // weak
int dword_100A32F8[] = { 0 }; // weak
char off_100A32FC[32] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A3F00[] = { '\0' }; // weak
char byte_100A3F01[] = { '\0' }; // weak
char byte_100A3F02[] = { '\0' }; // weak
int dword_100A3F04[] = { 0 }; // weak
char *off_100A3F08 = "0, 0, 0"; // weak
int dword_100A4390[] = { 0 }; // weak
int dword_100A4394[] = { 0 }; // weak
int dword_100A4398[] = { 0 }; // weak
int dword_100A439C[] = { 0 }; // weak
char *off_100A43A0 = "0, 0, 0"; // weak
int dword_100A4B28[] = { 0 }; // weak
int dword_100A4B2C[] = { 0 }; // weak
int dword_100A4B30[] = { 0 }; // weak
int dword_100A4B34[] = { 0 }; // weak
char off_100A4B38[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100A4E98[] = { 0 }; // weak
__int16 word_100A4E9A[] = { 0 }; // weak
__int16 word_100A4E9C[] = { 0 }; // weak
int dword_100A4EA0[] = { 0 }; // weak
char *off_100A4EA4 = "0, 0, 0"; // weak
int dword_100A5158[] = { 0 }; // weak
int dword_100A515C[] = { 0 }; // weak
int dword_100A5160[] = { 0 }; // weak
int dword_100A5164[] = { 0 }; // weak
char off_100A5168[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A54C8[] = { 0 }; // weak
int dword_100A54CC[] = { 0 }; // weak
int dword_100A54D0[] = { 0 }; // weak
int dword_100A54D4[] = { 0 }; // weak
int dword_100A54D8[] = { 0 }; // weak
int dword_100A54DC[] = { 0 }; // weak
int dword_100A54E0[] = { 0 }; // weak
char *off_100A54E4 = "0, 0, 0"; // weak
char byte_100A5A48[] = { '\0' }; // weak
char byte_100A5A49[] = { '\0' }; // weak
char byte_100A5A4A[] = { '\0' }; // weak
int dword_100A5A4C[] = { 0 }; // weak
char *off_100A5A50 = "0, 0, 0"; // weak
int dword_100A5C58[] = { 0 }; // weak
int dword_100A5C5C[] = { 0 }; // weak
int dword_100A5C60[] = { 0 }; // weak
int dword_100A5C64[] = { 0 }; // weak
char off_100A5C68[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A5FC8[] = { '\x01' }; // weak
void *off_100A5FCC = &unk_1006C380; // weak
void *off_100A5FD0 = &unk_1006C380; // weak
char off_100A5FD4[8] = { '', 'O', '\t', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100A6018[] = { '\0' }; // weak
char byte_100A6019[] = { '\0' }; // weak
int dword_100A601C[] = { 0 }; // weak
char *off_100A6020 = "0, 0, 0"; // weak
double dbl_100A6288[] = {  0.0 }; // weak
double dbl_100A6290[] = {  0.0 }; // weak
double dbl_100A6298[] = {  0.0 }; // weak
int dword_100A62A0[] = { 0 }; // weak
char *off_100A62A4 = "0, 0, 0"; // weak
float flt_100A6EA8[] = {  0.0 }; // weak
float flt_100A6EAC[] = {  0.0 }; // weak
float flt_100A6EB0[] = {  0.0 }; // weak
int dword_100A6EB4[] = { 0 }; // weak
char off_100A6EB8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A7640[] = { 0 }; // weak
int dword_100A7644[] = { 0 }; // weak
int dword_100A7648[] = { 0 }; // weak
int dword_100A764C[] = { 0 }; // weak
char *off_100A7650 = "0, 0, 0"; // weak
__int16 word_100A7DD8[] = { 0 }; // weak
__int16 word_100A7DDA[] = { 0 }; // weak
__int16 word_100A7DDC[] = { 0 }; // weak
int dword_100A7DE0[] = { 0 }; // weak
char *off_100A7DE4 = "0, 0, 0"; // weak
int dword_100A83E8[] = { 0 }; // weak
int dword_100A83EC[] = { 0 }; // weak
int dword_100A83F0[] = { 0 }; // weak
int dword_100A83F4[] = { 0 }; // weak
char off_100A83F8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100A8B80[] = { 0 }; // weak
int dword_100A8B84[] = { 0 }; // weak
int dword_100A8B88[] = { 0 }; // weak
int dword_100A8B8C[] = { 0 }; // weak
int dword_100A8B90[] = { 0 }; // weak
int dword_100A8B94[] = { 0 }; // weak
int dword_100A8B98[] = { 0 }; // weak
char off_100A8B9C[32] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100A97A0[] = { '\0' }; // weak
char byte_100A97A1[] = { '\0' }; // weak
char byte_100A97A2[] = { '\0' }; // weak
int dword_100A97A4[] = { 0 }; // weak
char *off_100A97A8 = "0, 0, 0"; // weak
int dword_100A9C30[] = { 0 }; // weak
int dword_100A9C34[] = { 0 }; // weak
int dword_100A9C38[] = { 0 }; // weak
int dword_100A9C3C[] = { 0 }; // weak
char *off_100A9C40 = "0, 0, 0"; // weak
int dword_100AA3C8[] = { 0 }; // weak
int dword_100AA3CC[] = { 0 }; // weak
int dword_100AA3D0[] = { 0 }; // weak
int dword_100AA3D4[] = { 0 }; // weak
char off_100AA3D8[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100AA738[] = { 0 }; // weak
__int16 word_100AA73A[] = { 0 }; // weak
__int16 word_100AA73C[] = { 0 }; // weak
int dword_100AA740[] = { 0 }; // weak
char *off_100AA744 = "0, 0, 0"; // weak
int dword_100AA9F8[] = { 0 }; // weak
int dword_100AA9FC[] = { 0 }; // weak
int dword_100AAA00[] = { 0 }; // weak
int dword_100AAA04[] = { 0 }; // weak
char off_100AAA08[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100AAD68[] = { 0 }; // weak
int dword_100AAD6C[] = { 0 }; // weak
int dword_100AAD70[] = { 0 }; // weak
int dword_100AAD74[] = { 0 }; // weak
int dword_100AAD78[] = { 0 }; // weak
int dword_100AAD7C[] = { 0 }; // weak
int dword_100AAD80[] = { 0 }; // weak
char *off_100AAD84 = "0, 0, 0"; // weak
char byte_100AB2E8[] = { '\0' }; // weak
char byte_100AB2E9[] = { '\0' }; // weak
char byte_100AB2EA[] = { '\0' }; // weak
int dword_100AB2EC[] = { 0 }; // weak
char *off_100AB2F0 = "0, 0, 0"; // weak
int dword_100AB4F8[] = { 0 }; // weak
int dword_100AB4FC[] = { 0 }; // weak
int dword_100AB500[] = { 0 }; // weak
int dword_100AB504[] = { 0 }; // weak
char off_100AB508[20] =
{
  'p',
  'T',
  '\t',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100AC4E8; // weak
_UNKNOWN unk_100AFDD8; // weak
int dword_100AFDDC[] = { 6006 }; // weak
int (*off_100B03B0[4])() = { &sub_1002B390, &sub_1002B380, &sub_1002B370, &sub_1002B380 }; // weak
int (__cdecl *off_100B08E8)(int, size_t, void *) = &sub_1002B4E0; // weak
char *off_100B0960 = "/shr_mem/dat_intf.shr"; // weak
char *off_100B098C = "/shr_mem/prx_intf.shr"; // weak
char *off_100B09B8 = "/shr_mem/nav_intf.shr"; // weak
char *off_100B09EC = "/shr_mem/iop_fltr_data_intf.shr"; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_100B0AE0 = "006-D0170-"; // weak
int (__cdecl *(*off_100B0AE4)[2])(int, int) = &off_100C5EB8; // weak
int (__cdecl *off_100B2270[3])(char) = { &sub_1001D140, &sub_1001D050, &sub_1001D010 }; // weak
_UNKNOWN unk_100B2D78; // weak
char byte_100B2D7C[] = { '\0' }; // weak
_UNKNOWN unk_100B41E8; // weak
int dword_100B41EC[] = { 1312 }; // weak
int dword_100B6140 = 64; // weak
__int16 word_100B6144[] = { 6782 }; // weak
__int16 word_100B6148[] = { 128 }; // weak
_UNKNOWN unk_100B6164; // weak
_DWORD dword_100B6168[4] = { 64, 24, 62, 18 }; // idb
_UNKNOWN unk_100B617C; // weak
__int16 word_100B617E[] = { 420 }; // weak
int dword_100B618C[] = { 0 }; // weak
char *off_100B6268 = "/shr_mem/iop_tcas_ii_intf.shr"; // weak
char *off_100B8008 = "/shr_mem/iop_gtx_intf.shr"; // weak
_UNKNOWN unk_100B8130; // weak
char byte_100B8320[] = { '\x01' }; // weak
__int16 word_100B8322[] = { 3020 }; // weak
_UNKNOWN unk_100B8B80; // weak
_UNKNOWN unk_100B8B98; // weak
_UNKNOWN unk_100B8BE0; // weak
int dword_100B8BE4[] = { 6767 }; // weak
_UNKNOWN unk_100B8BF0; // weak
_UNKNOWN unk_100B8C08; // weak
_UNKNOWN unk_100B8C20; // weak
int dword_100B8C24[] = { 6769 }; // weak
_UNKNOWN unk_100B8C38; // weak
int dword_100B8C3C[] = { 6093 }; // weak
__int16 word_100BA630[] = { 43 }; // weak
char byte_100BA634[] = { '\x06' }; // weak
_UNKNOWN unk_100BC128; // weak
int dword_100BC12C[] = { 0 }; // weak
_UNKNOWN unk_100BC4C8; // weak
int dword_100BC4CC[] = { 0 }; // weak
_UNKNOWN unk_100BD7B0; // weak
char *off_100BD954[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_100BD968 }; // weak
char *off_100BDAF8 = "true"; // weak
char byte_100BDAFC[] = { '\x01' }; // weak
char *off_100BDB60 = "failure listener"; // weak
_UNKNOWN unk_100BE2C8; // weak
char *off_100BE618 = "printf_listener"; // weak
__int16 word_100BF24C = 2573; // weak
char *off_100BF3A8 = "gate_listener"; // weak
_UNKNOWN unk_100BFF24; // weak
_UNKNOWN unk_100BFF48; // weak
_UNKNOWN unk_100C00F0; // weak
_UNKNOWN unk_100C0154; // weak
__int16 word_100C0156[] = { 565 }; // weak
_UNKNOWN unk_100C0EC8; // weak
int dword_100C0ECC[] = { 0 }; // weak
_UNKNOWN unk_100C0EE0; // weak
int dword_100C0EE4[] = { 0 }; // weak
_UNKNOWN unk_100C0F08; // weak
int dword_100C0F0C[] = { 0 }; // weak
_UNKNOWN unk_100C0F38; // weak
int dword_100C0F3C[] = { 0 }; // weak
_UNKNOWN unk_100C2D40; // weak
char byte_100C2D41[] = { '\0' }; // weak
char byte_100C2D68[] = { '\x01' }; // weak
__int16 word_100C2D6A[] = { 3020 }; // weak
char byte_100C4630[] = { '\x01' }; // weak
__int16 word_100C4638[] = { 3020 }; // weak
_UNKNOWN unk_100C5D08; // weak
void *off_100C5D0C = &unk_100C5A80; // weak
int (__cdecl *off_100C5EB8[2])(int, int) = { &sub_1003A5B0, &sub_1003A610 }; // weak
_UNKNOWN unk_100C7B90; // weak
_UNKNOWN unk_100C7B91; // weak
_UNKNOWN unk_100C8278; // weak
int dword_100C827C[] = { 6829 }; // weak
__int16 word_100C9620[] = { 1565 }; // weak
__int16 word_100C9624[] = { 534 }; // weak
char byte_100C9628[] = { '\x04' }; // weak
__int16 word_100C962A[] = { 6512 }; // weak
int dword_100C9640[] = { 118000 }; // weak
__int16 word_100CA16A[] = { 233 }; // weak
int dword_100CA170[] = { 6201 }; // weak
__int16 word_100CCD20[] = { 114 }; // weak
__int16 word_100CCE30[] = { 551 }; // weak
int dword_100CD00C[] = { 0 }; // weak
_UNKNOWN off_100CD010; // weak
_UNKNOWN unk_100CD0A0; // weak
_UNKNOWN unk_100CD0A4; // weak
_UNKNOWN unk_100CD0A8; // weak
_UNKNOWN unk_100CD0AC; // weak
_UNKNOWN unk_100CD0B0; // weak
_UNKNOWN unk_100CD0B4; // weak
_UNKNOWN unk_100CD0B8; // weak
_UNKNOWN unk_100CD0BC; // weak
char byte_100CD102[] = { '\x04' }; // weak
char byte_100CD107[] = { '\a' }; // weak
_UNKNOWN unk_100D7670; // weak
int dword_100D7674[] = { 3535 }; // weak
_UNKNOWN unk_100D76A8; // weak
int dword_100D76AC[] = { 6813 }; // weak
_UNKNOWN unk_100D76E0; // weak
int dword_100D76E4[] = { 9036 }; // weak
_UNKNOWN unk_100D7718; // weak
int dword_100D771C[] = { 6763 }; // weak
int dword_100D9840[] = { 6103 }; // weak
int dword_100D9844[] = { 8000 }; // weak
int dword_100DA538[] = { 0 }; // weak
_WORD dword_100E85F0[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_100E89F0[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_100E8DF0[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_100E91F0[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_100E95F0[] = { 99 }; // weak
int dword_100E99F0[] = { 25344 }; // weak
int dword_100E9DF0[] = { 6488064 }; // weak
int dword_100EA1F0[] = { 1660944384 }; // weak
int dword_100EA618[] = { 128 }; // weak
int dword_100EA628[] = { 0 }; // weak
int dword_100EA638[] = { 0 }; // weak
char byte_100EA6A9[] = { '\0' }; // weak
char byte_100EA6AA[] = { '\0' }; // weak
char byte_100EA6AB[] = { '\0' }; // weak
char byte_100EA6AC[] = { '\x10' }; // weak
int dword_100EA6C0[] = { 0 }; // weak
_UNKNOWN unk_100EA738; // weak
_UNKNOWN unk_100EABB8; // weak
char byte_100EAC30[] = { '\0' }; // weak
char byte_100EAD30[] = { '\0' }; // weak
char byte_100EAE30[] = { '\0' }; // weak
int dword_100EAF30[] = { 0 }; // weak
int dword_100EAFA8[] = { 0 }; // weak
int (__cdecl *off_100EB028)(int, int) = &sub_1005D3F0; // weak
int dword_100EB210[] = { 0 }; // weak
int dword_100EB258[] = { 16 }; // weak
_UNKNOWN unk_100EB2A8; // weak
_UNKNOWN unk_100EB328; // weak
_UNKNOWN unk_100EB3A8; // weak
_UNKNOWN unk_100EB420; // weak
_UNKNOWN unk_100EB498; // weak
_UNKNOWN unk_100EC498; // weak
_UNKNOWN unk_100EC5F0; // weak
_UNKNOWN unk_100EC5F8; // weak
int (*off_100EE29C[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
_UNKNOWN unk_100EE358; // weak
void *off_100EED58 = &unk_102AD5C0; // weak
_UNKNOWN unk_100EED68; // weak
_UNKNOWN unk_100EEDC8; // weak
_UNKNOWN unk_100EEFD8; // weak
int dword_100EF1B0 = 1024; // weak
int dword_100EF1B4 = 4294966273; // weak
int dword_100EF1B8 = 53; // weak
int dword_100EF1BC = 11; // weak
int dword_100EF1C0 = 64; // weak
int dword_100EF1C4 = 1023; // weak
int dword_100EF1C8 = 128; // weak
int dword_100EF1CC = 4294967169; // weak
int dword_100EF1D0 = 24; // weak
int dword_100EF1D4 = 8; // weak
int dword_100EF1D8 = 32; // weak
int dword_100EF1DC = 127; // weak
float flt_100EF800 =  0.0; // weak
float flt_100EF804 =  0.0; // weak
float flt_100EF808 =  0.0; // weak
float flt_100EF80C =  0.0; // weak
float flt_100EF810 =  0.0; // weak
char byte_100EF814 = '\0'; // weak
char byte_100EF815 = '\0'; // weak
char byte_100EF816 = '\0'; // weak
char byte_100EF817 = '\0'; // weak
float flt_100EF818 =  0.0; // weak
int dword_100EF81C = 0; // weak
_UNKNOWN unk_100EF820; // weak
int dword_100FF9F0; // weak
int dword_100FF9F4; // weak
char byte_100FF9F8[]; // weak
char byte_100FF9F9[]; // weak
float flt_100FFA70; // weak
int dword_100FFA74; // weak
_UNKNOWN unk_100FFA78; // weak
int dword_10105278; // weak
char byte_1010527C; // weak
int dword_10105280; // weak
int dword_10105284; // weak
_UNKNOWN unk_10105298; // weak
char byte_101052EC; // weak
char byte_101052ED; // weak
char byte_101052EE; // weak
char byte_10106A60[]; // weak
int dword_10106A64[]; // weak
int dword_10106D84; // weak
char byte_10106D88[]; // weak
__int16 word_10106E88[]; // weak
_UNKNOWN unk_10106F50; // weak
_UNKNOWN unk_10107050; // weak
int dword_10117E78[]; // weak
_UNKNOWN unk_10117F34; // weak
_UNKNOWN unk_10117F38; // weak
char byte_10117F3C[]; // weak
_UNKNOWN unk_10117F43; // weak
__int16 word_10117F44; // weak
int dword_10117F48; // weak
char byte_10117F50[]; // weak
char byte_10117F60[]; // weak
char byte_10117F88[]; // weak
_UNKNOWN unk_10117F90; // weak
char byte_10118058[]; // weak
_UNKNOWN unk_1011888C; // weak
int dword_10118A1C; // weak
int dword_10118A20; // weak
int dword_10118A24; // weak
int dword_10118A28[]; // weak
int dword_1017A4A8; // idb
int dword_1017A4E8; // weak
int dword_1017A4EC; // weak
int dword_1017A4F0; // weak
int dword_1017A4F4; // weak
__int16 word_1017A4F8; // weak
char byte_1017A4FA; // weak
int dword_1017A500[]; // weak
int dword_1017A504[]; // weak
__int64 qword_1017A580; // weak
int dword_1017A588; // weak
int dword_1017A58C; // weak
_UNKNOWN unk_1017A590; // weak
_UNKNOWN unk_1017A5A4; // weak
_UNKNOWN unk_1017A734; // weak
_UNKNOWN unk_1017A798; // weak
_UNKNOWN unk_1017AFCC; // weak
_UNKNOWN unk_1017B030; // weak
_UNKNOWN unk_1017B1C0; // weak
_UNKNOWN unk_1017B224; // weak
__int16 word_1017B388; // weak
_UNKNOWN unk_1017B38A; // weak
_UNKNOWN unk_1017B3A9; // weak
_UNKNOWN unk_1017BBE0; // weak
char byte_1017BF00[]; // weak
char byte_1017BF64; // weak
char byte_1017BF65[]; // weak
__int16 word_1017BFCA[]; // weak
__int16 word_1017C094; // weak
_UNKNOWN unk_1017C098; // weak
_UNKNOWN unk_1017D098; // weak
int dword_1018D098; // weak
int dword_1018D09C; // weak
int dword_1018D0A0; // weak
int dword_1018D0A4; // weak
char byte_1018D0A8[]; // weak
char byte_1018D0B8[]; // weak
_UNKNOWN unk_1018DA80; // weak
int dword_1018DAA0[]; // weak
int dword_1018DAA4[]; // weak
float flt_1018DAA8[]; // weak
int dword_1018DDC0[]; // weak
_UNKNOWN unk_1018DE00; // weak
char byte_1018DEC8[]; // weak
int dword_1018DEE8[]; // weak
char byte_1018DEEC[]; // weak
_UNKNOWN unk_1018DEF0; // weak
char byte_1018DEF2[]; // weak
_UNKNOWN unk_1018DF02; // weak
__int16 word_1018DF04[]; // weak
char byte_1018DFCD[]; // weak
char byte_1018DFD7[]; // weak
char byte_1018DFDA[]; // weak
char byte_1018DFDE[]; // weak
int dword_1018F088[]; // weak
_UNKNOWN unk_1018F0C8; // weak
int dword_1018F0D4; // weak
__int16 word_10190BCC; // weak
_UNKNOWN unk_10190BD0; // weak
_UNKNOWN unk_101A4450; // weak
char byte_101A4460; // weak
_UNKNOWN unk_101A4490; // weak
int dword_101A6490; // weak
int dword_101A6494; // weak
char byte_101A6498; // idb
char byte_101A689E; // weak
int dword_101A68A0; // weak
int dword_101A68A4; // weak
_UNKNOWN unk_101A68A8; // weak
char byte_101A68B8; // weak
char dword_101A68E8[]; // idb
int dword_101A68EC; // weak
char byte_101A68F0[]; // weak
_UNKNOWN unk_101A6960; // weak
_UNKNOWN unk_101A6961; // weak
_UNKNOWN unk_101A8260; // weak
_UNKNOWN unk_101A8261; // weak
_UNKNOWN unk_101A8262; // weak
_UNKNOWN unk_101AC0E2; // weak
char byte_101AC0E8[]; // weak
_UNKNOWN unk_101AE7F8; // weak
_UNKNOWN unk_101B0738; // weak
void (__cdecl *dword_101B07B8[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_101B07D8; // weak
__int16 word_101B59CC; // weak
__int16 word_101B59D0; // weak
__int16 word_101B59D4; // weak
int dword_101B59D8; // weak
char byte_101BAF48; // weak
char byte_101BAF49; // weak
int dword_101BAF4C; // weak
int dword_101BAF50; // weak
int dword_101BAF54; // weak
int dword_101BAF58; // weak
int dword_101BAF5C; // weak
int dword_101BAF60; // weak
int dword_101BAF64; // weak
int dword_101BAF68; // weak
int dword_101BAF6C; // weak
int dword_101BAF70; // weak
int dword_101BAF74; // weak
int dword_101BAF78; // weak
int dword_101BAF98; // weak
_UNKNOWN unk_101BAFA0; // weak
_UNKNOWN unk_101BB269; // weak
_UNKNOWN unk_101BB4F4; // weak
_UNKNOWN unk_101BB551; // weak
_UNKNOWN unk_101BB5AE; // weak
int dword_101BB6E4[]; // weak
__int16 word_101BB6E8[]; // weak
int dword_101BB6EC; // weak
__int16 word_101BB6F0; // weak
int dword_101BB6F4; // weak
__int16 word_101BB6F8; // weak
int dword_101BB6FC; // weak
__int16 word_101BB700; // weak
int dword_101BB704; // weak
__int16 word_101BB708; // weak
_UNKNOWN unk_101BB710; // weak
_UNKNOWN unk_101BB73E; // weak
_UNKNOWN unk_101BB768; // weak
_UNKNOWN unk_101BB76E; // weak
_UNKNOWN unk_101BB774; // weak
int dword_101BB788[]; // weak
__int16 word_101BB78C[]; // weak
int dword_101BB790; // weak
__int16 word_101BB794; // weak
int dword_101BB798; // weak
__int16 word_101BB79C; // weak
int dword_101BB7A0; // weak
__int16 word_101BB7A4; // weak
int dword_101BB7A8; // weak
__int16 word_101BB7AC; // weak
char byte_101BB7B0[100]; // idb
float flt_101BB814; // weak
float flt_101BB818; // weak
int dword_101BB81C; // weak
int dword_101BB820; // weak
char byte_101BB824; // weak
float flt_101BD598[]; // weak
char byte_101BD5E8; // weak
char byte_101BD5E9; // weak
char byte_101BD5EA; // weak
float flt_101BD5F0[]; // weak
float flt_101BD5F4[]; // weak
float flt_101BD5F8[]; // weak
float flt_101BD5FC[]; // weak
float flt_101BD730[]; // weak
_UNKNOWN unk_101BD780; // weak
_UNKNOWN unk_101BD781; // weak
_UNKNOWN unk_101BD797; // weak
_UNKNOWN unk_101BD798; // weak
_UNKNOWN unk_101BD799; // weak
_UNKNOWN unk_101BD79A; // weak
_UNKNOWN unk_101BD79C; // weak
_UNKNOWN unk_101BD7A0; // weak
_UNKNOWN unk_101BD7A4; // weak
_UNKNOWN unk_101BD7C4; // weak
_UNKNOWN unk_101BD7E4; // weak
_UNKNOWN unk_101BD804; // weak
_UNKNOWN unk_101BD824; // weak
_UNKNOWN unk_101BD844; // weak
_UNKNOWN unk_101BD864; // weak
_UNKNOWN unk_101BD884; // weak
_UNKNOWN unk_101BD8A4; // weak
_UNKNOWN unk_101BD8C4; // weak
_UNKNOWN unk_101BD8E4; // weak
_UNKNOWN unk_101BD904; // weak
_UNKNOWN unk_101BD924; // weak
_UNKNOWN unk_101BD944; // weak
_UNKNOWN unk_101BD964; // weak
_UNKNOWN unk_101BD984; // weak
_UNKNOWN unk_101BD9A4; // weak
_UNKNOWN unk_101BD9C4; // weak
_UNKNOWN unk_101BD9E4; // weak
_UNKNOWN unk_101BDA04; // weak
_UNKNOWN unk_101BDA24; // weak
_UNKNOWN unk_101BDA44; // weak
_UNKNOWN unk_101BDA64; // weak
_UNKNOWN unk_101BDA84; // weak
_UNKNOWN unk_101BDAA4; // weak
_UNKNOWN unk_101BDAC4; // weak
_UNKNOWN unk_101BDAE4; // weak
_UNKNOWN unk_101BDB04; // weak
_UNKNOWN unk_101BDB24; // weak
_UNKNOWN unk_101BDB28; // weak
_UNKNOWN unk_101BDB2C; // weak
_UNKNOWN unk_101BDB30; // weak
_UNKNOWN unk_101BDB34; // weak
_UNKNOWN unk_101BDB38; // weak
_UNKNOWN unk_101BDB3C; // weak
_UNKNOWN unk_101BDB5C; // weak
_UNKNOWN unk_101BDB7C; // weak
_UNKNOWN unk_101BDB9C; // weak
_UNKNOWN unk_101BDBBC; // weak
_UNKNOWN unk_101BDBDC; // weak
_UNKNOWN unk_101BDBFC; // weak
_UNKNOWN unk_101BDC1C; // weak
_UNKNOWN unk_101BDC3C; // weak
_UNKNOWN unk_101BDC3D; // weak
_UNKNOWN unk_101BDC3E; // weak
_UNKNOWN unk_101BDC90; // weak
_UNKNOWN unk_101BDCB0; // weak
_UNKNOWN unk_101BDCD0; // weak
_UNKNOWN unk_101BDCD4; // weak
_UNKNOWN unk_101BDCD8; // weak
_UNKNOWN unk_101BDCDC; // weak
_UNKNOWN unk_101BDCFC; // weak
_UNKNOWN unk_101BDD1C; // weak
_UNKNOWN unk_101BDD3C; // weak
_UNKNOWN unk_101BDD5C; // weak
_UNKNOWN unk_101BDD7C; // weak
_UNKNOWN unk_101BDD9C; // weak
_UNKNOWN unk_101BDDBC; // weak
_UNKNOWN unk_101BDDDC; // weak
_UNKNOWN unk_101BDDFC; // weak
_UNKNOWN unk_101BDE44; // weak
_UNKNOWN unk_101BDE8C; // weak
_UNKNOWN unk_101BDED4; // weak
_UNKNOWN unk_101BDF1C; // weak
_UNKNOWN unk_101BDF64; // weak
_UNKNOWN unk_101BDFAC; // weak
_UNKNOWN unk_101BDFF4; // weak
_UNKNOWN unk_101BE03C; // weak
_UNKNOWN unk_101BE084; // weak
_UNKNOWN unk_101BE0CC; // weak
_UNKNOWN unk_101BE114; // weak
_UNKNOWN unk_101BE15C; // weak
_UNKNOWN unk_101BE1A4; // weak
_UNKNOWN unk_101BE1EC; // weak
_UNKNOWN unk_101BE234; // weak
_UNKNOWN unk_101BE27C; // weak
_UNKNOWN unk_101BE2C4; // weak
_UNKNOWN unk_101BE30C; // weak
_UNKNOWN unk_101BE354; // weak
_UNKNOWN unk_101BE39C; // weak
_UNKNOWN unk_101BE3E4; // weak
_UNKNOWN unk_101BE42C; // weak
_UNKNOWN unk_101BE474; // weak
_UNKNOWN unk_101BE4BC; // weak
_UNKNOWN unk_101BE504; // weak
_UNKNOWN unk_101BE54C; // weak
_UNKNOWN unk_101BE594; // weak
_UNKNOWN unk_101BE5DC; // weak
_UNKNOWN unk_101BE624; // weak
_UNKNOWN unk_101BE66C; // weak
_UNKNOWN unk_101BE684; // weak
_UNKNOWN unk_101BE6A4; // weak
_UNKNOWN unk_101BE6C4; // weak
_UNKNOWN unk_101BE6C8; // weak
_UNKNOWN unk_101BE76C; // weak
_UNKNOWN unk_101BE810; // weak
_UNKNOWN unk_101BE8B4; // weak
_UNKNOWN unk_101BE958; // weak
_UNKNOWN unk_101BE9FC; // weak
_UNKNOWN unk_101BEAA0; // weak
_UNKNOWN unk_101BEB44; // weak
_UNKNOWN unk_101BEBE8; // weak
_UNKNOWN unk_101BEC8C; // weak
_UNKNOWN unk_101BED30; // weak
_UNKNOWN unk_101BEDD4; // weak
_UNKNOWN unk_101BEE78; // weak
_UNKNOWN unk_101BEF1C; // weak
_UNKNOWN unk_101BEFC0; // weak
_UNKNOWN unk_101BF064; // weak
_UNKNOWN unk_101BF108; // weak
_UNKNOWN unk_101BF1AC; // weak
_UNKNOWN unk_101BF250; // weak
_UNKNOWN unk_101BF2F4; // weak
_UNKNOWN unk_101BF398; // weak
_UNKNOWN unk_101BF43C; // weak
_UNKNOWN unk_101BF4E0; // weak
_UNKNOWN unk_101BF584; // weak
_UNKNOWN unk_101BF628; // weak
_UNKNOWN unk_101BF6CC; // weak
_UNKNOWN unk_101BF770; // weak
_UNKNOWN unk_101BF814; // weak
_UNKNOWN unk_101BF8B8; // weak
_UNKNOWN unk_101BF95C; // weak
_UNKNOWN unk_101BFA00; // weak
_UNKNOWN unk_101BFAA4; // weak
_UNKNOWN unk_101BFB48; // weak
_UNKNOWN unk_101BFBEC; // weak
_UNKNOWN unk_101BFC90; // weak
_UNKNOWN unk_101BFD34; // weak
_UNKNOWN unk_101BFDD8; // weak
_UNKNOWN unk_101BFE7C; // weak
_UNKNOWN unk_101BFF20; // weak
_UNKNOWN unk_101BFFC4; // weak
_UNKNOWN unk_101C0068; // weak
_UNKNOWN unk_101C010C; // weak
_UNKNOWN unk_101C01B0; // weak
_UNKNOWN unk_101C0254; // weak
_UNKNOWN unk_101C02F8; // weak
_UNKNOWN unk_101C039C; // weak
_UNKNOWN unk_101C0440; // weak
_UNKNOWN unk_101C04E4; // weak
_UNKNOWN unk_101C0588; // weak
_UNKNOWN unk_101C062C; // weak
_UNKNOWN unk_101C06D0; // weak
_UNKNOWN unk_101C0774; // weak
_UNKNOWN unk_101C0818; // weak
_UNKNOWN unk_101C08BC; // weak
_UNKNOWN unk_101C0960; // weak
_UNKNOWN unk_101C0A04; // weak
_UNKNOWN unk_101C0AA8; // weak
_UNKNOWN unk_101C0B4C; // weak
_UNKNOWN unk_101C0BF0; // weak
_UNKNOWN unk_101C0C94; // weak
_UNKNOWN unk_101C0D38; // weak
_UNKNOWN unk_101C0DDC; // weak
_UNKNOWN unk_101C0E80; // weak
_UNKNOWN unk_101C0F24; // weak
_UNKNOWN unk_101C0FC8; // weak
_UNKNOWN unk_101C106C; // weak
_UNKNOWN unk_101C1110; // weak
_UNKNOWN unk_101C11B4; // weak
_UNKNOWN unk_101C1258; // weak
_UNKNOWN unk_101C12FC; // weak
_UNKNOWN unk_101C13A0; // weak
_UNKNOWN unk_101C1444; // weak
_UNKNOWN unk_101C14E8; // weak
_UNKNOWN unk_101C158C; // weak
_UNKNOWN unk_101C1630; // weak
_UNKNOWN unk_101C16D4; // weak
_UNKNOWN unk_101C1778; // weak
_UNKNOWN unk_101C181C; // weak
_UNKNOWN unk_101C18C0; // weak
_UNKNOWN unk_101C1964; // weak
_UNKNOWN unk_101C1A08; // weak
_UNKNOWN unk_101C1AAC; // weak
_UNKNOWN unk_101C1B50; // weak
_UNKNOWN unk_101C1BF4; // weak
_UNKNOWN unk_101C1C98; // weak
_UNKNOWN unk_101C1D3C; // weak
_UNKNOWN unk_101C1DE0; // weak
_UNKNOWN unk_101C1E84; // weak
_UNKNOWN unk_101C1F28; // weak
_UNKNOWN unk_101C1FCC; // weak
_UNKNOWN unk_101C2070; // weak
_UNKNOWN unk_101C2114; // weak
_UNKNOWN unk_101C21B8; // weak
_UNKNOWN unk_101C225C; // weak
_UNKNOWN unk_101C2300; // weak
_UNKNOWN unk_101C23A4; // weak
_UNKNOWN unk_101C2448; // weak
_UNKNOWN unk_101C24EC; // weak
_UNKNOWN unk_101C2590; // weak
_UNKNOWN unk_101C2634; // weak
_UNKNOWN unk_101C26D8; // weak
_UNKNOWN unk_101C26F8; // weak
_UNKNOWN unk_101C2718; // weak
_UNKNOWN unk_101C2738; // weak
_UNKNOWN unk_101C2758; // weak
_UNKNOWN unk_101C2780; // weak
_UNKNOWN unk_101C279C; // weak
_UNKNOWN unk_101C27B8; // weak
_UNKNOWN unk_101C27D4; // weak
_UNKNOWN unk_101C27F0; // weak
_UNKNOWN unk_101C280C; // weak
_UNKNOWN unk_101C2828; // weak
_UNKNOWN unk_101C2844; // weak
_UNKNOWN unk_101C2860; // weak
_UNKNOWN unk_101C287C; // weak
_UNKNOWN unk_101C2898; // weak
_UNKNOWN unk_101C28B4; // weak
_UNKNOWN unk_101C28D0; // weak
_UNKNOWN unk_101C28EC; // weak
_UNKNOWN unk_101C2908; // weak
_UNKNOWN unk_101C2924; // weak
_UNKNOWN unk_101C2940; // weak
_UNKNOWN unk_101C295C; // weak
_UNKNOWN unk_101C2978; // weak
_UNKNOWN unk_101C2994; // weak
_UNKNOWN unk_101C29B0; // weak
_UNKNOWN unk_101C29CC; // weak
_UNKNOWN unk_101C29E8; // weak
_UNKNOWN unk_101C2A04; // weak
_UNKNOWN unk_101C2A20; // weak
_UNKNOWN unk_101C2A3C; // weak
_UNKNOWN unk_101C2A58; // weak
_UNKNOWN unk_101C2A74; // weak
_UNKNOWN unk_101C2A90; // weak
_UNKNOWN unk_101C2AAC; // weak
_UNKNOWN unk_101C2AC8; // weak
_UNKNOWN unk_101C2AE4; // weak
_UNKNOWN unk_101C2B00; // weak
_UNKNOWN unk_101C2B1C; // weak
_UNKNOWN unk_101C2B38; // weak
_UNKNOWN unk_101C2B54; // weak
_UNKNOWN unk_101C2B70; // weak
_UNKNOWN unk_101C2B8C; // weak
_UNKNOWN unk_101C2BA8; // weak
_UNKNOWN unk_101C2BC4; // weak
_UNKNOWN unk_101C2BE0; // weak
_UNKNOWN unk_101C2BFC; // weak
_UNKNOWN unk_101C2C18; // weak
_UNKNOWN unk_101C2C34; // weak
_UNKNOWN unk_101C2C50; // weak
_UNKNOWN unk_101C2C6C; // weak
_UNKNOWN unk_101C2C88; // weak
_UNKNOWN unk_101C2CA4; // weak
_UNKNOWN unk_101C2CC0; // weak
_UNKNOWN unk_101C2CDC; // weak
_UNKNOWN unk_101C2CF8; // weak
_UNKNOWN unk_101C2D14; // weak
_UNKNOWN unk_101C2D30; // weak
_UNKNOWN unk_101C2D4C; // weak
_UNKNOWN unk_101C2D68; // weak
_UNKNOWN unk_101C2D84; // weak
_UNKNOWN unk_101C2DA0; // weak
_UNKNOWN unk_101C2DBC; // weak
_UNKNOWN unk_101C2DD8; // weak
_UNKNOWN unk_101C2DF4; // weak
_UNKNOWN unk_101C2E10; // weak
_UNKNOWN unk_101C2E2C; // weak
_UNKNOWN unk_101C2E48; // weak
_UNKNOWN unk_101C2E64; // weak
_UNKNOWN unk_101C2E80; // weak
_UNKNOWN unk_101C2E9C; // weak
_UNKNOWN unk_101C2EB8; // weak
_UNKNOWN unk_101C2ED4; // weak
_UNKNOWN unk_101C2EF0; // weak
_UNKNOWN unk_101C2F0C; // weak
_UNKNOWN unk_101C2F28; // weak
_UNKNOWN unk_101C2F44; // weak
_UNKNOWN unk_101C2F60; // weak
_UNKNOWN unk_101C2F7C; // weak
_UNKNOWN unk_101C2F98; // weak
_UNKNOWN unk_101C2FB4; // weak
_UNKNOWN unk_101C2FD0; // weak
_UNKNOWN unk_101C2FEC; // weak
_UNKNOWN unk_101C3008; // weak
_UNKNOWN unk_101C3024; // weak
_UNKNOWN unk_101C3040; // weak
_UNKNOWN unk_101C305C; // weak
_UNKNOWN unk_101C3078; // weak
_UNKNOWN unk_101C3094; // weak
_UNKNOWN unk_101C30B0; // weak
_UNKNOWN unk_101C30CC; // weak
_UNKNOWN unk_101C30E8; // weak
_UNKNOWN unk_101C3104; // weak
_UNKNOWN unk_101C3120; // weak
_UNKNOWN unk_101C313C; // weak
_UNKNOWN unk_101C3158; // weak
_UNKNOWN unk_101C3174; // weak
_UNKNOWN unk_101C3190; // weak
_UNKNOWN unk_101C31AC; // weak
_UNKNOWN unk_101C31C8; // weak
_UNKNOWN unk_101C31E4; // weak
_UNKNOWN unk_101C3200; // weak
_UNKNOWN unk_101C321C; // weak
_UNKNOWN unk_101C3238; // weak
_UNKNOWN unk_101C3254; // weak
_UNKNOWN unk_101C3270; // weak
_UNKNOWN unk_101C3274; // weak
_UNKNOWN unk_101C3278; // weak
_UNKNOWN unk_101C327C; // weak
_UNKNOWN unk_101C3280; // weak
_UNKNOWN unk_101C3284; // weak
_UNKNOWN unk_101C3288; // weak
_UNKNOWN unk_101C328C; // weak
_UNKNOWN unk_101C3290; // weak
_UNKNOWN unk_101C3294; // weak
_UNKNOWN unk_101C3298; // weak
_UNKNOWN unk_101C329C; // weak
_UNKNOWN unk_101C32A0; // weak
_UNKNOWN unk_101C32A4; // weak
_UNKNOWN unk_101C32A8; // weak
_UNKNOWN unk_101C32AC; // weak
_UNKNOWN unk_101C32B0; // weak
_UNKNOWN unk_101C32B4; // weak
_UNKNOWN unk_101C32B8; // weak
_UNKNOWN unk_101C339C; // weak
_UNKNOWN unk_101C455C; // weak
_UNKNOWN unk_101C4560; // weak
_UNKNOWN unk_101C4588; // weak
_UNKNOWN unk_101C45B0; // weak
_UNKNOWN unk_101C45F0; // weak
_UNKNOWN unk_101C4670; // weak
_UNKNOWN unk_101C4674; // weak
_UNKNOWN unk_101C4678; // weak
_UNKNOWN unk_101C467A; // weak
_UNKNOWN unk_101C467C; // weak
_UNKNOWN unk_101C467D; // weak
_UNKNOWN unk_101C467E; // weak
_UNKNOWN unk_101C4680; // weak
_UNKNOWN unk_101C46E4; // weak
_UNKNOWN unk_101C46EC; // weak
_UNKNOWN unk_101C46F4; // weak
_UNKNOWN unk_101C46FC; // weak
_UNKNOWN unk_101C4704; // weak
_UNKNOWN unk_101C470C; // weak
_UNKNOWN unk_101C4714; // weak
_UNKNOWN unk_101C471C; // weak
_UNKNOWN unk_101C4724; // weak
_UNKNOWN unk_101C472C; // weak
_UNKNOWN unk_101C4734; // weak
_UNKNOWN unk_101C473C; // weak
_UNKNOWN unk_101C4744; // weak
_UNKNOWN unk_101C474C; // weak
_UNKNOWN unk_101C4754; // weak
_UNKNOWN unk_101C475C; // weak
_UNKNOWN unk_101C4764; // weak
_UNKNOWN unk_101C476C; // weak
_UNKNOWN unk_101C4774; // weak
_UNKNOWN unk_101C477C; // weak
_UNKNOWN unk_101C4784; // weak
_UNKNOWN unk_101C478C; // weak
_UNKNOWN unk_101C4794; // weak
_UNKNOWN unk_101C479C; // weak
_UNKNOWN unk_101C47A4; // weak
_UNKNOWN unk_101C47AC; // weak
_UNKNOWN unk_101C47B4; // weak
_UNKNOWN unk_101C47BC; // weak
_UNKNOWN unk_101C47C4; // weak
_UNKNOWN unk_101C47CC; // weak
_UNKNOWN unk_101C47D4; // weak
_UNKNOWN unk_101C47DC; // weak
_UNKNOWN unk_101C47E4; // weak
_UNKNOWN unk_101C47EC; // weak
_UNKNOWN unk_101C47F4; // weak
_UNKNOWN unk_101C47FC; // weak
_UNKNOWN unk_101C4804; // weak
_UNKNOWN unk_101C480C; // weak
_UNKNOWN unk_101C4814; // weak
_UNKNOWN unk_101C481C; // weak
_UNKNOWN unk_101C4A04; // weak
_UNKNOWN unk_101C4A14; // weak
_UNKNOWN unk_101C4A24; // weak
_UNKNOWN unk_101C4A34; // weak
_UNKNOWN unk_101C4A35; // weak
_UNKNOWN unk_101C4A36; // weak
_UNKNOWN unk_101C4A38; // weak
_UNKNOWN unk_101C4A3C; // weak
_UNKNOWN unk_101C4AE4; // weak
_UNKNOWN unk_101C4AE8; // weak
_UNKNOWN unk_101C4AEC; // weak
_UNKNOWN unk_101C4B3C; // weak
_UNKNOWN unk_101C4B40; // weak
_UNKNOWN unk_101C4B44; // weak
_UNKNOWN unk_101C4C34; // weak
_UNKNOWN unk_101C4D24; // weak
_UNKNOWN unk_101C4D28; // weak
_UNKNOWN unk_101C4D30; // weak
_UNKNOWN unk_101C4D38; // weak
_UNKNOWN unk_101C4D40; // weak
_UNKNOWN unk_101C4D48; // weak
_UNKNOWN unk_101C4D50; // weak
_UNKNOWN unk_101C4D58; // weak
_UNKNOWN unk_101C4D60; // weak
_UNKNOWN unk_101C4D68; // weak
_UNKNOWN unk_101C4D70; // weak
_UNKNOWN unk_101C4D78; // weak
_UNKNOWN unk_101C4D80; // weak
_UNKNOWN unk_101C4D84; // weak
_UNKNOWN unk_101C4D88; // weak
_UNKNOWN unk_101C4D8C; // weak
_UNKNOWN unk_101C4DE0; // weak
_UNKNOWN unk_101C4E34; // weak
_UNKNOWN unk_101C4E3C; // weak
_UNKNOWN unk_101C4E40; // weak
_UNKNOWN unk_101C4E44; // weak
_UNKNOWN unk_101C4E48; // weak
_UNKNOWN unk_101C4E4C; // weak
_UNKNOWN unk_101C5054; // weak
_UNKNOWN unk_101C51B4; // weak
_UNKNOWN unk_101C51CC; // weak
_UNKNOWN unk_101C51E4; // weak
_UNKNOWN unk_101C51EE; // weak
_UNKNOWN unk_101C51F0; // weak
_UNKNOWN unk_101C5200; // weak
_UNKNOWN unk_101C5204; // weak
_UNKNOWN unk_101C5208; // weak
_UNKNOWN unk_101C520C; // weak
_UNKNOWN unk_101C520D; // weak
_UNKNOWN unk_101C5210; // weak
_UNKNOWN unk_101C5260; // weak
_UNKNOWN unk_101C5264; // weak
_UNKNOWN unk_101C5265; // weak
_UNKNOWN unk_101C5266; // weak
_UNKNOWN unk_101C5267; // weak
_UNKNOWN unk_101C527B; // weak
_UNKNOWN unk_101C527C; // weak
_UNKNOWN unk_101C527D; // weak
_UNKNOWN unk_101C527E; // weak
_UNKNOWN unk_101C5280; // weak
_UNKNOWN unk_101C5320; // weak
_UNKNOWN unk_101C5370; // weak
_UNKNOWN unk_101C5374; // weak
_UNKNOWN unk_101C5378; // weak
_UNKNOWN unk_101C537C; // weak
_UNKNOWN unk_101C5380; // weak
_UNKNOWN unk_101C5384; // weak
_UNKNOWN unk_101C5388; // weak
_UNKNOWN unk_101C538C; // weak
_UNKNOWN unk_101C5390; // weak
_UNKNOWN unk_101C5394; // weak
_UNKNOWN unk_101C5398; // weak
_UNKNOWN unk_101C539C; // weak
_UNKNOWN unk_101C53A0; // weak
_UNKNOWN unk_101C54E0; // weak
_UNKNOWN unk_101C54EC; // weak
_UNKNOWN unk_101C5534; // weak
_UNKNOWN unk_101C5535; // weak
_UNKNOWN unk_101C5560; // weak
_UNKNOWN unk_101C5590; // weak
_UNKNOWN unk_101C55B8; // weak
_UNKNOWN unk_101C55BC; // weak
_UNKNOWN unk_101C55C0; // weak
_UNKNOWN unk_101C55C4; // weak
_UNKNOWN unk_101C55F4; // weak
_UNKNOWN unk_101C55F5; // weak
_UNKNOWN unk_101C55F6; // weak
_UNKNOWN unk_101C55F8; // weak
_UNKNOWN unk_101C55FC; // weak
_UNKNOWN unk_101C5600; // weak
_UNKNOWN unk_101C5604; // weak
_UNKNOWN unk_101C5608; // weak
_UNKNOWN unk_101C560C; // weak
_UNKNOWN unk_101C5610; // weak
_UNKNOWN unk_101C5614; // weak
_UNKNOWN unk_101C5618; // weak
_UNKNOWN unk_101C561C; // weak
_UNKNOWN unk_101C597C; // weak
_UNKNOWN unk_101C5980; // weak
_UNKNOWN unk_101C598A; // weak
_UNKNOWN unk_101C5994; // weak
char byte_101C7154; // weak
char byte_101C7160[]; // weak
char byte_101C7161[]; // weak
__int16 word_101C7162; // weak
__int16 word_101C7164; // weak
int dword_101C7168; // weak
char byte_101C716C[]; // weak
char byte_101C7170[]; // weak
char byte_101C7174[]; // weak
char byte_101C7178[]; // weak
int dword_101C717C; // weak
int dword_101C7180; // weak
__int16 word_101C7184; // weak
_UNKNOWN unk_101C7186; // weak
char byte_101C719B[]; // weak
int dword_101C719C; // weak
char byte_101DE860[]; // weak
int dword_101E0F70[]; // weak
int dword_101E0F74[]; // weak
_UNKNOWN unk_101F47F0; // weak
_UNKNOWN unk_101F8678; // weak
_UNKNOWN unk_101F867A; // weak
_UNKNOWN unk_101F8699; // weak
_UNKNOWN unk_101F86CC; // weak
_UNKNOWN unk_101F86E1; // weak
char byte_101F86F6[]; // weak
char byte_101F86F7[]; // weak
int dword_101F86F8[]; // weak
__int16 word_101F86FC[]; // weak
char byte_101F86FE[]; // weak
char byte_101F86FF[]; // weak
char byte_101F8700[]; // weak
char byte_101F8701[]; // weak
__int16 word_101F8702[]; // weak
int dword_101F8704[]; // weak
int dword_101F8708[]; // weak
__int16 word_101F870C[]; // weak
int dword_101F8710[]; // weak
__int16 word_101F8714[]; // weak
char byte_1021F778[]; // weak
_UNKNOWN unk_1021F7D8; // weak
_UNKNOWN unk_10221718; // weak
__int16 word_102217B4[]; // weak
_UNKNOWN unk_102255A0; // weak
char byte_10226EA0; // weak
int dword_10227544[]; // weak
char byte_10227558[254]; // idb
char byte_10227656[]; // weak
char byte_10227657[]; // weak
char byte_10227A58[2800]; // idb
char byte_10228548[1022]; // idb
char byte_10228946[]; // weak
char byte_10228947[]; // weak
char byte_10228948[1022]; // idb
char byte_10228D46[]; // weak
char byte_10228D47[]; // weak
char byte_10228D48[1022]; // idb
char byte_10229146[]; // weak
char byte_10229147[]; // weak
int dword_1022C148[]; // weak
int dword_1022C15C[]; // weak
char byte_1022C170[2800]; // idb
char byte_1022CC60[2800]; // idb
char byte_1022D750[2800]; // idb
int dword_1022E240[]; // weak
int dword_1022E254[]; // weak
char byte_1022E268[2796]; // idb
char byte_1022ED54[]; // weak
char byte_1022ED58[559]; // idb
char byte_1022EF87[]; // weak
int dword_1022F848[]; // weak
int dword_1022F85C[]; // weak
char byte_1022F870[2800]; // idb
char byte_10230360; // weak
char byte_10230361; // weak
int dword_10230368; // weak
int dword_1023036C; // weak
int dword_10230370; // weak
int dword_10230374; // weak
int dword_10230378; // weak
int dword_1023037C; // weak
char byte_10230380; // weak
int dword_10230388; // weak
_UNKNOWN unk_10230390; // weak
char byte_10230668[]; // weak
char byte_10230669[]; // weak
char byte_10230688[]; // weak
char byte_10230689[]; // weak
_UNKNOWN unk_102318D0; // weak
int dword_10233280; // weak
int dword_10233284; // weak
int dword_10233288; // weak
int dword_1023328C; // weak
int dword_10233290; // weak
int dword_102332A0[]; // weak
int dword_102332A4; // weak
int dword_102332A8; // weak
int dword_102332AC; // weak
int dword_102332B0; // weak
int dword_102332B4[]; // weak
int dword_102332B8; // weak
int dword_102332BC; // weak
int dword_102332C0; // weak
int dword_102332C4; // weak
_UNKNOWN unk_102332C8; // weak
char byte_102333E0; // idb
int dword_102334E0; // weak
_UNKNOWN unk_102334E8; // weak
_UNKNOWN unk_10234040; // weak
int dword_102363A8; // weak
_UNKNOWN unk_102363B0; // weak
int dword_102378F0; // weak
char byte_102378F8[]; // weak
char byte_102378FC[]; // weak
char byte_102378FD[]; // weak
int dword_10237904[]; // weak
int dword_1023790C[]; // weak
int dword_10237940; // weak
char byte_10237948[]; // weak
char byte_10237998[]; // weak
char byte_10241580[]; // weak
char byte_10241581[]; // weak
_UNKNOWN unk_10241620; // weak
int dword_102418F0[]; // weak
int dword_102418F4[]; // weak
_UNKNOWN unk_10241E10; // weak
_UNKNOWN unk_10244D18; // weak
_UNKNOWN unk_10245218; // weak
_UNKNOWN unk_102452C0; // weak
char byte_102452E0; // weak
char byte_102452E1; // weak
char byte_102452E2; // weak
char byte_102452E3; // weak
_UNKNOWN unk_102452E8; // weak
_UNKNOWN unk_10245308; // weak
_UNKNOWN unk_102464E8; // weak
_UNKNOWN unk_1024BCE8; // weak
char byte_102514E8[]; // weak
__int16 word_102514EA[]; // weak
_UNKNOWN unk_10252DE8; // weak
int dword_10252E08; // weak
char byte_10252E12; // weak
_UNKNOWN unk_10252E24; // weak
__int16 word_10252F08[]; // weak
__int16 word_10252F0A[]; // weak
__int16 word_10252F0C[]; // weak
char byte_10252F0E[]; // weak
__int16 word_10254E48[]; // weak
__int16 word_10254EE4[]; // weak
_DWORD dword_10258CD0[16]; // idb
int dword_10258D10[]; // weak
int dword_10258D50; // weak
int dword_10258D58[]; // weak
int dword_10258DC8; // weak
int dword_102590F4; // weak
int dword_102590FC; // weak
int dword_10259108; // weak
int dword_10259730; // weak
int dword_1025973C; // weak
int dword_10259748; // weak
int dword_1025974C; // weak
int dword_10259750; // weak
int dword_1025976C; // weak
int dword_10259770; // weak
int dword_10259774; // weak
int dword_10259778; // weak
int dword_1025977C; // weak
_UNKNOWN unk_10266F80; // weak
_UNKNOWN unk_1027E680; // weak
_UNKNOWN unk_102A5780; // weak
char byte_102ACCB0; // weak
int dword_102ACCC0; // weak
int dword_102ACCC4; // weak
int dword_102ACCC8; // weak
int dword_102ACCCC; // weak
int dword_102ACCD0; // weak
char byte_102ACCD4; // weak
int dword_102ACCD8; // weak
char byte_102ACCDC; // weak
int dword_102ACCE0; // weak
char byte_102ACCE4; // weak
int dword_102ACCE8; // weak
int dword_102ACCEC; // weak
int dword_102ACCF0; // weak
char byte_102ACCF4; // weak
int dword_102ACD00[]; // weak
__int16 word_102ACD04[]; // weak
int dword_102ACD08[]; // weak
int dword_102ACD0C; // weak
int dword_102ACD10; // weak
int dword_102ACD14; // weak
int dword_102ACD18; // weak
__int16 word_102ACD1C; // weak
int dword_102ACD20; // weak
int dword_102ACD68; // weak
int dword_102ACD84; // weak
__int16 word_102ACD88; // weak
int dword_102ACDC8; // weak
int dword_102ACDF8; // weak
int dword_102ACE40; // weak
int dword_102ACEE8; // weak
int dword_102ACEF4; // weak
int dword_102ACF04; // weak
__int16 word_102ACF08; // weak
int dword_102ACF10; // weak
__int16 word_102ACF14; // weak
int dword_102ACF1C; // weak
__int16 word_102ACF20; // weak
int dword_102AD024; // weak
int dword_102AD09C; // weak
__int16 word_102AD0A0; // weak
_UNKNOWN unk_102AD408; // weak
_UNKNOWN unk_102AD409; // weak
_UNKNOWN unk_102AD40A; // weak
__int16 word_102AD420[]; // weak
__int16 word_102AD422; // weak
__int16 word_102AD424; // weak
__int16 word_102AD426; // weak
__int16 word_102AD428; // weak
__int16 word_102AD42A; // weak
__int16 word_102AD42C; // weak
__int16 word_102AD42E; // weak
__int16 word_102AD444; // weak
__int16 word_102AD446; // weak
char byte_102AD54C; // weak
char byte_102AD54D; // weak
int dword_102AD550; // weak
char byte_102AD554; // weak
int dword_102AD558; // weak
int dword_102AD560; // weak
int dword_102AD564; // weak
int dword_102AD568; // weak
int dword_102AD56C; // weak
int dword_102AD570; // weak
int dword_102AD574; // weak
int dword_102AD578; // weak
int dword_102AD580; // weak
int dword_102AD584; // weak
int dword_102AD588; // weak
int dword_102AD58C; // weak
int dword_102AD590; // weak
void *dword_102AD5AC; // idb
int dword_102AE5C0; // weak
int dword_102AE5C4; // weak
UINT uNumber; // idb
int dword_102AE5E0[]; // weak
int dword_102AE6E0; // weak
int dword_102AE6F8; // weak


//----- (10001000) --------------------------------------------------------
char **sub_10001000()
{
  return off_10060E3C;
}
// 10060E3C: using guessed type char *off_10060E3C[3];

//----- (10001010) --------------------------------------------------------
double __cdecl sub_10001010(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 >= (double)a1 )
    result = a2;
  return result;
}

//----- (10001130) --------------------------------------------------------
double __cdecl sub_10001130(float a1)
{
  double v1; // st7@1
  double result; // st7@2
  float v3; // [sp+4h] [bp+4h]@2
  float v4; // [sp+4h] [bp+4h]@3

  v1 = a1;
  if ( a1 >= 43030.883 )
  {
    v4 = 15857.9462890625 - v1 * 0.08669999986886978;
    result = v4;
  }
  else
  {
    v3 = 55158.07421875 - v1;
    result = v3;
  }
  return result;
}

//----- (10001170) --------------------------------------------------------
bool __usercall sub_10001170@<al>(unsigned __int8 a1@<al>, char a2@<bl>, signed int a3, signed int a4, char a5)
{
  signed int v5; // ecx@2
  int v6; // esi@2
  int v7; // edx@2
  signed int v8; // eax@3
  double v9; // st7@5
  bool result; // al@12
  float v11; // [sp+4h] [bp-8h]@5
  float v12; // [sp+8h] [bp-4h]@10

  if ( a1 >= 5u )
  {
    sub_100129A0("..\\lib\\adl\\mon_alrt_trgr.c", 1330, 0, 0);
    return a2;
  }
  v5 = a4;
  v6 = a1;
  v7 = dword_10061664[a1];
  if ( a4 == v7 )
    return a2;
  v8 = a3;
  if ( a3 == v7 )
    return a2;
  switch ( v6 )
  {
    case 0:
      v8 = (unsigned __int8)a3;
      v5 = (unsigned __int8)a4;
      v11 = (double)(unsigned __int8)a3;
      v9 = (double)(unsigned __int8)a4;
      break;
    case 1:
      v11 = (double)(unsigned int)a3;
      v9 = (double)(unsigned int)a4;
      break;
    case 3:
      v8 = (unsigned __int16)a3;
      v5 = (unsigned __int16)a4;
      v11 = (double)(signed __int16)a3;
      v9 = (double)(signed __int16)a4;
      break;
    case 4:
      v11 = (double)a3;
      v9 = (double)a4;
      break;
    default:
      v11 = *(float *)&a3;
      v9 = *(float *)&a4;
      break;
  }
  v12 = v9;
  switch ( a5 )
  {
    case 0:
      if ( v12 <= (double)v11 )
        goto LABEL_12;
      return 1;
    case 1:
      if ( v12 < (double)v11 )
        goto LABEL_12;
      return 1;
    case 2:
      if ( v12 >= (double)v11 )
        goto LABEL_12;
      return 1;
    case 3:
      if ( v12 > (double)v11 )
        goto LABEL_12;
      return 1;
    case 4:
      if ( v12 != v11 )
        goto LABEL_12;
      result = 1;
      break;
    case 5:
      if ( v12 == v11 )
LABEL_12:
        result = 0;
      else
        result = 1;
      break;
    case 7:
      result = (v8 & v5) != 0;
      break;
    case 8:
      result = (v8 & v5) == 0;
      break;
    case 9:
      result = (v5 & v8) == v5;
      break;
    case 0xA:
      result = (v5 & v8) != v5;
      break;
    default:
      return a2;
  }
  return result;
}
// 10061664: using guessed type int dword_10061664[];

//----- (10001370) --------------------------------------------------------
char __usercall sub_10001370@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10013B60(0, &v5);
  v2 = sub_10013B80(0, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( v2 )
    {
      if ( v6 < v3 )
      {
        result = 1;
        *a1 = v5;
        return result;
      }
      v5 = v6;
      v3 = v6;
    }
    *a1 = v3;
    result = 1;
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100013E0) --------------------------------------------------------
char __usercall sub_100013E0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10013B10(0, &v5);
  v2 = sub_10013AC0(0, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( v2 )
    {
      if ( v6 < v3 )
      {
        result = 1;
        *a1 = v5;
        return result;
      }
      v5 = v6;
      v3 = v6;
    }
    *a1 = v3;
    result = 1;
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10001450) --------------------------------------------------------
char __usercall sub_10001450@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10013B10(1, &v5);
  v2 = sub_10013AC0(1, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( v2 )
    {
      if ( v6 < v3 )
      {
        result = 1;
        *a1 = v5;
        return result;
      }
      v5 = v6;
      v3 = v6;
    }
    *a1 = v3;
    result = 1;
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100014C0) --------------------------------------------------------
bool *__usercall sub_100014C0@<eax>(unsigned __int16 a1@<ax>, bool *a2)
{
  bool v2; // zf@1
  bool *result; // eax@1

  v2 = sub_10013C20(byte_100FF9F8[2 * a1], byte_100FF9F9[2 * a1]) == 0;
  result = a2;
  *a2 = !v2;
  return result;
}

//----- (10001500) --------------------------------------------------------
char __usercall sub_10001500@<al>(size_t a1@<edi>, int a2@<esi>, __int16 a3, void *a4)
{
  char v4; // bl@1
  int v5; // eax@1

  v4 = 0;
  v5 = j_reg_get_tag_info((unsigned __int16)a3, 0);
  a2 = (unsigned __int16)a2;
  a1 = (unsigned __int16)a1;
  if ( v5 >= (unsigned __int16)a1 + (unsigned __int16)a2 && !sub_1003E040((unsigned __int16)a3, (int)&unk_100FFA78, v5) )
  {
    v4 = 1;
    memcpy(a4, (char *)&unk_100FFA78 + a2, a1);
  }
  return v4;
}
// 1003E030: using guessed type int __cdecl j_reg_get_tag_info(_DWORD, _DWORD);

//----- (10001550) --------------------------------------------------------
BOOL __usercall sub_10001550@<eax>(_BYTE *a1@<esi>, unsigned __int8 a2)
{
  BOOL result; // eax@1
  char v3; // [sp+0h] [bp-FCh]@1
  char v4[200]; // [sp+30h] [bp-CCh]@2

  result = sub_10013EF0((int)&v3);
  if ( (_BYTE)result )
    *a1 = v4[2 * a2];
  else
    *a1 = 0;
  return result;
}
// 10001550: using guessed type char var_CC[200];

//----- (100015B0) --------------------------------------------------------
int __cdecl sub_100015B0(float a1)
{
  float v1; // ST00_4@1
  float v2; // ST00_4@2
  double v3; // st7@2
  double v4; // st6@2
  double v5; // st6@4
  float v7; // [sp+Ch] [bp+4h]@2
  float v8; // [sp+Ch] [bp+4h]@6

  v1 = flt_100EF808 - a1;
  if ( COERCE_FLOAT(LODWORD(v1) & 0x7FFFFFFF) > 30.48 )
  {
    v2 = pow(a1, 2.0);
    v3 = a1;
    v7 = v2 * 0.00006959750317037106 - 1.345610022544861 * a1 + 6494.43994140625;
    v4 = 0.0;
    if ( v7 > 0.0 )
      v4 = v7;
    flt_100EF800 = v4;
    v5 = flt_100EF800;
    if ( flt_100EF800 >= 1800.0 )
      v5 = 1800.0;
    v8 = v5;
    flt_100EF800 = v8;
    flt_100EF808 = v3;
  }
  return (signed __int64)flt_100EF800;
}
// 100EF800: using guessed type float flt_100EF800;
// 100EF808: using guessed type float flt_100EF808;

//----- (10001690) --------------------------------------------------------
char __cdecl sub_10001690(int a1)
{
  char result; // al@1

  result = 1;
  if ( HIWORD(a1) <= 0x7C5u
    || HIWORD(a1) > 0x84Eu
    || HIWORD(a1) == 2126 && (unsigned __int8)a1 > 2u
    || HIWORD(a1) == 2126 && (_BYTE)a1 == 2 && BYTE1(a1) > 4u )
  {
    result = 0;
  }
  return result;
}

//----- (100016D0) --------------------------------------------------------
char __usercall sub_100016D0@<al>(int a1@<eax>, char *a2)
{
  *a2 = sub_10014340(*(_WORD *)(a1 + 2));
  return 1;
}

//----- (100016F0) --------------------------------------------------------
char __cdecl sub_100016F0(_BYTE *a1)
{
  char v1; // cl@1
  double v2; // st6@4
  float v4; // [sp+0h] [bp-10h]@1
  float v5; // [sp+4h] [bp-Ch]@1
  float v6; // [sp+8h] [bp-8h]@1
  float v7; // [sp+Ch] [bp-4h]@1

  v4 = 9.8999998e24;
  sub_1003E0A0(2103, &v6, 4, &v4);
  sub_100149F0(&v7);
  v1 = sub_100145C0(&v5);
  if ( v1 )
  {
    if ( v5 < 7467.6 )
    {
      if ( v6 == 9.8999998e24 )
      {
        v2 = 2438.4;
      }
      else
      {
        v2 = 2438.4;
        if ( v6 > 2438.4 )
        {
          *a1 = 1;
          return v1;
        }
      }
      if ( v7 != 9.8999998e24 && v2 < v7 )
      {
        *a1 = 1;
        return v1;
      }
    }
    *a1 = 0;
  }
  return v1;
}

//----- (100017C0) --------------------------------------------------------
BOOL __cdecl sub_100017C0(char *a1)
{
  char v1; // al@1
  char v2; // bl@1
  bool v3; // zf@21
  char v5; // [sp+5h] [bp-Bh]@1
  char v6; // [sp+6h] [bp-Ah]@1
  char v7; // [sp+7h] [bp-9h]@1
  float v8; // [sp+8h] [bp-8h]@1
  float v9; // [sp+Ch] [bp-4h]@1

  v7 = sub_10014620(&v9);
  sub_10014B00((bool *)&v6);
  v1 = sub_10014A20(&v8);
  v2 = byte_1010527C;
  v5 = v1;
  if ( v6 && !byte_100EF815 || v1 && v8 < 121.92 && flt_100EF80C > 121.92 )
  {
    v2 = 1;
    dword_100EF81C = sub_1003DC90();
  }
  byte_100EF815 = v6;
  if ( v5 )
    flt_100EF80C = v8;
  if ( byte_1010527C && (unsigned int)(sub_1003DC90() - dword_10105280) > 0x15F90
    || v5 && v8 > 182.88
    || byte_100EF815 && (unsigned int)(sub_1003DC90() - dword_100EF81C) > 0x61A8
    || !v7
    || v9 < 20.57777777777778 )
  {
    v2 = 0;
  }
  else if ( v2 && !byte_1010527C )
  {
    dword_10105280 = sub_1003DC90();
  }
  v3 = v7 == 0;
  byte_1010527C = v2;
  *a1 = v2;
  return !v3 || v5;
}
// 100EF80C: using guessed type float flt_100EF80C;
// 100EF815: using guessed type char byte_100EF815;
// 100EF81C: using guessed type int dword_100EF81C;
// 1010527C: using guessed type char byte_1010527C;
// 10105280: using guessed type int dword_10105280;

//----- (10001900) --------------------------------------------------------
char __cdecl sub_10001900(char *a1)
{
  char v1; // al@1
  char v2; // bl@1
  char result; // al@18
  char v4; // [sp+5h] [bp-Fh]@1
  char v5; // [sp+6h] [bp-Eh]@1
  char v6; // [sp+7h] [bp-Dh]@1
  float v7; // [sp+8h] [bp-Ch]@1
  float v8; // [sp+Ch] [bp-8h]@1
  float v9; // [sp+10h] [bp-4h]@10

  v4 = sub_10014620(&v7);
  sub_10014B00((bool *)&v5);
  v1 = sub_100145C0(&v8);
  v2 = byte_100EF814;
  v6 = v1;
  if ( v1 && (!v5 && byte_100EF816 || v4 && v7 >= 25.72222222222222 && flt_100EF818 < 25.72222222222222) )
  {
    v2 = 1;
    dword_10105284 = sub_1003DC90();
    sub_1003E110(2103, (int)&v8, 4);
  }
  byte_100EF816 = v5;
  if ( v4 )
    flt_100EF818 = v7;
  sub_1003E040(2103, (int)&v9, 4);
  if ( (!byte_100EF814 || (unsigned int)(sub_1003DC90() - dword_100FF9F4) <= 0x15F90)
    && (!v6 || v9 + 121.9199981689453 >= v8)
    && (byte_100EF816 || (unsigned int)(sub_1003DC90() - dword_10105284) <= 0x61A8)
    && v4
    && v7 >= 20.57777777777778 )
  {
    if ( v2 )
    {
      if ( !byte_100EF814 )
        dword_100FF9F4 = sub_1003DC90();
    }
    *a1 = v2;
    result = v4;
    byte_100EF814 = v2;
  }
  else
  {
    *a1 = 0;
    result = v4;
    byte_100EF814 = 0;
  }
  return result;
}
// 100EF814: using guessed type char byte_100EF814;
// 100EF816: using guessed type char byte_100EF816;
// 100EF818: using guessed type float flt_100EF818;
// 100FF9F4: using guessed type int dword_100FF9F4;
// 10105284: using guessed type int dword_10105284;

//----- (10001A80) --------------------------------------------------------
char __usercall sub_10001A80@<al>(_DWORD *a1@<edi>)
{
  char v1; // bl@1
  unsigned int v2; // esi@3
  int v3; // ST18_4@3
  unsigned int v4; // esi@5
  unsigned int v5; // eax@5
  int v7; // [sp+8h] [bp-14h]@3
  unsigned __int64 v8; // [sp+Ch] [bp-10h]@1
  unsigned int v9; // [sp+14h] [bp-8h]@1
  unsigned int v10; // [sp+18h] [bp-4h]@1

  v1 = 0;
  v9 = 0;
  v10 = 0;
  v8 = 0i64;
  if ( sub_10013680(1, 1, 0, 8, &v9) )
  {
    if ( sub_10013680(1, 2, 0, 8, &v8) )
    {
      v2 = v10;
      LOBYTE(v3) = (v10 >> 16) & 0xF;
      HIWORD(v3) = (v10 >> 20) & 0xFFF;
      BYTE1(v3) = (v10 >> 11) & 0x1F;
      HIWORD(v7) = (HIDWORD(v8) >> 20) & 0xFFF;
      LOBYTE(v7) = (HIDWORD(v8) >> 16) & 0xF;
      BYTE1(v7) = (HIDWORD(v8) >> 11) & 0x1F;
      if ( sub_10001690(v3) )
      {
        if ( sub_10001690(v7) )
        {
          v1 = 1;
          v4 = sub_10014F20(__PAIR__(v2, v9));
          v5 = sub_10014F20(v8);
          if ( v4 >= v5 )
          {
            *a1 = v4 - v5;
            return 1;
          }
          *a1 = v5 - v4;
        }
      }
    }
  }
  return v1;
}

//----- (10001B90) --------------------------------------------------------
char __usercall sub_10001B90@<al>(int a1@<ecx>, float *a2@<edx>, double a3@<st0>)
{
  int v3; // esi@1
  char v4; // bl@1
  float *v5; // edi@1
  char v6; // al@7
  double v7; // st7@12
  double v8; // st6@12
  char v9; // al@41
  unsigned int v10; // eax@57
  char v11; // al@64
  char v12; // al@82
  double v13; // st7@95
  bool v14; // zf@95
  double v15; // st6@95
  char v16; // al@101
  unsigned int v17; // esi@121
  char v18; // al@126
  char v19; // al@129
  char v20; // al@132
  char v21; // al@135
  char v22; // al@138
  bool v23; // cl@144
  char v24; // al@145
  char v25; // al@163
  char v26; // al@173
  double v27; // st7@175
  double v28; // st6@175
  char v29; // al@197
  int v30; // eax@199
  double v31; // st7@211
  double v32; // st7@215
  char v33; // bl@244
  signed int v34; // esi@245
  unsigned int v35; // ST08_4@245
  int v36; // eax@245
  int v37; // ecx@247
  char v38; // al@257
  char v39; // al@262
  char v40; // al@268
  char v41; // al@274
  char v42; // al@289
  int v43; // eax@298
  bool v44; // al@300
  double v45; // st7@305
  double v46; // st7@306
  int v48; // [sp+0h] [bp-5E4h]@274
  int *v49; // [sp+4h] [bp-5E0h]@274
  int *v50; // [sp+Ch] [bp-5D8h]@6
  int v51; // [sp+1Ch] [bp-5C8h]@6
  float v52; // [sp+20h] [bp-5C4h]@5
  char v53[4]; // [sp+24h] [bp-5C0h]@2
  float v54; // [sp+28h] [bp-5BCh]@100
  char v55; // [sp+2Eh] [bp-5B6h]@39
  char v56; // [sp+2Fh] [bp-5B5h]@41
  double v57; // [sp+30h] [bp-5B4h]@70
  int v58; // [sp+38h] [bp-5ACh]@197
  int v59; // [sp+3Ch] [bp-5A8h]@245
  char v60[4]; // [sp+40h] [bp-5A4h]@244
  int v61; // [sp+44h] [bp-5A0h]@245
  float v62; // [sp+48h] [bp-59Ch]@143
  float v63; // [sp+4Ch] [bp-598h]@153
  float v64; // [sp+50h] [bp-594h]@144
  float v65; // [sp+54h] [bp-590h]@144
  double v66; // [sp+58h] [bp-58Ch]@244
  double v67; // [sp+60h] [bp-584h]@244
  int v68; // [sp+68h] [bp-57Ch]@266
  int v69; // [sp+6Ch] [bp-578h]@266
  int v70; // [sp+70h] [bp-574h]@266
  int v71; // [sp+74h] [bp-570h]@266
  int v72; // [sp+78h] [bp-56Ch]@244
  char v73; // [sp+80h] [bp-564h]@228
  char v74; // [sp+81h] [bp-563h]@229
  double v75; // [sp+88h] [bp-55Ch]@215
  char v76; // [sp+90h] [bp-554h]@35
  char v77; // [sp+A3h] [bp-541h]@35
  char v78; // [sp+CCh] [bp-518h]@213
  float v79; // [sp+F0h] [bp-4F4h]@215
  char v80; // [sp+114h] [bp-4D0h]@224
  char v81; // [sp+115h] [bp-4CFh]@225
  char v82; // [sp+135h] [bp-4AFh]@226

  v3 = a1;
  v4 = 0;
  v5 = a2;
  switch ( *(_WORD *)(a1 + 2) )
  {
    case 0:
      sub_10014B00((bool *)v53);
      v4 = 1;
      *(_BYTE *)v5 = v53[0];
      return v4;
    case 1:
      return sub_10014920(a2);
    case 3:
      return sub_1003E040(10016, (int)a2, 1) == 0;
    case 4:
      if ( !sub_100188F0(0x7Eu, &v52) )
        goto LABEL_10;
      v50 = &v51;
      goto LABEL_7;
    case 5:
      if ( !sub_100188F0(0x7Fu, &v52) )
        goto LABEL_10;
      v6 = sub_100188F0(0x35u, (float *)&v51);
      goto LABEL_8;
    case 6:
      if ( !sub_100188F0(0x7Cu, &v52) )
        goto LABEL_10;
      v50 = &v51;
LABEL_7:
      v6 = sub_100188F0(0x1Cu, (float *)v50);
      goto LABEL_8;
    case 7:
      if ( !sub_100188F0(0x7Du, &v52) )
        goto LABEL_10;
      v6 = sub_100188F0(0x35u, (float *)&v51);
LABEL_8:
      if ( v6 )
        v4 = 1;
      else
LABEL_10:
        v4 = 0;
      *(_BYTE *)v5 = 0;
      if ( !v4 )
        return v4;
      v7 = *(float *)&v51;
      v8 = v52;
      goto LABEL_13;
    case 0xC:
      if ( !sub_100199E0(&v52) || !sub_10019D60((float *)&v51) )
        goto LABEL_23;
      goto LABEL_112;
    default:
      goto LABEL_23;
    case 8:
      if ( !sub_100188F0(0x1Fu, &v52) || !sub_100188F0(0x38u, (float *)&v51) )
        goto LABEL_23;
      v4 = 1;
      *v5 = sub_10001010(v52, *(float *)&v51);
      return v4;
    case 9:
      return sub_100017C0((char *)a2);
    case 0xA:
      return sub_10001900((char *)a2);
    case 0xB:
      return sub_100016F0(a2);
    case 0xD:
      return sub_100199E0(a2);
    case 0xE:
      return sub_100198A0(a2);
    case 0xF:
      return sub_10019D60(a2);
    case 0x22:
      return sub_10019E30(a2);
    case 2:
      return sub_100145C0(a2);
    case 0x10:
      v4 = sub_1001A470(&v76);
      *(_BYTE *)v5 = (v77 & 1) == 1;
      return v4;
    case 0x11:
      v4 = sub_1001A470(&v76);
      *(_BYTE *)v5 = (v77 & 2) == 2;
      return v4;
    case 0x12:
      if ( !sub_1001A1A0(111, v53) )
        v53[0] = 0;
      if ( !sub_1001A1A0(119, &v55) )
        v55 = 0;
      v9 = sub_1001A1A0(120, &v56);
      if ( v9 )
        v9 = v56;
      v4 = 1;
      if ( !v53[0] || !v55 || !v9 )
        goto LABEL_46;
      goto LABEL_227;
    case 0x13:
      return sub_10018FB0(0, (bool *)a2);
    case 0x14:
      return sub_10018FB0(1, (bool *)a2);
    case 0x15:
      if ( *(_BYTE *)(dword_102AD588 + 23) == 2 )
        v4 = sub_1003E040(9139, (int)a2, 1) == 0;
      else
        v4 = sub_10019010(0, (bool *)a2);
      return v4;
    case 0x16:
      if ( *(_BYTE *)(dword_102AD588 + 23) == 2 )
        v4 = sub_1003E040(9140, (int)a2, 1) == 0;
      else
        v4 = sub_10019010(1, (bool *)a2);
      return v4;
    case 0x19:
      return sub_10014620(a2);
    case 0x1A:
      v4 = sub_10014840(&v52);
      if ( v4 )
      {
        v10 = sub_1003DC90();
        if ( v10 > dword_10105278 )
        {
          dword_10105278 = v10 + 1000;
          flt_100FFA70 = flt_100FFA70 * 0.8999999761581421 + v52 * 0.1000000014901161;
        }
        *v5 = flt_100FFA70;
      }
      return v4;
    case 0x1B:
      return sub_10014720(a2);
    case 0x1C:
      return sub_1003E040(9131, (int)a2, 1) == 0;
    case 0x1E:
      return sub_10014A90(a2);
    case 0x1F:
      v4 = 0;
      if ( sub_1003E040(2103, (int)&v52, 4) )
        return v4;
      v11 = sub_100145C0(&v51);
      goto LABEL_65;
    case 0x20:
      v4 = 0;
      sub_100149F0(&v51);
      if ( !sub_100188F0(0xC5u, &v52) )
        return sub_10014A20(v5);
      if ( *(float *)&v51 == 9.8999998e24 || v52 == 9.8999998e24 )
        return v4;
      *(float *)&v57 = v52 - *(float *)&v51;
      LODWORD(v57) &= 0x7FFFFFFFu;
      if ( *(float *)&v57 < 1.524 && sub_10014920((float *)&v51) )
        goto LABEL_66;
      if ( *(float *)&v57 >= 1.524 )
        return sub_10014A20(v5);
      return v4;
    case 0x1D:
      return sub_10014A20(v5);
    case 0x21:
      return sub_10019F70((char *)a2);
    case 0x24:
      return sub_10019070(a2);
    case 0x25:
      v4 = 0;
      v52 = sub_10019DD0();
      if ( v52 != 9.8999998e24 )
      {
        *v5 = v52;
        v4 = 1;
      }
      return v4;
    case 0x26:
      if ( sub_100188F0(0x75u, &v52) && sub_10019ED0(v52, (int)&v51) )
      {
        v4 = 1;
        *v5 = *(float *)&v51;
      }
      return v4;
    case 0x27:
      if ( !sub_100188F0(0x75u, &v52) )
        return v4;
      v12 = sub_10014780(&v51);
      goto LABEL_83;
    case 0x28:
      *(_BYTE *)a2 = sub_10015180(a1);
      return 1;
    case 0x29:
      *(_BYTE *)a2 = sub_10015E80((void *)a1);
      return 1;
    case 0x2A:
      *(_BYTE *)a2 = sub_10015EF0((void *)a1);
      return 1;
    case 0x2B:
      return sub_10001550(a2, *(_BYTE *)(a1 + 4));
    case 0x33:
      return sub_10019910(a2);
    case 0x34:
      return sub_10019930(a2);
    case 0x35:
      return sub_10018A70(a1, 0x4Eu, a2);
    case 0x36:
      return sub_10018A70(a1, 0x4Fu, a2);
    case 0x37:
    case 0x38:
      if ( sub_10013680(6, 155, 0, 4, &v52) && sub_10013680(6, 156, 0, 4, &v51) )
      {
        v4 = 1;
        v52 = sub_10018810(v52, flt_100EF810, 40, 0.0017453292);
        *(float *)&v51 = sub_10018810(*(float *)&v51, flt_100EF804, 40, 0.0017453292);
        v13 = v52;
        v14 = *(_WORD *)(v3 + 2) == 55;
        flt_100EF810 = v52;
        v15 = *(float *)&v51;
        flt_100EF804 = *(float *)&v51;
        if ( v14 )
        {
          *(float *)&v57 = (v13 + v15) * 0.5;
          *v5 = sub_10041C70(*(float *)&v57, 0.0017453292);
        }
        else
        {
          *(float *)&v57 = v15 - v13;
          LODWORD(v57) &= 0x7FFFFFFFu;
          *v5 = sub_10041C70(*(float *)&v57, 0.0017453292);
        }
      }
      return v4;
    case 0x39:
      if ( sub_10013680(6, 151, 0, 4, &v52) && sub_10013680(6, 174, 0, 4, &v51) )
      {
        v4 = 1;
        v54 = *(float *)&v51 - v52;
        *(_DWORD *)v5 = LODWORD(v54) & 0x7FFFFFFF;
      }
      return v4;
    case 0x3A:
      v53[0] = sub_100188F0(0x6Du, &v52);
      v16 = sub_100188F0(0x6Eu, (float *)&v51);
      if ( v53[0] == 1 )
      {
        v4 = 1;
        if ( v16 == 1 )
          *v5 = *(float *)&v51 + v52;
        else
          *v5 = v52;
      }
      else if ( v16 == 1 )
      {
        v4 = 1;
        *v5 = *(float *)&v51;
      }
      return v4;
    case 0x3B:
      if ( sub_100188F0(0x6Du, &v52) && sub_100188F0(0x6Eu, (float *)&v51) )
      {
        v4 = 1;
        v52 = sub_10001010(v52, 0.0);
        *(float *)&v51 = sub_10001010(*(float *)&v51, 0.0);
        v54 = *(float *)&v51 - v52;
        *(_DWORD *)v5 = LODWORD(v54) & 0x7FFFFFFF;
      }
      return v4;
    case 0x3C:
      if ( sub_100188F0(0x6Du, &v52) && sub_100188F0(0x6Eu, (float *)&v51) )
      {
LABEL_112:
        v4 = 1;
        *v5 = v52 - *(float *)&v51;
      }
      return v4;
    case 0x3D:
      if ( sub_100188F0(0x6Du, &v52) )
      {
        v11 = sub_100188F0(0x6Eu, (float *)&v51);
LABEL_65:
        if ( v11 )
        {
LABEL_66:
          v4 = 1;
          *v5 = *(float *)&v51 - v52;
        }
      }
      return v4;
    case 0x3E:
      return sub_1003E040(9172, (int)a2, 1) == 0;
    case 0x3F:
      return sub_100147E0(a2);
    case 0x40:
      return sub_100013E0(a2);
    case 0x41:
      return sub_10001450(a2);
    case 0x42:
      if ( byte_100EF817 == 1 && sub_100145C0(&v52) )
      {
        v4 = 1;
        v17 = (sub_1003DC90() - dword_100FFA74) / 0x3E8u;
        *(_BYTE *)v5 = v17 >= sub_100015B0(v52);
      }
      return v4;
    case 0x43:
      if ( byte_100EF817 == 1 )
      {
        v4 = 1;
        *(_DWORD *)a2 = (sub_1003DC90() - dword_100FFA74) / 0x3E8u;
      }
      return v4;
    case 0x44:
      v53[0] = sub_100188F0(0x176u, &v52);
      v12 = sub_100188F0(0x173u, (float *)&v51);
      if ( v53[0] )
        goto LABEL_83;
      return v4;
    case 0x45:
      v53[0] = sub_100188F0(0xABu, &v52);
      v18 = sub_100188F0(0xAEu, (float *)&v51);
      if ( v53[0] && v18 )
      {
        v4 = 1;
        v54 = *(float *)&v51 - v52;
        *(_DWORD *)v5 = LODWORD(v54) & 0x7FFFFFFF;
      }
      return v4;
    case 0x46:
      v53[0] = sub_100188F0(0x169u, &v52);
      v19 = sub_100188F0(0x16Au, (float *)&v51);
      if ( v53[0] && v19 )
      {
        v4 = 1;
        v54 = *(float *)&v51 - v52;
        *(_DWORD *)v5 = LODWORD(v54) & 0x7FFFFFFF;
      }
      return v4;
    case 0x47:
      v53[0] = sub_100188F0(0x19u, &v52);
      v20 = sub_100188F0(0x32u, (float *)&v51);
      if ( v53[0] && v20 )
      {
        v4 = 1;
        v54 = *(float *)&v51 - v52;
        *(_DWORD *)v5 = LODWORD(v54) & 0x7FFFFFFF;
      }
      return v4;
    case 0x48:
      v53[0] = sub_100188F0(0x1Au, &v52);
      v21 = sub_100188F0(0x33u, (float *)&v51);
      if ( v53[0] && v21 )
      {
        v4 = 1;
        v54 = *(float *)&v51 - v52;
        *(_DWORD *)v5 = LODWORD(v54) & 0x7FFFFFFF;
      }
      return v4;
    case 0x49:
      v53[0] = sub_100188F0(0x16Eu, &v52);
      v22 = sub_100188F0(0x16Fu, (float *)&v51);
      if ( v53[0] && v22 )
      {
        v4 = 1;
        v54 = *(float *)&v51 - v52;
        *(_DWORD *)v5 = LODWORD(v54) & 0x7FFFFFFF;
      }
      return v4;
    case 0x4A:
      return sub_1003E040(9214, (int)a2, 1) == 0;
    case 0x4B:
      if ( !sub_100188F0(0x174u, &v52) || sub_1003E040(9220, (int)&v62, 16) )
        return v4;
      v23 = v65 < (double)v52;
      if ( v64 <= (double)v52 )
        goto LABEL_146;
      v24 = 1;
      goto LABEL_147;
    case 0x4C:
      if ( sub_100188F0(0x175u, &v52) && !sub_1003E040(9220, (int)&v62, 16) )
      {
        v23 = v63 < (double)v52;
        if ( v62 <= (double)v52 )
LABEL_146:
          v24 = 0;
        else
          v24 = 1;
LABEL_147:
        if ( v23 || v24 )
        {
          *(_BYTE *)v5 = 0;
          v4 = 1;
        }
        else
        {
          *(_BYTE *)v5 = 1;
          v4 = 1;
        }
      }
      return v4;
    case 0x4D:
      return sub_10015D90(a2);
    case 0x4E:
      if ( !sub_100188F0(0x16u, &v52) || !sub_100188F0(0x11Fu, (float *)&v51) )
        return v4;
      *(float *)&v51 = sub_10001130(*(float *)&v51);
      v7 = v52;
      v4 = 1;
      v8 = *(float *)&v51;
      *(_BYTE *)v5 = 0;
      goto LABEL_13;
    case 0x4F:
      if ( !sub_100188F0(0x2Fu, &v52) || !sub_100188F0(0x120u, (float *)&v51) )
        return v4;
      *(float *)&v51 = sub_10001130(*(float *)&v51);
      v7 = v52;
      v4 = 1;
      v8 = *(float *)&v51;
      *(_BYTE *)v5 = 0;
      goto LABEL_13;
    case 0x50:
      if ( !sub_100188F0(0x3Cu, &v52) )
        return v4;
      v25 = sub_100188F0(0x41u, (float *)&v51);
      goto LABEL_164;
    case 0x51:
      if ( !sub_100188F0(0x1Du, &v52) || !sub_10013680(1, 1828, 0, 4, &v51) )
        return v4;
      v7 = v52;
      v4 = 1;
      v8 = *(float *)&v51;
      *(_BYTE *)v5 = 0;
      goto LABEL_13;
    case 0x52:
      if ( !sub_100188F0(0x36u, &v52) || !sub_10013680(1, 1829, 0, 4, &v51) )
        return v4;
      v7 = v52;
      v4 = 1;
      v8 = *(float *)&v51;
      *(_BYTE *)v5 = 0;
      goto LABEL_13;
    case 0x53:
      if ( !sub_100188F0(0x1Du, &v52) )
        return v4;
      v26 = sub_100188F0(0x80u, (float *)&v51);
      goto LABEL_174;
    case 0x54:
      if ( !sub_100188F0(0x36u, &v52) )
        return v4;
      v26 = sub_100188F0(0x81u, (float *)&v51);
      goto LABEL_174;
    case 0x55:
      if ( !sub_100188F0(0x186u, &v52) )
        return v4;
      v26 = sub_100188F0(0x188u, (float *)&v51);
      goto LABEL_174;
    case 0x56:
      if ( !sub_100188F0(0x187u, &v52) )
        return v4;
      v26 = sub_100188F0(0x189u, (float *)&v51);
      goto LABEL_174;
    case 0x57:
      if ( !sub_100188F0(0x180u, &v52) )
        return v4;
      v26 = sub_100188F0(0x182u, (float *)&v51);
      goto LABEL_174;
    case 0x58:
      if ( !sub_100188F0(0x181u, &v52) )
        return v4;
      v26 = sub_100188F0(0x183u, (float *)&v51);
      goto LABEL_174;
    case 0x59:
      if ( !sub_100187B0(0x127u, &v52) || !sub_10013680(1, 1971, 0, 4, &v51) )
        return v4;
      v7 = v52;
      v4 = 1;
      v8 = *(float *)&v51;
      *(_BYTE *)v5 = 0;
      goto LABEL_13;
    case 0x5A:
      if ( !sub_100187B0(0x128u, &v52) || !sub_10013680(1, 1972, 0, 4, &v51) )
        return v4;
      v7 = v52;
      v4 = 1;
      v8 = *(float *)&v51;
      *(_BYTE *)v5 = 0;
      goto LABEL_13;
    case 0x5C:
      if ( !sub_100188F0(0x121u, &v52) )
        return v4;
      v26 = sub_10013680(1, 1973, 0, 4, &v51);
      goto LABEL_174;
    case 0x5D:
      if ( !sub_100188F0(0x122u, &v52) )
        return v4;
      v26 = sub_10013680(1, 1974, 0, 4, &v51);
      goto LABEL_174;
    case 0x5E:
      v29 = sub_10013680(1, 996, 0, 4, &v58);
      goto LABEL_198;
    case 0x5F:
      v29 = sub_10013680(1, 1004, 0, 4, &v58);
LABEL_198:
      if ( v29 )
      {
        v30 = v58;
        v14 = (v58 & 0x40000) == 0;
        *(_BYTE *)v5 = 0;
        v4 = 1;
        if ( !v14 )
          *(_BYTE *)v5 = 1;
        if ( v30 & 0x80000 )
          ++*(_BYTE *)v5;
        if ( v30 & 0x100000 )
          ++*(_BYTE *)v5;
        if ( v30 & 0x200000 )
          ++*(_BYTE *)v5;
        if ( v30 & 0x400000 )
          ++*(_BYTE *)v5;
      }
      return v4;
    case 0x60:
      sub_10016320();
      if ( sub_10001450(&v52) )
      {
        v53[0] = sub_100145C0(&v51);
        v57 = v52;
        v31 = *(float *)(dword_102AD588 + 23308);
        sub_10016140(*(float *)(dword_102AD588 + 23308), *(float *)&v51, v53[0]);
        *(_BYTE *)v5 = v31 + *(float *)(dword_102AD588 + 23316) <= v57;
        v4 = 1;
      }
      if ( sub_100013E0(&v52) )
      {
        v53[0] = 0;
        if ( sub_10016500(512, &v78) )
        {
          v14 = *(_BYTE *)v5 == 0;
          v53[0] = 1;
          if ( v14
            && (v75 = v52,
                *(float *)&v57 = v79 * 1.943844437599182,
                v32 = *(float *)&v57,
                sub_10016280(*(float *)&v57),
                v32 * 0.5144444704055786 + *(float *)(dword_102AD588 + 23320) > v75) )
          {
            *(_BYTE *)v5 = 0;
            v4 = 1;
          }
          else
          {
            *(_BYTE *)v5 = 1;
            v4 = 1;
          }
        }
      }
      return v4;
    case 0x61:
      return sub_1003E040(9361, (int)a2, 1) == 0;
    case 0x66:
      return sub_10001370(a2);
    case 0x62:
      v4 = 0;
      if ( sub_10013B60(7, &v52) )
      {
        sub_10015E60(a3);
        v4 = 1;
        *v5 = a3 + v52;
      }
      return v4;
    case 0x63:
      v4 = 0;
      if ( sub_10013B80(7, &v51) )
      {
        sub_10015E60(a3);
        v4 = 1;
        *v5 = a3 + *(float *)&v51;
      }
      return v4;
    case 0x64:
      v4 = 0;
      if ( sub_10013680(2, 200, 0, 1228, &v80) )
      {
        v4 = 1;
        if ( v81 && v82 == 1 )
LABEL_227:
          *(_BYTE *)v5 = 1;
        else
LABEL_46:
          *(_BYTE *)v5 = 0;
      }
      return v4;
    case 0x65:
      v4 = 0;
      if ( sub_10013680(0, 260, 0, 8, &v73) )
      {
        v4 = 1;
        *(_BYTE *)v5 = v74 == 4 || v74 == 5 || v74 == 6;
      }
      return v4;
    case 0x67:
      if ( !sub_100188F0(0x1Du, &v52) || !sub_10013680(1, 2576, 0, 4, &v51) )
        return v4;
      v7 = v52;
      v4 = 1;
      v8 = *(float *)&v51;
      *(_BYTE *)v5 = 0;
      goto LABEL_13;
    case 0x68:
      if ( sub_100188F0(0x36u, &v52) && sub_10013680(1, 2577, 0, 4, &v51) )
      {
        v7 = v52;
        v4 = 1;
        v8 = *(float *)&v51;
        *(_BYTE *)v5 = 0;
LABEL_13:
        if ( v8 > v7 )
          goto LABEL_14;
      }
      return v4;
    case 0x69:
      if ( !sub_100188F0(0x1Cu, &v52) )
        return v4;
      v26 = sub_100188F0(0x78u, (float *)&v51);
      goto LABEL_174;
    case 0x6A:
      if ( sub_100188F0(0x35u, &v52) )
      {
        v26 = sub_100188F0(0x79u, (float *)&v51);
LABEL_174:
        if ( v26 )
        {
          v27 = v52;
          v4 = 1;
          v28 = *(float *)&v51;
          *(_BYTE *)v5 = 0;
          if ( v28 < v27 )
            *(_BYTE *)v5 = 1;
        }
      }
      return v4;
    case 0x6B:
      v33 = sub_10019F70(v60);
      v4 = sub_100159B0(0, (int)&v66) & v33;
      sub_10015720((int)&v72, v66, v67);
      if ( v4 )
      {
        v34 = *(_DWORD *)v60 % 0x15180u;
        v35 = *(_DWORD *)v60;
        *(_BYTE *)v5 = 0;
        sub_1000F290((int)&v72, v35, &v59, &v61);
        v36 = v59 + 1800;
        if ( (unsigned int)(v59 + 1800) > 0x15180 )
          v36 = v59 - 84600;
        v37 = v61 - 1800;
        if ( v61 - 1800 < 0 )
          v37 += 86400;
        if ( v36 >= v37 )
        {
          if ( v34 > v37 && v34 < v36 )
            *(_BYTE *)v5 = 1;
        }
        else if ( v34 < v36 )
        {
LABEL_14:
          *(_BYTE *)v5 = 1;
        }
        else if ( v34 > v37 )
        {
          *(_BYTE *)v5 = 1;
        }
      }
      return v4;
    case 0x6C:
      if ( !sub_10013B60(7, &v52) )
        goto LABEL_23;
      v38 = sub_10013B80(7, &v51);
      goto LABEL_258;
    case 0x6D:
      if ( !sub_10013B60(2, &v52) )
        goto LABEL_23;
      v38 = sub_10013B80(2, &v51);
LABEL_258:
      if ( !v38 )
        goto LABEL_23;
      v4 = 1;
      *v5 = v52 - *(float *)&v51;
      return v4;
    case 0x6E:
      v39 = sub_10015670(*(_BYTE *)(a1 + 4));
      if ( !v39 || v39 == 1 || v39 == 2 )
      {
        v4 = 1;
        *(_BYTE *)v5 = v39;
      }
      return v4;
    case 0x6F:
      v68 = 0;
      v69 = 0;
      v70 = 0;
      v71 = 0;
      *(_BYTE *)a2 = sub_100155D0(&v68);
      return 1;
    case 0x70:
      if ( sub_1003E040(9002, (int)&v52, 4) )
        return v4;
      v40 = sub_10015020(35, &v51);
      goto LABEL_269;
    case 0x71:
      if ( !sub_1003E040(9001, (int)&v52, 4) )
      {
        if ( sub_10015020(33, &v51) )
          goto LABEL_317;
        v40 = sub_10015020(31, &v51);
LABEL_269:
        if ( v40 )
        {
LABEL_317:
          v4 = 1;
          *v5 = *(float *)&v51 - v52;
        }
      }
      return v4;
    case 0x72:
      v41 = sub_10015020(4037, &v52);
      v49 = &v51;
      v48 = 4038;
      goto LABEL_275;
    case 0x73:
      v41 = sub_10015020(4039, &v52);
      v49 = &v51;
      v48 = 4040;
      goto LABEL_275;
    case 0x74:
      v53[0] = sub_10015020(4041, &v52);
      v12 = sub_10015020(4042, &v51);
      goto LABEL_276;
    case 0x75:
      v41 = sub_10015020(4043, &v52);
      v49 = &v51;
      v48 = 4044;
      goto LABEL_275;
    case 0x76:
      v41 = sub_10015020(4045, &v52);
      v49 = &v51;
      v48 = 4046;
      goto LABEL_275;
    case 0x77:
      v53[0] = sub_10015020(4047, &v52);
      v12 = sub_10015020(4048, &v51);
      goto LABEL_276;
    case 0x78:
      v41 = sub_10015020(4049, &v52);
      v49 = &v51;
      v48 = 4050;
      goto LABEL_275;
    case 0x79:
      v41 = sub_10015020(4051, &v52);
      v49 = &v51;
      v48 = 4052;
      goto LABEL_275;
    case 0x7A:
      v53[0] = sub_10015020(4053, &v52);
      v12 = sub_10015020(4054, &v51);
      goto LABEL_276;
    case 0x7B:
      v41 = sub_10015020(4055, &v52);
      v49 = &v51;
      v48 = 4056;
LABEL_275:
      v53[0] = v41;
      v12 = sub_10015020(v48, v49);
LABEL_276:
      if ( v53[0] )
      {
LABEL_83:
        if ( v12 )
        {
          v4 = 1;
          *v5 = v52 - *(float *)&v51;
        }
      }
      return v4;
    case 0x7C:
      return sub_10001A80(a2);
    case 0x7E:
      if ( sub_1003E040(9003, (int)&v52, 4) )
        return v4;
      v42 = sub_10015020(11, &v51);
      goto LABEL_290;
    case 0x7F:
      if ( sub_1003E040(9003, (int)&v52, 4) )
        return v4;
      v42 = sub_10015020(12, &v51);
      goto LABEL_290;
    case 0x80:
      if ( sub_1003E040(9003, (int)&v52, 4) )
        return v4;
      v42 = sub_10015020(13, &v51);
      goto LABEL_290;
    case 0x81:
      if ( !sub_1003E040(9003, (int)&v52, 4) )
      {
        v42 = sub_10015020(14, &v51);
LABEL_290:
        if ( v42 )
        {
          v4 = 1;
          *(float *)&v51 = *(float *)&v51 * 1.799999952316284 + 32.0;
          *v5 = *(float *)&v51 - v52;
        }
      }
      return v4;
    case 0x7D:
      v53[0] = sub_10014FB0(&v52);
      v43 = sub_1003E040(9145, (int)&v51, 4);
      *v5 = 0.0;
      v25 = v43 == 0;
      if ( v53[0] )
      {
LABEL_164:
        if ( v25 )
        {
          v4 = 1;
          *v5 = v52 - *(float *)&v51;
        }
      }
      return v4;
    case 0x82:
      v53[0] = sub_10015020(1, &v52);
      v44 = sub_1003E040(41110, (int)&v51, 4) == 0;
      if ( !v53[0] || !v44 )
        return v4;
      v4 = 1;
      v52 = v52 * 100.0;
      if ( *(float *)&v51 >= (double)v52 )
        goto LABEL_304;
      *(_BYTE *)v5 = 1;
      break;
    case 0x83:
      v52 = 0.0;
      sub_10001450(&v52);
      v45 = v52;
      if ( v52 >= 0.2300000041723251 )
      {
        if ( v45 >= 0.34 )
          v46 = -2.5999999;
        else
          v46 = 5.300000190734863 - v45 * 23.0;
      }
      else
      {
        v46 = 0.0;
      }
      *(float *)&v51 = v46;
      if ( sub_10013680(6, 738, 0, 4, &v54) || sub_10013680(6, 739, 0, 4, &v54) )
      {
        v4 = 1;
        if ( *(float *)&v51 + 14.5 >= v54 )
LABEL_304:
          *(_BYTE *)v5 = 0;
        else
          *(_BYTE *)v5 = 1;
      }
      else
      {
LABEL_23:
        v4 = 0;
      }
      break;
  }
  return v4;
}
// 100EF804: using guessed type float flt_100EF804;
// 100EF810: using guessed type float flt_100EF810;
// 100EF817: using guessed type char byte_100EF817;
// 100FFA70: using guessed type float flt_100FFA70;
// 100FFA74: using guessed type int dword_100FFA74;
// 10105278: using guessed type int dword_10105278;
// 102AD588: using guessed type int dword_102AD588;

//----- (100036F0) --------------------------------------------------------
__int16 __usercall sub_100036F0@<ax>(double st7_0@<st0>, int a1, char a2, int a3, int a4, int a5, char a6)
{
  int v7; // esi@1
  size_t v8; // edi@1
  void *v9; // ecx@1
  _BYTE *v10; // ebp@1
  int v11; // eax@1
  char v12; // bl@1
  int v13; // esi@11
  void *v14; // esi@18
  signed int v15; // eax@24
  char v16; // al@39
  int v17; // eax@43
  bool v18; // zf@46
  unsigned int v19; // eax@49
  char *v20; // ecx@64
  double v21; // st7@65
  double v22; // st6@67
  double v23; // rt1@69
  double v24; // st6@69
  double v25; // st7@69
  float v26; // ST24_4@69
  double v27; // st6@69
  double v28; // rt2@71
  double v29; // st6@71
  double v30; // st7@71
  float v31; // ST24_4@71
  float v32; // ST24_4@73
  unsigned int v33; // edx@73
  double v34; // st7@74
  float v35; // ST2C_4@76
  double v36; // st7@76
  float v37; // ST2C_4@78
  double v38; // st7@78
  float v39; // ST2C_4@80
  double v40; // st7@80
  float v41; // ST2C_4@82
  double v42; // st7@82
  float v43; // ST2C_4@84
  double v44; // st7@84
  int v45; // eax@86
  float v46; // ST2C_4@86
  float v47; // ST24_4@87
  double v48; // st7@87
  unsigned __int8 v49; // al@91
  char *v50; // ecx@97
  double v51; // st7@98
  double v52; // st6@100
  double v53; // rt0@102
  double v54; // st6@102
  double v55; // st7@102
  float v56; // ST24_4@102
  double v57; // st6@102
  double v58; // rt1@104
  double v59; // st6@104
  double v60; // st7@104
  float v61; // ST24_4@104
  float v62; // ST24_4@106
  int v63; // eax@107
  char v64; // bl@113
  int v65; // esi@115
  int v66; // eax@133
  signed int v67; // edx@133
  char v68; // ST0C_1@133
  int v69; // eax@136
  char v70; // ST0C_1@136
  int v71; // eax@138
  char v72; // al@143
  unsigned int v73; // edi@144
  unsigned int v74; // eax@159
  unsigned int v75; // ebp@161
  char v76; // al@166
  float v78; // [sp+20h] [bp-5Ch]@64
  float v79; // [sp+20h] [bp-5Ch]@67
  float v80; // [sp+20h] [bp-5Ch]@69
  float v81; // [sp+20h] [bp-5Ch]@71
  float v82; // [sp+20h] [bp-5Ch]@74
  float v83; // [sp+20h] [bp-5Ch]@78
  float v84; // [sp+20h] [bp-5Ch]@82
  float v85; // [sp+20h] [bp-5Ch]@97
  float v86; // [sp+20h] [bp-5Ch]@100
  float v87; // [sp+20h] [bp-5Ch]@102
  float v88; // [sp+20h] [bp-5Ch]@104
  char v89; // [sp+27h] [bp-55h]@42
  float v90; // [sp+28h] [bp-54h]@76
  float v91; // [sp+28h] [bp-54h]@80
  float v92; // [sp+28h] [bp-54h]@84
  __int16 v93; // [sp+28h] [bp-54h]@112
  int v94; // [sp+2Ch] [bp-50h]@1
  int v95; // [sp+30h] [bp-4Ch]@1
  char v96; // [sp+35h] [bp-47h]@1
  char v97; // [sp+36h] [bp-46h]@1
  char v98; // [sp+37h] [bp-45h]@1
  unsigned int v99; // [sp+38h] [bp-44h]@1
  _BYTE v100[60]; // [sp+3Ch] [bp-40h]@24

  HIWORD(v7) = HIWORD(a4);
  HIWORD(v8) = HIWORD(a5);
  v95 = a3;
  v96 = 0;
  v97 = 1;
  v99 = sub_1003DC90();
  v10 = (_BYTE *)(((unsigned __int16)a1 << 6) + a4);
  v11 = *v10 - 1;
  v12 = 0;
  v98 = 0;
  *(float *)&v94 = 0.0;
  switch ( v11 )
  {
    case 0:
      v12 = sub_1001A1A0(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), &v94);
      break;
    case 1:
      v12 = sub_100188F0(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), (float *)&v94);
      break;
    case 5:
      if ( !sub_1001B210(a5, *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), a6, (bool *)&v97, &v96) || v97 )
      {
        LOBYTE(v94) = 2;
        goto LABEL_8;
      }
      LOBYTE(v94) = v96;
      v12 = 1;
      break;
    case 6:
      LOBYTE(v94) = sub_100137E0(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2));
      v12 = 1;
      break;
    case 10:
      v12 = sub_10013680(
              6,
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4),
              word_10061658[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)],
              &v94);
      break;
    case 2:
      v12 = sub_10013680(
              0,
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4),
              word_10061658[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)],
              &v94);
      break;
    case 3:
      v12 = sub_10013680(
              1,
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4),
              word_10061658[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)],
              &v94);
      break;
    case 4:
      v12 = sub_10013680(
              2,
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
              *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4),
              word_10061658[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)],
              &v94);
      break;
    case 11:
      LOWORD(v8) = word_10061658[*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1)];
      LOWORD(v7) = *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4);
      v12 = sub_10001500(v8, v7, *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), &v94);
      break;
    case 9:
      v14 = sub_100160B0(v9);
      if ( *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4) != 8 )
        goto LABEL_24;
      if ( sub_10015EE0(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 2)) & (unsigned int)v14
        && (unsigned int)v14 & *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 12)
        && (unsigned int)v14 & *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 20) )
      {
        if ( *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4) == 8 )
          v98 = 1;
LABEL_24:
        v15 = sub_10015EE0(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 2));
        if ( !j_HWM_pvg_hsdb_get_router_entry(v15, v100) )
        {
          v12 = 1;
          if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1) )
            v94 = *(int *)&v100[*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4)];
          else
            LOBYTE(v94) = v100[*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4)];
        }
      }
      break;
    case 7:
      v12 = sub_10001B90(((unsigned __int16)a1 << 6) + a4, (float *)&v94, st7_0);
      break;
    case 12:
      v12 = sub_100016D0(((unsigned __int16)a1 << 6) + a4, (char *)&v94);
      break;
    case 8:
      LOBYTE(v94) = sub_10013880(
                      *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2),
                      *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4));
      v12 = 1;
      break;
    case 13:
      v12 = sub_10015020(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), &v94);
      break;
    case 14:
      v12 = sub_1001AF30(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), &v94);
      break;
    case 15:
      if ( a6 )
      {
        if ( a6 == 1 )
        {
          v94 = *(int *)(16 * *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2) + dword_102ACCC8 - 15988);
          v12 = 1;
        }
      }
      else
      {
        v94 = *(int *)(16 * *(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2) + dword_102ACCC8 + 12);
        v12 = 1;
      }
      break;
    case 16:
      sub_100014C0(*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 2), (bool *)v95);
      LOBYTE(v94) = *(_BYTE *)v95;
      v12 = 1;
      break;
    default:
LABEL_8:
      v12 = 0;
      break;
  }
  if ( !(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x10) || a2 )
  {
    v13 = v95;
  }
  else
  {
    v13 = v95;
    *(_BYTE *)v95 = 0;
  }
  v16 = *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1);
  if ( v16 != 2 )
  {
    if ( v16 == 3 )
    {
      if ( !v12 )
        goto LABEL_42;
      v19 = sub_1001A930(&v94, -32768, 0x7FFF, 0, 0);
    }
    else if ( v16 == 4 )
    {
      if ( !v12 )
        goto LABEL_42;
      v19 = sub_1001A9D0(&v94, 2147483648, 0x7FFFFFFF, 0, 0);
    }
    else if ( v16 )
    {
      if ( v16 != 1 )
        sub_100129A0("..\\lib\\adl\\mon_alrt_trgr.c", 684, 0, 0);
      if ( !v12 )
        goto LABEL_42;
      v19 = sub_1001ABE0(&v94, 0, 0xFFFFFFFF, 0, 0);
    }
    else
    {
      if ( !v12 )
        goto LABEL_42;
      v19 = sub_1001AAF0((unsigned __int8 *)&v94, 0, 0xFFu, 0, 0);
    }
    if ( !v19 )
      goto LABEL_61;
LABEL_42:
    v89 = 0;
    goto LABEL_43;
  }
  if ( !v12 || sub_1001A7F0((int)&v94, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    goto LABEL_42;
LABEL_61:
  v89 = 1;
  if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 8) & 8 )
  {
    if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1) != 2 )
      sub_100129A0("..\\lib\\adl\\mon_alrt_trgr.c", 709, 0, 0);
    v20 = (char *)&unk_100EF820 + 44 * (unsigned __int16)a1;
    v78 = *((float *)v20 + 2);
    if ( *(float *)&v94 >= (double)v78 )
    {
      v21 = *(float *)&v94;
      v78 = *(float *)&v94;
    }
    else
    {
      v21 = *(float *)&v94;
    }
    v22 = v78;
    *((float *)v20 + 2) = v78;
    v79 = *((float *)v20 + 6);
    if ( v79 < v21 )
      v21 = v79;
    v23 = v22;
    v24 = v21;
    v25 = v23;
    v26 = v24;
    v27 = v26;
    *((float *)v20 + 6) = v26;
    v80 = *(float *)v20;
    if ( v80 > v23 )
      v25 = v80;
    v28 = v27;
    v29 = v25;
    v30 = v28;
    v31 = v29;
    *(float *)v20 = v31;
    v81 = *((float *)v20 + 1);
    if ( v81 < v28 )
      v30 = v81;
    v32 = v30;
    *((float *)v20 + 1) = v32;
    v33 = v99;
    if ( *((_DWORD *)v20 + 10) + *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 28) / 3u < v99 )
    {
      *(_DWORD *)v20 = *((_DWORD *)v20 + 2);
      *((_DWORD *)v20 + 1) = *((_DWORD *)v20 + 6);
      *((_DWORD *)v20 + 5) = *((_DWORD *)v20 + 4);
      v82 = *((float *)v20 + 5);
      v34 = *(float *)v20;
      if ( v82 >= v34 )
        v34 = v82;
      v35 = v34;
      *(float *)v20 = v35;
      *((_DWORD *)v20 + 9) = *((_DWORD *)v20 + 8);
      v90 = *((float *)v20 + 9);
      v36 = *((float *)v20 + 1);
      if ( v90 <= v36 )
        v36 = v90;
      v37 = v36;
      *((float *)v20 + 1) = v37;
      *((_DWORD *)v20 + 4) = *((_DWORD *)v20 + 3);
      v83 = *((float *)v20 + 4);
      v38 = *(float *)v20;
      if ( v83 >= v38 )
        v38 = v83;
      v39 = v38;
      *(float *)v20 = v39;
      *((_DWORD *)v20 + 8) = *((_DWORD *)v20 + 7);
      v91 = *((float *)v20 + 8);
      v40 = *((float *)v20 + 1);
      if ( v91 <= v40 )
        v40 = v91;
      v41 = v40;
      *((float *)v20 + 1) = v41;
      *((_DWORD *)v20 + 3) = *((_DWORD *)v20 + 2);
      v84 = *((float *)v20 + 3);
      v42 = *(float *)v20;
      if ( v84 >= v42 )
        v42 = v84;
      v43 = v42;
      *(float *)v20 = v43;
      *((_DWORD *)v20 + 7) = *((_DWORD *)v20 + 6);
      v92 = *((float *)v20 + 7);
      v44 = *((float *)v20 + 1);
      if ( v92 <= v44 )
        v44 = v92;
      v45 = v94;
      v46 = v44;
      *((float *)v20 + 2) = *(float *)&v94;
      *((float *)v20 + 1) = v46;
      *((_DWORD *)v20 + 6) = v45;
      *((_DWORD *)v20 + 10) = v33;
    }
    v47 = *(float *)v20 - *((float *)v20 + 1);
    v48 = COERCE_FLOAT(LODWORD(v47) & 0x7FFFFFFF);
LABEL_111:
    *(float *)(v13 + 12) = v48;
    goto LABEL_112;
  }
LABEL_43:
  v17 = *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8);
  if ( v17 & 0x60 )
  {
    if ( !v89 )
      goto LABEL_112;
    if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1) != 2 )
      sub_100129A0("..\\lib\\adl\\mon_alrt_trgr.c", 746, 0, 0);
    v50 = (char *)&unk_100EF820 + 44 * (unsigned __int16)a1;
    v85 = *((float *)v50 + 2);
    if ( *(float *)&v94 >= (double)v85 )
    {
      v51 = *(float *)&v94;
      v85 = *(float *)&v94;
    }
    else
    {
      v51 = *(float *)&v94;
    }
    v52 = v85;
    *((float *)v50 + 2) = v85;
    v86 = *((float *)v50 + 6);
    if ( v86 < v51 )
      v51 = v86;
    v53 = v52;
    v54 = v51;
    v55 = v53;
    v56 = v54;
    v57 = v56;
    *((float *)v50 + 6) = v56;
    v87 = *(float *)v50;
    if ( v87 > v53 )
      v55 = v87;
    v58 = v57;
    v59 = v55;
    v60 = v58;
    v61 = v59;
    *(float *)v50 = v61;
    v88 = *((float *)v50 + 1);
    if ( v88 < v58 )
      v60 = v88;
    v62 = v60;
    *((float *)v50 + 1) = v62;
    if ( !a2 )
    {
      v63 = v94;
      *((float *)v50 + 2) = *(float *)&v94;
      *(_DWORD *)v50 = v63;
      *((_DWORD *)v50 + 6) = v63;
      *((_DWORD *)v50 + 1) = v63;
    }
    if ( *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x40 )
      v48 = *(float *)v50;
    else
      v48 = *((float *)v50 + 1);
    goto LABEL_111;
  }
  if ( v89 )
  {
    if ( a2 )
      v18 = (*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x400) == 0;
    else
      v18 = (v17 & 4) == 0;
    if ( v18 )
      *(float *)(v13 + 12) = *(float *)&v94;
  }
  else
  {
    v49 = *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1);
    if ( v49 >= 5u )
    {
      *(_DWORD *)(v13 + 12) = -1;
      sub_100129A0("..\\lib\\adl\\mon_alrt_trgr.c", 802, 0, 0);
    }
    else
    {
      *(_DWORD *)(v13 + 12) = dword_10061664[v49];
    }
  }
LABEL_112:
  HIBYTE(v93) = 4;
  if ( v89 )
  {
    if ( *(_BYTE *)v13 )
    {
      if ( *(_BYTE *)v13 == 1 )
      {
        if ( a2 && *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x800 )
          v64 = 0;
        else
          v64 = sub_10001170(
                  *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
                  1,
                  *(_DWORD *)(v95 + 12),
                  *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 20),
                  *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 24)) == 0;
      }
      else
      {
        v64 = sub_10001170(
                *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
                0,
                *(_DWORD *)(v95 + 12),
                *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 12),
                *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16));
        if ( v64 && *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x800 && 0.0 != *(float *)(v95 + 16) )
          v64 = sub_10001170(
                  *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
                  0,
                  *(_DWORD *)(v95 + 12),
                  *(_DWORD *)(v95 + 16),
                  *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16));
      }
    }
    else
    {
      v65 = v95;
      v64 = sub_10001170(
              *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
              0,
              *(_DWORD *)(v95 + 12),
              *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 12),
              *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16));
      if ( v64 && *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8) & 0x800 && 0.0 != *(float *)(v65 + 16) )
      {
        v64 = sub_10001170(
                *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 1),
                0,
                *(_DWORD *)(v65 + 12),
                *(_DWORD *)(v65 + 16),
                *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16));
        goto LABEL_129;
      }
    }
  }
  else
  {
    v64 = 2;
  }
  v65 = v95;
LABEL_129:
  if ( v98 && v64 != 1 )
  {
    if ( *(_BYTE *)v65 == 1 )
      goto LABEL_174;
    if ( !j_HWM_pvg_hsdb_get_router_entry(*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 12), v100) )
    {
      *(_DWORD *)(v65 + 12) = *(_DWORD *)&v100[*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4)];
      v66 = sub_10015EE0(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 2));
      v67 = *(_DWORD *)(v65 + 12);
      v68 = *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 16);
      v94 = v66;
      v64 = sub_10001170(1u, 0, v67, v66, v68);
      goto LABEL_137;
    }
    if ( *(_BYTE *)v65 == 1 )
    {
LABEL_174:
      if ( !j_HWM_pvg_hsdb_get_router_entry(*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 20), v100) )
      {
        *(_DWORD *)(v65 + 12) = *(_DWORD *)&v100[*(_WORD *)(((unsigned __int16)a1 << 6) + a4 + 4)];
        v69 = sub_10015EE0(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 2));
        v70 = *(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 24);
        v94 = v69;
        v64 = sub_10001170(1u, 1, *(_DWORD *)(v65 + 12), v69, v70) == 0;
      }
    }
  }
LABEL_137:
  if ( v64 == 2 )
  {
    v71 = *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 8);
    if ( v71 & 1 )
    {
      v64 = 1;
      HIBYTE(v93) = 2;
      goto LABEL_143;
    }
    if ( !(v71 & 0x200) )
    {
LABEL_156:
      v73 = v99;
      goto LABEL_157;
    }
    v64 = 0;
    HIBYTE(v93) = 3;
LABEL_151:
    if ( *(_BYTE *)(v65 + 8) == 1
      && a6 == 1
      && (*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 28) || *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 32)) )
    {
      sub_100139C0(a1, 0);
    }
    goto LABEL_156;
  }
  if ( v64 != 1 )
  {
    if ( v64 )
      goto LABEL_156;
    goto LABEL_151;
  }
LABEL_143:
  v72 = *(_BYTE *)(v65 + 8);
  if ( v72 == 1 )
    goto LABEL_156;
  v73 = v99;
  if ( v72 != 2 )
    *(_DWORD *)(v65 + 4) = v99;
  if ( a6 == 1
    && (*(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 28) || *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 32)) )
  {
    sub_100139C0(a1, *(_DWORD *)(v65 + 4));
  }
LABEL_157:
  *(_BYTE *)(v65 + 8) = v64;
  if ( v64 == 1 && !(*(_BYTE *)(((unsigned __int16)a1 << 6) + a4 + 8) & 8) )
  {
    if ( (v74 = *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 28)) != 0 && v73 - *(_DWORD *)(v65 + 4) < v74
      || (v75 = *(_DWORD *)(((unsigned __int16)a1 << 6) + a4 + 32)) != 0 && v73 - *(_DWORD *)(v65 + 4) > v75 )
    {
      v64 = 0;
    }
  }
  *(_BYTE *)v65 = v64;
  if ( v89 )
    *(_DWORD *)(v65 + 16) = *(_DWORD *)(v65 + 12);
  v76 = HIBYTE(v93);
  LOBYTE(v93) = v64;
  if ( HIBYTE(v93) == 4 )
  {
    if ( v64 != 2 )
    {
      HIBYTE(v93) = v64;
      *(_BYTE *)(v65 + 1) = v64;
      return v93;
    }
    v76 = 3;
    HIBYTE(v93) = 3;
  }
  *(_BYTE *)(v65 + 1) = v76;
  return v93;
}
// 1003E350: using guessed type int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD);
// 10061658: using guessed type __int16 word_10061658[];
// 10061664: using guessed type int dword_10061664[];
// 102ACCC8: using guessed type int dword_102ACCC8;

//----- (10004230) --------------------------------------------------------
int __usercall sub_10004230@<eax>(double st7_0@<st0>, int a1, int a2, int a3, int a4)
{
  int v5; // eax@1
  int v6; // ecx@1
  char v7; // al@2
  int v8; // eax@6
  signed int v9; // edi@6
  int result; // eax@7
  char v11; // [sp+10h] [bp-4h]@1

  v5 = a3 + ((unsigned __int16)a1 << 6);
  v6 = *(_DWORD *)(v5 + 8);
  v11 = 1;
  if ( v6 & 0x100 )
  {
    v7 = *(_BYTE *)(a4 + 20 * *(_WORD *)(v5 + 36)) == 1;
  }
  else
  {
    if ( (char)v6 >= 0 )
      goto LABEL_6;
    v7 = sub_100138F0(*(_WORD *)(v5 + 36));
  }
  v11 = v7;
LABEL_6:
  v8 = dword_10117E78[(unsigned int)(unsigned __int16)a1 >> 5];
  v9 = 1 << (a1 & 0x1F);
  if ( v8 & v9 )
  {
    result = *(_DWORD *)(a4 + 20 * (unsigned __int16)a1 + 12);
  }
  else
  {
    dword_10117E78[(unsigned int)(unsigned __int16)a1 >> 5] = v9 | v8;
    sub_100036F0(st7_0, a1, v11, a4 + 20 * (unsigned __int16)a1, a3, a2, 0);
    result = *(_DWORD *)(a4 + 20 * (unsigned __int16)a1 + 12);
  }
  return result;
}
// 10117E78: using guessed type int dword_10117E78[];

//----- (100042E0) --------------------------------------------------------
__int16 __cdecl sub_100042E0(int a1, unsigned __int16 a2)
{
  int v2; // eax@1
  int v3; // edi@2
  int v4; // esi@2
  int v5; // ebp@2

  byte_101052EE = 0;
  memset(dword_10117E78, 0, 0xBCu);
  byte_101052EC = 0;
  memset(word_10106E88, 0, 0xC8u);
  memset(&unk_10105298, 0, 0x54u);
  memset(&unk_10106F50, 0, 0xFAu);
  memset(byte_10106D88, 0, 0xFAu);
  sub_1003E110(9194, (int)byte_10106D88, 250);
  sub_1003E040(6056, (int)&unk_10117F34, 4);
  LOWORD(v2) = a2;
  if ( a2 > 0u )
  {
    v3 = a1;
    v4 = 0;
    v5 = a2;
    do
    {
      v2 = -(sub_1001B2E0(v3) != 0);
      *(_DWORD *)(v4 + dword_102ACCC8 + 8) = v2;
      *(_DWORD *)(v4 + dword_102ACCC8 + 12) = 0;
      v3 += 160;
      v4 += 16;
      --v5;
    }
    while ( v5 );
  }
  return v2;
}
// 101052EC: using guessed type char byte_101052EC;
// 101052EE: using guessed type char byte_101052EE;
// 10106E88: using guessed type __int16 word_10106E88[];
// 10117E78: using guessed type int dword_10117E78[];
// 102ACCC8: using guessed type int dword_102ACCC8;

//----- (100043C0) --------------------------------------------------------
int __cdecl sub_100043C0(char a1)
{
  int result; // eax@3

  if ( a1 == 1 )
  {
    dword_102ACCC0 = dword_102AD580 + 40;
    result = dword_102AD580 + 136044;
    dword_102ACCC4 = dword_102AD580 + 120040;
    dword_102ACCC8 = dword_102AD580 + 120044;
    dword_102ACCCC = dword_102AD580 + 136044;
  }
  else if ( a1 == 2 )
  {
    dword_102ACCC0 = dword_102AD580 + 205204;
    result = dword_102AD580 + 237208;
    dword_102ACCC4 = dword_102AD580 + 229204;
    dword_102ACCC8 = dword_102AD580 + 229208;
    dword_102ACCCC = dword_102AD580 + 237208;
  }
  else
  {
    dword_102ACCC0 = dword_102AD584;
    result = dword_102AD584 + 120004;
    dword_102ACCC4 = dword_102AD584 + 120000;
    dword_102ACCC8 = dword_102AD584 + 120004;
    dword_102ACCCC = (int)&unk_10107050;
  }
  return result;
}
// 102ACCC0: using guessed type int dword_102ACCC0;
// 102ACCC4: using guessed type int dword_102ACCC4;
// 102ACCC8: using guessed type int dword_102ACCC8;
// 102ACCCC: using guessed type int dword_102ACCCC;
// 102AD580: using guessed type int dword_102AD580;
// 102AD584: using guessed type int dword_102AD584;

//----- (10004460) --------------------------------------------------------
int __usercall sub_10004460@<eax>(_WORD *a1@<eax>, int a2)
{
  int result; // eax@3
  _WORD *v3; // [sp+4h] [bp+4h]@2

  if ( byte_101052EE )
  {
    v3 = a1;
    if ( !sub_10013740(0) )
      sub_100129A0("..\\lib\\adl\\sys_usr_alrt.c", 1371, 0, "Non-alert master attempted to alter the alert's database");
    SYS_enter_krnl();
    SYS_pvg_alrt_set(v3);
    result = SYS_exit_krnl();
  }
  else
  {
    result = sub_10013930(*a1, a2, 1);
  }
  return result;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420C4: using guessed type int __cdecl SYS_pvg_alrt_set(_DWORD);
// 101052EE: using guessed type char byte_101052EE;

//----- (10004490) --------------------------------------------------------
signed int __usercall sub_10004490@<eax>(unsigned __int16 a1@<ax>)
{
  signed int result; // eax@2

  if ( a1 >= 0xFu )
  {
    sub_100129A0("..\\lib\\adl\\mon_cas.c", 2201, 0, "Unexpected requested registry for alert sync information");
    result = 42066;
  }
  else
  {
    result = (unsigned __int16)(a1 + 9012);
  }
  return result;
}

//----- (100044C0) --------------------------------------------------------
char __cdecl sub_100044C0(char a1, _DWORD *a2)
{
  __int16 v2; // ax@1
  char result; // al@2

  v2 = sub_1001CD60(&a1, 2u, (int)&unk_10090950, 12, 32, -1);
  if ( v2 == -1 )
  {
    result = 0;
  }
  else
  {
    *a2 = dword_1009094C[3 * v2];
    result = 1;
  }
  return result;
}
// 1009094C: using guessed type int dword_1009094C[];

//----- (10004510) --------------------------------------------------------
char __usercall sub_10004510@<al>(int a1@<eax>, int a2@<edx>, double st7_0@<st0>, char a3, char a4)
{
  int v5; // ecx@1
  __int16 v6; // dx@1
  unsigned __int16 v7; // si@2
  char v9; // [sp+0h] [bp-4h]@6

  a1 = (unsigned __int16)a1;
  v5 = a2 + 160 * (unsigned __int16)a1;
  v6 = *(_WORD *)(v5 + 132);
  if ( v6 )
  {
    v7 = *(_WORD *)(v5 + 148);
    if ( !v7 || (a1 *= 16, *(_DWORD *)(a1 + dword_102ACCC8 + 12) <= (unsigned int)v7) )
    {
      if ( a3 )
      {
        if ( !(*(_BYTE *)(v5 + 152) & 0x40) )
        {
          v9 = 1;
          if ( a4 )
            v9 = 3;
          LOBYTE(a1) = sub_1000CA80(st7_0, *(_WORD *)v5, v6, v9, byte_101052EC);
        }
      }
      else if ( !(*(_BYTE *)(v5 + 152) & 0x20) )
      {
        LOBYTE(a1) = sub_1000CA80(st7_0, *(_WORD *)v5, v6, 0, byte_101052EC);
      }
    }
  }
  return a1;
}
// 101052EC: using guessed type char byte_101052EC;
// 102ACCC8: using guessed type int dword_102ACCC8;

//----- (100045C0) --------------------------------------------------------
char __usercall sub_100045C0@<al>(unsigned __int16 a1@<ax>, int a2)
{
  unsigned __int16 v2; // ax@1
  bool v3; // zf@2
  char result; // al@2

  v2 = sub_10004490(a1);
  if ( v2 == -23470 || (v3 = sub_1003E040(v2, a2, 804) == 0, result = 1, !v3) )
    result = 0;
  return result;
}

//----- (10004600) --------------------------------------------------------
char __usercall sub_10004600@<al>(char a1@<al>, unsigned __int16 a2@<cx>)
{
  signed int v2; // ecx@1
  char result; // al@1

  v2 = 2 * a2;
  result = (a1 << v2 % 8) | byte_10106D88[(unsigned __int8)(v2 / 8)] & ~(1 << v2 % 8) & ~(1 << (v2 % 8 + 1));
  byte_10106D88[(unsigned __int8)(v2 / 8)] = result;
  return result;
}

//----- (10004650) --------------------------------------------------------
char __usercall sub_10004650@<al>(unsigned __int16 a1@<ax>, char a2)
{
  unsigned __int16 v2; // dx@1
  char v3; // al@1
  char v4; // cl@3
  int v5; // edx@6
  _BYTE *v6; // eax@7
  _BYTE *v7; // esi@9

  v2 = a1 >> 1;
  v3 = a1 & 1;
  if ( a2 )
  {
    if ( a2 == 1 )
      v4 = 1;
    else
      v4 = 4;
  }
  else
  {
    v4 = 2;
  }
  v5 = 3 * v2;
  if ( v3 )
  {
    v6 = (_BYTE *)(dword_102ACCC0 + 4 * v5 + 8);
    if ( !((unsigned __int8)v4 & *v6) )
    {
      *v6 |= v4;
      v6 = (_BYTE *)sub_1003DC90();
      *(_DWORD *)dword_102ACCC4 = v6;
    }
  }
  else
  {
    v7 = (_BYTE *)(dword_102ACCC0 + 4 * v5 + 8);
    LOBYTE(v6) = *v7;
    if ( !((unsigned __int8)(16 * v4) & *v7) )
    {
      *v7 |= 16 * v4;
      v6 = (_BYTE *)sub_1003DC90();
      *(_DWORD *)dword_102ACCC4 = v6;
    }
  }
  return (unsigned int)v6;
}
// 102ACCC0: using guessed type int dword_102ACCC0;
// 102ACCC4: using guessed type int dword_102ACCC4;

//----- (100046D0) --------------------------------------------------------
char __usercall sub_100046D0@<al>(int a1@<eax>, int a2@<ecx>, char a3@<bl>, int a4, char a5, _BYTE *a6)
{
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // edx@6
  int v10; // eax@7
  int v11; // edi@14
  char result; // al@22
  char v13; // [sp+Fh] [bp-9h]@1
  int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  a2 = (unsigned __int16)a2;
  v6 = 16 * (unsigned __int16)a2;
  v7 = a1;
  v8 = dword_102ACCC8;
  v14 = *(_DWORD *)(v6 + dword_102ACCC8);
  v13 = 0;
  v15 = *(_DWORD *)(v6 + dword_102ACCC8 + 4);
  if ( a5 == 1 )
  {
    if ( a3 != 1 && !*(_DWORD *)(v6 + dword_102ACCC8) && *(_DWORD *)(160 * a2 + v7 + 140) )
    {
      *(_DWORD *)(v6 + dword_102ACCC8) = a4;
      v8 = dword_102ACCC8;
      v13 = 1;
    }
    *(_DWORD *)(v6 + v8 + 4) = 0;
    v9 = *(_DWORD *)(v6 + dword_102ACCC8);
    if ( v9 )
    {
      v10 = 160 * a2 + v7;
      if ( a4 < v9 + *(_DWORD *)(v10 + 140) )
      {
        *a6 = a3;
        *(_BYTE *)(dword_102ACCC0 + 12 * *(_WORD *)(v10 + 156)) = a3;
      }
    }
  }
  else
  {
    *(_DWORD *)(v6 + dword_102ACCC8) = 0;
    if ( a3 == 1 && !*(_DWORD *)(v6 + dword_102ACCC8 + 4) && *(_DWORD *)(160 * a2 + v7 + 144) )
    {
      *(_DWORD *)(v6 + dword_102ACCC8 + 4) = a4;
      v13 = 2;
    }
    if ( *(_DWORD *)(v6 + dword_102ACCC8 + 4) )
    {
      v11 = 160 * a2 + v7;
      if ( (!(*(_BYTE *)(v11 + 152) & 4) || !sub_100137E0(*(_WORD *)v11))
        && a4 < *(_DWORD *)(v11 + 144) + *(_DWORD *)(v6 + dword_102ACCC8 + 4) )
      {
        *a6 = a3;
        *(_BYTE *)(dword_102ACCC0 + 12 * *(_WORD *)(v11 + 156)) = a3;
      }
    }
  }
  if ( *(_DWORD *)(v6 + dword_102ACCC8) || *(_DWORD *)(v6 + dword_102ACCC8 + 4) || !v14 && !v15 )
    result = v13;
  else
    result = 3;
  return result;
}
// 102ACCC0: using guessed type int dword_102ACCC0;
// 102ACCC8: using guessed type int dword_102ACCC8;

//----- (10004840) --------------------------------------------------------
char __usercall sub_10004840@<al>(unsigned __int16 a1@<ax>, int a2@<edi>)
{
  unsigned __int16 v2; // si@1
  void *v3; // ecx@1
  void *v4; // eax@1
  bool v5; // zf@2
  char result; // al@2

  v2 = sub_10004490(a1);
  v4 = sub_1001D4B0(v3);
  *(_BYTE *)(a2 + 800) = sub_1001D260((int)v4);
  if ( v2 == -23470 || (v5 = sub_1003E110(v2, a2, 804) == 0, result = 1, !v5) )
    result = 0;
  return result;
}

//----- (10004890) --------------------------------------------------------
char __cdecl sub_10004890(char a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char result; // al@4
  int v4; // [sp+8h] [bp-70h]@1
  char v5; // [sp+Ch] [bp-6Ch]@1
  char v6; // [sp+40h] [bp-38h]@1

  v2 = v1;
  memset(&v5, 0, 0x33u);
  memset(&v6, 0, 0x33u);
  if ( sub_100044C0(a1, &v4) )
    sub_1003E2F0(v4, &v5, 51, &v6);
  if ( sub_1001D770(&v5, 0x33u) <= 0 )
  {
    result = 0;
  }
  else
  {
    sub_1001D720(v2 + 33, &v5, 51);
    result = 1;
  }
  return result;
}

//----- (10004940) --------------------------------------------------------
char __usercall sub_10004940@<al>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, double st7_0@<st0>, __int16 a4, unsigned __int16 a5, int a6, char a7)
{
  int v8; // edi@1
  int v9; // esi@1
  char v10; // al@1
  int v11; // eax@18
  unsigned __int16 v12; // dx@18
  int v13; // eax@23
  int v14; // ecx@23
  int v15; // esi@23
  int v16; // eax@23
  unsigned __int16 v17; // ax@24
  bool v18; // cf@26
  bool v19; // zf@26
  int v20; // eax@32
  int v21; // ecx@32
  int v22; // eax@32
  char v23; // al@33
  unsigned int v24; // edx@37
  int v25; // eax@37
  signed int v26; // edi@37
  int v27; // ecx@38
  __int16 v28; // kr00_2@38
  int v29; // eax@41
  int v30; // ecx@41
  int v31; // esi@41
  int v32; // eax@41
  char v33; // cl@45
  char v34; // cl@49
  int v35; // eax@55
  char v37; // [sp+Dh] [bp-B3h]@15
  char v38; // [sp+Dh] [bp-B3h]@32
  char v39; // [sp+11h] [bp-AFh]@38
  char v40; // [sp+12h] [bp-AEh]@1
  char v41; // [sp+13h] [bp-ADh]@1
  int v42; // [sp+14h] [bp-ACh]@1
  int v43; // [sp+18h] [bp-A8h]@1
  int v44; // [sp+1Ch] [bp-A4h]@1
  char v45; // [sp+20h] [bp-A0h]@1
  char v46; // [sp+22h] [bp-9Eh]@23
  char v47; // [sp+B8h] [bp-8h]@22

  v8 = a2;
  v9 = a1;
  v44 = a2;
  v43 = a1;
  v42 = a6;
  memset(&v45, 0, 0x9Cu);
  v10 = *(_BYTE *)(a3 + 8 * a5 + 6);
  v40 = 0;
  v41 = 1;
  if ( !v10 || v10 == 16 || v10 == 8 || v10 == 7 || v10 == 9 || v10 == 10 || v10 == 11 || v10 == 15 || v10 == 17 )
  {
    v17 = *(_WORD *)(a3 + 8 * a5);
    if ( v17 == -1 )
      return 0;
    if ( a7 == 1 )
    {
      v18 = v17 < 0x5DCu;
      v19 = v17 == 1500;
    }
    else if ( a7 )
    {
      if ( a7 != 2 )
        goto LABEL_32;
      v18 = v17 < 0x258u;
      v19 = v17 == 600;
    }
    else
    {
      v18 = v17 < 0x5DCu;
      v19 = v17 == 1500;
    }
    if ( !v18 && !v19 )
      return 0;
LABEL_32:
    v20 = v17 << 6;
    v21 = *(_DWORD *)(v20 + v9 + 8);
    v22 = v9 + v20;
    v38 = 1;
    if ( v21 & 0x100 )
    {
      v23 = *(_BYTE *)(v42 + 20 * *(_WORD *)(v22 + 36)) == 1;
    }
    else
    {
      if ( (char)v21 >= 0 )
      {
LABEL_37:
        v24 = (unsigned int)*(_WORD *)(a3 + 8 * a5) >> 5;
        v25 = dword_10117E78[v24];
        v26 = 1 << (*(_WORD *)(a3 + 8 * a5) & 0x1F);
        if ( v25 & v26 )
        {
          v37 = *(_BYTE *)(v42 + 20 * *(_WORD *)(a3 + 8 * a5));
          v39 = *(_BYTE *)(v42 + 20 * *(_WORD *)(a3 + 8 * a5) + 1);
        }
        else
        {
          v27 = v44;
          dword_10117E78[v24] = v26 | v25;
          v28 = sub_100036F0(st7_0, *(_WORD *)(a3 + 8 * a5), v38, v42 + 20 * *(_WORD *)(a3 + 8 * a5), v9, v27, a7);
          v39 = HIBYTE(v28);
          v37 = v28;
        }
        if ( !(*(_BYTE *)((*(_WORD *)(a3 + 8 * a5) << 6) + v9 + 8) & 2) )
        {
          v29 = 6916 * (unsigned __int8)byte_101052EC;
          *(_DWORD *)(dword_102ACCCC
                    + 4 * (1729 * (unsigned __int8)byte_101052EC + *(_BYTE *)(v29 + dword_102ACCCC + 2))
                    + 20) = *(_DWORD *)(v42 + 20 * *(_WORD *)(a3 + 8 * a5) + 12);
          *(_BYTE *)(v29 + *(_BYTE *)(v29 + dword_102ACCCC + 2) + dword_102ACCCC + 420) = *(_BYTE *)((*(_WORD *)(a3 + 8 * a5) << 6) + v9 + 1);
          v30 = dword_102ACCCC;
          word_10106E88[*(_BYTE *)(v29 + dword_102ACCCC + 2)] = a5;
          sub_1001D720(
            v29 + 21 * *(_BYTE *)(v29 + v30 + 2) + v30 + 520,
            (_BYTE *)((*(_WORD *)(a3 + 8 * a5) << 6) + v9 + 38),
            21);
          v31 = (unsigned __int8)byte_101052EC;
          v32 = 6916 * (unsigned __int8)byte_101052EC;
          *(_BYTE *)(v32 + *(_BYTE *)(v32 + dword_102ACCCC + 2) + dword_102ACCCC + 3120) = v39;
          *(_BYTE *)(v32 + *(_BYTE *)(v32 + dword_102ACCCC + 2) + dword_102ACCCC + 2620) = *(_BYTE *)((*(_WORD *)(a3 + 8 * a5) << 6) + v43 + 59);
          *(_DWORD *)(dword_102ACCCC + 4 * (1729 * v31 + *(_BYTE *)(v32 + dword_102ACCCC + 2)) + 2720) = *(_DWORD *)((*(_WORD *)(a3 + 8 * a5) << 6) + v43 + 60);
          *(_WORD *)(dword_102ACCCC + 2 * (3458 * v31 + *(_BYTE *)(v32 + dword_102ACCCC + 2)) + 3220) = *(_WORD *)(a3 + 8 * a5);
          v9 = v43;
          ++*(_BYTE *)(v32 + dword_102ACCCC + 2);
        }
        switch ( *(_BYTE *)(a3 + 8 * a5 + 6) )
        {
          case 7:
            if ( v37 != 2 )
              v37 = v37 == 0;
            break;
          case 9:
            v33 = v37;
            if ( *(_BYTE *)(dword_102ACCC0 + 12 * a5 + 1) != 1 || (v37 = 1, v33 == 1) )
              v37 = 0;
            *(_BYTE *)(dword_102ACCC0 + 12 * a5 + 1) = v33;
            break;
          case 0xA:
            v34 = v37;
            if ( *(_BYTE *)(dword_102ACCC0 + 12 * a5 + 1) == 1 || (v37 = 1, v34 != 1) )
              v37 = 0;
            *(_BYTE *)(dword_102ACCC0 + 12 * a5 + 1) = v34;
            break;
          case 0x10:
            if ( v37 == 1 )
              byte_101052EE = sub_10004890(*(_WORD *)((*(_WORD *)(a3 + 8 * a5) << 6) + v9 + 2));
            break;
          default:
            goto LABEL_55;
        }
        goto LABEL_55;
      }
      v23 = sub_100138F0(*(_WORD *)(v22 + 36));
    }
    v38 = v23;
    goto LABEL_37;
  }
  if ( (v10 == 13 || v10 == 14 || v10 == 12) && sub_1001B210(v8, *(_WORD *)(a3 + 8 * a5), a7, (bool *)&v41, &v40) )
  {
    if ( v41 )
    {
      v37 = 2;
    }
    else
    {
      v37 = v40 != 0;
      if ( *(_BYTE *)(a3 + 8 * a5 + 6) == 14 )
        v37 = v40 == 0;
    }
    v11 = *(_WORD *)(a3 + 8 * a5);
    v12 = word_1007D760[6 * (unsigned __int8)a7];
    if ( (unsigned __int16)v11 < v12 || (unsigned __int16)v11 > (unsigned __int16)word_1007D762[6 * (unsigned __int8)a7] )
    {
      if ( !sub_10013780((int)&v45, v11) )
      {
LABEL_55:
        v35 = 12 * a5;
        *(_BYTE *)(v35 + dword_102ACCC0) = v37;
        *(_DWORD *)(v35 + dword_102ACCC0 + 4) = *(_DWORD *)(v42 + 20 * *(_WORD *)(a3 + 8 * a5) + 12);
        sub_10004650(a5, v37);
        return v37;
      }
    }
    else
    {
      qmemcpy(&v45, (const void *)(v8 + 160 * (unsigned __int16)(v11 - v12)), 0x9Cu);
    }
    if ( !(v47 & 2) )
    {
      v13 = 6916 * (unsigned __int8)byte_101052EC;
      *(_BYTE *)(dword_102ACCCC + 4 * (1729 * (unsigned __int8)byte_101052EC + *(_BYTE *)(v13 + dword_102ACCCC + 2)) + 20) = v37;
      *(_BYTE *)(v13 + *(_BYTE *)(v13 + dword_102ACCCC + 2) + dword_102ACCCC + 420) = 0;
      v14 = dword_102ACCCC;
      word_10106E88[*(_BYTE *)(v13 + dword_102ACCCC + 2)] = a5;
      strncpy((char *)(v13 + 21 * *(_BYTE *)(v13 + v14 + 2) + v14 + 520), &v46, 0x15u);
      v15 = (unsigned __int8)byte_101052EC;
      v16 = 6916 * (unsigned __int8)byte_101052EC;
      *(_BYTE *)(v16 + 21 * *(_BYTE *)(v16 + dword_102ACCCC + 2) + dword_102ACCCC + 540) = 0;
      *(_BYTE *)(v16 + *(_BYTE *)(v16 + dword_102ACCCC + 2) + dword_102ACCCC + 3120) = v37;
      *(_BYTE *)(v16 + *(_BYTE *)(v16 + dword_102ACCCC + 2) + dword_102ACCCC + 2620) = 0;
      *(_DWORD *)(dword_102ACCCC + 4 * (1729 * v15 + *(_BYTE *)(v16 + dword_102ACCCC + 2)) + 2720) = 1;
      *(_WORD *)(dword_102ACCCC + 2 * (3458 * v15 + (*(_BYTE *)(v16 + dword_102ACCCC + 2))++) + 3220) = *(_WORD *)(a3 + 8 * a5);
    }
    goto LABEL_55;
  }
  return 0;
}
// 1007D760: using guessed type __int16 word_1007D760[];
// 1007D762: using guessed type __int16 word_1007D762[];
// 101052EC: using guessed type char byte_101052EC;
// 101052EE: using guessed type char byte_101052EE;
// 10106E88: using guessed type __int16 word_10106E88[];
// 10117E78: using guessed type int dword_10117E78[];
// 102ACCC0: using guessed type int dword_102ACCC0;
// 102ACCCC: using guessed type int dword_102ACCCC;

//----- (10004F80) --------------------------------------------------------
char __usercall sub_10004F80@<al>(unsigned __int16 a1@<ax>, char a2@<dl>, int a3@<ecx>, int a4)
{
  char v4; // bl@1
  signed __int64 v5; // rax@1
  signed __int64 v6; // rt2@1
  __int16 v7; // cx@1
  unsigned __int16 v8; // ax@1
  unsigned __int16 v9; // si@1
  unsigned int v10; // eax@6

  v4 = a2;
  v5 = *(_WORD *)(160 * a1 + a3) - 1000;
  v6 = v5 % 100;
  v7 = v5 / 100;
  v8 = dword_10106D84;
  LOWORD(dword_10106D84) = v7;
  v9 = v6;
  if ( v7 == v8 && byte_101052ED )
    goto LABEL_11;
  if ( v8 != -1 && byte_101052ED )
    sub_10004840(v8, (int)byte_10106A60);
  LOBYTE(v10) = sub_100045C0(dword_10106D84, (int)byte_10106A60);
  byte_101052ED = v10;
  if ( (_BYTE)v10 )
  {
LABEL_11:
    v10 = 8 * v9;
    byte_10106A60[v10] = v4;
    dword_10106A64[v10 / 4] = v4 != 3 ? a4 : 0;
  }
  return v10;
}
// 101052ED: using guessed type char byte_101052ED;
// 10106A64: using guessed type int dword_10106A64[];
// 10106D84: using guessed type int dword_10106D84;

//----- (10005020) --------------------------------------------------------
char __usercall sub_10005020@<al>(double st7_0@<st0>, int a1, int a2, unsigned __int8 a3, unsigned __int16 a4, char a5)
{
  char v6; // cl@1
  char v7; // dl@3
  unsigned __int16 v8; // ax@5
  int v9; // ecx@6
  int v10; // edi@6
  char v11; // al@7
  char *v12; // ecx@21
  char v14; // [sp+Bh] [bp-5h]@1
  char v15; // [sp+Ch] [bp-4h]@3

  v6 = a5;
  v14 = 0;
  if ( a5 == 1 || a5 == 2 )
  {
    v15 = 1;
    v7 = 1;
  }
  else
  {
    v7 = 0;
    v15 = 0;
  }
  v8 = a2;
  if ( (_WORD)a2 != -1 )
  {
    do
    {
      v9 = *(_DWORD *)(a1 + 8);
      v10 = v8;
      if ( *(_WORD *)(v9 + 8 * v8 + 2) == -1 )
      {
        v11 = sub_10004940(
                *(_DWORD *)(a1 + 12),
                *(_DWORD *)a1,
                v9,
                st7_0,
                *(_WORD *)(a1 + 4),
                v8,
                *(_DWORD *)(a1 + 16),
                *(_BYTE *)(a1 + 20));
      }
      else if ( a3 >= 0x64u )
      {
        sub_100129A0("..\\lib\\adl\\mon_cas.c", 1866, 0, "Exceeded recursion depth limit in get_node_value()");
        v11 = 2;
      }
      else
      {
        v11 = sub_10005020(a1, *(_WORD *)(v9 + 8 * v8 + 2), a3 + 1, v8, *(_BYTE *)(v9 + 8 * v8 + 6));
      }
      switch ( a5 )
      {
        case 1:
        case 2:
          if ( v11 == 2 )
            v14 = 1;
          else
            v15 &= v11;
          break;
        case 3:
        case 4:
          if ( v11 == 2 )
            v14 = 1;
          else
            v15 |= v11;
          break;
        case 5:
        case 6:
          if ( v11 == 2 )
            v14 = 1;
          else
            v15 ^= v11;
          break;
        case 9:
          v12 = (char *)(dword_102ACCC0 + 12 * v10 + 1);
          if ( *v12 == 1 && v11 != 1 )
            v15 = 1;
          goto LABEL_24;
        case 0xA:
          v12 = (char *)(dword_102ACCC0 + 12 * v10 + 1);
          if ( *v12 == 1 || v11 != 1 )
          {
LABEL_24:
            *v12 = v11;
          }
          else
          {
            v15 = 1;
            *v12 = 1;
          }
          break;
        case 7:
          if ( v11 == 2 )
            v15 = 2;
          else
            v15 = v11 == 0;
          break;
        default:
          v15 = v11;
          break;
      }
      v8 = *(_WORD *)(*(_DWORD *)(a1 + 8) + 8 * v10 + 4);
    }
    while ( v8 != -1 );
    v7 = v15;
    v6 = a5;
  }
  switch ( v6 )
  {
    case 1:
    case 2:
      if ( v14 && v7 == 1 )
      {
        v15 = 2;
        v7 = 2;
      }
      if ( v6 == 2 && v7 != 2 )
      {
        v15 = v7 == 0;
        goto LABEL_52;
      }
      break;
    case 3:
    case 4:
      if ( v14 && !v7 )
      {
        v15 = 2;
        v7 = 2;
      }
      if ( v6 == 4 && v7 != 2 )
      {
        v15 = v7 == 0;
        goto LABEL_52;
      }
      break;
    case 5:
    case 6:
      if ( v14 )
      {
        v15 = 2;
        v7 = 2;
      }
      if ( v6 == 6 && v7 != 2 )
      {
        v15 = v7 == 0;
LABEL_52:
        v7 = v15;
      }
      break;
    default:
      break;
  }
  *(_BYTE *)(dword_102ACCC0 + 12 * a4) = v7;
  sub_10004650(a4, v15);
  return v15;
}
// 102ACCC0: using guessed type int dword_102ACCC0;

//----- (10005290) --------------------------------------------------------
int __usercall sub_10005290@<eax>(int a1@<edi>, double st7_0@<st0>, int a2, int a3, int a4, char a5, __int16 a6, _BYTE *a7, _BYTE *a8, _BYTE *a9, _BYTE *a10)
{
  _BYTE *v11; // ebx@1
  int result; // eax@1
  int v13; // esi@2
  char v14; // cl@2
  unsigned __int16 v15; // ST0C_2@5
  int v16; // eax@5
  char v17; // al@5
  int v18; // [sp+8h] [bp-18h]@5
  __int16 v19; // [sp+Ch] [bp-14h]@5
  int v20; // [sp+10h] [bp-10h]@5
  int v21; // [sp+14h] [bp-Ch]@5
  int v22; // [sp+18h] [bp-8h]@5
  char v23; // [sp+1Ch] [bp-4h]@5

  *a7 = 0;
  v11 = a8;
  *a10 = 0;
  *a9 = 0;
  *a8 = 0;
  for ( result = *(_WORD *)(a1 + 8 * *(_WORD *)(160 * (unsigned __int16)a6 + a2 + 156) + 4);
        (_WORD)result != -1;
        result = *(_WORD *)(v13 + 4) )
  {
    v13 = a1 + 8 * (unsigned __int16)result;
    v14 = *(_BYTE *)(v13 + 6);
    if ( v14 == 12 || v14 == 17 || *(_WORD *)v13 != -1 )
    {
      v17 = sub_10004940(a3, a2, a1, st7_0, a6, result, a4, a5);
      v11 = a8;
    }
    else
    {
      v18 = a2;
      v15 = result;
      v16 = *(_WORD *)(v13 + 2);
      v21 = a3;
      v22 = a4;
      v19 = a6;
      v20 = a1;
      v23 = a5;
      v17 = sub_10005020(st7_0, (int)&v18, v16, 1u, v15, v14);
    }
    if ( v17 == 1 )
    {
      switch ( *(_BYTE *)(v13 + 6) )
      {
        case 8:
          *a7 |= 0x20u;
          break;
        case 0xB:
          *v11 = 1;
          break;
        case 0xF:
          *v11 = 1;
          *a9 = 1;
          break;
        case 0xC:
          *a10 = 1;
          break;
        default:
          continue;
      }
    }
  }
  return result;
}

//----- (100053D0) --------------------------------------------------------
char __usercall sub_100053D0@<al>(double st7_0@<st0>, int a1, signed __int16 a2, int a3, int a4, int a5, int a6)
{
  char result; // al@1
  void *v8; // ecx@7
  _WORD *v9; // esi@10
  int v10; // edi@10
  signed __int16 v11; // ax@17
  signed __int16 v12; // ax@24
  unsigned __int16 *v13; // ebp@27
  unsigned int v14; // eax@28
  signed int v15; // eax@31
  __int16 v16; // si@33
  int v17; // ebx@33
  int v18; // edi@33
  char v19; // al@34
  unsigned __int16 v20; // ax@35
  char v21; // bl@36
  char v22; // al@40
  unsigned int v23; // eax@60
  unsigned __int16 *v24; // ecx@60
  char *v25; // edx@60
  int v26; // esi@64
  int v27; // eax@65
  _BYTE *v28; // ecx@65
  _BYTE *v29; // edx@65
  int v30; // eax@67
  _BYTE *v31; // ecx@67
  _BYTE *v32; // edx@67
  _BYTE *v33; // ecx@69
  _BYTE *v34; // edx@69
  signed int v35; // eax@71
  char v36; // al@82
  unsigned __int16 v37; // cx@82
  char v38; // [sp+8h] [bp-130h]@33
  char v39; // [sp+9h] [bp-12Fh]@33
  char v40; // [sp+Ah] [bp-12Eh]@33
  char v41; // [sp+Bh] [bp-12Dh]@33
  unsigned int v42; // [sp+Ch] [bp-12Ch]@27
  int v43; // [sp+10h] [bp-128h]@1
  int v44; // [sp+14h] [bp-124h]@27
  int v45; // [sp+18h] [bp-120h]@33
  unsigned int v46; // [sp+1Ch] [bp-11Ch]@1
  unsigned int v47; // [sp+20h] [bp-118h]@3
  int v48; // [sp+24h] [bp-114h]@36
  int v49; // [sp+28h] [bp-110h]@53
  int v50; // [sp+2Ch] [bp-10Ch]@33
  int v51; // [sp+30h] [bp-108h]@1
  int v52; // [sp+34h] [bp-104h]@1
  int v53; // [sp+38h] [bp-100h]@82
  int v54; // [sp+3Ch] [bp-FCh]@1
  int v55; // [sp+40h] [bp-F8h]@1
  int v56; // [sp+44h] [bp-F4h]@35
  __int16 v57; // [sp+48h] [bp-F0h]@35
  int v58; // [sp+4Ch] [bp-ECh]@35
  int v59; // [sp+50h] [bp-E8h]@35
  int v60; // [sp+54h] [bp-E4h]@35
  char v61; // [sp+58h] [bp-E0h]@35
  char v62; // [sp+5Ch] [bp-DCh]@33
  char v63; // [sp+F8h] [bp-40h]@1
  char v64; // [sp+114h] [bp-24h]@9
  int v65; // [sp+140h] [bp+8h]@20

  v43 = a1;
  v54 = a3;
  v52 = a4;
  v51 = a5;
  v46 = sub_1003DC90();
  memset(dword_10117E78, 0, 0xBCu);
  sub_1001D900(&v63);
  v55 = 0;
  result = sub_10015FD0(30000);
  if ( result )
    return result;
  if ( (_BYTE)a6 == 1 )
  {
    if ( !sub_1003E2F0(9373, &v47, 4, &v55) && v47 < 0x96 )
    {
      ++v47;
      sub_1003E110(9373, (int)&v47, 4);
    }
LABEL_7:
    result = sub_10016110();
    if ( result || (result = sub_100160D0(v8), result == 4) && !v64 )
    {
      v9 = (_WORD *)a1;
      v10 = (unsigned __int16)(a2 + 1);
      do
      {
        if ( *v9 != -1 )
        {
          result = sub_10013800((int)v9);
          if ( result )
          {
            sub_10013A30(255, *v9, 5);
            result = sub_10013A80(*v9);
          }
        }
        v9 += 80;
        --v10;
      }
      while ( v10 );
      return result;
    }
    goto LABEL_16;
  }
  if ( (_BYTE)a6 != 2 )
    goto LABEL_7;
LABEL_16:
  if ( (_BYTE)a6 )
  {
    v11 = a2;
    if ( (unsigned __int8)a6 == 1 )
    {
      if ( (unsigned __int16)a2 >= 0x3E8u )
        v11 = 1000;
      v65 = (unsigned __int16)v11;
    }
    else
    {
      if ( (unsigned __int16)a2 >= 0x1F4u )
        v11 = 500;
      v65 = (unsigned __int16)v11;
    }
  }
  else
  {
    v12 = a2;
    if ( (unsigned __int16)a2 >= 0x3E8u )
      v12 = 1000;
    v65 = (unsigned __int16)v12;
  }
  LOWORD(dword_10106D84) = -1;
  byte_101052ED = 1;
  v42 = 0;
  v44 = 0;
  v13 = (unsigned __int16 *)(a1 + 156);
  do
  {
    v14 = *(_DWORD *)(v44 + dword_102ACCC8 + 8);
    if ( v14 == -1 || v46 < v14 || *(v13 - 78) == 2300 )
      goto LABEL_100;
    v15 = *((_DWORD *)v13 - 7);
    if ( !v15 )
      v15 = 1000;
    qmemcpy(&v62, v13 - 78, 0x9Cu);
    *(_DWORD *)(v44 + dword_102ACCC8 + 8) = v15 + v46 - 100;
    LOBYTE(v45) = 0;
    v41 = 0;
    v40 = 0;
    LOBYTE(v50) = 0;
    memset((void *)(dword_102ACCCC + 6916 * (unsigned __int8)byte_101052EC), 0, 0x1B04u);
    v16 = v42;
    v17 = v43;
    v18 = v54;
    v39 = *(_BYTE *)(dword_102ACCC0 + 12 * *v13);
    v38 = 0;
    byte_101052EE = 0;
    sub_10005290(v54, st7_0, v43, v52, v51, a6, v42, &v45, &v50, &v40, &v41);
    if ( *(_WORD *)(v18 + 8 * *v13 + 2) == -1 )
    {
      v19 = sub_10004940(v52, v43, v18, st7_0, v16, *v13, v51, a6);
    }
    else
    {
      v59 = v52;
      v20 = *v13;
      v60 = v51;
      v56 = v17;
      v57 = v16;
      v58 = v18;
      v61 = a6;
      v19 = sub_10005020(st7_0, (int)&v56, *(_WORD *)(v18 + 8 * v20 + 2), 1u, v20, *(_BYTE *)(v18 + 8 * v20 + 6));
    }
    v21 = v19;
    LOBYTE(v48) = v19;
    if ( (_BYTE)a6 == 1 )
      sub_10004600(v19, v42);
    if ( *((_DWORD *)v13 - 4) || *((_DWORD *)v13 - 3) )
    {
      v22 = sub_100046D0(v43, v42, v39, v46, v48, &v48);
      v21 = v48;
    }
    else
    {
      v22 = 0;
    }
    if ( (_BYTE)a6 != 1 && (_BYTE)a6 != 2 )
      v22 = 0;
    if ( v21 == 1 && v39 != 1 )
      ++*(_DWORD *)(v44 + dword_102ACCC8 + 12);
    if ( v22 )
      sub_10004F80(v42, v22, v43, v46);
    if ( v41 )
    {
      if ( v21 == 2 )
      {
        v21 = 0;
        *(_BYTE *)(dword_102ACCC0 + 12 * *v13) = 0;
      }
LABEL_53:
      LOBYTE(v49) = 0;
      goto LABEL_76;
    }
    if ( v21 != 1 && (v21 != 2 || !(*((_BYTE *)v13 - 4) & 1)) )
      goto LABEL_53;
    LOBYTE(v49) = 1;
    if ( !(_BYTE)v50 )
    {
      if ( sub_100138F0(*(v13 - 78)) )
      {
        v23 = 156;
        v24 = v13 - 78;
        v25 = &v62;
        do
        {
          if ( *(_DWORD *)v25 != *(_DWORD *)v24 )
            goto LABEL_64;
          v23 -= 4;
          v24 += 2;
          v25 += 4;
        }
        while ( v23 >= 4 );
        if ( !v23 )
        {
LABEL_73:
          v35 = 0;
          goto LABEL_74;
        }
LABEL_64:
        v26 = (unsigned __int8)*v25 - *(_BYTE *)v24;
        if ( (unsigned __int8)*v25 == *(_BYTE *)v24 )
        {
          v27 = v23 - 1;
          v28 = (char *)v24 + 1;
          v29 = v25 + 1;
          if ( !v27 )
            goto LABEL_73;
          v26 = *v29 - *v28;
          if ( *v29 == *v28 )
          {
            v30 = v27 - 1;
            v31 = v28 + 1;
            v32 = v29 + 1;
            if ( !v30 )
              goto LABEL_73;
            v26 = *v32 - *v31;
            if ( *v32 == *v31 )
            {
              v33 = v31 + 1;
              v34 = v32 + 1;
              if ( v30 == 1 )
                goto LABEL_73;
              v26 = *v34 - *v33;
              if ( *v34 == *v33 )
                goto LABEL_73;
            }
          }
        }
        v35 = 1;
        if ( v26 <= 0 )
          v35 = -1;
LABEL_74:
        if ( v35 )
        {
          sub_10013A80(*(v13 - 78));
          sub_10004460(v13 - 78, v45);
          v38 = 1;
        }
      }
      else
      {
        sub_10004460(v13 - 78, v45);
      }
    }
LABEL_76:
    if ( (_BYTE)v45 )
      sub_10013A30(255, *(v13 - 78), 5);
    if ( !(_BYTE)v49 && !v40 && sub_100138F0(*(v13 - 78)) )
      sub_10013930(*(v13 - 78), 0, 0);
    v36 = sub_100138F0(*(v13 - 78));
    v37 = *(v13 - 9);
    LOBYTE(v53) = v36;
    if ( v37 )
    {
      if ( *((_BYTE *)v13 - 4) & 8 && v36 )
        LOBYTE(v53) = 2;
      sub_1001A130(v37, v53);
    }
    if ( v21 == v39 )
      goto LABEL_95;
    v38 = 1;
    if ( v21 == 2 )
    {
      if ( v39 == 1 )
        goto LABEL_93;
    }
    else if ( v21 == 1 && v39 == 2 )
    {
LABEL_93:
      if ( *((_BYTE *)v13 - 4) & 1 )
        v38 = 0;
      goto LABEL_95;
    }
LABEL_95:
    if ( (_BYTE)v49 && *((_BYTE *)v13 - 29) & 0x80 || v38 == 1 )
    {
      sub_10004510(v42, v43, st7_0, v49, v50);
      if ( (unsigned __int8)++byte_101052EC >= 0xAu )
        byte_101052EC = 0;
    }
LABEL_100:
    v44 += 16;
    v13 += 80;
    ++v42;
  }
  while ( (unsigned __int16)v42 <= (unsigned __int16)v65 );
  if ( (_WORD)dword_10106D84 != -1 && byte_101052ED )
    sub_10004840(dword_10106D84, (int)byte_10106A60);
  return sub_10013960(a6);
}
// 101052EC: using guessed type char byte_101052EC;
// 101052ED: using guessed type char byte_101052ED;
// 101052EE: using guessed type char byte_101052EE;
// 10106D84: using guessed type int dword_10106D84;
// 10117E78: using guessed type int dword_10117E78[];
// 102ACCC0: using guessed type int dword_102ACCC0;
// 102ACCC8: using guessed type int dword_102ACCC8;
// 102ACCCC: using guessed type int dword_102ACCCC;

//----- (10005A40) --------------------------------------------------------
char __cdecl sub_10005A40(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // edi@1
  unsigned int v4; // eax@4
  unsigned int v5; // edi@4
  unsigned int v6; // ST40_4@6
  char v7; // dl@6
  int v8; // ecx@6
  int v9; // eax@6
  unsigned int v11; // [sp+8h] [bp-18Ch]@6
  unsigned int v12; // [sp+10h] [bp-184h]@6
  char v13; // [sp+14h] [bp-180h]@6
  int v14; // [sp+18h] [bp-17Ch]@6
  char v15; // [sp+20h] [bp-174h]@6
  char v16; // [sp+24h] [bp-170h]@6
  int v17; // [sp+54h] [bp-140h]@6
  char v18; // [sp+58h] [bp-13Ch]@6
  int v19; // [sp+5Ch] [bp-138h]@6
  char v20; // [sp+64h] [bp-130h]@2

  v3 = 284 * a1;
  if ( byte_1018DEF2[v3] )
    sub_1001D720((int)&v20, "/mnt/card1/cmc/", 300);
  else
    sub_1001D720((int)&v20, "/mnt/sys_nand0/cmc/", 300);
  sub_1001D870(&v20, &byte_1018DEC8[v3], 300);
  sub_1001D870(&v20, "/.logs_db", 300);
  v4 = j_FIL_vfs_open(&v20, 4, 0);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    sub_1003E730(v4, a2 << 6, 0);
    sub_1003E4B0(v5, &v16, 64);
    sub_10042AEC((int)&v16, (int)"%4hd-%2hu-%2hu_%2hu%2hu%2hu_%4s.bin", (unsigned int)&v11 + 2);
    BYTE2(v12) = v13;
    BYTE3(v12) = v15;
    sub_10014D30(&v14, v11);
    v6 = v12;
    *(_DWORD *)(a3 + 8) = v14;
    sub_10014E70(&v14, v6);
    v7 = v18;
    v8 = v19;
    *(_DWORD *)(a3 + 8) += v14;
    v9 = v17;
    *(_DWORD *)(a3 + 12) = v8;
    *(_BYTE *)(a3 + 16) = v7;
    *(_DWORD *)(a3 + 20) = v9;
  }
  else
  {
    *(_BYTE *)(a3 + 16) = 7;
  }
  sub_1003E3E0(v5);
  return 1;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10005BD0) --------------------------------------------------------
char __cdecl sub_10005BD0(unsigned __int8 a1, int a2, int a3)
{
  char result; // al@1
  int v4; // ecx@2
  bool v5; // zf@2
  char *v6; // ecx@2

  result = 0;
  if ( a1 < 0x10u )
  {
    v4 = 284 * a1;
    v5 = byte_1018DEC8[v4] == 0;
    v6 = &byte_1018DEC8[v4];
    if ( !v5 )
    {
      sub_1001D720(a2, v6, a3);
      result = 1;
    }
  }
  return result;
}

//----- (10005C10) --------------------------------------------------------
signed __int16 __cdecl sub_10005C10(unsigned __int8 a1)
{
  signed __int16 v1; // di@1
  int v2; // eax@2
  char *v3; // esi@2
  unsigned int v4; // eax@6
  unsigned int v5; // esi@6
  signed __int16 result; // ax@9
  char v7; // [sp+8h] [bp-130h]@4

  v1 = -1;
  if ( a1 < 0x10u && (v2 = 284 * a1, v3 = &byte_1018DEC8[v2], byte_1018DEC8[v2]) )
  {
    if ( byte_1018DEF2[v2] )
      sub_1001D720((int)&v7, "/mnt/card1/cmc/", 300);
    else
      sub_1001D720((int)&v7, "/mnt/sys_nand0/cmc/", 300);
    sub_1001D870(&v7, v3, 300);
    sub_1001D870(&v7, "/.logs_db", 300);
    v4 = j_FIL_vfs_open(&v7, 4, 0);
    v5 = v4;
    if ( v4 < 0xFFFFFFC2 )
    {
      if ( v4 )
      {
        v1 = (unsigned __int64)(sub_1003E5F0(v4) / 64) - 1;
        sub_1003E3A0(v5);
      }
    }
    result = v1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10005D20) --------------------------------------------------------
signed int __cdecl sub_10005D20(unsigned __int8 a1, unsigned __int16 a2, char a3)
{
  int v3; // esi@1
  unsigned int v4; // esi@4
  char v6; // [sp+8h] [bp-170h]@4
  char v7; // [sp+3Ch] [bp-13Ch]@4
  char v8; // [sp+48h] [bp-130h]@2

  v3 = 284 * a1;
  if ( byte_1018DEF2[v3] )
    sub_1001D720((int)&v8, "/mnt/card1/cmc/", 300);
  else
    sub_1001D720((int)&v8, "/mnt/sys_nand0/cmc/", 300);
  sub_1001D870(&v8, &byte_1018DEC8[v3], 300);
  sub_1001D870(&v8, "/.logs_db", 300);
  v4 = j_FIL_vfs_open(&v8, 6, 0);
  sub_1003E730(v4, a2 << 6, 0);
  sub_1003E4B0(v4, &v6, 64);
  v7 = a3;
  sub_1003E730(v4, a2 << 6, 0);
  j_FIL_vfs_write(v4, &v6, 64);
  return sub_1003E3A0(v4);
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10005E20) --------------------------------------------------------
int sub_10005E20()
{
  int v0; // edi@1
  char *v1; // esi@1
  int result; // eax@2

  v0 = 0;
  v1 = byte_1018DEC8;
  do
  {
    result = sub_1003E040(v0 + 18000, (int)v1, 284);
    v1 += 284;
    ++v0;
  }
  while ( (signed int)v1 < (signed int)dword_1018F088 );
  return result;
}
// 1018F088: using guessed type int dword_1018F088[];

//----- (10005E60) --------------------------------------------------------
unsigned int __cdecl sub_10005E60(char a1)
{
  unsigned __int8 v1; // cl@0
  unsigned __int8 v2; // bl@1
  unsigned int v3; // esi@3
  unsigned int result; // eax@7
  unsigned int v5; // ebp@7
  int v6; // ecx@9
  signed int v7; // edi@13
  __int64 v8; // kr00_8@15
  int v9; // et2@15
  int v10; // edi@18
  double v11; // st7@18
  int v12; // ecx@18
  float v13; // ST4C_4@18
  unsigned int v14; // eax@21
  unsigned int v15; // [sp+10h] [bp-3CCh]@2
  char v16; // [sp+14h] [bp-3C8h]@13
  int v17; // [sp+3Ch] [bp-3A0h]@15
  int v18; // [sp+40h] [bp-39Ch]@16
  __int64 v19; // [sp+4Ch] [bp-390h]@15
  char v20; // [sp+54h] [bp-388h]@2
  char v21; // [sp+180h] [bp-25Ch]@13
  char v22; // [sp+2ACh] [bp-130h]@7

  v2 = v1;
  if ( v1 == 16 )
  {
    sub_1001D840(&v20, 0x12Cu, "%s%s", "/mnt/sys_nand0/cmc/", "ATN_LOGS");
    v15 = 0x200000;
  }
  else
  {
    v3 = 284 * v1;
    if ( byte_1018DEF2[v3] )
      sub_1001D720((int)&v20, "/mnt/card1/cmc/", 300);
    else
      sub_1001D720((int)&v20, "/mnt/sys_nand0/cmc/", 300);
    sub_1001D870(&v20, &byte_1018DEC8[v3], 300);
    v15 = dword_1018DEE8[v3 / 4];
  }
  sub_1001D720((int)&v22, &v20, 300);
  sub_1001D870(&v20, "/.logs_db", 300);
  result = j_FIL_vfs_open(&v20, 6, 0);
  v5 = result;
  if ( result < 0xFFFFFFC2 && result )
  {
    while ( 1 )
    {
      v6 = dword_1017A504[2 * v2];
      if ( v6 <= 0 && (v6 < 0 || dword_1017A500[2 * v2] <= v15) && !a1 )
        break;
      a1 = 0;
      sub_1003E730(v5, 0, 0);
      v7 = sub_1003E4B0(v5, &v16, 64);
      sub_1001D720((int)&v21, &v22, 300);
      sub_1001D870(&v21, "/", 300);
      sub_1001D870(&v21, &v16, 300);
      if ( v7 == 64 && v16 )
      {
        sub_1001D840(&v21, 0x12Cu, "%s/%s", &v22, &v16);
        v8 = v19;
        v9 = dword_1017A500[2 * v2] - v19;
        dword_1017A504[2 * v2] = (__PAIR__(dword_1017A504[2 * v2], dword_1017A500[2 * v2]) - v19) >> 32;
        dword_1017A500[2 * v2] = v9;
        if ( v17 == -1 || v18 != v8 )
          --dword_1018DAA0[13 * v2];
        j_FIL_vfs_delete(&v21);
        v10 = (unsigned __int64)sub_1003E5F0(v5) - 64;
        sub_1003E430(v5, 0, v5, 64, v10);
        sub_1003E750(v5, v10, (unsigned __int64)v10 >> 32);
        v11 = (double)(unsigned int)dword_1017A500[2 * v2];
        v12 = 13 * v2;
        --dword_1018DAA4[v12];
        v13 = v11 / (double)(unsigned int)dword_1018DEE8[71 * v2] * 100.0;
        flt_1018DAA8[v12] = v13;
        if ( v13 > 100.0 )
          flt_1018DAA8[v12] = 100.0;
        if ( !v10 )
        {
          v14 = *(&dword_1017A4A8 + v2);
          if ( v14 < 0xFFFFFFC2 )
          {
            if ( v14 )
            {
              sub_100129A0(
                "..\\lib\\adl\\mon_log.c",
                4016,
                0,
                "Current log file exceeds max folder size.  Closing and deleting current log.");
              sub_1003E3A0(*(&dword_1017A4A8 + v2));
              *(&dword_1017A4A8 + v2) = 0;
              dword_1017A500[2 * v2] = 0;
              dword_1017A504[2 * v2] = 0;
              *((_BYTE *)&dword_1018D098 + v2) = 1;
              *((_BYTE *)&dword_1017A4E8 + v2) = 0;
              dword_1018DDC0[v2] = 0;
              memset((char *)&unk_1017D098 + 4096 * v2, 0, 0x1000u);
              dword_1018F088[v2] = 0;
              break;
            }
          }
        }
      }
    }
    result = sub_1003E3A0(v5);
  }
  return result;
}
// 1003E400: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1017A4E8: using guessed type int dword_1017A4E8;
// 1017A500: using guessed type int dword_1017A500[];
// 1017A504: using guessed type int dword_1017A504[];
// 1018D098: using guessed type int dword_1018D098;
// 1018DAA0: using guessed type int dword_1018DAA0[];
// 1018DAA4: using guessed type int dword_1018DAA4[];
// 1018DAA8: using guessed type float flt_1018DAA8[];
// 1018DDC0: using guessed type int dword_1018DDC0[];
// 1018DEE8: using guessed type int dword_1018DEE8[];
// 1018F088: using guessed type int dword_1018F088[];

//----- (100061C0) --------------------------------------------------------
double __cdecl sub_100061C0(float a1, int a2)
{
  float v2; // ST14_4@1
  float v4; // [sp+8h] [bp+4h]@1

  v2 = dbl_10063BEC[2 * sub_1001CEF0(&a2, 4u, (int)dword_10063BE8, 16, 168)];
  v4 = v2 * a1;
  if ( a2 == 4 )
    v4 = v4 + 32.0;
  return v4;
}
// 10063BE8: using guessed type int dword_10063BE8[];
// 10063BEC: using guessed type double dbl_10063BEC[];

//----- (10006210) --------------------------------------------------------
int __cdecl sub_10006210(unsigned __int8 a1)
{
  int v1; // esi@1
  int v2; // eax@4
  unsigned int v3; // ebx@4
  unsigned __int64 v4; // rax@4
  unsigned int v5; // ebp@4
  unsigned int v6; // esi@4
  unsigned __int16 v7; // di@6
  int result; // eax@13
  int v9; // [sp+10h] [bp-174h]@1
  char v10; // [sp+14h] [bp-170h]@8
  int v11; // [sp+3Ch] [bp-148h]@8
  int v12; // [sp+40h] [bp-144h]@9
  __int64 v13; // [sp+4Ch] [bp-138h]@9
  char v14; // [sp+54h] [bp-130h]@2

  v1 = 284 * a1;
  v9 = 0;
  if ( byte_1018DEF2[v1] )
    sub_1001D720((int)&v14, "/mnt/card1/cmc/", 300);
  else
    sub_1001D720((int)&v14, "/mnt/sys_nand0/cmc/", 300);
  sub_1001D870(&v14, &byte_1018DEC8[v1], 300);
  sub_1001D870(&v14, "/.logs_db", 300);
  v2 = j_FIL_vfs_open(&v14, 14, 1911);
  v3 = v2;
  v4 = sub_1003E5F0(v2);
  v5 = v4 >> 6;
  v6 = HIDWORD(v4) >> 6;
  if ( v3 < 0xFFFFFFC2 && v3 )
  {
    v7 = 0;
    if ( v6 || v5 )
    {
      do
      {
        sub_1003E4B0(v3, &v10, 64);
        if ( v11 == -1 || v12 != v13 )
          ++v9;
        ++v7;
      }
      while ( v6 > 0 || v7 < v5 );
    }
    sub_1003E3A0(v3);
    result = v9;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10006340) --------------------------------------------------------
char __cdecl sub_10006340(int a1, unsigned int *a2)
{
  unsigned __int8 v2; // cl@0
  unsigned __int8 v3; // bl@1
  int v4; // esi@1
  bool v5; // zf@1
  unsigned int v6; // eax@10
  unsigned int *v7; // ebp@10
  char result; // al@12
  unsigned int v9; // eax@13
  unsigned int v10; // esi@13
  int v11; // eax@16
  unsigned __int8 v12; // [sp+10h] [bp-1E8h]@1
  unsigned __int8 v13; // [sp+11h] [bp-1E7h]@1
  unsigned __int16 v14; // [sp+12h] [bp-1E6h]@1
  int v15; // [sp+14h] [bp-1E4h]@1
  unsigned int *v16; // [sp+18h] [bp-1E0h]@1
  char v17; // [sp+1Ch] [bp-1DCh]@1
  int v18; // [sp+44h] [bp-1B4h]@1
  char v19; // [sp+50h] [bp-1A8h]@1
  int v20; // [sp+5Ch] [bp-19Ch]@1
  __int16 v21; // [sp+60h] [bp-198h]@1
  char v22; // [sp+62h] [bp-196h]@1
  char v23; // [sp+64h] [bp-194h]@2
  char v24; // [sp+12Ch] [bp-CCh]@7

  v16 = a2;
  v3 = v2;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v14 = 1990;
  v12 = 1;
  v13 = 1;
  v15 = 0;
  memset(&v17, 0, 0x40u);
  v4 = 284 * v3;
  v5 = byte_1018DEF2[v4] == 0;
  v18 = -1;
  v19 = 0;
  if ( v5 )
    sub_1001D720((int)&v23, "/mnt/sys_nand0/cmc/", 200);
  else
    sub_1001D720((int)&v23, "/mnt/card1/cmc/", 200);
  sub_10014C40((int)&v12, *(_DWORD *)(a1 + 4));
  sub_10014E20((int)&v15, *(_DWORD *)(a1 + 4));
  if ( dword_1017A588 == 0x3FFFF )
  {
    v20 = 1600085855;
    v21 = 24415;
  }
  else
  {
    sub_1000F7D0(dword_1017A588, (int)&v20);
    HIBYTE(v21) = 0;
  }
  sub_1001D870(&v23, &byte_1018DEC8[v4], 200);
  sub_1001D870(&v23, "/", 200);
  sub_1001D720((int)&v24, &v23, 200);
  sub_1001D840(
    &v17,
    0x28u,
    "%4hu-%02u-%02u_%02u%02u%02u_%4.4s.cmc",
    v14,
    v12,
    v13,
    (signed __int16)v15,
    BYTE2(v15),
    BYTE3(v15),
    &v20);
  sub_1001D870(&v23, &v17, 200);
  if ( !byte_1018DEF2[v4] && (unsigned __int16)sub_10005C10(v3) + 1 >= (unsigned __int8)byte_1018D0A8[v3] )
    sub_10005E60(1);
  v6 = j_FIL_vfs_open(&v23, 142, 1877);
  v7 = v16;
  *v16 = v6;
  if ( v6 < 0xFFFFFFC2 && v6 )
  {
    sub_1001D870(&v24, ".logs_db", 200);
    v9 = j_FIL_vfs_open(&v24, 14, 1911);
    v10 = v9;
    if ( v9 < 0xFFFFFFC2 && v9 )
    {
      sub_1003E730(v9, 0, 2);
      j_FIL_vfs_write(v10, &v17, 64);
      sub_1003E3A0(v10);
      v11 = 13 * v3;
      ++dword_1018DAA4[v11];
      ++dword_1018DAA0[v11];
      result = 1;
    }
    else
    {
      sub_1003E3A0(*v7);
      *v7 = 0;
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 1017A588: using guessed type int dword_1017A588;
// 1018DAA0: using guessed type int dword_1018DAA0[];
// 1018DAA4: using guessed type int dword_1018DAA4[];

//----- (100065D0) --------------------------------------------------------
int __cdecl sub_100065D0(unsigned __int16 a1, unsigned __int8 a2)
{
  int v2; // edi@1
  int v3; // eax@1
  char *v4; // esi@1
  unsigned int v6; // eax@6
  unsigned int v7; // esi@6
  int v8; // edi@8
  char v9; // [sp+8h] [bp-29Ch]@10
  char v10; // [sp+48h] [bp-25Ch]@4
  char v11; // [sp+174h] [bp-130h]@6

  v2 = 0;
  memset(&unk_1018DE00, 0, 0xC8u);
  v3 = 284 * a2;
  v4 = &byte_1018DEC8[v3];
  if ( !byte_1018DEC8[v3] )
    return 0;
  if ( byte_1018DEF2[v3] )
    sub_1001D720((int)&v10, "/mnt/card1/cmc/", 300);
  else
    sub_1001D720((int)&v10, "/mnt/sys_nand0/cmc/", 300);
  sub_1001D870(&v10, v4, 300);
  sub_1001D720((int)&v11, &v10, 300);
  sub_1001D870(&v11, "/.logs_db", 300);
  v6 = j_FIL_vfs_open(&v11, 4, 0);
  v7 = v6;
  if ( v6 < 0xFFFFFFC2 && v6 )
  {
    v8 = a1 << 6;
    if ( sub_1003E5F0(v6) < (unsigned int)(v8 + 64) )
    {
      sub_1003E3A0(v7);
      return 0;
    }
    sub_1003E730(v7, v8, 0);
    sub_1003E4B0(v7, &v9, 64);
    sub_1001D870(&v10, "/", 300);
    sub_1001D870(&v10, &v9, 300);
    v2 = j_FIL_vfs_open(&v10, 4, 0);
    sub_1001D720((int)&unk_1018DE00, &v9, 200);
    sub_1003E3A0(v7);
  }
  return v2;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10006790) --------------------------------------------------------
int __usercall sub_10006790@<eax>(void *a1@<ecx>, _DWORD *a2@<ebx>, size_t a3, char a4, int a5)
{
  void *v5; // esi@1
  int v6; // eax@1
  __int64 v7; // kr00_8@1
  int v8; // eax@3
  int v9; // et2@3
  int v10; // esi@4
  unsigned int v11; // esi@7
  char v13; // [sp+Ch] [bp-10Ch]@7
  __int64 v14; // [sp+44h] [bp-D4h]@7
  char v15; // [sp+4Ch] [bp-CCh]@5

  v5 = a1;
  v6 = j_FIL_vfs_write(a5, a1, *a2);
  v7 = v6;
  if ( v6 && a4 != 16 )
  {
    v8 = (unsigned __int8)a4;
    v9 = v7 + dword_1017A500[2 * (unsigned __int8)a4];
    dword_1017A504[2 * v8] = (v7
                            + __PAIR__(dword_1017A504[2 * (unsigned __int8)v8], dword_1017A500[2 * (unsigned __int8)v8])) >> 32;
    dword_1017A500[2 * v8] = v9;
  }
  memset(v5, 0, a3);
  v10 = 284 * (unsigned __int8)a4;
  *a2 = 0;
  if ( byte_1018DEF2[v10] )
    sub_1001D720((int)&v15, "/mnt/card1/cmc/", 200);
  else
    sub_1001D720((int)&v15, "/mnt/sys_nand0/cmc/", 200);
  sub_1001D870(&v15, &byte_1018DEC8[v10], 200);
  sub_1001D870(&v15, "/.logs_db", 200);
  v11 = j_FIL_vfs_open(&v15, 6, 0);
  sub_1003E730(v11, -64, 2);
  sub_1003E4B0(v11, &v13, 64);
  v14 += v7;
  sub_1003E730(v11, -64, 2);
  j_FIL_vfs_write(v11, &v13, 64);
  return sub_1003E3A0(v11);
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 1017A500: using guessed type int dword_1017A500[];
// 1017A504: using guessed type int dword_1017A504[];

//----- (100068E0) --------------------------------------------------------
int __usercall sub_100068E0@<eax>(int a1@<ecx>, char *a2@<edi>, char a3, size_t a4)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // ecx@3
  int v7; // eax@4
  int v8; // eax@6
  char *v9; // eax@8
  unsigned __int8 v10; // [sp+8h] [bp-A8h]@1
  unsigned __int8 v11; // [sp+9h] [bp-A7h]@1
  unsigned __int16 v12; // [sp+Ah] [bp-A6h]@1
  int v13; // [sp+Ch] [bp-A4h]@1
  char v14; // [sp+10h] [bp-A0h]@5
  char v15; // [sp+12h] [bp-9Eh]@5
  char v16; // [sp+31h] [bp-7Fh]@7
  char v17; // [sp+64h] [bp-4Ch]@8
  char v18; // [sp+79h] [bp-37h]@10
  char v19; // [sp+8Eh] [bp-22h]@6

  v4 = a1;
  v12 = 1990;
  v10 = 1;
  v11 = 1;
  v13 = 0;
  switch ( a3 )
  {
    case 0:
      sub_10014C40((int)&v10, *(_DWORD *)(a1 + 4));
      sub_10014E20((int)&v13, *(_DWORD *)(v4 + 4));
      return sub_1001D840(
               a2,
               a4,
               "\"%4u-%02u-%02u %02u:%02u:%02u\"",
               v12,
               v10,
               v11,
               (signed __int16)v13,
               BYTE2(v13),
               BYTE3(v13));
    case 1:
      v6 = *(_DWORD *)(a1 + 8);
      goto LABEL_13;
    case 3:
      v7 = sub_1001CD60((_DWORD *)(a1 + 3), 1u, (int)&unk_10063B64, 8, 3, 0);
      return sub_1001D840(a2, a4, "\"%s\"", off_10063B68[2 * v7]);
    case 4:
      sub_10013780((int)&v14, *(_WORD *)a1);
      return sub_1001D840(a2, a4, "\"%s\"", &v15);
    case 5:
      sub_10013780((int)&v14, *(_WORD *)a1);
      v8 = sub_1001CEF0(&v19, 1u, (int)&unk_10063B7C, 8, 5);
      return sub_1001D840(a2, a4, "\"%s\"", off_10063B80[2 * v8]);
    case 6:
      sub_10013780((int)&v14, *(_WORD *)a1);
      return sub_1001D840(a2, a4, "\"%s\"", &v16);
    case 7:
      sub_10013780((int)&v14, *(_WORD *)a1);
      v9 = &v17;
      goto LABEL_9;
    case 8:
      sub_10013780((int)&v14, *(_WORD *)a1);
      v9 = &v18;
LABEL_9:
      result = sub_1001D840(a2, a4, "\"%.20s\"", v9);
      break;
    case 9:
      result = sub_1001D840(a2, a4, "\"%s\"", "^");
      break;
    default:
      v6 = *(_WORD *)a1;
LABEL_13:
      result = sub_1001D840(a2, a4, "\"%d\"", v6);
      break;
  }
  return result;
}

//----- (10006B60) --------------------------------------------------------
unsigned int __fastcall sub_10006B60(unsigned __int8 a1)
{
  unsigned __int8 v1; // bl@1
  int v2; // esi@1
  int v3; // edi@3
  unsigned int result; // eax@7
  unsigned int v5; // edi@7
  int v6; // eax@9
  int v7; // ebx@12
  int v8; // et2@13
  char v9; // [sp+Ch] [bp-29Ch]@13
  __int64 v10; // [sp+44h] [bp-264h]@13
  char v11; // [sp+4Ch] [bp-25Ch]@2
  char v12; // [sp+178h] [bp-130h]@7

  v1 = a1;
  v2 = a1;
  dword_1017A500[2 * v2] = 0;
  dword_1017A504[2 * v2] = 0;
  if ( a1 == 16 )
  {
    sub_1001D840(&v11, 0x12Cu, "%s%s", "/mnt/sys_nand0/cmc/", "ATN_LOGS");
  }
  else
  {
    v3 = 284 * a1;
    if ( byte_1018DEF2[284 * a1] )
      sub_1001D720((int)&v11, "/mnt/card1/cmc/", 300);
    else
      sub_1001D720((int)&v11, "/mnt/sys_nand0/cmc/", 300);
    sub_1001D870(&v11, &byte_1018DEC8[v3], 300);
  }
  sub_1001D720((int)&v12, &v11, 300);
  sub_1001D870(&v12, "/.logs_db", 300);
  result = j_FIL_vfs_open(&v12, 4, 0);
  v5 = result;
  if ( result < 0xFFFFFFC2 && result )
  {
    LOWORD(v6) = sub_10005C10(v1);
    if ( (_WORD)v6 == -1 )
      LOWORD(v6) = 0;
    v6 = (unsigned __int16)v6;
    if ( (signed int)(unsigned __int16)v6 > 0 )
    {
      v7 = v6;
      do
      {
        sub_1003E4B0(v5, &v9, 64);
        v8 = v10 + dword_1017A500[2 * v2];
        dword_1017A504[2 * v2] = (v10 + __PAIR__(dword_1017A504[2 * v2], dword_1017A500[2 * v2])) >> 32;
        dword_1017A500[2 * v2] = v8;
        --v7;
      }
      while ( v7 );
    }
    result = sub_1003E3A0(v5);
  }
  return result;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1017A500: using guessed type int dword_1017A500[];
// 1017A504: using guessed type int dword_1017A504[];

//----- (10006CC0) --------------------------------------------------------
void *__usercall sub_10006CC0@<eax>(int a1@<esi>)
{
  memset((void *)a1, 0, 0x1B04u);
  *(_WORD *)(a1 + 14) = -1;
  *(_WORD *)(a1 + 3420) = -1;
  *(_WORD *)a1 = -1;
  *(_BYTE *)(a1 + 3546) = 5;
  *(_BYTE *)(a1 + 3) = -1;
  return memset((void *)(a1 + 3120), 4, 0x64u);
}

//----- (10006D00) --------------------------------------------------------
int __usercall sub_10006D00@<eax>(unsigned int a1@<eax>, int a2@<esi>, unsigned __int8 a3, int a4)
{
  unsigned __int8 v4; // bl@1
  unsigned int v5; // edi@1
  int v6; // ebp@1
  int v7; // eax@2
  void *v9; // [sp-Ch] [bp-1Ch]@5
  size_t v10; // [sp-4h] [bp-14h]@5

  v4 = a3;
  v5 = a1;
  v6 = 0;
  if ( *(_DWORD *)a2 + (((unsigned int)a3 + *(_DWORD *)(a2 + 4) + 7) >> 3) > *(_DWORD *)(a2 + 8) )
  {
    v7 = j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 16), *(_DWORD *)a2);
    if ( v7 > 0 )
      v6 = v7;
    if ( *(_DWORD *)(a2 + 4) )
    {
      **(_BYTE **)(a2 + 16) = *(_BYTE *)(*(_DWORD *)(a2 + 16) + *(_DWORD *)a2);
      v10 = *(_DWORD *)(a2 + 8) - 1;
      v9 = (void *)(*(_DWORD *)(a2 + 16) + 1);
    }
    else
    {
      v10 = *(_DWORD *)(a2 + 8);
      v9 = *(void **)(a2 + 16);
    }
    memset(v9, 0, v10);
    *(_DWORD *)a2 = 0;
  }
  if ( a3 )
  {
    while ( 1 )
    {
      if ( v4 > 8u )
        v4 = 8;
      sub_1000F1B0(a2, v4, (unsigned __int8)v5);
      v5 >>= 8;
      a3 -= v4;
      if ( !a3 )
        break;
      v4 = a3;
    }
  }
  return v6;
}
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10006DB0) --------------------------------------------------------
void *__usercall sub_10006DB0@<eax>(size_t a1@<eax>, int a2@<edx>, void *a3@<edi>, size_t a4@<esi>, _DWORD *a5, void *a6, char a7)
{
  void *result; // eax@3

  if ( a4 + *a5 >= a1 )
    sub_10006790(a3, a5, a1, a7, a2);
  result = memcpy((char *)a3 + *a5, a6, a4);
  *a5 += a4;
  return result;
}

//----- (10006DF0) --------------------------------------------------------
char sub_10006DF0()
{
  void *v0; // ecx@1
  signed int v1; // eax@2
  char v3; // [sp+0h] [bp-1CCh]@1
  char v4; // [sp+C4h] [bp-108h]@4
  char v5; // [sp+C5h] [bp-107h]@1

  v3 = 23;
  memset(&v5, 0, 0x100u);
  if ( sub_10016050(v0) )
  {
    v1 = 0;
    do
    {
      *(_BYTE *)(v1 + dword_102ACCC0 + 8) = 0;
      v1 += 12;
    }
    while ( v1 < 120000 );
    v4 = 1;
  }
  else
  {
    v4 = 0;
    sub_1001D840(&v5, 0x100u, "Auto test mode must be enabled for this command to be processed.");
  }
  return sub_1001D930(&v3);
}
// 102ACCC0: using guessed type int dword_102ACCC0;

//----- (10006EA0) --------------------------------------------------------
unsigned int *__cdecl sub_10006EA0(unsigned int *a1)
{
  unsigned int v1; // edi@1
  unsigned int v2; // eax@3
  int v3; // ebx@7
  unsigned int *result; // eax@7
  unsigned int v5; // edi@12
  int v6; // esi@12
  int v7; // eax@12
  int v8; // edi@12
  char *v9; // ebp@12
  int i; // ebx@14
  int v11; // eax@15
  char *v12; // edx@16
  unsigned int v13; // kr04_4@16
  bool v14; // zf@16
  bool v15; // sf@16
  unsigned __int8 v16; // of@16
  int v17; // eax@20
  int v18; // edx@21
  int v19; // [sp+Ch] [bp-714h]@1
  unsigned __int8 v20; // [sp+10h] [bp-710h]@1
  unsigned __int8 v21; // [sp+11h] [bp-70Fh]@1
  unsigned __int16 v22; // [sp+12h] [bp-70Eh]@1
  int v23; // [sp+14h] [bp-70Ch]@1
  unsigned int *v24; // [sp+18h] [bp-708h]@1
  char v25; // [sp+1Ch] [bp-704h]@1
  char v26[1536]; // [sp+11Ch] [bp-604h]@12
  int v27; // [sp+71Ch] [bp-4h]@15

  v24 = a1;
  memset(&v25, 0, 0x100u);
  v1 = *a1;
  v22 = 1990;
  v20 = 1;
  v21 = 1;
  v23 = 0;
  v19 = v1;
  if ( (unsigned int)dword_10118A20 >= 0xFFFFFFC2 || !dword_10118A20 )
  {
    sub_10019FF0((int)&v20);
    sub_10019FA0((int)&v23);
    sub_1001D840(
      &v25,
      0x100u,
      "%s/%s/%04hu-%02hhu-%02hhu_%02hu%02hhu%02hhu.csv",
      "/mnt/sys_nand0/cmc/",
      "ATN_LOGS",
      v22,
      v20,
      v21,
      (signed __int16)v23,
      BYTE2(v23),
      BYTE3(v23));
    v2 = j_FIL_vfs_open(&v25, 142, 1911);
    dword_10118A20 = v2;
    if ( v2 >= 0xFFFFFFC2 || !v2 )
    {
      v19 = *(_DWORD *)dword_102AD578;
      v1 = *(_DWORD *)dword_102AD578;
    }
    sub_10006B60(0x10u);
  }
  v3 = dword_102AD578;
  result = *(unsigned int **)dword_102AD578;
  if ( *(_DWORD *)dword_102AD578 - v1 > 0xA )
  {
    v19 = (int)result - 10;
    v1 = (unsigned int)result - 10;
  }
  if ( (unsigned int *)v1 == result )
  {
    *a1 = v1;
  }
  else
  {
    while ( 1 )
    {
      v5 = v1 % 0xA;
      memset(v26, 0, 0x600u);
      v6 = 258 * v5;
      v7 = sub_1001D840(v26, 0x600u, "%hhu, %hhu", *(_BYTE *)(258 * v5 + v3 + 4), *(_BYTE *)(258 * v5 + v3 + 5));
      v8 = *(_WORD *)(dword_102AD578 + 2 * v5 + 2584) - 2;
      v9 = &v26[v7];
      if ( v8 < 0 )
      {
        sub_100129A0("..\\lib\\adl\\mon_log.c", 1377, 0, "Invalid data size sent to log");
        v8 = 0;
      }
      for ( i = 0; i < v8; v9 += v11 )
        v11 = sub_1001D840(v9, (char *)&v27 - v9, ", %hhu", *(_BYTE *)(v6 + dword_102AD578 + i++ + 6));
      sub_1001D870(v26, "\n", 1536);
      j_FIL_vfs_write(dword_10118A20, v26, strlen(v26));
      v12 = &v26[1];
      v13 = strlen(v26);
      v16 = __OFADD__(v13, qword_1017A580);
      v14 = ((unsigned __int64)v13 + qword_1017A580) >> 32 == 0;
      v15 = ((((unsigned __int64)v13 + qword_1017A580) >> 32) & 0x80000000) != 0i64;
      qword_1017A580 += v13;
      if ( SHIDWORD(qword_1017A580) >= 0
        && (!((unsigned __int8)(v15 ^ v16) | v14) || (unsigned int)qword_1017A580 > 0x200000) )
      {
        sub_10005E60(0);
      }
      j_FIL_vfs_clean_invalidate_cache(dword_10118A20, v12);
      v3 = dword_102AD578;
      v17 = v19++ + 1;
      if ( v19 == *(_DWORD *)dword_102AD578 )
        break;
      v1 = v19;
    }
    v18 = v17;
    result = v24;
    *v24 = v18;
  }
  return result;
}
// 1003E390: using guessed type int __fastcall j_FIL_vfs_clean_invalidate_cache(_DWORD, _DWORD);
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 10118A20: using guessed type int dword_10118A20;
// 1017A580: using guessed type __int64 qword_1017A580;
// 102AD578: using guessed type int dword_102AD578;
// 10006EA0: using guessed type char var_604[1536];

//----- (10007170) --------------------------------------------------------
int sub_10007170()
{
  unsigned int v0; // esi@1
  void *v1; // edi@1
  int result; // eax@3

  v0 = 0;
  v1 = &unk_1017D098;
  do
  {
    if ( dword_1018F088[v0] )
      result = sub_10006790(v1, &dword_1018F088[v0], 0x1000u, v0, *(&dword_1017A4A8 + v0));
    ++v0;
    v1 = (char *)v1 + 4096;
  }
  while ( v0 < 0x10 );
  return result;
}
// 1018F088: using guessed type int dword_1018F088[];

//----- (100071C0) --------------------------------------------------------
char __cdecl sub_100071C0(int a1)
{
  unsigned __int8 v1; // bl@1
  char *v2; // edi@1
  int v3; // esi@1
  char *v4; // edx@2
  char v5; // cl@3
  int v6; // eax@11
  int v8; // [sp+10h] [bp-14h]@1
  int *v9; // [sp+14h] [bp-10h]@1
  float *v10; // [sp+18h] [bp-Ch]@1
  unsigned __int8 v11; // [sp+1Ch] [bp-8h]@1

  v1 = 0;
  v11 = 0;
  v8 = 0;
  v10 = flt_1018DAA8;
  v9 = dword_1017A500;
  v2 = byte_1018DEC8;
  v3 = a1 + 44;
  do
  {
    v4 = v2;
    if ( !v2 || (v5 = *v2) != 0 )
    {
LABEL_6:
      sub_1001D720(v3 - 44, v2, 32);
      if ( *((_DWORD *)v2 + 8) )
      {
        if ( !*v9 )
          sub_10006B60(v1);
        *(float *)(v3 - 4) = (double)(unsigned int)*v9 / (double)*((unsigned int *)v2 + 8) * 100.0;
        if ( *v10 > 100.0 )
          *v10 = 100.0;
      }
      *(_DWORD *)v3 = *((_DWORD *)v2 + 8);
      *(_BYTE *)(v3 + 4) = v2[58] != 0;
      *(_DWORD *)(v3 - 12) = sub_10006210(v11);
      v6 = (unsigned __int16)sub_10005C10(v11);
      *(_DWORD *)(v3 - 8) = (unsigned __int16)v6;
      if ( (unsigned __int16)v6 == 0xFFFF )
        *(_DWORD *)(v3 - 8) = 0;
      else
        *(_DWORD *)(v3 - 8) = v6 + 1;
    }
    else
    {
      while ( v5 )
      {
        v5 = (v4++)[1];
        if ( v5 != v4[(_UNKNOWN *)((char *)&unk_10064984 - 284 * v8) - (_UNKNOWN *)byte_1018DEC8] )
          goto LABEL_6;
      }
    }
    ++v8;
    v9 += 2;
    v10 += 13;
    ++v1;
    v2 += 284;
    v3 += 52;
    v11 = v1;
  }
  while ( v1 < 0x10u );
  return 1;
}
// 1017A500: using guessed type int dword_1017A500[];
// 1018DAA8: using guessed type float flt_1018DAA8[];

//----- (10007310) --------------------------------------------------------
char __cdecl sub_10007310(int a1, int a2, void *a3, size_t a4)
{
  unsigned int v4; // eax@3
  unsigned int v5; // esi@3
  char result; // al@5

  memset(a3, 0, a4);
  if ( (unsigned __int8)a1 < 0x10u && byte_1018DEC8[284 * (unsigned __int8)a1] )
  {
    v4 = sub_100065D0(a2, a1);
    v5 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      sub_1001D720((int)a3, &unk_1018DE00, a4);
      sub_1003E3A0(v5);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10007390) --------------------------------------------------------
int __cdecl sub_10007390(unsigned __int8 a1, unsigned __int16 a2, char a3)
{
  int v3; // esi@1
  unsigned int v4; // esi@4
  char v6; // [sp+8h] [bp-170h]@4
  int v7; // [sp+30h] [bp-148h]@4
  int v8; // [sp+34h] [bp-144h]@4
  int v9; // [sp+38h] [bp-140h]@4
  char v10; // [sp+3Ch] [bp-13Ch]@4
  char v11; // [sp+48h] [bp-130h]@2

  v3 = 284 * a1;
  if ( byte_1018DEF2[v3] )
    sub_1001D720((int)&v11, "/mnt/card1/cmc/", 300);
  else
    sub_1001D720((int)&v11, "/mnt/sys_nand0/cmc/", 300);
  sub_1001D870(&v11, &byte_1018DEC8[v3], 300);
  sub_1001D870(&v11, "/.logs_db", 300);
  v4 = j_FIL_vfs_open(&v11, 6, 0);
  sub_1003E730(v4, a2 << 6, 0);
  sub_1003E4B0(v4, &v6, 64);
  v7 = -1;
  v8 = 0;
  v9 = 0;
  v10 = a3;
  sub_1003E730(v4, a2 << 6, 0);
  j_FIL_vfs_write(v4, &v6, 64);
  sub_1003E3A0(v4);
  sub_100071C0((int)&unk_1018DA80);
  return sub_1003E110(41106, (int)&unk_1018DA80, 832);
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100074C0) --------------------------------------------------------
int __usercall sub_100074C0@<eax>(int a1@<ecx>, void *a2@<edx>, char a3, int a4, int a5)
{
  int v5; // ebx@1
  void *v6; // edi@1
  char v7; // dl@1
  unsigned int v8; // eax@2
  int v9; // eax@6
  int v10; // ecx@8
  int v11; // esi@8
  int v12; // eax@16
  char *v13; // eax@16
  _BYTE *v14; // esi@16
  char v15; // cl@17
  int v16; // eax@22
  char v17; // cl@23
  int v18; // eax@28
  char v19; // cl@29
  int v20; // eax@34
  int v21; // eax@36
  int v22; // eax@37
  int v23; // eax@42
  char *v24; // eax@42
  _BYTE *v25; // esi@42
  char v26; // cl@43
  char v27; // cl@48
  char v28; // cl@53
  char v29; // cl@58
  unsigned int v30; // ecx@62
  unsigned int v31; // eax@63
  int v32; // eax@69
  unsigned int v34; // [sp+10h] [bp-78h]@2
  unsigned int v35; // [sp+10h] [bp-78h]@8
  unsigned int v36; // [sp+10h] [bp-78h]@34
  unsigned int v37; // [sp+10h] [bp-78h]@63
  int v38; // [sp+14h] [bp-74h]@32
  unsigned int v39; // [sp+14h] [bp-74h]@62
  int v40; // [sp+18h] [bp-70h]@8
  void *v41; // [sp+1Ch] [bp-6Ch]@33
  char v42; // [sp+20h] [bp-68h]@6
  _BYTE v43[3]; // [sp+21h] [bp-67h]@16

  v5 = a1;
  v6 = a2;
  *(_DWORD *)a5 = 0;
  *(_DWORD *)a2 = 0;
  v7 = 1;
  if ( !*((_BYTE *)&dword_1018D098 + (unsigned __int8)a3) )
    return sub_10006790(v6, (_DWORD *)a5, 0x400u, 16, v5);
  *((_BYTE *)&dword_1018D098 + (unsigned __int8)a3) = 0;
  v8 = 0;
  v34 = 0;
  do
  {
    if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3] + v8) != 1 )
    {
      if ( !v7 )
      {
        sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, ",", 16);
        v8 = v34;
      }
      v9 = sub_1001CEF0(&byte_10062E54[v8], 1u, (int)&unk_10063AA0, 8, 10);
      sub_1001D840(&v42, 0x64u, "%s", off_10063AA4[2 * v9]);
      sub_10006DB0(0x400u, v5, v6, strlen(&v42), (_DWORD *)a5, &v42, 16);
      v8 = v34;
      v7 = 0;
    }
    v34 = ++v8;
  }
  while ( v8 < 0xA );
  v10 = 0;
  v11 = 284 * (unsigned __int8)a3;
  v35 = 0;
  v40 = 284 * (unsigned __int8)a3;
  while ( 1 )
  {
    if ( *(&byte_1018DFD7[v11] + v10) == 1 )
      goto LABEL_31;
    if ( byte_10063B48[v10] )
    {
      if ( byte_10063B48[v10] == 1 )
      {
        if ( !(byte_1018DEEC[v11] & 4) )
          goto LABEL_31;
        if ( !v7 )
          sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, ",", 16);
        v16 = sub_1001CEF0(&byte_10063B48[v35], 1u, (int)&unk_10063B4C, 8, 3);
        sub_1001D840(&v42, 0x64u, "%s", off_10063B50[2 * v16]);
        v13 = &v42;
        v14 = v43;
        do
          v17 = *v13++;
        while ( v17 );
      }
      else
      {
        if ( !(byte_1018DEEC[v11] & 4) )
          goto LABEL_31;
        if ( !v7 )
          sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, ",", 16);
        v12 = sub_1001CEF0(&byte_10063B48[v35], 1u, (int)&unk_10063B4C, 8, 3);
        sub_1001D840(&v42, 0x64u, "%s", off_10063B50[2 * v12]);
        v13 = &v42;
        v14 = v43;
        do
          v15 = *v13++;
        while ( v15 );
      }
    }
    else
    {
      if ( !(byte_1018DEEC[v11] & 4) )
        goto LABEL_31;
      if ( !v7 )
        sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, ",", 16);
      v18 = sub_1001CEF0(&byte_10063B48[v35], 1u, (int)&unk_10063B4C, 8, 3);
      sub_1001D840(&v42, 0x64u, "%s", off_10063B50[2 * v18]);
      v13 = &v42;
      v14 = v43;
      do
        v19 = *v13++;
      while ( v19 );
    }
    sub_10006DB0(0x400u, v5, v6, v13 - v14, (_DWORD *)a5, &v42, 16);
    v7 = 0;
LABEL_31:
    v10 = v35++ + 1;
    if ( v35 >= 3 )
      break;
    v11 = 284 * (unsigned __int8)a3;
  }
  v38 = 0;
  if ( !byte_1017BF64 )
    goto LABEL_62;
  v41 = &unk_1017B3A9;
  while ( 2 )
  {
    v20 = 0;
    v36 = 0;
    while ( 2 )
    {
      if ( *(&byte_1018DFDA[v40] + v20) == 1 )
        goto LABEL_60;
      v21 = (unsigned __int8)byte_100632F4[v20];
      if ( !v21 )
      {
        if ( !v7 )
          sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, ",", 16);
        sub_1001D840(&v42, 0x64u, "\"%s ID\"", v41);
        v24 = &v42;
        v25 = v43;
        do
          v29 = *v24++;
        while ( v29 );
        goto LABEL_59;
      }
      v22 = v21 - 1;
      if ( !v22 )
      {
        if ( !v7 )
          sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, ",", 16);
        sub_1001D840(&v42, 0x64u, "\"%s Value\"", v41);
        v24 = &v42;
        v25 = v43;
        do
          v28 = *v24++;
        while ( v28 );
        goto LABEL_59;
      }
      if ( v22 == 1 )
      {
        if ( !v7 )
          sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, ",", 16);
        sub_1001D840(&v42, 0x64u, "\"%s Units\"", v41);
        v24 = &v42;
        v25 = v43;
        do
          v27 = *v24++;
        while ( v27 );
LABEL_59:
        sub_10006DB0(0x400u, v5, v6, v24 - v25, (_DWORD *)a5, &v42, 16);
        v7 = 0;
        goto LABEL_60;
      }
      if ( v38 == (unsigned __int8)byte_1017BF64 - 1 )
      {
        if ( !v7 )
          sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, ",", 16);
        v23 = sub_1001CEF0(&byte_100632F4[v36], 1u, (int)&unk_10063B28, 8, 4);
        sub_1001D840(&v42, 0x64u, "%s", off_10063B2C[2 * v23]);
        v24 = &v42;
        v25 = v43;
        do
          v26 = *v24++;
        while ( v26 );
        goto LABEL_59;
      }
LABEL_60:
      v20 = v36++ + 1;
      if ( v36 < 4 )
        continue;
      break;
    }
    v41 = (char *)v41 + 21;
    if ( ++v38 < (unsigned int)(unsigned __int8)byte_1017BF64 )
      continue;
    break;
  }
LABEL_62:
  v30 = 0;
  v39 = 0;
  if ( *(_BYTE *)(a4 + 2) )
  {
    do
    {
      v31 = 0;
      v37 = 0;
      do
      {
        if ( *(&byte_1018DFDE[v40] + v31) != 1 && (byte_10063AF0[v31] != 5 || v30 == *(_BYTE *)(a4 + 2) - 1) )
        {
          if ( !v7 )
          {
            sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, ",", 16);
            v31 = v37;
          }
          v32 = sub_1001CEF0(&byte_10063AF0[v31], 1u, (int)&unk_10063AF8, 8, 6);
          sub_1001D840(&v42, 0x64u, "%s", off_10063AFC[2 * v32]);
          sub_10006DB0(0x400u, v5, v6, strlen(&v42), (_DWORD *)a5, &v42, 16);
          v7 = 0;
          v31 = v37;
          v30 = v39;
        }
        v37 = ++v31;
      }
      while ( v31 < 6 );
      v39 = ++v30;
    }
    while ( v30 < *(_BYTE *)(a4 + 2) );
  }
  sub_10006DB0(0x400u, v5, v6, 1u, (_DWORD *)a5, "\n", 16);
  return sub_10006790(v6, (_DWORD *)a5, 0x400u, 16, v5);
}
// 1017BF64: using guessed type char byte_1017BF64;
// 1018D098: using guessed type int dword_1018D098;

//----- (10007B70) --------------------------------------------------------
void *__usercall sub_10007B70@<eax>(double st7_0@<st0>, char a1, char a2)
{
  char v3; // bl@1
  char *v4; // edi@1
  void *result; // eax@1
  int *v6; // eax@8
  char v7; // cl@9
  int *v8; // eax@12
  char v9; // cl@13
  char *v10; // eax@18
  char v11; // cl@19
  unsigned __int8 v12; // al@20
  char *v13; // ecx@21
  char *v14; // eax@23
  char v15; // cl@24
  int v16; // edx@25
  char *v17; // eax@28
  char v18; // cl@29
  int v19; // eax@33
  __int16 *v20; // eax@35
  int v21; // eax@35
  char *v22; // eax@42
  char v23; // cl@43
  int v24; // edx@47
  bool v25; // zf@48
  unsigned __int8 v26; // [sp+13h] [bp-131h]@14
  int *v27; // [sp+14h] [bp-130h]@1
  unsigned __int8 v28; // [sp+1Bh] [bp-129h]@33
  void *v29; // [sp+1Ch] [bp-128h]@38
  void *v30; // [sp+20h] [bp-124h]@1
  int v31; // [sp+24h] [bp-120h]@1
  __int16 *v32; // [sp+28h] [bp-11Ch]@35
  int v33; // [sp+2Ch] [bp-118h]@38
  int v34; // [sp+30h] [bp-114h]@36
  int v35; // [sp+34h] [bp-110h]@41
  int i; // [sp+38h] [bp-10Ch]@33
  char v37; // [sp+3Ch] [bp-108h]@27
  char v38; // [sp+48h] [bp-FCh]@28
  _BYTE v39[3]; // [sp+49h] [bp-FBh]@30
  char v40; // [sp+7Ch] [bp-C8h]@1
  _BYTE v41[3]; // [sp+7Dh] [bp-C7h]@25
  char v42; // [sp+D4h] [bp-70h]@17
  char v43; // [sp+F4h] [bp-50h]@18
  _BYTE v44[3]; // [sp+F5h] [bp-4Fh]@20
  int v45; // [sp+10Ch] [bp-38h]@1
  __int16 v46; // [sp+110h] [bp-34h]@1
  char v47; // [sp+112h] [bp-32h]@1
  char v48; // [sp+114h] [bp-30h]@42
  _BYTE v49[3]; // [sp+115h] [bp-2Fh]@44

  v3 = a1;
  v27 = &dword_1018F088[(unsigned __int8)a1];
  v4 = (char *)&unk_1017D098 + 4096 * (unsigned __int8)a1;
  v45 = 0;
  v46 = 0;
  v47 = 0;
  sub_1000D660(&v40);
  result = &unk_10064668;
  v30 = &unk_10064668;
  v31 = 10;
  do
  {
    if ( *(_BYTE *)result != 20 || word_1018DF04[142 * (unsigned __int8)v3] != -1 )
    {
      sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 1u, v27, result, v3);
      switch ( *(_BYTE *)v30 )
      {
        case 0:
          sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 4u, v27, &a2, v3);
          break;
        case 1:
          if ( dword_1017A588 != 0x3FFFF )
            sub_1000F7D0(dword_1017A588, (int)&v45);
          v6 = &v45;
          do
          {
            v7 = *(_BYTE *)v6;
            v6 = (int *)((char *)v6 + 1);
          }
          while ( v7 );
          if ( v6 == (int *)((char *)&v45 + 1) )
            sub_1001D720((int)&v45, "____", 7);
          v8 = &v45;
          do
          {
            v9 = *(_BYTE *)v8;
            v8 = (int *)((char *)v8 + 1);
          }
          while ( v9 );
          v26 = (_BYTE)v8 - ((unsigned int)&v45 + 1);
          sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 1u, v27, &v26, v3);
          sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, v26, v27, &v45, v3);
          break;
        case 2:
          sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 1u, v27, &a1, v3);
          v3 = a1;
          break;
        case 3:
          sub_10006DB0(
            0x1000u,
            *(&dword_1017A4A8 + (unsigned __int8)v3),
            v4,
            2u,
            v27,
            (char *)&unk_1018DEF0 + 284 * (unsigned __int8)v3,
            v3);
          break;
        case 4:
          sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 8u, v27, &v42, v3);
          break;
        case 5:
          v10 = &v43;
          do
            v11 = *v10++;
          while ( v11 );
          v26 = (_BYTE)v10 - (unsigned int)v44;
          sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 1u, v27, &v26, v3);
          v12 = v26;
          if ( v26 )
          {
            v13 = &v43;
            goto LABEL_22;
          }
          break;
        case 6:
          v14 = &v40;
          do
            v15 = *v14++;
          while ( v15 );
          v16 = *(&dword_1017A4A8 + (unsigned __int8)v3);
          v26 = (_BYTE)v14 - (unsigned int)v41;
          sub_10006DB0(0x1000u, v16, v4, 1u, v27, &v26, v3);
          if ( v26 )
            sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, v26, v27, &v40, v3);
          break;
        case 7:
          v26 = 0;
          if ( sub_1001D9F0(&v37) )
          {
            v17 = &v38;
            do
              v18 = *v17++;
            while ( v18 );
            v26 = (_BYTE)v17 - (unsigned int)v39;
          }
          sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 1u, v27, &v26, v3);
          v12 = v26;
          if ( v26 )
          {
            v13 = &v38;
LABEL_22:
            sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, v12, v27, v13, v3);
          }
          break;
        case 0x14:
          v19 = 142 * (unsigned __int8)v3;
          v28 = 0;
          for ( i = 142 * (unsigned __int8)v3; ; v19 = i )
          {
            v20 = &word_1018DF04[v19 + v28];
            v32 = v20;
            v21 = (unsigned __int16)*v20;
            if ( (_WORD)v21 == -1 )
              break;
            sub_1000D630(st7_0, v21, &v34);
            if ( v28 )
              sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 1u, v27, v30, v3);
            v29 = &unk_10064674;
            v33 = 3;
            do
            {
              sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 1u, v27, v29, v3);
              if ( *(_BYTE *)v29 == 21 )
              {
                sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 2u, v27, v32, v3);
              }
              else if ( *(_BYTE *)v29 == 22 )
              {
                sub_1001D840(&v48, 0x2Au, "%s", v34 + 38);
                v22 = &v48;
                do
                  v23 = *v22++;
                while ( v23 );
                v26 = (_BYTE)v22 - (unsigned int)v49;
                sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 1u, v27, &v26, v3);
                sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, v26, v27, &v48, v3);
              }
              else
              {
                v35 = dword_10063BF4[4 * sub_1001CEF0((_DWORD *)(v34 + 60), 4u, (int)dword_10063BE8, 16, 168)];
                sub_10006DB0(0x1000u, *(&dword_1017A4A8 + (unsigned __int8)v3), v4, 4u, v27, &v35, v3);
              }
              v29 = (char *)v29 + 1;
              --v33;
            }
            while ( v33 );
            v24 = *(&dword_1017A4A8 + (unsigned __int8)v3);
            v26 = 24;
            sub_10006DB0(0x1000u, v24, v4, 1u, v27, &v26, v3);
            if ( ++v28 >= 0x64u )
              break;
          }
          break;
        default:
          break;
      }
    }
    result = (char *)v30 + 1;
    v25 = v31-- == 1;
    v30 = (char *)v30 + 1;
  }
  while ( !v25 );
  return result;
}
// 10063BE8: using guessed type int dword_10063BE8[];
// 10063BF4: using guessed type int dword_10063BF4[];
// 1017A588: using guessed type int dword_1017A588;
// 1018DF04: using guessed type __int16 word_1018DF04[];
// 1018F088: using guessed type int dword_1018F088[];

//----- (10008160) --------------------------------------------------------
void *__usercall sub_10008160@<eax>(int a1@<edx>, int a2@<ecx>, int a3, unsigned __int8 a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  unsigned int v10; // eax@1
  int v11; // eax@7
  int v12; // ebx@7
  int v13; // eax@10
  size_t v14; // eax@15
  unsigned int v15; // esi@26
  _DWORD *v16; // ebx@27
  int v17; // eax@28
  int v18; // eax@30
  int v19; // eax@31
  char *v20; // eax@36
  _BYTE *v21; // edx@36
  char v22; // cl@37
  int v23; // eax@41
  size_t v24; // eax@41
  int v25; // eax@43
  char v26; // cl@56
  char v27; // cl@61
  bool v28; // zf@66
  float *v29; // ebx@67
  int v30; // ecx@67
  int v31; // eax@68
  size_t v32; // eax@73
  int v33; // eax@80
  int v34; // eax@92
  int v35; // eax@99
  unsigned int v36; // edx@103
  void *result; // eax@104
  char *v38; // [sp-8h] [bp-4D0h]@45
  char *v39; // [sp-8h] [bp-4D0h]@82
  int *v40; // [sp-4h] [bp-4CCh]@15
  int *v41; // [sp-4h] [bp-4CCh]@89
  char *v42; // [sp+0h] [bp-4C8h]@15
  char *v43; // [sp+0h] [bp-4C8h]@45
  double v44; // [sp+0h] [bp-4C8h]@47
  char *v45; // [sp+0h] [bp-4C8h]@82
  char *v46; // [sp+0h] [bp-4C8h]@89
  char v47; // [sp+4h] [bp-4C4h]@15
  float v48; // [sp+4h] [bp-4C4h]@45
  int v49; // [sp+4h] [bp-4C4h]@82
  char v50; // [sp+4h] [bp-4C4h]@89
  char v51; // [sp+1Fh] [bp-4A9h]@1
  int v52; // [sp+20h] [bp-4A8h]@1
  int v53; // [sp+24h] [bp-4A4h]@1
  unsigned int v54; // [sp+28h] [bp-4A0h]@1
  unsigned int v55; // [sp+2Ch] [bp-49Ch]@26
  float v56; // [sp+30h] [bp-498h]@1
  char v57[4]; // [sp+34h] [bp-494h]@1
  int v58; // [sp+38h] [bp-490h]@1
  _BYTE *v59; // [sp+3Ch] [bp-48Ch]@67
  int i; // [sp+40h] [bp-488h]@7
  int v61; // [sp+44h] [bp-484h]@1
  int v62; // [sp+48h] [bp-480h]@1
  int v63; // [sp+4Ch] [bp-47Ch]@1
  int v64; // [sp+50h] [bp-478h]@1
  float *v65; // [sp+54h] [bp-474h]@1
  char v66; // [sp+58h] [bp-470h]@5
  _BYTE v67[3]; // [sp+59h] [bp-46Fh]@36
  char v68; // [sp+C0h] [bp-408h]@1

  v65 = (float *)a6;
  v62 = a8;
  v63 = a2;
  *(_DWORD *)v57 = a1;
  v53 = a3;
  v58 = a5;
  v61 = a9;
  v64 = a10;
  v52 = 0;
  memset(&v68, 0, 0x400u);
  v51 = 1;
  sub_100074C0(a3, &v68, a4, a5, (int)&v52);
  v10 = 0;
  v54 = 0;
  LODWORD(v56) = &byte_1018DFCD[284 * a4];
  do
  {
    if ( *(_BYTE *)(LODWORD(v56) + v10) != 1 )
    {
      if ( !v51 )
      {
        sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
        v10 = v54;
      }
      v51 = 0;
      sub_100068E0(v58, &v66, byte_10062E54[v10], 0x64u);
      sub_10006DB0(0x400u, v53, &v68, strlen(&v66), &v52, &v66, 16);
      v10 = v54;
    }
    v54 = ++v10;
  }
  while ( v10 < 0xA );
  v11 = 0;
  v12 = 284 * a4;
  v54 = 0;
  for ( i = 284 * a4; ; v12 = i )
  {
    if ( *(&byte_1018DFD7[v12] + v11) == 1 )
      goto LABEL_25;
    v13 = (unsigned __int8)byte_10063B48[v11];
    if ( v13 )
    {
      if ( v13 == 1 )
      {
        if ( !(byte_1018DEEC[v12] & 4) )
          goto LABEL_25;
        if ( !v51 )
          sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
        v51 = 0;
        sub_1001D840(&v66, 0x64u, "\"%hd\"", (unsigned __int16)word_1017B388);
        v47 = 16;
        v14 = strlen(&v66);
        v42 = &v66;
        v40 = &v52;
      }
      else
      {
        if ( !(byte_1018DEEC[v12] & 4) )
          goto LABEL_25;
        if ( !v51 )
          sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
        sub_100068E0(v58, &v66, 9, 0x64u);
        v47 = 16;
        v14 = strlen(&v66);
        v42 = &v66;
        v40 = &v52;
      }
    }
    else
    {
      if ( !(byte_1018DEEC[v12] & 4) )
        goto LABEL_25;
      if ( !v51 )
        sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
      v51 = 0;
      sub_1001D840(&v66, 0x64u, "\"%s\"", &unk_1017B38A);
      v14 = strlen(&v66);
      v47 = 16;
      v42 = &v66;
      v40 = &v52;
    }
    sub_10006DB0(0x400u, v53, &v68, v14, v40, v42, v47);
LABEL_25:
    v11 = v54++ + 1;
    if ( v54 >= 3 )
      break;
  }
  v15 = 0;
  v55 = 0;
  if ( !byte_1017BF64 )
    goto LABEL_66;
  v16 = &unk_1017BBE0;
  while ( 2 )
  {
    v17 = 0;
    v54 = 0;
    while ( 2 )
    {
      if ( *(&byte_1018DFDA[i] + v17) == 1 )
        goto LABEL_64;
      v18 = (unsigned __int8)byte_100632F4[v17];
      if ( !v18 )
      {
        if ( !v51 )
          sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
        v51 = 0;
        sub_1001D840(&v66, 0x64u, "\"%hd\"", (unsigned __int16)word_1017BFCA[v55]);
        v20 = &v66;
        v21 = v67;
        do
          v27 = *v20++;
        while ( v27 );
        goto LABEL_62;
      }
      v19 = v18 - 1;
      if ( !v19 )
      {
        if ( dword_10063BE8[4 * sub_1001CEF0(v16 + 100, 4u, (int)dword_10063BE8, 16, 168)] == 1 )
        {
          v25 = sub_1001CEF0(v16, 1u, (int)&unk_10063BA4, 21, 3);
          sub_1001D840(&v66, 0x64u, "\"%s\"", &aInactive[21 * v25]);
        }
        else
        {
          switch ( byte_1017BF65[v15] )
          {
            case 0:
              LODWORD(v48) = *(_BYTE *)v16;
              v43 = "\"%hhu\"";
              v38 = &v66;
              break;
            case 1:
              v48 = *(float *)v16;
              v43 = "\"%u\"";
              v38 = &v66;
              break;
            case 2:
              v56 = *(float *)v16;
              v44 = v56;
              if ( (LODWORD(v56) & 0x7F800000) == 2139095040 )
                sub_1001D840(&v66, 0x64u, "\"%f\"", v44);
              else
                sub_1001D840(&v66, 0x64u, "\"%.*f\"", (unsigned __int8)byte_1017BF00[v15], v44);
              goto LABEL_53;
            case 3:
              LODWORD(v48) = *(_WORD *)v16;
              v43 = "\"%hd\"";
              v38 = &v66;
              break;
            default:
              v48 = *(float *)v16;
              v43 = "\"%d\"";
              v38 = &v66;
              break;
          }
          sub_1001D840(v38, 0x64u, v43, v48);
        }
LABEL_53:
        if ( !v51 )
          sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
        v20 = &v66;
        v51 = 0;
        v21 = v67;
        do
          v26 = *v20++;
        while ( v26 );
LABEL_62:
        v24 = v20 - v21;
LABEL_63:
        sub_10006DB0(0x400u, v53, &v68, v24, &v52, &v66, 16);
        goto LABEL_64;
      }
      if ( v19 == 1 )
      {
        if ( !v51 )
          sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
        v51 = 0;
        v23 = sub_1001CEF0(v16 + 100, 4u, (int)&unk_10062E60, 16, 68);
        sub_1001D840(&v66, 0x64u, "\"%s\"", (char *)&unk_10062E64 + 16 * v23);
        v24 = strlen(&v66);
        goto LABEL_63;
      }
      if ( v15 == (unsigned __int8)byte_1017BF64 - 1 )
      {
        if ( !v51 )
          sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
        v51 = 0;
        sub_1001D840(&v66, 0x64u, "\"%s\"", "^");
        v20 = &v66;
        v21 = v67;
        do
          v22 = *v20++;
        while ( v22 );
        goto LABEL_62;
      }
LABEL_64:
      v15 = v55;
      v17 = v54++ + 1;
      if ( v54 < 4 )
        continue;
      break;
    }
    v15 = v55 + 1;
    ++v16;
    v55 = v15;
    if ( v15 < (unsigned __int8)byte_1017BF64 )
      continue;
    break;
  }
LABEL_66:
  v28 = *(_BYTE *)(v58 + 2) == 0;
  v55 = 0;
  if ( !v28 )
  {
    v29 = v65;
    LODWORD(v56) = v62 - (_DWORD)v65;
    v62 = a7 - *(_DWORD *)v57;
    v30 = v61 - *(_DWORD *)v57;
    v59 = *(_BYTE **)v57;
    *(_DWORD *)v57 = v63;
    v61 = v30;
    do
    {
      v31 = 0;
      v54 = 0;
      do
      {
        if ( *(&byte_1018DFDE[i] + v31) != 1 )
        {
          switch ( v31 )
          {
            case 0:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
              if ( !v51 )
                sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
              v51 = 0;
              sub_1001D840(&v66, 0x64u, "\"%hd\"", *(_WORD *)(v64 + 2 * v55));
              v32 = strlen(&v66);
              break;
            case 1:
              if ( !v51 )
                sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
              v51 = 0;
              sub_1001D840(&v66, 0x64u, "\"%s\"", *(_DWORD *)v57);
              v32 = strlen(&v66);
              break;
            case 2:
              if ( !v51 )
                sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
              v51 = 0;
              if ( dword_10063BE8[4
                                * sub_1001CEF0((float *)((char *)v29 + LODWORD(v56)), 4u, (int)dword_10063BE8, 16, 168)] == 1 )
              {
                v33 = sub_1001CEF0(v29, 1u, (int)&unk_10063BA4, 21, 3);
                sub_1001D840(&v66, 0x64u, "\"%s\"", &aInactive[21 * v33]);
              }
              else
              {
                switch ( v59[v62] )
                {
                  case 0:
                    v49 = *(_BYTE *)v29;
                    v45 = "\"%hhu\"";
                    v39 = &v66;
                    break;
                  case 1:
                    v49 = *(_DWORD *)v29;
                    v45 = "\"%u\"";
                    goto LABEL_87;
                  case 2:
                    sub_1001D840(&v66, 0x64u, "\"%.*f\"", *v59, *v29);
                    goto LABEL_89;
                  case 3:
                    v49 = *(_WORD *)v29;
                    v45 = "\"%hd\"";
                    v39 = &v66;
                    break;
                  default:
                    v49 = *(_DWORD *)v29;
                    v45 = "\"%d\"";
LABEL_87:
                    v39 = &v66;
                    break;
                }
                sub_1001D840(v39, 0x64u, v45, v49);
              }
LABEL_89:
              v32 = strlen(&v66);
              v50 = 16;
              v46 = &v66;
              v41 = &v52;
              goto LABEL_101;
            case 3:
              if ( !v51 )
                sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
              v51 = 0;
              v34 = sub_1001CEF0((float *)((char *)v29 + LODWORD(v56)), 4u, (int)&unk_10062E60, 16, 68);
              sub_1001D840(&v66, 0x64u, "\"%s\"", (char *)&unk_10062E64 + 16 * v34);
              v50 = 16;
              v32 = strlen(&v66);
              v46 = &v66;
              v41 = &v52;
              goto LABEL_101;
            case 5:
              if ( v55 != *(_BYTE *)(v58 + 2) - 1 )
                goto LABEL_102;
              if ( !v51 )
                sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
              v51 = 0;
              sub_1001D840(&v66, 0x64u, "\"%s\"", "^");
              v32 = strlen(&v66);
              break;
            default:
              if ( !v51 )
                sub_10006DB0(0x400u, v53, &v68, 1u, &v52, ",", 16);
              v51 = 0;
              v35 = sub_1001CEF0(&v59[v61], 1u, (int)&unk_100632A0, 21, 4);
              sub_1001D840(&v66, 0x64u, "\"%s\"", &aInactive_0[21 * v35]);
              v32 = strlen(&v66);
              break;
          }
          v50 = 16;
          v46 = &v66;
          v41 = &v52;
LABEL_101:
          sub_10006DB0(0x400u, v53, &v68, v32, v41, v46, v50);
        }
LABEL_102:
        v31 = v54++ + 1;
      }
      while ( v54 < 6 );
      v36 = *(_BYTE *)(v58 + 2);
      *(_DWORD *)v57 += 21;
      ++v59;
      ++v29;
      ++v55;
    }
    while ( v55 < v36 );
  }
  result = sub_10006DB0(0x400u, v53, &v68, 1u, &v52, "\n", 16);
  if ( v52 )
    result = (void *)sub_10006790(&v68, &v52, 0x400u, 16, v53);
  return result;
}
// 10063BE8: using guessed type int dword_10063BE8[];
// 1017B388: using guessed type __int16 word_1017B388;
// 1017BF64: using guessed type char byte_1017BF64;
// 1017BFCA: using guessed type __int16 word_1017BFCA[];

//----- (10008D10) --------------------------------------------------------
signed int __usercall sub_10008D10@<eax>(int a1@<edx>, int a2@<ecx>, char a3@<bl>, double st7_0@<st0>, int a4, _WORD *a5, int a6, int a7, int a8, int a9, int a10)
{
  _WORD *v11; // esi@1
  int v12; // edx@1
  char *v13; // edi@1
  _DWORD *v14; // eax@1
  int v15; // eax@4
  int v16; // eax@8
  int v17; // eax@10
  int v18; // eax@12
  int v19; // eax@14
  char *v20; // eax@15
  char v21; // cl@16
  int v22; // eax@19
  int v23; // eax@21
  char *v24; // eax@22
  char v25; // cl@23
  int v26; // eax@26
  char *v27; // eax@27
  char v28; // cl@28
  int v29; // eax@31
  char *v30; // eax@32
  char v31; // cl@33
  int v32; // esi@36
  int v33; // eax@36
  char *v34; // eax@39
  char v35; // cl@40
  int v36; // esi@44
  int v37; // eax@44
  bool v38; // zf@49
  int v39; // eax@52
  int v40; // eax@52
  size_t v41; // esi@53
  void *v42; // ecx@54
  int v43; // edx@54
  int v44; // edx@55
  char *v45; // eax@55
  char v46; // cl@56
  int v47; // eax@59
  int v48; // edx@61
  float v49; // ST1C_4@62
  float v50; // ST1C_4@63
  float v51; // ST1C_4@64
  float v52; // ST1C_4@65
  float v53; // ecx@67
  bool v54; // cf@75
  int v55; // eax@78
  __int16 *v56; // eax@79
  int v57; // ecx@79
  int v58; // edx@81
  float v59; // ST1C_4@82
  float v60; // ST1C_4@83
  float v61; // ST1C_4@84
  float v62; // ST1C_4@85
  signed int result; // eax@93
  void *v64; // [sp-Ch] [bp-1A8h]@5
  char v65; // [sp-8h] [bp-1A4h]@5
  unsigned __int8 v66; // [sp+16h] [bp-186h]@17
  unsigned __int8 v67; // [sp+17h] [bp-185h]@49
  int v68; // [sp+18h] [bp-184h]@1
  _DWORD *v69; // [sp+1Ch] [bp-180h]@1
  float v70; // [sp+20h] [bp-17Ch]@62
  void *v71; // [sp+24h] [bp-178h]@55
  __int16 *v72; // [sp+28h] [bp-174h]@50
  int v73; // [sp+2Ch] [bp-170h]@1
  _WORD *v74; // [sp+30h] [bp-16Ch]@1
  float v75; // [sp+34h] [bp-168h]@51
  _DWORD *v76; // [sp+38h] [bp-164h]@51
  int v77; // [sp+3Ch] [bp-160h]@38
  int v78; // [sp+40h] [bp-15Ch]@1
  int v79; // [sp+44h] [bp-158h]@79
  int v80; // [sp+48h] [bp-154h]@1
  int v81; // [sp+4Ch] [bp-150h]@1
  int v82; // [sp+50h] [bp-14Ch]@1
  int v83; // [sp+54h] [bp-148h]@1
  int v84; // [sp+58h] [bp-144h]@1
  int v85; // [sp+5Ch] [bp-140h]@1
  char v86; // [sp+60h] [bp-13Ch]@1
  char v87; // [sp+62h] [bp-13Ah]@15
  char v88; // [sp+63h] [bp-139h]@17
  char v89; // [sp+81h] [bp-11Bh]@22
  __int16 v90; // [sp+82h] [bp-11Ah]@24
  char v91; // [sp+B4h] [bp-E8h]@27
  _BYTE v92[3]; // [sp+B5h] [bp-E7h]@29
  char v93; // [sp+C9h] [bp-D3h]@32
  __int16 v94; // [sp+CAh] [bp-D2h]@34
  char v95; // [sp+DEh] [bp-BEh]@20
  char v96; // [sp+FCh] [bp-A0h]@39
  char v97; // [sp+FEh] [bp-9Eh]@39
  char v98; // [sp+FFh] [bp-9Dh]@41

  v68 = a4;
  v84 = a6;
  v11 = a5;
  v81 = a1;
  v83 = a9;
  v78 = a8;
  v12 = *a5;
  v73 = a2;
  v82 = a7;
  v74 = a5;
  v85 = a10;
  v13 = (char *)&unk_1017D098 + 4096 * (unsigned __int8)a3;
  sub_10013780((int)&v86, v12);
  v14 = &unk_100646D0;
  v69 = &unk_100646D0;
  v80 = 14;
  while ( 1 )
  {
    switch ( *(_BYTE *)v14 )
    {
      case 0:
        v15 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3]
             + sub_1001CEF0((char *)&unk_100646E9 + 2 * v15, 1u, (int)byte_10062E54, 1, 10)) != 1 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          v65 = a3;
          v64 = v74 + 2;
          goto LABEL_6;
        }
        break;
      case 1:
        v16 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3]
             + sub_1001CEF0((char *)&unk_100646E9 + 2 * v16, 1u, (int)byte_10062E54, 1, 10)) != 1 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          v65 = a3;
          v64 = v74 + 4;
LABEL_6:
          sub_10006DB0(0x1000u, v68, v13, 4u, &dword_1018F088[(unsigned __int8)a3], v64, v65);
        }
        break;
      case 2:
        v17 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3]
             + sub_1001CEF0((char *)&unk_100646E9 + 2 * v17, 1u, (int)byte_10062E54, 1, 10)) != 1 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], (char *)v74 + 3, a3);
        }
        break;
      case 3:
        v18 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3]
             + sub_1001CEF0((char *)&unk_100646E9 + 2 * v18, 1u, (int)byte_10062E54, 1, 10)) != 1 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          sub_10006DB0(0x1000u, v68, v13, 2u, &dword_1018F088[(unsigned __int8)a3], v74, a3);
        }
        break;
      case 4:
        v19 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3]
             + sub_1001CEF0((char *)&unk_100646E9 + 2 * v19, 1u, (int)byte_10062E54, 1, 10)) != 1 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          v20 = &v87;
          do
            v21 = *v20++;
          while ( v21 );
          v66 = (_BYTE)v20 - (unsigned int)&v88;
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v66, a3);
          if ( v66 )
            sub_10006DB0(0x1000u, v68, v13, v66, &dword_1018F088[(unsigned __int8)a3], &v87, a3);
        }
        break;
      case 5:
        v22 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3]
             + sub_1001CEF0((char *)&unk_100646E9 + 2 * v22, 1u, (int)byte_10062E54, 1, 10)) != 1 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v95, a3);
        }
        break;
      case 6:
        v23 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3]
             + sub_1001CEF0((char *)&unk_100646E9 + 2 * v23, 1u, (int)byte_10062E54, 1, 10)) != 1 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          v24 = &v89;
          do
            v25 = *v24++;
          while ( v25 );
          v66 = (_BYTE)v24 - (unsigned int)&v90;
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v66, a3);
          if ( v66 )
            sub_10006DB0(0x1000u, v68, v13, v66, &dword_1018F088[(unsigned __int8)a3], &v89, a3);
        }
        break;
      case 7:
        v26 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3]
             + sub_1001CEF0((char *)&unk_100646E9 + 2 * v26, 1u, (int)byte_10062E54, 1, 10)) != 1 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          v27 = &v91;
          do
            v28 = *v27++;
          while ( v28 );
          v66 = (_BYTE)v27 - (unsigned int)v92;
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v66, a3);
          if ( v66 )
            sub_10006DB0(0x1000u, v68, v13, v66, &dword_1018F088[(unsigned __int8)a3], &v91, a3);
        }
        break;
      case 8:
        v29 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFCD[284 * (unsigned __int8)a3]
             + sub_1001CEF0((char *)&unk_100646E9 + 2 * v29, 1u, (int)byte_10062E54, 1, 10)) != 1 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          v30 = &v93;
          do
            v31 = *v30++;
          while ( v31 );
          v66 = (_BYTE)v30 - (unsigned int)&v94;
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v66, a3);
          if ( v66 )
            sub_10006DB0(0x1000u, v68, v13, v66, &dword_1018F088[(unsigned __int8)a3], &v93, a3);
        }
        break;
      case 9:
        v32 = 284 * (unsigned __int8)a3;
        v33 = sub_1001CEF0(v14, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFD7[sub_1001CEF0((char *)&unk_100646E9 + 2 * v33, 1u, (int)byte_10063B48, 1, 3)] + v32) != 1
          && byte_1018DEEC[v32] & 4 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          v66 = 0;
          if ( sub_10013BA0(1u, &v77) )
          {
            sub_10013780((int)&v96, v77);
            v34 = &v97;
            do
              v35 = *v34++;
            while ( v35 );
            v66 = (_BYTE)v34 - (unsigned int)&v98;
          }
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v66, a3);
          if ( v66 )
            sub_10006DB0(0x1000u, v68, v13, v66, &dword_1018F088[(unsigned __int8)a3], &v97, a3);
        }
        break;
      case 0xA:
        v36 = 284 * (unsigned __int8)a3;
        v37 = sub_1001CEF0(v69, 1u, (int)&unk_100646E8, 2, 17);
        if ( *(&byte_1018DFD7[sub_1001CEF0((char *)&unk_100646E9 + 2 * v37, 1u, (int)byte_10063B48, 1, 3)] + v36) != 1
          && byte_1018DEEC[v36] & 4 )
        {
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          if ( !sub_10013BA0(1u, &v77) )
            v77 = 0xFFFF;
          sub_10006DB0(0x1000u, v68, v13, 2u, &dword_1018F088[(unsigned __int8)a3], &v77, a3);
        }
        break;
      case 0x14:
        v38 = *((_BYTE *)v11 + 2) == 0;
        v67 = 0;
        if ( !v38 )
        {
          v72 = (__int16 *)(284 * (unsigned __int8)a3);
          do
          {
            sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
            v76 = &unk_100646E0;
            LODWORD(v75) = 5;
            do
            {
              v39 = sub_1001CEF0(v76, 1u, (int)&unk_100646E8, 2, 17);
              v40 = sub_1001CEF0((char *)&unk_100646E9 + 2 * v39, 1u, (int)byte_10063AF0, 1, 6);
              if ( *((_BYTE *)v72 + v40 + (_DWORD)byte_1018DFDE) != 1 )
              {
                v41 = 1;
                sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v76, a3);
                switch ( *(_BYTE *)v76 )
                {
                  case 0x15:
                    v42 = (void *)(v85 + 2 * v67);
                    v43 = *(&dword_1017A4A8 + (unsigned __int8)a3);
                    v41 = 2;
                    goto LABEL_73;
                  case 0x16:
                    v44 = 21 * v67;
                    v45 = (char *)(v44 + v84);
                    v71 = (void *)(v44 + v84);
                    do
                      v46 = *v45++;
                    while ( v46 );
                    v66 = (_BYTE)v45 - (v44 + v84 + 1);
                    sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v66, a3);
                    if ( v66 )
                      sub_10006DB0(0x1000u, v68, v13, v66, &dword_1018F088[(unsigned __int8)a3], v71, a3);
                    break;
                  case 0x17:
                    v47 = *(_DWORD *)(v78 + 4 * v67);
                    if ( v47 && v47 != 1 )
                    {
                      v48 = *(_BYTE *)(v81 + v67);
                      v66 = 2;
                      switch ( v48 )
                      {
                        case 0:
                          v71 = (void *)*(_BYTE *)(v73 + 4 * v67);
                          v49 = (double)(signed int)v71;
                          st7_0 = sub_100061C0(v49, v47);
                          v70 = st7_0;
                          break;
                        case 3:
                          v71 = (void *)*(_WORD *)(v73 + 4 * v67);
                          v50 = (double)(signed int)v71;
                          st7_0 = sub_100061C0(v50, v47);
                          v70 = st7_0;
                          break;
                        case 4:
                          v51 = (double)*(signed int *)(v73 + 4 * v67);
                          st7_0 = sub_100061C0(v51, v47);
                          v70 = st7_0;
                          break;
                        case 1:
                          v71 = *(void **)(v73 + 4 * v67);
                          v52 = (double)(unsigned int)v71;
                          st7_0 = sub_100061C0(v52, v47);
                          v70 = st7_0;
                          break;
                        default:
                          st7_0 = sub_100061C0(*(float *)(v73 + 4 * v67), v47);
                          v70 = st7_0;
                          break;
                      }
                    }
                    else
                    {
                      v53 = *(float *)(v73 + 4 * v67);
                      v66 = *(_BYTE *)(v81 + v67);
                      v70 = v53;
                    }
                    sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v66, a3);
                    sub_10006DB0(0x1000u, v68, v13, 4u, &dword_1018F088[(unsigned __int8)a3], &v70, a3);
                    if ( v66 != 2 )
                      break;
                    v42 = (void *)(v67 + v82);
                    v41 = 1;
                    goto LABEL_72;
                  case 0x18:
                    v71 = (void *)dword_10063BF4[4
                                               * sub_1001CEF0(
                                                   (_DWORD *)(v78 + 4 * v67),
                                                   4u,
                                                   (int)dword_10063BE8,
                                                   16,
                                                   168)];
                    sub_10006DB0(0x1000u, v68, v13, 4u, &dword_1018F088[(unsigned __int8)a3], &v71, a3);
                    break;
                  default:
                    v42 = (void *)(v83 + v67);
LABEL_72:
                    v43 = v68;
LABEL_73:
                    sub_10006DB0(0x1000u, v43, v13, v41, &dword_1018F088[(unsigned __int8)a3], v42, a3);
                    break;
                }
              }
              v76 = (_DWORD *)((char *)v76 + 1);
              --LODWORD(v75);
            }
            while ( v75 != 0.0 );
            v66 = 34;
            sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v66, a3);
            v54 = (unsigned __int8)(v67++ + 1) < *((_BYTE *)v74 + 2);
          }
          while ( v54 );
        }
        break;
      case 0x23:
        v67 = 0;
        v71 = (void *)(142 * (unsigned __int8)a3);
        do
        {
          v55 = (int)v71 + v67;
          v38 = word_1018DF04[v55] == -1;
          v72 = &word_1018DF04[v55];
          if ( v38 )
            break;
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
          *(float *)&v56 = COERCE_FLOAT(sub_1000D630(st7_0, (unsigned __int16)*v72, &v79));
          v57 = *(_DWORD *)(v79 + 60);
          v75 = *(float *)&v56;
          if ( v57 && v57 != 1 )
          {
            v58 = *(_BYTE *)(v79 + 1);
            v66 = 2;
            switch ( v58 )
            {
              case 0:
                v72 = (__int16 *)(unsigned __int8)v56;
                v59 = (double)(unsigned __int8)v56;
                st7_0 = sub_100061C0(v59, v57);
                v70 = st7_0;
                break;
              case 3:
                v72 = (__int16 *)(signed __int16)v56;
                v60 = (double)(signed __int16)v56;
                st7_0 = sub_100061C0(v60, v57);
                v70 = st7_0;
                break;
              case 4:
                v61 = (double)SLODWORD(v75);
                st7_0 = sub_100061C0(v61, v57);
                v70 = st7_0;
                break;
              case 1:
                v72 = v56;
                v62 = (double)(unsigned int)v56;
                st7_0 = sub_100061C0(v62, v57);
                v70 = st7_0;
                break;
              default:
                st7_0 = sub_100061C0(v75, v57);
                v70 = st7_0;
                break;
            }
          }
          else
          {
            v66 = *(_BYTE *)(v79 + 1);
            v70 = *(float *)&v56;
          }
          sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], &v66, a3);
          sub_10006DB0(0x1000u, v68, v13, 4u, &dword_1018F088[(unsigned __int8)a3], &v70, a3);
          if ( v66 == 2 )
            sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], (void *)(v79 + 59), a3);
          ++v67;
        }
        while ( v67 < 0x64u );
        break;
      default:
        sub_10006DB0(0x1000u, v68, v13, 1u, &dword_1018F088[(unsigned __int8)a3], v69, a3);
        break;
    }
    result = 1;
    v69 = (_DWORD *)((char *)v69 + 1);
    if ( !--v80 )
      return result;
    v14 = v69;
    v11 = v74;
  }
}
// 10063BE8: using guessed type int dword_10063BE8[];
// 10063BF4: using guessed type int dword_10063BF4[];
// 1018DF04: using guessed type __int16 word_1018DF04[];
// 1018F088: using guessed type int dword_1018F088[];

//----- (10009A50) --------------------------------------------------------
signed int __usercall sub_10009A50@<eax>(unsigned __int16 a1@<ax>, unsigned __int8 a2@<cl>, char a3)
{
  __int16 v3; // si@1
  char v4; // bl@1
  unsigned int v5; // eax@1
  unsigned int v6; // esi@1
  signed int v7; // eax@11
  unsigned __int8 v8; // cl@11
  signed int v9; // eax@23
  unsigned __int8 v10; // cl@23
  signed int v11; // eax@29
  unsigned __int8 v12; // cl@29
  signed int v13; // eax@35
  unsigned __int8 v14; // cl@35
  bool v15; // zf@43
  signed int v16; // eax@47
  unsigned __int8 v17; // cl@47
  unsigned int v18; // ebx@54
  int v19; // eax@63
  __int64 v20; // kr00_8@68
  unsigned __int8 v22; // [sp+Dh] [bp-7h]@4
  char v23; // [sp+Eh] [bp-6h]@1
  char v24; // [sp+Fh] [bp-5h]@54
  unsigned int v25; // [sp+10h] [bp-4h]@54

  v3 = a1;
  v4 = a2;
  memset(dword_10118A28, 255, 0x61A80u);
  memset(&unk_10117F38, 0, 0xAE8u);
  v23 = 1;
  word_1017C094 = v3;
  byte_1017A4FA = v4;
  sub_10007170();
  v5 = sub_100065D0(v3, v4);
  v6 = v5;
  if ( v5 < 0xFFFFFFC2 && v5 )
  {
LABEL_3:
    while ( 2 )
    {
      if ( v23 )
      {
        if ( sub_1003E4B0(v6, &v22, 1) == 1 )
        {
          switch ( v22 )
          {
            case 0u:
              if ( sub_1003E4B0(v6, &unk_10117F38, 4) == 4 )
                continue;
              goto LABEL_7;
            case 1u:
              if ( sub_1003E4B0(v6, &v22, 1) == 1 )
              {
                if ( v22 )
                {
                  v7 = sub_1003E4B0(v6, byte_10117F3C, v22);
                  v8 = v22;
                  if ( v7 != v22 )
                  {
                    v8 = 0;
                    v23 = 0;
                    v22 = 0;
                  }
                  byte_10117F3C[v8] = 0;
                }
              }
              else
              {
                v23 = 0;
                v22 = 0;
              }
              continue;
            case 2u:
              if ( sub_1003E4B0(v6, &unk_10117F43, 1) != 1 )
                v23 = 0;
              continue;
            case 3u:
              if ( sub_1003E4B0(v6, &word_10117F44, 2) != 2 )
                v23 = 0;
              continue;
            case 4u:
              if ( sub_1003E4B0(v6, &dword_10117F48, 8) != 8 )
                v23 = 0;
              continue;
            case 5u:
              if ( sub_1003E4B0(v6, &v22, 1) == 1 )
              {
                if ( v22 )
                {
                  v9 = sub_1003E4B0(v6, byte_10117F50, v22);
                  v10 = v22;
                  if ( v9 != v22 )
                  {
                    v10 = 0;
                    v23 = 0;
                    v22 = 0;
                  }
                  byte_10117F50[v10] = 0;
                }
              }
              else
              {
                v23 = 0;
                v22 = 0;
              }
              continue;
            case 6u:
              if ( sub_1003E4B0(v6, &v22, 1) == 1 )
              {
                if ( v22 )
                {
                  v11 = sub_1003E4B0(v6, byte_10117F60, v22);
                  v12 = v22;
                  if ( v11 != v22 )
                  {
                    v12 = 0;
                    v23 = 0;
                    v22 = 0;
                  }
                  byte_10117F60[v12] = 0;
                }
              }
              else
              {
                v23 = 0;
                v22 = 0;
              }
              continue;
            case 7u:
              if ( sub_1003E4B0(v6, &v22, 1) == 1 )
              {
                if ( v22 )
                {
                  v13 = sub_1003E4B0(v6, byte_10117F88, v22);
                  v14 = v22;
                  if ( v13 != v22 )
                  {
                    v14 = 0;
                    v23 = 0;
                    v22 = 0;
                  }
                  byte_10117F88[v14] = 0;
                }
              }
              else
              {
                v23 = 0;
                v22 = 0;
              }
              continue;
            case 0x14u:
              while ( 2 )
              {
                if ( v23 )
                {
                  if ( sub_1003E4B0(v6, &v22, 1) == 1 )
                  {
                    switch ( v22 )
                    {
                      case 0x15u:
                        v15 = sub_1003E4B0(v6, (char *)&unk_10117F90 + 2 * dword_10118A1C, 2) == 2;
                        goto LABEL_38;
                      case 0x16u:
                        if ( sub_1003E4B0(v6, &v22, 1) == 1 )
                        {
                          if ( v22 )
                          {
                            v16 = sub_1003E4B0(v6, &byte_10118058[21 * dword_10118A1C], v22);
                            v17 = v22;
                            if ( v16 != v22 )
                            {
                              v17 = 0;
                              v23 = 0;
                              v22 = 0;
                            }
                            *(&byte_10118058[21 * dword_10118A1C] + v17) = 0;
                          }
                        }
                        else
                        {
                          v22 = 0;
LABEL_39:
                          v23 = 0;
                        }
                        continue;
                      case 0x17u:
                        v15 = sub_1003E4B0(v6, (char *)&unk_1011888C + 4 * dword_10118A1C, 4) == 4;
LABEL_38:
                        if ( !v15 )
                          goto LABEL_39;
                        continue;
                      case 0x18u:
                        if ( (unsigned int)++dword_10118A1C >= 0x64 )
                          v23 = 0;
                        break;
                      default:
                        continue;
                    }
                  }
                  else
                  {
LABEL_7:
                    v23 = 0;
                  }
                }
                goto LABEL_3;
              }
            default:
              goto LABEL_53;
            case 0x1Fu:
              goto LABEL_54;
          }
        }
        else
        {
LABEL_53:
          v23 = 0;
        }
      }
      break;
    }
LABEL_54:
    v24 = v23;
    v18 = 0;
    v25 = a3 != 0 ? 1 : 100000;
    if ( (a3 != 0 ? 0xFFFE7961 : 0) != -100000 )
    {
      do
      {
        if ( !v24 )
          break;
        dword_10118A28[v18] = sub_1003E730(v6, 0, 1);
        dword_10118A24 = v18;
        while ( sub_1003E4B0(v6, &v22, 1) == 1 )
        {
          if ( v22 == 126 )
            goto LABEL_68;
          if ( v22 != 20 && v22 != 34 )
          {
            if ( v22 == 23 || v22 == 35 )
            {
              if ( sub_1003E4B0(v6, &v22, 1) != 1 )
                break;
              v19 = 4;
              if ( v22 == 2 )
                v19 = 5;
            }
            else
            {
              v19 = dword_10064714[2 * sub_1001CEF0(&v22, 1u, (int)&unk_10064710, 8, 15)];
              if ( !v19 )
              {
                if ( sub_1003E4B0(v6, &v22, 1) != 1 )
                  break;
                v19 = v22;
              }
            }
            if ( sub_1003E730(v6, v19, 1) < 0 )
              break;
          }
        }
        --dword_10118A24;
        dword_10118A28[v18] = -1;
        v24 = 0;
LABEL_68:
        v20 = sub_1003E730(v6, 0, 1);
        if ( v20 == sub_1003E5F0(v6) )
          break;
        ++v18;
      }
      while ( v18 < v25 );
    }
    sub_1003E3A0(v6);
    if ( !v23 )
      return 0;
  }
  if ( dword_10118A28[0] == -1 )
    return 0;
  return 1;
}
// 10064714: using guessed type int dword_10064714[];
// 10117F44: using guessed type __int16 word_10117F44;
// 10117F48: using guessed type int dword_10117F48;
// 10118A1C: using guessed type int dword_10118A1C;
// 10118A24: using guessed type int dword_10118A24;
// 10118A28: using guessed type int dword_10118A28[];
// 1017A4FA: using guessed type char byte_1017A4FA;
// 1017C094: using guessed type __int16 word_1017C094;

//----- (1000A010) --------------------------------------------------------
int sub_1000A010()
{
  int v0; // edi@1
  char *v1; // esi@1
  signed int v2; // ebx@1
  unsigned __int8 v3; // bl@3
  char *v4; // ebp@3
  signed __int16 v5; // ax@14
  int v6; // esi@14
  int v7; // eax@16
  unsigned int v8; // esi@16
  __int64 v9; // rax@16
  unsigned int v10; // ebp@20
  unsigned __int8 v11; // bl@20
  char v12; // si@20
  const char *v13; // edi@20
  unsigned __int8 v14; // bl@25
  int *v15; // edi@25
  int *v16; // esi@25
  int *v17; // eax@26
  char v18; // cl@27
  int v19; // edx@31
  char *v20; // edx@36
  int *v21; // ecx@36
  signed int v22; // esi@36
  bool v23; // zf@37
  float v24; // ST54_4@39
  float v25; // ST54_4@39
  double v26; // st4@39
  char *v28; // [sp-Ch] [bp-2E8h]@8
  const char *v29; // [sp-8h] [bp-2E4h]@8
  int *v30; // [sp+10h] [bp-2CCh]@3
  signed int v31; // [sp+10h] [bp-2CCh]@39
  int v32; // [sp+14h] [bp-2C8h]@0
  unsigned __int8 v33; // [sp+14h] [bp-2C8h]@20
  char v34; // [sp+1Ch] [bp-2C0h]@8
  char v35; // [sp+148h] [bp-194h]@16
  char v36; // [sp+210h] [bp-CCh]@16

  v0 = 18000;
  v1 = byte_1018DEC8;
  v2 = 16;
  do
  {
    sub_1003E040(v0, (int)v1, 284);
    v1 += 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  v3 = 0;
  LOBYTE(v32) = 0;
  v30 = &dword_1017A4A8;
  v4 = byte_1018DEC8;
  do
  {
    if ( strlen(v4) )
    {
      if ( v4[42] )
      {
        if ( !sub_1003E660((int)"/mnt/card1/cmc/") )
          j_FIL_vfs_mkdir("/mnt/card1/cmc/", 1911);
        v29 = "/mnt/card1/cmc/";
        v28 = &v34;
      }
      else
      {
        if ( !sub_1003E660((int)"/mnt/sys_nand0/cmc/") )
          j_FIL_vfs_mkdir("/mnt/sys_nand0/cmc/", 1911);
        v29 = "/mnt/sys_nand0/cmc/";
        v28 = &v34;
      }
      sub_1001D720((int)v28, v29, 300);
      sub_1001D870(&v34, v4, 300);
      if ( sub_1003E660((int)&v34) )
      {
        v5 = sub_10005C10(v32);
        v6 = (unsigned __int16)v5;
        if ( v5 != -1 && !(unsigned __int8)sub_10009A50(v5, v3, 1) )
        {
          sub_10007310(v32, v6, &v36, 0xC8u);
          sub_1001D870(&v34, "/", 300);
          sub_1001D720((int)&v35, &v34, 200);
          sub_1001D870(&v34, &v36, 300);
          j_FIL_vfs_delete(&v34);
          sub_1001D870(&v35, ".logs_db", 200);
          v7 = j_FIL_vfs_open(&v35, 6, 1911);
          v8 = v7;
          v9 = sub_1003E5F0(v7);
          sub_1003E610(v8, v9 - 64, (unsigned __int64)(v9 - 64) >> 32);
          sub_1003E3A0(v8);
        }
      }
      else
      {
        j_FIL_vfs_mkdir(&v34, 1877);
      }
    }
    ++v3;
    *v30 = 0;
    v4 += 284;
    LOBYTE(v32) = v3;
    ++v30;
  }
  while ( v3 < 0x10u );
  sub_1001D840(&v34, 0x12Cu, "%s%s", "/mnt/sys_nand0/cmc/", "ATN_LOGS");
  if ( !sub_1003E660((int)&v34) )
    j_FIL_vfs_mkdir(&v34, 1877);
  sub_1003E040(2167, (int)&dword_1017A588, 4);
  v10 = 0;
  memset(dword_1017A500, 0, 0x88u);
  memset(dword_10118A28, 255, 0x61A80u);
  dword_1018D098 = 16843009;
  dword_1018D09C = 16843009;
  dword_1018D0A0 = 16843009;
  dword_1018D0A4 = 16843009;
  byte_1017A4FA = 16;
  word_1017C094 = -1;
  dword_1017A4E8 = 0;
  dword_1017A4EC = 0;
  dword_1017A4F0 = 0;
  dword_1017A4F4 = 0;
  memset(dword_1018DDC0, 0, 0x40u);
  v11 = 0;
  dword_10118A20 = 0;
  LOWORD(dword_1017A58C) = 0;
  word_1017A4F8 = 0;
  v33 = 0;
  v12 = 0;
  v13 = byte_1018DEC8;
  do
  {
    if ( strlen(v13) && sub_10005C10(v33) != -1 )
      word_1017A4F8 |= 1 << v12;
    ++v11;
    ++v12;
    v13 += 284;
    v33 = v11;
  }
  while ( v11 < 0x10u );
  sub_1003E110(41093, (int)&word_1017A4F8, 2);
  sub_100071C0((int)&unk_1018DA80);
  v14 = 0;
  v15 = dword_1017A500;
  v16 = dword_1018DEE8;
  do
  {
    v17 = v16 - 8;
    do
    {
      v18 = *(_BYTE *)v17;
      v17 = (int *)((char *)v17 + 1);
    }
    while ( v18 );
    if ( v17 != (int *)((char *)v16 - 31) )
    {
      if ( !*((_BYTE *)v16 + 10) )
        v10 += *v16;
      v19 = v15[1];
      if ( v19 >= 0 && (v19 > 0 || *v15 > (unsigned int)*v16) )
      {
        sub_100129A0("..\\lib\\adl\\mon_log.c", 1086, 0, "LOG Folder exceeds max size on power-up.  Deleting old logs");
        sub_10005E60(0);
      }
    }
    ++v14;
    v16 += 71;
    v15 += 2;
  }
  while ( v14 < 0x10u );
  v20 = byte_1018D0A8;
  v21 = dword_1018DEE8;
  v22 = 16;
  do
  {
    v23 = *((_BYTE *)v21 + 10) == 0;
    *v20 = 0;
    if ( v23 && v10 )
    {
      v24 = (double)(unsigned int)*v21 / (double)v10;
      v25 = v24 * 100.0;
      v26 = v25;
      v31 = -1;
      if ( v26 >= 0.0 )
        v31 = 1;
      *v20 = (signed int)(v26 + (double)v31 * 0.5);
    }
    v21 += 71;
    ++v20;
    --v22;
  }
  while ( v22 );
  return sub_1003E110(41106, (int)&unk_1018DA80, 832);
}
// 1003E400: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 1003E480: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10118A20: using guessed type int dword_10118A20;
// 10118A28: using guessed type int dword_10118A28[];
// 1017A4E8: using guessed type int dword_1017A4E8;
// 1017A4EC: using guessed type int dword_1017A4EC;
// 1017A4F0: using guessed type int dword_1017A4F0;
// 1017A4F4: using guessed type int dword_1017A4F4;
// 1017A4F8: using guessed type __int16 word_1017A4F8;
// 1017A4FA: using guessed type char byte_1017A4FA;
// 1017A500: using guessed type int dword_1017A500[];
// 1017A588: using guessed type int dword_1017A588;
// 1017A58C: using guessed type int dword_1017A58C;
// 1017C094: using guessed type __int16 word_1017C094;
// 1018D098: using guessed type int dword_1018D098;
// 1018D09C: using guessed type int dword_1018D09C;
// 1018D0A0: using guessed type int dword_1018D0A0;
// 1018D0A4: using guessed type int dword_1018D0A4;
// 1018DDC0: using guessed type int dword_1018DDC0[];
// 1018DEE8: using guessed type int dword_1018DEE8[];

//----- (1000A4F0) --------------------------------------------------------
char __usercall sub_1000A4F0@<al>(double st7_0@<st0>, unsigned __int16 a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  signed int v10; // eax@1
  char v11; // bl@2
  char v12; // cl@2
  int *v13; // esi@2
  int *v14; // ebp@2
  char *v15; // edi@2
  double v16; // st7@13
  bool v17; // sf@13
  double v18; // st6@15
  float v19; // ST60_4@15
  unsigned int v20; // esi@20
  int v21; // esi@22
  __int16 v22; // ax@27
  char v24; // [sp+0h] [bp-144h]@2
  int *v25; // [sp+4h] [bp-140h]@2
  int v26; // [sp+8h] [bp-13Ch]@2
  int *v27; // [sp+10h] [bp-134h]@2
  signed int v28; // [sp+2Ch] [bp-118h]@3
  char v29; // [sp+38h] [bp-10Ch]@20
  char v30; // [sp+6Ch] [bp-D8h]@20
  char v31; // [sp+78h] [bp-CCh]@18

  LOBYTE(v10) = sub_10015FD0(40000);
  if ( !(_BYTE)v10 )
  {
    v11 = 0;
    v12 = 0;
    v13 = &dword_1017A4A8;
    v24 = 0;
    v26 = 0;
    v25 = dword_1017A500;
    v14 = dword_1018DAA0;
    v15 = byte_1018DEC8;
    v27 = &dword_1017A4A8;
    do
    {
      v10 = 1 << v12;
      v28 = 1 << v12;
      if ( (1 << v12) & a1 && *v15 )
      {
        if ( v11 == byte_1017A4FA && word_1017C094 == sub_10005C10(v24) )
          word_1017C094 = -1;
        if ( (unsigned int)*v13 < 0xFFFFFFC2 && *v13 )
          goto LABEL_13;
        if ( sub_10006340(a2, (unsigned int *)v13) )
        {
          sub_10007B70(st7_0, v24, *(_DWORD *)(a2 + 4));
LABEL_13:
          sub_10008D10(a4, a3, v11, st7_0, *v13, (_WORD *)a2, a5, a6, a7, a8, a9);
          v16 = (double)*v25;
          v17 = *v25 < 0;
          *((_BYTE *)&dword_1017A4E8 + v26) = 1;
          if ( v17 )
            v16 = v16 + 4294967300.0;
          v18 = v16 / (double)*((unsigned int *)v15 + 8) * 100.0;
          st7_0 = 100.0;
          v19 = v18;
          *((float *)v14 + 2) = v19;
          if ( v19 > 100.0 )
          {
            st7_0 = 100.0;
            *((float *)v14 + 2) = 100.0;
          }
          if ( v15[42] )
            sub_1001D720((int)&v31, "/mnt/card1/cmc/", 200);
          else
            sub_1001D720((int)&v31, "/mnt/sys_nand0/cmc/", 200);
          sub_1001D870(&v31, v15, 200);
          sub_1001D870(&v31, "/.logs_db", 200);
          v20 = j_FIL_vfs_open(&v31, 6, 1911);
          sub_1003E730(v20, -64, 2);
          sub_1003E4B0(v20, &v29, 64);
          if ( v30 == 6 )
          {
            ++*v14;
            v30 = 5;
            sub_1003E730(v20, -64, 1);
            j_FIL_vfs_write(v20, &v29, 64);
          }
          sub_1003E3A0(v20);
          sub_1003E110(41106, (int)&unk_1018DA80, 832);
          v21 = v25[1];
          if ( v21 >= 0 && (v21 > 0 || (unsigned int)*v25 > *((_DWORD *)v15 + 8)) )
          {
            sub_10005E60(0);
            sub_1003E110(41106, (int)&unk_1018DA80, 832);
          }
          if ( v15[58] == 3 )
          {
            sub_10007170();
            v22 = sub_10005C10(v24);
            sub_1001DB70(v24, v22, 0);
          }
          LOBYTE(v10) = word_1017A4F8;
          if ( !((unsigned __int16)word_1017A4F8 & (unsigned __int16)v28) )
          {
            word_1017A4F8 |= 1 << v26;
            LOBYTE(v10) = sub_1003E110(41093, (int)&word_1017A4F8, 2);
          }
          v13 = v27;
          v11 = v24;
          goto LABEL_31;
        }
        LOBYTE(v10) = sub_100129A0("..\\lib\\adl\\mon_log.c", 1197, 0, 0);
      }
LABEL_31:
      v25 += 2;
      ++v11;
      v12 = v26 + 1;
      ++v13;
      v14 += 13;
      v15 += 284;
      v24 = v11;
      ++v26;
      v27 = v13;
    }
    while ( (unsigned __int8)v11 < 0x10u );
  }
  return v10;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 1017A4E8: using guessed type int dword_1017A4E8;
// 1017A4F4: using guessed type int dword_1017A4F4;
// 1017A4F8: using guessed type __int16 word_1017A4F8;
// 1017A4FA: using guessed type char byte_1017A4FA;
// 1017A500: using guessed type int dword_1017A500[];
// 1017C094: using guessed type __int16 word_1017C094;
// 1018DAA0: using guessed type int dword_1018DAA0[];

//----- (1000A880) --------------------------------------------------------
char sub_1000A880()
{
  int v0; // ebp@1
  int *v1; // esi@1
  _BYTE *v2; // ebx@1
  int *v3; // edi@1
  __int16 v4; // ax@6
  __int16 v5; // ax@10
  char result; // al@11
  unsigned __int8 v7; // [sp+10h] [bp-8h]@1
  int v8; // [sp+14h] [bp-4h]@1

  v0 = sub_1003DC90();
  v8 = v0;
  v7 = 0;
  v1 = &dword_1017A4E8;
  v2 = &unk_1018DF02;
  v3 = dword_1018DDC0;
  while ( 1 )
  {
    if ( *v2 == 1 && *(_BYTE *)v1 && (unsigned int)(v0 - *v3) >= *(_DWORD *)(v2 - 6) )
    {
      sub_10007170();
      *v3 = v0;
      *(_BYTE *)v1 = 0;
      v4 = sub_10005C10(v7);
      sub_1001DB70(v7, v4, 0);
    }
    else if ( *v2 == 2 && *(_BYTE *)v1 )
    {
      if ( sub_10013820(*((_WORD *)v2 - 4)) )
      {
        sub_10007170();
        v5 = sub_10005C10(v7);
        sub_1001DB70(v7, v5, 0);
        *(_BYTE *)v1 = 0;
      }
    }
    result = v7 + 1;
    ++v3;
    v2 += 284;
    v1 = (int *)((char *)v1 + 1);
    if ( ++v7 >= 0x10u )
      break;
    v0 = v8;
  }
  return result;
}
// 1017A4E8: using guessed type int dword_1017A4E8;
// 1018DDC0: using guessed type int dword_1018DDC0[];

//----- (1000A950) --------------------------------------------------------
void *sub_1000A950()
{
  int *v0; // ebp@1
  unsigned int *v1; // edi@1
  char *v2; // esi@1
  char v4; // [sp+10h] [bp-130h]@4

  v0 = dword_1017A500;
  v1 = (unsigned int *)&dword_1017A4A8;
  v2 = byte_1018DEC8;
  do
  {
    if ( strlen(v2) )
    {
      if ( v2[42] )
        sub_1001D720((int)&v4, "/mnt/card1/cmc/", 300);
      else
        sub_1001D720((int)&v4, "/mnt/sys_nand0/cmc/", 300);
      sub_1001D870(&v4, v2, 300);
      if ( sub_1003E660((int)&v4) )
      {
        if ( *v1 < 0xFFFFFFC2 && *v1 )
        {
          sub_1003E3A0(*v1);
          *v1 = 0;
        }
        if ( !sub_1003E770(&v4) )
        {
          j_FIL_vfs_mkdir(&v4, 0);
          *v0 = 0;
          v0[1] = 0;
        }
      }
    }
    v2 += 284;
    ++v1;
    v0 += 2;
  }
  while ( (signed int)v2 < (signed int)dword_1018F088 );
  word_1017A4F8 = 0;
  sub_1003E110(41093, (int)&word_1017A4F8, 2);
  sub_100071C0((int)&unk_1018DA80);
  sub_1003E110(41106, (int)&unk_1018DA80, 832);
  memset(&unk_1017D098, 0, 0x10000u);
  return memset(dword_1018F088, 0, 0x40u);
}
// 1003E480: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);
// 1017A4F8: using guessed type __int16 word_1017A4F8;
// 1017A500: using guessed type int dword_1017A500[];
// 1018F088: using guessed type int dword_1018F088[];

//----- (1000AAB0) --------------------------------------------------------
void *__cdecl sub_1000AAB0(unsigned __int16 a1)
{
  int v1; // ecx@2
  char *v2; // edi@2
  char *v3; // eax@2
  char v4; // dl@3
  unsigned int v5; // eax@9
  void *result; // eax@16
  char v7; // [sp+Ch] [bp-130h]@6

  if ( a1 < 0x10u )
  {
    v1 = 284 * a1;
    v2 = &byte_1018DEC8[v1];
    v3 = &byte_1018DEC8[v1];
    do
      v4 = *v3++;
    while ( v4 );
    if ( v3 != &byte_1018DEC8[v1 + 1] )
    {
      if ( byte_1018DEF2[v1] )
        sub_1001D720((int)&v7, "/mnt/card1/cmc/", 300);
      else
        sub_1001D720((int)&v7, "/mnt/sys_nand0/cmc/", 300);
      sub_1001D870(&v7, v2, 300);
      if ( sub_1003E660((int)&v7) )
      {
        v5 = *(&dword_1017A4A8 + a1);
        if ( v5 < 0xFFFFFFC2 && v5 )
        {
          sub_1003E3A0(*(&dword_1017A4A8 + a1));
          *(&dword_1017A4A8 + a1) = 0;
        }
        if ( sub_1003E770(&v7) )
        {
          sub_100129A0("..\\lib\\adl\\mon_log.c", 1607, 0, 0);
        }
        else
        {
          j_FIL_vfs_mkdir(&v7, 0);
          dword_1017A500[2 * a1] = 0;
          dword_1017A504[2 * a1] = 0;
        }
      }
      word_1017A4F8 &= ~(1 << a1);
      sub_1003E110(41093, (int)&word_1017A4F8, 2);
    }
  }
  sub_100071C0((int)&unk_1018DA80);
  sub_1003E110(41106, (int)&unk_1018DA80, 832);
  result = memset((char *)&unk_1017D098 + 4096 * a1, 0, 0x1000u);
  dword_1018F088[a1] = 0;
  return result;
}
// 1003E480: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);
// 1017A4F8: using guessed type __int16 word_1017A4F8;
// 1017A500: using guessed type int dword_1017A500[];
// 1017A504: using guessed type int dword_1017A504[];
// 1018F088: using guessed type int dword_1018F088[];

//----- (1000AC40) --------------------------------------------------------
char __usercall sub_1000AC40@<al>(unsigned int a1@<eax>, unsigned __int16 a2@<cx>, unsigned int a3@<ebx>, unsigned __int8 a4, int a5)
{
  unsigned int v5; // esi@1
  unsigned __int16 v6; // di@1
  char result; // al@3
  int v8; // eax@11
  int v9; // eax@35
  int v10; // eax@42
  unsigned __int8 v11; // [sp+Dh] [bp-3h]@18
  char v12; // [sp+Eh] [bp-2h]@12
  char v13; // [sp+Fh] [bp-1h]@1

  v5 = a1;
  v6 = a2;
  v13 = 1;
  if ( a1 >= 0x186A0 )
  {
    sub_100129A0("..\\lib\\adl\\mon_log.c", 4918, 0, "Requesting row past end of cache index.");
    return 0;
  }
  if ( sub_1003E5F0(a3) )
  {
    if ( a4 != byte_1017A4FA || v6 != word_1017C094 )
      v13 = sub_10009A50(v6, a4, 0);
    if ( v5 > dword_10118A24 )
      return 0;
    if ( !v13 )
      return 0;
    v8 = dword_10118A28[v5];
    if ( v8 == -1 )
      return 0;
    sub_1003E730(a3, v8, 0);
    v12 = 0;
    do
    {
      while ( 2 )
      {
        sub_1003E4B0(a3, &v12, 1);
        switch ( v12 )
        {
          case 0:
            sub_1003E4B0(a3, (void *)(a5 + 4), 4);
            break;
          case 1:
            sub_1003E4B0(a3, (void *)(a5 + 8), 4);
            break;
          case 2:
            sub_1003E4B0(a3, (void *)(a5 + 3), 1);
            break;
          case 3:
            sub_1003E4B0(a3, (void *)a5, 2);
            *(_WORD *)(a5 + 3420) = *(_WORD *)a5;
            break;
          case 4:
            sub_1003E4B0(a3, &v11, 1);
            if ( v11 )
            {
              sub_1003E4B0(a3, (void *)(a5 + 3422), v11);
              *(_BYTE *)(v11 + a5 + 3422) = 0;
            }
            break;
          case 5:
            sub_1003E4B0(a3, (void *)(a5 + 3546), 1);
            break;
          case 6:
            sub_1003E4B0(a3, &v11, 1);
            if ( v11 )
            {
              sub_1003E4B0(a3, (void *)(a5 + 3453), v11);
              *(_BYTE *)(v11 + a5 + 3453) = 0;
            }
            break;
          case 7:
            sub_1003E4B0(a3, &v11, 1);
            if ( v11 )
            {
              sub_1003E4B0(a3, (void *)(a5 + 3504), v11);
              *(_BYTE *)(v11 + a5 + 3504) = 0;
            }
            break;
          case 8:
            sub_1003E4B0(a3, &v11, 1);
            if ( v11 )
            {
              sub_1003E4B0(a3, (void *)(a5 + 3525), v11);
              *(_BYTE *)(v11 + a5 + 3525) = 0;
            }
            break;
          case 9:
            sub_1003E4B0(a3, &v11, 1);
            if ( v11 )
            {
              sub_1003E4B0(a3, (void *)(a5 + 3578), v11);
              *(_BYTE *)(v11 + a5 + 3578) = 0;
            }
            break;
          case 0xA:
            sub_1003E4B0(a3, (void *)(a5 + 3576), 2);
            break;
          case 0x14:
            while ( v12 != 34 )
            {
              sub_1003E4B0(a3, &v12, 1);
              switch ( v12 )
              {
                case 0x15:
                  sub_1003E4B0(a3, (void *)(a5 + 2 * *(_BYTE *)(a5 + 2) + 3220), 2);
                  break;
                case 0x16:
                  sub_1003E4B0(a3, &v11, 1);
                  if ( v11 )
                  {
                    sub_1003E4B0(a3, (void *)(21 * *(_BYTE *)(a5 + 2) + a5 + 520), v11);
                    *(_BYTE *)(v11 + a5 + 21 * *(_BYTE *)(a5 + 2) + 520) = 0;
                  }
                  break;
                case 0x17:
                  sub_1003E4B0(a3, (void *)(*(_BYTE *)(a5 + 2) + a5 + 420), 1);
                  sub_1003E4B0(a3, (void *)(a5 + 4 * *(_BYTE *)(a5 + 2) + 20), 4);
                  v9 = a5 + *(_BYTE *)(a5 + 2);
                  if ( *(_BYTE *)(v9 + 420) == 2 )
                    sub_1003E4B0(a3, (void *)(v9 + 2620), 1);
                  break;
                case 0x18:
                  sub_1003E4B0(a3, (void *)(a5 + 4 * *(_BYTE *)(a5 + 2) + 2720), 4);
                  break;
                case 0x19:
                  sub_1003E4B0(a3, (void *)(*(_BYTE *)(a5 + 2) + a5 + 3120), 1);
                  break;
                default:
                  ++*(_BYTE *)(a5 + 2);
                  break;
              }
            }
            continue;
          case 0x23:
            sub_1003E4B0(a3, (void *)(*(_BYTE *)(a5 + 6612) + a5 + 6613), 1);
            sub_1003E4B0(a3, (void *)(a5 + 4 * *(_BYTE *)(a5 + 6612) + 5712), 4);
            v10 = a5 + *(_BYTE *)(a5 + 6612);
            if ( *(_BYTE *)(v10 + 6613) == 2 )
              sub_1003E4B0(a3, (void *)(v10 + 6512), 1);
            ++*(_BYTE *)(a5 + 6612);
            qmemcpy((void *)(a5 + 3609), byte_10118058, 0x834u);
            qmemcpy((void *)(a5 + 6112), &unk_1011888C, 0x190u);
            qmemcpy((void *)(a5 + 6714), &unk_10117F90, 0xC8u);
            break;
          default:
            goto LABEL_45;
        }
        break;
      }
LABEL_45:
      ;
    }
    while ( v12 != 126 );
    result = v13;
  }
  else
  {
    sub_100129A0("..\\lib\\adl\\mon_log.c", 4924, 0, "Accessing empty file.");
    result = 0;
  }
  return result;
}
// 10118A24: using guessed type int dword_10118A24;
// 10118A28: using guessed type int dword_10118A28[];
// 1017A4FA: using guessed type char byte_1017A4FA;
// 1017C094: using guessed type __int16 word_1017C094;

//----- (1000B140) --------------------------------------------------------
char __cdecl sub_1000B140(unsigned int a1, unsigned __int8 a2, unsigned __int16 a3, int a4)
{
  char v4; // bl@1
  unsigned int v5; // eax@1
  unsigned int v6; // edi@1

  v4 = 0;
  v5 = sub_100065D0(a3, a2);
  v6 = v5;
  if ( v5 < 0xFFFFFFC2 && v5 )
  {
    sub_10006CC0(a4);
    *(_WORD *)(a4 + 12) = a1;
    v4 = sub_1000AC40(a1, a3, v6, a2, a4);
    sub_1003E3A0(v6);
  }
  return v4;
}

//----- (1000B1A0) --------------------------------------------------------
char __cdecl sub_1000B1A0(unsigned __int8 a1, int a2)
{
  char v2; // bl@1
  unsigned int v3; // eax@1
  unsigned int v4; // edi@1
  unsigned __int16 v5; // cx@3

  v2 = 0;
  LOWORD(dword_1017A58C) = 0;
  v3 = sub_100065D0(0, a1);
  v4 = v3;
  if ( v3 < 0xFFFFFFC2 && v3 )
  {
    sub_10006CC0(a2);
    v5 = dword_1017A58C;
    *(_WORD *)(a2 + 12) = 0;
    v2 = sub_1000AC40(0, v5, v4, a1, a2);
    sub_1003E3A0(v4);
  }
  return v2;
}
// 1017A58C: using guessed type int dword_1017A58C;

//----- (1000B200) --------------------------------------------------------
char __cdecl sub_1000B200(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@1
  unsigned int v5; // edi@1

  v3 = 0;
  v4 = sub_100065D0(a2, a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    sub_10006CC0(a3);
    *(_WORD *)(a3 + 12) = 0;
    v3 = sub_1000AC40(0, a2, v5, a1, a3);
    sub_1003E3A0(v5);
  }
  return v3;
}

//----- (1000B260) --------------------------------------------------------
char __cdecl sub_1000B260(unsigned __int8 a1, int a2)
{
  signed __int16 v2; // ax@1
  unsigned int v3; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@5
  unsigned __int16 v6; // cx@5
  char result; // al@6
  char v8; // [sp+Bh] [bp-1h]@3

  v2 = sub_10005C10(a1);
  LOWORD(dword_1017A58C) = v2;
  v3 = sub_100065D0(v2, a1);
  v4 = v3;
  if ( v3 < 0xFFFFFFC2 && v3 )
  {
    v8 = 1;
    sub_10006CC0(a2);
    if ( !(unsigned __int8)sub_10009A50(dword_1017A58C, a1, 0) )
      v8 = 0;
    v5 = dword_10118A24;
    v6 = dword_1017A58C;
    *(_WORD *)(a2 + 12) = dword_10118A24;
    if ( sub_1000AC40(v5, v6, v4, a1, a2) )
    {
      sub_1003E3A0(v4);
      result = v8;
    }
    else
    {
      sub_1003E3A0(v4);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10118A24: using guessed type int dword_10118A24;
// 1017A58C: using guessed type int dword_1017A58C;

//----- (1000B300) --------------------------------------------------------
bool __cdecl sub_1000B300(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  unsigned int v3; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool result; // al@3

  v3 = sub_100065D0(a2, a1);
  v4 = v3;
  if ( v3 < 0xFFFFFFC2 && v3 )
  {
    sub_10006CC0(a3);
    sub_10009A50(a2, a1, 0);
    v5 = dword_10118A24;
    *(_WORD *)(a3 + 12) = dword_10118A24;
    sub_1000AC40(v5, a2, v4, a1, a3);
    sub_1003E3A0(v4);
    result = *(_WORD *)(a3 + 12) != 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10118A24: using guessed type int dword_10118A24;

//----- (1000B370) --------------------------------------------------------
char __cdecl sub_1000B370(unsigned __int8 a1, int a2)
{
  unsigned int v2; // eax@1
  __int16 v3; // bx@1
  unsigned int v4; // edi@1
  unsigned __int16 v5; // cx@3
  char v6; // bl@3
  unsigned __int16 v7; // di@4
  unsigned int v8; // eax@4
  unsigned int v9; // edi@4
  char result; // al@7

  v2 = sub_100065D0(dword_1017A58C, a1);
  v3 = *(_WORD *)(a2 + 12);
  v4 = v2;
  if ( v2 < 0xFFFFFFC2 && v2 )
  {
    sub_10006CC0(a2);
    v5 = dword_1017A58C;
    *(_WORD *)(a2 + 12) = v3 + 1;
    v6 = sub_1000AC40((unsigned __int16)(v3 + 1), v5, v4, a1, a2);
    sub_1003E3A0(v4);
    if ( !v6 )
    {
      LOWORD(dword_1017A58C) = dword_1017A58C + 1;
      v7 = dword_1017A58C;
      sub_10006CC0(a2);
      *(_WORD *)(a2 + 12) = 0;
      v8 = sub_100065D0(v7, a1);
      v9 = v8;
      if ( v8 < 0xFFFFFFC2 )
      {
        if ( v8 )
        {
          v6 = sub_1000AC40(*(_WORD *)(a2 + 12), dword_1017A58C, v8, a1, a2);
          sub_1003E3A0(v9);
        }
      }
    }
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1017A58C: using guessed type int dword_1017A58C;

//----- (1000B430) --------------------------------------------------------
char __cdecl sub_1000B430(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  unsigned int v3; // eax@1
  __int16 v4; // bx@1
  unsigned int v5; // edi@1
  char v6; // bl@3
  char result; // al@3

  v3 = sub_100065D0(a2, a1);
  v4 = *(_WORD *)(a3 + 12);
  v5 = v3;
  if ( v3 < 0xFFFFFFC2 && v3 )
  {
    sub_10006CC0(a3);
    *(_WORD *)(a3 + 12) = v4 + 1;
    v6 = sub_1000AC40((unsigned __int16)(v4 + 1), a2, v5, a1, a3);
    sub_1003E3A0(v5);
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000B490) --------------------------------------------------------
char __cdecl sub_1000B490(unsigned __int8 a1, int a2)
{
  unsigned __int8 v2; // bl@3
  unsigned int v3; // eax@3
  unsigned __int16 v4; // bp@3
  unsigned int v5; // edi@5
  unsigned __int16 v6; // cx@7
  char v7; // bl@7

  if ( *(_WORD *)(a2 + 12) )
  {
    --*(_WORD *)(a2 + 12);
    v2 = a1;
    v4 = *(_WORD *)(a2 + 12);
    v3 = sub_100065D0(dword_1017A58C, a1);
  }
  else
  {
    if ( (unsigned __int16)dword_1017A58C <= 0u )
      return 0;
    LOWORD(dword_1017A58C) = dword_1017A58C - 1;
    v2 = a1;
    sub_10009A50(dword_1017A58C, a1, 0);
    v3 = sub_100065D0(dword_1017A58C, a1);
    v4 = dword_10118A24;
  }
  v5 = v3;
  if ( v3 < 0xFFFFFFC2 && v3 )
  {
    sub_10006CC0(a2);
    v6 = dword_1017A58C;
    *(_WORD *)(a2 + 12) = v4;
    v7 = sub_1000AC40(v4, v6, v5, v2, a2);
    sub_1003E3A0(v5);
    return v7;
  }
  return 0;
}
// 10118A24: using guessed type int dword_10118A24;
// 1017A58C: using guessed type int dword_1017A58C;

//----- (1000B550) --------------------------------------------------------
char __cdecl sub_1000B550(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  __int16 v3; // bp@1
  unsigned int v4; // eax@1
  unsigned int v5; // edi@1
  char v6; // bl@3
  char result; // al@3

  v3 = *(_WORD *)(a3 + 12);
  v4 = sub_100065D0(a2, a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    sub_10006CC0(a3);
    *(_WORD *)(a3 + 12) = v3 - 1;
    v6 = sub_1000AC40((unsigned __int16)(v3 - 1), a2, v5, a1, a3);
    sub_1003E3A0(v5);
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1000B5B0) --------------------------------------------------------
int __cdecl sub_1000B5B0(int a1, int a2, char *a3)
{
  int result; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@11
  char *v6; // esi@11
  unsigned int v7; // eax@13
  int v8; // edi@13
  unsigned int v9; // esi@15
  char v10; // [sp+Ch] [bp-60Ch]@11
  char v11; // [sp+14h] [bp-604h]@4
  char v12; // [sp+214h] [bp-404h]@15

  sub_10007170();
  result = sub_100065D0(a2, a1);
  v4 = result;
  if ( (unsigned int)result < 0xFFFFFFC2 && result )
  {
    if ( *a3 )
    {
      if ( !strncmp(a3, "/mnt/card0", 0xAu) || !strncmp(a3, "/mnt/card1", 0xAu) )
        sub_1001D720((int)&v11, a3, 512);
      else
        _snprintf(&v11, 0x200u, "%s/%s", "/mnt/card0", a3);
    }
    else
    {
      _snprintf(&v11, 0x200u, "%s/%s", "/mnt/card0", &byte_1018DEC8[284 * (unsigned __int8)a1]);
      if ( !sub_1003E660((int)&v11) )
        j_FIL_vfs_mkdir(&v11, 1911);
      _snprintf(&v11, 0x200u, "%s/%s/%s", "/mnt/card0", &byte_1018DEC8[284 * (unsigned __int8)a1], &unk_1018DE00);
    }
    v5 = (unsigned __int8)a1;
    v6 = strstr(&v11, ".");
    sub_1001D840(&v10, 8u, "_%d.csv", (unsigned __int8)a1);
    strcpy(v6, &v10);
    if ( sub_1003E690((int)&v11) )
      j_FIL_vfs_delete(&v11);
    v7 = j_FIL_vfs_open(&v11, 26, 0);
    v8 = v7;
    if ( v7 < 0xFFFFFFC2 && v7 )
    {
      sub_10009A50(a2, a1, 0);
      sub_1001D840(
        &v12,
        0x400u,
        "\"%d\",\"%lX\",\"%s\",\"%s\",\"%s\",\"%hu\",\"%hhu\"\n",
        0,
        dword_10117F48,
        byte_10117F50,
        byte_10117F60,
        byte_10117F88,
        (unsigned __int16)word_10117F44,
        (unsigned __int8)a1);
      j_FIL_vfs_write(v8, &v12, strlen(&v12));
      memset(&unk_1017A590, 0, 0x1B04u);
      v9 = 0;
      if ( sub_1000AC40(0, a2, v4, a1, (int)&unk_1017A590) )
      {
        do
        {
          sub_10008160(
            (int)&unk_1017AFCC,
            (int)&unk_1017A798,
            v8,
            a1,
            (int)&unk_1017A590,
            (int)&unk_1017A5A4,
            (int)&unk_1017A734,
            (int)&unk_1017B030,
            (int)&unk_1017B1C0,
            (int)&unk_1017B224);
          ++v9;
          memset(&unk_1017A590, 0, 0x1B04u);
        }
        while ( sub_1000AC40(v9, a2, v4, a1, (int)&unk_1017A590) );
        v5 = (unsigned __int8)a1;
      }
      sub_1003E3A0(v4);
      sub_1003E3A0(v8);
      *((_BYTE *)&dword_1018D098 + v5) = 1;
      result = 0;
    }
    else
    {
      sub_1003E3A0(v4);
      result = v8;
    }
  }
  return result;
}
// 1003E400: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 1003E480: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 10117F44: using guessed type __int16 word_10117F44;
// 10117F48: using guessed type int dword_10117F48;
// 1018D098: using guessed type int dword_1018D098;

//----- (1000B8C0) --------------------------------------------------------
int __cdecl sub_1000B8C0(unsigned __int8 a1, unsigned __int16 a2, unsigned int a3, unsigned int a4)
{
  int v4; // ecx@0
  int v5; // esi@1
  int v6; // ebp@1
  unsigned int v7; // eax@1
  unsigned int v8; // ebx@1
  unsigned int v9; // eax@3
  unsigned int v10; // edi@3
  int v11; // ebp@5
  int v12; // ebp@6
  char *v13; // eax@13
  char v14; // cl@14
  int v15; // eax@31
  int v16; // ebp@44
  int v17; // eax@44
  int v18; // ebp@47
  unsigned int v19; // eax@48
  int v20; // ebp@49
  int v21; // ebp@52
  int v22; // ebp@57
  int v23; // ebp@60
  int v24; // ebp@65
  int v25; // ebp@69
  int v26; // ebp@72
  int v27; // ebp@81
  int v28; // ebp@84
  int v29; // eax@85
  int v30; // ebp@87
  int v31; // ebp@93
  unsigned int v32; // eax@96
  int v33; // ebp@102
  int v34; // eax@104
  __int64 v35; // kr08_8@109
  __int64 v36; // rax@109
  int v37; // ebp@110
  unsigned int v38; // eax@110
  int v39; // eax@112
  __int16 *v41; // [sp-10h] [bp-1C64h]@49
  unsigned __int8 v42; // [sp+13h] [bp-1C41h]@6
  unsigned int v43; // [sp+14h] [bp-1C40h]@8
  bool v44; // [sp+1Bh] [bp-1C39h]@40
  unsigned int v45; // [sp+1Ch] [bp-1C38h]@7
  unsigned __int16 v46; // [sp+20h] [bp-1C34h]@12
  int v47; // [sp+24h] [bp-1C30h]@1
  int v48; // [sp+28h] [bp-1C2Ch]@111
  unsigned int *v49; // [sp+34h] [bp-1C20h]@110
  unsigned int v50; // [sp+38h] [bp-1C1Ch]@1
  unsigned int v51; // [sp+40h] [bp-1C14h]@109
  char v52[4]; // [sp+44h] [bp-1C10h]@13
  unsigned __int16 v53; // [sp+4Ch] [bp-1C08h]@39
  char v54[256]; // [sp+1B50h] [bp-104h]@8

  v5 = v4;
  v6 = 0;
  v50 = a3;
  sub_10007170();
  memset(&unk_1017C098, 0, 0x1000u);
  memset(byte_1018D0B8, 0, 0x9C4u);
  sub_1000F170((int)&v47, 4096, (int)&unk_1017C098);
  v7 = sub_100065D0(a2, a1);
  v8 = v7;
  if ( v7 < 0xFFFFFFC2 )
  {
    if ( v7 )
    {
      v9 = j_FIL_vfs_open(v5, 42, 0);
      v10 = v9;
      if ( v9 < 0xFFFFFFC2 )
      {
        if ( v9 )
        {
          v11 = sub_10006D00(0, (int)&v47, 8u, v9);
LABEL_6:
          while ( 2 )
          {
            sub_1003E4B0(v8, &v42, 1);
            v12 = sub_10006D00(v42, (int)&v47, 5u, v10) + v11;
            switch ( v42 )
            {
              case 0u:
                sub_1003E4B0(v8, &v45, 4);
                v11 = sub_10006D00(v45, (int)&v47, 0x20u, v10) + v12;
                continue;
              case 1u:
                sub_1003E4B0(v8, &v42, 1);
                v11 = sub_10006D00(v42, (int)&v47, 3u, v10) + v12;
                sub_1003E4B0(v8, v54, v42);
                v43 = 0;
                if ( v42 )
                {
                  do
                    v11 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                  while ( v43 < v42 );
                }
                continue;
              case 2u:
                sub_1003E4B0(v8, &v42, 1);
                v11 = sub_10006D00(v42, (int)&v47, 8u, v10) + v12;
                continue;
              case 3u:
                sub_1003E4B0(v8, &v46, 2);
                v11 = sub_10006D00(v46, (int)&v47, 0x10u, v10) + v12;
                continue;
              case 4u:
                sub_1003E4B0(v8, v52, 8);
                sub_1001D840(v54, 0x100u, "%08lX", *(_DWORD *)v52);
                v11 = sub_10006D00(strlen(v54), (int)&v47, 4u, v10) + v12;
                v13 = v54;
                v43 = 0;
                do
                  v14 = *v13++;
                while ( v14 );
                if ( v13 != &v54[1] )
                {
                  do
                    v11 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                  while ( v43 < strlen(v54) );
                }
                continue;
              case 5u:
                sub_1003E4B0(v8, &v42, 1);
                v11 = sub_10006D00(v42, (int)&v47, 4u, v10) + v12;
                sub_1003E4B0(v8, v54, v42);
                v43 = 0;
                if ( v42 )
                {
                  do
                    v11 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                  while ( v43 < v42 );
                }
                continue;
              case 6u:
                sub_1003E4B0(v8, &v42, 1);
                v11 = sub_10006D00(v42, (int)&v47, 6u, v10) + v12;
                sub_1003E4B0(v8, v54, v42);
                v43 = 0;
                if ( v42 )
                {
                  do
                    v11 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                  while ( v43 < v42 );
                }
                continue;
              case 7u:
                sub_1003E4B0(v8, &v42, 1);
                v11 = sub_10006D00(v42, (int)&v47, 3u, v10) + v12;
                sub_1003E4B0(v8, v54, v42);
                v43 = 0;
                if ( v42 )
                {
                  do
                    v11 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                  while ( v43 < v42 );
                }
                continue;
              case 0x14u:
                goto LABEL_28;
              default:
                v43 = sub_1003E730(v8, 0, 1);
                if ( a4 )
                  v43 = a4;
                v53 = -1;
                sub_10006CC0((int)&v53);
                sub_1000AC40(a3, a2, v8, a1, (int)&v53);
                if ( v53 == -1 )
                  v44 = 1;
                else
                  v44 = byte_1018D0B8[v53] == 0;
                sub_1003E730(v8, v43, 0);
                while ( 2 )
                {
                  sub_1003E4B0(v8, &v42, 1);
                  switch ( v42 )
                  {
                    case 0u:
                      v16 = sub_10006D00(0, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v45, 4);
                      v17 = sub_10006D00(v45, (int)&v47, 0x20u, v10);
                      goto LABEL_45;
                    case 1u:
                      v16 = sub_10006D00(1u, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v45, 4);
                      v17 = sub_10006D00(v45, (int)&v47, 0xAu, v10);
                      goto LABEL_45;
                    case 2u:
                      v18 = sub_10006D00(2u, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v42, 1);
                      v12 = sub_10006D00(v42, (int)&v47, 2u, v10) + v18;
                      continue;
                    case 3u:
                      v19 = 3;
                      goto LABEL_49;
                    case 4u:
                      if ( !v44 )
                        goto LABEL_55;
                      v21 = sub_10006D00(4u, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v42, 1);
                      v12 = sub_10006D00(v42, (int)&v47, 5u, v10) + v21;
                      sub_1003E4B0(v8, v54, v42);
                      v43 = 0;
                      if ( v42 )
                      {
                        do
                          v12 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                        while ( v43 < v42 );
                      }
                      continue;
                    case 5u:
                      if ( v44 )
                      {
                        v22 = sub_10006D00(5u, (int)&v47, 7u, v10) + v12;
                        sub_1003E4B0(v8, &v42, 1);
                        v12 = sub_10006D00(v42, (int)&v47, 8u, v10) + v22;
                      }
                      else
                      {
                        sub_1003E4B0(v8, &v42, 1);
                      }
                      continue;
                    case 6u:
                      if ( v44 )
                      {
                        v23 = sub_10006D00(6u, (int)&v47, 7u, v10) + v12;
                        sub_1003E4B0(v8, &v42, 1);
                        v12 = sub_10006D00(v42, (int)&v47, 6u, v10) + v23;
                        sub_1003E4B0(v8, v54, v42);
                        v43 = 0;
                        if ( v42 )
                        {
                          do
                            v12 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                          while ( v43 < v42 );
                        }
                      }
                      else
                      {
                        sub_1003E4B0(v8, &v42, 1);
                        sub_1003E4B0(v8, v54, v42);
                      }
                      continue;
                    case 7u:
                      if ( !v44 )
                        goto LABEL_55;
                      v24 = sub_10006D00(7u, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v42, 1);
                      v12 = sub_10006D00(v42, (int)&v47, 5u, v10) + v24;
                      sub_1003E4B0(v8, v54, v42);
                      v43 = 0;
                      if ( v42 )
                      {
                        do
                          v12 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                        while ( v43 < v42 );
                      }
                      continue;
                    case 8u:
                      if ( !v44 )
                        goto LABEL_55;
                      v25 = sub_10006D00(8u, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v42, 1);
                      v12 = sub_10006D00(v42, (int)&v47, 5u, v10) + v25;
                      sub_1003E4B0(v8, v54, v42);
                      v43 = 0;
                      if ( v42 )
                      {
                        do
                          v12 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                        while ( v43 < v42 );
                      }
                      continue;
                    case 9u:
                      v26 = sub_10006D00(9u, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v42, 1);
                      v12 = sub_10006D00(v42, (int)&v47, 5u, v10) + v26;
                      sub_1003E4B0(v8, v54, v42);
                      v43 = 0;
                      if ( v42 )
                      {
                        do
                          v12 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                        while ( v43 < v42 );
                      }
                      continue;
                    case 0xAu:
                      v19 = 10;
LABEL_49:
                      v20 = sub_10006D00(v19, (int)&v47, 7u, v10) + v12;
                      v41 = (__int16 *)&v46;
                      goto LABEL_50;
                    case 0x14u:
                      v12 += sub_10006D00(0x14u, (int)&v47, 7u, v10);
                      continue;
                    case 0x15u:
                      if ( v44 )
                      {
                        v20 = sub_10006D00(0x15u, (int)&v47, 7u, v10) + v12;
                        v41 = (__int16 *)&v46;
LABEL_50:
                        sub_1003E4B0(v8, v41, 2);
                        v12 = sub_10006D00(v46, (int)&v47, 0x10u, v10) + v20;
                      }
                      else
                      {
                        sub_1003E4B0(v8, &v46, 2);
                      }
                      continue;
                    case 0x16u:
                      if ( v44 )
                      {
                        v27 = sub_10006D00(0x16u, (int)&v47, 7u, v10) + v12;
                        sub_1003E4B0(v8, &v42, 1);
                        v12 = sub_10006D00(v42, (int)&v47, 5u, v10) + v27;
                        sub_1003E4B0(v8, v54, v42);
                        v43 = 0;
                        if ( v42 )
                        {
                          do
                            v12 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                          while ( v43 < v42 );
                        }
                      }
                      else
                      {
LABEL_55:
                        sub_1003E4B0(v8, &v42, 1);
                        sub_1003E4B0(v8, v54, v42);
                      }
                      continue;
                    case 0x17u:
                      v28 = sub_10006D00(0x17u, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v42, 1);
                      v12 = sub_10006D00(v42, (int)&v47, 8u, v10) + v28;
                      sub_1003E4B0(v8, &v45, 4);
                      switch ( v42 )
                      {
                        case 0u:
                          goto LABEL_85;
                        case 2u:
                          goto LABEL_87;
                        case 3u:
                          v12 += sub_10006D00(v45, (int)&v47, 0x10u, v10);
                          continue;
                        case 1u:
                        case 4u:
                          goto LABEL_89;
                        default:
                          continue;
                      }
                      continue;
                    case 0x18u:
                      if ( v44 )
                      {
                        v16 = sub_10006D00(0x18u, (int)&v47, 7u, v10) + v12;
                        sub_1003E4B0(v8, &v45, 4);
                        v17 = sub_10006D00(v45, (int)&v47, 0x10u, v10);
LABEL_45:
                        v12 = v17 + v16;
                      }
                      else
                      {
                        sub_1003E4B0(v8, &v45, 4);
                      }
                      continue;
                    case 0x19u:
                      v31 = sub_10006D00(0x19u, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v42, 1);
                      if ( v42 )
                      {
                        if ( v42 == 1 )
                        {
                          v32 = 1;
                        }
                        else if ( v42 == 2 )
                        {
                          v32 = 3;
                        }
                        else
                        {
                          v32 = 2;
                        }
                      }
                      else
                      {
                        v32 = 0;
                      }
                      v45 = v32;
                      v12 = sub_10006D00(v32, (int)&v47, 2u, v10) + v31;
                      continue;
                    case 0x22u:
                      v12 += sub_10006D00(0x22u, (int)&v47, 7u, v10);
                      continue;
                    case 0x23u:
                      v33 = sub_10006D00(0x23u, (int)&v47, 7u, v10) + v12;
                      sub_1003E4B0(v8, &v42, 1);
                      v12 = sub_10006D00(v42, (int)&v47, 8u, v10) + v33;
                      sub_1003E4B0(v8, &v45, 4);
                      switch ( v42 )
                      {
                        case 0u:
LABEL_85:
                          v29 = sub_10006D00(v45, (int)&v47, 8u, v10);
                          goto LABEL_86;
                        case 2u:
LABEL_87:
                          v30 = sub_10006D00(v45, (int)&v47, 0x20u, v10) + v12;
                          sub_1003E4B0(v8, &v42, 1);
                          v12 = sub_10006D00(v42, (int)&v47, 4u, v10) + v30;
                          break;
                        case 1u:
                        case 4u:
LABEL_89:
                          v12 += sub_10006D00(v45, (int)&v47, 0x20u, v10);
                          break;
                        case 3u:
                          v29 = sub_10006D00(v45, (int)&v47, 0x10u, v10);
LABEL_86:
                          v12 += v29;
                          break;
                        default:
                          continue;
                      }
                      continue;
                    default:
                      v34 = sub_10006D00(v42, (int)&v47, 7u, v10);
                      ++v50;
                      v12 += v34;
                      if ( v53 != -1 )
                        byte_1018D0B8[v53] = 1;
                      v43 = sub_1003E730(v8, 0, 1);
                      v53 = -1;
                      sub_10006CC0((int)&v53);
                      sub_1000AC40(v50, a2, v8, a1, (int)&v53);
                      if ( v53 == -1 )
                        v44 = 1;
                      else
                        v44 = byte_1018D0B8[v53] == 0;
                      sub_1003E730(v8, v43, 0);
                      v35 = sub_1003E730(v8, 0, 1);
                      v51 = HIDWORD(v35);
                      v36 = sub_1003E5F0(v8);
                      if ( __PAIR__(v51, (unsigned int)v35) != v36 )
                        continue;
                      v45 = 127;
                      v37 = sub_10006D00(0x7Fu, (int)&v47, 7u, v10) + v12;
                      sub_1003E3A0(v8);
                      sub_1000F150((int)&v47);
                      v38 = sub_10041EF0(v49, v47 + 1, 0xFFFFFFFF);
                      v6 = sub_10006D00(v38, (int)&v47, 0x20u, v10) + v37;
                      if ( v47 )
                      {
                        v39 = v48 ? j_FIL_vfs_write(v10, v49, v47 + 1) : j_FIL_vfs_write(v10, v49, v47);
                        if ( v39 > 0 )
                          v6 += v39;
                      }
                      sub_1003E3A0(v10);
                      break;
                  }
                  return v6;
                }
            }
          }
LABEL_28:
          while ( 1 )
          {
            sub_1003E4B0(v8, &v42, 1);
            v11 = sub_10006D00(v42, (int)&v47, 5u, v10) + v12;
            if ( v42 == 21 )
              break;
            if ( v42 == 22 )
            {
              sub_1003E4B0(v8, &v42, 1);
              v12 = sub_10006D00(v42, (int)&v47, 5u, v10) + v11;
              if ( v42 )
              {
                sub_1003E4B0(v8, v54, v42);
                v43 = 0;
                if ( v42 )
                {
                  do
                    v12 += sub_10006D00((unsigned __int8)v54[v43++], (int)&v47, 8u, v10);
                  while ( v43 < v42 );
                }
              }
            }
            else
            {
              if ( v42 != 23 )
                goto LABEL_6;
              sub_1003E4B0(v8, &v45, 4);
              v15 = sub_10006D00(v45, (int)&v47, 0x10u, v10);
LABEL_27:
              v12 = v15 + v11;
            }
          }
          sub_1003E4B0(v8, &v46, 2);
          v15 = sub_10006D00(v46, (int)&v47, 0x10u, v10);
          goto LABEL_27;
        }
      }
    }
  }
  sub_1003E3A0(v8);
  return v6;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 1000B8C0: using guessed type char var_104[256];

//----- (1000C860) --------------------------------------------------------
int __cdecl sub_1000C860(unsigned __int8 a1, unsigned __int16 a2, int a3, char a4)
{
  int v4; // esi@1
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  unsigned int v7; // eax@8
  int v8; // ebx@10
  char v10; // [sp+1Ch] [bp-170h]@4
  int v11; // [sp+44h] [bp-148h]@7
  unsigned int v12; // [sp+48h] [bp-144h]@4
  char v13[4]; // [sp+4Ch] [bp-140h]@10
  char v14; // [sp+50h] [bp-13Ch]@10
  __int64 v15; // [sp+54h] [bp-138h]@4
  char v16; // [sp+5Ch] [bp-130h]@2

  sub_10007170();
  v4 = 284 * a1;
  if ( byte_1018DEF2[v4] )
    sub_1001D720((int)&v16, "/mnt/card1/cmc/", 300);
  else
    sub_1001D720((int)&v16, "/mnt/sys_nand0/cmc/", 300);
  sub_1001D870(&v16, &byte_1018DEC8[v4], 300);
  sub_1001D870(&v16, "/.logs_db", 300);
  v5 = j_FIL_vfs_open(&v16, 6, 0);
  sub_1003E730(v5, a2 << 6, 0);
  sub_1003E4B0(v5, &v10, 64);
  v6 = v12;
  if ( v12 != v15 )
    --dword_1018DAA0[13 * a1];
  if ( a4 || v11 <= -1 )
  {
    v7 = 0;
    v6 = 0;
  }
  else
  {
    v7 = v11 + 1;
  }
  v8 = sub_1000B8C0(a1, a2, v7, v6);
  sub_1003E730(v5, a2 << 6, 0);
  v11 = dword_10118A24;
  v12 = v15;
  v14 = 1;
  if ( !sub_10019F70(v13) )
    *(_DWORD *)v13 = 0;
  j_FIL_vfs_write(v5, &v10, 64);
  sub_1003E3A0(v5);
  sub_1003E110(41106, (int)&unk_1018DA80, 832);
  return v8;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 10118A24: using guessed type int dword_10118A24;
// 1018DAA0: using guessed type int dword_1018DAA0[];

//----- (1000CA00) --------------------------------------------------------
int sub_1000CA00()
{
  return sub_1003DDD0(49, 16);
}

//----- (1000CA10) --------------------------------------------------------
int sub_1000CA10()
{
  int v0; // esi@1
  double v1; // st6@1
  int result; // eax@1
  signed int v3; // ecx@1
  char v4; // bl@3
  unsigned __int8 *v5; // edi@3
  unsigned __int8 v6; // dl@4
  char v7; // cl@4

  *(_DWORD *)dword_102AD584 = 0;
  flt_100EF818 = 0.0;
  flt_100EF80C = 0.0;
  v0 = 0;
  flt_100FFA70 = 0.0;
  flt_100EF810 = 0.0;
  byte_100EF816 = 0;
  flt_100EF804 = 0.0;
  byte_100EF814 = 0;
  flt_100EF800 = 0.0;
  dword_100FF9F4 = 0;
  flt_100EF808 = 0.0;
  dword_10105284 = 0;
  byte_100EF815 = 0;
  byte_1010527C = 0;
  dword_10105280 = 0;
  dword_100EF81C = 0;
  dword_10105278 = 0;
  dword_100FF9F0 = 0;
  dword_100FFA74 = sub_1003DC90();
  sub_1003DB80(104, &byte_100EF817);
  v1 = 9.8999998e24;
  result = (int)&unk_100EF820;
  v3 = 1500;
  do
  {
    *(_DWORD *)(result + 40) = 0;
    *(float *)result = -9.8999998e24;
    result += 44;
    --v3;
    *(float *)(result - 36) = -9.8999998e24;
    *(float *)(result - 40) = *(float *)&v1;
    *(float *)(result - 20) = *(float *)&v1;
  }
  while ( v3 );
  v4 = 0;
  v5 = (unsigned __int8 *)&unk_10060EA8;
  do
  {
    v6 = *v5;
    v7 = 0;
    if ( *v5 )
    {
      do
      {
        result = 2 * (unsigned __int16)v0;
        byte_100FF9F9[result] = v7++;
        ++v0;
        byte_100FF9F8[result] = v4;
      }
      while ( (unsigned __int8)v7 < v6 );
    }
    ++v4;
    ++v5;
  }
  while ( (unsigned __int8)v4 < 5u );
  return result;
}
// 100EF800: using guessed type float flt_100EF800;
// 100EF804: using guessed type float flt_100EF804;
// 100EF808: using guessed type float flt_100EF808;
// 100EF80C: using guessed type float flt_100EF80C;
// 100EF810: using guessed type float flt_100EF810;
// 100EF814: using guessed type char byte_100EF814;
// 100EF815: using guessed type char byte_100EF815;
// 100EF816: using guessed type char byte_100EF816;
// 100EF817: using guessed type char byte_100EF817;
// 100EF818: using guessed type float flt_100EF818;
// 100EF81C: using guessed type int dword_100EF81C;
// 100FF9F0: using guessed type int dword_100FF9F0;
// 100FF9F4: using guessed type int dword_100FF9F4;
// 100FFA70: using guessed type float flt_100FFA70;
// 100FFA74: using guessed type int dword_100FFA74;
// 10105278: using guessed type int dword_10105278;
// 1010527C: using guessed type char byte_1010527C;
// 10105280: using guessed type int dword_10105280;
// 10105284: using guessed type int dword_10105284;
// 102AD584: using guessed type int dword_102AD584;

//----- (1000CA20) --------------------------------------------------------
signed int sub_1000CA20()
{
  signed int result; // eax@2

  sub_1001AFD0();
  if ( sub_1003EE40((LONG)&off_100652E0) )
  {
    sub_100043C0(0);
    sub_1000CA10();
    result = sub_1003E9D0((int)&off_100652E0);
  }
  else
  {
    sub_100129A0("..\\lib\\adl\\mon_log_init.c", 156, 1, 0);
    result = sub_1003E9D0((int)&off_100652E0);
  }
  return result;
}
// 100652E0: using guessed type char *off_100652E0;

//----- (1000CA80) --------------------------------------------------------
char __usercall sub_1000CA80@<al>(double st7_0@<st0>, __int16 a1, __int16 a2, char a3, unsigned __int8 a4)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-44h]@2
  char v8; // [sp+8h] [bp-40h]@1
  unsigned int v9; // [sp+14h] [bp-34h]@2
  unsigned int v10; // [sp+3Ch] [bp-Ch]@2
  unsigned int v11; // [sp+40h] [bp-8h]@2

  v5 = 6916 * a4;
  *(_WORD *)(v5 + dword_102ACCCC) = a1;
  *(_BYTE *)(v5 + dword_102ACCCC + 3) = a3;
  *(_WORD *)(v5 + dword_102ACCCC + 16) = a2;
  if ( sub_10013680(0, 148, 0, 60, &v8) )
  {
    sub_10014D30(&v7, v10);
    *(_DWORD *)(v5 + dword_102ACCCC + 4) = v7;
    sub_10014E70(&v7, v11);
    *(_DWORD *)(v5 + dword_102ACCCC + 4) += v7;
    *(_DWORD *)(v5 + dword_102ACCCC + 8) = v9 / 0xF4240;
  }
  else if ( !sub_10019F70((char *)(v5 + dword_102ACCCC + 4)) )
  {
    *(_DWORD *)(v5 + dword_102ACCCC + 4) = 0;
  }
  return sub_1000A4F0(
           st7_0,
           *(_WORD *)(v5 + dword_102ACCCC + 16),
           v5 + dword_102ACCCC,
           v5 + dword_102ACCCC + 20,
           v5 + dword_102ACCCC + 420,
           v5 + dword_102ACCCC + 520,
           v5 + dword_102ACCCC + 2620,
           v5 + dword_102ACCCC + 2720,
           v5 + dword_102ACCCC + 3120,
           v5 + dword_102ACCCC + 3220);
}
// 102ACCCC: using guessed type int dword_102ACCCC;

//----- (1000CBB0) --------------------------------------------------------
void __usercall sub_1000CBB0(double a1@<st0>)
{
  void *v1; // ecx@5
  void *v2; // ecx@13
  int v3; // ecx@24
  void *v4; // ecx@31
  char v5; // al@47
  int v6; // esi@85
  char v7; // [sp+11h] [bp-1CB7h]@1
  char v8; // [sp+12h] [bp-1CB6h]@1
  char v9; // [sp+13h] [bp-1CB5h]@1
  int *v10; // [sp+14h] [bp-1CB4h]@51
  int v11; // [sp+18h] [bp-1CB0h]@51
  int v12; // [sp+1Ch] [bp-1CACh]@31
  char v13; // [sp+22h] [bp-1CA6h]@1
  bool v14; // [sp+23h] [bp-1CA5h]@1
  int v15; // [sp+24h] [bp-1CA4h]@85
  int v16; // [sp+28h] [bp-1CA0h]@1
  int v17; // [sp+2Ch] [bp-1C9Ch]@1
  int v18; // [sp+30h] [bp-1C98h]@30
  int v19; // [sp+34h] [bp-1C94h]@1
  int v20; // [sp+38h] [bp-1C90h]@1
  int v21; // [sp+3Ch] [bp-1C8Ch]@1
  int v22; // [sp+40h] [bp-1C88h]@79
  unsigned __int16 v23; // [sp+44h] [bp-1C84h]@30
  int v24; // [sp+48h] [bp-1C80h]@37
  char v25[4]; // [sp+4Ch] [bp-1C7Ch]@37
  char v26; // [sp+50h] [bp-1C78h]@77
  int v27; // [sp+79h] [bp-1C4Fh]@85
  int v28; // [sp+80h] [bp-1C48h]@80
  int v29; // [sp+84h] [bp-1C44h]@80
  int v30; // [sp+88h] [bp-1C40h]@80
  int v31; // [sp+8Ch] [bp-1C3Ch]@80
  int v32; // [sp+90h] [bp-1C38h]@80
  int v33; // [sp+94h] [bp-1C34h]@80
  char v34; // [sp+98h] [bp-1C30h]@1
  char v35; // [sp+178h] [bp-1B50h]@37
  int v36; // [sp+188h] [bp-1B40h]@38
  char v37; // [sp+18Ch] [bp-1B3Ch]@38
  char v38; // [sp+31Ch] [bp-19ACh]@38
  char v39; // [sp+380h] [bp-1948h]@38
  char v40; // [sp+BB4h] [bp-1114h]@38
  char v41; // [sp+C18h] [bp-10B0h]@38
  char v42; // [sp+DA8h] [bp-F20h]@38
  char v43; // [sp+E0Ch] [bp-EBCh]@38
  char v44; // [sp+1C7Ch] [bp-4Ch]@51
  char v45; // [sp+1C9Ch] [bp-2Ch]@57

  sub_1001E150();
  sub_1001DD50(&v34);
  sub_1001DB60();
  sub_1001D9A0();
  v8 = 0;
  v9 = 1;
  v13 = 1;
  v17 = 0;
  sub_100043C0(0);
  sub_1000EB00(
    0,
    (int)&unk_1027E680,
    (int)&v21,
    (int)&unk_10190BD0,
    &unk_10266F80,
    15000,
    14000,
    22000,
    1500,
    1000,
    10000,
    (int)"/mnt/card0/atm/log_cov.bin",
    &unk_102A5780);
  sub_100042E0((int)&unk_1027E680, 0x3E8u);
  sub_10013DB0();
  v16 = 0;
  v19 = 0;
  v20 = 0;
  v14 = 0;
  sub_1001AFF0();
  word_10190BCC = 0;
  v7 = 0;
  while ( !sub_1003DC40(29) || !sub_1003DC40(30) )
    sub_1003DE80(10);
  sub_1003E2F0(9027, &v9, 1, &v13);
  sub_1003E110(41097, (int)&v7, 1);
  if ( sub_1001D4B0(v1) == (void *)4 && !sub_1001D4D0(1) && byte_102ACCB0 && v9 )
    v8 = 1;
  while ( 1 )
  {
    sub_1003DF10(&v16);
    if ( v16 & 0x10 )
      sub_1000A010();
    if ( v16 & 1 )
    {
      sub_1003E2F0(9027, &v9, 1, &v13);
      if ( sub_1001D4B0(v2) == (void *)4 && !sub_1001D4D0(1) && byte_102ACCB0 && v9 )
      {
        v8 = 1;
        if ( v14 || (v14 = sub_1001AF80()) != 0 )
          sub_100053D0(a1, (int)&unk_1027E680, v21, (int)&unk_10190BD0, (int)&unk_10266F80, (int)&unk_102A5780, 0);
        if ( (unsigned int)(sub_1003DC90() - v19) >= 0x3E8 )
        {
          v19 = sub_1003DC90();
          sub_1001DC30((int *)&v34);
        }
        if ( (unsigned int)(sub_1003DC90() - v20) >= 0x1388 )
        {
          v20 = sub_1003DC90();
          sub_10007170();
        }
        sub_1000A880();
        if ( (unsigned __int8)sub_1001D9B0(v3) && (unsigned __int8)sub_1001D9E0() )
        {
          sub_1003DDA0(80, 1000);
          if ( v17 != *(_DWORD *)dword_102AD578 )
            sub_10006EA0((unsigned int *)&v17);
          sub_1003DD40(80);
        }
      }
      else
      {
        v8 = 0;
      }
    }
    if ( v16 & 2 && sub_1003DC10((int)&v23, (int)&v18) != 1 )
    {
      do
      {
        memset(&unk_1018F0C8, 0, 0x1B04u);
        v12 = 1;
        if ( (signed int)v23 > 32769 )
        {
          switch ( v23 )
          {
            case 0x8016u:
              goto LABEL_34;
            case 0x8002u:
              if ( v8 && (unsigned __int8)sub_1001DC20() )
              {
                memcpy(&v35, (const void *)(dword_102AD574 + 6916 * (unsigned __int16)v24), 0x1B04u);
                sub_1000A4F0(
                  a1,
                  v36,
                  (int)&v35,
                  (int)&v37,
                  (int)&v38,
                  (int)&v39,
                  (int)&v40,
                  (int)&v41,
                  (int)&v42,
                  (int)&v43);
              }
              break;
            case 0x8003u:
              v12 = 0;
              if ( sub_1001D4B0(v4) != (void *)4 )
                goto LABEL_49;
              v5 = sub_1000B140(v24, v25[0], *(unsigned __int16 *)&v25[2], (int)&unk_1018F0C8);
              goto LABEL_48;
            case 0x8004u:
              v12 = 0;
              if ( sub_1001D4B0(v4) == (void *)4 )
                v12 = (unsigned __int8)sub_1000B1A0(v25[0], (int)&unk_1018F0C8);
              goto LABEL_49;
            case 0x8005u:
              v12 = 0;
              if ( sub_1001D4B0(v4) == (void *)4 )
                v12 = (unsigned __int8)sub_1000B200(v25[0], *(unsigned __int16 *)&v25[2], (int)&unk_1018F0C8);
              goto LABEL_49;
            case 0x8007u:
              v12 = 0;
              if ( sub_1001D4B0(v4) != (void *)4 )
                goto LABEL_49;
              v5 = sub_10007310(*(int *)v25, *(int *)&v25[2], &v45, 0x28u);
              goto LABEL_48;
            case 0x8006u:
              v12 = 0;
              if ( sub_1001D4B0(v4) != (void *)4 )
                goto LABEL_49;
              v5 = sub_10005BD0(v25[0], (int)&v44, 32);
              goto LABEL_48;
            case 0x8008u:
              v12 = 0;
              if ( sub_1001D4B0(v4) == (void *)4 )
                v12 = (unsigned __int8)sub_1000B260(v25[0], (int)&unk_1018F0C8);
              goto LABEL_49;
            case 0x8009u:
              v12 = 0;
              if ( sub_1001D4B0(v4) == (void *)4 )
                v12 = sub_1000B300(v25[0], *(unsigned __int16 *)&v25[2], (int)&unk_1018F0C8);
              goto LABEL_49;
            case 0x800Au:
              v12 = 0;
              if ( sub_1001D4B0(v4) != (void *)4 )
                goto LABEL_49;
              dword_1018F0D4 = v24;
              v5 = sub_1000B370(v25[0], (int)&unk_1018F0C8);
              goto LABEL_48;
            case 0x800Bu:
              v12 = 0;
              if ( sub_1001D4B0(v4) == (void *)4 )
              {
                dword_1018F0D4 = v24;
                v12 = (unsigned __int8)sub_1000B430(v25[0], *(unsigned __int16 *)&v25[2], (int)&unk_1018F0C8);
              }
              goto LABEL_49;
            case 0x800Cu:
              v12 = 0;
              if ( sub_1001D4B0(v4) != (void *)4 )
                goto LABEL_49;
              dword_1018F0D4 = v24;
              v5 = sub_1000B490(v25[0], (int)&unk_1018F0C8);
              goto LABEL_48;
            case 0x800Du:
              v12 = 0;
              if ( sub_1001D4B0(v4) == (void *)4 )
              {
                dword_1018F0D4 = v24;
                v12 = (unsigned __int8)sub_1000B550(v25[0], *(unsigned __int16 *)&v25[2], (int)&unk_1018F0C8);
              }
              goto LABEL_49;
            case 0x800Eu:
              if ( sub_1001D4B0(v4) == (void *)4 )
              {
                v7 = 4;
                sub_1003E110(41097, (int)&v7, 1);
                sub_1000A950();
                v7 = 0;
                sub_1003E110(41097, (int)&v7, 1);
              }
              break;
            case 0x8011u:
              if ( sub_1001D4B0(v4) == (void *)4 )
              {
                v7 = 4;
                sub_1003E110(41097, (int)&v7, 1);
                sub_1000AAB0(HIWORD(v24));
                v7 = 0;
                sub_1003E110(41097, (int)&v7, 1);
              }
              break;
            case 0x800Fu:
              if ( sub_1001D4B0(v4) == (void *)4 )
              {
                v7 = 1;
                sub_1003E110(41097, (int)&v7, 1);
                sub_1000B5B0(*(int *)v25, *(int *)&v25[2], &v26);
                v7 = 0;
                sub_1003E110(41097, (int)&v7, 1);
              }
              break;
            case 0x8014u:
              if ( sub_1001D4B0(v4) != (void *)4 )
                break;
              v12 = 1;
              v22 = (unsigned __int16)sub_10005C10(v25[0]);
              goto LABEL_49;
            case 0x8015u:
              v12 = 0;
              v28 = 0;
              v29 = 0;
              v30 = 0;
              v31 = 0;
              v32 = 0;
              v33 = 0;
              if ( sub_1001D4B0(v4) == (void *)4 )
              {
                v5 = sub_10005A40(v25[0], *(unsigned __int16 *)&v25[2], (int)&v28);
LABEL_48:
                v12 = (unsigned __int8)v5;
              }
LABEL_49:
              if ( v12 == 1 )
              {
                switch ( v23 )
                {
                  case 0x8006:
                    v10 = (int *)&v44;
                    v11 = 32;
                    break;
                  case 0x8007:
                    v10 = (int *)&v45;
                    v11 = 40;
                    break;
                  case 0x8014:
                    v10 = &v22;
                    v11 = 2;
                    break;
                  case 0x8015:
                    v10 = &v28;
                    v11 = 24;
                    break;
                  default:
                    sub_1001B160(0, (unsigned __int16)word_10190BCC, &unk_1018F0C8);
                    v10 = (int *)&word_10190BCC;
                    v11 = 2;
                    break;
                }
              }
              else
              {
                v10 = 0;
                v11 = 0;
              }
              sub_1003DD60(v18, (int)&v10);
              if ( v12 == 1 && (unsigned __int16)++word_10190BCC >= 0xAu )
                word_10190BCC = 0;
              break;
            case 0x8010u:
              if ( v8 )
                sub_10006DF0();
              break;
            case 0x8013u:
              if ( sub_1001D4B0(v4) == (void *)4 )
              {
                v7 = 2;
                sub_1003E110(41097, (int)&v7, 1);
                sub_1003E040(41105, (int)&v15, 4);
                v15 |= 0x10u;
                sub_1003E110(41105, (int)&v15, 4);
                v6 = sub_1000C860(v25[0], *(unsigned __int16 *)&v25[2], (int)&v26, v27);
                sub_1003E040(41105, (int)&v15, 4);
                v15 |= 0x20u;
                sub_1003E110(41105, (int)&v15, 4);
                v7 = 0;
                sub_1003E110(41097, (int)&v7, 1);
                sub_1001DAC0(v25[0], v6);
              }
              break;
            case 0x8018u:
              sub_10007390(BYTE2(v24), v24, SBYTE3(v24));
              break;
            case 0x8019u:
              sub_10005D20(BYTE2(v24), v24, SBYTE3(v24));
              break;
            default:
              break;
          }
        }
        else if ( v23 == 32769 )
        {
          if ( v8 )
          {
            if ( sub_1001B000(v25[0], (unsigned __int16)v24, &v35) )
              sub_1000A4F0(
                a1,
                v36,
                (int)&v35,
                (int)&v37,
                (int)&v38,
                (int)&v39,
                (int)&v40,
                (int)&v41,
                (int)&v42,
                (int)&v43);
          }
          else if ( sub_1001D4B0(v4) != (void *)4 && sub_10013740(0) )
          {
            sub_1001DA70(v24);
          }
        }
        else if ( v23 == 1 )
        {
LABEL_34:
          sub_10005E20();
        }
      }
      while ( sub_1003DC10((int)&v23, (int)&v18) != 1 );
    }
  }
}
// 1001E150: using guessed type int sub_1001E150(void);
// 1018F0D4: using guessed type int dword_1018F0D4;
// 10190BCC: using guessed type __int16 word_10190BCC;
// 102ACCB0: using guessed type char byte_102ACCB0;
// 102AD574: using guessed type int dword_102AD574;
// 102AD578: using guessed type int dword_102AD578;

//----- (1000D630) --------------------------------------------------------
int __usercall sub_1000D630@<eax>(double st7_0@<st0>, int a1, _DWORD *a2)
{
  *a2 = (char *)&unk_10266F80 + 64 * (unsigned __int16)a1;
  return sub_10004230(st7_0, a1, (int)&unk_1027E680, (int)&unk_10266F80, (int)&unk_102A5780);
}

//----- (1000D660) --------------------------------------------------------
int __cdecl sub_1000D660(void *a1)
{
  int *v1; // edi@1
  char *v2; // esi@1
  int v3; // eax@2
  int v5; // [sp+8h] [bp-314h]@1
  int v6; // [sp+Ch] [bp-310h]@1
  char v7; // [sp+10h] [bp-30Ch]@2
  int v8; // [sp+20h] [bp-2FCh]@2
  int v9; // [sp+24h] [bp-2F8h]@2
  char v10; // [sp+30h] [bp-2ECh]@1
  char v11; // [sp+40h] [bp-2DCh]@1

  memset(a1, 0, 0x90u);
  sub_1001D720((int)a1, (_BYTE *)(dword_102AD588 + 20440), 40);
  sub_1003E040(6120, (int)&v10, 744);
  strncpy((char *)a1 + 120, &v10, 0x10u);
  strncpy((char *)a1 + 136, &v11, 8u);
  sub_1001D720((int)a1 + 64, (_BYTE *)(dword_102AD588 + 1), 22);
  sub_1001D720((int)a1 + 40, "006-B0319-C1", 16);
  sub_1001D720((int)a1 + 56, "14.01", 8);
  v5 = 0;
  v6 = 0;
  sub_1003E0A0(6103, (char *)a1 + 88, 8, &v5);
  v1 = (int *)off_100942EC;
  v2 = (char *)a1 + 96;
  do
  {
    sub_1003E940(*v1, (unsigned int)&v7);
    v3 = v9;
    *(_DWORD *)v2 = v8;
    *((_DWORD *)v2 + 1) = v3;
    ++v1;
    v2 += 8;
  }
  while ( (signed int)v1 < (signed int)off_100942F8 );
  return 0;
}
// 100942EC: using guessed type char *off_100942EC[7];
// 100942F8: using guessed type char *off_100942F8[4];
// 102AD588: using guessed type int dword_102AD588;

//----- (1000D780) --------------------------------------------------------
char **sub_1000D780()
{
  return off_10066DB8;
}
// 10066DB8: using guessed type char *off_10066DB8[3];

//----- (1000D790) --------------------------------------------------------
bool sub_1000D790()
{
  byte_102ACCB0 = 1;
  return sub_1001E780(0, 0, (int)".\\test\\tst_mon_log_main.c", (int)"92", (int)"CMC set to valid.", 1u, 1u, 0);
}
// 102ACCB0: using guessed type char byte_102ACCB0;

//----- (1000D7C0) --------------------------------------------------------
bool sub_1000D7C0()
{
  return sub_1001E780(0, 0, (int)".\\test\\tst_mon_log_main.c", (int)"115", (int)"CMC is valid?", byte_102ACCB0, 1u, 0);
}
// 102ACCB0: using guessed type char byte_102ACCB0;

//----- (1000D7F0) --------------------------------------------------------
int (**sub_1000D7F0())()
{
  return off_10067620;
}
// 10067620: using guessed type int (*off_10067620[3])();

//----- (1000D810) --------------------------------------------------------
int __usercall sub_1000D810@<eax>(size_t a1@<ebx>, char *a2@<esi>)
{
  int v2; // ebp@1
  int v3; // edi@5
  int v5; // [sp+8h] [bp-14h]@1
  int v6; // [sp+Ch] [bp-10h]@1
  char v7; // [sp+10h] [bp-Ch]@4
  char v8; // [sp+15h] [bp-7h]@4

  v2 = 0;
  v5 = 0;
  v6 = 0;
  if ( sub_10019F70(dword_101A68E8) )
  {
    sub_1002ACA0((int *)dword_101A68E8, *(int *)dword_101A68E8);
  }
  else
  {
    v5 = 131072257;
    sub_10014D30((int *)dword_101A68E8, 0x7D00101u);
  }
  sub_1000F7D0(dword_101A68A0, (int)&v7);
  v8 = 0;
  while ( 1 )
  {
    sub_10014C40((int)&v5, *(unsigned int *)dword_101A68E8);
    sub_10014E20((int)&v6, *(unsigned int *)dword_101A68E8);
    v3 = sub_1001D840(
           a2,
           a1,
           "/mnt/card0/data_log/log_%02d%02d%02d_%02d%02d%02d_%s.csv",
           HIWORD(v5) % 100,
           (unsigned __int8)v5,
           BYTE1(v5),
           (signed __int16)v6,
           BYTE2(v6),
           BYTE3(v6),
           &v7);
    if ( !sub_1003E690((int)a2) )
      break;
    ++*(_DWORD *)dword_101A68E8;
    if ( ++v2 >= 1000 )
      goto LABEL_9;
  }
  v3 = 0;
LABEL_9:
  if ( byte_101A4460 && !j_FIL_vfs_rename(&byte_101A4460, a2) )
    sub_1001D720((int)&byte_101A4460, a2, 48);
  return v3;
}
// 1003E580: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);
// 101A4460: using guessed type char byte_101A4460;
// 101A68A0: using guessed type int dword_101A68A0;

//----- (1000D960) --------------------------------------------------------
char __cdecl sub_1000D960(unsigned __int16 a1, float *a2)
{
  *a2 = 0.0;
  return sub_100188F0(a1, a2);
}

//----- (1000D980) --------------------------------------------------------
int sub_1000D980()
{
  void *v0; // ecx@1
  int v1; // edi@4
  unsigned __int16 *v2; // esi@4
  char v4; // [sp+Fh] [bp-1h]@1

  memset(&unk_101A4490, 0, 0x2004u);
  memset(byte_101A68F0, 0, 0x6Cu);
  memset(&unk_101A4450, 0, 0x40u);
  memset(&unk_101A68A8, 0, 0x40u);
  sub_1003E0E0(9160, (int)&unk_101A68A8, 64);
  dword_101A68A0 = 0x3FFFF;
  dword_101A68EC = 0;
  *(_DWORD *)dword_101A68E8 = 0;
  v4 = 0;
  byte_101A689E = 0;
  if ( sub_1001D4B0(v0) == (void *)4 )
  {
    sub_1003DB80(87, &v4);
    if ( v4 == 1 )
      byte_101A689E = 2;
  }
  dword_101A6494 = sub_1003DC90();
  dword_101A68A4 = 0;
  v1 = 0;
  v2 = (unsigned __int16 *)&unk_100681F4;
  do
  {
    if ( *v2 )
      byte_101A68F0[v1] = sub_1002ACC0(*v2);
    else
      byte_101A68F0[v1] = 1;
    v2 += 20;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)"_%02d%02d%02d_%s.csv" );
  return sub_1003DDD0(57, 16);
}
// 101A6494: using guessed type int dword_101A6494;
// 101A689E: using guessed type char byte_101A689E;
// 101A68A0: using guessed type int dword_101A68A0;
// 101A68A4: using guessed type int dword_101A68A4;
// 101A68EC: using guessed type int dword_101A68EC;

//----- (1000DA70) --------------------------------------------------------
signed int __usercall sub_1000DA70@<eax>(unsigned int a1@<eax>, char *a2, signed int a3)
{
  char *v3; // ebp@1
  unsigned int v4; // esi@1
  int v5; // eax@5
  int v6; // edi@5
  int v7; // ebx@6

  v3 = a2;
  v4 = a1;
  if ( (signed int)a1 >= a3 || a1 >= 0x2000 || a2[a1] || !a2[a1 - 1] )
  {
    v7 = -15;
  }
  else
  {
    v5 = dword_101A6490;
    v6 = 0x2000 - dword_101A6490;
    if ( 0x2000 - dword_101A6490 <= (signed int)v4 )
    {
      memcpy_0((char *)&unk_101A4490 + dword_101A6490, a2, 0x2000 - dword_101A6490);
      j_HWM_pvg_wait_for_power(6, 1);
      v7 = j_FIL_vfs_write(dword_101A68A4, &unk_101A4490, 0x2000);
      if ( v7 == 0x2000 )
      {
        v7 = 0;
        sub_1001D720((int)&unk_101A4450, "LOGGING DATA", 16);
      }
      v3 = &a2[v6];
      v4 -= v6;
      v5 = 0;
      dword_101A68EC = v7;
      dword_101A6490 = 0;
    }
    else
    {
      v7 = 0;
      if ( dword_101A68EC >= 0 )
      {
        sub_1001D720((int)&unk_101A4450, "LOGGING DATA", 16);
        v5 = dword_101A6490;
      }
    }
    if ( v4 > 0x2000 - v5 )
    {
      v4 = 0;
      v5 = 0;
      dword_101A6490 = 0;
    }
    memcpy_0((char *)&unk_101A4490 + v5, v3, v4);
    dword_101A6490 += v4;
    if ( v7 >= 0 )
      return v7;
    if ( v7 == -27 )
    {
      sub_1001D720((int)&unk_101A4450, "ERROR CARD FULL", 16);
      sub_1003E3A0(dword_101A68A4);
      dword_101A68A4 = -27;
      return -27;
    }
  }
  sub_1001D720((int)&unk_101A4450, "FILE ERROR", 16);
  return v7;
}
// 1003E380: using guessed type int __cdecl j_HWM_pvg_wait_for_power(_DWORD, _DWORD);
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 101A6490: using guessed type int dword_101A6490;
// 101A68A4: using guessed type int dword_101A68A4;
// 101A68EC: using guessed type int dword_101A68EC;

//----- (1000DBC0) --------------------------------------------------------
void __usercall sub_1000DBC0(void *a1@<ecx>, _DWORD a2@<esi>)
{
  char v2; // bl@1
  float v3; // ST28_4@1
  int v4; // ecx@1
  int v5; // eax@1
  bool v6; // al@3
  double v7; // st7@4
  _BYTE v8; // al@7
  double v9; // st7@9
  char v10; // al@10
  double v11; // st7@12
  char v12; // al@14
  double v13; // st7@14
  _DWORD v14; // ecx@15
  _DWORD v15; // eax@15
  bool v16; // zf@15
  _DWORD v17; // eax@19
  bool v18; // cf@19
  _DWORD v19; // eax@22
  double v20; // st7@26
  _DWORD v21; // eax@27
  double v22; // st7@37
  double v23; // st5@37
  double v24; // st4@37
  double v25; // st3@37
  double v26; // st2@37
  double v27; // st7@39
  const char *v28; // [sp-10h] [bp-14Ch]@7
  char v29; // [sp+Fh] [bp-12Dh]@3
  char v30; // [sp+10h] [bp-12Ch]@7
  float v31; // [sp+14h] [bp-128h]@9
  char v32; // [sp+18h] [bp-124h]@7
  float v33; // [sp+1Ch] [bp-120h]@7
  char v34; // [sp+24h] [bp-118h]@37
  float v35; // [sp+28h] [bp-114h]@37
  float v36; // [sp+2Ch] [bp-110h]@37
  float v37; // [sp+30h] [bp-10Ch]@37
  float v38; // [sp+34h] [bp-108h]@37
  float v39; // [sp+38h] [bp-104h]@37
  char v40; // [sp+3Ch] [bp-100h]@10
  float v41; // [sp+40h] [bp-FCh]@12
  float v42; // [sp+44h] [bp-F8h]@11
  char v43; // [sp+48h] [bp-F4h]@27
  char v44; // [sp+4Ch] [bp-F0h]@25
  int v45; // [sp+50h] [bp-ECh]@26
  int v46; // [sp+54h] [bp-E8h]@26
  char v47; // [sp+68h] [bp-D4h]@4
  float v48; // [sp+E8h] [bp-54h]@4
  unsigned __int8 v49; // [sp+FCh] [bp-40h]@14
  int v50; // [sp+100h] [bp-3Ch]@18
  unsigned __int8 v51; // [sp+107h] [bp-35h]@19

  v2 = 1;
  *(_BYTE *)(a2 + 2676) = 1;
  v3 = (double)sub_1001A710(a1) * 0.000000001462918119976564;
  *(float *)(a2 + 336) = sub_10041D80(v3);
  *(_BYTE *)(a2 + 2677) = 1;
  *(_BYTE *)(a2 + 2678) = 1;
  *(_BYTE *)(a2 + 2679) = 1;
  *(_BYTE *)(a2 + 2680) = 1;
  *(float *)(a2 + 340) = (double)(unsigned int)sub_1002B0F0(3, 1);
  *(float *)(a2 + 344) = (double)(unsigned int)sub_1002B0F0(4, 1);
  *(float *)(a2 + 348) = (double)(unsigned int)sub_1002B0F0(0, 1);
  *(float *)(a2 + 352) = (double)(unsigned int)sub_1002B0F0(1, 1);
  *(_BYTE *)(a2 + 2675) = 1;
  v5 = (unsigned __int8)sub_1001A6D0(v4) - 1;
  if ( !v5 )
  {
    sub_1002B0D0((int)&v32);
    *(float *)(a2 + 356) = v33;
    *(_BYTE *)(a2 + 2681) = 1;
    v8 = sub_1002AEC0(3, (int)&v30);
    v28 = "NAV1";
    goto LABEL_9;
  }
  if ( v5 == 1 )
  {
    sub_1002B0D0((int)&v32);
    *(float *)(a2 + 356) = v33;
    *(_BYTE *)(a2 + 2681) = 1;
    v8 = sub_1002AEC0(4, (int)&v30);
    v28 = "NAV2";
LABEL_9:
    v9 = v31;
    *(_BYTE *)(a2 + 2682) = v8;
    *(float *)(a2 + 360) = v9;
    sub_1001D720(a2 + 2092, v28, 20);
    goto LABEL_10;
  }
  *(_BYTE *)(a2 + 2681) = sub_1003FBB0((float *)(a2 + 356));
  v6 = sub_10040290((float *)(a2 + 360), &v29);
  *(_BYTE *)(a2 + 2682) = v6;
  if ( !v6 )
  {
    sub_100402E0(&v47);
    v7 = v48;
    if ( v48 != 9.9999996e24 )
    {
      *(_BYTE *)(a2 + 2682) = 1;
      *(float *)(a2 + 360) = v7 * 0.003280839882791042;
    }
  }
  sub_1001D720(a2 + 2092, "GPS", 20);
LABEL_10:
  v10 = sub_1003FEA0((int)&v40);
  *(_BYTE *)(a2 + 2683) = v10;
  if ( v10 == 1 && v42 < 9.9999996e24 )
  {
    v11 = v41;
    if ( v41 < 9.9999996e24 )
    {
      *(float *)(a2 + 364) = v42;
      *(_BYTE *)(a2 + 2684) = 1;
      *(float *)(a2 + 368) = v11;
    }
  }
  *(_BYTE *)(a2 + 2685) = sub_10040140(1, (float *)(a2 + 372));
  *(_BYTE *)(a2 + 2686) = sub_10040000(0, 0, (float *)(a2 + 376));
  *(_BYTE *)(a2 + 2687) = 1;
  v12 = sub_10040330();
  v13 = sub_1003FAE0(v12);
  *(float *)(a2 + 380) = v13;
  if ( sub_1001A470((char *)&v49) )
  {
    v14 = v49;
    v15 = v49;
    v16 = v49 == 0;
    *(_BYTE *)(a2 + 2688) = 1;
    if ( v16 )
    {
      *(_DWORD *)(a2 + 384) = (unsigned __int8)v50;
      v17 = v51;
      v18 = v51 < 0xEu;
      *(_BYTE *)(a2 + 2689) = 1;
      *(_BYTE *)(a2 + 2690) = 1;
      *(_DWORD *)(a2 + 388) = v17;
      if ( v18 )
        sub_1001D720(a2 + 2372, *(_BYTE **)&off_10068144[8 * v17], 20);
      else
        sub_1001D840((char *)(a2 + 2372), 0x14u, "%u", v17);
      v19 = BYTE3(v50);
      v18 = BYTE3(v50) < 0xFu;
      *(_DWORD *)(a2 + 392) = BYTE3(v50);
      if ( v18 )
        sub_1001D720(a2 + 2392, *(_BYTE **)&off_100680CC[8 * v19], 20);
      else
        sub_1001D840((char *)(a2 + 2392), 0x14u, "%u", v19);
    }
    else if ( v15 == 1 )
    {
      *(_DWORD *)(a2 + 384) = v50;
    }
    else
    {
      *(_DWORD *)(a2 + 384) = v14;
    }
  }
  if ( sub_1001A5F0(&v44) )
  {
    v20 = (double)v46;
    *(_BYTE *)(a2 + 2691) = 1;
    *(_BYTE *)(a2 + 2692) = 1;
    *(float *)(a2 + 396) = v20 * 0.00000008381903171539307;
    v13 = 0.00000008381903171539307 * (double)v45;
    *(float *)(a2 + 400) = v13;
  }
  *(_BYTE *)(a2 + 2599) = 1;
  sub_1001A6C0();
  *(float *)(a2 + 28) = v13;
  *(_BYTE *)(a2 + 2693) = sub_10015DF0((float *)(a2 + 404), (float *)&v43);
  *(_BYTE *)(a2 + 2694) = 1;
  v21 = (unsigned __int8)sub_100158E0();
  *(_DWORD *)(a2 + 408) = (unsigned __int8)v21;
  switch ( v21 )
  {
    case 0:
      sub_1001D720(a2 + 2472, "ForcNO", 20);
      break;
    case 1:
      sub_1001D720(a2 + 2472, "NoSoln", 20);
      break;
    case 2:
      sub_1001D720(a2 + 2472, "2D", 20);
      break;
    case 3:
      sub_1001D720(a2 + 2472, "3D", 20);
      break;
    case 4:
      sub_1001D720(a2 + 2472, "2DDiff", 20);
      break;
    case 5:
      sub_1001D720(a2 + 2472, "3DDiff", 20);
      break;
    case 6:
      sub_1001D720(a2 + 2472, "DRGPS", 20);
      break;
    case 7:
      sub_1001D720(a2 + 2472, "DRWAAS", 20);
      break;
    default:
      sub_1001D840((char *)(a2 + 2472), 0x14u, "%6u", v21);
      break;
  }
  sub_10015910((int)&v34);
  v22 = v35;
  v23 = v38;
  *(_BYTE *)(a2 + 2695) = v35 < 32767.0;
  v24 = v37;
  *(_BYTE *)(a2 + 2696) = v23 < 32767.0;
  v25 = v36;
  *(_BYTE *)(a2 + 2697) = v24 < 32767.0;
  v26 = v39;
  *(_BYTE *)(a2 + 2698) = v25 < 32767.0;
  if ( v26 >= 32767.0 )
    v2 = 0;
  *(float *)(a2 + 412) = v22;
  *(_BYTE *)(a2 + 2699) = v2;
  *(float *)(a2 + 416) = v23;
  *(float *)(a2 + 420) = v24;
  v27 = v26;
  *(float *)(a2 + 424) = v25;
  *(float *)(a2 + 428) = *(float *)&v27;
}
// 1000DBC0: too many cbuild loops

//----- (1000E190) --------------------------------------------------------
int sub_1000E190()
{
  unsigned int v0; // eax@6
  _DWORD *v1; // ecx@6
  _DWORD *v2; // edx@6
  int v3; // esi@10
  int v4; // eax@11
  _BYTE *v5; // ecx@11
  _BYTE *v6; // edx@11
  int v7; // eax@13
  _BYTE *v8; // ecx@13
  _BYTE *v9; // edx@13
  _BYTE *v10; // ecx@15
  _BYTE *v11; // edx@15
  int result; // eax@17

  if ( byte_101A689E != 2 )
  {
    if ( byte_101A689E == 1 )
      sub_1001D720((int)&unk_101A4450, "INVALID CARD", 16);
    else
      sub_1001D720((int)&unk_101A4450, "CONFIGURED OFF", 16);
    byte_101A4460 = 0;
  }
  v0 = 64;
  v1 = &unk_101A4450;
  v2 = &unk_101A68A8;
  do
  {
    if ( *v2 != *v1 )
      goto LABEL_10;
    v0 -= 4;
    ++v1;
    ++v2;
  }
  while ( v0 >= 4 );
  if ( !v0 )
  {
LABEL_19:
    result = 0;
    goto LABEL_20;
  }
LABEL_10:
  v3 = *(_BYTE *)v2 - *(_BYTE *)v1;
  if ( *(_BYTE *)v2 == *(_BYTE *)v1 )
  {
    v4 = v0 - 1;
    v5 = (char *)v1 + 1;
    v6 = (char *)v2 + 1;
    if ( !v4 )
      goto LABEL_19;
    v3 = *v6 - *v5;
    if ( *v6 == *v5 )
    {
      v7 = v4 - 1;
      v8 = v5 + 1;
      v9 = v6 + 1;
      if ( !v7 )
        goto LABEL_19;
      v3 = *v9 - *v8;
      if ( *v9 == *v8 )
      {
        v10 = v8 + 1;
        v11 = v9 + 1;
        if ( v7 == 1 )
          goto LABEL_19;
        v3 = *v11 - *v10;
        if ( *v11 == *v10 )
          goto LABEL_19;
      }
    }
  }
  result = 1;
  if ( v3 <= 0 )
    result = -1;
LABEL_20:
  if ( result )
  {
    qmemcpy(&unk_101A68A8, &unk_101A4450, 0x40u);
    result = sub_1003E110(9160, (int)&unk_101A68A8, 64);
  }
  return result;
}
// 101A4460: using guessed type char byte_101A4460;
// 101A689E: using guessed type char byte_101A689E;

//----- (1000E280) --------------------------------------------------------
signed int __thiscall sub_1000E280(void *this)
{
  unsigned int v1; // ebp@1
  char v2; // al@1
  const char *v3; // edi@2
  const char *v4; // esi@5
  int v5; // eax@7
  unsigned int v6; // esi@9
  int v7; // ebp@9
  _BYTE *v8; // edi@9
  int v9; // eax@11
  unsigned int v10; // edi@16
  int v11; // ebp@16
  _BYTE *v12; // esi@16
  int v13; // eax@18
  signed int result; // eax@23
  char v15; // [sp+Ch] [bp-94h]@7
  char v16; // [sp+34h] [bp-6Ch]@7
  char v17; // [sp+44h] [bp-5Ch]@7
  int v18; // [sp+64h] [bp-3Ch]@7
  int v19; // [sp+68h] [bp-38h]@7
  char v20; // [sp+84h] [bp-1Ch]@7

  v1 = 0;
  byte_101A6498 = 0;
  v2 = sub_100160D0(this);
  if ( v2 & 2 )
  {
    v3 = "CONFIG";
  }
  else
  {
    v3 = "TEST";
    if ( !(v2 & 8) )
      v3 = "NORMAL";
  }
  v4 = " SIMULATOR";
  if ( !(v2 & 4) )
    v4 = (const char *)&unk_10064984;
  sub_1000D660(&v15);
  v5 = sub_1001D840(
         &byte_101A6498,
         0x406u,
         "#airframe_info, log_version=\"1.00\", airframe_name=\"%s\", unit_software_part_number=\"%s\", unit_software_ver"
         "sion=\"%s\", system_software_part_number=\"%s\", system_id=\"%lX%08lX\", mode=%s%s, \n",
         &v15,
         &v16,
         &v17,
         &v20,
         v19,
         v18,
         v3,
         v4);
  if ( v5 > 0 )
    v1 = v5;
  sub_1000DA70(v1, &byte_101A6498, 1030);
  v6 = 0;
  byte_101A6498 = 0;
  v7 = 0;
  v8 = &unk_100681E1;
  do
  {
    if ( byte_101A68F0[v7] )
    {
      v9 = sub_1001D840(&byte_101A6498 + v6, 1030 - v6, "%*s, ", *v8, *(_DWORD *)(v8 - 9));
      if ( v9 > 0 )
        v6 += v9;
    }
    v8 += 40;
    ++v7;
  }
  while ( (signed int)v8 < (signed int)"og/log_%02d%02d%02d_%02d%02d%02d_%s.csv" );
  if ( v6 < 0x403 )
  {
    *((_BYTE *)&dword_101A6494 + v6 + 2) = 10;
    *((_BYTE *)&dword_101A6494 + v6-- + 3) = 0;
  }
  sub_1000DA70(v6, &byte_101A6498, 1030);
  v10 = 0;
  byte_101A6498 = 0;
  v11 = 0;
  v12 = &unk_100681E1;
  do
  {
    if ( byte_101A68F0[v11] )
    {
      v13 = sub_1001D840(&byte_101A6498 + v10, 1030 - v10, "%*s, ", *v12, *(_DWORD *)(v12 - 13));
      if ( v13 > 0 )
        v10 += v13;
    }
    v12 += 40;
    ++v11;
  }
  while ( (signed int)v12 < (signed int)"og/log_%02d%02d%02d_%02d%02d%02d_%s.csv" );
  if ( v10 < 0x403 )
  {
    *((_BYTE *)&dword_101A6494 + v10 + 2) = 10;
    *((_BYTE *)&dword_101A6494 + v10-- + 3) = 0;
  }
  result = sub_1000DA70(v10, &byte_101A6498, 1030);
  byte_101A6498 = 0;
  return result;
}
// 101A6494: using guessed type int dword_101A6494;

//----- (1000E450) --------------------------------------------------------
char __thiscall sub_1000E450(void *this)
{
  void *v1; // edi@1
  int v2; // ebx@1
  void *v3; // ebp@1
  void *v4; // esi@1
  int (__cdecl *v5)(void *); // eax@2
  char v6; // al@3
  bool v7; // al@8
  bool v8; // zf@9
  char v9; // al@12
  float v10; // ST58_4@13
  float v11; // ST58_4@15
  float v12; // ST58_4@15
  char v13; // al@16
  char v14; // al@18
  void *v15; // ecx@18
  _BYTE *v16; // eax@20
  float *v17; // ebp@20
  void *v18; // esi@20
  char *v19; // ebx@20
  unsigned __int8 v20; // al@24
  char *v21; // eax@26
  signed int v22; // eax@30
  char result; // al@32
  int v24; // eax@33
  int v25; // esi@33
  int v26; // ebx@33
  int v27; // [sp+18h] [bp-194h]@20
  char v28[4]; // [sp+1Ch] [bp-190h]@32
  int v29; // [sp+20h] [bp-18Ch]@12
  float v30; // [sp+24h] [bp-188h]@24
  __int16 v31; // [sp+28h] [bp-184h]@33
  unsigned __int8 v32; // [sp+2Ah] [bp-182h]@33
  unsigned __int8 v33; // [sp+2Bh] [bp-181h]@33
  unsigned int v34; // [sp+2Ch] [bp-180h]@33
  double v35; // [sp+30h] [bp-17Ch]@15
  double v36; // [sp+38h] [bp-174h]@8
  double v37; // [sp+40h] [bp-16Ch]@9
  int v38; // [sp+48h] [bp-164h]@10
  int v39; // [sp+4Ch] [bp-160h]@11
  char v40; // [sp+B0h] [bp-FCh]@10
  char v41; // [sp+114h] [bp-98h]@10
  char v42; // [sp+178h] [bp-34h]@11

  v1 = this;
  memset(this, 0, 0xA8Cu);
  v2 = 0;
  v3 = v1;
  v4 = &unk_100681F0;
  do
  {
    v5 = (int (__cdecl *)(void *))*((_DWORD *)v4 - 1);
    if ( v5 )
    {
      v6 = v5(v3);
    }
    else
    {
      if ( !*(_DWORD *)v4 )
        goto LABEL_7;
      v6 = (*(int (__cdecl **)(_DWORD, void *))v4)(*((_WORD *)v4 + 2), v3);
    }
    *((_BYTE *)v1 + v2 + 2592) = v6;
LABEL_7:
    v4 = (char *)v4 + 40;
    ++v2;
    v3 = (char *)v3 + 4;
  }
  while ( (signed int)v4 < (signed int)"%02d_%02d%02d%02d_%s.csv" );
  v7 = sub_100159B0(0, (int)&v36);
  *((_BYTE *)v1 + 2596) = v7;
  *((_BYTE *)v1 + 2597) = v7;
  if ( v7 == 1 )
  {
    v8 = dword_101A68A0 == 0x3FFFF;
    *((float *)v1 + 4) = v36;
    *((float *)v1 + 5) = v37;
    if ( v8 )
    {
      sub_1000FAB0(v2, 0, &v38, (float *)&v41, (float *)&v40);
      if ( v38 > 0 )
      {
        dword_101A68A0 = v39;
        sub_1000D810(0x30u, &v42);
      }
    }
  }
  v9 = sub_1002AC70(0, &v29);
  *((_BYTE *)v1 + 2609) = v9;
  if ( v9 )
  {
    v10 = (double)v29 * 0.000000001462918119976564;
    *((float *)v1 + 17) = sub_10041D80(v10);
  }
  if ( *((_BYTE *)v1 + 2610) )
  {
    v35 = *((float *)v1 + 18);
    v11 = v35 - sub_1003FAE0(0);
    v12 = sub_10041C10(v11);
    *((float *)v1 + 18) = v12;
    *((float *)v1 + 18) = sub_10041D80(v12);
  }
  v13 = sub_1002A840(&v29);
  *((_BYTE *)v1 + 2605) = v13;
  if ( v13 )
    *((float *)v1 + 13) = (double)v29 * 0.00000008381903171539307;
  v14 = sub_1002A850(&v29);
  *((_BYTE *)v1 + 2606) = v14;
  if ( v14 )
    *((float *)v1 + 14) = (double)v29 * 0.00000008381903171539307;
  sub_1000DBC0(v15, v1);
  v16 = (char *)v1 + 2592;
  v27 = (int)v1 + 2592;
  v17 = (float *)v1;
  v18 = &unk_100681E0;
  v19 = (char *)v1 + 432;
  do
  {
    if ( *v16 == 1 && !*v19 )
    {
      if ( 1.0 != *((float *)v18 - 1) )
      {
        v30 = *v17 * *((float *)v18 - 1);
        *(float *)&v35 = v30;
        *v17 = v30;
        v20 = *(_BYTE *)v18;
        if ( *(_BYTE *)v18 )
        {
          LODWORD(v30) = v20;
          *v17 = (double)v20 + *(float *)&v35;
        }
      }
      v21 = (char *)*((_DWORD *)v18 + 1);
      if ( v21[*((_BYTE *)v18 + 8) - 2] == 102 )
        sub_1001D840(v19, 0x14u, v21, *v17);
      else
        sub_1001D840(v19, 0x14u, v21, *(_DWORD *)v17);
    }
    v16 = (_BYTE *)(v27 + 1);
    v18 = (char *)v18 + 40;
    ++v17;
    v19 += 20;
    ++v27;
  }
  while ( (signed int)v18 < (signed int)"log/log_%02d%02d%02d_%02d%02d%02d_%s.csv" );
  v22 = sub_1003FB90();
  if ( v22 != 0x3FFFF )
  {
    *((_BYTE *)v1 + 2595) = 1;
    sub_1000FA50(v22, (char *)v1 + 492);
    *((_BYTE *)v1 + 498) = 0;
  }
  result = sub_10019F70(v28);
  *((_BYTE *)v1 + 2592) = result;
  *((_BYTE *)v1 + 2593) = result;
  *((_BYTE *)v1 + 2594) = result;
  if ( result )
  {
    v24 = sub_10015F50();
    v25 = v24;
    v26 = (char)(v24 / 3600);
    sub_1002ACA0((int *)v28, *(int *)v28);
    sub_10014C40((int)&v34, *(unsigned int *)v28);
    sub_10014E20((int)&v31, *(unsigned int *)v28);
    sub_1001D840((char *)v1 + 432, 0x14u, "%04d-%02d-%02d", HIWORD(v34), (unsigned __int8)v34, BYTE1(v34));
    sub_1001D840((char *)v1 + 452, 0x14u, "%02d:%02d:%02d", v31, v32, v33);
    result = sub_1001D840((char *)v1 + 472, 0x14u, "%+03d:%02d", v26, (unsigned __int8)abs((v25 - 3600 * v26) / 60));
    if ( (unsigned int)(*(_DWORD *)v28 - *(_DWORD *)dword_101A68E8) > 0x15180 )
      result = sub_1000D810(0x30u, &v42);
  }
  return result;
}
// 101A68A0: using guessed type int dword_101A68A0;

//----- (1000E820) --------------------------------------------------------
signed int __usercall sub_1000E820@<eax>(signed int a1@<eax>, char *a2@<ecx>)
{
  signed int v2; // ebx@1
  char *v3; // esi@1
  signed int v4; // edi@1
  signed int result; // eax@2
  signed int v6; // ecx@5
  int v7; // eax@6
  unsigned int v8; // eax@7
  void *v9; // ecx@9

  v2 = a1;
  v3 = a2;
  j_FIL_vfs_mkdir("/mnt/card0/data_log", 0);
  v4 = -15;
  if ( sub_1003E690((int)"/mnt/card0/data_log/dsbl_flight_data_log") )
  {
    result = -15;
    byte_101A689E = 1;
    return result;
  }
  if ( v2 >= 48 )
  {
    if ( byte_101A68B8 )
    {
      sub_1001D720((int)v3, &byte_101A68B8, v2);
      v6 = 206;
      goto LABEL_7;
    }
    v7 = sub_1000D810(v2, v3);
    v6 = 174;
    if ( !v7 )
    {
LABEL_7:
      v8 = j_FIL_vfs_open(v3, v6, 0);
      v4 = v8;
      if ( v8 < 0xFFFFFFC2 )
      {
        if ( v8 )
        {
          sub_1001D720((int)&byte_101A4460, v3, 48);
          sub_1000E280(v9);
        }
      }
      return v4;
    }
  }
  return v4;
}
// 1003E480: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 101A4460: using guessed type char byte_101A4460;
// 101A689E: using guessed type char byte_101A689E;
// 101A68B8: using guessed type char byte_101A68B8;

//----- (1000E8C0) --------------------------------------------------------
signed int sub_1000E8C0()
{
  unsigned int v0; // edi@1
  signed int result; // eax@4
  int v2; // ebx@8
  _BYTE *v3; // esi@8
  char *v4; // ebp@8
  int v5; // eax@10
  char v6; // [sp+4h] [bp-AB0h]@6
  char v7; // [sp+24h] [bp-A90h]@8
  char v8; // [sp+1D4h] [bp-8E0h]@8

  v0 = 0;
  byte_101A6498 = 0;
  if ( (unsigned int)dword_101A68A4 < 0xFFFFFFC2 && dword_101A68A4 )
  {
    if ( sub_1003E940((int)"/dev/sd_card0", (unsigned int)&v6) >= 0 )
    {
      byte_101A6498 = 0;
      sub_1000E450(&v7);
      v2 = 0;
      v3 = &unk_100681E1;
      v4 = &v8;
      do
      {
        if ( byte_101A68F0[v2] )
        {
          v5 = sub_1001D840(&byte_101A6498 + v0, 1030 - v0, "%*s, ", *v3, v4);
          if ( v5 > 0 )
            v0 += v5;
        }
        v3 += 40;
        ++v2;
        v4 += 20;
      }
      while ( (signed int)v3 < (signed int)"og/log_%02d%02d%02d_%02d%02d%02d_%s.csv" );
      if ( v0 < 0x403 )
      {
        *((_BYTE *)&dword_101A6494 + v0 + 2) = 10;
        *((_BYTE *)&dword_101A6494 + v0-- + 3) = 0;
      }
      result = sub_1000DA70(v0, &byte_101A6498, 1030);
    }
    else
    {
      result = sub_1001D720((int)&unk_101A4450, "NO CARD", 16);
    }
  }
  else if ( dword_101A68A4 == -27 )
  {
    result = sub_1001D720((int)&unk_101A4450, "ERROR CARD FULL", 16);
  }
  else
  {
    result = sub_1001D720((int)&unk_101A4450, "FILE ERROR", 16);
  }
  return result;
}
// 100942EC: using guessed type char *off_100942EC[7];
// 101A6494: using guessed type int dword_101A6494;
// 101A68A4: using guessed type int dword_101A68A4;

//----- (1000EA30) --------------------------------------------------------
void sub_1000EA30()
{
  int v0; // eax@5

  if ( byte_101A689E == 2 )
  {
    if ( sub_1003E660((int)"/mnt/card0") )
    {
      v0 = sub_1003DC90();
      if ( (unsigned int)(v0 - dword_101A6494) >= 0x3B6 )
      {
        dword_101A6494 = v0;
        byte_101A6498 = 0;
        if ( ((unsigned int)dword_101A68A4 >= 0xFFFFFFC2 || !dword_101A68A4) && dword_101A68A4 != -27 )
          dword_101A68A4 = sub_1000E820(48, &byte_101A6498);
        sub_1000E8C0();
      }
    }
    else
    {
      sub_1001D720((int)&unk_101A4450, "NO CARD", 16);
    }
  }
}
// 101A6494: using guessed type int dword_101A6494;
// 101A689E: using guessed type char byte_101A689E;
// 101A68A4: using guessed type int dword_101A68A4;

//----- (1000EAB0) --------------------------------------------------------
int sub_1000EAB0()
{
  int result; // eax@2
  int v1; // [sp+0h] [bp-4h]@1

  v1 = 0;
  sub_1000D980();
  sub_1003DEA0(12, 10000);
  do
  {
    result = sub_1003DF10(&v1);
    if ( v1 & 0x11 )
    {
      sub_1000EA30();
      result = sub_1000E190();
    }
  }
  while ( byte_101A689E == 2 );
  return result;
}
// 101A689E: using guessed type char byte_101A689E;

//----- (1000EB00) --------------------------------------------------------
__int16 __cdecl sub_1000EB00(int a1, int a2, int a3, int a4, void *a5, int a6, int a7, int a8, __int16 a9, __int16 a10, __int16 a11, int a12, void *a13)
{
  int v13; // ebp@1
  int v14; // ebx@1
  char *v15; // edi@3
  void *v16; // esi@3
  int v17; // esi@6
  int v18; // edi@6
  int v19; // ebx@6
  void *v20; // eax@8
  int v21; // ecx@8
  char *v22; // esi@9
  char v23; // dl@10
  char *v24; // esi@11
  char v25; // dl@12
  char *v26; // esi@13
  char v27; // dl@14
  bool v28; // zf@15
  int v29; // esi@22
  int v30; // edi@22
  char *v31; // ebp@23
  char *v32; // ecx@25
  void *v33; // eax@25
  void *v34; // ecx@28
  void *v35; // eax@29
  signed int v36; // ebp@30
  char v37; // bl@31
  unsigned __int16 *v38; // esi@31
  signed int v39; // edi@33
  unsigned int v40; // eax@39
  unsigned int v41; // ecx@41
  unsigned int v42; // eax@47
  unsigned int v43; // esi@47
  signed int v44; // eax@50
  int v45; // ecx@53
  signed int v46; // eax@53
  char *v48; // [sp+10h] [bp-94h]@2
  __int16 v49; // [sp+10h] [bp-94h]@6
  char v50; // [sp+1Bh] [bp-89h]@0
  unsigned int v51; // [sp+20h] [bp-84h]@36
  int v52; // [sp+24h] [bp-80h]@6
  int v53; // [sp+28h] [bp-7Ch]@34
  int v54; // [sp+2Ch] [bp-78h]@34
  void *v55; // [sp+30h] [bp-74h]@1
  int v56; // [sp+34h] [bp-70h]@1
  int i; // [sp+38h] [bp-6Ch]@6
  char v58; // [sp+3Ch] [bp-68h]@28

  v55 = (void *)a4;
  v56 = a12;
  memset(a5, 0, (unsigned __int16)a9 << 6);
  memset(a13, 0, 20 * (unsigned __int16)a9);
  memset(&unk_101A6960, 0, 0x1900u);
  v13 = (unsigned __int16)a9 / 100;
  v14 = 0;
  if ( v13 > 0 )
  {
    v48 = (char *)a5 + 1;
    do
    {
      sub_1003E040(v14 + a6, (int)&unk_101A6960, 6400);
      v15 = v48;
      v48 += 6400;
      v16 = &unk_101A6961;
      do
      {
        *(_DWORD *)(v15 + 31) = *(_DWORD *)((char *)v16 + 31);
        *v15 = *(_BYTE *)v16;
        *(_DWORD *)(v15 + 19) = *(_DWORD *)((char *)v16 + 19);
        v15[23] = *((_BYTE *)v16 + 23);
        *(_DWORD *)(v15 + 7) = *(_DWORD *)((char *)v16 + 7);
        *(_WORD *)(v15 + 35) = *(_WORD *)((char *)v16 + 35);
        *(_WORD *)(v15 + 1) = *(_WORD *)((char *)v16 + 1);
        *(_WORD *)(v15 + 3) = *(_WORD *)((char *)v16 + 3);
        *(_DWORD *)(v15 + 27) = *(_DWORD *)((char *)v16 + 27);
        *(v15 - 1) = *((char *)v16 - 1);
        *(_DWORD *)(v15 + 11) = *(_DWORD *)((char *)v16 + 11);
        v15[15] = *((_BYTE *)v16 + 15);
        v15[58] = *((_BYTE *)v16 + 58);
        *(_DWORD *)(v15 + 59) = *(_DWORD *)((char *)v16 + 59);
        sub_1001D720((int)(v15 + 37), (_BYTE *)v16 + 37, 21);
        v16 = (char *)v16 + 64;
        v15 += 64;
      }
      while ( (signed int)v16 < (signed int)&unk_101A8261 );
      ++v14;
    }
    while ( v14 < v13 );
  }
  v49 = 0;
  memset((void *)a2, 0, 160 * (unsigned __int16)a10);
  memset(&unk_101A8260, 0, 0x3E84u);
  v17 = (unsigned __int16)a10 / 100;
  v18 = 0;
  v19 = 0;
  v52 = 0;
  for ( i = (unsigned __int16)a10 / 100; v18 < v17; v52 = v18 )
  {
    if ( !sub_1003E040(v18 + a7, (int)&unk_101A8260, 16004) )
    {
      v20 = &unk_101A8262;
      v21 = 160 * v19 + a2 + 33;
      do
      {
        *(_WORD *)(v21 + 123) = *((_WORD *)v20 + 77);
        strcpy((char *)(v21 - 31), (const char *)v20);
        v22 = (char *)v20 + 31;
        do
        {
          v23 = *v22;
          v22[v21 - ((_DWORD)v20 + 31)] = *v22;
          ++v22;
        }
        while ( v23 );
        v24 = (char *)v20 + 82;
        do
        {
          v25 = *v24;
          v24[v21 - ((_DWORD)v20 + 82) + 51] = *v24;
          ++v24;
        }
        while ( v25 );
        v26 = (char *)v20 + 103;
        do
        {
          v27 = *v26;
          v26[v21 - ((_DWORD)v20 + 103) + 72] = *v26;
          ++v26;
        }
        while ( v27 );
        v28 = *(_BYTE *)(v21 - 31) == 0;
        *(_BYTE *)(v21 + 101) = *((_BYTE *)v20 + 132);
        *(_DWORD *)(v21 + 107) = *(_DWORD *)((char *)v20 + 138);
        *(_BYTE *)(v21 + 102) = *((_BYTE *)v20 + 133);
        *(_BYTE *)(v21 + 104) = *((_BYTE *)v20 + 135);
        *(_WORD *)(v21 + 99) = *((_WORD *)v20 + 65);
        *(_DWORD *)(v21 + 111) = *(_DWORD *)((char *)v20 + 142);
        *(_WORD *)(v21 + 105) = *((_WORD *)v20 + 68);
        *(_DWORD *)(v21 + 119) = *(_DWORD *)((char *)v20 + 150);
        *(_WORD *)(v21 - 33) = *((_WORD *)v20 - 1);
        *(_BYTE *)(v21 + 93) = *((_BYTE *)v20 + 124);
        *(_BYTE *)(v21 + 94) = *((_BYTE *)v20 + 125);
        *(_DWORD *)(v21 + 95) = *(_DWORD *)((char *)v20 + 126);
        *(_BYTE *)(v21 + 103) = *((_BYTE *)v20 + 134);
        if ( v28 )
        {
          *(_WORD *)(v21 - 33) = -1;
        }
        else if ( *(_WORD *)(v21 - 33) != -1 )
        {
          v49 = v19;
        }
        v20 = (char *)v20 + 160;
        ++v19;
        v21 += 160;
      }
      while ( (signed int)v20 < (signed int)&unk_101AC0E2 );
      v17 = i;
      v18 = v52;
    }
    ++v18;
  }
  memset(v55, 0, 8 * (unsigned __int16)a11);
  memset(&unk_101AE7F8, 0, 0x1F40u);
  v29 = (unsigned __int16)a11 / 1000;
  v30 = 0;
  if ( v29 > 0 )
  {
    v31 = (char *)v55 + 2;
    do
    {
      if ( !sub_1003E040(v30 + a8, (int)&unk_101AE7F8, 8000) )
      {
        v32 = v31;
        v33 = &unk_101AE7F8;
        v31 += 8000;
        do
        {
          v32[4] = *((_BYTE *)v33 + 6);
          *((_WORD *)v32 - 1) = *(_WORD *)v33;
          *(_WORD *)v32 = *((_WORD *)v33 + 1);
          *((_WORD *)v32 + 1) = *((_WORD *)v33 + 2);
          v33 = (char *)v33 + 8;
          v32 += 8;
        }
        while ( (signed int)v33 < (signed int)&unk_101B0738 );
      }
      ++v30;
    }
    while ( v30 < v29 );
  }
  byte_102ACCB0 = sub_1001C900(0, &v58);
  if ( !byte_102ACCB0 )
  {
    v35 = sub_1001D4B0(v34);
    sub_10014470(27, (int)v35);
    sub_100129A0("..\\lib\\adl\\mon_init_prj_log.c", 277, 0, &v58);
  }
  v36 = 0;
  if ( (signed int)(unsigned __int16)a10 > 0 )
  {
    v37 = v50;
    v38 = (unsigned __int16 *)(a2 + 138);
    do
    {
      if ( *v38 )
      {
        v39 = 0;
        do
        {
          if ( sub_1002B310(*v38, v39, &v53, &v54) )
          {
            if ( (char)v53 >= 7 )
              sub_100129A0("..\\lib\\adl\\mon_init_prj_log.c", 308, 0, 0);
            else
              v37 = sub_100136B0(v53, v54, &v51);
            if ( v37 )
            {
              v40 = v51 - 100;
              v51 -= 100;
              if ( v51 >= 0xC8 )
              {
                v41 = *(_DWORD *)(v38 - 5);
                if ( !v41 && v40 < 0x3E8 || v40 < v41 )
                  *(_DWORD *)(v38 - 5) = v40;
              }
              else
              {
                sub_1001D840(
                  &v58,
                  0x64u,
                  "CAS processing can't update discrete out %i for CAS alert %i quick enough",
                  *v38,
                  v36);
                sub_100129A0("..\\lib\\adl\\mon_init_prj_log.c", 331, 0, &v58);
              }
            }
          }
          ++v39;
        }
        while ( v39 < 3 );
      }
      ++v36;
      v38 += 80;
    }
    while ( v36 < (unsigned __int16)a10 );
  }
  v42 = j_FIL_vfs_open(v56, 4, 0);
  v43 = v42;
  if ( v42 >= 0xFFFFFFC2 )
  {
    LOWORD(v42) = v49;
    *(_WORD *)a3 = v49;
  }
  else if ( v42 )
  {
    if ( sub_1003E4B0(v42, byte_101AC0E8, 10000) == 10000 )
    {
      v45 = 0;
      v46 = 0;
      do
      {
        *(_BYTE *)(v46 + dword_102ACCC0 + 8) = byte_101AC0E8[v45];
        v46 += 12;
        ++v45;
      }
      while ( v46 < 120000 );
    }
    else
    {
      v44 = 0;
      do
      {
        *(_BYTE *)(v44 + dword_102ACCC0 + 8) = 0;
        v44 += 12;
      }
      while ( v44 < 120000 );
    }
    sub_1003E3A0(v43);
    LOWORD(v42) = a3;
    *(_WORD *)a3 = v49;
  }
  else
  {
    *(_WORD *)a3 = v49;
  }
  return v42;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 102ACCB0: using guessed type char byte_102ACCB0;
// 102ACCC0: using guessed type int dword_102ACCC0;

//----- (1000F100) --------------------------------------------------------
#error "1000F137: call analysis failed (funcsize=21)"

//----- (1000F150) --------------------------------------------------------
int __cdecl sub_1000F150(int a1)
{
  int result; // eax@1

  result = a1;
  if ( *(_DWORD *)(a1 + 4) )
  {
    ++*(_DWORD *)a1;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return result;
}

//----- (1000F170) --------------------------------------------------------
int __cdecl sub_1000F170(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  return result;
}

//----- (1000F190) --------------------------------------------------------
int __cdecl sub_1000F190(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@1

  v2 = a2 + *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 += (unsigned int)(a2 + *(_DWORD *)(a1 + 4)) >> 3;
  result = v2 & 7;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (1000F1B0) --------------------------------------------------------
void __cdecl sub_1000F1B0(int a1, char a2, signed int a3)
{
  char v3; // bl@1
  int v4; // eax@2
  int v5; // edx@5
  char v6; // cl@5
  char v7; // bl@6
  int v8; // ST04_4@6

  v3 = a2;
  while ( v3 )
  {
    v4 = *(_DWORD *)(a1 + 4);
    if ( v4 || (unsigned __int8)v3 < 8u )
    {
      v5 = *(_DWORD *)(a1 + 16);
      v6 = v3;
      if ( (unsigned int)(unsigned __int8)v3 + v4 <= 8 )
      {
        *(_BYTE *)(v5 + *(_DWORD *)a1) = *(_BYTE *)(v5 + *(_DWORD *)a1) & ~(byte_1006A497[(unsigned __int8)v3] << (8 - v3 - *(_BYTE *)(a1 + 4))) | (byte_1006A497[(unsigned __int8)v3] << (8 - v3 - *(_BYTE *)(a1 + 4))) & ((_BYTE)a3 << (8 - v3 - *(_BYTE *)(a1 + 4)));
        sub_1000F190(a1, (unsigned __int8)v3);
        return;
      }
      v7 = 8 - *(_BYTE *)(a1 + 4);
      v8 = (unsigned __int8)(8 - *(_BYTE *)(a1 + 4));
      *(_BYTE *)(v5 + *(_DWORD *)a1) = *(_BYTE *)(v5 + *(_DWORD *)a1) & ~byte_1006A497[v8] | byte_1006A497[v8] & (a3 >> (v6 - (8 - *(_BYTE *)(a1 + 4))));
      sub_1000F190(a1, v8);
      a2 -= v7;
      v3 = a2;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 16) + *(_DWORD *)a1) = a3 >> (v3 - 8);
      sub_1000F190(a1, 8);
      v3 -= 8;
      a2 = v3;
    }
  }
}

//----- (1000F290) --------------------------------------------------------
void __cdecl sub_1000F290(int a1, unsigned int a2, signed int *a3, signed int *a4)
{
  double v4; // st7@1
  float v5; // ST28_4@10
  float v6; // ST14_4@10
  float v7; // ST28_4@10
  float v8; // ST20_4@10
  float v9; // ST28_4@10
  float v10; // ST10_4@10
  float v11; // ST24_4@10
  float v12; // ST1C_4@10
  float v13; // ST28_4@10
  float v14; // ST2C_4@10
  float v15; // ST2C_4@10
  long double v16; // ST3C_8@10
  float v17; // ST2C_4@10
  float v18; // ST2C_4@10
  float v19; // ST2C_4@10
  float v20; // ST2C_4@10
  float v21; // ST14_4@10
  float v22; // ST10_4@10
  float v23; // ST10_4@10
  long double v24; // ST3C_8@10
  float v25; // ST10_4@10
  long double v26; // st7@10
  float v27; // ST28_4@12
  float v28; // ST38_4@12
  float v29; // ST38_4@12
  double v30; // st7@12
  double v31; // st6@12
  float v32; // ST38_4@12
  double v33; // st4@12
  signed int v34; // eax@12
  signed int v35; // esi@12
  float v36; // ST38_4@12
  signed int v37; // ecx@12
  float v38; // [sp+14h] [bp-3Ch]@1
  float v39; // [sp+28h] [bp-28h]@10
  float v40; // [sp+34h] [bp-1Ch]@1
  long double v41; // [sp+40h] [bp-10h]@1
  double v42; // [sp+48h] [bp-8h]@1

  sub_10015700((int)&v41, *(_DWORD *)a1, *(_DWORD *)(a1 + 4));
  v38 = v41;
  v40 = v42;
  v4 = v38;
  if ( (LODWORD(v38) & 0x7F800000) != 2139095040 && v4 <= 1.570796370506287 && v4 >= -1.570796370506287 )
  {
    if ( (LODWORD(v38) & 0x7F800000) == 2139095040 || v4 > 1.558579 )
    {
      v38 = 1.558579;
    }
    else if ( v4 < -1.558579 )
    {
      v38 = -1.558579;
    }
    v5 = (double)(a2 / 0x15180) - 3653.5;
    v6 = v5 / 36525.0;
    v7 = v6 * (0.0003032000095117837 * v6 + 36000.76953125) + 280.4664611816406;
    v8 = sub_10041B70(v7, 360.0) * 0.01745329238474369;
    v9 = (35999.05078125 - 0.0001537000061944127 * v6) * v6 + 357.5291137695312;
    v10 = 0.01745329238474369 * v9;
    v11 = 0.01670863479375839 - v6 * (0.0000001267000016014208 * v6 + 0.00004203700154903345);
    v12 = sin(v10);
    v13 = sin(v10 + v10);
    v41 = (125.0400009155273 - v6 * 1934.135986328125) * 0.01745329251994333;
    v14 = ((21.44799995422363 - v6 * ((0.000590000010561198 - 0.001812999951653183 * v6) * v6 + 46.81499862670898))
         / 60.0
         + 26.0)
        / 60.0
        + 23.0;
    v15 = cos(v41) * 0.00255999993532896 + v14;
    v16 = v15 * 0.01745329251994333;
    v17 = sin(v10 * 3.0);
    v18 = v17 * 0.0002889999886974692
        + (1.914602041244507 - (0.00001400000019202707 * v6 + 0.00481700012460351) * v6) * v12
        + (0.01999299973249435 - v6 * 0.0001009999978123233) * v13;
    v19 = v18 + v8 * 57.29577951308219;
    v20 = (v19 - 0.005690000019967556 - sin(v41) * 0.004780000075697899) * 0.01745329251994333;
    v41 = sin(v20);
    v21 = asin(sin(v16) * v41);
    v22 = tan(v16 * 0.5);
    v23 = v22 * v22;
    v41 = v8 + v8;
    v41 = sin(v41) * v23 - (v11 + v11) * v12 + cos(v41) * (v11 * 4.0 * v23 * v12);
    v39 = (v41 - sin(v8 * 4.0) * (v23 * (0.5 * v23)) - v11 * (1.25 * v11) * v13) * 57.29577951308219 * 4.0;
    v41 = cos(v21);
    v24 = cos(1.585334922659806) / (cos(v38) * v41);
    v41 = tan(v21);
    v25 = v24 - tan(v38) * v41;
    v26 = v25;
    if ( v25 <= -1.0 || v26 > 1.0 )
    {
      *a3 = 0x7FFFFFFF;
      *a4 = 0x7FFFFFFF;
    }
    else
    {
      v27 = acos(v26) * 57.29577951308219;
      v28 = 720.0 - 57.29577951308219 * v40 * 4.0 - v39;
      v29 = v28 / 1440.0;
      v30 = v27 / 360.0;
      v31 = v29;
      v32 = v29 - v30;
      v33 = v32 * 86400.0;
      v34 = (signed int)v33;
      v35 = (signed int)v33;
      v36 = v30 + v31;
      v37 = (signed int)(86400.0 * v36);
      if ( (signed int)v33 >= 0 )
      {
        if ( v34 >= 86400 )
          v35 += 86400
               * (((signed int)(((unsigned __int64)(1037155065i64 * v34) >> 32) - v34) >> 16)
                + ((unsigned int)(((unsigned __int64)(1037155065i64 * v34) >> 32) - v34) >> 31));
      }
      else
      {
        v35 += 86400 - 86400 * (v34 / 86400);
      }
      if ( v37 >= 0 )
      {
        if ( v37 >= 86400 )
          v37 += 86400
               * (((signed int)(((unsigned __int64)(1037155065i64 * v37) >> 32) - v37) >> 16)
                + ((unsigned int)(((unsigned __int64)(1037155065i64 * v37) >> 32) - v37) >> 31));
        *a3 = v35;
        *a4 = v37;
      }
      else
      {
        *a3 = v35;
        *a4 = 86400 - 86400 * (v37 / 86400) + v37;
      }
    }
  }
  else
  {
    *a3 = 0x7FFFFFFF;
    *a4 = 0x7FFFFFFF;
  }
}

//----- (1000F7D0) --------------------------------------------------------
void __cdecl sub_1000F7D0(unsigned int a1, int a2)
{
  __int64 v2; // [sp-4h] [bp-24h]@0
  int v3; // [sp+8h] [bp-18h]@10
  char v4[4]; // [sp+Ch] [bp-14h]@10
  char v5; // [sp+10h] [bp-10h]@10

  if ( a1 >= 0x3E8 )
  {
    switch ( a1 )
    {
      case 0x3FFFFu:
        *(_DWORD *)a2 = 1600085855;
        *(_WORD *)(a2 + 4) = 24415;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      case 0x3FFFEu:
        *(_DWORD *)a2 = 1801678668;
        *(_WORD *)(a2 + 4) = 25701;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      case 0x3FFFDu:
        *(_DWORD *)a2 = 1330654800;
        *(_WORD *)(a2 + 4) = 83;
        *(_BYTE *)(a2 + 6) = 0;
        break;
      default:
        LODWORD(v2) = a1;
        if ( sub_10010610(v2) == 11 )
        {
          sub_100105F0(a1, &v3, v4);
          sub_10010270(v3, v4[0], &v5);
          sub_1001D720(a2, &v5, 7);
        }
        else
        {
          sub_1000FE40(a1, a2);
        }
        break;
    }
  }
  else
  {
    sub_10010780(a1, a2);
  }
}

//----- (1000F920) --------------------------------------------------------
double *__cdecl sub_1000F920(char a1, char a2, double *a3)
{
  unsigned int v3; // esi@1
  double *result; // eax@10
  __int64 v5; // [sp-4h] [bp-60h]@0
  int v6; // [sp+4h] [bp-58h]@7
  char v7; // [sp+8h] [bp-54h]@10
  double v8; // [sp+10h] [bp-4Ch]@3
  double v9; // [sp+18h] [bp-44h]@10
  char v10; // [sp+20h] [bp-3Ch]@10

  v3 = a2;
  if ( a2 == 0x3FFFF )
    goto LABEL_11;
  if ( (unsigned int)a2 >= 0x3E8 )
  {
    if ( a2 == 262141 )
    {
      sub_100159B0(a1, (int)&v8);
      goto LABEL_13;
    }
    LODWORD(v5) = a2;
    if ( sub_10010610(v5) != 11 )
    {
      sub_10010060(v3, (int)&v8);
      goto LABEL_13;
    }
    sub_100105F0(v3, &v6, &a2);
    if ( (_BYTE)v6 != -1 && a2 != -1 && sub_10010880(v6, a2) == v3 )
    {
      sub_100101F0(v6, a2, &v10);
      sub_10010180((int)&v10, (int)&v7);
      sub_10041D00((int)&v7, (int)&v8);
      result = a3;
      *a3 = v8;
      result[1] = v9;
      return result;
    }
LABEL_11:
    result = a3;
    v8 = 6.2831853071796;
    v9 = 6.2831853071796;
    *a3 = 6.2831853071796;
    result[1] = v9;
    return result;
  }
  sub_10010810(a2, (int)&v8);
LABEL_13:
  result = a3;
  *a3 = v8;
  result[1] = v9;
  return result;
}

//----- (1000FA50) --------------------------------------------------------
void __cdecl sub_1000FA50(unsigned int a1, char *a2)
{
  __int64 v2; // [sp-4h] [bp-10h]@0
  char v3[4]; // [sp+4h] [bp-8h]@2
  int v4; // [sp+8h] [bp-4h]@2

  LODWORD(v2) = a1;
  if ( sub_10010610(v2) == 11 )
  {
    sub_100105F0(a1, &v4, v3);
    sub_10010270(v4, v3[0], a2);
  }
  else
  {
    sub_1000F7D0(a1, (int)a2);
  }
}

//----- (1000FAB0) --------------------------------------------------------
void __usercall sub_1000FAB0(int ebx0@<ebx>, unsigned __int8 a1, int *a2, float *a3, float *a4)
{
  int v5; // ST1C_4@2
  char v6; // bl@2
  char v7; // al@2
  signed int v8; // ecx@5
  signed int v9; // eax@5
  bool v10; // zf@5
  bool v11; // sf@5
  int *v12; // edx@6
  int v13; // esi@8
  int v14; // ebx@9
  float *v15; // esi@10
  int *v16; // edi@10
  int v17; // eax@11
  int v18; // ecx@14
  int v19; // esi@15
  float *v20; // eax@16
  int *v21; // edx@16
  int v22; // ecx@16
  float *v23; // eax@19
  int *v24; // ebp@19
  signed int v25; // edx@19
  char v26; // [sp+8h] [bp-A0h]@11
  char v27; // [sp+18h] [bp-90h]@9
  __int16 v28; // [sp+28h] [bp-80h]@5
  int v29[31]; // [sp+2Ch] [bp-7Ch]@5

  if ( a2 )
  {
    v5 = ebx0;
    v6 = sub_100158E0();
    sub_1002B7F0(v5);
    if ( v7 && v6 != 1 && v6 )
    {
      sub_1003DDA0(100, 60000);
      qmemcpy(&v28, (const void *)((a1 << 7) + dword_102AD570 + 248), 0x80u);
      sub_1003DD40(100);
      sub_10010C80(v28, (char *)v29);
      v8 = v28;
      v9 = 0;
      v10 = v28 == 0;
      v11 = v28 < 0;
      *a2 = 0;
      if ( !v11 && !v10 )
      {
        v12 = a2 + 1;
        do
        {
          if ( v9 >= 25 )
            break;
          v13 = v29[v9];
          ++*a2;
          *v12 = v13;
          ++v9;
          ++v12;
        }
        while ( v9 < v8 );
      }
      sub_10041D00(dword_102AD570 + 1144, (int)&v27);
      v14 = 0;
      if ( *a2 > 0 )
      {
        v15 = a3;
        v16 = a2 + 1;
        do
        {
          sub_1000F920(0, *v16, (double *)&v26);
          LOBYTE(v17) = sub_10040330();
          sub_1003D9E0((int)&v27, (int)&v26, v17, v15, (int)v15 + (char *)a4 - (char *)a3);
          ++v14;
          ++v16;
          ++v15;
        }
        while ( v14 < *a2 );
        if ( *a2 > 0 )
        {
          do
          {
            if ( a3[*a2 - 1] <= 370380.97 )
              break;
            v18 = *a2 - 1;
            *a2 = v18;
          }
          while ( v18 > 0 );
        }
      }
      v19 = *a2;
      if ( *a2 < 25 )
      {
        v20 = &a4[v19];
        v21 = &a2[v19 + 1];
        v22 = 25 - v19;
        do
        {
          *v21 = 0x3FFFF;
          *(float *)((char *)v20 + (char *)a3 - (char *)a4) = 9.9999996e24;
          *v20 = 9.9999996e24;
          ++v21;
          ++v20;
          --v22;
        }
        while ( v22 );
      }
    }
    else
    {
      v23 = a4;
      *a2 = 0;
      v24 = a2 + 1;
      v25 = 25;
      do
      {
        *v24 = 0x3FFFF;
        *(float *)((char *)v23 + (char *)a3 - (char *)a4) = 9.9999996e24;
        *v23 = 9.9999996e24;
        ++v24;
        ++v23;
        --v25;
      }
      while ( v25 );
    }
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\prx\\prx_intf.c", 515, 0, 0);
  }
}
// 1000FAB0: could not find valid save-restore pair for ebx
// 1003DD40: using guessed type double __cdecl sub_1003DD40(_DWORD);
// 102AD570: using guessed type int dword_102AD570;
// 1000FAB0: using guessed type int var_7C[31];

//----- (1000FCD0) --------------------------------------------------------
void sub_1000FCD0()
{
  dword_102ACCEC = -15;
}
// 102ACCEC: using guessed type int dword_102ACCEC;

//----- (1000FCE0) --------------------------------------------------------
signed int sub_1000FCE0()
{
  return sub_1003ED70((int)&off_1006ABC4);
}
// 1006ABC4: using guessed type char *off_1006ABC4;

//----- (1000FCF0) --------------------------------------------------------
char __cdecl sub_1000FCF0(unsigned __int8 a1, int a2, char a3, int a4)
{
  char result; // al@2

  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, int))dword_102ACCE0)(
                          a2 + dword_1006B7E0[3 * a1] - 3,
                          4,
                          a4) )
  {
    *(_BYTE *)(a4 + 4) = a3;
    *(_BYTE *)a4 &= byte_1006ABD8[5 * a1];
    *(_BYTE *)(a4 + 1) &= byte_1006ABD9[5 * a1];
    *(_BYTE *)(a4 + 2) &= byte_1006ABDA[5 * a1];
    *(_BYTE *)(a4 + 3) &= byte_1006ABDB[5 * a1];
    *(_BYTE *)(a4 + 4) &= byte_1006ABDC[5 * a1];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1006B7E0: using guessed type int dword_1006B7E0[];
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (1000FD70) --------------------------------------------------------
char __usercall sub_1000FD70@<al>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // edi@1
  unsigned int v3; // edi@2
  char v4; // dl@2
  signed int v5; // eax@2
  char result; // al@6
  __int16 v7; // [sp+Ch] [bp-1ECh]@1
  char v8[490]; // [sp+Eh] [bp-1EAh]@3

  v2 = a1;
  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, __int16 *))dword_102ACCE0)(
                          dword_102ACD00[3 * (unsigned __int8)byte_1006B7D8[12 * a2]],
                          492,
                          &v7) )
  {
    v3 = v2 - *(_DWORD *)(dword_102AD550 + 4 * a2 + 20812);
    v4 = 0;
    v5 = 163;
    do
    {
      if ( *(unsigned __int16 *)((char *)&v7 + 3 * v5) + ((v8[3 * v5] & 3u) << 16) <= v3 )
      {
        v4 = v5;
        v5 = 0;
      }
      --v5;
    }
    while ( v5 >= 0 );
    result = v4 + 4;
  }
  else
  {
    result = -92;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102ACD00: using guessed type int dword_102ACD00[];
// 102AD550: using guessed type int dword_102AD550;
// 1000FD70: using guessed type char var_1EA[490];

//----- (1000FE10) --------------------------------------------------------
int __fastcall sub_1000FE10(int a1, int a2)
{
  int result; // eax@1

  result = ((*(_WORD *)a1 << 9) + (*(_WORD *)(a1 + 5) & 0x1FF)) << 7;
  *(_DWORD *)a2 = (*(_BYTE *)(a1 + 4) + (*(_WORD *)(a1 + 2) << 8)) << 7;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (1000FE40) --------------------------------------------------------
void __cdecl sub_1000FE40(unsigned int a1, int a2)
{
  unsigned __int8 v2; // bl@4
  int v3; // ebp@4
  char v4; // ST34_1@4
  char v5; // [sp+Ch] [bp-Ch]@4
  char v6; // [sp+10h] [bp-8h]@5

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_102AD550 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        sub_10011C60(a1, a2);
      else
        sub_10011570(a1, a2);
    }
    else
    {
      v2 = sub_10011AE0(a1);
      v3 = sub_10011B10(a1, v2, 1);
      v4 = sub_1000FD70(a1, v2);
      if ( sub_1000FCF0(v2, v3, v4, (int)&v5) )
      {
        sub_10010550(&v6, 6, a2);
        sub_1001D8B0(a2, 6);
      }
      else
      {
        *(_DWORD *)a2 = 1600085855;
        *(_WORD *)(a2 + 4) = 24415;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = 1600085855;
    *(_WORD *)(a2 + 4) = 24415;
    *(_BYTE *)(a2 + 6) = 0;
  }
}
// 102AD550: using guessed type int dword_102AD550;

//----- (1000FF80) --------------------------------------------------------
char __cdecl sub_1000FF80(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // al@4
  unsigned int v4; // eax@4
  char v5; // [sp+4h] [bp-8h]@4

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_102AD550 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        result = sub_10011E40(a1, a2);
      else
        result = sub_10011770(a1, a2);
    }
    else
    {
      v3 = sub_10011AE0(a1);
      v4 = sub_10011B10(a1, v3, 1);
      (*(void (__cdecl **)(unsigned int, signed int, char *))dword_102ACCE0)(v4, 7, &v5);
      result = sub_1000FE10((int)&v5, a2);
    }
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD550: using guessed type int dword_102AD550;

//----- (10010030) --------------------------------------------------------
void __usercall sub_10010030(int a1@<ecx>, int a2@<esi>)
{
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  sub_1000FE10(a1, (int)&v2);
  *(double *)a2 = sub_1002BAF0(v2, 24);
  *(double *)(a2 + 8) = sub_1002BAF0(v3, 24);
}

//----- (10010060) --------------------------------------------------------
char __cdecl sub_10010060(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // bl@4
  unsigned int v4; // eax@4
  unsigned int v5; // ebx@7
  char v6; // bl@13
  int v7; // [sp+4h] [bp-20h]@4
  int v8; // [sp+8h] [bp-1Ch]@10
  unsigned __int8 v9; // [sp+Ch] [bp-18h]@9
  unsigned int v10; // [sp+Eh] [bp-16h]@7
  unsigned int v11; // [sp+14h] [bp-10h]@8

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_102AD550 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
      {
        v6 = sub_10011E40(a1, (int)&v7);
        if ( v6 )
        {
          sub_10015700(a2, v7, v8);
          result = v6;
        }
        else
        {
          *(double *)a2 = 6.2831853071796;
          *(double *)(a2 + 8) = 6.2831853071796;
          result = 0;
        }
      }
      else
      {
        result = sub_10011700(a1, a2);
      }
    }
    else
    {
      v3 = sub_10011AE0(a1);
      v4 = sub_10011B10(a1, v3, 1);
      (*(void (__cdecl **)(unsigned int, signed int, int *))dword_102ACCE0)(v4, 32, &v7);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          LOBYTE(v5) = v9 >> 1;
        }
        else if ( v3 == 2 )
        {
          v5 = v11 >> 14;
        }
        else
        {
          v5 = v10 >> 23;
        }
      }
      else
      {
        v5 = (unsigned int)v8 >> 29;
      }
      sub_10010030((int)&v7, a2);
      result = v5 & 1;
    }
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
    result = 0;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD550: using guessed type int dword_102AD550;

//----- (10010180) --------------------------------------------------------
int __cdecl sub_10010180(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(float *)a2 = 6.2831855;
  *(float *)(a2 + 4) = 6.2831855;
  switch ( *(_BYTE *)a1 )
  {
    case 1:
    case 4:
    case 0x12:
    case 0x14:
    case 0x15:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 48);
      break;
    case 2:
    case 5:
    case 0x13:
    case 0x16:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 56);
      break;
    default:
      return result;
  }
  return result;
}

//----- (100101F0) --------------------------------------------------------
int __cdecl sub_100101F0(int a1, char a2, void *a3)
{
  int v3; // eax@1
  int result; // eax@3

  sub_1003DDA0(54, 60000);
  v3 = sub_10010CC0(a1);
  if ( v3 && (unsigned __int8)a2 < *(_BYTE *)(v3 + 1) )
  {
    qmemcpy(a3, (const void *)(84 * (unsigned __int8)a2 + v3 + 148), 0x3Cu);
    result = sub_1003DD40(54);
  }
  else
  {
    memset(a3, 0, 0x3Cu);
    *(_BYTE *)a3 = 24;
    *((_BYTE *)a3 + 1) = 0;
    *((_BYTE *)a3 + 4) = 0;
    *((_BYTE *)a3 + 6) = 0;
    *((_BYTE *)a3 + 7) = 4;
    result = sub_1003DD40(54);
  }
  return result;
}

//----- (10010270) --------------------------------------------------------
char __cdecl sub_10010270(int a1, char a2, char *a3)
{
  char result; // al@2
  int v4; // ebx@6
  unsigned int v5; // esi@8
  float v6; // edi@10
  unsigned int v7; // esi@10
  double v8; // ST28_8@10
  int v9; // eax@10
  int v10; // edi@13
  float v11; // [sp+1Ch] [bp-44h]@6
  float v12; // [sp+1Ch] [bp-44h]@13
  char v13; // [sp+24h] [bp-3Ch]@1
  float v14; // [sp+30h] [bp-30h]@5
  int v15; // [sp+48h] [bp-18h]@1
  float v16; // [sp+50h] [bp-10h]@6
  float v17; // [sp+54h] [bp-Ch]@6

  sub_100101F0(a1, a2, &v13);
  if ( v15 == 262142 )
  {
    result = sub_1001D720((int)a3, "Locked", 12);
  }
  else
  {
    switch ( v13 )
    {
      case 0:
        result = sub_1001D720((int)a3, "DME ARC", 12);
        break;
      case 1:
      case 7:
      case 0x12:
        sub_1001D840(a3, 0xCu, "%d", (signed int)(v14 * 3.280839895013123 + 0.5));
        result = sub_1001D870(a3, &unk_1006B1B8, 12);
        break;
      case 2:
      case 9:
      case 0x13:
        v11 = v17 * 0.0005399568034557236;
        sub_1000F7D0(LODWORD(v16), (int)a3);
        v4 = 3;
        if ( v11 >= 9.9499998 )
          v4 = 4;
        v5 = strlen(a3);
        result = sub_1001D540(v11, v4, 1, (int)&a3[v5]);
        *(&a3[v4] + v5) = 0;
        break;
      case 4:
      case 0x14:
        result = sub_1001D720((int)a3, "INTRCPT ", 12);
        break;
      case 5:
      case 0x16:
        v6 = v16;
        sub_1000F7D0(LODWORD(v16), (int)a3);
        v7 = strlen(a3);
        v8 = v17;
        *(float *)&v8 = v8 - sub_10010640(v6);
        *(float *)&v8 = sub_10041C10(*(float *)&v8);
        v9 = sub_10041D20(*(float *)&v8);
        if ( !v9 )
          v9 = 360;
        result = sub_1001D840(&a3[v7], 12 - v7, "%03i", v9);
        break;
      case 8:
        v10 = 3;
        v12 = v16 * 0.0005399568034557236;
        if ( v12 >= 9.9499998 )
          v10 = 4;
        *a3 = 68;
        result = sub_1001D540(v12, v10, 1, (int)(a3 + 1));
        a3[v10 + 1] = 0;
        break;
      case 0xA:
      case 0x15:
        result = sub_1001D720((int)a3, "MANSEQ", 12);
        break;
      case 0xF:
        result = sub_1001D720((int)a3, "PROC. TURN", 12);
        break;
      case 0xB:
      case 0xC:
      case 0xD:
        result = sub_1001D720((int)a3, "HOLD", 12);
        break;
      case 0x10:
        result = sub_1001D720((int)a3, &unk_1006B144, 12);
        break;
      default:
        result = (char)a3;
        *a3 = 0;
        break;
    }
  }
  return result;
}

//----- (10010550) --------------------------------------------------------
void __cdecl sub_10010550(_BYTE *a1, signed int a2, int a3)
{
  signed int v3; // esi@1
  _BYTE *v4; // ecx@2
  unsigned int v5; // edx@2
  unsigned int v6; // eax@6
  unsigned __int16 v7; // ax@7
  char v8; // al@10

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = a1;
    v5 = a2;
    do
    {
      if ( v3 & 3 )
      {
        if ( (v3 & 3) == 1 )
        {
          v6 = v5 >> 4;
        }
        else
        {
          --v4;
          if ( (v3 & 3) == 2 )
          {
            HIBYTE(v7) = v4[1];
            LOBYTE(v7) = *v4;
            v5 = v7;
            v6 = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(v6) = v5;
          }
        }
      }
      else
      {
        BYTE1(v5) = *v4--;
        LOBYTE(v5) = *v4;
        v5 = (unsigned __int16)v5;
        LOWORD(v6) = (unsigned __int16)v5 >> 10;
      }
      v8 = v6 & 0x3F;
      if ( v8 )
      {
        if ( (unsigned __int8)(v8 - 1) > 0x19u )
        {
          if ( (unsigned __int8)(v8 - 32) <= 9u )
            v8 += 16;
        }
        else
        {
          v8 += 64;
        }
        *(_BYTE *)(v3 + a3) = v8;
      }
      else
      {
        *(_BYTE *)(v3 + a3) = 32;
      }
      ++v3;
    }
    while ( v3 < a2 );
  }
}

//----- (100105F0) --------------------------------------------------------
unsigned int __cdecl sub_100105F0(unsigned int a1, _BYTE *a2, _BYTE *a3)
{
  unsigned int result; // eax@1

  *a2 = a1;
  result = a1 >> 8;
  *a3 = BYTE1(a1);
  return result;
}

//----- (10010610) --------------------------------------------------------
char __cdecl sub_10010610(__int64 a1)
{
  char result; // al@5

  if ( (unsigned int)a1 < 0x3E8 || (_DWORD)a1 == 262141 )
  {
    result = 4;
  }
  else if ( (_DWORD)a1 == 0x3FFFF || (_DWORD)a1 == 262142 )
  {
    result = 9;
  }
  else
  {
    result = sub_10011BC0(a1);
  }
  return result;
}

//----- (10010640) --------------------------------------------------------
double __cdecl sub_10010640(float a1)
{
  unsigned int v1; // esi@1
  char v2; // al@1
  char v3; // al@2
  double result; // st7@2
  __int64 v5; // [sp-4h] [bp-20h]@0
  char v6; // [sp+4h] [bp-18h]@9
  char v7; // [sp+Ch] [bp-10h]@9

  v1 = LODWORD(a1);
  *(float *)&v5 = a1;
  v2 = sub_10010610(v5);
  if ( v1 == 262141 )
  {
    v3 = sub_10040330();
    a1 = sub_1003FAE0(v3);
    result = a1;
  }
  else
  {
    switch ( v2 )
    {
      case 9:
        a1 = 6.2831855;
        result = (float)6.2831855;
        break;
      case 8:
        a1 = sub_10011500(v1);
        result = a1;
        break;
      case 3:
        a1 = sub_10012230(v1);
        result = a1;
        break;
      default:
        sub_1000F920(0, v1, (double *)&v7);
        sub_10041C50((int)&v7, (int)&v6);
        sub_10012210((int)&v6, &a1);
        result = a1;
        break;
    }
  }
  return result;
}

//----- (10010700) --------------------------------------------------------
char __usercall sub_10010700@<al>(unsigned __int16 a1@<ax>, void *a2)
{
  unsigned __int16 v2; // si@1
  char result; // al@4

  v2 = a1;
  if ( (unsigned __int8)sub_1000FCE0() && v2 < 0x3E8u && *(_WORD *)(dword_102ACCEC + 56 * v2 + 880428) == v2 )
  {
    qmemcpy(a2, (const void *)(dword_102ACCEC + 56 * (v2 + 15721)), 0x38u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102ACCEC: using guessed type int dword_102ACCEC;

//----- (10010760) --------------------------------------------------------
int __usercall sub_10010760@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(double *)result = (double)*(signed int *)a2 * 0.000000001462918079267163;
  *(double *)(result + 8) = 0.000000001462918079267163 * (double)*(signed int *)(a2 + 4);
  return result;
}

//----- (10010780) --------------------------------------------------------
int __cdecl sub_10010780(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+8h] [bp-38h]@3

  sub_1003DDA0(58, 60000);
  if ( sub_10010700(a1, &v3) )
  {
    sub_10010550(&v4, 6, a2);
    sub_1001D8B0(a2, 6);
  }
  else
  {
    *(_DWORD *)a2 = 1600085855;
    *(_WORD *)(a2 + 4) = 24415;
    *(_BYTE *)(a2 + 6) = 0;
  }
  return sub_1003DD40(58);
}

//----- (10010810) --------------------------------------------------------
int __cdecl sub_10010810(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+Ch] [bp-34h]@3

  sub_1003DDA0(58, 60000);
  if ( sub_10010700(a1, &v3) )
  {
    sub_10010760(a2, (int)&v4);
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
  }
  return sub_1003DD40(58);
}

//----- (10010880) --------------------------------------------------------
signed int __cdecl sub_10010880(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  sub_1003DDA0(54, 60000);
  v2 = 0x3FFFF;
  v3 = sub_10010CC0(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_1002BAD0(84 * a2 + v3 + 148);
  sub_1003DD40(54);
  return v2;
}

//----- (100108E0) --------------------------------------------------------
double sub_100108E0()
{
  double result; // st7@1
  char v1; // al@1
  int v2; // esi@2
  int v3; // edi@2

  result = sub_1002B7F0(6.283185);
  if ( v1 )
  {
    sub_1003DDA0(100, 60000);
    v2 = *(_DWORD *)(dword_102AD570 + 1144);
    v3 = *(_DWORD *)(dword_102AD570 + 1148);
    result = sub_1003DD40(100);
  }
  return result;
}
// 1003DD40: using guessed type double __cdecl sub_1003DD40(_DWORD);
// 102AD570: using guessed type int dword_102AD570;

//----- (10010940) --------------------------------------------------------
void __cdecl sub_10010940(unsigned int a1, char *a2, float *a3, int a4, char a5)
{
  int v5; // eax@1
  int v6; // edx@1
  unsigned int v7; // eax@2
  float *v8; // edi@2
  int v9; // ebp@2
  char *v10; // ecx@3
  int v11; // ebx@3
  float *v12; // esi@3
  int v13; // ebx@6
  char v14; // bl@10
  unsigned int v15; // eax@10
  int v16; // eax@11
  float *v17; // ecx@11
  int v18; // edx@11
  char *v19; // edi@11
  char *v20; // esi@11
  unsigned int v21; // ebp@11
  int v22; // ST30_4@13
  float v23; // ST30_4@13
  float v24; // ST30_4@13
  int v25; // ST30_4@15
  float v26; // ST30_4@15
  float v27; // ST30_4@15
  int v28; // ST30_4@17
  float v29; // ST30_4@17
  float v30; // ST30_4@17
  int v31; // ST30_4@19
  float v32; // ST30_4@19
  float v33; // ST30_4@19
  float *v34; // edx@23
  int v35; // ecx@23
  int v36; // ST30_4@25
  float v37; // ST30_4@25
  float v38; // ST30_4@25
  unsigned int v39; // [sp+8h] [bp-38h]@9
  int v40; // [sp+Ch] [bp-34h]@23
  unsigned int v41; // [sp+10h] [bp-30h]@11
  char *v42; // [sp+10h] [bp-30h]@23
  unsigned int v43; // [sp+14h] [bp-2Ch]@3
  char *v44; // [sp+14h] [bp-2Ch]@11
  char *v45; // [sp+14h] [bp-2Ch]@23
  int v46; // [sp+18h] [bp-28h]@1
  int v47; // [sp+1Ch] [bp-24h]@1
  char v48; // [sp+20h] [bp-20h]@6
  char v49; // [sp+30h] [bp-10h]@2

  sub_100108E0();
  v46 = v5;
  v47 = v6;
  if ( sub_1002C210((int)&v46, (int)&unk_1006B248) )
  {
    sub_10041D00((int)&v46, (int)&v49);
    v7 = a1;
    v8 = a3;
    v9 = a4;
    if ( a1 )
    {
      v10 = &a2[-a4];
      v11 = a4 - (_DWORD)a3;
      v12 = a3;
      v43 = a1;
      do
      {
        if ( !a5 || *v12 >= 9.8999998e24 )
        {
          v13 = (int)v12 + v11;
          sub_1000F920(0, *(_DWORD *)&v10[v13], (double *)&v48);
          sub_1003D9E0((int)&v49, (int)&v48, 1, v12, v13);
          v10 = &a2[-a4];
          v11 = a4 - (_DWORD)a3;
        }
        ++v12;
        --v43;
      }
      while ( v43 );
      v7 = a1;
    }
    v39 = v7;
    do
    {
      v14 = 0;
      v15 = 1;
      if ( (signed int)(v39 - 1) >= 4 )
      {
        v44 = (char *)(a2 - (char *)v8);
        v16 = v9 - (_DWORD)v8;
        v17 = v8;
        v18 = v9 + 8;
        v19 = &a2[-v9];
        v20 = a2 + 12;
        v21 = ((v39 - 5) >> 2) + 1;
        v41 = v21;
        v46 = 4 * v21 + 1;
        do
        {
          if ( *v17 > (double)v17[1] )
          {
            v22 = *(_DWORD *)((char *)v17 + (_DWORD)v44);
            *(float *)((char *)v17 + (_DWORD)v44) = *((float *)v20 - 2);
            v21 = v41;
            *((_DWORD *)v20 - 2) = v22;
            v23 = *v17;
            v14 = 1;
            *v17 = v17[1];
            v17[1] = v23;
            v24 = *(float *)((char *)v17 + v16);
            *(float *)((char *)v17 + v16) = *(float *)(v18 - 4);
            *(float *)(v18 - 4) = v24;
          }
          if ( v17[1] > (double)v17[2] )
          {
            v25 = *((_DWORD *)v20 - 2);
            *((_DWORD *)v20 - 2) = *(_DWORD *)&v19[v18];
            *(_DWORD *)&v19[v18] = v25;
            v26 = v17[1];
            v14 = 1;
            v17[1] = v17[2];
            v17[2] = v26;
            v27 = *(float *)(v18 - 4);
            *(float *)(v18 - 4) = *(float *)v18;
            *(float *)v18 = v27;
          }
          if ( v17[2] > (double)v17[3] )
          {
            v28 = *(_DWORD *)&v19[v18];
            *(_DWORD *)&v19[v18] = *(_DWORD *)v20;
            *(_DWORD *)v20 = v28;
            v29 = v17[2];
            v14 = 1;
            v17[2] = v17[3];
            v17[3] = v29;
            v30 = *(float *)v18;
            *(float *)v18 = *(float *)(v18 + 4);
            *(float *)(v18 + 4) = v30;
          }
          if ( v17[3] > (double)v17[4] )
          {
            v31 = *(_DWORD *)v20;
            *(_DWORD *)v20 = *((_DWORD *)v20 + 1);
            *((_DWORD *)v20 + 1) = v31;
            v32 = v17[3];
            v14 = 1;
            v17[3] = v17[4];
            v17[4] = v32;
            v33 = *(float *)(v18 + 4);
            *(float *)(v18 + 4) = *(float *)(v18 + 8);
            *(float *)(v18 + 8) = v33;
          }
          v17 += 4;
          v18 += 16;
          v20 += 16;
          v41 = --v21;
        }
        while ( v21 );
        v9 = a4;
        v8 = a3;
        v15 = v46;
      }
      if ( v15 < v39 )
      {
        v45 = (char *)(a2 - (char *)v8);
        v40 = v9 - (_DWORD)v8;
        v42 = &a2[-v9];
        v34 = (float *)(v9 + 4 * v15);
        v35 = (int)&v8[v15 - 1];
        v46 = v39 - v15;
        do
        {
          if ( *(float *)v35 > (double)*(float *)(v35 + 4) )
          {
            v36 = *(_DWORD *)&v45[v35];
            *(float *)&v45[v35] = *(float *)((char *)v34 + (_DWORD)v42);
            *(_DWORD *)((char *)v34 + (_DWORD)v42) = v36;
            v37 = *(float *)v35;
            v14 = 1;
            *(float *)v35 = *(float *)(v35 + 4);
            *(float *)(v35 + 4) = v37;
            v38 = *(float *)(v40 + v35);
            *(float *)(v40 + v35) = *v34;
            *v34 = v38;
          }
          v35 += 4;
          ++v34;
          --v46;
        }
        while ( v46 );
      }
      --v39;
    }
    while ( v14 );
  }
  else if ( a1 )
  {
    memset32(a2, 0x3FFFF, a1);
  }
}

//----- (10010C80) --------------------------------------------------------
void __cdecl sub_10010C80(signed int a1, char *a2)
{
  signed int v2; // eax@1
  char v3; // [sp+0h] [bp-F8h]@5
  char v4; // [sp+7Ch] [bp-7Ch]@5

  v2 = a1;
  if ( a1 <= 31 )
  {
    if ( a1 < 0 )
      v2 = 0;
  }
  else
  {
    v2 = 31;
  }
  sub_10010940(v2, a2, (float *)&v4, (int)&v3, 0);
}

//----- (10010CC0) --------------------------------------------------------
int __cdecl sub_10010CC0(unsigned __int8 a1)
{
  int v1; // eax@3
  bool v2; // zf@3
  int result; // eax@3

  if ( a1 >= 0x67u
    || !(unsigned __int8)sub_1000FCE0()
    || (v1 = 8524 * a1, v2 = a1 == *(_BYTE *)(v1 + dword_102ACCEC + 2004), result = v1 + dword_102ACCEC + 2004, !v2) )
  {
    result = 0;
  }
  return result;
}
// 102ACCEC: using guessed type int dword_102ACCEC;

//----- (10010D00) --------------------------------------------------------
int __cdecl sub_10010D00(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  unsigned __int16 v3; // [sp+Ch] [bp+4h]@1

  result = 0;
  v3 = *(_WORD *)(a1 + 4);
  v2 = 0;
  do
  {
    if ( v3 & (unsigned __int16)(1 << v2) )
      result += (unsigned __int16)word_102AD422;
    ++v2;
  }
  while ( v2 < 16 );
  return result;
}
// 102AD422: using guessed type __int16 word_102AD422;

//----- (10010D40) --------------------------------------------------------
signed int __thiscall sub_10010D40(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 0x10 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_10010D00(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_102ACCE0)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_102AD422;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_102AD422;
    }
    if ( v5 & 4 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_102AD422;
    }
    if ( v5 & 8 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD422: using guessed type __int16 word_102AD422;

//----- (10010DF0) --------------------------------------------------------
signed int __usercall sub_10010DF0@<eax>(int a1@<edi>)
{
  signed int result; // eax@1
  int v2; // ebx@2
  int v3; // esi@2
  __int16 v4; // ax@2
  char *v5; // ecx@2
  unsigned __int16 v6; // [sp+0h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_10010D00(a1);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_102ACCE0)(v2, 160, &v6);
    v4 = *(_WORD *)(a1 + 4);
    v5 = (char *)&v6;
    if ( v4 & 1 )
    {
      v3 += v6;
      v5 = (char *)&v6 + (unsigned __int16)word_102AD422;
    }
    if ( v4 & 2 )
      v3 += *(_WORD *)v5;
    result = v3;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD422: using guessed type __int16 word_102AD422;

//----- (10010E80) --------------------------------------------------------
signed int __thiscall sub_10010E80(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 8 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_10010D00(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_102ACCE0)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_102AD422;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_102AD422;
    }
    if ( v5 & 4 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD422: using guessed type __int16 word_102AD422;

//----- (10010F20) --------------------------------------------------------
int __usercall sub_10010F20@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 1 )
    result = *(_DWORD *)a1 + sub_10010D00(a1);
  return result;
}

//----- (10010F40) --------------------------------------------------------
char __usercall sub_10010F40@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6)
{
  int *v6; // ebp@1

  v6 = a6;
  *a6 = 1000;
  *(_BYTE *)a1 = 95;
  *a2 = 1000;
  *a3 = 95;
  if ( *(_BYTE *)(a4 + 3) & 0x1F )
  {
    *v6 = *(_BYTE *)(a4 + 3) & 0x1F;
    *(_BYTE *)a1 = byte_1006B7A0[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    *a2 = (*(_BYTE *)(a4 + 3) & 0x1F) + 18;
    a1 = ((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7;
    *a3 = byte_1006B798[a1];
  }
  if ( *(_BYTE *)(a4 + 5) & 4 )
  {
    (*(void (__cdecl **)(_DWORD, signed int, int **))dword_102ACCE0)(*a5, 1, &a6);
    *a5 += (unsigned __int16)word_102AD426;
    LOBYTE(a1) = (_BYTE)a6;
    if ( (unsigned __int8)a6 & 0x1F )
    {
      a1 = ((unsigned __int8)a6 & 0x1F) + 18;
      *a2 = a1;
      *a3 = byte_1006B798[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    }
    else
    {
      *a2 = 1000;
      *a3 = 95;
    }
  }
  return a1;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD426: using guessed type __int16 word_102AD426;

//----- (10011000) --------------------------------------------------------
void *__usercall sub_10011000@<eax>(int a1@<eax>, char *a2@<esi>)
{
  int v2; // ST0C_4@2
  int v3; // eax@2
  void *result; // eax@2

  if ( *(_WORD *)(a1 + 10) & 0x8000 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 22);
    HIWORD(v2) = (*(_DWORD *)(a1 + 16) >> 25) & 0x7F;
    v3 = v2 + dword_102ACD84;
    *(_DWORD *)a2 = v2 + dword_102ACD84;
    result = (void *)(*(int (__cdecl **)(int, signed int, char *, int))dword_102ACCE0)(v3, 2, a2 + 4, v2);
    *(_DWORD *)a2 += (unsigned __int16)word_102ACD88;
  }
  else
  {
    result = memcpy_0(a2, &unk_1006B7A8, 6u);
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102ACD84: using guessed type int dword_102ACD84;
// 102ACD88: using guessed type __int16 word_102ACD88;

//----- (10011060) --------------------------------------------------------
__int16 __usercall sub_10011060@<ax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // edi@2
  int v6; // ecx@6
  int v7; // edx@10
  char v8; // cl@10
  unsigned int v9; // eax@10
  int v10; // edx@16
  int v12; // [sp+0h] [bp-20h]@0
  __int16 v13; // [sp+Ch] [bp-14h]@2
  __int16 v14; // [sp+Eh] [bp-12h]@6
  int v15; // [sp+10h] [bp-10h]@2

  v3 = a1;
  sub_1000FF80(a3 & 0x3FFFF, v12);
  *(_DWORD *)a2 >>= 7;
  *(_DWORD *)(a2 + 4) >>= 7;
  LOWORD(v4) = HIWORD(a3) >> 10;
  if ( HIWORD(a3) >> 10 != 5 )
  {
    if ( (_WORD)v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_102ACCE0)(v3, 9, &v13);
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned int)(unsigned __int8)v15 >> 4;
    }
    else
    {
      if ( (_WORD)v4 == 7 )
      {
        (*(void (__cdecl **)(int, signed int, __int16 *))dword_102ACCE0)(v3, 11, &v13);
      }
      else
      {
        if ( (_WORD)v4 != 8 )
          return v4;
        (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_102ACCE0)(v3, 15, &v13);
      }
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned __int8)v15 >> 4;
    }
    *(_DWORD *)a2 = (v7 - (v8 & 0xF)) << 7;
    v10 = *(_DWORD *)(a2 + 4) - v9;
    v4 = 16 * v13;
    *(_DWORD *)(a2 + 4) = (v10 - v4) << 7;
    return v4;
  }
  (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_102ACCE0)(v3, 7, &v13);
  LOWORD(v4) = v15;
  v5 = (unsigned __int16)word_102AD424 + v3;
  if ( BYTE1(v15) & 8 )
  {
    if ( BYTE1(v15) & 4 )
      v5 += (unsigned __int16)word_102AD426;
    (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_102ACCE0)(v5, 19, &v13);
    if ( (HIWORD(a3) & 0x3FCu) > 0x1FC )
    {
      v4 = (signed __int16)v15;
      *(_DWORD *)a2 -= SHIWORD(v15);
      *(_DWORD *)(a2 + 4) -= v4;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
    else
    {
      LOWORD(v4) = v14;
      v6 = v13;
      *(_DWORD *)a2 -= v14;
      *(_DWORD *)(a2 + 4) -= v6;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0x7FFFFFFF;
    *(_DWORD *)(a2 + 4) = 0x7FFFFFFF;
  }
  return v4;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD424: using guessed type __int16 word_102AD424;
// 102AD426: using guessed type __int16 word_102AD426;

//----- (100111D0) --------------------------------------------------------
void *__cdecl sub_100111D0(unsigned int a1, char *a2)
{
  unsigned int v2; // eax@2
  __int64 v4; // [sp-4h] [bp-24h]@0
  char v5; // [sp+4h] [bp-1Ch]@2
  __int16 v6; // [sp+Eh] [bp-12h]@1

  v6 &= 0x7FFFu;
  LODWORD(v4) = a1;
  if ( !sub_10011BC0(v4) )
  {
    v2 = sub_10011B90(a1);
    (*(void (__cdecl **)(unsigned int, signed int, char *))dword_102ACCE0)(v2, 28, &v5);
  }
  return sub_10011000((int)&v5, a2);
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (10011220) --------------------------------------------------------
signed int __cdecl sub_10011220(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-10h]@3
  int v6; // [sp+Eh] [bp-6h]@3

  result = sub_10010D40(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_102ACCE0)(v3, 15, &v5);
        if ( !(v6 & 0x400) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_102AD42C;
        if ( v6 & 0x200 )
          v3 += (unsigned __int16)word_102AD42E;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD42C: using guessed type __int16 word_102AD42C;
// 102AD42E: using guessed type __int16 word_102AD42E;

//----- (100112A0) --------------------------------------------------------
signed int __usercall sub_100112A0@<eax>(int a1@<edi>, unsigned __int8 a2)
{
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  char v6; // [sp+9h] [bp-7h]@3

  result = sub_10010DF0(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_102ACCE0)(v3, 9, &v5);
        if ( !(v6 & 1) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_102AD444;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD444: using guessed type __int16 word_102AD444;

//----- (10011310) --------------------------------------------------------
signed int __cdecl sub_10011310(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  int v6; // [sp+Ch] [bp-4h]@3

  result = sub_10010E80(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_102ACCE0)(v3, 11, &v5);
        if ( !(v6 & 0x8000) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_102AD446;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD446: using guessed type __int16 word_102AD446;

//----- (10011380) --------------------------------------------------------
int __usercall sub_10011380@<eax>(int a1@<eax>, char a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // [sp+4h] [bp-8h]@3
  char v6; // [sp+6h] [bp-6h]@3
  char v7; // [sp+9h] [bp-3h]@4

  result = sub_10010F20(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(int, signed int, char *))dword_102ACCE0)(v3, 7, &v5);
        if ( !(v6 & 0x80) )
          break;
        v3 += (unsigned __int16)word_102AD424;
        ++v4;
        if ( v7 & 4 )
          v3 += (unsigned __int16)word_102AD426;
        if ( v7 & 8 )
          v3 += (unsigned __int16)word_102AD428;
        if ( v7 & 0x10 )
          v3 += (unsigned __int16)word_102AD42A;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD424: using guessed type __int16 word_102AD424;
// 102AD426: using guessed type __int16 word_102AD426;
// 102AD428: using guessed type __int16 word_102AD428;
// 102AD42A: using guessed type __int16 word_102AD42A;

//----- (10011410) --------------------------------------------------------
void __usercall sub_10011410(int a1@<edi>, int a2, int a3)
{
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@1

  sub_10011060(a3, (int)&v3, a2);
  *(double *)a1 = sub_1002BAF0(v3, 24);
  *(double *)(a1 + 8) = sub_1002BAF0(v4, 24);
}

//----- (10011450) --------------------------------------------------------
int __cdecl sub_10011450(__int64 a1)
{
  int result; // eax@2
  char v2; // [sp+0h] [bp-8h]@1

  sub_100111D0(a1 & 0x3FFFF, &v2);
  switch ( (unsigned int)WORD1(a1) >> 10 )
  {
    case 5u:
      result = sub_10011380((int)&v2, (*(_DWORD *)((char *)&a1 + 2) >> 2) & 0x7F);
      break;
    case 6u:
      result = sub_100112A0((int)&v2, *(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 7u:
      result = sub_10011310(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 8u:
      result = sub_10011220(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    default:
      result = 0xFFFFFF;
      break;
  }
  return result;
}

//----- (10011500) --------------------------------------------------------
double __cdecl sub_10011500(int a1)
{
  __int64 v1; // ST08_8@1
  int v2; // eax@1
  float v4; // [sp+0h] [bp-14h]@1
  char v5; // [sp+4h] [bp-10h]@2
  __int16 v6; // [sp+Eh] [bp-6h]@2

  LODWORD(v1) = a1;
  *((float *)&v1 + 1) = 6.2831855;
  v2 = sub_10011450(v1);
  if ( v2 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_102ACCE0)(v2, 15, &v5);
    v4 = (double)(signed __int16)((signed __int16)(v6 << 7) >> 7) * 0.01745329238474369 * 0.5;
  }
  return v4;
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (10011570) --------------------------------------------------------
int __cdecl sub_10011570(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  __int16 v4; // ax@2
  signed int v5; // eax@4
  char v6; // bl@4
  __int64 v7; // [sp-4h] [bp-58h]@0
  char v8; // [sp+Eh] [bp-46h]@3
  char v9; // [sp+Fh] [bp-45h]@3
  int v10; // [sp+10h] [bp-44h]@3
  int v11; // [sp+14h] [bp-40h]@3
  int v12; // [sp+18h] [bp-3Ch]@3
  char v13; // [sp+1Ch] [bp-38h]@3
  char v14; // [sp+23h] [bp-31h]@12
  char v15; // [sp+24h] [bp-30h]@10

  *(_DWORD *)a2 = 1600085855;
  *(_WORD *)(a2 + 4) = 24415;
  LODWORD(v7) = a1;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_10011450(v7);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = HIWORD(a1) >> 10;
    if ( HIWORD(a1) >> 10 == 5 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_102ACCE0)(v3, 12, &v13);
      v10 = (unsigned __int16)word_102AD424 + v3;
      sub_10010F40((unsigned int)&v9, (unsigned int *)&v12, &v8, (int)&v13, &v10, &v11);
      if ( (HIWORD(a1) & 0x3FCu) <= 0x1FC )
      {
        v6 = v9;
        v5 = v11;
      }
      else
      {
        v5 = v12;
        v6 = v8;
      }
      *(_BYTE *)a2 = 82;
      *(_BYTE *)(a2 + 1) = 87;
      if ( sub_1001D6B0(v5, 2, (_BYTE *)(a2 + 2)) )
      {
        *(_BYTE *)(a2 + 4) = v6;
        *(_BYTE *)(a2 + 6) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 2) = 1600085855;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
    else if ( v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_102ACCE0)(v3, 9, &v13);
      sub_10010550(&v15, 5, a2);
      *(_BYTE *)(a2 + 5) = 0;
    }
    else if ( v4 == 7 )
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_102ACCE0)(v3, 11, &v13);
      sub_10010550(&v14, 3, a2);
      *(_BYTE *)(a2 + 3) = 0;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_102ACCE0)(v3, 15, &v13);
      sub_10010550(&v14, 4, a2);
      *(_BYTE *)(a2 + 4) = 0;
    }
    result = sub_1001D8B0(a2, 0);
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD424: using guessed type __int16 word_102AD424;

//----- (10011700) --------------------------------------------------------
char __cdecl sub_10011700(int a1, int a2)
{
  char v2; // bl@1
  int v3; // ebp@1
  unsigned int v4; // eax@2
  __int64 v6; // [sp-4h] [bp-30h]@0
  char v7; // [sp+10h] [bp-1Ch]@2
  unsigned int v8; // [sp+14h] [bp-18h]@2

  *(double *)a2 = 6.2831853071796;
  LODWORD(v6) = a1;
  *(double *)(a2 + 8) = 6.2831853071796;
  v2 = 0;
  v3 = sub_10011450(v6);
  if ( v3 != 0xFFFFFF )
  {
    v4 = sub_10011B90(a1 & 0x3FFFF);
    (*(void (__cdecl **)(unsigned int, signed int, char *))dword_102ACCE0)(v4, 28, &v7);
    v2 = (v8 >> 29) & 1;
    sub_10011410(a2, a1, v3);
  }
  return v2;
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (10011770) --------------------------------------------------------
__int16 __cdecl sub_10011770(int a1, int a2)
{
  int v2; // eax@1
  __int64 v4; // [sp-4h] [bp-Ch]@0

  LODWORD(v4) = a1;
  *(_DWORD *)a2 = 2147483648;
  *(_DWORD *)(a2 + 4) = 2147483648;
  v2 = sub_10011450(v4);
  if ( v2 != 0xFFFFFF )
    LOWORD(v2) = sub_10011060(v2, a2, a1);
  return v2;
}

//----- (100117B0) --------------------------------------------------------
char *__cdecl sub_100117B0(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_102ACD00[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_102ACD08];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_102ACD04];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_102ACD08];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_102ACCE0)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102ACD00: using guessed type int dword_102ACD00[];
// 102ACD04: using guessed type __int16 word_102ACD04[];
// 102ACD08: using guessed type int dword_102ACD08[];
// 100117B0: using guessed type char var_20[28];

//----- (10011870) --------------------------------------------------------
signed int sub_10011870()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_102ACCE4 = 0;
  dword_102ACCE8 = 0xFFFFFF;
  byte_102ACCD4 = 0;
  dword_102ACCD8 = 0xFFFFFF;
  return result;
}
// 102ACCD4: using guessed type char byte_102ACCD4;
// 102ACCD8: using guessed type int dword_102ACCD8;
// 102ACCE4: using guessed type char byte_102ACCE4;
// 102ACCE8: using guessed type int dword_102ACCE8;

//----- (10011890) --------------------------------------------------------
int sub_10011890()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_102ACCE0 + 16))();
  byte_102ACCDC = (_BYTE)result == 0;
  return result;
}
// 102ACCDC: using guessed type char byte_102ACCDC;
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (100118F0) --------------------------------------------------------
int sub_100118F0()
{
  int result; // eax@1

  *(_DWORD *)(dword_102AD550 + 20812) = 1000;
  *(_DWORD *)(dword_102AD550 + 20816) = dword_102ACD68 + *(_DWORD *)(dword_102AD550 + 20812);
  *(_DWORD *)(dword_102AD550 + 20820) = dword_102ACDC8 + *(_DWORD *)(dword_102AD550 + 20816);
  *(_DWORD *)(dword_102AD550 + 20824) = dword_102ACDF8 + *(_DWORD *)(dword_102AD550 + 20820);
  result = dword_102AD550;
  *(_DWORD *)(dword_102AD550 + 20828) = dword_102ACE40 + *(_DWORD *)(dword_102AD550 + 20824);
  return result;
}
// 102ACD68: using guessed type int dword_102ACD68;
// 102ACDC8: using guessed type int dword_102ACDC8;
// 102ACDF8: using guessed type int dword_102ACDF8;
// 102ACE40: using guessed type int dword_102ACE40;
// 102AD550: using guessed type int dword_102AD550;

//----- (10011960) --------------------------------------------------------
char *sub_10011960()
{
  sub_100117B0(0x40u);
  sub_100117B0(0x39u);
  sub_100117B0(0x33u);
  sub_100117B0(0x31u);
  sub_100117B0(0x32u);
  sub_100117B0(0x4Eu);
  sub_100117B0(0x4Fu);
  sub_100117B0(0x3Du);
  sub_100117B0(0x3Eu);
  sub_100117B0(0x45u);
  return sub_100117B0(0x38u);
}
// 102AD550: using guessed type int dword_102AD550;

//----- (10011A30) --------------------------------------------------------
int __cdecl sub_10011A30(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_101B07B8, a1, 0x1Cu);
  dword_102ACCE0 = (int)dword_101B07B8;
  dword_102AD550 = (int)&unk_101B07D8;
  memset(&unk_101B07D8, 0, 0x516Cu);
  dword_101B07B8[5](dword_102AD550 + 20832, dword_102AD550 + 20833, dword_102AD550 + 20836);
  (*(void (__cdecl **)(int))(dword_102ACCE0 + 24))(dword_102AD550 + 20840);
  sub_1002BFE0();
  sub_1002BC70();
  sub_1002BE20();
  sub_1002BD40();
  sub_10011960();
  sub_10011870();
  sub_100125F0();
  sub_10011EB0();
  sub_10011890();
  sub_100118F0();
  *(_DWORD *)(dword_102AD550 + 20800) = 0;
  *(_DWORD *)(dword_102AD550 + 20804) = dword_102ACEE8;
  result = dword_102AD550;
  *(_DWORD *)(dword_102AD550 + 20808) = dword_102ACEF4 + *(_DWORD *)(dword_102AD550 + 20804);
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102ACEE8: using guessed type int dword_102ACEE8;
// 102ACEF4: using guessed type int dword_102ACEF4;
// 102AD550: using guessed type int dword_102AD550;

//----- (10011AE0) --------------------------------------------------------
unsigned __int8 __cdecl sub_10011AE0(unsigned int a1)
{
  unsigned __int8 result; // al@1

  result = 0;
  do
  {
    if ( a1 < *(_DWORD *)(dword_102AD550 + 4 * result + 20816) )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}
// 102AD550: using guessed type int dword_102AD550;

//----- (10011B10) --------------------------------------------------------
unsigned int __cdecl sub_10011B10(unsigned int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // esi@2
  char v4; // bl@4
  unsigned int result; // eax@5

  if ( a2 >= 4u )
  {
    result = 0xFFFFFF;
  }
  else
  {
    v3 = a1;
    if ( a3 )
      v3 = a1 - *(_DWORD *)(dword_102AD550 + 4 * a2 + 20812);
    v4 = byte_1006B7DC[12 * a2];
    if ( sub_1002BB30(v3, (unsigned __int8)byte_1006B7DC[12 * a2]) )
      result = dword_102ACD00[3 * (unsigned __int8)v4] + v3 * (unsigned __int16)word_102ACD04[6 * (unsigned __int8)v4];
    else
      result = 0xFFFFFF;
  }
  return result;
}
// 102ACD00: using guessed type int dword_102ACD00[];
// 102ACD04: using guessed type __int16 word_102ACD04[];
// 102AD550: using guessed type int dword_102AD550;

//----- (10011B90) --------------------------------------------------------
unsigned int __cdecl sub_10011B90(unsigned int a1)
{
  unsigned __int8 v1; // ST14_1@1

  v1 = sub_10011AE0(a1);
  return sub_10011B10(a1, v1, 1);
}

//----- (10011BC0) --------------------------------------------------------
char __cdecl sub_10011BC0(__int64 a1)
{
  char v1; // bl@1
  char result; // al@3
  unsigned __int16 v3; // ax@7

  v1 = 9;
  if ( (unsigned int)a1 < 0x3E8 )
  {
LABEL_13:
    result = v1;
  }
  else
  {
    switch ( sub_10011AE0(a1) )
    {
      case 0u:
        result = 0;
        break;
      case 1u:
        result = 1;
        break;
      case 2u:
        result = 2;
        break;
      case 3u:
        result = 3;
        break;
      default:
        v3 = WORD1(a1) >> 10;
        if ( (unsigned __int16)(WORD1(a1) >> 10) >= 0xBu && v3 < 0xDu
          || v3 >= 5u && v3 <= 8u && (unsigned __int16)(a1 - 1000) < (unsigned int)sub_1002BB70(8u) )
        {
          v1 = (*(_DWORD *)((char *)&a1 + 2) >> 10) & 0x3F;
        }
        goto LABEL_13;
    }
  }
  return result;
}

//----- (10011C60) --------------------------------------------------------
void __cdecl sub_10011C60(unsigned int a1, int a2)
{
  unsigned int v2; // ebx@3
  unsigned int v3; // ebp@4
  unsigned int v4; // eax@5
  int v5; // ecx@5
  int v6; // eax@6
  char v7; // dl@10
  char v8; // cl@10
  char v9; // al@10
  char v10; // cl@11
  char v11; // dl@11
  char v12; // dl@13
  char v13; // cl@13
  char v14; // al@13
  char v15; // cl@14
  char v16; // dl@14
  char v17; // cl@14
  char v18; // [sp+4h] [bp-10h]@5
  char v19; // [sp+5h] [bp-Fh]@10
  char v20; // [sp+6h] [bp-Eh]@10
  char v21; // [sp+8h] [bp-Ch]@5
  char v22; // [sp+Ah] [bp-Ah]@10
  char v23; // [sp+Bh] [bp-9h]@10

  if ( a2 )
  {
    if ( (a1 & 0xFC000000) != 805306368 || (v2 = a1 & 0x1FF, v2 > 0x168) || (v3 = (a1 >> 9) & 0x1FF, v3 > 0x168) )
    {
      *(_DWORD *)a2 = 1600085855;
      *(_WORD *)(a2 + 4) = 24415;
      *(_BYTE *)(a2 + 6) = 0;
    }
    else
    {
      sub_1001D840(&v18, 4u, "%+03d", (signed int)(v2 - 180) / 2);
      sub_1001D840(&v21, 5u, "%+04d", v3 - 180);
      v4 = (v3 - 180) >> 31;
      v5 = (v3 - 180 - v4) ^ ((signed int)(v3 - 180 - v4) >> 31);
      if ( v2 < 0xB4 )
      {
        LOBYTE(v4) = v3 < 0xB4;
        v6 = 4 * v4 + 83;
      }
      else
      {
        LOBYTE(v6) = v3 < 0xB4 ? 78 : 69;
      }
      *(_BYTE *)(a2 + 5) = 0;
      if ( a1 & 1 )
      {
        if ( v5 >= 100 )
        {
          v10 = v22;
          *(_BYTE *)a2 = v19;
          v11 = v23;
          *(_BYTE *)(a2 + 1) = v6;
          *(_BYTE *)(a2 + 2) = v20;
          *(_BYTE *)(a2 + 3) = v10;
          *(_BYTE *)(a2 + 4) = v11;
        }
        else
        {
          v7 = v20;
          *(_BYTE *)(a2 + 1) = v19;
          v8 = v23;
          *(_BYTE *)a2 = v6;
          v9 = v22;
          *(_BYTE *)(a2 + 2) = v7;
          *(_BYTE *)(a2 + 3) = v9;
          *(_BYTE *)(a2 + 4) = v8;
        }
      }
      else if ( v5 < 100 )
      {
        v15 = v20;
        *(_BYTE *)a2 = v19;
        v16 = v22;
        *(_BYTE *)(a2 + 1) = v15;
        v17 = v23;
        *(_BYTE *)(a2 + 2) = v16;
        *(_BYTE *)(a2 + 3) = v17;
        *(_BYTE *)(a2 + 4) = v6;
      }
      else
      {
        v12 = v20;
        *(_BYTE *)a2 = v19;
        v13 = v23;
        *(_BYTE *)(a2 + 2) = v6;
        v14 = v22;
        *(_BYTE *)(a2 + 1) = v12;
        *(_BYTE *)(a2 + 3) = v14;
        *(_BYTE *)(a2 + 4) = v13;
      }
    }
  }
}

//----- (10011E40) --------------------------------------------------------
char __cdecl sub_10011E40(unsigned int a1, int a2)
{
  char result; // al@1
  unsigned int v3; // edx@3
  unsigned int v4; // ecx@4

  result = 0;
  if ( a2 )
  {
    if ( (a1 & 0xFC000000) == 805306368 )
    {
      v3 = a1 & 0x1FF;
      if ( v3 <= 0x168 )
      {
        v4 = (a1 >> 9) & 0x1FF;
        if ( v4 <= 0x168 )
        {
          *(_DWORD *)a2 = (signed int)(11930464 * (v3 - 180)) / 2;
          *(_DWORD *)(a2 + 4) = 11930464 * (v4 - 180);
          result = 1;
        }
      }
    }
  }
  return result;
}

//----- (10011EB0) --------------------------------------------------------
int sub_10011EB0()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_1002BB30(0x4Du, 1u) )
  {
    result = dword_102AD09C;
    dword_101B59D8 = dword_102AD09C;
    if ( dword_102AD09C )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_102ACCE0)(dword_102AD09C, 8, &v1);
      word_101B59D0 = v1;
      result = v3 & 0x1FF;
      dword_101B59D8 += (unsigned __int16)word_102AD0A0;
      word_101B59D4 = v2 & 0x1FF;
      word_101B59CC = v3 & 0x1FF;
    }
  }
  else
  {
    word_101B59D0 = 6;
    word_101B59D4 = 6;
    result = dword_102ACF1C;
    word_101B59CC = 60;
    dword_101B59D8 = dword_102ACF1C;
  }
  return result;
}
// 101B59CC: using guessed type __int16 word_101B59CC;
// 101B59D0: using guessed type __int16 word_101B59D0;
// 101B59D4: using guessed type __int16 word_101B59D4;
// 101B59D8: using guessed type int dword_101B59D8;
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102ACF1C: using guessed type int dword_102ACF1C;
// 102AD09C: using guessed type int dword_102AD09C;
// 102AD0A0: using guessed type __int16 word_102AD0A0;

//----- (10011F50) --------------------------------------------------------
char __cdecl sub_10011F50(float *a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char v3; // bl@1
  char v4; // al@1
  float v5; // ST44_4@4
  double v6; // st6@4
  signed __int16 v7; // si@4
  signed int v8; // eax@4
  signed __int16 v9; // di@4
  float v10; // ST44_4@7
  __int16 v11; // cx@8
  __int16 v12; // ax@8
  signed int v13; // edi@8
  __int16 v14; // bp@8
  int v15; // esi@8
  __int16 v16; // bx@8
  signed int v17; // esi@8
  int *v18; // edi@8
  signed int v19; // ecx@10
  __int64 v20; // rax@11
  __int16 v21; // si@16
  float v23; // [sp+Ch] [bp-1Ch]@8
  float v24; // [sp+10h] [bp-18h]@4
  float v25; // [sp+10h] [bp-18h]@8
  int v26; // [sp+18h] [bp-10h]@8
  int v27; // [sp+1Ch] [bp-Ch]@8

  *a1 = 0.0;
  v2 = v1;
  v3 = 0;
  v4 = sub_1002C210(v1, 0);
  if ( dword_101B59D8 && v4 && sub_1002BB30(0, 0x2Du) )
  {
    v24 = (*(float *)v2 + 1.570796370506287) * 57.29578018188477;
    v5 = 57.29578018188477 * (*(float *)(v2 + 4) + 3.141592741012573);
    v6 = v5;
    v7 = (signed int)v24;
    v8 = (signed int)v5;
    v9 = v8;
    if ( v7 > 179 )
      v7 = 179;
    if ( v9 >= 360 )
    {
      v9 = v8 - 360;
      v10 = v6 - 360.0;
      v6 = v10;
    }
    v11 = v7 / word_101B59D0;
    v12 = v9 / word_101B59D4;
    v13 = (signed __int16)(v7 / word_101B59D0);
    v14 = v7 / word_101B59D0 + 1;
    v23 = v24 / (double)word_101B59D0 - (double)v13;
    v15 = v12;
    v25 = v6 / (double)word_101B59D4 - (double)v12;
    v16 = (v12 + 1) % word_101B59CC;
    (*(void (__cdecl **)(int, signed int, int *))dword_102ACCE0)(
      dword_101B59D8 + (unsigned __int16)word_102ACF20 * (v12 + v11 * word_101B59CC),
      2,
      &v26);
    (*(void (__cdecl **)(int, signed int, char *))dword_102ACCE0)(
      dword_101B59D8 + (unsigned __int16)word_102ACF20 * (v16 + v13 * word_101B59CC),
      2,
      (char *)&v26 + 2);
    (*(void (__cdecl **)(int, signed int, int *))dword_102ACCE0)(
      dword_101B59D8 + (unsigned __int16)word_102ACF20 * (v15 + v14 * word_101B59CC),
      2,
      &v27);
    (*(void (__cdecl **)(int, _DWORD, char *))dword_102ACCE0)(
      dword_101B59D8 + (unsigned __int16)word_102ACF20 * (v16 + v14 * word_101B59CC),
      2,
      (char *)&v27 + 2);
    v3 = 1;
    v17 = 1;
    v18 = &v26;
    do
    {
      if ( !v3 )
        break;
      v19 = v17;
      if ( v17 < 4 )
      {
        while ( 1 )
        {
          v20 = (signed __int16)(*(_WORD *)v18 - *((_WORD *)&v26 + v19));
          if ( (signed int)((HIDWORD(v20) ^ v20) - HIDWORD(v20)) > 1820 )
            break;
          if ( ++v19 >= 4 )
            goto LABEL_15;
        }
        v3 = 0;
      }
LABEL_15:
      ++v17;
      v18 = (int *)((char *)v18 + 2);
    }
    while ( v17 - 1 < 3 );
    v21 = v26 + (signed int)((double)(signed __int16)(v27 - v26) * v23);
    *a1 = (double)(signed __int16)(v21
                                 + (signed int)((double)(signed __int16)(HIWORD(v26)
                                                                       + (signed int)(v23
                                                                                    * (double)(signed __int16)(HIWORD(v27) - HIWORD(v26)))
                                                                       - v21)
                                              * v25))
        * 0.0000958738019107841;
  }
  return v3;
}
// 101B59CC: using guessed type __int16 word_101B59CC;
// 101B59D0: using guessed type __int16 word_101B59D0;
// 101B59D4: using guessed type __int16 word_101B59D4;
// 101B59D8: using guessed type int dword_101B59D8;
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102ACF20: using guessed type __int16 word_102ACF20;

//----- (10012210) --------------------------------------------------------
char __cdecl sub_10012210(int a1, float *a2)
{
  return sub_10011F50(a2);
}

//----- (10012230) --------------------------------------------------------
double __cdecl sub_10012230(unsigned int a1)
{
  unsigned int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-44h]@0
  float v4; // [sp+4h] [bp-3Ch]@1
  char v5; // [sp+8h] [bp-38h]@5
  char v6; // [sp+10h] [bp-30h]@5
  char v7; // [sp+20h] [bp-20h]@2
  unsigned int v8; // [sp+24h] [bp-1Ch]@2
  int v9; // [sp+2Eh] [bp-12h]@4

  v4 = 6.2831855;
  LODWORD(v3) = a1;
  if ( sub_10011BC0(v3) == 3 )
  {
    v1 = sub_10011B90(a1);
    (*(void (__cdecl **)(unsigned int, signed int, char *))dword_102ACCE0)(v1, 29, &v7);
    if ( v8 >> 29 != 2 && v8 >> 29 != 6 )
      return (float)((double)(v9 >> 23) * 0.01745329238474369 * 0.5);
    sub_10010060(a1, (int)&v6);
    sub_10041C50((int)&v6, (int)&v5);
    sub_10012210((int)&v5, &v4);
  }
  return v4;
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (100122E0) --------------------------------------------------------
_BYTE *__cdecl sub_100122E0(_BYTE *a1, _BYTE *a2)
{
  _BYTE *result; // eax@1

  result = (_BYTE *)sub_1002BB70(0x2Bu);
  *a1 = (_BYTE)result;
  if ( (_BYTE)result )
  {
    result = a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (10012310) --------------------------------------------------------
int sub_10012310()
{
  return (*(int (**)(void))(dword_102ACCE0 + 8))();
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (10012320) --------------------------------------------------------
int __fastcall sub_10012320(unsigned __int8 a1)
{
  return dword_102ACF04 + a1 * (unsigned __int16)word_102ACF08;
}
// 102ACF04: using guessed type int dword_102ACF04;
// 102ACF08: using guessed type __int16 word_102ACF08;

//----- (10012340) --------------------------------------------------------
int __fastcall sub_10012340(unsigned __int8 a1)
{
  return dword_102ACF10 + a1 * (unsigned __int16)word_102ACF14;
}
// 102ACF10: using guessed type int dword_102ACF10;
// 102ACF14: using guessed type __int16 word_102ACF14;

//----- (10012360) --------------------------------------------------------
void *__cdecl sub_10012360(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_100122E0(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_10012320(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_102ACCE0)(v3, 22, &v7);
      result = (void *)sub_1002BDA0(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy_0(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (10012430) --------------------------------------------------------
int __cdecl sub_10012430(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy_0((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_10012320(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_102ACCE0)(v2, 22, &v22);
    sub_1002BDA0((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_10012340(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_102ACCE0)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_1002BDA0((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_102ACCE0 + 12))(a1);
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (100125F0) --------------------------------------------------------
char sub_100125F0()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_10012310();
  sub_100122E0(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_10012360(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_1002BB70(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_10012360(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_10012430((int)&v8);
  }
  return v0;
}

//----- (10012760) --------------------------------------------------------
char *__cdecl sub_10012760(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_1003DBF0();
  *(_DWORD *)(a5 + 596) = sub_1003DC90();
  sub_1003DCB0((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_1001D720(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10019F70((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10012890) --------------------------------------------------------
char sub_10012890()
{
  char result; // al@1

  result = 0;
  byte_101BAF48 = 0;
  byte_101BAF49 = 0;
  return result;
}
// 101BAF48: using guessed type char byte_101BAF48;
// 101BAF49: using guessed type char byte_101BAF49;

//----- (100128A0) --------------------------------------------------------
char __cdecl sub_100128A0(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10012760(-5, a1, a2, a4, a5);
  else
    sub_10012760(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_1001D870((const char *)(a5 + 485), " DBGA", 100);
  sub_1003DCB0((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_101BAF48 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_101BAF49 )
LABEL_15:
      result = sub_1003DCF0(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 1003E360: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 101BAF48: using guessed type char byte_101BAF48;
// 101BAF49: using guessed type char byte_101BAF49;

//----- (100129A0) --------------------------------------------------------
char __cdecl sub_100129A0(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_100128A0(a1, a2, a3, a4, (int)&v5);
}

//----- (10012A10) --------------------------------------------------------
int __cdecl sub_10012A10(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1006FE6C[a1];
  return result;
}
// 1006FE6C: using guessed type __int16 word_1006FE6C[];

//----- (10012A30) --------------------------------------------------------
signed int sub_10012A30()
{
  signed int result; // eax@1

  result = -15;
  dword_101BAF68 = -15;
  dword_101BAF74 = -15;
  dword_101BAF50 = -15;
  dword_101BAF78 = -15;
  dword_101BAF64 = -15;
  dword_101BAF54 = -15;
  dword_101BAF4C = -15;
  dword_101BAF60 = -15;
  dword_101BAF70 = -15;
  dword_101BAF6C = -15;
  dword_101BAF5C = -15;
  dword_101BAF58 = -15;
  return result;
}
// 101BAF4C: using guessed type int dword_101BAF4C;
// 101BAF50: using guessed type int dword_101BAF50;
// 101BAF54: using guessed type int dword_101BAF54;
// 101BAF58: using guessed type int dword_101BAF58;
// 101BAF5C: using guessed type int dword_101BAF5C;
// 101BAF60: using guessed type int dword_101BAF60;
// 101BAF64: using guessed type int dword_101BAF64;
// 101BAF68: using guessed type int dword_101BAF68;
// 101BAF6C: using guessed type int dword_101BAF6C;
// 101BAF70: using guessed type int dword_101BAF70;
// 101BAF74: using guessed type int dword_101BAF74;
// 101BAF78: using guessed type int dword_101BAF78;

//----- (10012A80) --------------------------------------------------------
signed int __usercall sub_10012A80@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_1003ED70((int)&off_1006FE8C);
      break;
    case 0:
      result = sub_1003ED70((int)&off_1006FEA0);
      break;
    case 1:
      result = sub_1003ED70((int)&off_1006FEB4);
      break;
    case 2:
      result = sub_1003ED70((int)&off_1006FEDC);
      break;
    case 3:
      result = sub_1003ED70((int)&off_1006FEC8);
      break;
    case 5:
      result = sub_1003ED70((int)&off_1006FEF0);
      break;
    default:
      result = sub_1003ED70(a2);
      break;
  }
  return result;
}
// 1006FE8C: using guessed type char *off_1006FE8C;
// 1006FEA0: using guessed type char *off_1006FEA0;
// 1006FEB4: using guessed type char *off_1006FEB4;
// 1006FEC8: using guessed type char *off_1006FEC8;
// 1006FEDC: using guessed type char *off_1006FEDC;
// 1006FEF0: using guessed type char *off_1006FEF0;

//----- (10012B20) --------------------------------------------------------
int __usercall sub_10012B20@<eax>(char a1@<al>)
{
  return sub_1003DD40(dword_1006F9BC[a1]);
}
// 1006F9BC: using guessed type int dword_1006F9BC[];

//----- (10012B40) --------------------------------------------------------
int __usercall sub_10012B40@<eax>(char a1@<al>)
{
  return sub_1003DDA0(dword_1006F9BC[a1], 10);
}
// 1006F9BC: using guessed type int dword_1006F9BC[];

//----- (10012B60) --------------------------------------------------------
unsigned __int16 __usercall sub_10012B60@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  unsigned __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10012A80(a1, a1) )
        {
          sub_100129A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_101BAF68 + 2 * a2 + 241212);
        v3 = result < 0x256u;
        goto LABEL_32;
      }
      sub_100129A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_100129A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10012A80(a1, a1) )
      {
        result = *(_WORD *)(dword_101BAF74 + 2 * a2 + 284664);
        v3 = result < 0x211u;
        goto LABEL_32;
      }
      if ( sub_10015FD0(15000) )
        goto LABEL_6;
      sub_100129A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_100129A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10012A80(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101BAF50 + 2 * a2 + 447808);
      v3 = result < 0x979u;
      goto LABEL_32;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_100129A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10012A80(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_101BAF78 + 2 * a2 + 356016);
      v3 = result < 0x23Du;
      goto LABEL_32;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_100129A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10012A80(a1, a1) )
      {
        sub_100129A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_101BAF64 + 2 * a2 + 23096);
      v3 = result < 0x52u;
      goto LABEL_32;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10012A80(a1, a1) )
        {
          result = *(_WORD *)(dword_101BAF54 + 2 * a2 + 1804);
          v3 = result < 4u;
LABEL_32:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 101BAF50: using guessed type int dword_101BAF50;
// 101BAF54: using guessed type int dword_101BAF54;
// 101BAF64: using guessed type int dword_101BAF64;
// 101BAF68: using guessed type int dword_101BAF68;
// 101BAF74: using guessed type int dword_101BAF74;
// 101BAF78: using guessed type int dword_101BAF78;

//----- (10012DA0) --------------------------------------------------------
char __cdecl sub_10012DA0(char a1, unsigned __int16 a2, _BYTE *a3)
{
  unsigned __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_10012B60(a1, a2);
  if ( v3 != -1 && !sub_10012B40(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)(v3 + dword_101BAF68);
        sub_10012B20(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)(v3 + dword_101BAF74);
        sub_10012B20(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_101BAF50;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)(v3 + dword_101BAF78);
        sub_10012B20(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        *a3 = *(_BYTE *)(v3 + dword_101BAF64);
        sub_10012B20(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        v6 = dword_101BAF54;
LABEL_16:
        *a3 = *(_BYTE *)(v3 + v6);
        sub_10012B20(a1);
        return 1;
      default:
LABEL_17:
        sub_10012B20(a1);
        break;
    }
  }
  return 0;
}
// 101BAF50: using guessed type int dword_101BAF50;
// 101BAF54: using guessed type int dword_101BAF54;
// 101BAF64: using guessed type int dword_101BAF64;
// 101BAF68: using guessed type int dword_101BAF68;
// 101BAF74: using guessed type int dword_101BAF74;
// 101BAF78: using guessed type int dword_101BAF78;

//----- (10012F00) --------------------------------------------------------
char __cdecl sub_10012F00(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  unsigned __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10012B60(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10012A80(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_101BAF68 + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10012A80(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_101BAF74 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10012A80(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_101BAF50 + 321708), 0x34u);
        break;
      case 2:
        if ( (unsigned __int8)sub_10012A80(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_101BAF78 + 326220), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10012A80(a1, v3) != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_101BAF64 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        result = sub_10012A80(a1, v3);
        if ( result != 1 )
          goto LABEL_16;
        qmemcpy(a3, (const void *)(52 * v4 + dword_101BAF54 + 1596), 0x34u);
        break;
      default:
LABEL_16:
        result = 0;
        break;
    }
  }
  return result;
}
// 101BAF50: using guessed type int dword_101BAF50;
// 101BAF54: using guessed type int dword_101BAF54;
// 101BAF64: using guessed type int dword_101BAF64;
// 101BAF68: using guessed type int dword_101BAF68;
// 101BAF74: using guessed type int dword_101BAF74;
// 101BAF78: using guessed type int dword_101BAF78;

//----- (10013080) --------------------------------------------------------
char __cdecl sub_10013080(char a1, unsigned __int16 a2, int a3)
{
  unsigned __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10012B60(a1, a2);
  if ( v3 != -1 && !sub_10012B40(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101BAF68 + 24 * (v3 + 25);
        goto LABEL_16;
      case 0:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101BAF74 + 24 * v3 + 532;
        goto LABEL_16;
      case 1:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101BAF50 + 24 * v3 + 2428;
        goto LABEL_16;
      case 2:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101BAF78 + 24 * (v3 + 24);
        goto LABEL_16;
      case 3:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101BAF64 + 24 * v3 + 84;
        goto LABEL_16;
      case 5:
        if ( (unsigned __int8)sub_10012A80(a1, v4) != 1 )
          goto LABEL_17;
        v5 = dword_101BAF54 + 24 * v3 + 4;
LABEL_16:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10012B20(a1);
        return 1;
      default:
LABEL_17:
        sub_10012B20(a1);
        break;
    }
  }
  return 0;
}
// 101BAF50: using guessed type int dword_101BAF50;
// 101BAF54: using guessed type int dword_101BAF54;
// 101BAF64: using guessed type int dword_101BAF64;
// 101BAF68: using guessed type int dword_101BAF68;
// 101BAF74: using guessed type int dword_101BAF74;
// 101BAF78: using guessed type int dword_101BAF78;

//----- (100131E0) --------------------------------------------------------
char __cdecl sub_100131E0(int a1, int a2, void *a3, char a4, __int16 a5, char a6)
{
  int v6; // ecx@0
  unsigned __int16 v7; // ax@1
  int v8; // edi@2
  __int16 v9; // si@11
  __int16 v11; // [sp+8h] [bp-560h]@13
  __int16 v12; // [sp+3Ch] [bp-52Ch]@10
  char v13; // [sp+40h] [bp-528h]@16
  char v14; // [sp+41h] [bp-527h]@10
  __int16 v15; // [sp+42h] [bp-526h]@10
  char v16; // [sp+44h] [bp-524h]@10
  __int16 v17; // [sp+46h] [bp-522h]@15
  int v18; // [sp+48h] [bp-520h]@16
  char v19; // [sp+4Ch] [bp-51Ch]@15

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_8;
    case 0:
      v8 = 29;
      goto LABEL_8;
    case 1:
      v8 = 30;
      goto LABEL_8;
    case 2:
      v8 = 31;
      goto LABEL_8;
    case 3:
      v8 = 32;
      goto LABEL_8;
    case 5:
      v8 = 33;
LABEL_8:
      LOBYTE(v7) = sub_10012A80(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10012B60(a1, a2);
      if ( v7 == -1 )
        return v7;
      v14 = a6;
      LOBYTE(v7) = a4;
      v12 = -32768;
      v15 = a2;
      v16 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10012F00(a1, a2, &v11) != 1 )
          goto LABEL_16;
        v9 = v11;
      }
      memcpy(&v19, a3, (unsigned __int16)v9);
      v17 = v9;
LABEL_16:
      v18 = sub_1003DC90();
      v13 = 0;
      LOBYTE(v7) = sub_1002E9E0(v8, (int)&v12);
      return v7;
    default:
      return v7;
  }
}

//----- (10013320) --------------------------------------------------------
char __cdecl sub_10013320(char a1, unsigned __int16 a2, int a3)
{
  unsigned __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  unsigned __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      v4 = 31;
      goto LABEL_8;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10012B60(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_1002E9E0(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}

//----- (10013400) --------------------------------------------------------
char __cdecl sub_10013400(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  unsigned __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@13
  int v17; // eax@15
  int v18; // eax@17
  int v19; // eax@25
  char v20; // [sp+7h] [bp-9h]@19
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_1003DC90();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10012B60(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10012A80(a1, v7) )
            goto LABEL_30;
          v9 = 3 * v8 + 75;
          v10 = dword_101BAF68 + 14952;
          v11 = 52 * v8 + dword_101BAF68 + 210116;
          v12 = dword_101BAF68 + 8 * v9;
          v13 = 195164;
          goto LABEL_18;
        case 0:
          if ( !(unsigned __int8)sub_10012A80(a1, v7) )
            goto LABEL_30;
          v14 = 3 * v8;
          v10 = dword_101BAF74 + 13228;
          v11 = 52 * v8 + dword_101BAF74 + 257156;
          v12 = dword_101BAF74 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_18;
        case 1:
          if ( !(unsigned __int8)sub_10012A80(a1, v7) )
            goto LABEL_30;
          v15 = 3 * v8;
          v10 = dword_101BAF50 + 60628;
          v11 = 52 * v8 + dword_101BAF50 + 321708;
          v12 = dword_101BAF50 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_18;
        case 2:
          if ( !(unsigned __int8)sub_10012A80(a1, v7) )
            goto LABEL_30;
          v16 = 3 * v8 + 72;
          v10 = dword_101BAF78 + 14328;
          v11 = 52 * v8 + dword_101BAF78 + 326220;
          v12 = dword_101BAF78 + 8 * v16;
          v13 = 311892;
          goto LABEL_18;
        case 3:
          if ( !(unsigned __int8)sub_10012A80(a1, v7) )
            goto LABEL_30;
          v17 = 3 * v8;
          v10 = dword_101BAF64 + 2052;
          v11 = 52 * v8 + dword_101BAF64 + 18832;
          v12 = dword_101BAF64 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_18;
        case 5:
          if ( !(unsigned __int8)sub_10012A80(a1, v7) )
            goto LABEL_30;
          v18 = 3 * v8;
          v10 = dword_101BAF54 + 100;
          v11 = 52 * v8 + dword_101BAF54 + 1596;
          v12 = dword_101BAF54 + 8 * v18 + 4;
          v13 = 1496;
LABEL_18:
          if ( sub_10012B40(a1) )
            goto LABEL_30;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_33;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_33:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10012B20(a1);
          result = v20;
          break;
        default:
LABEL_30:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101BAF4C: using guessed type int dword_101BAF4C;
// 101BAF50: using guessed type int dword_101BAF50;
// 101BAF54: using guessed type int dword_101BAF54;
// 101BAF60: using guessed type int dword_101BAF60;
// 101BAF64: using guessed type int dword_101BAF64;
// 101BAF68: using guessed type int dword_101BAF68;
// 101BAF70: using guessed type int dword_101BAF70;
// 101BAF74: using guessed type int dword_101BAF74;
// 101BAF78: using guessed type int dword_101BAF78;

//----- (10013680) --------------------------------------------------------
char __cdecl sub_10013680(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10013400(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (100136B0) --------------------------------------------------------
char __cdecl sub_100136B0(char a1, unsigned __int16 a2, _DWORD *a3)
{
  char result; // al@1
  char v4; // [sp+0h] [bp-34h]@1
  int v5; // [sp+10h] [bp-24h]@2

  result = sub_10012F00(a1, a2, &v4);
  if ( result == 1 )
    *a3 = v5;
  return result;
}

//----- (100136E0) --------------------------------------------------------
char __cdecl sub_100136E0(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10013400(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10013710) --------------------------------------------------------
char __cdecl sub_10013710(char a1, int a2, void *a3, int a4)
{
  return sub_10013400(a1, a2, 0, 0, a3, a4);
}

//----- (10013740) --------------------------------------------------------
char __cdecl sub_10013740(_DWORD *a1)
{
  int v1; // ecx@1
  char result; // al@3
  int v3; // [sp+4h] [bp-4h]@1

  v3 = 0;
  sub_1003E0E0(9210, (int)&v3, 4);
  v1 = v3;
  if ( a1 )
    *a1 = v3;
  result = 1;
  if ( v1 != dword_101BAF98 )
    result = 0;
  return result;
}
// 101BAF98: using guessed type int dword_101BAF98;

//----- (10013780) --------------------------------------------------------
char __cdecl sub_10013780(int a1, int a2)
{
  char v2; // bl@1

  SYS_enter_krnl();
  v2 = SYS_pvg_alrt_get_hdr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042088: using guessed type int __cdecl SYS_pvg_alrt_get_hdr(_DWORD, _DWORD);

//----- (100137B0) --------------------------------------------------------
char __cdecl sub_100137B0(int a1, int a2, int a3)
{
  char v3; // bl@1

  SYS_enter_krnl();
  v3 = SYS_pvg_alrt_get_hdr_text(a1, a2, a3);
  SYS_exit_krnl();
  return v3;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 1004208E: using guessed type int __cdecl SYS_pvg_alrt_get_hdr_text(_DWORD, _DWORD, _DWORD);

//----- (100137E0) --------------------------------------------------------
char __cdecl sub_100137E0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_acked(a1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 1004209A: using guessed type int __cdecl SYS_pvg_alrt_is_acked(_DWORD);

//----- (10013800) --------------------------------------------------------
char __cdecl sub_10013800(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set(a1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420A0: using guessed type int __cdecl SYS_pvg_alrt_is_set(_DWORD);

//----- (10013820) --------------------------------------------------------
char __cdecl sub_10013820(__int16 a1)
{
  char v1; // bl@1
  __int16 v3; // [sp+4h] [bp-A0h]@1

  v3 = a1;
  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_id_is_set(&v3, 0);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042094: using guessed type int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD);

//----- (10013880) --------------------------------------------------------
char __cdecl sub_10013880(__int16 a1, char a2)
{
  char v2; // bl@1
  __int16 v4; // [sp+4h] [bp-A0h]@1

  memset(&v4, 0, 0x9Cu);
  v4 = a1;
  SYS_enter_krnl();
  v2 = SYS_pvg_alrt_is_set_data(&v4, &a2, 4);
  SYS_exit_krnl();
  return v2;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420A6: using guessed type int __cdecl SYS_pvg_alrt_is_set_data(_DWORD, _DWORD, _DWORD);

//----- (100138F0) --------------------------------------------------------
char __cdecl sub_100138F0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_queued(a1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420AC: using guessed type int __cdecl SYS_pvg_alrt_is_set_queued(_DWORD);

//----- (10013910) --------------------------------------------------------
char __cdecl sub_10013910(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_text(a1, 1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420B2: using guessed type int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD);

//----- (10013930) --------------------------------------------------------
int __cdecl sub_10013930(int a1, int a2, int a3)
{
  SYS_enter_krnl();
  SYS_pvg_alrt_queue(a1, a2, a3);
  return SYS_exit_krnl();
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420B8: using guessed type int __cdecl SYS_pvg_alrt_queue(_DWORD, _DWORD, _DWORD);

//----- (10013960) --------------------------------------------------------
int __cdecl sub_10013960(int a1)
{
  SYS_enter_krnl();
  SYS_pvg_alrt_queue_flush(a1);
  return SYS_exit_krnl();
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420BE: using guessed type int __cdecl SYS_pvg_alrt_queue_flush(_DWORD);

//----- (100139C0) --------------------------------------------------------
int __cdecl sub_100139C0(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_trig_update(a1, a2);
  return SYS_exit_krnl();
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420CA: using guessed type int __cdecl SYS_pvg_trig_update(_DWORD, _DWORD);

//----- (10013A30) --------------------------------------------------------
int __cdecl sub_10013A30(int a1, int a2, int a3)
{
  if ( !sub_10013740(0) )
    sub_100129A0("..\\lib\\adl\\sys_usr_alrt.c", 282, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_ack(a1, a2, a3);
  return SYS_exit_krnl();
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420D0: using guessed type int __cdecl SYS_pvg_alrt_ack(_DWORD, _DWORD, _DWORD);

//----- (10013A80) --------------------------------------------------------
int __cdecl sub_10013A80(int a1)
{
  if ( !sub_10013740(0) )
    sub_100129A0("..\\lib\\adl\\sys_usr_alrt.c", 352, 0, "Non-alert master attempted to alter the alert's database");
  SYS_enter_krnl();
  SYS_pvg_alrt_clr(a1);
  return SYS_exit_krnl();
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420D6: using guessed type int __cdecl SYS_pvg_alrt_clr(_DWORD);

//----- (10013AC0) --------------------------------------------------------
char __cdecl sub_10013AC0(int a1, void *a2)
{
  char v3[68]; // [sp+4h] [bp-48h]@1

  sub_1003E040(9190, (int)v3, 67);
  return sub_1002BA30(a1, v3[(unsigned __int8)a1], a2);
}
// 10013AC0: using guessed type char var_48[68];

//----- (10013B10) --------------------------------------------------------
char __cdecl sub_10013B10(int a1, void *a2)
{
  char v3[68]; // [sp+4h] [bp-48h]@1

  sub_1003E040(9189, (int)v3, 67);
  return sub_1002BA30(a1, v3[(unsigned __int8)a1], a2);
}
// 10013B10: using guessed type char var_48[68];

//----- (10013B60) --------------------------------------------------------
char __cdecl sub_10013B60(int a1, void *a2)
{
  return sub_1002BA30(a1, 0, a2);
}

//----- (10013B80) --------------------------------------------------------
char __cdecl sub_10013B80(int a1, void *a2)
{
  return sub_1002BA30(a1, 1, a2);
}

//----- (10013BA0) --------------------------------------------------------
char __cdecl sub_10013BA0(unsigned __int8 a1, _WORD *a2)
{
  char result; // al@1
  unsigned int v3; // esi@2
  unsigned __int8 v4; // bl@3
  int v5; // edi@4

  result = 0;
  if ( a1 < 5u )
  {
    v3 = 8 * a1;
    if ( dword_101BB6E4[v3 / 4] )
    {
      v4 = 0;
      if ( word_101BB6E8[v3 / 2] )
      {
        while ( 1 )
        {
          v5 = *(_WORD *)(dword_101BB6E4[v3 / 4] + 2 * v4);
          if ( sub_100138F0(v5) )
            break;
          if ( ++v4 >= (unsigned __int16)word_101BB6E8[v3 / 2] )
            return 0;
        }
        if ( !a2 )
          return 0;
        *a2 = v5;
        result = 1;
      }
    }
  }
  return result;
}
// 101BB6E4: using guessed type int dword_101BB6E4[];
// 101BB6E8: using guessed type __int16 word_101BB6E8[];

//----- (10013C20) --------------------------------------------------------
char __cdecl sub_10013C20(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // edx@1
  unsigned int v3; // eax@2
  int v4; // eax@3

  v2 = 0xFFFF;
  if ( a1 < 5u )
  {
    v3 = 4 * a1;
    if ( a2 < (unsigned __int16)word_101BB6E8[v3] )
    {
      v4 = dword_101BB6E4[v3 / 2];
      if ( v4 )
        v2 = *(_WORD *)(v4 + 2 * a2);
    }
  }
  return sub_100138F0(v2);
}
// 101BB6E4: using guessed type int dword_101BB6E4[];
// 101BB6E8: using guessed type __int16 word_101BB6E8[];

//----- (10013C70) --------------------------------------------------------
char sub_10013C70()
{
  char result; // al@1
  unsigned int v1; // ecx@1
  signed int v2; // edx@1
  unsigned int v3; // esi@3
  signed int v4; // edi@3

  result = 1;
  v1 = 0;
  v2 = 5;
  do
  {
    dword_101BB788[v1 / 4] = 0;
    word_101BB78C[v1 / 2] = 0;
    dword_101BB6E4[v1 / 4] = 0;
    word_101BB6E8[v1 / 2] = 0;
    v1 += 8;
    --v2;
  }
  while ( v2 );
  word_101BB78C[0] = 23;
  word_101BB6E8[0] = 23;
  word_101BB794 = 21;
  word_101BB6F0 = 21;
  word_101BB79C = 3;
  word_101BB6F8 = 3;
  word_101BB7A4 = 3;
  word_101BB700 = 3;
  dword_101BB788[0] = (int)&unk_101BAFA0;
  dword_101BB6E4[0] = (int)&unk_101BB710;
  dword_101BB790 = (int)&unk_101BB269;
  dword_101BB6EC = (int)&unk_101BB73E;
  dword_101BB798 = (int)&unk_101BB4F4;
  dword_101BB6F4 = (int)&unk_101BB768;
  dword_101BB7A0 = (int)&unk_101BB551;
  dword_101BB6FC = (int)&unk_101BB76E;
  dword_101BB7A8 = (int)&unk_101BB5AE;
  word_101BB7AC = 10;
  dword_101BB704 = (int)&unk_101BB774;
  word_101BB708 = 10;
  v3 = 0;
  v4 = 5;
  do
  {
    if ( !dword_101BB788[v3 / 4] || !word_101BB78C[v3 / 2] || !dword_101BB6E4[v3 / 4] || !word_101BB6E8[v3 / 2] )
    {
      sub_100129A0("..\\lib\\adl\\app_pof_intf.c", 679, 0, 0);
      result = 0;
    }
    v3 += 8;
    --v4;
  }
  while ( v4 );
  return result;
}
// 101BB6E4: using guessed type int dword_101BB6E4[];
// 101BB6E8: using guessed type __int16 word_101BB6E8[];
// 101BB6EC: using guessed type int dword_101BB6EC;
// 101BB6F0: using guessed type __int16 word_101BB6F0;
// 101BB6F4: using guessed type int dword_101BB6F4;
// 101BB6F8: using guessed type __int16 word_101BB6F8;
// 101BB6FC: using guessed type int dword_101BB6FC;
// 101BB700: using guessed type __int16 word_101BB700;
// 101BB704: using guessed type int dword_101BB704;
// 101BB708: using guessed type __int16 word_101BB708;
// 101BB788: using guessed type int dword_101BB788[];
// 101BB78C: using guessed type __int16 word_101BB78C[];
// 101BB790: using guessed type int dword_101BB790;
// 101BB794: using guessed type __int16 word_101BB794;
// 101BB798: using guessed type int dword_101BB798;
// 101BB79C: using guessed type __int16 word_101BB79C;
// 101BB7A0: using guessed type int dword_101BB7A0;
// 101BB7A4: using guessed type __int16 word_101BB7A4;
// 101BB7A8: using guessed type int dword_101BB7A8;
// 101BB7AC: using guessed type __int16 word_101BB7AC;

//----- (10013DB0) --------------------------------------------------------
char sub_10013DB0()
{
  unsigned __int8 v0; // al@2
  unsigned int v1; // esi@3
  unsigned __int8 v2; // bl@5
  char result; // al@13
  unsigned __int8 v4; // [sp+6h] [bp-A6h]@2
  char v5; // [sp+7h] [bp-A5h]@2
  int v6; // [sp+8h] [bp-A4h]@0
  __int16 v7; // [sp+Ch] [bp-A0h]@6

  if ( sub_1003E040(6799, (int)&unk_101BAFA0, 1860) )
  {
    sub_100129A0("..\\lib\\adl\\app_pof_intf.c", 434, 0, 0);
    result = 0;
  }
  else
  {
    v5 = sub_10013C70() & 1;
    v0 = 0;
    v4 = 0;
    do
    {
      v1 = 8 * v0;
      if ( dword_101BB788[v1 / 4] && dword_101BB6E4[v1 / 4] )
      {
        v2 = 0;
        if ( word_101BB78C[v1 / 2] )
        {
          do
          {
            LOBYTE(v6) = v0 != 1;
            if ( sub_100137B0((int)&v7, dword_101BB788[v1 / 4] + 31 * v2, v6) )
              *(_WORD *)(dword_101BB6E4[v1 / 4] + 2 * v2) = v7;
            else
              *(_WORD *)(dword_101BB6E4[v1 / 4] + 2 * v2) = -1;
            v0 = v4;
            ++v2;
          }
          while ( v2 < (unsigned __int16)word_101BB78C[v1 / 2] );
        }
      }
      else
      {
        v5 = 0;
      }
      v4 = ++v0;
    }
    while ( v0 < 5u );
    result = v5;
  }
  return result;
}
// 101BB6E4: using guessed type int dword_101BB6E4[];
// 101BB788: using guessed type int dword_101BB788[];
// 101BB78C: using guessed type __int16 word_101BB78C[];

//----- (10013EF0) --------------------------------------------------------
BOOL __cdecl sub_10013EF0(int a1)
{
  return sub_1003E040(9360, a1, 248) == 0;
}

//----- (10013F10) --------------------------------------------------------
char __cdecl sub_10013F10(char a1, _DWORD *a2)
{
  int v2; // eax@1
  char result; // al@2

  v2 = sub_1001CD60(&a1, 2u, (int)&unk_1008FC52, 8, 415, -1);
  if ( v2 == -1 )
  {
    result = 0;
  }
  else
  {
    *a2 = *(&dword_1008FC54 + 2 * v2);
    result = 1;
  }
  return result;
}

//----- (10013F50) --------------------------------------------------------
__int16 __usercall sub_10013F50@<ax>(int a1@<edi>, char a2)
{
  __int16 v2; // ax@1
  __int16 result; // ax@3

  v2 = sub_1001CD60(&a2, 2u, (int)&unk_10090AC8, 16, 18, -1);
  if ( v2 == -1 )
  {
LABEL_11:
    result = -1;
  }
  else
  {
    switch ( a1 )
    {
      case 1:
        result = word_10090ACA[8 * v2];
        break;
      case 2:
        result = word_10090ACE[8 * v2];
        break;
      case 4:
        result = word_10090ACC[8 * v2];
        break;
      case 64:
        result = word_10090AD0[8 * v2];
        break;
      case 128:
        result = word_10090AD2[8 * v2];
        break;
      case 16:
        result = word_10090AD4[8 * v2];
        break;
      case 32:
        result = word_10090AD6[8 * v2];
        break;
      default:
        sub_1001D840(byte_101BB7B0, 0x64u, "Unrecognized LRU (%u) passed into alert processing.", a1);
        sub_100129A0("..\\lib\\adl\\sys_updt_alrt_data.c", 1037, 0, byte_101BB7B0);
        goto LABEL_11;
    }
  }
  return result;
}
// 10090ACA: using guessed type __int16 word_10090ACA[];
// 10090ACC: using guessed type __int16 word_10090ACC[];
// 10090ACE: using guessed type __int16 word_10090ACE[];
// 10090AD0: using guessed type __int16 word_10090AD0[];
// 10090AD2: using guessed type __int16 word_10090AD2[];
// 10090AD4: using guessed type __int16 word_10090AD4[];
// 10090AD6: using guessed type __int16 word_10090AD6[];

//----- (100140F0) --------------------------------------------------------
signed __int16 __usercall sub_100140F0@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>)
{
  signed __int16 v3; // di@1
  void *v4; // ecx@4
  void *v5; // eax@19
  char v7; // [sp+4h] [bp-38h]@2

  v3 = a2;
  if ( a3 )
    memset(&v7, 0, 0x33u);
  if ( a2 == 300 )
  {
    switch ( sub_1001D4B0(a1) )
    {
      case 1u:
        v3 = 380;
        if ( !a3 )
          return v3;
        sub_1001D870(&v7, "PFD1", 51);
        break;
      case 4u:
        v3 = 381;
        if ( !a3 )
          return v3;
        sub_1001D870(&v7, "MFD1", 51);
        break;
      case 2u:
        v3 = 382;
        if ( !a3 )
          return v3;
        sub_1001D870(&v7, "PFD2", 51);
        break;
      case 0x40u:
        v3 = 383;
        if ( !a3 )
          return v3;
        sub_1001D870(&v7, "GTC1", 51);
        break;
      case 0x80u:
        v3 = 384;
        if ( !a3 )
          return v3;
        sub_1001D870(&v7, "GTC2", 51);
        break;
      case 0x10u:
        v3 = 385;
        if ( !a3 )
          return v3;
        sub_1001D870(&v7, "GTC3", 51);
        break;
      case 0x20u:
        v3 = 386;
        if ( !a3 )
          return v3;
        sub_1001D870(&v7, "GTC4", 51);
        break;
      default:
        v3 = -1;
        v5 = sub_1001D4B0(v4);
        sub_1001D840(byte_101BB7B0, 0x64u, "Unrecognized LRU (%u) passed into DB error alert processing.", v5);
        sub_100129A0("..\\lib\\adl\\sys_updt_alrt_data.c", 1286, 0, byte_101BB7B0);
        break;
    }
  }
  if ( a3 )
    sub_1001D870(a3, &v7, 51);
  return v3;
}

//----- (10014340) --------------------------------------------------------
char __cdecl sub_10014340(signed __int16 a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  char result; // al@2
  char v4; // [sp+Ah] [bp-6h]@1
  char v5; // [sp+Bh] [bp-5h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = (unsigned __int16)sub_100140F0(v1, a1, 0);
  v2 = sub_1001CD60(&v6, 2u, (int)&unk_1008FC52, 8, 415, -1);
  if ( v2 < 0 )
  {
    sub_100129A0("..\\lib\\adl\\sys_updt_alrt_data.c", 152, 0, 0);
    result = 0;
  }
  else
  {
    sub_1003E2F0(*(&dword_1008FC54 + 2 * v2), &v4, 1, &v5);
    result = v4;
  }
  return result;
}

//----- (100143D0) --------------------------------------------------------
char __cdecl sub_100143D0(unsigned __int16 a1)
{
  int v1; // esi@2
  int v2; // eax@2
  char v4; // [sp+6h] [bp-6h]@1
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v5 = 1;
  if ( sub_10013F10(a1, &v6) )
  {
    v1 = v6;
    v2 = sub_1003E2F0(v6, &v4, 1, &v5);
    if ( !v2 && !v4 )
    {
      v4 = 1;
      LOBYTE(v2) = sub_1003E110(v1, (int)&v4, 1);
    }
  }
  else
  {
    sub_1001D840(
      byte_101BB7B0,
      0x64u,
      "An attempt to set a system trigger was performed with an invalid trigger id (%u)",
      a1);
    LOBYTE(v2) = sub_100129A0("..\\lib\\adl\\sys_updt_alrt_data.c", 666, 0, byte_101BB7B0);
  }
  return v2;
}

//----- (10014470) --------------------------------------------------------
char __cdecl sub_10014470(char a1, int a2)
{
  __int16 v2; // ax@1

  v2 = sub_10013F50(a2, a1);
  return sub_100143D0(v2);
}

//----- (10014490) --------------------------------------------------------
bool __cdecl sub_10014490(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  char v6; // al@3
  bool result; // al@6
  void *v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_100160B0(v1);
  v10 = 0;
  v5 = &unk_10071918;
  do
  {
    if ( (unsigned int)v8 & *v5 )
    {
      v6 = sub_1002EC00(v10, 0);
      if ( sub_1002BA30(3, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (10014530) --------------------------------------------------------
int sub_10014530()
{
  int result; // eax@1

  sub_1003E0E0(6361, (int)&flt_101BB814, 4);
  result = sub_1003E0E0(6362, (int)&flt_101BB818, 4);
  dword_101BB81C = 1379255385;
  return result;
}
// 101BB814: using guessed type float flt_101BB814;
// 101BB818: using guessed type float flt_101BB818;
// 101BB81C: using guessed type int dword_101BB81C;

//----- (10014560) --------------------------------------------------------
char __usercall sub_10014560@<al>(int a1@<eax>, float *a2@<esi>, float a3, float a4)
{
  char v4; // cl@1
  char result; // al@5
  void *v6; // [sp+0h] [bp-8h]@0

  v4 = sub_1002BAB0(a1, v6);
  if ( v4 && ((COERCE_UNSIGNED_INT(*a2) & 0x7F800000) == 2139095040 || a3 < (double)*a2 || a4 > (double)*a2) )
  {
    result = 0;
    *a2 = 0.0;
  }
  else
  {
    result = v4;
  }
  return result;
}

//----- (100145C0) --------------------------------------------------------
char __cdecl sub_100145C0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1002BAB0(7, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39950.746
     || *(float *)a1 < -39950.746) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10014620) --------------------------------------------------------
char __cdecl sub_10014620(float *a1)
{
  char v1; // bl@1
  double v2; // st7@2
  double v3; // st7@6
  char result; // al@9
  float v5; // [sp+Ch] [bp-Ch]@1
  float v6; // [sp+10h] [bp-8h]@5
  float v7; // [sp+14h] [bp-4h]@2

  v1 = sub_1002BAB0(53, &v5);
  if ( v1 )
  {
    v2 = v5;
    v7 = v5;
    if ( (LODWORD(v5) & 0x7F800000) == 2139095040 || v2 > 526.79114 || v2 < -526.79114 )
      return 0;
    if ( sub_1002BAB0(59, &v6) )
    {
      v3 = v6;
      v7 = v6;
      if ( (LODWORD(v6) & 0x7F800000) != 2139095040 && v3 <= 526.79114 && v3 >= -526.79114 )
      {
        sub_10040EB0(flt_101BB814, 0.0);
        result = v1;
        v5 = flt_101BB818 * v6 + v5;
        *a1 = v5;
        return result;
      }
    }
    *a1 = v5;
  }
  return v1;
}
// 101BB814: using guessed type float flt_101BB814;
// 101BB818: using guessed type float flt_101BB818;

//----- (10014720) --------------------------------------------------------
char __cdecl sub_10014720(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1002BAB0(2, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 512.0 || *(float *)a1 < -512.0) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10014780) --------------------------------------------------------
char __cdecl sub_10014780(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1002BAB0(9, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 216728.75
     || *(float *)a1 < -216728.75) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (100147E0) --------------------------------------------------------
char __cdecl sub_100147E0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1002BAB0(56, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 1053.5823
     || *(float *)a1 < -1053.5823) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10014840) --------------------------------------------------------
char __cdecl sub_10014840(void *a1)
{
  char v1; // bl@1
  int v2; // eax@7
  char result; // al@9
  float v4; // [sp+14h] [bp-10h]@1
  float v5; // [sp+18h] [bp-Ch]@1
  float v6; // [sp+1Ch] [bp-8h]@1
  float v7; // [sp+20h] [bp-4h]@2

  v5 = 0.0;
  v4 = 0.0;
  v6 = 0.0;
  v1 = sub_1002BAB0(57, a1);
  if ( v1 )
  {
    v7 = *(float *)a1;
    if ( (LODWORD(v7) & 0x7F800000) == 2139095040 || *(float *)a1 > 166.46144 || *(float *)a1 < -166.46144 )
    {
      v1 = 0;
      *(float *)a1 = 0.0;
    }
  }
  sub_1003E0E0(6950, (int)&v4, 4);
  if ( 0.0 != v4 && sub_1002BAB0(66, &v5) && (LOBYTE(v2) = 58, sub_10014560(v2, &v6, 166.46144, -166.46144)) )
  {
    result = 1;
    *(float *)a1 = v4 * v5 + v6;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10014920) --------------------------------------------------------
char __cdecl sub_10014920(float *a1)
{
  float *v1; // esi@1
  char v2; // bl@1

  v1 = a1;
  *a1 = 0.0;
  v2 = sub_100145C0(&a1);
  if ( v2 )
  {
    sub_10015E60(0.0);
    *v1 = *(float *)&a1 + 0.0;
  }
  return v2;
}

//----- (10014950) --------------------------------------------------------
char __cdecl sub_10014950(float *a1)
{
  float *v1; // esi@1
  char result; // al@4
  float v3; // [sp+8h] [bp-4h]@1

  v1 = a1;
  *a1 = 9.8999998e24;
  if ( sub_10014720(&v3) && sub_10014920((float *)&a1) )
  {
    *(float *)&a1 = *(float *)&a1 * 3.280839920043945;
    if ( *(float *)&a1 < 36089.0 )
    {
      result = 1;
      *v1 = v3 - (15.0 - *(float *)&a1 / 1000.0 * 1.981199979782104);
    }
    else
    {
      result = 1;
      *v1 = v3 - -56.5;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100149F0) --------------------------------------------------------
int __cdecl sub_100149F0(void *a1)
{
  float v2; // [sp+0h] [bp-4h]@1

  v2 = 9.8999998e24;
  return sub_1003E0A0(2102, a1, 4, &v2);
}

//----- (10014A20) --------------------------------------------------------
char __cdecl sub_10014A20(float *a1)
{
  char v1; // bl@1
  float v3; // [sp+4h] [bp-4h]@1

  v1 = 0;
  if ( sub_10015BD0(&v3) && (unsigned __int8)sub_1002B7F0() )
  {
    sub_1003DDA0(100, 60000);
    if ( *(float *)(dword_102AD570 + 1548) > -32767.0 )
    {
      v1 = 1;
      *a1 = v3 - *(float *)(dword_102AD570 + 1548);
    }
    sub_1003DD40(100);
  }
  return v1;
}
// 102AD570: using guessed type int dword_102AD570;

//----- (10014A90) --------------------------------------------------------
char __cdecl sub_10014A90(float *a1)
{
  char v1; // bl@1
  float v3; // [sp+4h] [bp-4h]@1

  v1 = 0;
  if ( sub_100145C0(&v3) && (unsigned __int8)sub_1002B7F0() )
  {
    sub_1003DDA0(100, 60000);
    if ( *(float *)(dword_102AD570 + 1548) > -32767.0 )
    {
      v1 = 1;
      *a1 = v3 - *(float *)(dword_102AD570 + 1548);
    }
    sub_1003DD40(100);
  }
  return v1;
}
// 102AD570: using guessed type int dword_102AD570;

//----- (10014B00) --------------------------------------------------------
char __cdecl sub_10014B00(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_100158E0() > 1u;
  v1 = 0;
  v12 = sub_10014490(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_10071F88;
  if ( sub_1001A0C0(0x2E6u) || sub_1001A0C0(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_10071F80;
  v3 = 4;
  do
  {
    if ( sub_1001A0C0(*v2) && sub_1001A1A0(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_10071F90[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_10015C70() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_100160D0(v4) == 2 || sub_100160D0(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (10014C40) --------------------------------------------------------
int __cdecl sub_10014C40(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_10071FA6[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_10071FA6[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (10014D30) --------------------------------------------------------
int __cdecl sub_10014D30(int *a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // eax@9
  int v4; // ecx@9
  signed int v5; // eax@9
  int i; // ecx@9
  int v7; // ecx@13

  result = a2 >> 16;
  if ( HIWORD(a2) > 0x7C5u )
  {
    if ( HIWORD(a2) > 0x84Eu
      || HIWORD(a2) == 2126 && (unsigned __int8)a2 > 2u
      || HIWORD(a2) == 2126 && (_BYTE)a2 == 2 && BYTE1(a2) > 5u )
    {
      *a1 = -23296;
    }
    else
    {
      v3 = (HIWORD(a2) - 1990) / 4;
      v4 = v3;
      v5 = 4 * v3 + 1990;
      for ( i = 1461 * v4; v5 < HIWORD(a2); ++v5 )
      {
        i += 365;
        if ( !(v5 % 4) )
          ++i;
      }
      v7 = *(_WORD *)&word_10071FA6[2 * (unsigned __int8)a2] + i;
      if ( (unsigned __int8)a2 > 2u && !(HIWORD(a2) % 4) )
        ++v7;
      result = 86400 * (v7 + BYTE1(a2));
      *a1 = result;
    }
  }
  else
  {
    result = (int)a1;
    *a1 = 0;
  }
  return result;
}

//----- (10014E20) --------------------------------------------------------
__int16 __cdecl sub_10014E20(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (10014E70) --------------------------------------------------------
int __cdecl sub_10014E70(int *a1, unsigned int a2)
{
  int result; // eax@1

  result = (a2 >> 24) + 60 * ((unsigned __int8)(a2 >> 16) + 60 * (unsigned __int16)a2);
  *a1 = result;
  return result;
}

//----- (10014EA0) --------------------------------------------------------
__int16 __cdecl sub_10014EA0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_10014E20((int)&v5, *a1);
  sub_10014C40((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (10014F20) --------------------------------------------------------
int __cdecl sub_10014F20(unsigned __int64 a1)
{
  unsigned int v1; // ST10_4@1
  unsigned int v3; // [sp+4h] [bp-4h]@1

  LOBYTE(v1) = (HIDWORD(a1) >> 16) & 0xF;
  HIWORD(v1) = (HIDWORD(a1) >> 20) & 0xFFF;
  BYTE1(v1) = (HIDWORD(a1) >> 11) & 0x1F;
  LOWORD(v3) = (HIDWORD(a1) >> 6) & 0x1F;
  BYTE2(v3) = BYTE4(a1) & 0x3F;
  BYTE3(v3) = (a1 >> 26) & 0x3F;
  sub_10014D30((int *)&a1, v1);
  sub_10014E70((int *)&v3, v3);
  return v3 + a1;
}

//----- (10014FB0) --------------------------------------------------------
int __cdecl sub_10014FB0(void *a1)
{
  int result; // eax@6

  if ( !sub_100136E0(0, 196, a1) )
    return 0;
  if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 7620.0 )
  {
    result = 0;
    *(float *)a1 = 7620.0;
  }
  else
  {
    if ( *(float *)a1 < -3048.0 )
    {
      *(float *)a1 = -3048.0;
      return 0;
    }
    result = 1;
  }
  return result;
}

//----- (10015020) --------------------------------------------------------
char __cdecl sub_10015020(int a1, void *a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // ecx@1
  int v5; // edi@1
  char result; // al@5
  int v7; // eax@7
  int v8; // ebp@7
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@1
  float v11; // [sp+10h] [bp-8h]@1

  v11 = 9.8999998e24;
  *(float *)a2 = 9.8999998e24;
  LOBYTE(v9) = 0;
  v10 = 0;
  v2 = sub_1002ED50(a1);
  v3 = sub_1002ECD0(a1);
  v5 = v3;
  if ( !v2 )
    goto LABEL_15;
  if ( !v3 )
    return sub_100187B0(a1, a2);
  if ( *(_WORD *)(v2 + 12) != 6 )
    goto LABEL_15;
  if ( sub_100160D0(v4) == 4 )
  {
    *(float *)a2 = *(float *)(v2 + 8);
    return 1;
  }
  if ( (unsigned __int8)(*(_BYTE *)(v5 + 2) - 1) <= 2u )
  {
    v7 = sub_1002EC20(&v9, (void *)(v5 + 4), 0xCu, 27, 100);
    *(float *)a2 = v11;
    v8 = v7;
    result = sub_1003DC90() - v10 < (unsigned int)(unsigned __int16)word_10072060[*(_BYTE *)(v5 + 3)] ? v9 : 0;
    if ( v8 >= 0 )
    {
      if ( result )
        result = sub_100183B0(v2, (float *)a2);
    }
    else
    {
      sub_100129A0("..\\lib\\acl\\dat\\dat_proc_float.c", 174, 0, 0);
      result = 0;
    }
  }
  else
  {
LABEL_15:
    result = 0;
  }
  return result;
}
// 10072060: using guessed type __int16 word_10072060[];

//----- (10015180) --------------------------------------------------------
char __fastcall sub_10015180(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  BYTE3(v2) = 0;
  if ( sub_1003E040(2018, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 2u) )
  {
    BYTE3(v2) = 0;
    sub_1003E110(2018, (int)&v2 + 3, 1);
    result = BYTE3(v2);
  }
  return result;
}

//----- (100151D0) --------------------------------------------------------
char __cdecl sub_100151D0(unsigned int a1)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // ebx@1
  unsigned int v3; // ebx@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@4
  char result; // al@4
  unsigned __int8 v7; // [sp+8h] [bp+4h]@1

  v1 = a1 / 0x3E8;
  v2 = a1 % 0x3E8;
  v7 = a1 % 0x3E8 / 0x64;
  v3 = -100 * v7 + v2;
  v4 = v3 / 0xA;
  if ( (unsigned __int8)v1 >= 8u || v7 >= 8u || (unsigned __int8)v4 >= 8u || (v5 = v3 - 10 * v4, result = 1, v5 >= 8u) )
    result = 0;
  return result;
}

//----- (10015240) --------------------------------------------------------
char __cdecl sub_10015240(char a1)
{
  char result; // al@1

  result = 0;
  if ( !a1 )
  {
    if ( sub_1002E830(33) || sub_1002E860(17) )
      return 1;
    return 0;
  }
  if ( a1 != 1 )
    return result;
  if ( !sub_1002E830(34) && !sub_1002E860(19) )
    return 0;
  return 1;
}

//----- (10015290) --------------------------------------------------------
char __cdecl sub_10015290(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1002E830(11);
  }
  else
  {
    result = sub_1002E830(5);
  }
  return result;
}

//----- (100152C0) --------------------------------------------------------
char __cdecl sub_100152C0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_1001A0C0(0x1EDu);
  }
  else
  {
    result = sub_1001A0C0(0x1ECu);
  }
  return result;
}

//----- (100152F0) --------------------------------------------------------
char __usercall sub_100152F0@<al>(unsigned __int8 a1@<al>, _BYTE *a2)
{
  int v2; // ecx@1

  v2 = 0;
  while ( (a1 & (unsigned __int8)byte_10072F20[2 * v2]) != byte_10072F20[2 * v2] )
  {
    if ( ++v2 >= 5 )
      return 0;
  }
  *a2 = byte_10072F21[2 * v2];
  return 1;
}

//----- (10015320) --------------------------------------------------------
char __cdecl sub_10015320(void *a1, int a2)
{
  unsigned __int8 v2; // al@3
  char v3; // al@6
  bool v4; // al@8
  bool v5; // zf@8
  char v6; // cl@8
  int v7; // eax@8
  unsigned __int8 v8; // al@18
  int v9; // ecx@18
  int v10; // edx@18
  char v11; // al@22
  char result; // al@32
  char v13; // [sp+Ah] [bp-4Eh]@1
  bool v14; // [sp+Bh] [bp-4Dh]@1
  int v15; // [sp+Ch] [bp-4Ch]@1
  int v16; // [sp+10h] [bp-48h]@1
  unsigned __int8 v17; // [sp+14h] [bp-44h]@13
  int v18; // [sp+18h] [bp-40h]@14
  char v19; // [sp+20h] [bp-38h]@5
  char v20; // [sp+23h] [bp-35h]@10
  char v21; // [sp+26h] [bp-32h]@8
  int v22; // [sp+4Ah] [bp-Eh]@6
  char v23; // [sp+52h] [bp-6h]@8

  *(_DWORD *)a1 = 0;
  *((_DWORD *)a1 + 1) = 0;
  *((_DWORD *)a1 + 2) = 0;
  *((_DWORD *)a1 + 3) = 0;
  v14 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  if ( (unsigned __int8)a2 >= 2u )
    goto LABEL_25;
  if ( !sub_100152C0(a2) )
  {
    if ( !sub_10015240(a2) )
    {
      if ( (unsigned __int8)a2 == 1 )
        v11 = sub_100136E0(1, 1221, a1);
      else
        v11 = sub_100136E0(1, 1209, a1);
      v13 = v11;
      goto LABEL_25;
    }
    if ( sub_1002EE10(a2, 1, &v17)
      && sub_1002F050(v18, &v15)
      && sub_1002F050(HIWORD(v18), &v16)
      && sub_100152F0(v17, (_BYTE *)a1 + 3)
      && sub_1002EE10(a2, 2, &v17) )
    {
      v8 = v17;
      v5 = (v17 & 0x80) == -128;
      v9 = (unsigned __int16)v15;
      *(_BYTE *)a1 = (v17 & 0x10) == 16;
      *((_BYTE *)a1 + 2) = v5;
      v10 = (unsigned __int16)v16;
      v13 = 1;
      *((_DWORD *)a1 + 3) = v9;
      *((_DWORD *)a1 + 2) = v10;
      if ( v8 & 2 )
        *((_BYTE *)a1 + 1) = 2;
      else
        *((_BYTE *)a1 + 1) = (v8 & 8) == 8;
      goto LABEL_25;
    }
LABEL_11:
    v13 = 0;
    goto LABEL_25;
  }
  v2 = sub_1001CD60(&a2, 1u, (int)&unk_10072F10, 4, 2, 0);
  if ( !sub_1001A1A0((unsigned __int16)word_10072F12[2 * v2], &v13) || !v13 )
    goto LABEL_11;
  if ( !sub_1002EF40(&v19) || (v3 = sub_1002F050(v22, &v15), v13 = 1, !v3) )
    v13 = 0;
  v4 = sub_1002EF90();
  v5 = v23 == 1;
  v6 = v21;
  *(_BYTE *)a1 = v4;
  v7 = (unsigned __int16)v15;
  *((_BYTE *)a1 + 3) = 0;
  *((_BYTE *)a1 + 2) = v6;
  *((_DWORD *)a1 + 3) = v7;
  *((_DWORD *)a1 + 2) = v7;
  if ( v5 )
    *((_BYTE *)a1 + 1) = 2;
  else
    *((_BYTE *)a1 + 1) = v20 == 0;
LABEL_25:
  if ( sub_1002E360((unsigned __int8 *)a1)
    || !sub_100151D0(*((_DWORD *)a1 + 2))
    || !sub_100151D0(*((_DWORD *)a1 + 3))
    || sub_10015290(a2) && *((_BYTE *)a1 + 1) == 3 )
  {
    result = 0;
  }
  else
  {
    sub_1003E040(9241, (int)&v14, 1);
    if ( v14 != (*(_BYTE *)a1 == 1) )
    {
      v14 = *(_BYTE *)a1 == 1;
      sub_1003E110(9241, (int)&v14, 1);
    }
    result = v13;
  }
  return result;
}
// 10072F12: using guessed type __int16 word_10072F12[];

//----- (100155D0) --------------------------------------------------------
char __cdecl sub_100155D0(void *a1)
{
  int v1; // ecx@0
  int v2; // ST08_4@1

  v2 = v1;
  LOBYTE(v2) = sub_10015180(v1);
  return sub_10015320(a1, v2);
}

//----- (100155F0) --------------------------------------------------------
signed int sub_100155F0()
{
  return sub_1003ED70((int)&off_10073674);
}
// 10073674: using guessed type char *off_10073674;

//----- (10015600) --------------------------------------------------------
int sub_10015600()
{
  int result; // eax@3

  if ( (unsigned __int8)byte_101BB824 <= 1u )
  {
    result = sub_1003DD40(98);
    byte_101BB824 = 0;
  }
  else
  {
    --byte_101BB824;
  }
  return result;
}
// 101BB824: using guessed type char byte_101BB824;

//----- (10015630) --------------------------------------------------------
char sub_10015630()
{
  char result; // al@2

  if ( sub_1003DFA0(98) )
  {
    result = 1;
    ++byte_101BB824;
  }
  else if ( sub_1003DDA0(98, 500) )
  {
    byte_101BB824 = 0;
    result = 0;
  }
  else
  {
    result = 1;
    byte_101BB824 = 1;
  }
  return result;
}
// 101BB824: using guessed type char byte_101BB824;

//----- (10015670) --------------------------------------------------------
char __cdecl sub_10015670(char a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  BYTE3(v3) = 0;
  if ( (unsigned __int8)sub_100155F0() && sub_10015630() )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        BYTE3(v3) = *(_BYTE *)(dword_101BB820 + 90120);
      }
      else if ( a1 == 2 )
      {
        BYTE3(v3) = *(_BYTE *)(dword_101BB820 + 90980);
      }
    }
    else
    {
      BYTE3(v3) = *(_BYTE *)(dword_101BB820 + 90102);
    }
    sub_10015600();
  }
  sub_1001AAF0((unsigned __int8 *)&v3 + 3, 0, 0xFFu, 0, 1);
  return BYTE3(v3);
}
// 101BB820: using guessed type int dword_101BB820;

//----- (10015700) --------------------------------------------------------
int __cdecl sub_10015700(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (10015720) --------------------------------------------------------
int __cdecl sub_10015720(int a1, double a2, double a3)
{
  long double v3; // st6@1
  long double v4; // st4@1
  int result; // eax@3
  double v6; // st7@6
  double v7; // [sp+0h] [bp-10h]@6
  double v8; // [sp+8h] [bp-8h]@6

  v3 = fabs(a2);
  v4 = fabs(a3);
  if ( v3 > 1.5707963267949 || v4 >= 3.1415926535898 )
  {
    if ( v3 > 4.7123889803847 || v4 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = a2;
      v8 = a3;
      sub_1002C110((int)&v7);
      v6 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v6;
      *(_DWORD *)(a1 + 4) = (signed int)v6;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(a2 * 683565275.5764301);
    result = (signed int)(683565275.5764301 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (10015800) --------------------------------------------------------
int __cdecl sub_10015800(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10015850) --------------------------------------------------------
void sub_10015850()
{
  dword_102AD58C = -15;
}
// 102AD58C: using guessed type int dword_102AD58C;

//----- (10015860) --------------------------------------------------------
signed int sub_10015860()
{
  return sub_1003ED70((int)&off_100736C8);
}
// 100736C8: using guessed type char *off_100736C8;

//----- (10015870) --------------------------------------------------------
char __usercall sub_10015870@<al>(float *a1@<esi>)
{
  char result; // al@1
  int v2; // ecx@1
  __int16 v3; // dx@1
  double v4; // st7@4
  float v5; // ST08_4@6

  result = 0;
  *a1 = 9.9999996e24;
  v2 = dword_102AD58C;
  v3 = *(_WORD *)(dword_102AD58C + 1456);
  if ( v3 == 3 || v3 == 5 )
  {
    if ( *(_BYTE *)(dword_102AD58C + 1296) )
    {
      v4 = sub_1002F660(*(_DWORD *)(dword_102AD58C + 1292));
      v2 = dword_102AD58C;
    }
    else
    {
      v4 = 0.0;
    }
    v5 = v4;
    result = 1;
    *a1 = *(float *)(v2 + 1520) * v5 + *(float *)(v2 + 1468);
  }
  return result;
}
// 102AD58C: using guessed type int dword_102AD58C;

//----- (100158E0) --------------------------------------------------------
signed int sub_100158E0()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_10015860() )
    v0 = *(_BYTE *)(dword_102AD58C + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 102AD58C: using guessed type int dword_102AD58C;

//----- (10015910) --------------------------------------------------------
int __cdecl sub_10015910(int a1)
{
  int result; // eax@2

  if ( (unsigned __int8)sub_10015860() )
  {
    sub_1003DDA0(101, 60000);
    *(_BYTE *)a1 = *(_BYTE *)(dword_102AD58C + 1458);
    *(float *)(a1 + 4) = *(float *)(dword_102AD58C + 1492);
    *(float *)(a1 + 8) = *(float *)(dword_102AD58C + 1496);
    *(float *)(a1 + 12) = *(float *)(dword_102AD58C + 1500);
    *(float *)(a1 + 16) = *(float *)(dword_102AD58C + 1504);
    *(float *)(a1 + 20) = *(float *)(dword_102AD58C + 1508);
    result = sub_1003DD40(101);
  }
  else
  {
    result = a1;
    *(float *)(a1 + 4) = 0.0;
    *(_BYTE *)a1 = 1;
    *(float *)(a1 + 8) = 9.9999996e24;
    *(float *)(a1 + 12) = 9.9999996e24;
    *(float *)(a1 + 20) = 9.9999996e24;
    *(float *)(a1 + 16) = 0.0;
  }
  return result;
}
// 102AD58C: using guessed type int dword_102AD58C;

//----- (100159B0) --------------------------------------------------------
bool __cdecl sub_100159B0(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_1003E040(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_10015860() )
  {
    sub_1003DDA0(101, 10000);
    v3 = 0.0;
    v4 = dword_102AD58C;
    v2 = *(_WORD *)(dword_102AD58C + 1456) > 1u;
    if ( *(_BYTE *)(dword_102AD58C + 1296) )
    {
      v14 = sub_1002F660(*(_DWORD *)(dword_102AD58C + 1292));
      v4 = dword_102AD58C;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_10015800(6.2831853071796, -6.2831853071796);
      sub_10015800(6.2831853071796, -6.2831853071796);
      sub_10042050(v14, dword_102AD58C + 1512, (int)&v17);
      v4 = dword_102AD58C;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_10042020((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_102AD58C;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_102AD58C + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_1003DD40(101);
    sub_1002C110(a2);
  }
  return v2;
}
// 102AD58C: using guessed type int dword_102AD58C;

//----- (10015BD0) --------------------------------------------------------
char __cdecl sub_10015BD0(float *a1)
{
  char v1; // bl@1

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_10015860() )
  {
    sub_1003DDA0(101, 60000);
    v1 = sub_10015870(a1);
    if ( v1 )
      *a1 = *(float *)(dword_102AD58C + 1440) + *a1;
    sub_1003DD40(101);
  }
  return v1;
}
// 102AD58C: using guessed type int dword_102AD58C;

//----- (10015C30) --------------------------------------------------------
char __cdecl sub_10015C30(float *a1)
{
  char v1; // bl@1

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_10015860() )
  {
    sub_1003DDA0(101, 60000);
    v1 = sub_10015870(a1);
    sub_1003DD40(101);
  }
  return v1;
}
// 1003DD40: using guessed type double __cdecl sub_1003DD40(_DWORD);

//----- (10015C70) --------------------------------------------------------
char sub_10015C70()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_10015860() )
  {
    sub_1003DDA0(101, 10000);
    if ( !*(_BYTE *)(dword_102AD58C + 1444)
      || !*(_BYTE *)(dword_102AD58C + 1451)
      || (v0 = 1, *(_WORD *)(dword_102AD58C + 1456) <= 1u)
      || *(float *)(dword_102AD58C + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_1003DD40(101);
  }
  return v0;
}
// 102AD58C: using guessed type int dword_102AD58C;

//----- (10015CE0) --------------------------------------------------------
bool __cdecl sub_10015CE0(float *a1)
{
  bool v1; // bl@1
  double v2; // st7@3

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_10015860() )
  {
    sub_1003DDA0(101, 10000);
    if ( *(_BYTE *)(dword_102AD58C + 1444) )
      v2 = (double)(unsigned int)(sub_1003DC90() - *(_DWORD *)(dword_102AD58C + 1292))
         / 1000.0
         * *(float *)(dword_102AD58C + 1488)
         + *(float *)(dword_102AD58C + 1484);
    else
      v2 = *(float *)(dword_102AD58C + 1484);
    *a1 = v2;
    *a1 = sub_10041C10(*a1);
    v1 = *(_WORD *)(dword_102AD58C + 1456) > 1u;
    sub_1003DD40(101);
  }
  return v1;
}
// 1003DD40: using guessed type double __cdecl sub_1003DD40(_DWORD);
// 102AD58C: using guessed type int dword_102AD58C;

//----- (10015D90) --------------------------------------------------------
bool __cdecl sub_10015D90(float *a1)
{
  bool v1; // bl@1
  int v2; // eax@2

  *a1 = 0.0;
  v1 = 0;
  if ( (unsigned __int8)sub_10015860() )
  {
    sub_1003DDA0(101, 60000);
    v2 = dword_102AD58C;
    if ( *(_BYTE *)(dword_102AD58C + 1451) )
    {
      *a1 = *(float *)(dword_102AD58C + 1480);
      v2 = dword_102AD58C;
    }
    v1 = *(_WORD *)(v2 + 1456) > 1u;
    sub_1003DD40(101);
  }
  return v1;
}
// 102AD58C: using guessed type int dword_102AD58C;

//----- (10015DF0) --------------------------------------------------------
char __cdecl sub_10015DF0(float *a1, float *a2)
{
  char v2; // bl@1
  __int16 v3; // cx@2
  float *v4; // eax@4

  *a1 = 9.9999996e24;
  *a2 = 9.9999996e24;
  v2 = 0;
  if ( (unsigned __int8)sub_10015860() )
  {
    sub_1003DDA0(101, 60000);
    v3 = *(_WORD *)(dword_102AD58C + 1456);
    if ( v3 == 3 || v3 == 5 )
    {
      v4 = (float *)(dword_102AD58C + 1520);
      *a1 = *(float *)(dword_102AD58C + 1520);
      v2 = 1;
      *a2 = *v4;
    }
    sub_1003DD40(101);
  }
  return v2;
}
// 102AD58C: using guessed type int dword_102AD58C;

//----- (10015E60) --------------------------------------------------------
void __usercall sub_10015E60(double a1@<st0>)
{
  float v1; // ST00_4@1

  sub_1001A6C0();
  v1 = a1;
  sub_10040CA0(v1);
}

//----- (10015E80) --------------------------------------------------------
char __thiscall sub_10015E80(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1003E2F0(3180, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10015EB0) --------------------------------------------------------
char __thiscall sub_10015EB0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_1003E2F0(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10015EE0) --------------------------------------------------------
signed int __cdecl sub_10015EE0(char a1)
{
  return 1 << a1;
}

//----- (10015EF0) --------------------------------------------------------
char __thiscall sub_10015EF0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 18;
  sub_1003E2F0(3005, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10015F20) --------------------------------------------------------
char __thiscall sub_10015F20(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_1003E2F0(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (10015F50) --------------------------------------------------------
int sub_10015F50()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_1003E2F0(3012, &v2, 4, &v1);
  return v2;
}

//----- (10015F80) --------------------------------------------------------
char __fastcall sub_10015F80(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_1003DB80(42, (_BYTE *)&v2 + 2);
  if ( sub_1003E040(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_1003E1D0(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (10015FD0) --------------------------------------------------------
char __cdecl sub_10015FD0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420DC: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);

//----- (10015FF0) --------------------------------------------------------
int __cdecl sub_10015FF0(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_100129A0("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_100129A0("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420E2: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (10016050) --------------------------------------------------------
char __thiscall sub_10016050(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015FF0(35, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10016070) --------------------------------------------------------
char __thiscall sub_10016070(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015FF0(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10016090) --------------------------------------------------------
char __thiscall sub_10016090(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015FF0(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100160B0) --------------------------------------------------------
void *__thiscall sub_100160B0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10015FF0(29, (char *)&v2);
  return v2;
}

//----- (100160D0) --------------------------------------------------------
char __thiscall sub_100160D0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015FF0(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100160F0) --------------------------------------------------------
char __thiscall sub_100160F0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10015FF0(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (10016110) --------------------------------------------------------
BOOL sub_10016110()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = 1;
  sub_10015FF0(49, &v1);
  return v1 == 0;
}

//----- (10016130) --------------------------------------------------------
int __cdecl sub_10016130(char a1)
{
  return sub_10015FF0(56, &a1);
}

//----- (10016140) --------------------------------------------------------
void __cdecl sub_10016140(float a1, float a2, char a3)
{
  int v3; // eax@1
  float *v4; // edi@2
  int v5; // esi@3
  double v6; // st7@8
  float v7; // ST20_4@10
  int v8; // esi@13
  int v9; // edi@14
  float v10; // [sp+0h] [bp-2Ch]@1
  char v11; // [sp+8h] [bp-24h]@3

  v3 = 0;
  v10 = a1;
  if ( byte_101BD5E8 )
  {
    v4 = flt_101BD5FC;
    do
    {
      v5 = v3 + 1;
      sub_1001D840(&v11, 0x1Fu, "_mach_curve_%d", v3 + 1);
      if ( a3 && *(v4 - 3) <= (double)a2 && *(v4 - 2) >= (double)a2 && sub_10013910((int)&v11) )
      {
        v6 = 9.8999998e24 == *(v4 - 1) ? *v4 : (a2 - *v4) / *(v4 - 1);
        v7 = v6;
        if ( v7 <= (double)v10 )
          v10 = v6;
      }
      v3 = v5;
      v4 += 4;
    }
    while ( v5 < (unsigned __int8)byte_101BD5E8 );
  }
  v8 = 0;
  if ( byte_101BD5EA )
  {
    do
    {
      v9 = v8 + 1;
      sub_1001D840(&v11, 0x1Fu, "_mach_ovrspd_%d", v8 + 1);
      if ( sub_10013910((int)&v11) )
      {
        if ( v10 > (double)flt_101BD730[v8] )
          v10 = flt_101BD730[v8];
      }
      ++v8;
    }
    while ( v9 < (unsigned __int8)byte_101BD5EA );
  }
}
// 101BD5E8: using guessed type char byte_101BD5E8;
// 101BD5EA: using guessed type char byte_101BD5EA;
// 101BD5FC: using guessed type float flt_101BD5FC[];
// 101BD730: using guessed type float flt_101BD730[];

//----- (10016280) --------------------------------------------------------
void __cdecl sub_10016280(float a1)
{
  int v1; // esi@1
  int v2; // edi@2
  float v3; // [sp+0h] [bp-2Ch]@1
  float v4; // [sp+4h] [bp-28h]@2
  char v5; // [sp+8h] [bp-24h]@2

  v1 = 0;
  v3 = a1;
  if ( byte_101BD5E9 )
  {
    do
    {
      v2 = v1 + 1;
      sub_1001D840(&v5, 0x1Fu, "_ovrspd_alrt_%d", v1 + 1);
      v4 = flt_101BD598[v1] * 1.943844437599182;
      if ( sub_10013910((int)&v5) )
      {
        if ( v3 > (double)v4 )
          v3 = v4;
      }
      ++v1;
    }
    while ( v2 < (unsigned __int8)byte_101BD5E9 );
  }
}
// 101BD598: using guessed type float flt_101BD598[];
// 101BD5E9: using guessed type char byte_101BD5E9;

//----- (10016320) --------------------------------------------------------
void sub_10016320()
{
  char v0; // al@1
  char v1; // al@5
  char v2; // al@9
  int v3; // ecx@14
  int v4; // edi@14
  float v5; // esi@15
  float v6; // edx@15
  double v7; // st3@17
  double v8; // st3@19
  double v9; // st3@21
  double v10; // st3@21
  char v11; // [sp+7h] [bp-149h]@1
  float v12; // [sp+8h] [bp-148h]@15
  float v13; // [sp+Ch] [bp-144h]@15
  float v14; // [sp+10h] [bp-140h]@11
  int v15; // [sp+14h] [bp-13Ch]@15
  float v16; // [sp+18h] [bp-138h]@19
  int v17[77]; // [sp+1Ch] [bp-134h]@15

  v11 = 0;
  sub_1003E0A0(6350, &byte_101BD5E9, 1, &v11);
  sub_1003E0A0(6527, &byte_101BD5EA, 1, &v11);
  sub_1003E0A0(6679, &byte_101BD5E8, 1, &v11);
  v0 = byte_101BD5E9;
  if ( (unsigned __int8)byte_101BD5E9 >= 0x14u )
    v0 = 20;
  byte_101BD5E9 = v0;
  if ( sub_1003E040(6351, (int)flt_101BD598, 80) )
    byte_101BD5E9 = 0;
  v1 = byte_101BD5EA;
  if ( (unsigned __int8)byte_101BD5EA >= 0x14u )
    v1 = 20;
  byte_101BD5EA = v1;
  if ( sub_1003E040(6528, (int)flt_101BD730, 80) )
    byte_101BD5EA = 0;
  v2 = byte_101BD5E8;
  if ( (unsigned __int8)byte_101BD5E8 >= 0x14u )
    v2 = 20;
  byte_101BD5E8 = v2;
  if ( sub_1003E040(6680, (int)&v14, 320) )
  {
    byte_101BD5E8 = 0;
  }
  else if ( (signed int)(unsigned __int8)byte_101BD5E8 > 0 )
  {
    v3 = 0;
    v4 = (unsigned __int8)byte_101BD5E8;
    do
    {
      v6 = *(float *)&v17[v3];
      v13 = *(float *)((char *)&v15 + v3 * 4);
      v5 = v13;
      v12 = v13;
      if ( SLODWORD(v13) >= SLODWORD(v6) )
        v12 = v6;
      v7 = (double)SLODWORD(v12);
      v12 = v13;
      flt_101BD5F0[v3] = v7 * 0.3048000037670135;
      if ( SLODWORD(v5) <= SLODWORD(v6) )
        v12 = v6;
      flt_101BD5F4[v3] = (double)SLODWORD(v12) * 0.3048000037670135;
      v8 = *(float *)((char *)&v16 + v3 * 4) - *(float *)((char *)&v14 + v3 * 4);
      if ( 0.0 == v8 || (LODWORD(v12) = LODWORD(v5) - LODWORD(v6), (double)(LODWORD(v5) - LODWORD(v6)) == 0.0) )
      {
        flt_101BD5F8[v3] = 9.8999998e24;
        v10 = *(float *)((char *)&v14 + v3 * 4);
      }
      else
      {
        v12 = (double)(LODWORD(v6) - LODWORD(v5)) * 0.3048000037670135 / v8;
        v9 = v12;
        flt_101BD5F8[v3] = v12;
        v10 = (double)SLODWORD(v13) * 0.3048000037670135 - v9 * *(float *)((char *)&v14 + v3 * 4);
      }
      flt_101BD5FC[v3] = v10;
      v3 += 4;
      --v4;
    }
    while ( v4 );
  }
}
// 101BD598: using guessed type float flt_101BD598[];
// 101BD5E8: using guessed type char byte_101BD5E8;
// 101BD5E9: using guessed type char byte_101BD5E9;
// 101BD5EA: using guessed type char byte_101BD5EA;
// 101BD5F0: using guessed type float flt_101BD5F0[];
// 101BD5F4: using guessed type float flt_101BD5F4[];
// 101BD5F8: using guessed type float flt_101BD5F8[];
// 101BD5FC: using guessed type float flt_101BD5FC[];
// 101BD730: using guessed type float flt_101BD730[];
// 10016320: using guessed type int var_134[77];

//----- (10016500) --------------------------------------------------------
char __cdecl sub_10016500(int a1, void *a2)
{
  char result; // al@1
  unsigned __int8 v3; // dl@1

  memset(a2, 0, 0x48u);
  result = 0;
  v3 = 0;
  do
  {
    if ( result )
      break;
    if ( a1 & *(_DWORD *)(dword_102AD588 + 72 * v3 + 1704) )
    {
      qmemcpy(a2, (const void *)(dword_102AD588 + 72 * v3 + 1660), 0x48u);
      result = 1;
    }
    ++v3;
  }
  while ( v3 < 0x1Eu );
  return result;
}
// 102AD588: using guessed type int dword_102AD588;

//----- (10016560) --------------------------------------------------------
void *__usercall sub_10016560@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_1003E040(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_1003E190(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (100165B0) --------------------------------------------------------
signed int sub_100165B0()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_102AD588 = 0;
  v4 = 0;
  sub_1003DB80(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_1003E110(3201, (int)&v4, 1);
    sub_1003DBB0(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_1003E110(3201, (int)&v4, 1);
    sub_1003DBB0(94, (int)&v4);
  }
  sub_10016560(1u, 6011, &unk_101BD780);
  sub_10016560(0x16u, 6194, &unk_101BD781);
  sub_10016560(1u, 6012, &unk_101BD797);
  sub_10016560(1u, 6013, &unk_101BD798);
  sub_10016560(1u, 6014, &unk_101BD799);
  sub_10016560(1u, 6015, &unk_101BD79A);
  sub_10016560(4u, 6078, &unk_101BD79C);
  sub_10016560(4u, 6104, &unk_101BD7A0);
  sub_10016560(0x20u, 6016, &unk_101BD7A4);
  sub_10016560(0x20u, 6017, &unk_101BD7C4);
  sub_10016560(0x20u, 6018, &unk_101BD7E4);
  sub_10016560(0x20u, 6019, &unk_101BD804);
  sub_10016560(0x20u, 6020, &unk_101BD824);
  sub_10016560(0x20u, 6021, &unk_101BD844);
  sub_10016560(0x20u, 6022, &unk_101BD864);
  sub_10016560(0x20u, 6023, &unk_101BD884);
  sub_10016560(0x20u, 6024, &unk_101BD8A4);
  sub_10016560(0x20u, 6025, &unk_101BD8C4);
  sub_10016560(0x20u, 6026, &unk_101BD8E4);
  sub_10016560(0x20u, 6027, &unk_101BD904);
  sub_10016560(0x20u, 6028, &unk_101BD924);
  sub_10016560(0x20u, 6029, &unk_101BD944);
  sub_10016560(0x20u, 6030, &unk_101BD964);
  sub_10016560(0x20u, 6031, &unk_101BD984);
  sub_10016560(0x20u, 6032, &unk_101BD9A4);
  sub_10016560(0x20u, 6033, &unk_101BD9C4);
  sub_10016560(0x20u, 6034, &unk_101BD9E4);
  sub_10016560(0x20u, 6035, &unk_101BDA04);
  sub_10016560(0x20u, 6036, &unk_101BDA24);
  sub_10016560(0x20u, 6037, &unk_101BDA44);
  sub_10016560(0x20u, 6038, &unk_101BDA64);
  sub_10016560(0x20u, 6039, &unk_101BDA84);
  sub_10016560(0x20u, 6040, &unk_101BDAA4);
  sub_10016560(0x20u, 6041, &unk_101BDAC4);
  sub_10016560(0x20u, 6042, &unk_101BDAE4);
  sub_10016560(0x20u, 6043, &unk_101BDB04);
  sub_10016560(4u, 6044, &unk_101BDB24);
  sub_10016560(4u, 6045, &unk_101BDB28);
  sub_10016560(4u, 6046, &unk_101BDB2C);
  sub_10016560(4u, 6357, &unk_101BDB30);
  sub_10016560(4u, 6358, &unk_101BDB34);
  sub_10016560(4u, 6359, &unk_101BDB38);
  sub_10016560(0x20u, 6047, &unk_101BDB3C);
  sub_10016560(0x20u, 6048, &unk_101BDB5C);
  sub_10016560(0x20u, 6049, &unk_101BDB7C);
  sub_10016560(0x20u, 6050, &unk_101BDB9C);
  sub_10016560(0x20u, 6051, &unk_101BDBBC);
  sub_10016560(0x20u, 6052, &unk_101BDBDC);
  sub_10016560(0x20u, 6053, &unk_101BDBFC);
  sub_10016560(0x20u, 6054, &unk_101BDC1C);
  sub_10016560(1u, 6511, &unk_101BDC3C);
  sub_10016560(1u, 6522, &unk_101BDC3D);
  sub_10016560(1u, 6057, &unk_101BDC3E);
  sub_10016560(0x20u, 6075, &unk_101BDC90);
  sub_10016560(0x20u, 6076, &unk_101BDCB0);
  sub_10016560(1u, 6077, &unk_101BDCD0);
  sub_10016560(4u, 6079, &unk_101BDCD4);
  sub_10016560(4u, 6080, &unk_101BDCD8);
  sub_10016560(0x20u, 6082, &unk_101BDCDC);
  sub_10016560(0x20u, 6083, &unk_101BDCFC);
  sub_10016560(0x20u, 6084, &unk_101BDD1C);
  sub_10016560(0x20u, 6085, &unk_101BDD3C);
  sub_10016560(0x20u, 6086, &unk_101BDD5C);
  sub_10016560(0x20u, 6087, &unk_101BDD7C);
  sub_10016560(0x20u, 6088, &unk_101BDD9C);
  sub_10016560(0x20u, 6089, &unk_101BDDBC);
  sub_10016560(0x20u, 6123, &unk_101BDDDC);
  sub_10016560(0x48u, 6906, &unk_101BDDFC);
  sub_10016560(0x48u, 6907, &unk_101BDE44);
  sub_10016560(0x48u, 6908, &unk_101BDE8C);
  sub_10016560(0x48u, 6909, &unk_101BDED4);
  sub_10016560(0x48u, 6910, &unk_101BDF1C);
  sub_10016560(0x48u, 6911, &unk_101BDF64);
  sub_10016560(0x48u, 6912, &unk_101BDFAC);
  sub_10016560(0x48u, 6913, &unk_101BDFF4);
  sub_10016560(0x48u, 6914, &unk_101BE03C);
  sub_10016560(0x48u, 6915, &unk_101BE084);
  sub_10016560(0x48u, 6916, &unk_101BE0CC);
  sub_10016560(0x48u, 6917, &unk_101BE114);
  sub_10016560(0x48u, 6918, &unk_101BE15C);
  sub_10016560(0x48u, 6919, &unk_101BE1A4);
  sub_10016560(0x48u, 6920, &unk_101BE1EC);
  sub_10016560(0x48u, 6921, &unk_101BE234);
  sub_10016560(0x48u, 6922, &unk_101BE27C);
  sub_10016560(0x48u, 6923, &unk_101BE2C4);
  sub_10016560(0x48u, 6924, &unk_101BE30C);
  sub_10016560(0x48u, 6925, &unk_101BE354);
  sub_10016560(0x48u, 6926, &unk_101BE39C);
  sub_10016560(0x48u, 6927, &unk_101BE3E4);
  sub_10016560(0x48u, 6928, &unk_101BE42C);
  sub_10016560(0x48u, 6929, &unk_101BE474);
  sub_10016560(0x48u, 6930, &unk_101BE4BC);
  sub_10016560(0x48u, 6931, &unk_101BE504);
  sub_10016560(0x48u, 6932, &unk_101BE54C);
  sub_10016560(0x48u, 6933, &unk_101BE594);
  sub_10016560(0x48u, 6934, &unk_101BE5DC);
  sub_10016560(0x48u, 6935, &unk_101BE624);
  sub_10016560(0x18u, 6163, &unk_101BE66C);
  sub_10016560(0x20u, 6164, &unk_101BE684);
  sub_10016560(0x20u, 6165, &unk_101BE6A4);
  sub_10016560(2u, 6166, &unk_101BE6C4);
  sub_10016560(0xA4u, 40100, &unk_101BE6C8);
  sub_10016560(0xA4u, 40101, &unk_101BE76C);
  sub_10016560(0xA4u, 40102, &unk_101BE810);
  sub_10016560(0xA4u, 40103, &unk_101BE8B4);
  sub_10016560(0xA4u, 40104, &unk_101BE958);
  sub_10016560(0xA4u, 40105, &unk_101BE9FC);
  sub_10016560(0xA4u, 40106, &unk_101BEAA0);
  sub_10016560(0xA4u, 40107, &unk_101BEB44);
  sub_10016560(0xA4u, 40108, &unk_101BEBE8);
  sub_10016560(0xA4u, 40109, &unk_101BEC8C);
  sub_10016560(0xA4u, 40110, &unk_101BED30);
  sub_10016560(0xA4u, 40111, &unk_101BEDD4);
  sub_10016560(0xA4u, 40112, &unk_101BEE78);
  sub_10016560(0xA4u, 40113, &unk_101BEF1C);
  sub_10016560(0xA4u, 40114, &unk_101BEFC0);
  sub_10016560(0xA4u, 40115, &unk_101BF064);
  sub_10016560(0xA4u, 40116, &unk_101BF108);
  sub_10016560(0xA4u, 40117, &unk_101BF1AC);
  sub_10016560(0xA4u, 40118, &unk_101BF250);
  sub_10016560(0xA4u, 40119, &unk_101BF2F4);
  sub_10016560(0xA4u, 40120, &unk_101BF398);
  sub_10016560(0xA4u, 40121, &unk_101BF43C);
  sub_10016560(0xA4u, 40122, &unk_101BF4E0);
  sub_10016560(0xA4u, 40123, &unk_101BF584);
  sub_10016560(0xA4u, 40124, &unk_101BF628);
  sub_10016560(0xA4u, 40125, &unk_101BF6CC);
  sub_10016560(0xA4u, 40126, &unk_101BF770);
  sub_10016560(0xA4u, 40127, &unk_101BF814);
  sub_10016560(0xA4u, 40128, &unk_101BF8B8);
  sub_10016560(0xA4u, 40129, &unk_101BF95C);
  sub_10016560(0xA4u, 40130, &unk_101BFA00);
  sub_10016560(0xA4u, 40131, &unk_101BFAA4);
  sub_10016560(0xA4u, 40132, &unk_101BFB48);
  sub_10016560(0xA4u, 40133, &unk_101BFBEC);
  sub_10016560(0xA4u, 40134, &unk_101BFC90);
  sub_10016560(0xA4u, 40135, &unk_101BFD34);
  sub_10016560(0xA4u, 40136, &unk_101BFDD8);
  sub_10016560(0xA4u, 40137, &unk_101BFE7C);
  sub_10016560(0xA4u, 40138, &unk_101BFF20);
  sub_10016560(0xA4u, 40139, &unk_101BFFC4);
  sub_10016560(0xA4u, 40140, &unk_101C0068);
  sub_10016560(0xA4u, 40141, &unk_101C010C);
  sub_10016560(0xA4u, 40142, &unk_101C01B0);
  sub_10016560(0xA4u, 40143, &unk_101C0254);
  sub_10016560(0xA4u, 40144, &unk_101C02F8);
  sub_10016560(0xA4u, 40145, &unk_101C039C);
  sub_10016560(0xA4u, 40146, &unk_101C0440);
  sub_10016560(0xA4u, 40147, &unk_101C04E4);
  sub_10016560(0xA4u, 40148, &unk_101C0588);
  sub_10016560(0xA4u, 40149, &unk_101C062C);
  sub_10016560(0xA4u, 40150, &unk_101C06D0);
  sub_10016560(0xA4u, 40151, &unk_101C0774);
  sub_10016560(0xA4u, 40152, &unk_101C0818);
  sub_10016560(0xA4u, 40153, &unk_101C08BC);
  sub_10016560(0xA4u, 40154, &unk_101C0960);
  sub_10016560(0xA4u, 40155, &unk_101C0A04);
  sub_10016560(0xA4u, 40156, &unk_101C0AA8);
  sub_10016560(0xA4u, 40157, &unk_101C0B4C);
  sub_10016560(0xA4u, 40158, &unk_101C0BF0);
  sub_10016560(0xA4u, 40159, &unk_101C0C94);
  sub_10016560(0xA4u, 40160, &unk_101C0D38);
  sub_10016560(0xA4u, 40161, &unk_101C0DDC);
  sub_10016560(0xA4u, 40162, &unk_101C0E80);
  sub_10016560(0xA4u, 40163, &unk_101C0F24);
  sub_10016560(0xA4u, 40164, &unk_101C0FC8);
  sub_10016560(0xA4u, 40165, &unk_101C106C);
  sub_10016560(0xA4u, 40166, &unk_101C1110);
  sub_10016560(0xA4u, 40167, &unk_101C11B4);
  sub_10016560(0xA4u, 40168, &unk_101C1258);
  sub_10016560(0xA4u, 40169, &unk_101C12FC);
  sub_10016560(0xA4u, 40170, &unk_101C13A0);
  sub_10016560(0xA4u, 40171, &unk_101C1444);
  sub_10016560(0xA4u, 40172, &unk_101C14E8);
  sub_10016560(0xA4u, 40173, &unk_101C158C);
  sub_10016560(0xA4u, 40174, &unk_101C1630);
  sub_10016560(0xA4u, 40175, &unk_101C16D4);
  sub_10016560(0xA4u, 40176, &unk_101C1778);
  sub_10016560(0xA4u, 40177, &unk_101C181C);
  sub_10016560(0xA4u, 40178, &unk_101C18C0);
  sub_10016560(0xA4u, 40179, &unk_101C1964);
  sub_10016560(0xA4u, 40180, &unk_101C1A08);
  sub_10016560(0xA4u, 40181, &unk_101C1AAC);
  sub_10016560(0xA4u, 40182, &unk_101C1B50);
  sub_10016560(0xA4u, 40183, &unk_101C1BF4);
  sub_10016560(0xA4u, 40184, &unk_101C1C98);
  sub_10016560(0xA4u, 40185, &unk_101C1D3C);
  sub_10016560(0xA4u, 40186, &unk_101C1DE0);
  sub_10016560(0xA4u, 40187, &unk_101C1E84);
  sub_10016560(0xA4u, 40188, &unk_101C1F28);
  sub_10016560(0xA4u, 40189, &unk_101C1FCC);
  sub_10016560(0xA4u, 40190, &unk_101C2070);
  sub_10016560(0xA4u, 40191, &unk_101C2114);
  sub_10016560(0xA4u, 40192, &unk_101C21B8);
  sub_10016560(0xA4u, 40193, &unk_101C225C);
  sub_10016560(0xA4u, 40194, &unk_101C2300);
  sub_10016560(0xA4u, 40195, &unk_101C23A4);
  sub_10016560(0xA4u, 40196, &unk_101C2448);
  sub_10016560(0xA4u, 40197, &unk_101C24EC);
  sub_10016560(0xA4u, 40198, &unk_101C2590);
  sub_10016560(0xA4u, 40199, &unk_101C2634);
  sub_10016560(0x20u, 6190, &unk_101C26D8);
  sub_10016560(0x20u, 6191, &unk_101C26F8);
  sub_10016560(0x20u, 6192, &unk_101C2718);
  sub_10016560(0x20u, 6199, &unk_101C2738);
  sub_10016560(0x28u, 6207, &unk_101C2758);
  sub_10016560(4u, 6231, &unk_101C3270);
  sub_10016560(4u, 6232, &unk_101C3274);
  sub_10016560(4u, 6233, &unk_101C3278);
  sub_10016560(4u, 6234, &unk_101C327C);
  sub_10016560(0x1Cu, 40000, &unk_101C2780);
  sub_10016560(0x1Cu, 40001, &unk_101C279C);
  sub_10016560(0x1Cu, 40002, &unk_101C27B8);
  sub_10016560(0x1Cu, 40003, &unk_101C27D4);
  sub_10016560(0x1Cu, 40004, &unk_101C27F0);
  sub_10016560(0x1Cu, 40005, &unk_101C280C);
  sub_10016560(0x1Cu, 40006, &unk_101C2828);
  sub_10016560(0x1Cu, 40007, &unk_101C2844);
  sub_10016560(0x1Cu, 40008, &unk_101C2860);
  sub_10016560(0x1Cu, 40009, &unk_101C287C);
  sub_10016560(0x1Cu, 40010, &unk_101C2898);
  sub_10016560(0x1Cu, 40011, &unk_101C28B4);
  sub_10016560(0x1Cu, 40012, &unk_101C28D0);
  sub_10016560(0x1Cu, 40013, &unk_101C28EC);
  sub_10016560(0x1Cu, 40014, &unk_101C2908);
  sub_10016560(0x1Cu, 40015, &unk_101C2924);
  sub_10016560(0x1Cu, 40016, &unk_101C2940);
  sub_10016560(0x1Cu, 40017, &unk_101C295C);
  sub_10016560(0x1Cu, 40018, &unk_101C2978);
  sub_10016560(0x1Cu, 40019, &unk_101C2994);
  sub_10016560(0x1Cu, 40020, &unk_101C29B0);
  sub_10016560(0x1Cu, 40021, &unk_101C29CC);
  sub_10016560(0x1Cu, 40022, &unk_101C29E8);
  sub_10016560(0x1Cu, 40023, &unk_101C2A04);
  sub_10016560(0x1Cu, 40024, &unk_101C2A20);
  sub_10016560(0x1Cu, 40025, &unk_101C2A3C);
  sub_10016560(0x1Cu, 40026, &unk_101C2A58);
  sub_10016560(0x1Cu, 40027, &unk_101C2A74);
  sub_10016560(0x1Cu, 40028, &unk_101C2A90);
  sub_10016560(0x1Cu, 40029, &unk_101C2AAC);
  sub_10016560(0x1Cu, 40030, &unk_101C2AC8);
  sub_10016560(0x1Cu, 40031, &unk_101C2AE4);
  sub_10016560(0x1Cu, 40032, &unk_101C2B00);
  sub_10016560(0x1Cu, 40033, &unk_101C2B1C);
  sub_10016560(0x1Cu, 40034, &unk_101C2B38);
  sub_10016560(0x1Cu, 40035, &unk_101C2B54);
  sub_10016560(0x1Cu, 40036, &unk_101C2B70);
  sub_10016560(0x1Cu, 40037, &unk_101C2B8C);
  sub_10016560(0x1Cu, 40038, &unk_101C2BA8);
  sub_10016560(0x1Cu, 40039, &unk_101C2BC4);
  sub_10016560(0x1Cu, 40040, &unk_101C2BE0);
  sub_10016560(0x1Cu, 40041, &unk_101C2BFC);
  sub_10016560(0x1Cu, 40042, &unk_101C2C18);
  sub_10016560(0x1Cu, 40043, &unk_101C2C34);
  sub_10016560(0x1Cu, 40044, &unk_101C2C50);
  sub_10016560(0x1Cu, 40045, &unk_101C2C6C);
  sub_10016560(0x1Cu, 40046, &unk_101C2C88);
  sub_10016560(0x1Cu, 40047, &unk_101C2CA4);
  sub_10016560(0x1Cu, 40048, &unk_101C2CC0);
  sub_10016560(0x1Cu, 40049, &unk_101C2CDC);
  sub_10016560(0x1Cu, 40050, &unk_101C2CF8);
  sub_10016560(0x1Cu, 40051, &unk_101C2D14);
  sub_10016560(0x1Cu, 40052, &unk_101C2D30);
  sub_10016560(0x1Cu, 40053, &unk_101C2D4C);
  sub_10016560(0x1Cu, 40054, &unk_101C2D68);
  sub_10016560(0x1Cu, 40055, &unk_101C2D84);
  sub_10016560(0x1Cu, 40056, &unk_101C2DA0);
  sub_10016560(0x1Cu, 40057, &unk_101C2DBC);
  sub_10016560(0x1Cu, 40058, &unk_101C2DD8);
  sub_10016560(0x1Cu, 40059, &unk_101C2DF4);
  sub_10016560(0x1Cu, 40060, &unk_101C2E10);
  sub_10016560(0x1Cu, 40061, &unk_101C2E2C);
  sub_10016560(0x1Cu, 40062, &unk_101C2E48);
  sub_10016560(0x1Cu, 40063, &unk_101C2E64);
  sub_10016560(0x1Cu, 40064, &unk_101C2E80);
  sub_10016560(0x1Cu, 40065, &unk_101C2E9C);
  sub_10016560(0x1Cu, 40066, &unk_101C2EB8);
  sub_10016560(0x1Cu, 40067, &unk_101C2ED4);
  sub_10016560(0x1Cu, 40068, &unk_101C2EF0);
  sub_10016560(0x1Cu, 40069, &unk_101C2F0C);
  sub_10016560(0x1Cu, 40070, &unk_101C2F28);
  sub_10016560(0x1Cu, 40071, &unk_101C2F44);
  sub_10016560(0x1Cu, 40072, &unk_101C2F60);
  sub_10016560(0x1Cu, 40073, &unk_101C2F7C);
  sub_10016560(0x1Cu, 40074, &unk_101C2F98);
  sub_10016560(0x1Cu, 40075, &unk_101C2FB4);
  sub_10016560(0x1Cu, 40076, &unk_101C2FD0);
  sub_10016560(0x1Cu, 40077, &unk_101C2FEC);
  sub_10016560(0x1Cu, 40078, &unk_101C3008);
  sub_10016560(0x1Cu, 40079, &unk_101C3024);
  sub_10016560(0x1Cu, 40080, &unk_101C3040);
  sub_10016560(0x1Cu, 40081, &unk_101C305C);
  sub_10016560(0x1Cu, 40082, &unk_101C3078);
  sub_10016560(0x1Cu, 40083, &unk_101C3094);
  sub_10016560(0x1Cu, 40084, &unk_101C30B0);
  sub_10016560(0x1Cu, 40085, &unk_101C30CC);
  sub_10016560(0x1Cu, 40086, &unk_101C30E8);
  sub_10016560(0x1Cu, 40087, &unk_101C3104);
  sub_10016560(0x1Cu, 40088, &unk_101C3120);
  sub_10016560(0x1Cu, 40089, &unk_101C313C);
  sub_10016560(0x1Cu, 40090, &unk_101C3158);
  sub_10016560(0x1Cu, 40091, &unk_101C3174);
  sub_10016560(0x1Cu, 40092, &unk_101C3190);
  sub_10016560(0x1Cu, 40093, &unk_101C31AC);
  sub_10016560(0x1Cu, 40094, &unk_101C31C8);
  sub_10016560(0x1Cu, 40095, &unk_101C31E4);
  sub_10016560(0x1Cu, 40096, &unk_101C3200);
  sub_10016560(0x1Cu, 40097, &unk_101C321C);
  sub_10016560(0x1Cu, 40098, &unk_101C3238);
  sub_10016560(0x1Cu, 40099, &unk_101C3254);
  sub_10016560(4u, 6238, &unk_101C3280);
  sub_10016560(4u, 6239, &unk_101C3284);
  sub_10016560(4u, 6240, &unk_101C3288);
  sub_10016560(4u, 6242, &unk_101C328C);
  sub_10016560(4u, 6244, &unk_101C3290);
  sub_10016560(4u, 6245, &unk_101C3294);
  sub_10016560(4u, 6246, &unk_101C3298);
  sub_10016560(4u, 6251, &unk_101C329C);
  sub_10016560(4u, 6252, &unk_101C32A0);
  sub_10016560(4u, 6253, &unk_101C32A4);
  sub_10016560(4u, 6254, &unk_101C32A8);
  sub_10016560(1u, 6255, &unk_101C32AC);
  sub_10016560(4u, 6256, &unk_101C32B0);
  sub_10016560(4u, 6257, &unk_101C32B4);
  sub_10016560(0xE2u, 6286, &unk_101C32B8);
  v0 = 18000;
  v1 = &unk_101C339C;
  v2 = 16;
  do
  {
    sub_10016560(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10016560(4u, 6262, &unk_101C455C);
  sub_10016560(0x28u, 6263, &unk_101C4560);
  sub_10016560(0x28u, 6264, &unk_101C4588);
  sub_10016560(0x40u, 6268, &unk_101C45B0);
  sub_10016560(4u, 6272, &unk_101C4670);
  sub_10016560(4u, 6273, &unk_101C4674);
  sub_10016560(1u, 6274, &unk_101C4678);
  sub_10016560(2u, 6275, &unk_101C467A);
  sub_10016560(1u, 6276, &unk_101C467C);
  sub_10016560(1u, 6277, &unk_101C467D);
  sub_10016560(1u, 6278, &unk_101C467E);
  sub_10016560(0x40u, 6279, &unk_101C4680);
  sub_10016560(0x28u, 6753, &unk_101C5535);
  sub_10016560(0x30u, 6754, &unk_101C5560);
  sub_10016560(0x28u, 6958, &unk_101C5590);
  sub_10016560(0x80u, 6802, &unk_101C45F0);
  sub_10016560(1u, 6760, &unk_101C55B8);
  sub_10016560(0x10u, 6312, &unk_101C4A04);
  sub_10016560(0x10u, 6313, &unk_101C4A14);
  sub_10016560(0x10u, 6314, &unk_101C4A24);
  sub_10016560(1u, 6307, &unk_101C4A34);
  sub_10016560(1u, 6308, &unk_101C4A35);
  sub_10016560(1u, 6309, &unk_101C4A36);
  sub_10016560(4u, 6285, &unk_101C4A38);
  sub_10016560(0xA8u, 6318, &unk_101C4A3C);
  sub_10016560(4u, 6319, &unk_101C4AE4);
  sub_10016560(1u, 6350, &unk_101C4AE8);
  sub_10016560(0x50u, 6351, &unk_101C4AEC);
  sub_10016560(4u, 6352, &unk_101C4B3C);
  sub_10016560(4u, 6353, &unk_101C4B40);
  sub_10016560(0x54u, 6448, &unk_101C4D8C);
  sub_10016560(0x54u, 6449, &unk_101C4DE0);
  sub_10016560(8u, 6287, &unk_101C46E4);
  sub_10016560(8u, 6288, &unk_101C46EC);
  sub_10016560(8u, 6289, &unk_101C46F4);
  sub_10016560(8u, 6290, &unk_101C46FC);
  sub_10016560(8u, 6291, &unk_101C4704);
  sub_10016560(8u, 6292, &unk_101C470C);
  sub_10016560(8u, 6293, &unk_101C4714);
  sub_10016560(8u, 6294, &unk_101C471C);
  sub_10016560(8u, 6295, &unk_101C4724);
  sub_10016560(8u, 6296, &unk_101C472C);
  sub_10016560(8u, 6297, &unk_101C4734);
  sub_10016560(8u, 6298, &unk_101C473C);
  sub_10016560(8u, 6299, &unk_101C4744);
  sub_10016560(8u, 6300, &unk_101C474C);
  sub_10016560(8u, 6301, &unk_101C4754);
  sub_10016560(8u, 6302, &unk_101C475C);
  sub_10016560(8u, 6303, &unk_101C4764);
  sub_10016560(8u, 6304, &unk_101C476C);
  sub_10016560(8u, 6305, &unk_101C4774);
  sub_10016560(8u, 6306, &unk_101C477C);
  sub_10016560(8u, 6409, &unk_101C4784);
  sub_10016560(8u, 6410, &unk_101C478C);
  sub_10016560(8u, 6411, &unk_101C4794);
  sub_10016560(8u, 6412, &unk_101C479C);
  sub_10016560(8u, 6413, &unk_101C47A4);
  sub_10016560(8u, 6414, &unk_101C47AC);
  sub_10016560(8u, 6415, &unk_101C47B4);
  sub_10016560(8u, 6416, &unk_101C47BC);
  sub_10016560(8u, 6417, &unk_101C47C4);
  sub_10016560(8u, 6418, &unk_101C47CC);
  sub_10016560(8u, 6419, &unk_101C47D4);
  sub_10016560(8u, 6420, &unk_101C47DC);
  sub_10016560(8u, 6421, &unk_101C47E4);
  sub_10016560(8u, 6422, &unk_101C47EC);
  sub_10016560(8u, 6423, &unk_101C47F4);
  sub_10016560(8u, 6424, &unk_101C47FC);
  sub_10016560(8u, 6425, &unk_101C4804);
  sub_10016560(8u, 6426, &unk_101C480C);
  sub_10016560(8u, 6427, &unk_101C4814);
  sub_10016560(8u, 6428, &unk_101C481C);
  sub_10016560(4u, 6429, &unk_101C4D24);
  sub_10016560(8u, 6430, &unk_101C4D28);
  sub_10016560(8u, 6431, &unk_101C4D30);
  sub_10016560(8u, 6432, &unk_101C4D38);
  sub_10016560(8u, 6433, &unk_101C4D40);
  sub_10016560(8u, 6434, &unk_101C4D48);
  sub_10016560(8u, 6435, &unk_101C4D50);
  sub_10016560(8u, 6436, &unk_101C4D58);
  sub_10016560(8u, 6437, &unk_101C4D60);
  sub_10016560(8u, 6438, &unk_101C4D68);
  sub_10016560(8u, 6439, &unk_101C4D70);
  sub_10016560(8u, 6440, &unk_101C4D78);
  sub_10016560(0xAu, 6519, &unk_101C51E4);
  sub_10016560(4u, 6442, &unk_101C4D80);
  sub_10016560(4u, 6443, &unk_101C4D84);
  sub_10016560(0xF0u, 6367, &unk_101C4B44);
  sub_10016560(0xF0u, 6368, &unk_101C4C34);
  sub_10016560(1u, 6446, &unk_101C4D88);
  sub_10016560(6u, 6452, &unk_101C4E34);
  sub_10016560(4u, 6457, &unk_101C4E3C);
  sub_10016560(4u, 6458, &unk_101C4E40);
  sub_10016560(4u, 6459, &unk_101C4E44);
  sub_10016560(4u, 6460, &unk_101C4E48);
  sub_10016560(0x208u, 6515, &unk_101C4E4C);
  sub_10016560(0x160u, 6516, &unk_101C5054);
  sub_10016560(0x18u, 6517, &unk_101C51B4);
  sub_10016560(0x18u, 6518, &unk_101C51CC);
  sub_10016560(1u, 6520, &unk_101C51EE);
  sub_10016560(0x10u, 6521, &unk_101C51F0);
  sub_10016560(4u, 6523, &unk_101C5200);
  sub_10016560(4u, 6524, &unk_101C5204);
  sub_10016560(4u, 6525, &unk_101C5208);
  sub_10016560(1u, 6526, &unk_101C520C);
  sub_10016560(1u, 6527, &unk_101C520D);
  sub_10016560(0x50u, 6528, &unk_101C5210);
  sub_10016560(4u, 6529, &unk_101C5260);
  sub_10016560(1u, 6530, &unk_101C5264);
  sub_10016560(1u, 6531, &unk_101C5265);
  sub_10016560(1u, 6532, &unk_101C5266);
  sub_10016560(0x14u, 6533, &unk_101C5267);
  sub_10016560(0xAu, 6883, &unk_101C5980);
  sub_10016560(0xAu, 6884, &unk_101C598A);
  sub_10016560(0xAu, 6885, &unk_101C5994);
  sub_10016560(1u, 6664, &unk_101C527B);
  sub_10016560(1u, 6666, &unk_101C527C);
  sub_10016560(1u, 6667, &unk_101C527D);
  sub_10016560(1u, 6668, &unk_101C527E);
  sub_10016560(0xA0u, 6669, &unk_101C5280);
  sub_10016560(2u, 6670, &unk_101C5370);
  sub_10016560(4u, 6671, &unk_101C5374);
  sub_10016560(4u, 6672, &unk_101C5378);
  sub_10016560(4u, 6673, &unk_101C537C);
  sub_10016560(4u, 6674, &unk_101C5380);
  sub_10016560(4u, 6675, &unk_101C5384);
  sub_10016560(4u, 6676, &unk_101C538C);
  sub_10016560(4u, 6677, &unk_101C5394);
  sub_10016560(4u, 6678, &unk_101C5398);
  sub_10016560(1u, 6679, &unk_101C539C);
  sub_10016560(0x140u, 6680, &unk_101C53A0);
  sub_10016560(4u, 6882, &unk_101C597C);
  sub_10016560(0xCu, 6652, &unk_101C54E0);
  sub_10016560(0x48u, 6653, &unk_101C54EC);
  sub_10016560(1u, 6688, &unk_101C5534);
  sub_10016560(4u, 6771, &unk_101C55BC);
  sub_10016560(4u, 6772, &unk_101C55C0);
  sub_10016560(8u, 6787, &unk_101C55C4);
  sub_10016560(1u, 6832, &unk_101C55F4);
  sub_10016560(1u, 6833, &unk_101C55F5);
  sub_10016560(1u, 6834, &unk_101C55F6);
  sub_10016560(4u, 6835, &unk_101C55F8);
  sub_10016560(4u, 6836, &unk_101C55FC);
  sub_10016560(4u, 6837, &unk_101C5600);
  sub_10016560(4u, 6838, &unk_101C5604);
  sub_10016560(1u, 6839, &unk_101C5608);
  sub_10016560(0x50u, 6840, &unk_101C5320);
  sub_10016560(4u, 6841, &unk_101C560C);
  sub_10016560(4u, 6842, &unk_101C5610);
  sub_10016560(4u, 6843, &unk_101C5614);
  sub_10016560(1u, 6844, &unk_101C5618);
  sub_10016560(0x360u, 6845, &unk_101C561C);
  sub_10016560(4u, 6846, &unk_101C5388);
  sub_10016560(4u, 6847, &unk_101C5390);
  result = 1;
  dword_102AD588 = (int)&unk_101BD780;
  return result;
}
// 102AD588: using guessed type int dword_102AD588;

//----- (100183B0) --------------------------------------------------------
char __cdecl sub_100183B0(int a1, float *a2)
{
  char v2; // bl@1
  char result; // al@8

  v2 = 1;
  if ( *(float *)(a1 + 4) > (double)*a2 )
  {
    if ( *(_BYTE *)(a1 + 19) )
    {
      if ( *(_BYTE *)(a1 + 19) == 1 )
        *a2 = *(float *)(a1 + 4);
    }
    else
    {
      v2 = 0;
    }
  }
  if ( *(float *)a1 >= (double)*a2 )
  {
    result = v2;
  }
  else if ( *(_BYTE *)(a1 + 20) )
  {
    result = v2;
    if ( *(_BYTE *)(a1 + 20) == 1 )
      *a2 = *(float *)a1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10018410) --------------------------------------------------------
char __usercall sub_10018410@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5)
{
  unsigned __int8 v5; // cl@1
  char v6; // dl@2
  char v7; // bl@4
  double v8; // st7@6
  int v9; // edi@6
  int v10; // ecx@6
  bool v11; // zf@10
  unsigned int v12; // eax@18
  char v14; // [sp+3h] [bp-5h]@1
  char v15; // [sp+4h] [bp-4h]@2
  char v16; // [sp+10h] [bp+8h]@10
  char v17; // [sp+14h] [bp+Ch]@10

  v5 = *(_BYTE *)(a2 + 10 * a1 + 22535);
  v14 = 10;
  if ( (unsigned __int8)a4 >= 9u )
  {
    v15 = 9;
    v6 = 9;
  }
  else
  {
    v6 = a4;
    v15 = a4;
  }
  v7 = a5;
  if ( (unsigned __int8)a5 >= 9u )
    v7 = 9;
  v8 = a3;
  v9 = v5;
  v10 = 10 * v5;
  if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v6) + 53416) >= (double)a3 )
  {
    if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7) + 53416) <= v8 )
    {
      v11 = v7 == v6;
      v16 = 1;
      v17 = 0;
      if ( (unsigned __int8)v7 > (unsigned __int8)v6 )
      {
        v16 = -1;
        v17 = -1;
        v11 = v7 == v6;
      }
      if ( !v11 )
      {
        while ( *(float *)(a2 + 4 * ((unsigned __int8)v7 + v10) + 53416) > v8
             || *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7 + v16) + 53416) < v8 )
        {
          v7 += v16;
          if ( v7 == v15 )
            goto LABEL_18;
        }
        v14 = v7 + v17;
      }
    }
    else
    {
      v14 = v7;
    }
  }
  else
  {
    v14 = v6;
  }
LABEL_18:
  v12 = *(_BYTE *)(44 * v9 + a2 + 52576) - 2;
  if ( (unsigned __int8)v14 < v12 )
    LOBYTE(v12) = v14;
  return v12;
}

//----- (10018520) --------------------------------------------------------
double __usercall sub_10018520@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4)
{
  int v4; // esi@1
  unsigned __int8 v5; // al@1
  int v6; // edi@2
  unsigned __int8 v7; // al@2
  char v8; // al@6
  double v9; // st7@7
  double result; // st7@7
  char v11; // [sp+14h] [bp-8h]@4
  char v12; // [sp+18h] [bp-4h]@4
  float v13; // [sp+24h] [bp+8h]@7

  v4 = a1;
  v5 = *(_BYTE *)(a1 + 10 * (unsigned __int16)a3 + 22535);
  if ( v5 >= 0x14u )
  {
    *a2 = 1;
    result = a4;
  }
  else
  {
    v6 = v5;
    v7 = *(_BYTE *)(44 * v5 + v4 + 52576);
    if ( v7 <= 1u || v7 > 0xAu )
      goto LABEL_12;
    v11 = 0;
    v12 = v7 - 1;
    if ( *(float *)(v4 + 4 * (10 * v6 + (unsigned __int8)(v7 - 1)) + 53416) < (double)*(float *)(v4 + 40 * v6 + 53416) )
    {
      v11 = v7 - 1;
      v12 = 0;
    }
    v8 = sub_10018410(a3, v4, a4, v12, v11);
    if ( (unsigned __int8)v8 >= 9u )
    {
LABEL_12:
      *a2 = 1;
      result = a4;
    }
    else
    {
      v9 = *(float *)(v4 + 4 * ((unsigned __int8)v8 + 2 * (9 * v6 + 6777))) * a4
         + *(float *)(v4 + 4 * ((unsigned __int8)v8 + 18 * v6) + 54252);
      *a2 = 1;
      v13 = v9;
      result = v13;
    }
  }
  return result;
}

//----- (10018620) --------------------------------------------------------
unsigned __int8 __cdecl sub_10018620(int a1, int a2, char a3, void *a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  unsigned __int8 result; // al@1
  int v7; // edi@1
  int v8; // esi@4
  char v9; // bl@7
  int v10; // edi@7
  char v11; // al@7
  int v12; // edx@7
  char v13; // al@8
  char v14; // dl@8
  unsigned __int8 v15; // [sp+16h] [bp-156h]@1
  char v16; // [sp+17h] [bp-155h]@7
  int v17; // [sp+18h] [bp-154h]@1
  int v18; // [sp+1Ch] [bp-150h]@1
  int v19; // [sp+20h] [bp-14Ch]@1
  char v20[12]; // [sp+24h] [bp-148h]@7
  float v21[78]; // [sp+30h] [bp-13Ch]@8

  *(float *)a4 = 9.8999998e24;
  v4 = a2;
  v5 = *(_WORD *)(a2 + 16);
  result = 0;
  v7 = a1;
  v17 = a1;
  v19 = a2;
  v15 = 0;
  v18 = v5;
  while ( v15 < *(_BYTE *)(v4 + 18) )
  {
    v5 = (unsigned __int16)v5;
    v8 = v7 + 10 * (unsigned __int16)v5 + 22534;
    switch ( *(_BYTE *)v8 )
    {
      case 1:
        result = sub_1002B790(
                   *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22538),
                   *(_WORD *)(v7 + 2 * (5 * v5 + 11270)),
                   *(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22542),
                   4,
                   a4);
        break;
      case 3:
        result = sub_10031A40(COERCE_FLOAT(*(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22538)), a4);
        break;
      case 4:
        v9 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v10 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v11 = sub_10041A30((unsigned int)*(_BYTE *)(v8 + 5) >> 3, 1);
        v12 = *(_BYTE *)(v8 + 4);
        v16 = v11;
        result = sub_1002B790(6, (unsigned __int16)word_10077C8C[v12], 0, 324, v20);
        if ( result )
        {
          v13 = v16;
          v14 = v16;
          *(float *)a4 = v21[v10];
          result = ((unsigned __int8)v20[(unsigned __int8)v13] >> (v9 - 8 * v14)) & 1;
        }
        v7 = v17;
        break;
    }
    ++v15;
    v5 = v18++ + 1;
    if ( result )
    {
      v15 = result;
      goto LABEL_15;
    }
    v4 = v19;
  }
  v15 = result;
  if ( !result )
    return result;
LABEL_15:
  if ( a3 )
  {
    *(float *)a4 = sub_10018520(v7, &v15, v5 - 1, *(float *)a4);
    result = v15;
  }
  return result;
}
// 10077C8C: using guessed type __int16 word_10077C8C[];
// 10018620: using guessed type char var_148[12];
// 10018620: using guessed type float var_13C[78];

//----- (100187B0) --------------------------------------------------------
char __cdecl sub_100187B0(unsigned __int16 a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(float *)a2 = 9.8999998e24;
  v2 = sub_1002ED50(a1);
  v3 = sub_1002B7B0();
  if ( v2 && v3 && *(_WORD *)(v2 + 12) == 6 )
  {
    result = sub_10018620(v3, v2, 1, a2);
    if ( result )
      result = sub_100183B0(v2, (float *)a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10018810) --------------------------------------------------------
double __cdecl sub_10018810(float a1, float a2, int a3, float a4)
{
  double v4; // st7@2
  double v5; // st7@4
  bool v6; // c0@5
  double v7; // st7@5
  double v9; // st5@7
  bool v10; // c0@7
  bool v11; // c3@7
  float v12; // [sp+8h] [bp-8h]@4
  float v13; // [sp+Ch] [bp-4h]@4
  int v14; // [sp+1Ch] [bp+Ch]@4
  int v15; // [sp+1Ch] [bp+Ch]@4
  int v16; // [sp+1Ch] [bp+Ch]@4
  int v17; // [sp+1Ch] [bp+Ch]@9

  if ( (unsigned __int8)a3 <= 0x64u )
    v4 = (double)(unsigned __int8)a3;
  else
    v4 = 100.0;
  *(float *)&v14 = v4;
  *(float *)&v15 = *(float *)&v14 / 100.0 * a4;
  v12 = (*(float *)&v15 + a4) * 0.5;
  v13 = sub_10041A70(a1, a4);
  *(float *)&v16 = sub_10041990(a1, a4);
  v5 = a1;
  if ( a1 < (double)a2 )
  {
    v9 = *(float *)&v16 - v12;
    v10 = v9 < v5;
    v11 = v9 == v5;
    v7 = *(float *)&v16;
    if ( !v10 && !v11 )
      v7 = v13;
  }
  else
  {
    v6 = v13 + v12 < v5;
    v7 = v13;
    if ( v6 )
      return *(float *)&v16;
  }
  *(float *)&v17 = v7;
  return *(float *)&v17;
}

//----- (100188F0) --------------------------------------------------------
char __cdecl sub_100188F0(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_10032330(a1, v4, &v6) == 1 )
  {
    v2 = sub_10012A10(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_100136E0(v4[0], v6, &v5) && !sub_1001A7F0((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10018A10) --------------------------------------------------------
double __cdecl sub_10018A10(float a1)
{
  int v1; // ecx@0
  double result; // st7@1
  float v3; // [sp+0h] [bp-4h]@1
  float v4; // [sp+8h] [bp+4h]@1
  float v5; // [sp+8h] [bp+4h]@3

  v4 = *(float *)v1 * a1 + *(float *)(v1 + 4);
  v3 = *(float *)(v1 + 8);
  result = v4;
  if ( v3 >= (double)v4 )
    result = v3;
  v5 = *(float *)(v1 + 12);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10018A70) --------------------------------------------------------
char __usercall sub_10018A70@<al>(int a1@<esi>, unsigned __int16 a2, float *a3)
{
  char v3; // dl@39
  char result; // al@39
  float v5; // [sp+0h] [bp-280h]@11
  float v6[19]; // [sp+4h] [bp-27Ch]@11
  float v7; // [sp+50h] [bp-230h]@11
  float v8[76]; // [sp+54h] [bp-22Ch]@11
  float v9; // [sp+184h] [bp-FCh]@29
  char v10; // [sp+197h] [bp-E9h]@1
  float v11; // [sp+198h] [bp-E8h]@1
  float v12; // [sp+19Ch] [bp-E4h]@1
  float v13; // [sp+1A0h] [bp-E0h]@1
  float v14; // [sp+1A4h] [bp-DCh]@1
  float v15; // [sp+1A8h] [bp-D8h]@1
  float v16; // [sp+1ACh] [bp-D4h]@1
  float v17; // [sp+1B0h] [bp-D0h]@17
  float v18; // [sp+1B4h] [bp-CCh]@37
  float v19; // [sp+1B8h] [bp-C8h]@22
  float v20; // [sp+1BCh] [bp-C4h]@17
  int v21; // [sp+1C0h] [bp-C0h]@1
  int v22[3]; // [sp+1C4h] [bp-BCh]@1
  int v23; // [sp+1D0h] [bp-B0h]@1
  int v24[3]; // [sp+1D4h] [bp-ACh]@1
  int v25; // [sp+1E0h] [bp-A0h]@1
  int v26; // [sp+1E4h] [bp-9Ch]@1
  int v27; // [sp+208h] [bp-78h]@1
  int v28; // [sp+20Ch] [bp-74h]@1
  int v29; // [sp+230h] [bp-50h]@1
  int v30; // [sp+234h] [bp-4Ch]@1
  int v31; // [sp+258h] [bp-28h]@1
  int v32; // [sp+25Ch] [bp-24h]@1

  v10 = 0;
  v23 = 0;
  v24[0] = 0;
  v21 = 0;
  v22[0] = 0;
  v25 = 0;
  v26 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v27 = 0;
  v28 = 0;
  v11 = 0.0;
  v12 = 0.0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  switch ( a2 )
  {
    case 0x3Au:
    case 0x3Bu:
      if ( sub_1003E040(6091, (int)&v21, 16) )
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 192, 0, 0);
      if ( sub_1003E040(6115, (int)&v23, 16) )
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 193, 0, 0);
      v14 = *((float *)&v21 + 2 * a1);
      v13 = *(float *)&v22[2 * a1];
      v11 = *((float *)&v23 + 2 * a1);
      v12 = *(float *)&v24[2 * a1];
      goto LABEL_37;
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x3Fu:
    case 0x40u:
      if ( sub_1003E040(6090, (int)&v29, 40) )
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 205, 0, 0);
      if ( sub_1003E040(6114, (int)&v25, 40) )
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 206, 0, 0);
      v14 = *(&v7 + 2 * a2);
      v13 = v8[2 * a2];
      v11 = *(&v5 + 2 * a2);
      v12 = v6[2 * a2];
      goto LABEL_37;
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
      if ( sub_1003E040(6092, (int)&v27, 40) )
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 218, 0, 0);
      if ( sub_1003E040(6116, (int)&v31, 40) )
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 219, 0, 0);
      v14 = *(&v5 + 2 * a2);
      v13 = v6[2 * a2];
      v11 = *(&v7 + 2 * a2);
      v12 = v8[2 * a2];
      goto LABEL_37;
    case 0x4Eu:
      v17 = 9.8999998e24;
      if ( sub_1003E0A0(6355, &v20, 4, &v17) )
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 228, 0, 0);
      sub_1003DB80(14, &v10);
      if ( v10 == 10 )
        v20 = v20 * 0.5555555820465088;
      v14 = 9.9999996e24;
      v13 = -9.9999996e24;
      v15 = -9.9999996e24;
      v16 = 9.9999996e24;
      v12 = v20;
      v11 = 1.0;
      goto LABEL_37;
    case 0x4Fu:
      v17 = 9.8999998e24;
      if ( sub_1003E0A0(6356, &v19, 4, &v17) )
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 250, 0, 0);
      sub_1003DB80(14, &v10);
      if ( v10 == 10 )
        v19 = v19 * 0.5555555820465088;
      v14 = 9.9999996e24;
      v13 = -9.9999996e24;
      v15 = -9.9999996e24;
      v16 = 9.9999996e24;
      v12 = v19;
      v11 = 1.0;
      goto LABEL_37;
    case 0x98u:
    case 0x99u:
      v14 = 9.9999996e24;
      v13 = -9.9999996e24;
      v11 = 1.0;
      v12 = 0.0;
      goto LABEL_37;
    case 0x67u:
      if ( !sub_1003E040(6162, (int)&v11, 24) )
        goto LABEL_37;
      v9 = 0.0;
      LODWORD(v8[75]) = 0;
      LODWORD(v8[74]) = 282;
      goto LABEL_36;
    case 0x68u:
    case 0xC0u:
      if ( !sub_1003E040(6161, (int)&v11, 24) )
        goto LABEL_37;
      v9 = 0.0;
      LODWORD(v8[75]) = 0;
      LODWORD(v8[74]) = 287;
      goto LABEL_36;
    case 0x69u:
      if ( !sub_1003E040(6160, (int)&v11, 24) )
        goto LABEL_37;
      v9 = 0.0;
      LODWORD(v8[75]) = 0;
      LODWORD(v8[74]) = 291;
      goto LABEL_36;
    case 0x70u:
      if ( sub_1003E040(6235, (int)&v11, 24) )
      {
        v9 = 0.0;
        LODWORD(v8[75]) = 0;
        LODWORD(v8[74]) = 295;
LABEL_36:
        sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", SLODWORD(v8[74]), SLOBYTE(v8[75]), (char *)LODWORD(v9));
      }
LABEL_37:
      if ( sub_100188F0(a2, &v18) && (LODWORD(v18) & 0x7F800000) != 2139095040 )
      {
        *a3 = sub_10018A10(v18);
        result = v3;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 10018A70: using guessed type int var_AC[3];
// 10018A70: using guessed type int var_BC[3];
// 10018A70: using guessed type float var_22C[76];
// 10018A70: using guessed type float var_27C[19];

//----- (10018FB0) --------------------------------------------------------
char __cdecl sub_10018FB0(char a1, bool *a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-8h]@3

  result = 0;
  *a2 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
      return result;
    result = sub_100136E0(0, 257, &v3);
  }
  else
  {
    result = sub_100136E0(0, 256, &v3);
  }
  if ( result )
    *a2 = (v3 & 4) == 4;
  return result;
}

//----- (10019010) --------------------------------------------------------
char __cdecl sub_10019010(char a1, bool *a2)
{
  char result; // al@1
  int v3; // [sp+4h] [bp-8h]@3

  result = 0;
  *a2 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
      return result;
    result = sub_100136E0(0, 257, &v3);
  }
  else
  {
    result = sub_100136E0(0, 256, &v3);
  }
  if ( result )
    *a2 = (v3 & 1) == 1;
  return result;
}

//----- (10019070) --------------------------------------------------------
char __cdecl sub_10019070(float *a1)
{
  double v1; // st7@5
  double v2; // st7@10
  double v3; // st3@13
  char result; // al@13
  double v5; // st7@13
  char v6; // [sp+7h] [bp-29h]@1
  float v7; // [sp+8h] [bp-28h]@3
  float v8; // [sp+Ch] [bp-24h]@1
  float v9; // [sp+10h] [bp-20h]@8
  float v10; // [sp+14h] [bp-1Ch]@13
  float v11; // [sp+18h] [bp-18h]@13
  float v12; // [sp+1Ch] [bp-14h]@13
  float v13; // [sp+20h] [bp-10h]@13
  float v14; // [sp+24h] [bp-Ch]@13
  float v15; // [sp+28h] [bp-8h]@2
  float v16; // [sp+2Ch] [bp-4h]@13

  sub_10014B00((bool *)&v6);
  if ( sub_100188F0(0xC9u, &v8) && sub_100188F0(0xCAu, &v15) )
  {
    if ( !sub_10014780(&v7) )
    {
      if ( v6 )
        v1 = 59501.773;
      else
        v1 = 17857.426;
      v7 = v1;
    }
    if ( !sub_100188F0(0x75u, &v9) )
    {
      if ( v6 )
        v2 = 105007.18;
      else
        v2 = 84667.641;
      v9 = v2;
    }
    v10 = v15 + 273.1499938964844;
    v11 = v10 * v10;
    v12 = v11 * v10;
    v16 = v10 * v12;
    v15 = v7 + v8;
    v13 = v15 * 0.000145037702168338;
    v7 = v13 * v13;
    v8 = v7 * v13;
    v14 = v8 * v13;
    v15 = exp(-v13 / 464.7000122070312);
    v3 = v16;
    v16 = (13.75137901306152 - v10 * 0.1226860210299492 + v11 * 0.0003980170004069805 - v12 * 0.0000004366189898519224)
        * v13
        + 10742.181640625
        - 177.0700836181641 * v10
        + 1.059352517127991 * v11
        - 0.002737746108323336 * v12
        + 0.000002587880089777173 * v16
        + (0.001406852970831096 - v10 * 0.000008421870006714016 + v11 * 0.0000000123934995599484) * v7
        + (v10 * 1.458149920252616e-11 - 0.000000004256659913437488) * v8
        + v14 * 5.409509849069703e-14;
    result = 1;
    v5 = v16 * (1.0 - v15);
    v16 = (0.001010339008644223 - v10 * 0.000006046890121069737 + v11 * 0.000000008856750000063585) * v7
        + v13
        * (4.909426212310791 - v10 * 0.02970160357654095 + v11 * 0.00007757999992463738 - v12
                                                                                        * 0.00000007407909663470491)
        + 329.7364501953125
        - v10 * 4.856092929840088
        + v11 * 0.02650014311075211
        - v12 * 0.00006350519834086299
        + v3 * 0.00000005639689959480165
        + (0.00000001747300082399761 - v10 * 3.771030016030963e-11) * v8
        - v14 * 4.320039985461488e-12;
    v8 = v5 + v16 * v15;
    *a1 = v8 * 6894.75927734375 - v9;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10019310) --------------------------------------------------------
double sub_10019310()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_1003E0A0(10043, &v2, 4, &v1);
  return v2;
}

//----- (10019340) --------------------------------------------------------
double sub_10019340()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_1003E0A0(10002, &v2, 4, &v1);
  return v2;
}

//----- (10019370) --------------------------------------------------------
void __usercall sub_10019370(int a1@<esi>, int a2, float a3)
{
  signed int v3; // ebx@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@3
  double v7; // st6@4
  double v8; // st6@5
  double v9; // st7@5
  double v10; // st6@8
  double v11; // st7@8
  int v12; // edi@10
  signed int v13; // ecx@10
  int v14; // ebx@11
  signed int v15; // edx@11
  int v16; // ebp@13
  float *v17; // eax@19
  int v18; // [sp+4h] [bp-4h]@13
  float *v19; // [sp+10h] [bp+8h]@11
  float v20; // [sp+10h] [bp+8h]@19

  v3 = *(_BYTE *)(a1 + 320);
  v4 = v3 - 1;
  v5 = 0;
  if ( *(float *)(a1 + 8 * v3 - 4) < (double)*(float *)(a1 + 4) )
  {
    v5 = v3 - 1;
    v4 = 0;
  }
  v6 = a3;
  if ( *(float *)(a1 + 8 * v4 + 4) < (double)a3 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v8 = *(float *)(a1 + 8 * v4) / v6;
      v9 = 0.0;
      *(float *)a2 = v8;
      *(float *)(a2 + 4) = *(float *)&v9;
      return;
    }
LABEL_9:
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v7;
    return;
  }
  if ( *(float *)(a1 + 8 * v5 + 4) > v6 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v10 = *(float *)(a1 + 8 * v5) / v6;
      v11 = 0.0;
      *(float *)a2 = v10;
      *(float *)(a2 + 4) = *(float *)&v11;
      return;
    }
    goto LABEL_9;
  }
  v12 = 0;
  v13 = 1;
  if ( v3 <= 1 )
  {
LABEL_18:
    *(float *)a2 = 0.0;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12);
  }
  else
  {
    v14 = 0;
    v15 = 8;
    v19 = (float *)(a1 + 12);
    while ( 1 )
    {
      if ( *(float *)(v14 + a1 + 4) >= (double)*v19 )
      {
        v12 = v13 - 1;
        v14 = v15 - 8;
        v16 = v13;
        v18 = v15;
      }
      else
      {
        v12 = v13;
        v14 = v15;
        v16 = v13 - 1;
        v18 = v15 - 8;
      }
      if ( *(float *)(v14 + a1 + 4) > v6 && *(float *)(v18 + a1 + 4) <= v6 )
        break;
      v19 += 2;
      ++v13;
      v15 += 8;
      if ( v13 >= *(_BYTE *)(a1 + 320) )
        goto LABEL_18;
    }
    v17 = (float *)(a1 + 8 * v12 + 4);
    v20 = (*(float *)(a1 + 8 * v12) - *(float *)(a1 + 8 * v16)) / (*v17 - *(float *)(a1 + 8 * v16 + 4));
    *(float *)a2 = v20;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12) - v20 * *v17;
  }
}

//----- (100194D0) --------------------------------------------------------
char __usercall sub_100194D0@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3)
{
  double v3; // st7@8
  char result; // al@10
  char v5; // [sp+7h] [bp-29h]@3
  float v6; // [sp+8h] [bp-28h]@1
  float v7; // [sp+Ch] [bp-24h]@3
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  float v12[4]; // [sp+20h] [bp-10h]@1

  v6 = 0.0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_1003E0A0(6117, v12, 16, &v8) )
    sub_100129A0("..\\lib\\adl\\iop_eis_intf.c", 2716, 0, 0);
  sub_10012DA0(1, 0x50u, &v5);
  if ( sub_1003E0E0(6354, (int)&v7, 4) )
    sub_100129A0("..\\lib\\adl\\iop_eis_intf.c", 2735, 0, 0);
  if ( (sub_1002ACC0(a2) || v5) && sub_100188F0(a2, &v6) )
  {
    v6 = v12[2 * a3] * v6;
    v3 = v6;
    *a1 = v6;
    if ( v7 > v3 )
      *a1 = 0.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100194D0: using guessed type float var_10[4];

//----- (100195C0) --------------------------------------------------------
char __usercall sub_100195C0@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4)
{
  int v4; // ecx@1
  unsigned __int16 *v5; // esi@1
  char v6; // al@1
  double v7; // st7@1
  int v8; // ebp@1
  unsigned __int8 v9; // bl@4
  char result; // al@7
  int v11; // eax@9
  unsigned __int16 *v12; // edi@9
  int v13; // eax@11
  int v14; // eax@14
  int v15; // eax@17
  double v16; // st7@22
  double v17; // st7@24
  int v18; // edi@31
  int v19; // [sp-8h] [bp-A0h]@12
  int v20; // [sp-4h] [bp-9Ch]@12
  float v21; // [sp+0h] [bp-98h]@12
  float v22; // [sp+14h] [bp-84h]@1
  float v23; // [sp+18h] [bp-80h]@1
  int v24; // [sp+1Ch] [bp-7Ch]@1
  int v25; // [sp+20h] [bp-78h]@5
  float v26; // [sp+24h] [bp-74h]@6
  float v27; // [sp+28h] [bp-70h]@9
  float v28; // [sp+2Ch] [bp-6Ch]@9
  float v29; // [sp+38h] [bp-60h]@10
  float v30; // [sp+3Ch] [bp-5Ch]@11
  float v31; // [sp+48h] [bp-50h]@13
  float v32; // [sp+4Ch] [bp-4Ch]@14
  float v33; // [sp+70h] [bp-28h]@16
  float v34; // [sp+74h] [bp-24h]@17

  v4 = a2;
  v5 = a1;
  *a3 = -1.0;
  v6 = *(_BYTE *)(a2 + 320);
  v7 = 0.0;
  v8 = 0;
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0;
  if ( !v6 || v6 == 1 && 0.0 == *(float *)a2 )
  {
    if ( a4 )
    {
      v18 = a4;
      do
      {
        if ( sub_1002ACC0(*v5) )
        {
          ++v8;
          if ( sub_10018A70((int)v5, *v5, &v22) )
          {
            ++v24;
            v23 = v23 + v22;
          }
        }
        ++v5;
        --v18;
      }
      while ( v18 );
      if ( v8 != v24 )
        goto LABEL_42;
    }
    *a3 = v23;
    if ( v8 <= 0 )
LABEL_42:
      result = 0;
    else
      result = 1;
    return result;
  }
  v9 = 0;
  if ( !a4 )
    goto LABEL_5;
  while ( 2 )
  {
    v28 = v7;
    v11 = v5[v9];
    v27 = v7;
    v12 = &v5[v9];
    switch ( v11 )
    {
      case 58:
      case 59:
        if ( !sub_1003E040(6091, (int)&v29, 16) )
        {
          v13 = 8 * *v12 - 464;
          v28 = *(float *)((char *)&v29 + v13);
          v27 = *(float *)((char *)&v30 + v13);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2889;
        goto LABEL_19;
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
        if ( !sub_1003E040(6090, (int)&v31, 40) )
        {
          v14 = 8 * *v12 - 480;
          v28 = *(float *)((char *)&v31 + v14);
          v27 = *(float *)((char *)&v32 + v14);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2921;
        goto LABEL_19;
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
        if ( sub_1003E040(6092, (int)&v33, 40) )
        {
          v21 = 0.0;
          v20 = 0;
          v19 = 2953;
LABEL_19:
          sub_100129A0("..\\lib\\adl\\iop_eis_intf.c", v19, v20, (char *)LODWORD(v21));
        }
        else
        {
          v15 = 8 * *v12 - 520;
          v28 = *(float *)((char *)&v33 + v15);
          v27 = *(float *)((char *)&v34 + v15);
        }
LABEL_20:
        if ( sub_1002ACC0(*v12) )
        {
          ++v8;
          if ( sub_100188F0(*v12, &v22) )
          {
            v16 = v22;
            if ( v27 >= (double)v22 )
              v16 = v27;
            v22 = v16;
            v17 = v22;
            if ( v28 <= (double)v22 )
              v17 = v28;
            ++v24;
            v22 = v17;
            v23 = v22 + v23;
          }
        }
        if ( ++v9 < a4 )
        {
          v7 = 0.0;
          continue;
        }
        v4 = a2;
LABEL_5:
        sub_10019370(v4, (int)&v25, v23);
        if ( v8 != v24 || (*a3 = *(float *)&v25 * v23 + v26, v8 <= 0) )
LABEL_29:
          result = 0;
        else
          result = 1;
        return result;
      default:
        goto LABEL_29;
    }
  }
}

//----- (100198A0) --------------------------------------------------------
char __cdecl sub_100198A0(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_1003E040(6266, (int)&v2, 324) )
  {
    sub_100129A0("..\\lib\\adl\\iop_eis_intf.c", 590, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100195C0((unsigned __int16 *)&unk_1007937C, (int)&v2, a1, 2u);
  }
  return result;
}

//----- (10019910) --------------------------------------------------------
char __cdecl sub_10019910(float *a1)
{
  return sub_100194D0(a1, 0x14u, 0);
}

//----- (10019930) --------------------------------------------------------
char __cdecl sub_10019930(float *a1)
{
  return sub_100194D0(a1, 0x2Du, 1u);
}

//----- (10019950) --------------------------------------------------------
char __cdecl sub_10019950(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10019910(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10019930(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else if ( v1 )
  {
    result = v1;
    *a1 = v4;
  }
  else
  {
    *a1 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (100199E0) --------------------------------------------------------
char __cdecl sub_100199E0(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_1003E040(6265, (int)&v2, 324) )
  {
    sub_100129A0("..\\lib\\adl\\iop_eis_intf.c", 1606, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100195C0(L"<=>?@", (int)&v2, a1, 5u);
  }
  return result;
}
// 10079388: using guessed type wchar_t a__[6];

//----- (10019A50) --------------------------------------------------------
char __cdecl sub_10019A50(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_1003E040(6266, (int)&v8, 324) )
  {
    sub_100129A0("..\\lib\\adl\\iop_eis_intf.c", 1847, 0, "Center cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L":;<=>?@";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10032330(v4, v5, &v6);
      if ( v1 )
        v1 = sub_100136E0(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000" )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_100195C0((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 10079394: using guessed type wchar_t a___0[8];

//----- (10019B20) --------------------------------------------------------
char __cdecl sub_10019B20(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_1003E040(6265, (int)&v8, 324) )
  {
    sub_100129A0("..\\lib\\adl\\iop_eis_intf.c", 1946, 0, "Left cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10032330(v4, v5, &v6);
      if ( v1 )
        v1 = sub_100136E0(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&a___0[7] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_100195C0((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 10079394: using guessed type wchar_t a___0[8];

//----- (10019BF0) --------------------------------------------------------
char __cdecl sub_10019BF0(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_1003E040(6267, (int)&v8, 324) )
  {
    sub_100129A0("..\\lib\\adl\\iop_eis_intf.c", 2045, 0, "Right cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"ABCDE";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10032330(v4, v5, &v6);
      if ( v1 )
        v1 = sub_100136E0(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&aAbcde_0[5] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_100195C0((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100793A4: using guessed type wchar_t aAbcde_0[6];

//----- (10019CC0) --------------------------------------------------------
char __cdecl sub_10019CC0(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10019A50(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10019B20(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_10019BF0(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10019D60) --------------------------------------------------------
char __cdecl sub_10019D60(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_1003E040(6267, (int)&v2, 324) )
  {
    sub_100129A0("..\\lib\\adl\\iop_eis_intf.c", 2199, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_100195C0(L"ABCDE", (int)&v2, a1, 5u);
  }
  return result;
}
// 100793B0: using guessed type wchar_t aAbcde[6];

//----- (10019DD0) --------------------------------------------------------
double sub_10019DD0()
{
  int v0; // eax@1
  double result; // st7@1
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  double v4; // [sp+8h] [bp-8h]@2

  v3 = 9.8999998e24;
  v0 = sub_1003E0A0(10009, &v2, 4, &v3);
  result = v2;
  if ( !v0 )
  {
    v4 = v2;
    v2 = v4 - sub_10019340();
    if ( v2 >= 0.0 )
    {
      result = v2;
    }
    else
    {
      v2 = 0.0;
      result = (float)0.0;
    }
  }
  return result;
}

//----- (10019E30) --------------------------------------------------------
char __cdecl sub_10019E30(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_100199E0(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_100198A0(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_10019D60(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10019ED0) --------------------------------------------------------
char __cdecl sub_10019ED0(float a1, int a2)
{
  double v2; // st7@1
  long double v3; // st7@1
  char result; // al@2
  float v5; // [sp+4h] [bp+4h]@1
  float v6; // [sp+4h] [bp+4h]@4
  float v7; // [sp+4h] [bp+4h]@5

  v2 = a1;
  v5 = a1 / 101325.0;
  v3 = v2 / 22631.953125;
  if ( v3 > 0.0 )
  {
    if ( v5 <= 0.223360002040863 )
    {
      v7 = log(v3);
      result = 1;
      *(float *)a2 = 11000.232421875 - v7 * 6341.615234375;
    }
    else
    {
      v6 = pow(v5, 0.1902630904662425);
      result = 1;
      *(float *)a2 = (v6 - 1.0) * -44330.76953125;
    }
  }
  else
  {
    *(float *)a2 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (10019F70) --------------------------------------------------------
char __cdecl sub_10019F70(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_10015FF0(13, (char *)&v3 + 3);
  sub_10015FF0(12, a1);
  return BYTE3(v3);
}

//----- (10019FA0) --------------------------------------------------------
char __cdecl sub_10019FA0(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_10019F70((char *)&v4);
  if ( v2 )
  {
    if ( sub_10015F20(v1) == 1 )
      sub_1002ACA0((int *)&v4, v4);
    sub_10014E20(a1, v4);
  }
  return v2;
}

//----- (10019FF0) --------------------------------------------------------
char __cdecl sub_10019FF0(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_10019F70((char *)&v4);
  if ( v2 )
  {
    if ( sub_10015F20(v1) == 1 )
      sub_1002ACA0((int *)&v4, v4);
    sub_10014C40(a1, v4);
  }
  return v2;
}

//----- (1001A040) --------------------------------------------------------
bool __cdecl sub_1001A040(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_1002B2B0(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_10012A10(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_100136E0(v5[0], v6, a2) && !sub_1001A7A0(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (1001A0C0) --------------------------------------------------------
char __cdecl sub_1001A0C0(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_1002B2B0(a1, 0, &v4, &v3) != 1 && sub_1002B2B0(a1, 1u, &v4, &v3) != 1
    || (result = sub_10012DA0(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (1001A130) --------------------------------------------------------
char __cdecl sub_1001A130(unsigned __int16 a1, char a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  unsigned __int16 v4; // ax@1
  int v6; // [sp+0h] [bp-Ch]@1
  int v7; // [sp+4h] [bp-8h]@1
  int v8; // [sp+8h] [bp-4h]@1

  LOBYTE(v6) = -1;
  v7 = 0;
  v3 = sub_1002E8C0(v2);
  LOBYTE(v8) = v3 != 0;
  LOBYTE(v4) = sub_1002B310(a1, v3 != 0, &v6, &v7);
  if ( (_BYTE)v4 == 1 )
  {
    v4 = sub_10012A10(v6);
    if ( (unsigned __int16)v7 < v4 )
      LOBYTE(v4) = sub_100131E0(v6, v7, &a2, 0, 1, 1);
  }
  return v4;
}

//----- (1001A1A0) --------------------------------------------------------
bool __cdecl sub_1001A1A0(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_1002E8C0(v2) != 0;
  return sub_1001A040(a1, a2, v3);
}

//----- (1001A1D0) --------------------------------------------------------
signed int sub_1001A1D0()
{
  signed int result; // eax@3

  if ( (unsigned __int8)byte_101C7154 > 2u )
    sub_100129A0("..\\lib\\adl\\iop_ap_intf.c", 958, 0, 0);
  result = (unsigned __int8)byte_101C7154;
  if ( (unsigned __int8)byte_101C7154 >= 2u )
    result = 2;
  byte_101C7154 = result;
  return result;
}
// 101C7154: using guessed type char byte_101C7154;

//----- (1001A210) --------------------------------------------------------
char __thiscall sub_1001A210(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1003E0E0(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (1001A230) --------------------------------------------------------
char __cdecl sub_1001A230(char a1)
{
  char result; // al@2
  char v2; // [sp+2h] [bp-2h]@1
  char v3; // [sp+3h] [bp-1h]@1

  v3 = 1;
  v2 = 1;
  if ( a1 )
  {
    sub_1003E0A0(9420, &v2, 1, &v3);
    result = v2;
  }
  else
  {
    sub_1003E0A0(9419, &v2, 1, &v3);
    result = v2;
  }
  return result;
}

//----- (1001A280) --------------------------------------------------------
char sub_1001A280()
{
  char v1; // [sp+2h] [bp-2h]@1
  char v2; // [sp+3h] [bp-1h]@1

  v1 = 0;
  v2 = 0;
  sub_1003E0A0(6888, &v1, 1, &v2);
  return v1;
}

//----- (1001A2B0) --------------------------------------------------------
char sub_1001A2B0()
{
  char result; // al@1

  byte_101C7154 = 2;
  result = sub_1002E860(4);
  if ( result )
  {
    byte_101C7154 = 0;
  }
  else
  {
    result = sub_1002E860(7);
    if ( result )
      byte_101C7154 = 1;
  }
  return result;
}
// 101C7154: using guessed type char byte_101C7154;

//----- (1001A2F0) --------------------------------------------------------
double __cdecl sub_1001A2F0(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_1002E8C0(v1);
  if ( sub_1001A210(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_1003E0E0(2015, (int)&v5, 12);
      return v6;
    }
    sub_1003E0E0(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_1003E0E0(2015, (int)&v5, 12);
      return v6;
    }
    sub_1003E0E0(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (1001A370) --------------------------------------------------------
int __cdecl sub_1001A370(unsigned __int8 a1)
{
  void *v1; // ecx@0

  return dword_1007AA80[(unsigned __int8)sub_1002E8C0(v1) + 2 * a1];
}
// 1007AA80: using guessed type int dword_1007AA80[];

//----- (1001A390) --------------------------------------------------------
bool __usercall sub_1001A390@<al>(int a1@<esi>)
{
  signed int v1; // edx@1
  signed int v2; // eax@1
  void *v3; // ecx@5
  int v4; // eax@7
  int v5; // eax@9
  int v6; // edx@11
  bool v7; // zf@13

  v1 = 0x20000000;
  v2 = 178956970;
  if ( *(_BYTE *)(a1 + 1) )
    v1 = 357913941;
  if ( *(_BYTE *)(a1 + 2) )
    v2 = 0x20000000;
  v3 = *(void **)(a1 + 8);
  if ( (signed int)v3 >= v2 )
    v3 = (void *)v2;
  v4 = -v2;
  *(_DWORD *)(a1 + 8) = v3;
  if ( (signed int)v3 > v4 )
    v4 = (int)v3;
  *(_DWORD *)(a1 + 8) = v4;
  v5 = *(_DWORD *)(a1 + 4);
  if ( v5 >= v1 )
    v5 = v1;
  v6 = -v1;
  *(_DWORD *)(a1 + 4) = v5;
  if ( v5 <= v6 )
    v5 = v6;
  v7 = *(_BYTE *)a1 == 0;
  *(_DWORD *)(a1 + 4) = v5;
  return v7 && (unsigned int)sub_1001D4B0(v3) & *(_DWORD *)(a1 + 24);
}

//----- (1001A400) --------------------------------------------------------
bool __usercall sub_1001A400@<al>(int a1@<eax>)
{
  signed int v1; // eax@17
  bool result; // al@19

  result = 0;
  if ( *(_BYTE *)(a1 + 2) < 3u
    && *(_BYTE *)(a1 + 10) < 3u
    && *(_BYTE *)a1 < 8u
    && *(_BYTE *)(a1 + 1) < 0xBu
    && *(_BYTE *)(a1 + 3) < 0xFu
    && *(_BYTE *)(a1 + 4) < 0xDu
    && *(_BYTE *)(a1 + 5) < 6u
    && *(_BYTE *)(a1 + 24) < 0xDu
    && *(_BYTE *)(a1 + 6) < 7u
    && *(_BYTE *)(a1 + 25) < 0xDu
    && *(_BYTE *)(a1 + 7) < 0xEu
    && *(_BYTE *)(a1 + 8) < 0xDu
    && *(_BYTE *)(a1 + 9) < 8u
    && *(_BYTE *)(a1 + 26) < 0xDu
    && *(_BYTE *)(a1 + 11) < 0x13u
    && *(_BYTE *)(a1 + 12) < 0xDu )
  {
    v1 = *(_DWORD *)(a1 + 20);
    if ( v1 >= 0 && v1 <= 357913941 )
      result = 1;
  }
  return result;
}

//----- (1001A470) --------------------------------------------------------
char __cdecl sub_1001A470(char *a1)
{
  char *v1; // edi@1
  char v2; // bl@1
  signed int v3; // ebp@1
  char *v4; // esi@1
  char v5; // al@2
  bool v6; // al@4
  char result; // al@13
  char v8; // dh@15
  bool v9; // al@16
  bool v10; // bl@20
  void *v11; // ecx@22
  char v12; // al@23
  int v13; // eax@23
  __int16 v14; // [sp+10h] [bp-88h]@1
  int v15; // [sp+14h] [bp-84h]@1
  char *v16; // [sp+18h] [bp-80h]@1
  char v17; // [sp+1Ch] [bp-7Ch]@27
  char v18; // [sp+20h] [bp-78h]@16
  char v19; // [sp+3Eh] [bp-5Ah]@29
  char v20; // [sp+58h] [bp-40h]@1
  char v21; // [sp+5Ch] [bp-3Ch]@19
  char v22; // [sp+7Ah] [bp-1Eh]@31

  v16 = a1;
  v15 = 3342386;
  v1 = 0;
  v2 = sub_1001A1D0();
  v14 = 0;
  v3 = 1;
  v4 = &v20;
  do
  {
    v5 = sub_100136E0(1, *((_WORD *)&v15 + v3), v4);
    *((_BYTE *)&v14 + v3) = v5;
    v6 = v5 && !sub_1002E350((unsigned __int8 *)v4);
    *((_BYTE *)&v14 + v3) = v6;
    if ( v6 && *v4 == v2 )
      v1 = v4;
    --v3;
    v4 -= 60;
  }
  while ( v3 >= 0 );
  if ( !v1 )
    return 0;
  if ( v2 )
  {
    if ( v2 != 1 )
      return 0;
    goto LABEL_34;
  }
  v8 = HIBYTE(v14);
  if ( !(_BYTE)v14 || (v9 = sub_1001A400((int)&v18), LOBYTE(v14) = 1, !v9) )
    LOBYTE(v14) = 0;
  v10 = v8 && sub_1001A400((int)&v21);
  if ( sub_1001A280() )
  {
    v12 = sub_1002E8C0(v11);
    LOBYTE(v15) = v12;
    v13 = (unsigned __int8)sub_1001A230(v12) - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        return 0;
      goto LABEL_32;
    }
    if ( !(_BYTE)v14 )
      return 0;
LABEL_27:
    result = 1;
    qmemcpy(v16, &v17, 0x3Cu);
    return result;
  }
  if ( (_BYTE)v14 && (v19 || !v10 || !v22) )
    goto LABEL_27;
LABEL_32:
  if ( !v10 )
    return 0;
  v1 = &v20;
LABEL_34:
  result = 1;
  qmemcpy(v16, v1, 0x3Cu);
  return result;
}

//----- (1001A5F0) --------------------------------------------------------
char __cdecl sub_1001A5F0(void *a1)
{
  char v1; // al@1
  void *v2; // ecx@2
  char v3; // ST10_1@3
  int v4; // eax@3
  int v5; // eax@4
  char v6; // al@6
  char v8; // [sp+8h] [bp-40h]@7
  unsigned __int8 v9; // [sp+16h] [bp-32h]@8

  v1 = sub_1001A1D0();
  if ( v1 )
  {
    if ( v1 != 1 || !sub_100136E0(1, 52, a1) )
      return 0;
    goto LABEL_15;
  }
  if ( sub_1001A280() )
  {
    v3 = sub_1002E8C0(v2);
    v4 = (unsigned __int8)sub_1001A230(v3);
  }
  else
  {
    if ( !sub_1001A470(&v8) )
      return 0;
    v4 = v9;
  }
  v5 = v4 - 1;
  if ( !v5 )
  {
    v6 = sub_100136E0(1, 52, a1);
    goto LABEL_10;
  }
  if ( v5 != 1 )
    return 0;
  v6 = sub_100136E0(1, 53, a1);
LABEL_10:
  if ( !v6 || !sub_1001A390((int)a1) )
    return 0;
LABEL_15:
  if ( sub_1002DC80((int)a1) )
    return 0;
  return 1;
}

//----- (1001A6C0) --------------------------------------------------------
void sub_1001A6C0()
{
  sub_1001A2F0(0);
}

//----- (1001A6D0) --------------------------------------------------------
char __fastcall sub_1001A6D0(int a1)
{
  int v1; // eax@1
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = a1;
  HIWORD(v3) = 0;
  v1 = sub_1001A370(0);
  sub_1003E0A0(v1, (char *)&v3 + 2, 1, (char *)&v3 + 3);
  result = BYTE2(v3);
  if ( BYTE2(v3) >= 3u )
    result = 0;
  return result;
}

//----- (1001A710) --------------------------------------------------------
int __thiscall sub_1001A710(void *this)
{
  int v1; // eax@1
  int v2; // eax@2
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v1 = (unsigned __int8)sub_1001A6D0((int)this);
  if ( (_BYTE)v1 )
  {
    v2 = v1 - 1;
    if ( !v2 )
    {
      sub_1003E2F0(2064, &v4, 4, &v5);
      return v4;
    }
    if ( v2 == 1 )
    {
      sub_1003E2F0(2065, &v4, 4, &v5);
      return v4;
    }
  }
  else
  {
    sub_1003E2F0(2016, &v4, 4, &v5);
  }
  return v4;
}

//----- (1001A7A0) --------------------------------------------------------
signed int __cdecl sub_1001A7A0(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (1001A7F0) --------------------------------------------------------
int __cdecl sub_1001A7F0(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1001A8E0) --------------------------------------------------------
unsigned int __cdecl sub_1001A8E0(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1001A930) --------------------------------------------------------
unsigned int __cdecl sub_1001A930(_BYTE *a1, __int16 a2, __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  int v8; // eax@9
  char v9; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((signed __int16)a1 >= a2 ? (v8 = (signed __int16)a1 < a3,
                                    LOBYTE(v8) = (signed __int16)a1 <= a3,
                                    result = (v8 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v9 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v9;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1001A9D0) --------------------------------------------------------
unsigned int __cdecl sub_1001A9D0(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1001AA90) --------------------------------------------------------
signed int __cdecl sub_1001AA90(void *a1, size_t a2, int a3)
{
  signed int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_1001D770(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (1001AAF0) --------------------------------------------------------
int __cdecl sub_1001AAF0(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (1001AB40) --------------------------------------------------------
int __cdecl sub_1001AB40(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (1001ABE0) --------------------------------------------------------
int __cdecl sub_1001ABE0(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (1001AC90) --------------------------------------------------------
char __cdecl sub_1001AC90(int a1, int a2, void *a3)
{
  char v3; // bl@1
  int v4; // eax@1
  unsigned __int16 v5; // bp@1
  int v6; // esi@4
  int v7; // eax@6
  char v8; // al@7
  unsigned __int8 v9; // dl@10
  __int16 v10; // cx@10
  char v11; // dl@12
  char v12; // ST2C_1@13
  char v13; // bl@14
  float v14; // ST30_4@16
  double v15; // st7@16
  char v16; // ST2C_1@16
  char v18; // [sp+18h] [bp-5Ch]@10
  char v19; // [sp+18h] [bp-5Ch]@14
  unsigned __int8 v20; // [sp+1Bh] [bp-59h]@1
  unsigned __int16 v21; // [sp+1Ch] [bp-58h]@14
  unsigned int v22; // [sp+20h] [bp-54h]@12
  int v23; // [sp+24h] [bp-50h]@1
  int v24; // [sp+28h] [bp-4Ch]@1
  unsigned __int64 v25; // [sp+2Ch] [bp-48h]@13
  char v26[8]; // [sp+34h] [bp-40h]@14
  char v27[8]; // [sp+3Ch] [bp-38h]@15
  char v28[44]; // [sp+44h] [bp-30h]@7

  v3 = 0;
  v24 = a1;
  v4 = a2;
  *(_BYTE *)a3 = 0;
  v5 = *(_WORD *)(a2 + 16);
  v23 = a2;
  v20 = 0;
  while ( v20 < *(_BYTE *)(v4 + 18) )
  {
    v6 = v24 + 10 * v5 + 22534;
    if ( *(_BYTE *)v6 == 1 )
    {
      v14 = (double)*(_WORD *)(v24 + 10 * v5 + 22542) * 0.125;
      v15 = sub_10041A70(v14, 1.0);
      v16 = *(_WORD *)(v6 + 8) % 8;
      v3 = sub_1002B790(*(_BYTE *)(v6 + 4), *(_WORD *)(v6 + 6), (signed int)v15, 1, a3);
      v11 = ((unsigned __int8)(1 << v16) & *(_BYTE *)a3) != 0;
LABEL_17:
      *(_BYTE *)a3 = v11;
    }
    else if ( *(_BYTE *)v6 == 2 )
    {
      v7 = *(_BYTE *)(v24 + 10 * v5 + 22538);
      switch ( v7 )
      {
        case 0:
        case 1:
          v3 = sub_1002B790(6, (unsigned __int16)word_1007AB08[v7], 0, 44, v28);
          v8 = v28[*(_BYTE *)(v6 + 5)];
          *(_BYTE *)a3 = v8 == 1;
          if ( !v8 || v8 == 3 )
            v3 = 0;
          break;
        case 2:
        case 3:
        case 4:
          v9 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          v10 = 0;
          v18 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          if ( v9 >= 0x18u )
          {
            v10 = 4;
            v18 = v9 - 24;
          }
          v3 = sub_1002B790(0, (unsigned __int16)word_1007AB08[v7], v10, 4, &v22);
          v11 = (v22 >> v18) & 1;
          goto LABEL_17;
        case 5:
        case 6:
        case 7:
        case 8:
          v12 = *(_BYTE *)(v24 + 10 * v5 + 22539) - 79;
          v3 = sub_1002B790(0, (unsigned __int16)word_1007AB08[v7], 0, 8, &v25);
          *(_BYTE *)a3 = (v25 >> v12) & 1;
          break;
        case 9:
        case 10:
        case 11:
        case 12:
          v13 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          v21 = sub_10041A30((unsigned int)*(_BYTE *)(v24 + 10 * v5 + 22539) >> 3, 1);
          v19 = v13 - 8 * v21;
          v3 = sub_1002B790(6, (unsigned __int16)word_1007AB08[*(_BYTE *)(v6 + 4)], 0, 16, v26);
          if ( !v3 )
            break;
          v3 = ((unsigned __int8)v26[v21] >> v19) & 1;
          v11 = ((unsigned __int8)v27[v21] >> v19) & 1;
          goto LABEL_17;
        default:
          break;
      }
    }
    ++v20;
    ++v5;
    if ( v3 )
      break;
    v4 = v23;
  }
  return v3;
}
// 1007AB08: using guessed type __int16 word_1007AB08[];
// 1001AC90: using guessed type char var_30[44];
// 1001AC90: using guessed type char var_40[8];
// 1001AC90: using guessed type char var_38[8];

//----- (1001AF30) --------------------------------------------------------
char __cdecl sub_1001AF30(unsigned __int16 a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(_BYTE *)a2 = 0;
  v2 = sub_1002ED50(a1);
  v3 = sub_1002B7B0();
  if ( v2 && v3 && !*(_WORD *)(v2 + 12) )
    result = sub_1001AC90(v3, v2, a2);
  else
    result = 0;
  return result;
}

//----- (1001AF80) --------------------------------------------------------
bool sub_1001AF80()
{
  void *v0; // ecx@2
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v2 = 0;
  sub_1003E0A0(9373, &v3, 4, &v2);
  return v3 && !(unsigned __int8)sub_10016110() && sub_100160D0(v0) != 4;
}

//----- (1001AFD0) --------------------------------------------------------
signed int sub_1001AFD0()
{
  signed int result; // eax@1

  result = -15;
  dword_102AD584 = -15;
  dword_102AD580 = -15;
  return result;
}
// 102AD580: using guessed type int dword_102AD580;
// 102AD584: using guessed type int dword_102AD584;

//----- (1001AFE0) --------------------------------------------------------
signed int sub_1001AFE0()
{
  return sub_1003ED70((int)&off_1007B358);
}
// 1007B358: using guessed type char *off_1007B358;

//----- (1001AFF0) --------------------------------------------------------
signed int sub_1001AFF0()
{
  return sub_1003ED70((int)&off_1007B36C);
}
// 1007B36C: using guessed type char *off_1007B36C;

//----- (1001B000) --------------------------------------------------------
char __cdecl sub_1001B000(char a1, int a2, void *a3)
{
  char v3; // bl@1
  const void *v5; // edx@7

  v3 = 0;
  if ( !a1 )
  {
    if ( !(unsigned __int8)sub_1001AFE0() || (unsigned int)a2 >= 0xA )
      return v3;
    v5 = (const void *)(6916 * a2 + dword_102AD584 + 136004);
    goto LABEL_14;
  }
  if ( a1 == 1 )
  {
    if ( !(unsigned __int8)sub_1001AFF0() || (unsigned int)a2 >= 0xA )
      return v3;
    v5 = (const void *)(6916 * a2 + dword_102AD580 + 136044);
    goto LABEL_14;
  }
  if ( a1 != 2 )
    return 0;
  if ( (unsigned __int8)sub_1001AFF0() && (unsigned int)a2 < 0xA )
  {
    v5 = (const void *)(6916 * a2 + dword_102AD580 + 237208);
LABEL_14:
    v3 = 1;
    memcpy(a3, v5, 0x1B04u);
  }
  return v3;
}
// 102AD580: using guessed type int dword_102AD580;
// 102AD584: using guessed type int dword_102AD584;

//----- (1001B0B0) --------------------------------------------------------
char __cdecl sub_1001B0B0(unsigned __int16 a1, unsigned __int16 a2)
{
  char result; // al@5

  if ( a2 >= 0x2710u )
  {
    result = 0;
  }
  else
  {
    if ( a1 >= 0x9C4u )
      goto LABEL_16;
    if ( (unsigned __int16)(a1 - 1000) <= 0x3E7u && (unsigned __int8)sub_1001AFF0() )
      return *(_BYTE *)(dword_102AD580 + 12 * a2 + 40);
    if ( (unsigned __int16)(a1 - 2000) <= 0x1F3u && (unsigned __int8)sub_1001AFF0() )
      return *(_BYTE *)(dword_102AD580 + 12 * a2 + 205204);
    if ( a1 <= 0x3E7u && (unsigned __int8)sub_1001AFE0() )
      result = *(_BYTE *)(dword_102AD584 + 12 * a2);
    else
LABEL_16:
      result = 0;
  }
  return result;
}
// 102AD580: using guessed type int dword_102AD580;
// 102AD584: using guessed type int dword_102AD584;

//----- (1001B160) --------------------------------------------------------
char __cdecl sub_1001B160(char a1, int a2, void *a3)
{
  char v3; // bl@1
  void *v5; // eax@7

  v3 = 0;
  if ( !a1 )
  {
    if ( !(unsigned __int8)sub_1001AFE0() || (unsigned int)a2 >= 0xA )
      return v3;
    v5 = (void *)(6916 * a2 + dword_102AD584 + 136004);
    goto LABEL_14;
  }
  if ( a1 == 1 )
  {
    if ( !(unsigned __int8)sub_1001AFF0() || (unsigned int)a2 >= 0xA )
      return v3;
    v5 = (void *)(6916 * a2 + dword_102AD580 + 136044);
    goto LABEL_14;
  }
  if ( a1 != 2 )
    return 0;
  if ( (unsigned __int8)sub_1001AFF0() && (unsigned int)a2 < 0xA )
  {
    v5 = (void *)(6916 * a2 + dword_102AD580 + 237208);
LABEL_14:
    v3 = 1;
    memcpy(v5, a3, 0x1B04u);
  }
  return v3;
}
// 102AD580: using guessed type int dword_102AD580;
// 102AD584: using guessed type int dword_102AD584;

//----- (1001B210) --------------------------------------------------------
char __cdecl sub_1001B210(int a1, int a2, char a3, bool *a4, char *a5)
{
  unsigned __int8 v5; // al@1
  int v6; // ecx@4
  unsigned __int16 v7; // dx@4
  __int16 v8; // ax@7
  char result; // al@9

  v5 = sub_1001B390(a2);
  if ( v5 < 3u && a4 && a5 )
  {
    v6 = 6 * v5;
    v7 = a2 - word_1007D760[v6];
    if ( v5 == a3 && v7 < (unsigned __int16)word_1007D764[v6] && a1 )
      v8 = *(_WORD *)(160 * v7 + a1 + 156);
    else
      v8 = sub_1001B3C0(v7, v5);
    *a4 = (unsigned __int8)sub_1001B0B0(a2, v8) >= 2u;
    *a5 = sub_100138F0(a2);
    result = 1;
  }
  else
  {
    sub_100129A0("..\\lib\\adl\\mon_intf.c", 365, 0, 0);
    result = 0;
  }
  return result;
}
// 1007D760: using guessed type __int16 word_1007D760[];
// 1007D764: using guessed type __int16 word_1007D764[];

//----- (1001B2E0) --------------------------------------------------------
char __cdecl sub_1001B2E0(int a1)
{
  char result; // al@1

  result = 0;
  if ( !a1 || *(_WORD *)a1 == -1 || !*(_BYTE *)(a1 + 2) || *(_BYTE *)(a1 + 127) & 0x40 || *(_WORD *)(a1 + 156) == -1 )
    result = 1;
  return result;
}

//----- (1001B310) --------------------------------------------------------
char sub_1001B310()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_1003E0E0(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 1001B310: using guessed type int var_1C[7];

//----- (1001B390) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001B390(unsigned __int16 a1)
{
  unsigned __int8 result; // al@1
  int v2; // ecx@2

  result = 0;
  do
  {
    v2 = 6 * result;
    if ( a1 >= (unsigned __int16)word_1007D760[v2] && a1 <= (unsigned __int16)word_1007D762[v2] )
      break;
    ++result;
  }
  while ( result < 3u );
  return result;
}
// 1007D760: using guessed type __int16 word_1007D760[];
// 1007D762: using guessed type __int16 word_1007D762[];

//----- (1001B3C0) --------------------------------------------------------
__int16 __cdecl sub_1001B3C0(unsigned __int16 a1, unsigned __int8 a2)
{
  int v2; // edi@3
  __int16 result; // ax@4

  if ( a2 >= 3u )
  {
    result = -1;
  }
  else if ( a1 >= (unsigned __int16)word_1007D764[6 * a2]
         || (memset(&unk_10221718, 0, 0x3E84u),
             v2 = a1 % 100,
             sub_1003E040(dword_1007D784[a2] + a1 / 100, (int)&unk_10221718, 16004)) )
  {
    result = -1;
  }
  else
  {
    result = word_102217B4[80 * (unsigned __int16)v2];
  }
  return result;
}
// 1007D764: using guessed type __int16 word_1007D764[];
// 1007D784: using guessed type int dword_1007D784[];
// 102217B4: using guessed type __int16 word_102217B4[];

//----- (1001B450) --------------------------------------------------------
bool sub_1001B450()
{
  unsigned int v0; // esi@1
  bool result; // al@4
  char v2; // [sp+8h] [bp-120h]@1
  __int16 v3; // [sp+24h] [bp-104h]@3

  memset(&v2, 0, 0x11Cu);
  v0 = 0;
  do
  {
    result = !sub_1003E040((int)(&byte_1021F778[37000 - (_DWORD)byte_1021F778] + v0), (int)&v2, 284) && v3 == -1;
    byte_1021F778[v0++] = result;
  }
  while ( v0 < 0x5C );
  byte_10226EA0 = 1;
  return result;
}
// 10226EA0: using guessed type char byte_10226EA0;

//----- (1001B4F0) --------------------------------------------------------
char __cdecl sub_1001B4F0(unsigned int a1)
{
  char result; // al@4

  if ( !byte_10226EA0 )
  {
    sub_100129A0(
      "..\\lib\\adl\\mon_cnfg_intf.c",
      1236,
      0,
      "Audio Message Is Continuous Array has NOT been initialized.  Initializing now.");
    sub_1001B450();
  }
  if ( a1 >= 0x5C )
    result = 0;
  else
    result = byte_1021F778[a1];
  return result;
}
// 10226EA0: using guessed type char byte_10226EA0;

//----- (1001B530) --------------------------------------------------------
double __fastcall sub_1001B530(int a1, int a2)
{
  int v2; // edx@1
  unsigned int v3; // eax@2
  float v6; // [sp+0h] [bp-4h]@1

  v6 = 0.0;
  if ( !sub_1001B2E0(a2) )
  {
    v3 = *(_DWORD *)(v2 + 128);
    if ( !v3 )
      return (float)(0.0 + 1.0);
    v6 = 1000.0 / (double)v3 + 0.0;
  }
  return v6;
}

//----- (1001B590) --------------------------------------------------------
void *__cdecl sub_1001B590(__int16 a1)
{
  unsigned int v1; // esi@2
  void *result; // eax@2
  int v3; // eax@3
  char *v4; // ebp@3
  bool v5; // zf@3
  __int16 v6; // bx@5
  int v7; // esi@10
  __int16 v8; // cx@10
  _WORD v9; // ax@10
  __int16 v10; // bp@13
  int v11; // esi@18
  char *v12; // ST30_4@18
  unsigned int v13; // esi@18
  unsigned int v14; // edi@18
  char v15; // al@18
  int v16; // ecx@18
  __int16 v17; // dx@18
  char v18; // al@18
  char v19; // al@18
  int v20; // edx@18
  int v21; // edx@18
  int v22; // [sp+8h] [bp-8h]@3
  int v23; // [sp+Ch] [bp-4h]@3

  if ( (unsigned __int16)a1 < 0x19Fu )
  {
    v22 = (unsigned __int16)(a1 + 2000);
    v3 = 8 * (unsigned __int16)sub_1001CD60(&v22, 2u, (int)&unk_1008FC50, 8, 415, 0xFFFF);
    v4 = (char *)&unk_1008FC52 + v3;
    v5 = a1 == *(_WORD *)((char *)&unk_1008FC52 + v3);
    v23 = v3;
    if ( !v5 )
      sub_100129A0("..\\lib\\adl\\mon_cnfg_intf.c", 1441, 0, 0);
    v6 = 0;
    do
    {
      if ( !byte_101C7160[64 * (unsigned __int16)v6] )
        break;
      ++v6;
    }
    while ( (unsigned __int16)v6 < 0x258u );
    if ( v6 == 600 )
      v6 = a1;
    v7 = (unsigned __int16)v6 << 6;
    memset(&byte_101C7160[v7], 0, 0x40u);
    v8 = *(_WORD *)v4;
    byte_101C7160[v7] = 13;
    byte_101C7161[v7] = 0;
    *(__int16 *)((char *)&word_101C7162 + v7) = v8;
    *(__int16 *)((char *)&word_101C7164 + v7) = 0;
    *(int *)((char *)&dword_101C7168 + v7) = 512;
    byte_101C716C[v7] = 1;
    byte_101C7170[v7] = 4;
    byte_101C7174[v7] = 1;
    byte_101C7178[v7] = 5;
    *(int *)((char *)&dword_101C717C + v7) = 0;
    *(int *)((char *)&dword_101C7180 + v7) = 0;
    *(__int16 *)((char *)&word_101C7184 + v7) = 0;
    byte_101C719B[v7] = 0;
    *(int *)((char *)&dword_101C719C + v7) = 0;
    v9 = sub_1001CD60(v4, 2u, (int)&unk_10090EF0, 8, 415, 0xFFFF);
    if ( v9 == -1 )
      sub_100129A0("..\\lib\\adl\\mon_cnfg_intf.c", 1526, 0, 0);
    else
      sub_1001D720((int)&unk_101C7186 + v7, off_10090EF4[2 * v9], 21);
    v10 = 0;
    do
    {
      if ( LOWORD(dword_101E0F70[2 * (unsigned __int16)v10]) == -1 )
        break;
      ++v10;
    }
    while ( (unsigned __int16)v10 < 0x7D0u );
    if ( v10 == 2000 )
      v10 = a1;
    v11 = 2 * (unsigned __int16)v10;
    dword_101E0F70[v11] = 0;
    dword_101E0F74[v11] = 0;
    v12 = (char *)&dword_1008FC54 + v23;
    LOWORD(dword_101E0F70[v11]) = v6;
    HIWORD(dword_101E0F70[v11]) = -1;
    LOWORD(dword_101E0F74[v11]) = -1;
    BYTE2(dword_101E0F74[v11]) = sub_1001CD60(v12, 4u, (int)&unk_10090948, 12, 32, 0xFFFF) != 0xFFFF ? 0x10 : 0;
    v13 = 160 * (unsigned __int16)a1;
    memset((char *)&unk_101F8678 + 160 * (unsigned __int16)a1, 0, 0x9Cu);
    v14 = 156 * (unsigned __int16)a1;
    *((_WORD *)&unk_101F8678 + 80 * (unsigned __int16)a1) = *(_WORD *)&aAhrs1Tas[v14];
    sub_1001D720((int)&unk_101F867A + v13, &aAhrs1Tas[v14 + 2], 31);
    sub_1001D720((int)&unk_101F8699 + v13, &aAhrs1NotReceiv[v14], 51);
    sub_1001D720((int)&unk_101F86CC + v13, &byte_1007FFBC[v14], 21);
    sub_1001D720((int)&unk_101F86E1 + v13, &byte_1007FFD1[v14], 21);
    v15 = byte_1007FFE7[v14];
    v16 = dword_1007FFE8[v14 / 4];
    byte_101F86F6[v13] = byte_1007FFE6[v14];
    v17 = word_1007FFEC[v14 / 2];
    byte_101F86F7[v13] = v15;
    v18 = byte_1007FFEE[v14];
    dword_101F86F8[v13 / 4] = v16;
    LOBYTE(v16) = byte_1007FFEF[v14];
    word_101F86FC[v13 / 2] = v17;
    LOBYTE(v17) = byte_1007FFF0[v14];
    byte_101F86FE[v13] = v18;
    v19 = byte_1007FFF1[v14];
    byte_101F86FF[v13] = v16;
    LOWORD(v16) = word_1007FFF2[v14 / 2];
    byte_101F8700[v13] = v17;
    v20 = dword_1007FFF4[v14 / 4];
    byte_101F8701[v13] = v19;
    word_101F8702[v13 / 2] = v16;
    dword_101F8704[v13 / 4] = v20;
    LOWORD(v16) = word_1007FFFC[v14 / 2];
    result = (void *)dword_1007FFF8[v14 / 4];
    v21 = dword_10080000[v14 / 4];
    word_101F8714[v13 / 2] = v10;
    dword_101F8708[v13 / 4] = (int)result;
    word_101F870C[v13 / 2] = v16;
    dword_101F8710[v13 / 4] = v21;
  }
  else
  {
    v1 = 160 * (unsigned __int16)a1;
    result = memset((char *)&unk_101F8678 + v1, 0, 0xA0u);
    *(_WORD *)((char *)&unk_101F8678 + v1) = -1;
    word_101F8714[v1 / 2] = -1;
  }
  return result;
}
// 1001B590: too many cbuild loops
// 1007FFE8: using guessed type int dword_1007FFE8[];
// 1007FFEC: using guessed type __int16 word_1007FFEC[];
// 1007FFF2: using guessed type __int16 word_1007FFF2[];
// 1007FFF4: using guessed type int dword_1007FFF4[];
// 1007FFF8: using guessed type int dword_1007FFF8[];
// 1007FFFC: using guessed type __int16 word_1007FFFC[];
// 10080000: using guessed type int dword_10080000[];
// 101C7162: using guessed type __int16 word_101C7162;
// 101C7164: using guessed type __int16 word_101C7164;
// 101C7168: using guessed type int dword_101C7168;
// 101C717C: using guessed type int dword_101C717C;
// 101C7180: using guessed type int dword_101C7180;
// 101C7184: using guessed type __int16 word_101C7184;
// 101C719C: using guessed type int dword_101C719C;
// 101E0F70: using guessed type int dword_101E0F70[];
// 101E0F74: using guessed type int dword_101E0F74[];
// 101F86F8: using guessed type int dword_101F86F8[];
// 101F86FC: using guessed type __int16 word_101F86FC[];
// 101F8702: using guessed type __int16 word_101F8702[];
// 101F8704: using guessed type int dword_101F8704[];
// 101F8708: using guessed type int dword_101F8708[];
// 101F870C: using guessed type __int16 word_101F870C[];
// 101F8710: using guessed type int dword_101F8710[];
// 101F8714: using guessed type __int16 word_101F8714[];

//----- (1001B900) --------------------------------------------------------
char __usercall sub_1001B900@<al>(unsigned __int16 a1@<ax>, int a2, char *a3)
{
  char result; // al@3
  int v4; // [sp+0h] [bp-4h]@1

  v4 = (unsigned __int16)(a1 + 2000);
  if ( sub_1001B2E0(a2 + 160 * a1) && sub_1001CD60(&v4, 2u, (int)&unk_10091BE8, 2, 60, 60) != 60 )
  {
    sprintf(a3, "Error:  TSO required system alert with alert id %i cannot be disabled.", (unsigned __int16)v4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1001B970) --------------------------------------------------------
char __usercall sub_1001B970@<al>(int a1@<eax>, unsigned __int16 a2@<di>, char *a3@<esi>)
{
  char result; // al@2
  signed __int16 v4; // cx@8
  unsigned __int16 v5; // ax@14

  if ( *(_BYTE *)a1 < 0x12u )
  {
    if ( *(_BYTE *)(a1 + 1) < 5u )
    {
      if ( *(_BYTE *)(a1 + 16) >= 0xBu || *(_BYTE *)(a1 + 24) >= 0xBu )
      {
        sprintf(a3, "Invalid operation for trigger %i", a2);
        result = 0;
      }
      else
      {
        switch ( *(_BYTE *)a1 )
        {
          case 1:
            v4 = 793;
            goto LABEL_21;
          case 2:
            v4 = 472;
            goto LABEL_21;
          case 0xB:
            v4 = 741;
            goto LABEL_21;
          case 3:
            v4 = 836;
            goto LABEL_21;
          case 4:
            v4 = 3020;
            goto LABEL_21;
          case 5:
            v4 = 904;
            goto LABEL_21;
          case 0xA:
            v5 = *(_BYTE *)(a1 + 2);
            v4 = 31;
            goto LABEL_22;
          case 6:
          case 7:
          case 9:
            v4 = 2415;
            goto LABEL_21;
          case 8:
            v4 = 132;
            goto LABEL_21;
          case 0xD:
            v4 = 415;
            goto LABEL_21;
          case 0xC:
            v4 = -23470;
            goto LABEL_21;
          case 0xE:
          case 0xF:
            v4 = 4067;
            goto LABEL_21;
          case 0x11:
            v4 = 60;
LABEL_21:
            v5 = *(_WORD *)(a1 + 2);
LABEL_22:
            if ( v5 < (unsigned __int16)v4 )
              goto LABEL_24;
            sprintf(a3, "Invalid id for trigger %i", a2);
            result = 0;
            break;
          default:
LABEL_24:
            result = 1;
            break;
        }
      }
    }
    else
    {
      sprintf(a3, "Invalid data type for trigger %i", a2);
      result = 0;
    }
  }
  else
  {
    sprintf(a3, "Invalid source for trigger %i", a2);
    result = 0;
  }
  return result;
}

//----- (1001BAB0) --------------------------------------------------------
int sub_1001BAB0()
{
  int v0; // ebx@1
  int v1; // ebp@1
  void *v2; // eax@2
  signed int v3; // edx@2
  char *v4; // edi@3
  char *v5; // esi@3
  int v6; // ebx@5
  void *v7; // edx@6
  signed int v8; // ebp@6
  char *v9; // edi@7
  char *v10; // esi@7
  bool v11; // zf@8
  int v12; // esi@9
  int v13; // edi@9
  signed int v14; // ebx@9
  void *v15; // eax@10
  signed int v16; // edx@10
  int v17; // ecx@11
  int result; // eax@12
  signed int v19; // [sp+10h] [bp-8h]@1
  int v20; // [sp+10h] [bp-8h]@5
  signed int v21; // [sp+14h] [bp-4h]@5

  v0 = 0;
  v1 = 25000;
  v19 = 6;
  do
  {
    v2 = &unk_102255A0;
    v3 = 100;
    do
    {
      v4 = (char *)v2;
      v5 = &byte_101C7160[64 * (unsigned __int16)v0++];
      v2 = (char *)v2 + 64;
      --v3;
      qmemcpy(v4, v5, 0x40u);
    }
    while ( v3 );
    sub_1003E110(v1++, (int)&unk_102255A0, 6400);
    --v19;
  }
  while ( v19 );
  v6 = 0;
  v20 = 23000;
  v21 = 5;
  do
  {
    v7 = &unk_101F47F0;
    v8 = 100;
    do
    {
      v9 = (char *)v7;
      v10 = (char *)&unk_101F8678 + 160 * (unsigned __int16)v6++;
      v7 = (char *)v7 + 160;
      --v8;
      qmemcpy(v9, v10, 0xA0u);
    }
    while ( v8 );
    sub_1003E110(v20, (int)&unk_101F47F0, 16004);
    v11 = v21-- == 1;
    ++v20;
  }
  while ( !v11 );
  v12 = 0;
  v13 = 24000;
  v14 = 2;
  do
  {
    v15 = &unk_1021F7D8;
    v16 = 1000;
    do
    {
      v17 = dword_101E0F74[2 * (unsigned __int16)v12];
      *(_DWORD *)v15 = dword_101E0F70[2 * (unsigned __int16)v12];
      *((_DWORD *)v15 + 1) = v17;
      ++v12;
      v15 = (char *)v15 + 8;
      --v16;
    }
    while ( v16 );
    result = sub_1003E110(v13++, (int)&unk_1021F7D8, 8000);
    --v14;
  }
  while ( v14 );
  return result;
}
// 101E0F70: using guessed type int dword_101E0F70[];
// 101E0F74: using guessed type int dword_101E0F74[];

//----- (1001BC00) --------------------------------------------------------
void *sub_1001BC00()
{
  char *v0; // eax@1
  signed int v1; // ecx@1
  int *v2; // eax@3
  signed int v3; // ecx@3
  __int16 v4; // si@5
  void *result; // eax@6

  memset(&unk_101F8678, 0, 0x13880u);
  memset(dword_101E0F70, 0, 0x3E80u);
  memset(byte_101C7160, 0, 0x9600u);
  v0 = byte_101C7160;
  v1 = 600;
  do
  {
    *v0 = 0;
    v0 += 64;
    --v1;
  }
  while ( v1 );
  v2 = dword_101E0F70;
  v3 = 2000;
  do
  {
    *(_WORD *)v2 = -1;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  do
    result = sub_1001B590(v4++);
  while ( (unsigned __int16)v4 < 0x1F4u );
  return result;
}
// 101E0F70: using guessed type int dword_101E0F70[];

//----- (1001BC80) --------------------------------------------------------
char __cdecl sub_1001BC80(int a1, int a2, int a3, int a4, int a5, int a6, char *a7)
{
  unsigned __int16 v7; // cx@1
  signed __int16 v8; // dx@1
  int v9; // ebp@5
  int v10; // edi@6
  _WORD *v11; // eax@6
  unsigned __int16 v12; // ax@6
  char v13; // cl@14
  unsigned __int16 v14; // cx@17
  char result; // al@22
  unsigned __int16 v16; // ax@33
  __int16 v17; // cx@36
  unsigned __int16 v18; // ax@39
  _WORD *v19; // [sp+10h] [bp-4h]@6

  v7 = a4;
  v8 = 0;
  if ( (_WORD)a4 == -1 )
  {
LABEL_47:
    result = 1;
  }
  else
  {
    while ( 2 )
    {
      if ( ++*(_WORD *)a5 > 0x64u )
      {
        sprintf(a7, "Maximum number of nodes exceeded for alert %i", (unsigned __int16)a2);
LABEL_49:
        result = 0;
      }
      else
      {
        v9 = v7;
        if ( byte_101DE860[v7] )
        {
          sprintf(a7, "Reuse of nodes is not allowed: alert %i node %i", (unsigned __int16)a2, v7);
          result = 0;
        }
        else
        {
          v10 = a2;
          v11 = (_WORD *)(a1 + 160 * (unsigned __int16)a2);
          byte_101DE860[v7] = 1;
          v19 = v11;
          v12 = *v11;
          if ( v12 < 0x7D0u || v12 > 0x9C3u )
          {
            if ( v12 >= 0x3E8u && v12 <= 0x7CFu || v12 <= 0x3E7u )
              v8 = 1499;
          }
          else
          {
            v8 = 599;
          }
          if ( v12 != -1
            && (v13 = *(_BYTE *)(a3 + 8 * v7 + 6), v13 != 13)
            && v13 != 14
            && v13 != 12
            && (v14 = *(_WORD *)(a3 + 8 * v9), v14 > (unsigned __int16)v8)
            && v14 != -1 )
          {
            sprintf(a7, "Invalid trigger for alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
            result = 0;
          }
          else
          {
            switch ( *(_BYTE *)(a3 + 8 * v9 + 6) )
            {
              case 0xD:
              case 0xE:
                if ( *(_WORD *)(a3 + 8 * v9) >= 0x96Fu )
                {
                  sprintf(a7, "Invalid alert id for alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                else
                {
                  if ( *(_WORD *)(a3 + 8 * v9 + 2) == -1 )
                    goto LABEL_44;
                  sprintf(a7, "Alert node with children: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                return result;
              case 0:
              case 0x10:
                if ( *(_BYTE *)(a3 + 8 * v9 + 6) == 16 && v12 != -1 && (v12 < 0x7D0u || v12 > 0x9C3u) )
                {
                  sprintf(a7, "Text nodes are only allowed for system alerts: alert %i", (unsigned __int16)a2);
                  result = 0;
                }
                else if ( *(_WORD *)(a3 + 8 * v9) == -1 )
                {
                  sprintf(a7, "Leaf node without trigger: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                else
                {
                  if ( *(_WORD *)(a3 + 8 * v9 + 2) == -1 )
                  {
                    if ( sub_1001B970(a6 + (*(_WORD *)(a3 + 8 * v9) << 6), *(_WORD *)(a3 + 8 * v9), a7) )
                      goto LABEL_43;
                    sprintf(a7, "%s, used in alert %i node %i", a7, (unsigned __int16)a2, (unsigned __int16)a4);
                    goto LABEL_31;
                  }
                  sprintf(a7, "Leaf node with children: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                return result;
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                if ( *(_WORD *)(a3 + 8 * v9) == -1 )
                {
                  v16 = *(_WORD *)(a3 + 8 * v9 + 2);
                  if ( v16 == -1 )
                  {
                    sprintf(
                      a7,
                      "No children for gate node: alert %i node %i",
                      (unsigned __int16)a2,
                      (unsigned __int16)a4);
                    result = 0;
                  }
                  else
                  {
                    if ( *(_WORD *)(a3 + 8 * v16 + 4) != -1 )
                      goto LABEL_44;
                    sprintf(
                      a7,
                      "Not enough children for gate node: alert %i node %i",
                      (unsigned __int16)a2,
                      (unsigned __int16)a4);
                    result = 0;
                  }
                }
                else
                {
                  sprintf(a7, "Gate node with trigger: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                return result;
              case 7:
              case 9:
              case 0xA:
                v17 = *(_WORD *)(a3 + 8 * v9);
                if ( v17 == -1 )
                  goto LABEL_39;
                if ( *(_WORD *)(a3 + 8 * v9 + 2) != -1 )
                  goto LABEL_59;
                if ( v17 != -1 )
                  goto LABEL_42;
LABEL_39:
                v18 = *(_WORD *)(a3 + 8 * v9 + 2);
                if ( v18 == -1 || *(_WORD *)(a3 + 8 * v18 + 4) != -1 )
                {
LABEL_59:
                  sprintf(a7, "Incorrect input for node: alert %i node %i", (unsigned __int16)a2, (unsigned __int16)a4);
                  result = 0;
                }
                else
                {
                  if ( v17 == -1 )
                    goto LABEL_44;
LABEL_42:
                  if ( sub_1001B970(a6 + (*(_WORD *)(a3 + 8 * v9) << 6), *(_WORD *)(a3 + 8 * v9), a7) )
                  {
LABEL_43:
                    v10 = a2;
LABEL_44:
                    if ( (_WORD)a4 != v19[78] && !sub_1001BC80(a1, v10, a3, *(_WORD *)(a3 + 8 * v9 + 4), a5, a6, a7) )
                      goto LABEL_49;
                    v8 = 0;
                    a4 = *(_WORD *)(a3 + 8 * v9 + 2);
                    if ( *(_WORD *)(a3 + 8 * v9 + 2) != -1 )
                    {
                      v7 = *(_WORD *)(a3 + 8 * v9 + 2);
                      continue;
                    }
                    goto LABEL_47;
                  }
                  sprintf(a7, "%s, used in alert %i node %i", a7, (unsigned __int16)a2, (unsigned __int16)a4);
LABEL_31:
                  result = 0;
                }
                break;
              case 8:
              case 0xB:
              case 0xC:
              case 0xF:
              case 0x11:
                sprintf(
                  a7,
                  "Invalid use of ACK, cascade, inhibit, or log: alert %i node %i",
                  (unsigned __int16)a2,
                  (unsigned __int16)a4);
                return 0;
              default:
                sprintf(
                  a7,
                  "Invalid operation %i for alert %i node %i",
                  *(_BYTE *)(a3 + 8 * (unsigned __int16)a4 + 6),
                  (unsigned __int16)a2,
                  (unsigned __int16)a4);
                return 0;
            }
          }
        }
      }
      break;
    }
  }
  return result;
}

//----- (1001C0C0) --------------------------------------------------------
char __usercall sub_1001C0C0@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int8 a3, int a4, int a5, int a6)
{
  char *v6; // esi@1
  int v7; // eax@1
  bool v8; // zf@1
  int v9; // edi@1
  char result; // al@3
  unsigned __int8 v11; // al@6
  unsigned __int8 v12; // al@8
  unsigned __int8 v13; // al@10
  unsigned __int16 v14; // ax@24
  unsigned int v15; // eax@27
  unsigned int v16; // ecx@29
  unsigned int v17; // eax@34
  unsigned __int8 v18; // al@40
  unsigned __int8 v19; // al@42
  unsigned __int16 v20; // ax@46
  signed __int16 v21; // dx@46
  signed __int16 v22; // cx@46
  int v23; // ebp@52
  __int16 v24; // ax@57
  unsigned __int16 v25; // ax@60
  int v26; // eax@62
  unsigned __int16 v27; // ax@70
  signed __int16 v28; // [sp+10h] [bp-10h]@46
  int v29; // [sp+14h] [bp-Ch]@48
  int v30; // [sp+18h] [bp-8h]@1
  unsigned int v31; // [sp+1Ch] [bp-4h]@24

  v6 = a1;
  v7 = 160 * (unsigned __int16)a5;
  v8 = *(_WORD *)(v7 + a4 + 156) == -1;
  v9 = v7 + a4;
  v30 = v7 + a4;
  if ( v8 )
  {
    if ( a3 != 2 )
      return 1;
  }
  else if ( a3 != 2 )
  {
    goto LABEL_6;
  }
  if ( *(_WORD *)v9 == -2 )
    return 1;
LABEL_6:
  v11 = *(_BYTE *)(v9 + 126);
  if ( v11 >= 5u )
  {
    sprintf(v6, "Invalid level %i for alert %i", v11, (unsigned __int16)a5);
    return 0;
  }
  v12 = *(_BYTE *)(v9 + 136);
  if ( v12 >= 0x5Cu && v12 != -1 || (v13 = *(_BYTE *)(v9 + 137), v13 >= 0x5Cu) && v13 != -1 )
  {
    sprintf(v6, "Invalid audio message for alert %i", (unsigned __int16)a5);
    return 0;
  }
  if ( a3 && *(_BYTE *)(v9 + 127) & 0x20 && sub_1001B4F0(v13) )
  {
    sprintf(
      v6,
      "Invalid Continuous Clear Audio for alert %i ( aud msg = %i )",
      (unsigned __int16)a5 + (unsigned __int16)word_1007D760[6 * a3],
      *(_BYTE *)(v9 + 137));
    return 0;
  }
  if ( *(_BYTE *)(v9 + 135) & 4 && (*(_BYTE *)(v9 + 126) != 3 || !(*(_BYTE *)(v9 + 127) & 5)) )
  {
    sprintf(
      v6,
      "Invalid Alert Clear Flags.  Hide-on-View is only valid for Viewable Messages.  Alert: %i",
      (unsigned __int16)a5);
    return 0;
  }
  if ( !sub_1001B2E0(v9) && *(_WORD *)v9 > (unsigned __int16)word_1007D762[6 * a3] )
  {
    sprintf(v6, "Invalid alert id. Id out of bounds. Alert: %i ID: %i", (unsigned __int16)a5, *(_WORD *)v9);
    return 0;
  }
  v14 = *(_WORD *)v9;
  v31 = 12 * a3;
  if ( v14 != (unsigned __int16)a5 + (unsigned __int16)word_1007D760[v31 / 2] && v14 != -1 )
  {
    sprintf(v6, "Invalid alert id. Id mismatch. Alert: %i ID: %i", (unsigned __int16)a5, v14);
    return 0;
  }
  v15 = *(_DWORD *)(v9 + 140);
  if ( v15 && v15 < 0xC8 || (v16 = *(_DWORD *)(v9 + 144)) != 0 && v16 < 0xC8 )
  {
    sprintf(v6, "Invalid debounce time. Must be greater than or equal to %i. Alert: %i", 200, (unsigned __int16)a5);
    return 0;
  }
  if ( v15 % 0xC8 || *(_DWORD *)(v9 + 144) % 0xC8u )
  {
    sprintf(v6, "Invalid debounce time. Not multiple of %i. Alert: %i", 200, (unsigned __int16)a5);
    return 0;
  }
  v17 = *(_DWORD *)(v9 + 128);
  if ( v17 && v17 < 0xC8 )
  {
    sprintf(v6, "Invalid update period time. Must be greater than or equal to %i. Alert: %i", 200, (unsigned __int16)a5);
    return 0;
  }
  if ( v17 % 0xC8 )
  {
    sprintf(v6, "Invalid update period time. Not multiple of %i. Alert: %i", 200, (unsigned __int16)a5);
    return 0;
  }
  if ( !a3 )
  {
    v18 = *(_BYTE *)(v9 + 127);
    if ( v18 & 0x37 )
    {
      sub_1001D840(v6, 0x64u, "Invalid CMC alert Notification. Alert: %i, Notification: %i", (unsigned __int16)a5, v18);
      return 0;
    }
    v19 = *(_BYTE *)(v9 + 134);
    if ( v19 )
    {
      sub_1001D840(
        v6,
        0x64u,
        "Acknowledgements restricted for CMC alerts. Alert: %i, Acknowledgement: %i",
        (unsigned __int16)a5,
        v19);
      return 0;
    }
    goto LABEL_46;
  }
  if ( a3 == 2 && !sub_1001B900(a5, a4, v6) )
    return 0;
LABEL_46:
  v20 = *(_WORD *)(v9 + 156);
  v21 = -1;
  v22 = -1;
  v28 = -1;
  if ( v20 != -1 )
  {
    v22 = *(_WORD *)(a2 + 8 * v20 + 4);
    v28 = *(_WORD *)(a2 + 8 * v20 + 4);
  }
  v29 = 0;
  if ( v22 == -1 )
    return sub_1001BC80(a4, a5, a2, *(_WORD *)(v9 + 156), (int)&v29, a6, v6);
  while ( 2 )
  {
    if ( (unsigned __int16)++v29 > 0x64u )
    {
      sprintf(v6, "Maximum number of nodes exceeded for alert %i", (unsigned __int16)a5);
      return 0;
    }
    v23 = (unsigned __int16)v22;
    if ( byte_101DE860[(unsigned __int16)v22] )
    {
      sprintf(v6, "Reuse of nodes is not allowed: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
      return 0;
    }
    byte_101DE860[(unsigned __int16)v22] = 1;
    switch ( *(_BYTE *)(a2 + 8 * (unsigned __int16)v22 + 6) )
    {
      case 0xC:
        if ( *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2) == v21 )
        {
          if ( *(_WORD *)(a2 + 8 * (unsigned __int16)v22) < 0x96Fu )
            goto LABEL_73;
          sprintf(v6, "Invalid alert id: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
          result = 0;
        }
        else
        {
          sprintf(v6, "Cascade node with children: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
          result = 0;
        }
        return result;
      case 8:
      case 0xB:
      case 0xF:
        v24 = *(_WORD *)(a2 + 8 * (unsigned __int16)v22);
        if ( v24 == v21 )
          goto LABEL_60;
        if ( *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2) != v21 )
          goto LABEL_78;
        if ( v24 == v21 )
        {
LABEL_60:
          v25 = *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2);
          if ( v25 == v21 || *(_WORD *)(a2 + 8 * v25 + 4) != v21 )
          {
LABEL_78:
            sprintf(
              v6,
              "Incorrect input for ACK/inhibit: alert %i node %i",
              (unsigned __int16)a5,
              (unsigned __int16)v22);
            return 0;
          }
        }
        v26 = *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2);
        if ( (_WORD)v26 != v21 )
        {
          if ( !sub_1001BC80(a4, a5, a2, v26, (int)&v29, a6, v6) )
            return 0;
          v21 = -1;
        }
        if ( *(_WORD *)(a2 + 8 * v23) == v21 )
          goto LABEL_73;
        if ( sub_1001B970(a6 + (*(_WORD *)(a2 + 8 * v23) << 6), *(_WORD *)(a2 + 8 * v23), v6) )
        {
          v9 = v30;
          goto LABEL_72;
        }
        sprintf(v6, "%s, used in alert %i node %i", v6, (unsigned __int16)a5, (unsigned __int16)v28);
        result = 0;
        break;
      case 0x11:
        if ( *(_WORD *)(a2 + 8 * (unsigned __int16)v22 + 2) == v21 )
        {
          if ( *(_WORD *)(v9 + 132) )
          {
            v27 = *(_WORD *)(a2 + 8 * (unsigned __int16)v22);
            if ( v27 != v21 && v27 <= (unsigned __int16)word_1007D766[v31 / 2] )
            {
LABEL_72:
              v21 = -1;
LABEL_73:
              v28 = *(_WORD *)(a2 + 8 * v23 + 4);
              if ( *(_WORD *)(a2 + 8 * v23 + 4) != v21 )
              {
                v22 = *(_WORD *)(a2 + 8 * v23 + 4);
                continue;
              }
              return sub_1001BC80(a4, a5, a2, *(_WORD *)(v9 + 156), (int)&v29, a6, v6);
            }
            sprintf(
              v6,
              "Trigger ID %i is out of range for LOG node %i.",
              *(_WORD *)(a2 + 8 * (unsigned __int16)v22),
              (unsigned __int16)v22);
            result = 0;
          }
          else
          {
            sprintf(
              v6,
              "Log folder not selected for alert %i using LOG node %i.",
              (unsigned __int16)a5,
              (unsigned __int16)v22);
            result = 0;
          }
        }
        else
        {
          sprintf(v6, "Log node with children: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
          result = 0;
        }
        break;
      default:
        sprintf(v6, "Invalid root node sibling: alert %i node %i", (unsigned __int16)a5, (unsigned __int16)v22);
        result = 0;
        break;
    }
    return result;
  }
}
// 1007D760: using guessed type __int16 word_1007D760[];
// 1007D762: using guessed type __int16 word_1007D762[];
// 1007D766: using guessed type __int16 word_1007D766[];

//----- (1001C6C0) --------------------------------------------------------
bool __cdecl sub_1001C6C0(int a1, int a2, int a3, int a4, char *a5, char a6)
{
  char v6; // bl@1
  unsigned __int8 v7; // cl@1
  int v8; // edx@4
  unsigned int v9; // eax@4
  signed int v10; // ebp@4
  int v11; // edi@6
  int v12; // eax@7
  int v13; // esi@9
  char *v14; // ebp@9
  char v15; // al@9
  int v16; // ecx@9
  double v17; // st7@13
  bool result; // al@16
  int v19; // esi@20
  int v20; // ecx@24
  double v21; // st7@24
  char v22; // [sp+26h] [bp-12h]@1
  char v23; // [sp+27h] [bp-11h]@1
  float v24; // [sp+28h] [bp-10h]@1
  float v25; // [sp+2Ch] [bp-Ch]@4
  signed int v26; // [sp+30h] [bp-8h]@4

  v24 = 0.0;
  v22 = 0;
  v6 = 1;
  v23 = 0;
  memset(byte_101DE860, 0, 0x2710u);
  v7 = a1;
  if ( (_BYTE)a1 && (_BYTE)a1 != 1 && (_BYTE)a1 != 2 )
  {
    sprintf(a5, "Invalid alert class %i.", (unsigned __int8)a1);
    result = 0;
  }
  else
  {
    v8 = (unsigned __int8)a1;
    v9 = 12 * (unsigned __int8)a1;
    v10 = (unsigned __int16)word_1007D764[v9 / 2];
    v25 = flt_1007D768[v9 / 4];
    v26 = (unsigned __int16)word_1007D764[v9 / 2];
    if ( (_BYTE)a1 != 1 && (_BYTE)a1 )
    {
      v11 = 0;
      if ( v10 > 0 )
      {
        v12 = 0;
        while ( 1 )
        {
          v13 = 160 * v12;
          v14 = (char *)(160 * v12 + a3);
          v15 = sub_1001C0C0(a5, a4, v7, a3, v11, a2);
          LOBYTE(v16) = v15 == 0;
          v22 |= v15 == 0;
          if ( a6 && (!v15 || *(_WORD *)v14 == -2) )
          {
            sub_1001B590(v11);
            v23 = 1;
            v14 = (char *)&unk_101F8678 + v13;
          }
          v17 = sub_1001B530(v16, (int)v14);
          v12 = (unsigned __int16)++v11;
          v24 = v17 + v24;
          if ( (unsigned __int16)v11 >= v26 )
            break;
          v7 = a1;
        }
      }
      if ( v25 < (double)v24
        && (sprintf(a5, "Num alerts/sec %f exceeds max alerts/sec %f for SYS alerts.  Re-defaulting.", v24, v25),
            v22 = 1,
            a6) )
      {
        sub_1001BC00();
        sub_1001BAB0();
        result = 0;
      }
      else
      {
        if ( v23 )
          sub_1001BAB0();
        result = v22 == 0;
      }
    }
    else
    {
      v19 = 0;
      if ( v10 <= 0 )
      {
LABEL_27:
        if ( v25 < (double)v24 )
        {
          sprintf(a5, "Num alerts/sec %f exceeds max alerts/sec %f for alert class %i.", v24, v25, v8);
          return 0;
        }
      }
      else
      {
        while ( v6 )
        {
          v6 = sub_1001C0C0(a5, a4, v7, a3, v19, a2);
          v21 = sub_1001B530(v20, a3 + 160 * (unsigned int)(unsigned __int16)v19++);
          v24 = v21 + v24;
          if ( (unsigned __int16)v19 >= v10 )
          {
            if ( !v6 )
              break;
            v8 = (unsigned __int8)a1;
            goto LABEL_27;
          }
          v7 = a1;
        }
      }
      result = v6;
    }
  }
  return result;
}
// 1007D764: using guessed type __int16 word_1007D764[];
// 1007D768: using guessed type float flt_1007D768[];

//----- (1001C900) --------------------------------------------------------
bool __cdecl sub_1001C900(int a1, char *a2)
{
  int v2; // ebp@1
  int v3; // ebx@2
  void *v4; // eax@3
  signed int v5; // edx@3
  const void *v6; // esi@4
  char *v7; // edi@4
  int v8; // ebp@6
  void *v9; // edx@7
  signed int v10; // ebx@7
  const void *v11; // esi@8
  char *v12; // edi@8
  int v13; // esi@10
  int v14; // edi@10
  signed int v15; // ebx@10
  void *v16; // eax@11
  signed int v17; // edx@11
  int v18; // ecx@12
  int v19; // ebp@12
  int v20; // ebx@16
  void *v21; // eax@17
  signed int v22; // edx@17
  const void *v23; // esi@18
  char *v24; // edi@18
  int v25; // ebp@20
  void *v26; // edx@21
  signed int v27; // ebx@21
  const void *v28; // esi@22
  char *v29; // edi@22
  int v30; // esi@24
  int v31; // edi@24
  signed int v32; // ebx@24
  void *v33; // eax@25
  signed int v34; // edx@25
  int v35; // ecx@26
  int v36; // ebp@26
  unsigned int v37; // eax@29
  int v38; // ebx@31
  void *v39; // eax@32
  signed int v40; // edx@32
  const void *v41; // esi@33
  char *v42; // edi@33
  int v43; // esi@35
  int v44; // ebp@35
  void *v45; // edx@37
  signed int v46; // ebx@37
  const void *v47; // esi@38
  char *v48; // edi@38
  int v49; // esi@40
  int v50; // edi@40
  signed int v51; // ebx@40
  void *v52; // eax@41
  signed int v53; // edx@41
  int v54; // ecx@42
  int v55; // ebp@42
  int v57; // [sp+10h] [bp-10h]@6
  int v58; // [sp+10h] [bp-10h]@20
  unsigned __int8 v59; // [sp+10h] [bp-10h]@29
  signed int v60; // [sp+14h] [bp-Ch]@2
  signed int v61; // [sp+14h] [bp-Ch]@6
  signed int v62; // [sp+14h] [bp-Ch]@16
  signed int v63; // [sp+14h] [bp-Ch]@20
  signed int v64; // [sp+14h] [bp-Ch]@31
  signed int v65; // [sp+14h] [bp-Ch]@35
  int v66; // [sp+18h] [bp-8h]@1
  int v67; // [sp+1Ch] [bp-4h]@35

  v2 = 0;
  v66 = 0;
  memset(byte_101C7160, 0, 0x17700u);
  memset(&unk_101F8678, 0, 0x27100u);
  memset(dword_101E0F70, 0, 0x13880u);
  memset(&unk_101F47F0, 0, 0x3E84u);
  memset(&unk_1021F7D8, 0, 0x1F40u);
  memset(&unk_102255A0, 0, 0x1900u);
  if ( (_BYTE)a1 == 1 )
  {
    v3 = 13000;
    v60 = 15;
    do
    {
      sub_1003E040(v3, (int)&unk_102255A0, 6400);
      v4 = &unk_102255A0;
      v5 = 100;
      do
      {
        v6 = v4;
        v7 = &byte_101C7160[64 * (unsigned __int16)v2++];
        v4 = (char *)v4 + 64;
        --v5;
        qmemcpy(v7, v6, 0x40u);
      }
      while ( v5 );
      ++v3;
      --v60;
    }
    while ( v60 );
    v8 = 0;
    v57 = 12000;
    v61 = 10;
    do
    {
      sub_1003E040(v57, (int)&unk_101F47F0, 16004);
      v9 = &unk_101F47F0;
      v10 = 100;
      do
      {
        v11 = v9;
        v12 = (char *)&unk_101F8678 + 160 * (unsigned __int16)v8++;
        v9 = (char *)v9 + 160;
        --v10;
        qmemcpy(v12, v11, 0xA0u);
      }
      while ( v10 );
      ++v57;
      --v61;
    }
    while ( v61 );
    v13 = 0;
    v14 = 21000;
    v15 = 10;
    do
    {
      sub_1003E040(v14, (int)&unk_1021F7D8, 8000);
      v16 = &unk_1021F7D8;
      v17 = 1000;
      do
      {
        v18 = (unsigned __int16)v13;
        dword_101E0F70[2 * v18] = *(_DWORD *)v16;
        v19 = *((_DWORD *)v16 + 1);
        ++v13;
        v16 = (char *)v16 + 8;
        --v17;
        dword_101E0F74[2 * v18] = v19;
      }
      while ( v17 );
      ++v14;
      --v15;
    }
    while ( v15 );
  }
  else if ( (_BYTE)a1 )
  {
    v59 = 1;
    sub_1003E040(6948, (int)&v66, 4);
    v37 = sub_10041EF0((unsigned int *)"\aAHRS1 TAS", 64740, 0xFFFFFFFF);
    if ( v66 != v37 )
      v59 = 0;
    v38 = 25000;
    v64 = 6;
    do
    {
      sub_1003E210(v38, v59);
      sub_1003E040(v38, (int)&unk_102255A0, 6400);
      v39 = &unk_102255A0;
      v40 = 100;
      do
      {
        v41 = v39;
        v42 = &byte_101C7160[64 * (unsigned __int16)v2++];
        v39 = (char *)v39 + 64;
        --v40;
        qmemcpy(v42, v41, 0x40u);
      }
      while ( v40 );
      ++v38;
      --v64;
    }
    while ( v64 );
    v43 = 23000;
    v44 = 0;
    v65 = 23000;
    v67 = 5;
    while ( 1 )
    {
      sub_1003E210(v43, v59);
      sub_1003E040(v43, (int)&unk_101F47F0, 16004);
      v45 = &unk_101F47F0;
      v46 = 100;
      do
      {
        v47 = v45;
        v48 = (char *)&unk_101F8678 + 160 * (unsigned __int16)v44++;
        v45 = (char *)v45 + 160;
        --v46;
        qmemcpy(v48, v47, 0xA0u);
      }
      while ( v46 );
      ++v65;
      if ( !--v67 )
        break;
      v43 = v65;
    }
    v49 = 0;
    v50 = 24000;
    v51 = 2;
    do
    {
      sub_1003E210(v50, v59);
      sub_1003E040(v50, (int)&unk_1021F7D8, 8000);
      v52 = &unk_1021F7D8;
      v53 = 1000;
      do
      {
        v54 = (unsigned __int16)v49;
        dword_101E0F70[2 * v54] = *(_DWORD *)v52;
        v55 = *((_DWORD *)v52 + 1);
        ++v49;
        v52 = (char *)v52 + 8;
        --v53;
        dword_101E0F74[2 * v54] = v55;
      }
      while ( v53 );
      ++v50;
      --v51;
    }
    while ( v51 );
  }
  else
  {
    v20 = 15000;
    v62 = 15;
    do
    {
      sub_1003E040(v20, (int)&unk_102255A0, 6400);
      v21 = &unk_102255A0;
      v22 = 100;
      do
      {
        v23 = v21;
        v24 = &byte_101C7160[64 * (unsigned __int16)v2++];
        v21 = (char *)v21 + 64;
        --v22;
        qmemcpy(v24, v23, 0x40u);
      }
      while ( v22 );
      ++v20;
      --v62;
    }
    while ( v62 );
    v25 = 0;
    v58 = 14000;
    v63 = 10;
    do
    {
      sub_1003E040(v58, (int)&unk_101F47F0, 16004);
      v26 = &unk_101F47F0;
      v27 = 100;
      do
      {
        v28 = v26;
        v29 = (char *)&unk_101F8678 + 160 * (unsigned __int16)v25++;
        v26 = (char *)v26 + 160;
        --v27;
        qmemcpy(v29, v28, 0xA0u);
      }
      while ( v27 );
      ++v58;
      --v63;
    }
    while ( v63 );
    v30 = 0;
    v31 = 22000;
    v32 = 10;
    do
    {
      sub_1003E040(v31, (int)&unk_1021F7D8, 8000);
      v33 = &unk_1021F7D8;
      v34 = 1000;
      do
      {
        v35 = (unsigned __int16)v30;
        dword_101E0F70[2 * v35] = *(_DWORD *)v33;
        v36 = *((_DWORD *)v33 + 1);
        ++v30;
        v33 = (char *)v33 + 8;
        --v34;
        dword_101E0F74[2 * v35] = v36;
      }
      while ( v34 );
      ++v31;
      --v32;
    }
    while ( v32 );
  }
  return sub_1001C6C0(a1, (int)byte_101C7160, (int)&unk_101F8678, (int)dword_101E0F70, a2, 1);
}
// 101E0F70: using guessed type int dword_101E0F70[];
// 101E0F74: using guessed type int dword_101E0F74[];

//----- (1001CD60) --------------------------------------------------------
int __cdecl sub_1001CD60(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (1001CEF0) --------------------------------------------------------
int __cdecl sub_1001CEF0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int result; // eax@1
  int v7; // ebx@1
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  unsigned int v21; // edx@23
  char *i; // ecx@23
  int v23; // [sp+20h] [bp+14h]@1

  v5 = a5;
  result = a5 - 1;
  v7 = a3 + a4 * (a5 - 1);
  v23 = a5 - 1;
  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && v5 > 0 )
  {
    if ( result > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v23;
        if ( v20 )
        {
          v7 -= a4;
          result = v23 - 1;
          v23 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a2;
    for ( i = (char *)v7; v21 >= 4; i += 4 )
    {
      if ( *(_DWORD *)&i[(_DWORD)a1 - v7] != *(_DWORD *)i )
        break;
      v21 -= 4;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001D010) --------------------------------------------------------
char __cdecl sub_1001D010(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1001D050) --------------------------------------------------------
char __cdecl sub_1001D050(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_100129A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1001D0C0) --------------------------------------------------------
signed int __cdecl sub_1001D0C0(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_100129A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1001D140) --------------------------------------------------------
char __cdecl sub_1001D140(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_100129A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1001D1B0) --------------------------------------------------------
char __cdecl sub_1001D1B0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_100129A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1001D260) --------------------------------------------------------
char __cdecl sub_1001D260(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 4:
      result = 0;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      if ( !(_BYTE)a1 )
        sub_100129A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 859, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1001D370) --------------------------------------------------------
char __cdecl sub_1001D370(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_100129A0("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1001D470) --------------------------------------------------------
char __thiscall sub_1001D470(void *this)
{
  void *v1; // eax@1

  v1 = sub_1001D4B0(this);
  return sub_1001D370((int)v1);
}

//----- (1001D480) --------------------------------------------------------
char __thiscall sub_1001D480(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_10015FF0(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 10042076: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (1001D4B0) --------------------------------------------------------
void *__thiscall sub_1001D4B0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_10015FF0(46, (char *)&v2);
  return v2;
}

//----- (1001D4D0) --------------------------------------------------------
bool __cdecl sub_1001D4D0(char a1)
{
  void *v1; // ecx@0
  bool result; // al@2
  void *v3; // ecx@4

  switch ( a1 )
  {
    case 5:
      result = sub_1002E980(0) == 1;
      break;
    case 6:
      goto LABEL_3;
    case 9:
      if ( (unsigned int)sub_1001D4B0(v1) & 3 || sub_100160F0(v3) == 1 )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 8:
      result = sub_100160F0(v1) != 1;
      break;
    default:
      result = sub_100160F0(v1) == 1;
      break;
  }
  return result;
}

//----- (1001D540) --------------------------------------------------------
bool __cdecl sub_1001D540(float a1, int a2, int a3, int a4)
{
  int v4; // edi@2
  int v5; // esi@3
  int v6; // ecx@8
  unsigned int v7; // eax@9
  float v8; // ST14_4@10
  float v9; // ST14_4@10
  float v10; // ST14_4@10
  float v11; // ST14_4@10
  float v12; // ST14_4@10
  float v13; // ST14_4@10
  float v14; // ST14_4@10
  int v15; // eax@12
  float v16; // ST14_4@14
  signed int v17; // ebx@14
  bool result; // al@19
  int v19; // [sp+8h] [bp-8h]@5

  if ( a4 && (v4 = a3, a3 <= 9) && (v5 = a2, a2 > 0) && a3 <= a2 - 2 )
  {
    v19 = 0;
    if ( a1 < 0.0 )
    {
      v4 = a3 - 1;
      a1 = fabs(a1);
      *(_BYTE *)a4 = 45;
      v19 = 1;
      if ( a3 == 1 )
        v4 = -1;
    }
    v6 = 0;
    if ( v4 >= 8 )
    {
      v7 = ((unsigned int)(v4 - 8) >> 3) + 1;
      v6 = 8 * v7;
      do
      {
        --v7;
        v8 = a1 * 10.0;
        v9 = v8 * 10.0;
        v10 = v9 * 10.0;
        v11 = v10 * 10.0;
        v12 = v11 * 10.0;
        v13 = v12 * 10.0;
        v14 = v13 * 10.0;
        a1 = v14 * 10.0;
      }
      while ( v7 );
    }
    if ( v6 < v4 )
    {
      v15 = v4 - v6;
      do
      {
        --v15;
        a1 = a1 * 10.0;
      }
      while ( v15 );
    }
    v16 = a1 + 0.5;
    v17 = (signed int)v16;
    if ( a2 > v19 )
    {
      do
      {
        if ( --v5 == a2 - v4 - 1 )
        {
          *(_BYTE *)(v5 + a4) = 46;
        }
        else
        {
          *(_BYTE *)(v5 + a4) = v17 % 10 + 48;
          v17 /= 10;
        }
      }
      while ( v5 > v19 );
    }
    result = v17 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001D6B0) --------------------------------------------------------
bool __cdecl sub_1001D6B0(signed int a1, signed int a2, _BYTE *a3)
{
  bool result; // al@2
  signed int v4; // ebx@3
  signed int v5; // edi@3
  signed int i; // esi@5

  if ( a3 )
  {
    v4 = a1;
    v5 = 0;
    if ( a1 < 0 )
    {
      v4 = -a1;
      *a3 = 45;
      v5 = 1;
    }
    for ( i = a2; i > v5; v4 /= 10 )
      a3[--i] = v4 % 10 + 48;
    result = v4 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001D720) --------------------------------------------------------
int __cdecl sub_1001D720(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (1001D770) --------------------------------------------------------
int __cdecl sub_1001D770(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (1001D7A0) --------------------------------------------------------
int __cdecl sub_1001D7A0(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (1001D800) --------------------------------------------------------
int __cdecl sub_1001D800(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1001D840) --------------------------------------------------------
int sub_1001D840(char *arg0, size_t arg4, char *arg8, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, arg8);
  result = sub_1001D800(arg0, arg4, arg8, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (1001D870) --------------------------------------------------------
int __cdecl sub_1001D870(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_1001D720((int)&a1[v3], a2, a3 - v3);
}

//----- (1001D8B0) --------------------------------------------------------
int __cdecl sub_1001D8B0(int a1, int a2)
{
  return sub_1001D7A0(a1, "_ ", a2);
}

//----- (1001D8D0) --------------------------------------------------------
void *__usercall sub_1001D8D0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4)
{
  void *result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0
  int v6; // [sp+4h] [bp-8h]@0

  result = (void *)sub_1003E040(a4, v5, v6);
  if ( result )
  {
    sub_1003E110(a4, (int)a2, a3);
    result = memcpy(a1, a2, (unsigned __int16)a3);
  }
  return result;
}

//----- (1001D900) --------------------------------------------------------
void *__cdecl sub_1001D900(void *a1)
{
  return sub_1001D8D0(a1, &unk_100927DC, 60, 2116);
}

//----- (1001D930) --------------------------------------------------------
char __cdecl sub_1001D930(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32723;
  qmemcpy(&v3, a1, 0x1C8u);
  return sub_1002EB00((int)&v2);
}

//----- (1001D9A0) --------------------------------------------------------
void sub_1001D9A0()
{
  dword_102AD578 = -15;
}
// 102AD578: using guessed type int dword_102AD578;

//----- (1001D9B0) --------------------------------------------------------
BOOL __fastcall sub_1001D9B0(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_100327E0(6, 1, 27, 0, (int)&v2, 4) && v2 & 1;
}

//----- (1001D9E0) --------------------------------------------------------
signed int sub_1001D9E0()
{
  return sub_1003ED70((int)&off_100928A0);
}
// 100928A0: using guessed type char *off_100928A0;

//----- (1001D9F0) --------------------------------------------------------
char __cdecl sub_1001D9F0(char *a1)
{
  char result; // al@4
  char v2; // [sp+8h] [bp-44h]@1

  memset(&v2, 0, 0x40u);
  if ( (unsigned int)a1 >= 0xFFFFFFC2 || !a1 || sub_1003E040(6786, (int)&v2, 64) )
  {
    result = 0;
  }
  else
  {
    qmemcpy(a1, &v2, 0x40u);
    result = 1;
  }
  return result;
}

//----- (1001DA70) --------------------------------------------------------
char __cdecl sub_1001DA70(__int16 a1)
{
  __int16 v2; // [sp+0h] [bp-52Ch]@1
  __int16 v3; // [sp+4h] [bp-528h]@1

  v2 = -32701;
  v3 = a1;
  return sub_1002EB10((int)&v2);
}

//----- (1001DAC0) --------------------------------------------------------
char __cdecl sub_1001DAC0(unsigned __int8 a1, int a2)
{
  char result; // al@2
  __int16 v3; // [sp+0h] [bp-52Ch]@2
  int v4; // [sp+4h] [bp-528h]@1
  int v5; // [sp+8h] [bp-524h]@1
  int v6; // [sp+Ch] [bp-520h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  if ( a1 >= 0x10u )
  {
    result = sub_100129A0("..\\lib\\adl\\iop_cmc_intf.c", 456, 0, "Invalid CMC folder index referenced");
  }
  else
  {
    BYTE1(v4) = a1;
    v3 = -32693;
    LOBYTE(v4) = 6;
    v5 = a2;
    result = sub_1002EB10((int)&v3);
  }
  return result;
}

//----- (1001DB60) --------------------------------------------------------
void sub_1001DB60()
{
  dword_102AD574 = -15;
}
// 102AD574: using guessed type int dword_102AD574;

//----- (1001DB70) --------------------------------------------------------
char __cdecl sub_1001DB70(unsigned __int8 a1, __int16 a2, char a3)
{
  char result; // al@2
  __int16 v4; // [sp+0h] [bp-52Ch]@2
  int v5; // [sp+4h] [bp-528h]@1
  int v6; // [sp+8h] [bp-524h]@1
  int v7; // [sp+Ch] [bp-520h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( a1 >= 0x10u )
  {
    result = sub_100129A0("..\\lib\\adl\\iop_cmc_intf.c", 533, 0, "Invalid CMC folder index referenced");
  }
  else
  {
    BYTE1(v5) = a1;
    v4 = -32693;
    LOBYTE(v5) = 0;
    HIWORD(v5) = a2;
    LOBYTE(v7) = a3;
    result = sub_1002EB10((int)&v4);
  }
  return result;
}

//----- (1001DC20) --------------------------------------------------------
signed int sub_1001DC20()
{
  return sub_1003ED70((int)&off_10093818);
}
// 10093818: using guessed type char *off_10093818;

//----- (1001DC30) --------------------------------------------------------
int __cdecl sub_1001DC30(int *a1)
{
  int result; // eax@1

  result = sub_10034840((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_1003DC90();
    result = sub_10034680();
  }
  return result;
}

//----- (1001DC60) --------------------------------------------------------
char __usercall sub_1001DC60@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_1003DDA0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1001E420("%i %i\r\n", 13, v2);
    sub_10034EA0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    sub_1003DD40(*(_DWORD *)(a1 + 4));
    v6 = sub_1001E420("%i %i\r\n", 14, v5);
    sub_10034EA0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_10093C2C, (int)v6);
    result = 1;
  }
  else
  {
    sub_100129A0(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}
// 1003DD40: using guessed type double __cdecl sub_1003DD40(_DWORD);

//----- (1001DD10) --------------------------------------------------------
int __cdecl sub_1001DD10(const char *a1)
{
  int result; // eax@1

  result = sub_100329A0();
  if ( a1 )
    result = sub_10034870(dword_10227544[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 10227544: using guessed type int dword_10227544[];

//----- (1001DD50) --------------------------------------------------------
char __cdecl sub_1001DD50(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_100347C0((char *)a1 + 4);
  v1 = sub_1000D7F0();
  sub_10034760((int)v1, 0, 0);
  dword_10227544[sub_100329A0()] = (int)a1;
  v2 = sub_100364D0((int)sub_1001DD10);
  return sub_10034890(v2);
}
// 10227544: using guessed type int dword_10227544[];

//----- (1001DDA0) --------------------------------------------------------
signed int __cdecl sub_1001DDA0(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_1003DC90();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_1003DE80(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_1003DC90() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_1003DF10(&v23);
          }
          while ( sub_1003DC90() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_1003DC40(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_1003DCB0((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1001E420("The %s task is loaded.", &v24);
            sub_10034EA0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1001E420("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10034EA0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1001E420("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10034EA0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1001E420(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10034EA0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_1003DBD0(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1001E420("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10034EA0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1001E420("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10034EA0(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10034EA0(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_1003DCF0(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_100364D0((int)sub_1001DD10);
        sub_10034F70((int)v15);
        v16 = sub_100378A0((int)sub_1001DD10);
        sub_10034F70((int)v16);
        v17 = sub_100378A0((int)sub_1001DD10);
        sub_10034890(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_100364D0((int)sub_1001DD10);
        sub_10034F70((int)v18);
        v19 = sub_100378A0((int)sub_1001DD10);
        sub_10034F70((int)v19);
        v20 = sub_100364D0((int)sub_1001DD10);
        sub_10034890(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_1001DC60(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (1001E140) --------------------------------------------------------
char **sub_1001E140()
{
  return off_10093C18;
}
// 10093C18: using guessed type char *off_10093C18[3];

//----- (1001E150) --------------------------------------------------------
#error "1001E155: call analysis failed (funcsize=28)"

//----- (1001E180) --------------------------------------------------------
char *__cdecl sub_1001E180(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  const char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_10038830("CFG_ActDir", (int)&unk_10064984);
      v10 = sub_10038830("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_10038830("CFG_ExpDir", (int)&unk_10064984);
      v10 = sub_10038830("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_10038830("CFG_ActDir", (int)&unk_10064984);
      break;
    case 4:
      v10 = sub_10038830("CFG_ExpDir", (int)&unk_10064984);
      break;
    default:
      v10 = (char *)&unk_10064984;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = "/", v14) )
    v15 = (const char *)&unk_10064984;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1001E180: using guessed type char var_104[256];

//----- (1001E300) --------------------------------------------------------
int sub_1001E300()
{
  return dword_1022C148[sub_100329A0()];
}
// 1022C148: using guessed type int dword_1022C148[];

//----- (1001E310) --------------------------------------------------------
const char *__cdecl sub_1001E310(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_10094454[a1];
  return result;
}
// 10094454: using guessed type char *off_10094454[7];

//----- (1001E330) --------------------------------------------------------
int __cdecl sub_1001E330(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10034EE0(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1001E3E0) --------------------------------------------------------
int __cdecl sub_1001E3E0(int a1)
{
  int result; // eax@1

  result = sub_100329A0();
  dword_1022E254[result] = a1;
  return result;
}
// 1022E254: using guessed type int dword_1022E254[];

//----- (1001E400) --------------------------------------------------------
int __cdecl sub_1001E400(int a1)
{
  int result; // eax@1

  result = sub_100329A0();
  dword_1022C148[result] = a1;
  return result;
}
// 1022C148: using guessed type int dword_1022C148[];

//----- (1001E420) --------------------------------------------------------
char *sub_1001E420(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_100329A0() << 8;
  _vsnprintf(&byte_10227558[v1], 0x100u, a1, va);
  result = &byte_10227558[v1];
  byte_10227656[v1] = 42;
  byte_10227657[v1] = 0;
  return result;
}

//----- (1001E460) --------------------------------------------------------
char *__usercall sub_1001E460@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_10094468[a1 & 1];
  else
    result = off_10094460[a2];
  return result;
}
// 10094460: using guessed type char *off_10094460[4];
// 10094468: using guessed type char *off_10094468[2];

//----- (1001E480) --------------------------------------------------------
char __usercall sub_1001E480@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_100329A0();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1001E300() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_1022F848[v6];
      v12 = dword_1022F85C[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_1022C15C[v6];
      v12 = dword_1022E240[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 1022C15C: using guessed type int dword_1022C15C[];
// 1022E240: using guessed type int dword_1022E240[];
// 1022F848: using guessed type int dword_1022F848[];
// 1022F85C: using guessed type int dword_1022F85C[];

//----- (1001E660) --------------------------------------------------------
int sub_1001E660()
{
  nullsub_1("..\\lib\\utf\\utf_verify.c", "2370", "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
  return 0;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (1001E680) --------------------------------------------------------
int sub_1001E680()
{
  return nullsub_1(
           "..\\lib\\utf\\utf_verify.c",
           "2396",
           "UTF_NO_BITMAP_CMP was defined. Bitmap comparison not supported");
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);

//----- (1001E6A0) --------------------------------------------------------
int __cdecl sub_1001E6A0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100329A0();
  dword_1022E240[result] = a1;
  if ( a2 >= 0 )
  {
    dword_1022C15C[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1001E420(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10034EA0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_1022C15C[result] = 8;
  }
  return result;
}
// 1022C15C: using guessed type int dword_1022C15C[];
// 1022E240: using guessed type int dword_1022E240[];

//----- (1001E700) --------------------------------------------------------
int __cdecl sub_1001E700(int a1)
{
  return sub_1001E6A0(0, a1);
}

//----- (1001E710) --------------------------------------------------------
int __cdecl sub_1001E710(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_100329A0();
  dword_1022F85C[result] = a1;
  if ( a2 >= 0 )
  {
    dword_1022F848[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1001E420(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10034EA0(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_1022F848[result] = 8;
  }
  return result;
}
// 1022F848: using guessed type int dword_1022F848[];
// 1022F85C: using guessed type int dword_1022F85C[];

//----- (1001E770) --------------------------------------------------------
int __cdecl sub_1001E770(int a1)
{
  return sub_1001E710(0, a1);
}

//----- (1001E780) --------------------------------------------------------
bool __cdecl sub_1001E780(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_10033900() )
    v8 = v8 == 0;
  v9 = off_10094438[a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_10094428[v8 != 0];
  v19 = off_10094430[a1];
  v18 = v10;
  v21 = sub_1001E460(0, a6);
  v22 = sub_1001E460(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_10038B80();
  sub_10034DB0(7, (int)&v14, v11);
  sub_10038B90(v12);
  return v8;
}
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (1001E8C0) --------------------------------------------------------
bool __cdecl sub_1001E8C0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  char v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  bool v16; // [sp+1Bh] [bp-5Dh]@2
  char v17; // [sp+1Fh] [bp-59h]@25
  unsigned int v18; // [sp+20h] [bp-58h]@1
  char *v19; // [sp+3Ch] [bp-3Ch]@28
  int v20; // [sp+40h] [bp-38h]@28
  int v21; // [sp+44h] [bp-34h]@28
  int v22; // [sp+48h] [bp-30h]@28
  char *v23; // [sp+4Ch] [bp-2Ch]@28
  char *v24; // [sp+50h] [bp-28h]@28
  const char *v25; // [sp+54h] [bp-24h]@28
  const char *v26; // [sp+58h] [bp-20h]@28
  const char *v27; // [sp+5Ch] [bp-1Ch]@28
  char *v28; // [sp+60h] [bp-18h]@28
  int v29; // [sp+64h] [bp-14h]@29
  char v30; // [sp+68h] [bp-10h]@25

  v8 = sub_100329A0();
  v18 = 9;
  switch ( a2 )
  {
    case 0:
      v16 = a6 == a7;
      break;
    case 1:
      v16 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 4:
      v16 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v16 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_38;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v16 = 1;
      if ( a6 > (unsigned __int8)v10 )
LABEL_38:
        v16 = 0;
      v18 = 10;
      break;
    default:
LABEL_22:
      v16 = 0;
      break;
  }
  if ( sub_10033900() )
    v16 = v16 == 0;
  sub_1001E480((int)&v30, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_10228548[v11], 0x400u, &v30, a6);
  byte_10228946[v11] = 42;
  byte_10228947[v11] = 0;
  v17 = sub_1001E480((int)&v30, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v11], 0x400u, &v30, a7);
  byte_10228D46[v11] = 42;
  byte_10228D47[v11] = 0;
  if ( v18 <= 9 )
  {
    v12 = &byte_10228D48[v11];
    byte_10228D48[v11] = 0;
  }
  else
  {
    v17 = sub_1001E480((int)&v30, "%c", 3, 0xCu, 0.0);
    v12 = &byte_10228D48[v11];
    _snprintf(&byte_10228D48[v11], 0x400u, &v30, 0);
    byte_10229146[v11] = 42;
    byte_10229147[v11] = 0;
  }
  v19 = off_10094438[a2];
  v21 = a4;
  v22 = a5;
  v20 = a3;
  v25 = "char";
  v26 = &byte_10228548[v11];
  v27 = &byte_10228948[v11];
  v13 = off_10094430[a1];
  v23 = off_10094428[v16 != 0];
  v24 = v13;
  v28 = v12;
  if ( a8 )
  {
    v29 = a8;
    v18 = 11;
  }
  v14 = sub_10038B80();
  sub_10034DB0(7, (int)&v19, v18);
  if ( v17 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 && !strcmp(v26, v27) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v14);
  return v16;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (1001EC70) --------------------------------------------------------
bool __cdecl sub_1001EC70(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  bool v20; // [sp+27h] [bp-61h]@10
  char v21; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v22; // [sp+2Ch] [bp-5Ch]@8
  char *v23; // [sp+4Ch] [bp-3Ch]@37
  int v24; // [sp+50h] [bp-38h]@37
  int v25; // [sp+54h] [bp-34h]@37
  int v26; // [sp+58h] [bp-30h]@37
  char *v27; // [sp+5Ch] [bp-2Ch]@37
  char *v28; // [sp+60h] [bp-28h]@37
  const char *v29; // [sp+64h] [bp-24h]@37
  const char *v30; // [sp+68h] [bp-20h]@37
  const char *v31; // [sp+6Ch] [bp-1Ch]@37
  char *v32; // [sp+70h] [bp-18h]@37
  int v33; // [sp+74h] [bp-14h]@38
  char v34; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_100329A0();
  v22 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 1:
      v20 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v20 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v20 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_47;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_47:
        v20 = 0;
        v22 = 10;
      }
      else
      {
        v20 = 1;
        v22 = 10;
      }
      break;
    default:
LABEL_18:
      v20 = 0;
      break;
  }
  if ( sub_10033900() )
    v20 = v20 == 0;
  sub_1001E480((int)&v34, (char *)&unk_10094738, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_10228548[v12], 0x400u, &v34);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v21 = sub_1001E480((int)&v34, (char *)&unk_10094738, 3, 0xCu, a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v34, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v22 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v13 = &byte_10228D48[v12];
    v21 = sub_1001E480((int)&v34, (char *)&unk_10094738, 3, 0xCu, v10);
    _snprintf(&byte_10228D48[v12], 0x400u, &v34, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v23 = off_10094438[a2];
  v26 = a5;
  v25 = a4;
  v24 = a3;
  v29 = "double";
  v30 = &byte_10228548[v12];
  v32 = v13;
  v17 = off_10094430[a1];
  v27 = off_10094428[v20 != 0];
  v28 = v17;
  v31 = &byte_10228948[v12];
  if ( a9 )
  {
    v33 = a9;
    v22 = 11;
  }
  v18 = sub_10038B80();
  sub_10034DB0(7, (int)&v23, v22);
  if ( v21 && a6 != a7 && fabs(a6 - a7) > v10 && !strcmp(v30, v31) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v18);
  return v20;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (1001F0C0) --------------------------------------------------------
bool __cdecl sub_1001F0C0(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  bool v25; // [sp+1Bh] [bp-59h]@10
  char v26; // [sp+1Fh] [bp-55h]@35
  unsigned int v27; // [sp+20h] [bp-54h]@8
  float v28; // [sp+24h] [bp-50h]@8
  char *v29; // [sp+38h] [bp-3Ch]@38
  int v30; // [sp+3Ch] [bp-38h]@38
  int v31; // [sp+40h] [bp-34h]@38
  int v32; // [sp+44h] [bp-30h]@38
  char *v33; // [sp+48h] [bp-2Ch]@38
  char *v34; // [sp+4Ch] [bp-28h]@38
  const char *v35; // [sp+50h] [bp-24h]@38
  const char *v36; // [sp+54h] [bp-20h]@38
  const char *v37; // [sp+58h] [bp-1Ch]@38
  char *v38; // [sp+5Ch] [bp-18h]@38
  int v39; // [sp+60h] [bp-14h]@39
  char v40; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v28 = v13;
  v14 = v28;
  v15 = a6;
  v16 = sub_100329A0();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v25 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_48;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_48:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_32:
      v25 = 0;
      break;
  }
  if ( sub_10033900() )
    v25 = v25 == 0;
  sub_1001E480((int)&v40, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_10228548[v20], 0x400u, &v40);
  byte_10228946[v20] = 42;
  byte_10228947[v20] = 0;
  v26 = sub_1001E480((int)&v40, "%f", 3, 0xCu, a7);
  _snprintf(&byte_10228948[v20], 0x400u, &v40, a7);
  byte_10228D46[v20] = 42;
  byte_10228D47[v20] = 0;
  if ( v27 <= 9 )
  {
    v21 = &byte_10228D48[v20];
    byte_10228D48[v20] = 0;
  }
  else
  {
    v21 = &byte_10228D48[v20];
    v26 = sub_1001E480((int)&v40, "%f", 3, 0xCu, v28);
    _snprintf(&byte_10228D48[v20], 0x400u, &v40, v28);
    byte_10229146[v20] = 42;
    byte_10229147[v20] = 0;
  }
  v29 = off_10094438[a2];
  v32 = a5;
  v31 = a4;
  v30 = a3;
  v35 = "float";
  v36 = &byte_10228548[v20];
  v37 = &byte_10228948[v20];
  v38 = v21;
  v22 = off_10094428[v25 != 0];
  v34 = off_10094430[a1];
  v33 = v22;
  if ( a9 )
  {
    v39 = a9;
    v27 = 11;
  }
  v23 = sub_10038B80();
  sub_10034DB0(7, (int)&v29, v27);
  if ( v26 && a7 != a6 && v28 < fabs(a6 - a7) && !strcmp(v36, v37) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v23);
  return v25;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (1001F580) --------------------------------------------------------
bool __cdecl sub_1001F580(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  void *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v18 = sub_1001E480((int)&v31, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_10228D48[v12];
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = &unk_10094784;
  v27 = &byte_10228548[v12];
  v28 = &byte_10228948[v12];
  v29 = v13;
  v14 = off_10094428[v17 != 0];
  v25 = off_10094430[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (1001F940) --------------------------------------------------------
bool __cdecl sub_1001F940(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_37;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v17 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v13 = &byte_10228D48[v12];
    v18 = sub_1001E480((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10228548[v12];
  v21 = a3;
  v26 = "sint16";
  v28 = &byte_10228948[v12];
  v29 = v13;
  v14 = off_10094430[a1];
  v24 = off_10094428[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (1001FD40) --------------------------------------------------------
bool __cdecl sub_1001FD40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, (char *)&unk_10065FA8, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, (char *)&unk_10065FA8, 4, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v18 = sub_1001E480((int)&v31, (char *)&unk_10065FA8, 4, 0xCu, (double)a8);
    v13 = &byte_10228D48[v12];
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "sint32";
  v27 = &byte_10228548[v12];
  v28 = &byte_10228948[v12];
  v29 = v13;
  v14 = off_10094428[v17 != 0];
  v25 = off_10094430[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10020100) --------------------------------------------------------
bool __cdecl sub_10020100(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  bool v18; // [sp+1Bh] [bp-5Dh]@3
  char v19; // [sp+1Fh] [bp-59h]@37
  unsigned int v20; // [sp+20h] [bp-58h]@1
  int v21; // [sp+30h] [bp-48h]@1
  char *v22; // [sp+3Ch] [bp-3Ch]@40
  int v23; // [sp+40h] [bp-38h]@40
  int v24; // [sp+44h] [bp-34h]@40
  int v25; // [sp+48h] [bp-30h]@40
  char *v26; // [sp+4Ch] [bp-2Ch]@40
  char *v27; // [sp+50h] [bp-28h]@40
  const char *v28; // [sp+54h] [bp-24h]@40
  const char *v29; // [sp+58h] [bp-20h]@40
  const char *v30; // [sp+5Ch] [bp-1Ch]@40
  char *v31; // [sp+60h] [bp-18h]@40
  int v32; // [sp+64h] [bp-14h]@41
  char v33; // [sp+68h] [bp-10h]@37

  v21 = sub_100329A0();
  v20 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 1:
      v18 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v18 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v18 = 0;
      }
      else
      {
        v18 = 1;
      }
LABEL_35:
      if ( sub_10033900() )
        v18 = v18 == 0;
      sub_1001E480((int)&v33, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v21;
      _snprintf(&byte_10228548[3072 * v21], 0x400u, &v33, a6);
      byte_10228946[v13] = 42;
      byte_10228947[v13] = 0;
      v19 = sub_1001E480((int)&v33, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_10228948[3072 * v21], 0x400u, &v33, a7);
      byte_10228D46[v13] = 42;
      byte_10228D47[v13] = 0;
      if ( v20 <= 9 )
      {
        v14 = &byte_10228D48[v13];
        byte_10228D48[v13] = 0;
      }
      else
      {
        v19 = sub_1001E480((int)&v33, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_10228D48[v13];
        _snprintf(&byte_10228D48[v13], 0x400u, &v33, a8);
        byte_10229146[v13] = 42;
        byte_10229147[v13] = 0;
      }
      v22 = off_10094438[a2];
      v24 = a4;
      v25 = a5;
      v23 = a3;
      v28 = "sint64";
      v29 = &byte_10228548[3072 * v21];
      v30 = &byte_10228948[3072 * v21];
      v15 = off_10094430[a1];
      v26 = off_10094428[v18 != 0];
      v27 = v15;
      v31 = v14;
      if ( a9 )
      {
        v32 = a9;
        v20 = 11;
      }
      v16 = sub_10038B80();
      sub_10034DB0(7, (int)&v22, v20);
      if ( v19 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v29, v30) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_10034EA0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10038B90(v16);
      return v18;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v18 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v18 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_50;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_50:
        v18 = 0;
        v20 = 10;
      }
      else
      {
        v18 = 1;
        v20 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10020640) --------------------------------------------------------
bool __cdecl sub_10020640(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_37;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v17 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v13 = &byte_10228D48[v12];
    v18 = sub_1001E480((int)&v31, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10228548[v12];
  v21 = a3;
  v26 = "sint8";
  v28 = &byte_10228948[v12];
  v29 = v13;
  v14 = off_10094430[a1];
  v24 = off_10094428[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10020A20) --------------------------------------------------------
bool __cdecl sub_10020A20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-55h]@2
  char v18; // [sp+1Fh] [bp-51h]@24
  unsigned int v19; // [sp+20h] [bp-50h]@1
  char *v20; // [sp+34h] [bp-3Ch]@27
  int v21; // [sp+38h] [bp-38h]@27
  int v22; // [sp+3Ch] [bp-34h]@27
  int v23; // [sp+40h] [bp-30h]@27
  char *v24; // [sp+44h] [bp-2Ch]@27
  char *v25; // [sp+48h] [bp-28h]@27
  const char *v26; // [sp+4Ch] [bp-24h]@27
  const char *v27; // [sp+50h] [bp-20h]@27
  const char *v28; // [sp+54h] [bp-1Ch]@27
  char *v29; // [sp+58h] [bp-18h]@27
  int v30; // [sp+5Ch] [bp-14h]@28
  char v31; // [sp+60h] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, (char *)&unk_10065FA8, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, (char *)&unk_10065FA8, 4, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v18 = sub_1001E480((int)&v31, (char *)&unk_10065FA8, 4, 0xCu, (double)a8);
    v13 = &byte_10228D48[v12];
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "long int";
  v27 = &byte_10228548[v12];
  v28 = &byte_10228948[v12];
  v29 = v13;
  v14 = off_10094428[v17 != 0];
  v25 = off_10094430[a1];
  v24 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10020DE0) --------------------------------------------------------
bool __cdecl sub_10020DE0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  unsigned int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v18 = sub_1001E480((int)&v31, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_10228D48[v12];
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned int";
  v29 = v13;
  v14 = off_10094428[v17 != 0];
  v25 = off_10094430[a1];
  v24 = v14;
  v27 = &byte_10228548[v12];
  v28 = &byte_10228948[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10021180) --------------------------------------------------------
bool __cdecl sub_10021180(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_37;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v13 = &byte_10228D48[v12];
    v18 = sub_1001E480((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10228548[v12];
  v21 = a3;
  v26 = "uint16";
  v28 = &byte_10228948[v12];
  v29 = v13;
  v14 = off_10094430[a1];
  v24 = off_10094428[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10021580) --------------------------------------------------------
bool __cdecl sub_10021580(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  unsigned int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, (char *)&unk_10065FAC, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, (char *)&unk_10065FAC, 4, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v18 = sub_1001E480((int)&v31, (char *)&unk_10065FAC, 4, 0xCu, (double)a8);
    v13 = &byte_10228D48[v12];
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "uint32";
  v29 = v13;
  v14 = off_10094428[v17 != 0];
  v25 = off_10094430[a1];
  v24 = v14;
  v27 = &byte_10228548[v12];
  v28 = &byte_10228948[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10021920) --------------------------------------------------------
bool __cdecl sub_10021920(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  bool v19; // [sp+18h] [bp-64h]@3
  char v20; // [sp+27h] [bp-55h]@36
  unsigned int v21; // [sp+28h] [bp-54h]@1
  int v22; // [sp+2Ch] [bp-50h]@1
  char *v23; // [sp+2Ch] [bp-50h]@36
  char *v24; // [sp+40h] [bp-3Ch]@39
  int v25; // [sp+44h] [bp-38h]@39
  int v26; // [sp+48h] [bp-34h]@39
  int v27; // [sp+4Ch] [bp-30h]@39
  char *v28; // [sp+50h] [bp-2Ch]@39
  char *v29; // [sp+54h] [bp-28h]@39
  const char *v30; // [sp+58h] [bp-24h]@39
  const char *v31; // [sp+5Ch] [bp-20h]@39
  const char *v32; // [sp+60h] [bp-1Ch]@39
  char *v33; // [sp+64h] [bp-18h]@39
  int v34; // [sp+68h] [bp-14h]@40
  char v35; // [sp+6Ch] [bp-10h]@36

  v22 = sub_100329A0();
  v21 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 1:
      v19 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v19 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v19 = 0;
      }
      else
      {
        v19 = 1;
      }
LABEL_34:
      if ( sub_10033900() )
        v19 = v19 == 0;
      sub_1001E480((int)&v35, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v22;
      v14 = &byte_10228548[3072 * v22];
      _snprintf(&byte_10228548[3072 * v22], 0x400u, &v35, a6);
      byte_10228946[v13] = 42;
      byte_10228947[v13] = 0;
      v20 = sub_1001E480((int)&v35, "%I64u", 6, 0xCu, (double)a7);
      v23 = &byte_10228948[3072 * v22];
      _snprintf(&byte_10228948[v13], 0x400u, &v35, a7);
      byte_10228D46[v13] = 42;
      byte_10228D47[v13] = 0;
      if ( v21 <= 9 )
      {
        v15 = &byte_10228D48[v13];
        byte_10228D48[v13] = 0;
      }
      else
      {
        v20 = sub_1001E480((int)&v35, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_10228D48[v13];
        _snprintf(&byte_10228D48[v13], 0x400u, &v35, a8);
        byte_10229146[v13] = 42;
        byte_10229147[v13] = 0;
      }
      v24 = off_10094438[a2];
      v27 = a5;
      v26 = a4;
      v33 = v15;
      v25 = a3;
      v30 = "uint64";
      v31 = v14;
      v16 = off_10094430[a1];
      v28 = off_10094428[v19 != 0];
      v29 = v16;
      v32 = v23;
      if ( a9 )
      {
        v34 = a9;
        v21 = 11;
      }
      v17 = sub_10038B80();
      sub_10034DB0(7, (int)&v24, v21);
      if ( v20 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v31, v32) )
      {
        nullsub_1(
          a3,
          a4,
          "Test definition error: Floating point values differ by less than the floating point output precision. The outp"
          "ut can not accurately represent the difference between the actual and expected values in this test case.");
        sub_10034EA0(
          3,
          (int)"**Error**",
          a3,
          a4,
          (int)"Test definition error: Floating point values differ by less than the floating point output precision. The"
               " output can not accurately represent the difference between the actual and expected values in this test case.");
      }
      sub_10038B90(v17);
      return v19;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v19 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_49;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_49:
        v19 = 0;
        v21 = 10;
      }
      else
      {
        v19 = 1;
        v21 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10021F00) --------------------------------------------------------
bool __cdecl sub_10021F00(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+24h] [bp-58h]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_37;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v17 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v13 = &byte_10228D48[v12];
    v18 = sub_1001E480((int)&v31, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v27 = &byte_10228548[v12];
  v21 = a3;
  v26 = "uint8";
  v28 = &byte_10228948[v12];
  v29 = v13;
  v14 = off_10094430[a1];
  v24 = off_10094428[v17 != 0];
  v25 = v14;
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (100222F0) --------------------------------------------------------
bool __cdecl sub_100222F0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  unsigned int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  bool v17; // [sp+1Bh] [bp-61h]@2
  char v18; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v19; // [sp+20h] [bp-5Ch]@1
  char *v20; // [sp+40h] [bp-3Ch]@27
  int v21; // [sp+44h] [bp-38h]@27
  int v22; // [sp+48h] [bp-34h]@27
  int v23; // [sp+4Ch] [bp-30h]@27
  char *v24; // [sp+50h] [bp-2Ch]@27
  char *v25; // [sp+54h] [bp-28h]@27
  const char *v26; // [sp+58h] [bp-24h]@27
  const char *v27; // [sp+5Ch] [bp-20h]@27
  const char *v28; // [sp+60h] [bp-1Ch]@27
  char *v29; // [sp+64h] [bp-18h]@27
  int v30; // [sp+68h] [bp-14h]@28
  char v31; // [sp+6Ch] [bp-10h]@24

  v9 = sub_100329A0();
  v19 = 9;
  switch ( a2 )
  {
    case 0:
      v17 = a6 == a7;
      break;
    case 1:
      v17 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 4:
      v17 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v17 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_37;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v17 = 1;
      if ( a6 > a8 + v11 )
LABEL_37:
        v17 = 0;
      v19 = 10;
      break;
    default:
LABEL_21:
      v17 = 0;
      break;
  }
  if ( sub_10033900() )
    v17 = v17 == 0;
  sub_1001E480((int)&v31, (char *)&unk_10065FAC, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_10228548[v12], 0x400u, &v31, a6);
  byte_10228946[v12] = 42;
  byte_10228947[v12] = 0;
  v18 = sub_1001E480((int)&v31, (char *)&unk_10065FAC, 4, 0xCu, (double)a7);
  _snprintf(&byte_10228948[v12], 0x400u, &v31, a7);
  byte_10228D46[v12] = 42;
  byte_10228D47[v12] = 0;
  if ( v19 <= 9 )
  {
    v13 = &byte_10228D48[v12];
    byte_10228D48[v12] = 0;
  }
  else
  {
    v18 = sub_1001E480((int)&v31, (char *)&unk_10065FAC, 4, 0xCu, (double)a8);
    v13 = &byte_10228D48[v12];
    _snprintf(&byte_10228D48[v12], 0x400u, &v31, a8);
    byte_10229146[v12] = 42;
    byte_10229147[v12] = 0;
  }
  v20 = off_10094438[a2];
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v26 = "unsigned long int";
  v29 = v13;
  v14 = off_10094428[v17 != 0];
  v25 = off_10094430[a1];
  v24 = v14;
  v27 = &byte_10228548[v12];
  v28 = &byte_10228948[v12];
  if ( a9 )
  {
    v30 = a9;
    v19 = 11;
  }
  v15 = sub_10038B80();
  sub_10034DB0(7, (int)&v20, v19);
  if ( v18 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) && !strcmp(v27, v28) )
  {
    nullsub_1(
      a3,
      a4,
      "Test definition error: Floating point values differ by less than the floating point output precision. The output c"
      "an not accurately represent the difference between the actual and expected values in this test case.");
    sub_10034EA0(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
  sub_10038B90(v15);
  return v17;
}
// 1001DD00: using guessed type int __cdecl nullsub_1(_DWORD, _DWORD, _DWORD);
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10022690) --------------------------------------------------------
int sub_10022690()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_100329A0();
  sub_1001E3E0(1);
  sub_1001E770(-1);
  result = sub_1001E700(-1);
  dword_1022C148[v0] = 0;
  return result;
}
// 1022C148: using guessed type int dword_1022C148[];

//----- (100226C0) --------------------------------------------------------
BOOL __usercall sub_100226C0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_100329A0();
  sub_10038BC0((int)&v13);
  sub_10038BC0((int)&v14);
  sub_10038BC0((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_10039810((int (__cdecl *)(unsigned int))sub_1001E660, v7, (int)&v13) )
  {
    if ( sub_10039810((int (__cdecl *)(unsigned int))sub_1001E660, a2, (int)&v14) )
    {
      v9 = sub_10039680(
             dword_1022E254[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1001E660,
             (void (__cdecl *)(_DWORD))sub_1001E680,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_10039AB0((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_10038C90((void (__cdecl *)(_DWORD))sub_1001E680, (int)&v12);
  sub_10038C90((void (__cdecl *)(_DWORD))sub_1001E680, (int)&v13);
  sub_10038C90((void (__cdecl *)(_DWORD))sub_1001E680, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 1022E254: using guessed type int dword_1022E254[];

//----- (10022830) --------------------------------------------------------
bool __usercall sub_10022830@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_100329A0();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_10033900() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_10020DE0(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_10033900() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_10228548[3072 * v24], 0x400u, "%s", v9);
  byte_10228946[v15] = 42;
  byte_10228947[v15] = 0;
  _snprintf(&byte_10228948[3072 * v24], 0x400u, "%s", v22);
  v16 = off_10094438[a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_10228D46[v15] = 42;
  v17 = off_10094428[v14 != 0];
  v18 = off_10094430[a3];
  byte_10228D47[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_10228548[3072 * v24];
  v34 = &byte_10228948[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_10038B80();
  sub_10034DB0(7, (int)&v26, v19);
  sub_10038B90(v20);
  return v14;
}
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];

//----- (10022AA0) --------------------------------------------------------
char __cdecl sub_10022AA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_100329A0();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_1022E254[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_1022F870[v10];
  sub_1001E180(a3, 1, a6, 0x230u, &byte_1022F870[v10]);
  v27 = &byte_1022C170[v10];
  sub_1001E180(a3, 2, a7, 0x230u, &byte_1022C170[v10]);
  v24 = &byte_1022D750[v10];
  sub_1001E180(a3, 3, a6, 0x230u, &byte_1022D750[v10]);
  v26 = &byte_1022E268[v10];
  sub_1001E180(a3, 4, a7, 0x230u, &byte_1022E268[v10]);
  _snprintf(&byte_1022ED58[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_1022ED58[v10];
  byte_1022EF87[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1001E180(a3, 0, v25, 560 - (v11 - &byte_1022ED58[v10 + 1]), &byte_1022ED58[v10] + v11 - &byte_1022ED58[v10 + 1]);
  v13 = &byte_1022ED58[v10];
  byte_1022EF87[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_1022ED54[v10] + v13 - &byte_1022ED58[v10 + 1]) = 0;
  sub_1001E180(a3, 1, (int)&byte_1022ED58[v10], 0x230u, &byte_10227A58[v10]);
  sub_1001E180(a3, 1, (int)&byte_1022ED58[v10], 0x230u, &byte_1022CC60[v10]);
  v15 = sub_100226C0(v22, v27, v21, a2 == 1, (int)&byte_10227A58[v10], (const char **)&v22);
  if ( sub_10033900() )
    v15 = v15 == 0;
  v30 = off_10094438[a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_10094430[a1];
  v34 = off_10094428[v15 != 0];
  v17 = dword_1022E254[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_10038B80();
  sub_10034DB0(7, (int)&v30, v18);
  sub_10038B90(v19);
  return v15;
}
// 10094428: using guessed type char *off_10094428[18];
// 10094430: using guessed type char *off_10094430[16];
// 10094438: using guessed type char *off_10094438[14];
// 1022E254: using guessed type int dword_1022E254[];

//----- (10022DA0) --------------------------------------------------------
bool __cdecl sub_10022DA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1001F580(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (10022E50) --------------------------------------------------------
bool __cdecl sub_10022E50(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_10022830(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (10022E90) --------------------------------------------------------
signed int __cdecl sub_10022E90(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_10230361 = 1;
    byte_10230360 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10230360 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10230361 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 10230360: using guessed type char byte_10230360;
// 10230361: using guessed type char byte_10230361;

//----- (10022EF0) --------------------------------------------------------
bool __cdecl sub_10022EF0(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_10034E70(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100AC4E8, (int)"failing_subroutine( depth-1 )");
    sub_10022EF0(a1 - 1);
    exit_0(14);
  }
  return sub_10022E50(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (10022F60) --------------------------------------------------------
int sub_10022F60()
{
  const char *v0; // eax@1

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_10230360 )
  {
    sub_10022E50(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_10034E70(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_10022EF0(1);
    exit_0(14);
  }
  return sub_10034EA0(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 10230360: using guessed type char byte_10230360;

//----- (10023280) --------------------------------------------------------
char sub_10023280()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  int v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  int v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10230360 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_1009555C + v2) )
      {
        sub_1001E180((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_10095564[v2], 0x100u, &v11);
        sub_1001E180((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_1009555C + v2), 0x100u, &v12);
        sub_10039BE0(&v12, &v11);
      }
      if ( byte_10095558[v2] )
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_10095560[v2 / 4];
        v4 = *(_DWORD *)&off_10095564[v2];
        v5 = sub_1001E420(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10095564[v2],
               off_10095560[v2 / 4]);
        v6 = sub_10022AA0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001E780(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_10095560[v2 / 4];
        v8 = *(_DWORD *)&off_10095564[v2];
        v9 = sub_1001E420(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_10095564[v2],
               off_10095560[v2 / 4]);
        v10 = sub_10022AA0(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001E780(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1009555C: using guessed type void *off_1009555C;
// 10095560: using guessed type char *off_10095560[2];
// 10230360: using guessed type char byte_10230360;

//----- (100234A0) --------------------------------------------------------
char sub_100234A0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10230360 )
  {
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1001E780(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1001E780(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1001E780(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1001E780(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001E780(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10230360: using guessed type char byte_10230360;

//----- (100236A0) --------------------------------------------------------
char sub_100236A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_100955EC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_100955E9[v2 * 4];
        v4 = byte_100955E8[v2 * 4];
        v5 = sub_1001E420(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + dword_100955EC[v2])],
               (&off_100955F0)[v2 * 4]);
        v6 = sub_1001E8C0(
               0,
               *(&dword_1009553C + dword_100955EC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1001E420(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_100955EC[v2]],
               (&off_100955F0)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100955EC: using guessed type int dword_100955EC[];
// 100955F0: using guessed type char *off_100955F0;
// 10230360: using guessed type char byte_10230360;

//----- (10023820) --------------------------------------------------------
char sub_10023820()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_10095870[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_10095868[v2 / 8];
        v4 = dbl_10095860[v2 / 8];
        v5 = dbl_10095858[v2 / 8];
        v6 = sub_1001E420(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_10095874[v2]);
        v7 = sub_1001EC70(
               0,
               *(&dword_1009553C + dword_10095870[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_10095870[v2 / 4]],
               *(_DWORD *)&off_10095874[v2]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10095858: using guessed type double dbl_10095858[];
// 10095860: using guessed type double dbl_10095860[];
// 10095868: using guessed type double dbl_10095868[];
// 10095870: using guessed type int dword_10095870[];
// 10230360: using guessed type char byte_10230360;

//----- (100239A0) --------------------------------------------------------
char sub_100239A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_10096484[v2];
      if ( v0 != 6 )
      {
        v3 = flt_10096480[v2];
        v4 = flt_1009647C[v2];
        v5 = flt_10096478[v2];
        v6 = sub_1001E420(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_10096488[v2 * 4]);
        v7 = sub_1001F0C0(
               0,
               *(&dword_1009553C + dword_10096484[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_10096484[v2]],
               *(_DWORD *)&off_10096488[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10096478: using guessed type float flt_10096478[];
// 1009647C: using guessed type float flt_1009647C[];
// 10096480: using guessed type float flt_10096480[];
// 10096484: using guessed type int dword_10096484[];
// 10230360: using guessed type char byte_10230360;

//----- (10023B10) --------------------------------------------------------
char sub_10023B10()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10230360 )
  {
    sub_10022DA0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_10023B10,
      (int)sub_10023B10,
      (int)"This test is expected to fail");
    sub_10022DA0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_10023B10,
      0,
      (int)"This test is expected to fail");
    result = sub_10022DA0(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10023B10,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10230360: using guessed type char byte_10230360;

//----- (10023C10) --------------------------------------------------------
char sub_10023C10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_10096C2C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10096C28[v2];
        v4 = dword_10096C24[v2];
        v5 = dword_10096C20[v2];
        v6 = sub_1001E420(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_10096C30)[v2 * 4]);
        v7 = sub_1001F580(
               0,
               *(&dword_1009553C + dword_10096C2C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_10096C2C[v2]],
               (&off_10096C30)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10096C20: using guessed type int dword_10096C20[];
// 10096C24: using guessed type int dword_10096C24[];
// 10096C28: using guessed type int dword_10096C28[];
// 10096C2C: using guessed type int dword_10096C2C[];
// 10096C30: using guessed type char *off_10096C30;
// 10230360: using guessed type char byte_10230360;

//----- (10023D70) --------------------------------------------------------
char sub_10023D70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_100973C0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100973BC[v2 / 2];
        v4 = word_100973BA[v2 / 2];
        v5 = word_100973B8[v2 / 2];
        v6 = sub_1001E420(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_100973C4)[v2]);
        v7 = sub_1001F940(
               0,
               *(&dword_1009553C + dword_100973C0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_100973C0[v2 / 4]],
               (&off_100973C4)[v2]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100973B8: using guessed type __int16 word_100973B8[];
// 100973BA: using guessed type __int16 word_100973BA[];
// 100973BC: using guessed type __int16 word_100973BC[];
// 100973C0: using guessed type int dword_100973C0[];
// 100973C4: using guessed type char *off_100973C4;
// 10230360: using guessed type char byte_10230360;

//----- (10023ED0) --------------------------------------------------------
char sub_10023ED0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_100979D4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100979D0[v2];
        v4 = dword_100979CC[v2];
        v5 = dword_100979C8[v2];
        v6 = sub_1001E420(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_100979D8[v2 * 4]);
        v7 = sub_1001FD40(
               0,
               *(&dword_1009553C + dword_100979D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_100979D4[v2]],
               *(_DWORD *)&off_100979D8[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100979C8: using guessed type int dword_100979C8[];
// 100979CC: using guessed type int dword_100979CC[];
// 100979D0: using guessed type int dword_100979D0[];
// 100979D4: using guessed type int dword_100979D4[];
// 10230360: using guessed type char byte_10230360;

//----- (10024030) --------------------------------------------------------
char sub_10024030()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_10098178[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_10098174[v2];
        LODWORD(v3) = dword_10098170[v2];
        HIDWORD(v4) = dword_1009816C[v2];
        LODWORD(v4) = dword_10098168[v2];
        HIDWORD(v5) = dword_10098164[v2];
        LODWORD(v5) = dword_10098160[v2];
        v6 = sub_1001E420(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_1009817C[v2 * 4]);
        v7 = sub_10020100(
               0,
               *(&dword_1009553C + dword_10098178[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_10098178[v2]],
               *(_DWORD *)&off_1009817C[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10098160: using guessed type int dword_10098160[];
// 10098164: using guessed type int dword_10098164[];
// 10098168: using guessed type int dword_10098168[];
// 1009816C: using guessed type int dword_1009816C[];
// 10098170: using guessed type int dword_10098170[];
// 10098174: using guessed type int dword_10098174[];
// 10098178: using guessed type int dword_10098178[];
// 10230360: using guessed type char byte_10230360;

//----- (100241A0) --------------------------------------------------------
char sub_100241A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_10098D84[v2];
      if ( v0 != 6 )
      {
        v3 = byte_10098D82[v2 * 4];
        v4 = byte_10098D81[v2 * 4];
        v5 = byte_10098D80[v2 * 4];
        v6 = sub_1001E420(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_10098D88)[v2 * 4]);
        v7 = sub_10020640(
               0,
               *(&dword_1009553C + dword_10098D84[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_10098D84[v2]],
               (&off_10098D88)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10098D84: using guessed type int dword_10098D84[];
// 10098D88: using guessed type char *off_10098D88;
// 10230360: using guessed type char byte_10230360;

//----- (10024300) --------------------------------------------------------
char sub_10024300()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009921C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10099218[v2];
        v4 = dword_10099214[v2];
        v5 = dword_10099210[v2];
        v6 = sub_1001E420(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_10099220)[v2 * 4]);
        v7 = sub_10020A20(
               0,
               *(&dword_1009553C + dword_1009921C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009921C[v2]],
               (&off_10099220)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10099210: using guessed type int dword_10099210[];
// 10099214: using guessed type int dword_10099214[];
// 10099218: using guessed type int dword_10099218[];
// 1009921C: using guessed type int dword_1009921C[];
// 10099220: using guessed type char *off_10099220;
// 10230360: using guessed type char byte_10230360;

//----- (10024460) --------------------------------------------------------
char sub_10024460()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10230360 )
  {
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_10022E50(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10064984,
           (int)"This test is expected to fail");
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_10022E50(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10064984,
           "a",
           (int)"This test is expected to fail");
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_10022E50(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10064984,
           (const char *)&unk_10064984,
           (int)"This test is expected to fail");
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_10022E50(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1001E780(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10230360: using guessed type char byte_10230360;

//----- (10024680) --------------------------------------------------------
char sub_10024680()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_100999B4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100999B0[v2];
        v4 = dword_100999AC[v2];
        v5 = dword_100999A8[v2];
        v6 = sub_1001E420(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_100999B8[v2 * 4]);
        v7 = sub_10020DE0(
               0,
               *(&dword_1009553C + dword_100999B4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_100999B4[v2]],
               *(_DWORD *)&off_100999B8[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100999A8: using guessed type int dword_100999A8[];
// 100999AC: using guessed type int dword_100999AC[];
// 100999B0: using guessed type int dword_100999B0[];
// 100999B4: using guessed type int dword_100999B4[];
// 10230360: using guessed type char byte_10230360;

//----- (100247E0) --------------------------------------------------------
char sub_100247E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_10099D20[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_10099D1C[v2 / 2];
        v4 = word_10099D1A[v2 / 2];
        v5 = word_10099D18[v2 / 2];
        v6 = sub_1001E420(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_10099D24)[v2]);
        v7 = sub_10021180(
               0,
               *(&dword_1009553C + dword_10099D20[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_10099D20[v2 / 4]],
               (&off_10099D24)[v2]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10099D18: using guessed type __int16 word_10099D18[];
// 10099D1A: using guessed type __int16 word_10099D1A[];
// 10099D1C: using guessed type __int16 word_10099D1C[];
// 10099D20: using guessed type int dword_10099D20[];
// 10099D24: using guessed type char *off_10099D24;
// 10230360: using guessed type char byte_10230360;

//----- (10024940) --------------------------------------------------------
char sub_10024940()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_10099FE4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_10099FE0[v2];
        v4 = dword_10099FDC[v2];
        v5 = dword_10099FD8[v2];
        v6 = sub_1001E420(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_10099FE8[v2 * 4]);
        v7 = sub_10021580(
               0,
               *(&dword_1009553C + dword_10099FE4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_10099FE4[v2]],
               *(_DWORD *)&off_10099FE8[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 10099FD8: using guessed type int dword_10099FD8[];
// 10099FDC: using guessed type int dword_10099FDC[];
// 10099FE0: using guessed type int dword_10099FE0[];
// 10099FE4: using guessed type int dword_10099FE4[];
// 10230360: using guessed type char byte_10230360;

//----- (10024AA0) --------------------------------------------------------
char sub_10024AA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009A360[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1009A35C[v2];
        LODWORD(v3) = dword_1009A358[v2];
        HIDWORD(v4) = dword_1009A354[v2];
        LODWORD(v4) = dword_1009A350[v2];
        HIDWORD(v5) = dword_1009A34C[v2];
        LODWORD(v5) = dword_1009A348[v2];
        v6 = sub_1001E420(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_1009A364)[v2 * 4]);
        v7 = sub_10021920(
               0,
               *(&dword_1009553C + dword_1009A360[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009A360[v2]],
               (&off_1009A364)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009A348: using guessed type int dword_1009A348[];
// 1009A34C: using guessed type int dword_1009A34C[];
// 1009A350: using guessed type int dword_1009A350[];
// 1009A354: using guessed type int dword_1009A354[];
// 1009A358: using guessed type int dword_1009A358[];
// 1009A35C: using guessed type int dword_1009A35C[];
// 1009A360: using guessed type int dword_1009A360[];
// 1009A364: using guessed type char *off_1009A364;
// 10230360: using guessed type char byte_10230360;

//----- (10024C10) --------------------------------------------------------
char sub_10024C10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009A8CC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1009A8CA[v2 * 4];
        v4 = byte_1009A8C9[v2 * 4];
        v5 = byte_1009A8C8[v2 * 4];
        v6 = sub_1001E420(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_1009A8D0)[v2 * 4]);
        v7 = sub_10021F00(
               0,
               *(&dword_1009553C + dword_1009A8CC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009A8CC[v2]],
               (&off_1009A8D0)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009A8CC: using guessed type int dword_1009A8CC[];
// 1009A8D0: using guessed type char *off_1009A8D0;
// 10230360: using guessed type char byte_10230360;

//----- (10024D70) --------------------------------------------------------
char sub_10024D70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009AAE4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009AAE0[v2];
        v4 = dword_1009AADC[v2];
        v5 = dword_1009AAD8[v2];
        v6 = sub_1001E420(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_1009AAE8[v2 * 4]);
        v7 = sub_100222F0(
               0,
               *(&dword_1009553C + dword_1009AAE4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009AAE4[v2]],
               *(_DWORD *)&off_1009AAE8[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009AAD8: using guessed type int dword_1009AAD8[];
// 1009AADC: using guessed type int dword_1009AADC[];
// 1009AAE0: using guessed type int dword_1009AAE0[];
// 1009AAE4: using guessed type int dword_1009AAE4[];
// 10230360: using guessed type char byte_10230360;

//----- (10024ED0) --------------------------------------------------------
char sub_10024ED0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  int v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  int v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10230360 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_1009AE4C + v2) )
      {
        sub_1001E180((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_1009AE54[v2], 0x100u, &v11);
        sub_1001E180((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_1009AE4C + v2), 0x100u, &v12);
        sub_10039BE0(&v12, &v11);
      }
      if ( byte_1009AE48[v2] )
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_1009AE50[v2 / 4];
        v4 = *(_DWORD *)&off_1009AE54[v2];
        v5 = sub_1001E420(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1009AE54[v2],
               off_1009AE50[v2 / 4]);
        v6 = sub_10022AA0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1001E780(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_1009AE50[v2 / 4];
        v8 = *(_DWORD *)&off_1009AE54[v2];
        v9 = sub_1001E420(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_1009AE54[v2],
               off_1009AE50[v2 / 4]);
        v10 = sub_10022AA0(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1001E780(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 1009AE4C: using guessed type void *off_1009AE4C;
// 1009AE50: using guessed type char *off_1009AE50[2];
// 10230360: using guessed type char byte_10230360;

//----- (100250F0) --------------------------------------------------------
char sub_100250F0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_10230360 )
  {
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1001E780(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1001E780(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1001E780(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1001E780(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1001E780(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10230360: using guessed type char byte_10230360;

//----- (100252F0) --------------------------------------------------------
char sub_100252F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009AEDC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_1009AED9[v2 * 4];
        v4 = byte_1009AED8[v2 * 4];
        v5 = sub_1001E420(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + dword_1009AEDC[v2])],
               (&off_1009AEE0)[v2 * 4]);
        v6 = sub_1001E8C0(
               1,
               *(&dword_1009553C + dword_1009AEDC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1001E420(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009AEDC[v2]],
               (&off_1009AEE0)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009AEDC: using guessed type int dword_1009AEDC[];
// 1009AEE0: using guessed type char *off_1009AEE0;
// 10230360: using guessed type char byte_10230360;

//----- (10025470) --------------------------------------------------------
char sub_10025470()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009B160[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_1009B158[v2 / 8];
        v4 = dbl_1009B150[v2 / 8];
        v5 = dbl_1009B148[v2 / 8];
        v6 = sub_1001E420(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_1009B164)[v2]);
        v7 = sub_1001EC70(
               1,
               *(&dword_1009553C + dword_1009B160[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009B160[v2 / 4]],
               (&off_1009B164)[v2]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009B148: using guessed type double dbl_1009B148[];
// 1009B150: using guessed type double dbl_1009B150[];
// 1009B158: using guessed type double dbl_1009B158[];
// 1009B160: using guessed type int dword_1009B160[];
// 1009B164: using guessed type char *off_1009B164;
// 10230360: using guessed type char byte_10230360;

//----- (100255F0) --------------------------------------------------------
char sub_100255F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009BD74[v2];
      if ( v0 != 6 )
      {
        v3 = flt_1009BD70[v2];
        v4 = flt_1009BD6C[v2];
        v5 = flt_1009BD68[v2];
        v6 = sub_1001E420(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_1009BD78[v2 * 4]);
        v7 = sub_1001F0C0(
               1,
               *(&dword_1009553C + dword_1009BD74[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009BD74[v2]],
               *(_DWORD *)&off_1009BD78[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009BD68: using guessed type float flt_1009BD68[];
// 1009BD6C: using guessed type float flt_1009BD6C[];
// 1009BD70: using guessed type float flt_1009BD70[];
// 1009BD74: using guessed type int dword_1009BD74[];
// 10230360: using guessed type char byte_10230360;

//----- (10025760) --------------------------------------------------------
char sub_10025760()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10230360 )
  {
    sub_10022DA0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_10025760,
      (int)sub_10025760,
      0);
    sub_10022DA0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_10025760,
      0,
      0);
    result = sub_10022DA0(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10025760,
               0);
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10230360: using guessed type char byte_10230360;

//----- (10025850) --------------------------------------------------------
char sub_10025850()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009C50C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009C508[v2];
        v4 = dword_1009C504[v2];
        v5 = dword_1009C500[v2];
        v6 = sub_1001E420(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_1009C510)[v2 * 4]);
        v7 = sub_1001F580(
               1,
               *(&dword_1009553C + dword_1009C50C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009C50C[v2]],
               (&off_1009C510)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009C500: using guessed type int dword_1009C500[];
// 1009C504: using guessed type int dword_1009C504[];
// 1009C508: using guessed type int dword_1009C508[];
// 1009C50C: using guessed type int dword_1009C50C[];
// 1009C510: using guessed type char *off_1009C510;
// 10230360: using guessed type char byte_10230360;

//----- (100259B0) --------------------------------------------------------
char sub_100259B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009CCA0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1009CC9C[v2 / 2];
        v4 = word_1009CC9A[v2 / 2];
        v5 = word_1009CC98[v2 / 2];
        v6 = sub_1001E420(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_1009CCA4)[v2]);
        v7 = sub_1001F940(
               1,
               *(&dword_1009553C + dword_1009CCA0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009CCA0[v2 / 4]],
               (&off_1009CCA4)[v2]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009CC98: using guessed type __int16 word_1009CC98[];
// 1009CC9A: using guessed type __int16 word_1009CC9A[];
// 1009CC9C: using guessed type __int16 word_1009CC9C[];
// 1009CCA0: using guessed type int dword_1009CCA0[];
// 1009CCA4: using guessed type char *off_1009CCA4;
// 10230360: using guessed type char byte_10230360;

//----- (10025B10) --------------------------------------------------------
char sub_10025B10()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009D2B4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009D2B0[v2];
        v4 = dword_1009D2AC[v2];
        v5 = dword_1009D2A8[v2];
        v6 = sub_1001E420(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_1009D2B8[v2 * 4]);
        v7 = sub_1001FD40(
               1,
               *(&dword_1009553C + dword_1009D2B4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009D2B4[v2]],
               *(_DWORD *)&off_1009D2B8[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009D2A8: using guessed type int dword_1009D2A8[];
// 1009D2AC: using guessed type int dword_1009D2AC[];
// 1009D2B0: using guessed type int dword_1009D2B0[];
// 1009D2B4: using guessed type int dword_1009D2B4[];
// 10230360: using guessed type char byte_10230360;

//----- (10025C70) --------------------------------------------------------
char sub_10025C70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009DA58[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1009DA54[v2];
        LODWORD(v3) = dword_1009DA50[v2];
        HIDWORD(v4) = dword_1009DA4C[v2];
        LODWORD(v4) = dword_1009DA48[v2];
        HIDWORD(v5) = dword_1009DA44[v2];
        LODWORD(v5) = dword_1009DA40[v2];
        v6 = sub_1001E420(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_1009DA5C[v2 * 4]);
        v7 = sub_10020100(
               1,
               *(&dword_1009553C + dword_1009DA58[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009DA58[v2]],
               *(_DWORD *)&off_1009DA5C[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009DA40: using guessed type int dword_1009DA40[];
// 1009DA44: using guessed type int dword_1009DA44[];
// 1009DA48: using guessed type int dword_1009DA48[];
// 1009DA4C: using guessed type int dword_1009DA4C[];
// 1009DA50: using guessed type int dword_1009DA50[];
// 1009DA54: using guessed type int dword_1009DA54[];
// 1009DA58: using guessed type int dword_1009DA58[];
// 10230360: using guessed type char byte_10230360;

//----- (10025DE0) --------------------------------------------------------
char sub_10025DE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009E664[v2];
      if ( v0 != 6 )
      {
        v3 = byte_1009E662[v2 * 4];
        v4 = byte_1009E661[v2 * 4];
        v5 = byte_1009E660[v2 * 4];
        v6 = sub_1001E420(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_1009E668)[v2 * 4]);
        v7 = sub_10020640(
               1,
               *(&dword_1009553C + dword_1009E664[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009E664[v2]],
               (&off_1009E668)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009E664: using guessed type int dword_1009E664[];
// 1009E668: using guessed type char *off_1009E668;
// 10230360: using guessed type char byte_10230360;

//----- (10025F40) --------------------------------------------------------
char sub_10025F40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009EAFC[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009EAF8[v2];
        v4 = dword_1009EAF4[v2];
        v5 = dword_1009EAF0[v2];
        v6 = sub_1001E420(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_1009EB00)[v2 * 4]);
        v7 = sub_10020A20(
               1,
               *(&dword_1009553C + dword_1009EAFC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009EAFC[v2]],
               (&off_1009EB00)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009EAF0: using guessed type int dword_1009EAF0[];
// 1009EAF4: using guessed type int dword_1009EAF4[];
// 1009EAF8: using guessed type int dword_1009EAF8[];
// 1009EAFC: using guessed type int dword_1009EAFC[];
// 1009EB00: using guessed type char *off_1009EB00;
// 10230360: using guessed type char byte_10230360;

//----- (100260A0) --------------------------------------------------------
char sub_100260A0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10230360 )
  {
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_10022E50(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10064984,
           0);
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_10022E50(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           (const char *)&unk_10064984,
           "a",
           0);
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_10022E50(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10064984,
           (const char *)&unk_10064984,
           0);
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_10022E50(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1001E780(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10230360: using guessed type char byte_10230360;

//----- (100262A0) --------------------------------------------------------
char sub_100262A0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009F294[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009F290[v2];
        v4 = dword_1009F28C[v2];
        v5 = dword_1009F288[v2];
        v6 = sub_1001E420(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_1009F298[v2 * 4]);
        v7 = sub_10020DE0(
               1,
               *(&dword_1009553C + dword_1009F294[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009F294[v2]],
               *(_DWORD *)&off_1009F298[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009F288: using guessed type int dword_1009F288[];
// 1009F28C: using guessed type int dword_1009F28C[];
// 1009F290: using guessed type int dword_1009F290[];
// 1009F294: using guessed type int dword_1009F294[];
// 10230360: using guessed type char byte_10230360;

//----- (10026400) --------------------------------------------------------
char sub_10026400()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009F600[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_1009F5FC[v2 / 2];
        v4 = word_1009F5FA[v2 / 2];
        v5 = word_1009F5F8[v2 / 2];
        v6 = sub_1001E420(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_1009F604)[v2]);
        v7 = sub_10021180(
               1,
               *(&dword_1009553C + dword_1009F600[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009F600[v2 / 4]],
               (&off_1009F604)[v2]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009F5F8: using guessed type __int16 word_1009F5F8[];
// 1009F5FA: using guessed type __int16 word_1009F5FA[];
// 1009F5FC: using guessed type __int16 word_1009F5FC[];
// 1009F600: using guessed type int dword_1009F600[];
// 1009F604: using guessed type char *off_1009F604;
// 10230360: using guessed type char byte_10230360;

//----- (10026560) --------------------------------------------------------
char sub_10026560()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009F8C4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_1009F8C0[v2];
        v4 = dword_1009F8BC[v2];
        v5 = dword_1009F8B8[v2];
        v6 = sub_1001E420(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_1009F8C8[v2 * 4]);
        v7 = sub_10021580(
               1,
               *(&dword_1009553C + dword_1009F8C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009F8C4[v2]],
               *(_DWORD *)&off_1009F8C8[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009F8B8: using guessed type int dword_1009F8B8[];
// 1009F8BC: using guessed type int dword_1009F8BC[];
// 1009F8C0: using guessed type int dword_1009F8C0[];
// 1009F8C4: using guessed type int dword_1009F8C4[];
// 10230360: using guessed type char byte_10230360;

//----- (100266C0) --------------------------------------------------------
char sub_100266C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_1009FC40[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_1009FC3C[v2];
        LODWORD(v3) = dword_1009FC38[v2];
        HIDWORD(v4) = dword_1009FC34[v2];
        LODWORD(v4) = dword_1009FC30[v2];
        HIDWORD(v5) = dword_1009FC2C[v2];
        LODWORD(v5) = dword_1009FC28[v2];
        v6 = sub_1001E420(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_1009FC44)[v2 * 4]);
        v7 = sub_10021920(
               1,
               *(&dword_1009553C + dword_1009FC40[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_1009FC40[v2]],
               (&off_1009FC44)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 1009FC28: using guessed type int dword_1009FC28[];
// 1009FC2C: using guessed type int dword_1009FC2C[];
// 1009FC30: using guessed type int dword_1009FC30[];
// 1009FC34: using guessed type int dword_1009FC34[];
// 1009FC38: using guessed type int dword_1009FC38[];
// 1009FC3C: using guessed type int dword_1009FC3C[];
// 1009FC40: using guessed type int dword_1009FC40[];
// 1009FC44: using guessed type char *off_1009FC44;
// 10230360: using guessed type char byte_10230360;

//----- (10026830) --------------------------------------------------------
char sub_10026830()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_100A01AC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100A01AA[v2 * 4];
        v4 = byte_100A01A9[v2 * 4];
        v5 = byte_100A01A8[v2 * 4];
        v6 = sub_1001E420(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               (&off_100A01B0)[v2 * 4]);
        v7 = sub_10021F00(
               1,
               *(&dword_1009553C + dword_100A01AC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_100A01AC[v2]],
               (&off_100A01B0)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A01AC: using guessed type int dword_100A01AC[];
// 100A01B0: using guessed type char *off_100A01B0;
// 10230360: using guessed type char byte_10230360;

//----- (10026990) --------------------------------------------------------
char sub_10026990()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10230360 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_100A03C4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100A03C0[v2];
        v4 = dword_100A03BC[v2];
        v5 = dword_100A03B8[v2];
        v6 = sub_1001E420(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * *(&dword_1009553C + v0)],
               *(_DWORD *)&off_100A03C8[v2 * 4]);
        v7 = sub_100222F0(
               1,
               *(&dword_1009553C + dword_100A03C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1001E420(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_100A03C4[v2]],
               *(_DWORD *)&off_100A03C8[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100A03B8: using guessed type int dword_100A03B8[];
// 100A03BC: using guessed type int dword_100A03BC[];
// 100A03C0: using guessed type int dword_100A03C0[];
// 100A03C4: using guessed type int dword_100A03C4[];
// 10230360: using guessed type char byte_10230360;

//----- (10026AF0) --------------------------------------------------------
char sub_10026AF0()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_10230361 )
  {
    sub_10022E50(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10034EA0(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1001F580(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_10033900() )
      v1 = 3;
    sub_1001F580(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_10033900();
    sub_1001F580(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10034EA0(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1001F580(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10230361: using guessed type char byte_10230361;

//----- (10027090) --------------------------------------------------------
char sub_10027090()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  int v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  int v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10230361 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100A072C + v2) )
      {
        sub_1001E180((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100A0734[v2], 0x100u, &v13);
        sub_1001E180((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100A072C + v2), 0x100u, &v14);
        sub_10039BE0(&v14, &v13);
      }
      if ( byte_100A0728[v2] )
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = *(int *)((char *)&off_100A0730 + v2);
        v4 = *(_DWORD *)&off_100A0734[v2];
        v5 = sub_1001E420(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A0734[v2],
               *(void **)((char *)&off_100A0730 + v2));
        v12 = 1;
        v11 = sub_10022AA0(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2114", (int)v5, v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = *(int *)((char *)&off_100A0730 + v2);
        v7 = *(_DWORD *)&off_100A0734[v2];
        v8 = sub_1001E420(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A0734[v2],
               *(void **)((char *)&off_100A0730 + v2));
        v12 = 1;
        v11 = sub_10022AA0(0, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2123", (int)v8, v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A072C: using guessed type void *off_100A072C;
// 100A0730: using guessed type void *off_100A0730;
// 10230361: using guessed type char byte_10230361;

//----- (100272A0) --------------------------------------------------------
char sub_100272A0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10230361 )
  {
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1001E780(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1001E780(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1001E780(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1001E780(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001E780(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10230361: using guessed type char byte_10230361;

//----- (10027490) --------------------------------------------------------
char sub_10027490()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_100A077C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100A0779[v2 * 4];
        v4 = byte_100A0778[v2 * 4];
        v5 = sub_1001E420(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * dword_100A077C[v2]],
               (&off_100A0780)[v2 * 4]);
        v6 = sub_1001E8C0(0, dword_100A077C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1001E420(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_100A077C[v2]],
               (&off_100A0780)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100A077C: using guessed type int dword_100A077C[];
// 100A0780: using guessed type char *off_100A0780;
// 10230361: using guessed type char byte_10230361;

//----- (10027600) --------------------------------------------------------
char sub_10027600()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100A09F8[v2 / 2];
      v4 = dbl_100A09F0[v2 / 2];
      v5 = dbl_100A09E8[v2 / 2];
      v6 = sub_1001E420(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A0A00[v2]],
             (&off_100A0A04)[v2 * 4]);
      v7 = sub_1001EC70(0, dword_100A0A00[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A0A00[v2]],
             (&off_100A0A04)[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A09E8: using guessed type double dbl_100A09E8[];
// 100A09F0: using guessed type double dbl_100A09F0[];
// 100A09F8: using guessed type double dbl_100A09F8[];
// 100A0A00: using guessed type int dword_100A0A00[];
// 100A0A04: using guessed type char *off_100A0A04;
// 10230361: using guessed type char byte_10230361;

//----- (10027770) --------------------------------------------------------
char sub_10027770()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100A1610[v2];
      v4 = flt_100A160C[v2];
      v5 = flt_100A1608[v2];
      v6 = sub_1001E420(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A1614[v2]],
             *(_DWORD *)&off_100A1618[v2 * 4]);
      v7 = sub_1001F0C0(0, dword_100A1614[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A1614[v2]],
             *(_DWORD *)&off_100A1618[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A1608: using guessed type float flt_100A1608[];
// 100A160C: using guessed type float flt_100A160C[];
// 100A1610: using guessed type float flt_100A1610[];
// 100A1614: using guessed type int dword_100A1614[];
// 10230361: using guessed type char byte_10230361;

//----- (100278D0) --------------------------------------------------------
char sub_100278D0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10230361 )
  {
    sub_10022DA0(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_100278D0,
      (int)sub_100278D0,
      0);
    sub_10022DA0(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_100278D0,
      0,
      0);
    result = sub_10022DA0(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100278D0,
               0);
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10230361: using guessed type char byte_10230361;

//----- (100279C0) --------------------------------------------------------
char sub_100279C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100A1DA8[v2];
      v4 = dword_100A1DA4[v2];
      v5 = dword_100A1DA0[v2];
      v6 = sub_1001E420(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A1DAC[v2]],
             (&off_100A1DB0)[v2 * 4]);
      v7 = sub_1001F580(0, dword_100A1DAC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A1DAC[v2]],
             (&off_100A1DB0)[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A1DA0: using guessed type int dword_100A1DA0[];
// 100A1DA4: using guessed type int dword_100A1DA4[];
// 100A1DA8: using guessed type int dword_100A1DA8[];
// 100A1DAC: using guessed type int dword_100A1DAC[];
// 100A1DB0: using guessed type char *off_100A1DB0;
// 10230361: using guessed type char byte_10230361;

//----- (10027B20) --------------------------------------------------------
char sub_10027B20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100A253C[v2 / 2];
      v4 = word_100A253A[v2 / 2];
      v5 = word_100A2538[v2 / 2];
      v6 = sub_1001E420(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A2540[v2 / 4]],
             (&off_100A2544)[v2]);
      v7 = sub_1001F940(
             0,
             dword_100A2540[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A2540[v2 / 4]],
             (&off_100A2544)[v2]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A2538: using guessed type __int16 word_100A2538[];
// 100A253A: using guessed type __int16 word_100A253A[];
// 100A253C: using guessed type __int16 word_100A253C[];
// 100A2540: using guessed type int dword_100A2540[];
// 100A2544: using guessed type char *off_100A2544;
// 10230361: using guessed type char byte_10230361;

//----- (10027C80) --------------------------------------------------------
char sub_10027C80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100A2B50[v2];
      v4 = dword_100A2B4C[v2];
      v5 = dword_100A2B48[v2];
      v6 = sub_1001E420(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A2B54[v2]],
             *(_DWORD *)&off_100A2B58[v2 * 4]);
      v7 = sub_1001FD40(0, dword_100A2B54[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A2B54[v2]],
             *(_DWORD *)&off_100A2B58[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A2B48: using guessed type int dword_100A2B48[];
// 100A2B4C: using guessed type int dword_100A2B4C[];
// 100A2B50: using guessed type int dword_100A2B50[];
// 100A2B54: using guessed type int dword_100A2B54[];
// 10230361: using guessed type char byte_10230361;

//----- (10027DE0) --------------------------------------------------------
char sub_10027DE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100A32F4[v2];
      LODWORD(v3) = dword_100A32F0[v2];
      HIDWORD(v4) = dword_100A32EC[v2];
      LODWORD(v4) = dword_100A32E8[v2];
      HIDWORD(v5) = dword_100A32E4[v2];
      LODWORD(v5) = dword_100A32E0[v2];
      v6 = sub_1001E420(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A32F8[v2]],
             *(_DWORD *)&off_100A32FC[v2 * 4]);
      v7 = sub_10020100(0, dword_100A32F8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A32F8[v2]],
             *(_DWORD *)&off_100A32FC[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A32E0: using guessed type int dword_100A32E0[];
// 100A32E4: using guessed type int dword_100A32E4[];
// 100A32E8: using guessed type int dword_100A32E8[];
// 100A32EC: using guessed type int dword_100A32EC[];
// 100A32F0: using guessed type int dword_100A32F0[];
// 100A32F4: using guessed type int dword_100A32F4[];
// 100A32F8: using guessed type int dword_100A32F8[];
// 10230361: using guessed type char byte_10230361;

//----- (10027F50) --------------------------------------------------------
char sub_10027F50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100A3F02[v2 * 4];
      v4 = byte_100A3F01[v2 * 4];
      v5 = byte_100A3F00[v2 * 4];
      v6 = sub_1001E420(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A3F04[v2]],
             (&off_100A3F08)[v2 * 4]);
      v7 = sub_10020640(0, dword_100A3F04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A3F04[v2]],
             (&off_100A3F08)[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A3F04: using guessed type int dword_100A3F04[];
// 100A3F08: using guessed type char *off_100A3F08;
// 10230361: using guessed type char byte_10230361;

//----- (100280B0) --------------------------------------------------------
char sub_100280B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100A4398[v2];
      v4 = dword_100A4394[v2];
      v5 = dword_100A4390[v2];
      v6 = sub_1001E420(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A439C[v2]],
             (&off_100A43A0)[v2 * 4]);
      v7 = sub_10020A20(0, dword_100A439C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A439C[v2]],
             (&off_100A43A0)[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A4390: using guessed type int dword_100A4390[];
// 100A4394: using guessed type int dword_100A4394[];
// 100A4398: using guessed type int dword_100A4398[];
// 100A439C: using guessed type int dword_100A439C[];
// 100A43A0: using guessed type char *off_100A43A0;
// 10230361: using guessed type char byte_10230361;

//----- (10028210) --------------------------------------------------------
char sub_10028210()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10230361 )
  {
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_10022E50(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10064984,
           (const char *)&unk_10064984,
           0);
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_10022E50(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_10022E50(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10064984,
           0);
    sub_1001E780(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_10022E50(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001E780(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10230361: using guessed type char byte_10230361;

//----- (10028410) --------------------------------------------------------
char sub_10028410()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100A4B30[v2];
      v4 = dword_100A4B2C[v2];
      v5 = dword_100A4B28[v2];
      v6 = sub_1001E420(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A4B34[v2]],
             *(_DWORD *)&off_100A4B38[v2 * 4]);
      v7 = sub_10020DE0(0, dword_100A4B34[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A4B34[v2]],
             *(_DWORD *)&off_100A4B38[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A4B28: using guessed type int dword_100A4B28[];
// 100A4B2C: using guessed type int dword_100A4B2C[];
// 100A4B30: using guessed type int dword_100A4B30[];
// 100A4B34: using guessed type int dword_100A4B34[];
// 10230361: using guessed type char byte_10230361;

//----- (10028570) --------------------------------------------------------
char sub_10028570()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100A4E9C[v2 / 2];
      v4 = word_100A4E9A[v2 / 2];
      v5 = word_100A4E98[v2 / 2];
      v6 = sub_1001E420(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A4EA0[v2 / 4]],
             (&off_100A4EA4)[v2]);
      v7 = sub_10021180(
             0,
             dword_100A4EA0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A4EA0[v2 / 4]],
             (&off_100A4EA4)[v2]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A4E98: using guessed type __int16 word_100A4E98[];
// 100A4E9A: using guessed type __int16 word_100A4E9A[];
// 100A4E9C: using guessed type __int16 word_100A4E9C[];
// 100A4EA0: using guessed type int dword_100A4EA0[];
// 100A4EA4: using guessed type char *off_100A4EA4;
// 10230361: using guessed type char byte_10230361;

//----- (100286D0) --------------------------------------------------------
char sub_100286D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100A5160[v2];
      v4 = dword_100A515C[v2];
      v5 = dword_100A5158[v2];
      v6 = sub_1001E420(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A5164[v2]],
             *(_DWORD *)&off_100A5168[v2 * 4]);
      v7 = sub_10021580(0, dword_100A5164[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A5164[v2]],
             *(_DWORD *)&off_100A5168[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A5158: using guessed type int dword_100A5158[];
// 100A515C: using guessed type int dword_100A515C[];
// 100A5160: using guessed type int dword_100A5160[];
// 100A5164: using guessed type int dword_100A5164[];
// 10230361: using guessed type char byte_10230361;

//----- (10028830) --------------------------------------------------------
char sub_10028830()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100A54DC[v2];
      LODWORD(v3) = dword_100A54D8[v2];
      HIDWORD(v4) = dword_100A54D4[v2];
      LODWORD(v4) = dword_100A54D0[v2];
      HIDWORD(v5) = dword_100A54CC[v2];
      LODWORD(v5) = dword_100A54C8[v2];
      v6 = sub_1001E420(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A54E0[v2]],
             (&off_100A54E4)[v2 * 4]);
      v7 = sub_10021920(0, dword_100A54E0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A54E0[v2]],
             (&off_100A54E4)[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A54C8: using guessed type int dword_100A54C8[];
// 100A54CC: using guessed type int dword_100A54CC[];
// 100A54D0: using guessed type int dword_100A54D0[];
// 100A54D4: using guessed type int dword_100A54D4[];
// 100A54D8: using guessed type int dword_100A54D8[];
// 100A54DC: using guessed type int dword_100A54DC[];
// 100A54E0: using guessed type int dword_100A54E0[];
// 100A54E4: using guessed type char *off_100A54E4;
// 10230361: using guessed type char byte_10230361;

//----- (100289A0) --------------------------------------------------------
char sub_100289A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100A5A4A[v2 * 4];
      v4 = byte_100A5A49[v2 * 4];
      v5 = byte_100A5A48[v2 * 4];
      v6 = sub_1001E420(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A5A4C[v2]],
             (&off_100A5A50)[v2 * 4]);
      v7 = sub_10021F00(0, dword_100A5A4C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A5A4C[v2]],
             (&off_100A5A50)[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A5A4C: using guessed type int dword_100A5A4C[];
// 100A5A50: using guessed type char *off_100A5A50;
// 10230361: using guessed type char byte_10230361;

//----- (10028B00) --------------------------------------------------------
char sub_10028B00()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100A5C60[v2];
      v4 = dword_100A5C5C[v2];
      v5 = dword_100A5C58[v2];
      v6 = sub_1001E420(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A5C64[v2]],
             *(_DWORD *)&off_100A5C68[v2 * 4]);
      v7 = sub_100222F0(0, dword_100A5C64[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A5C64[v2]],
             *(_DWORD *)&off_100A5C68[v2 * 4]);
      result = sub_1001E780(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A5C58: using guessed type int dword_100A5C58[];
// 100A5C5C: using guessed type int dword_100A5C5C[];
// 100A5C60: using guessed type int dword_100A5C60[];
// 100A5C64: using guessed type int dword_100A5C64[];
// 10230361: using guessed type char byte_10230361;

//----- (10028C60) --------------------------------------------------------
char sub_10028C60()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  int v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  int v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10230361 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100A5FCC + v2) )
      {
        sub_1001E180((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100A5FD4[v2], 0x100u, &v13);
        sub_1001E180((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100A5FCC + v2), 0x100u, &v14);
        sub_10039BE0(&v14, &v13);
      }
      if ( byte_100A5FC8[v2] )
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = *(int *)((char *)&off_100A5FD0 + v2);
        v4 = *(_DWORD *)&off_100A5FD4[v2];
        v5 = sub_1001E420(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A5FD4[v2],
               *(void **)((char *)&off_100A5FD0 + v2));
        v12 = 1;
        v11 = sub_10022AA0(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2745", (int)v5, v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = *(int *)((char *)&off_100A5FD0 + v2);
        v7 = *(_DWORD *)&off_100A5FD4[v2];
        v8 = sub_1001E420(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100A5FD4[v2],
               *(void **)((char *)&off_100A5FD0 + v2));
        v12 = 1;
        v11 = sub_10022AA0(1, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2754", (int)v8, v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A5FCC: using guessed type void *off_100A5FCC;
// 100A5FD0: using guessed type void *off_100A5FD0;
// 10230361: using guessed type char byte_10230361;

//----- (10028E70) --------------------------------------------------------
char sub_10028E70()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10230361 )
  {
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1001E780(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1001E780(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1001E780(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1001E780(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1001E780(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10230361: using guessed type char byte_10230361;

//----- (10029060) --------------------------------------------------------
char sub_10029060()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      v0 = dword_100A601C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100A6019[v2 * 4];
        v4 = byte_100A6018[v2 * 4];
        v5 = sub_1001E420(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_10095520[4 * dword_100A601C[v2]],
               (&off_100A6020)[v2 * 4]);
        v6 = sub_1001E8C0(1, dword_100A601C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1001E420(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_10095520[4 * dword_100A601C[v2]],
               (&off_100A6020)[v2 * 4]);
        LOBYTE(v0) = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10034EA0(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100A601C: using guessed type int dword_100A601C[];
// 100A6020: using guessed type char *off_100A6020;
// 10230361: using guessed type char byte_10230361;

//----- (100291D0) --------------------------------------------------------
char sub_100291D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100A6298[v2 / 2];
      v4 = dbl_100A6290[v2 / 2];
      v5 = dbl_100A6288[v2 / 2];
      v6 = sub_1001E420(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A62A0[v2]],
             (&off_100A62A4)[v2 * 4]);
      v7 = sub_1001EC70(1, dword_100A62A0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A62A0[v2]],
             (&off_100A62A4)[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A6288: using guessed type double dbl_100A6288[];
// 100A6290: using guessed type double dbl_100A6290[];
// 100A6298: using guessed type double dbl_100A6298[];
// 100A62A0: using guessed type int dword_100A62A0[];
// 100A62A4: using guessed type char *off_100A62A4;
// 10230361: using guessed type char byte_10230361;

//----- (10029340) --------------------------------------------------------
char sub_10029340()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100A6EB0[v2];
      v4 = flt_100A6EAC[v2];
      v5 = flt_100A6EA8[v2];
      v6 = sub_1001E420(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A6EB4[v2]],
             *(_DWORD *)&off_100A6EB8[v2 * 4]);
      v7 = sub_1001F0C0(1, dword_100A6EB4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A6EB4[v2]],
             *(_DWORD *)&off_100A6EB8[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A6EA8: using guessed type float flt_100A6EA8[];
// 100A6EAC: using guessed type float flt_100A6EAC[];
// 100A6EB0: using guessed type float flt_100A6EB0[];
// 100A6EB4: using guessed type int dword_100A6EB4[];
// 10230361: using guessed type char byte_10230361;

//----- (100294A0) --------------------------------------------------------
char sub_100294A0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10230361 )
  {
    sub_10022DA0(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_100294A0,
      (int)sub_100294A0,
      0);
    sub_10022DA0(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_100294A0,
      0,
      0);
    result = sub_10022DA0(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_100294A0,
               0);
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10230361: using guessed type char byte_10230361;

//----- (10029590) --------------------------------------------------------
char sub_10029590()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100A7648[v2];
      v4 = dword_100A7644[v2];
      v5 = dword_100A7640[v2];
      v6 = sub_1001E420(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A764C[v2]],
             (&off_100A7650)[v2 * 4]);
      v7 = sub_1001F580(1, dword_100A764C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A764C[v2]],
             (&off_100A7650)[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A7640: using guessed type int dword_100A7640[];
// 100A7644: using guessed type int dword_100A7644[];
// 100A7648: using guessed type int dword_100A7648[];
// 100A764C: using guessed type int dword_100A764C[];
// 100A7650: using guessed type char *off_100A7650;
// 10230361: using guessed type char byte_10230361;

//----- (100296F0) --------------------------------------------------------
char sub_100296F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100A7DDC[v2 / 2];
      v4 = word_100A7DDA[v2 / 2];
      v5 = word_100A7DD8[v2 / 2];
      v6 = sub_1001E420(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A7DE0[v2 / 4]],
             (&off_100A7DE4)[v2]);
      v7 = sub_1001F940(
             1,
             dword_100A7DE0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A7DE0[v2 / 4]],
             (&off_100A7DE4)[v2]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A7DD8: using guessed type __int16 word_100A7DD8[];
// 100A7DDA: using guessed type __int16 word_100A7DDA[];
// 100A7DDC: using guessed type __int16 word_100A7DDC[];
// 100A7DE0: using guessed type int dword_100A7DE0[];
// 100A7DE4: using guessed type char *off_100A7DE4;
// 10230361: using guessed type char byte_10230361;

//----- (10029850) --------------------------------------------------------
char sub_10029850()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100A83F0[v2];
      v4 = dword_100A83EC[v2];
      v5 = dword_100A83E8[v2];
      v6 = sub_1001E420(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A83F4[v2]],
             *(_DWORD *)&off_100A83F8[v2 * 4]);
      v7 = sub_1001FD40(1, dword_100A83F4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A83F4[v2]],
             *(_DWORD *)&off_100A83F8[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A83E8: using guessed type int dword_100A83E8[];
// 100A83EC: using guessed type int dword_100A83EC[];
// 100A83F0: using guessed type int dword_100A83F0[];
// 100A83F4: using guessed type int dword_100A83F4[];
// 10230361: using guessed type char byte_10230361;

//----- (100299B0) --------------------------------------------------------
char sub_100299B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100A8B94[v2];
      LODWORD(v3) = dword_100A8B90[v2];
      HIDWORD(v4) = dword_100A8B8C[v2];
      LODWORD(v4) = dword_100A8B88[v2];
      HIDWORD(v5) = dword_100A8B84[v2];
      LODWORD(v5) = dword_100A8B80[v2];
      v6 = sub_1001E420(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A8B98[v2]],
             *(_DWORD *)&off_100A8B9C[v2 * 4]);
      v7 = sub_10020100(1, dword_100A8B98[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A8B98[v2]],
             *(_DWORD *)&off_100A8B9C[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A8B80: using guessed type int dword_100A8B80[];
// 100A8B84: using guessed type int dword_100A8B84[];
// 100A8B88: using guessed type int dword_100A8B88[];
// 100A8B8C: using guessed type int dword_100A8B8C[];
// 100A8B90: using guessed type int dword_100A8B90[];
// 100A8B94: using guessed type int dword_100A8B94[];
// 100A8B98: using guessed type int dword_100A8B98[];
// 10230361: using guessed type char byte_10230361;

//----- (10029B20) --------------------------------------------------------
char sub_10029B20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100A97A2[v2 * 4];
      v4 = byte_100A97A1[v2 * 4];
      v5 = byte_100A97A0[v2 * 4];
      v6 = sub_1001E420(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A97A4[v2]],
             (&off_100A97A8)[v2 * 4]);
      v7 = sub_10020640(1, dword_100A97A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A97A4[v2]],
             (&off_100A97A8)[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A97A4: using guessed type int dword_100A97A4[];
// 100A97A8: using guessed type char *off_100A97A8;
// 10230361: using guessed type char byte_10230361;

//----- (10029C80) --------------------------------------------------------
char sub_10029C80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100A9C38[v2];
      v4 = dword_100A9C34[v2];
      v5 = dword_100A9C30[v2];
      v6 = sub_1001E420(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100A9C3C[v2]],
             (&off_100A9C40)[v2 * 4]);
      v7 = sub_10020A20(1, dword_100A9C3C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100A9C3C[v2]],
             (&off_100A9C40)[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100A9C30: using guessed type int dword_100A9C30[];
// 100A9C34: using guessed type int dword_100A9C34[];
// 100A9C38: using guessed type int dword_100A9C38[];
// 100A9C3C: using guessed type int dword_100A9C3C[];
// 100A9C40: using guessed type char *off_100A9C40;
// 10230361: using guessed type char byte_10230361;

//----- (10029DE0) --------------------------------------------------------
char sub_10029DE0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10034EA0(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1001E310(0);
  sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10034EA0(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10230361 )
  {
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_10022E50(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           (const char *)&unk_10064984,
           (const char *)&unk_10064984,
           0);
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_10022E50(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_10022E50(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           (const char *)&unk_10064984,
           0);
    sub_1001E780(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_10022E50(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1001E780(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10230361: using guessed type char byte_10230361;

//----- (10029FE0) --------------------------------------------------------
char sub_10029FE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100AA3D0[v2];
      v4 = dword_100AA3CC[v2];
      v5 = dword_100AA3C8[v2];
      v6 = sub_1001E420(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100AA3D4[v2]],
             *(_DWORD *)&off_100AA3D8[v2 * 4]);
      v7 = sub_10020DE0(1, dword_100AA3D4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100AA3D4[v2]],
             *(_DWORD *)&off_100AA3D8[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AA3C8: using guessed type int dword_100AA3C8[];
// 100AA3CC: using guessed type int dword_100AA3CC[];
// 100AA3D0: using guessed type int dword_100AA3D0[];
// 100AA3D4: using guessed type int dword_100AA3D4[];
// 10230361: using guessed type char byte_10230361;

//----- (1002A140) --------------------------------------------------------
char sub_1002A140()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100AA73C[v2 / 2];
      v4 = word_100AA73A[v2 / 2];
      v5 = word_100AA738[v2 / 2];
      v6 = sub_1001E420(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100AA740[v2 / 4]],
             (&off_100AA744)[v2]);
      v7 = sub_10021180(
             1,
             dword_100AA740[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100AA740[v2 / 4]],
             (&off_100AA744)[v2]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AA738: using guessed type __int16 word_100AA738[];
// 100AA73A: using guessed type __int16 word_100AA73A[];
// 100AA73C: using guessed type __int16 word_100AA73C[];
// 100AA740: using guessed type int dword_100AA740[];
// 100AA744: using guessed type char *off_100AA744;
// 10230361: using guessed type char byte_10230361;

//----- (1002A2A0) --------------------------------------------------------
char sub_1002A2A0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100AAA00[v2];
      v4 = dword_100AA9FC[v2];
      v5 = dword_100AA9F8[v2];
      v6 = sub_1001E420(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100AAA04[v2]],
             *(_DWORD *)&off_100AAA08[v2 * 4]);
      v7 = sub_10021580(1, dword_100AAA04[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100AAA04[v2]],
             *(_DWORD *)&off_100AAA08[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AA9F8: using guessed type int dword_100AA9F8[];
// 100AA9FC: using guessed type int dword_100AA9FC[];
// 100AAA00: using guessed type int dword_100AAA00[];
// 100AAA04: using guessed type int dword_100AAA04[];
// 10230361: using guessed type char byte_10230361;

//----- (1002A400) --------------------------------------------------------
char sub_1002A400()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100AAD7C[v2];
      LODWORD(v3) = dword_100AAD78[v2];
      HIDWORD(v4) = dword_100AAD74[v2];
      LODWORD(v4) = dword_100AAD70[v2];
      HIDWORD(v5) = dword_100AAD6C[v2];
      LODWORD(v5) = dword_100AAD68[v2];
      v6 = sub_1001E420(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100AAD80[v2]],
             (&off_100AAD84)[v2 * 4]);
      v7 = sub_10021920(1, dword_100AAD80[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100AAD80[v2]],
             (&off_100AAD84)[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AAD68: using guessed type int dword_100AAD68[];
// 100AAD6C: using guessed type int dword_100AAD6C[];
// 100AAD70: using guessed type int dword_100AAD70[];
// 100AAD74: using guessed type int dword_100AAD74[];
// 100AAD78: using guessed type int dword_100AAD78[];
// 100AAD7C: using guessed type int dword_100AAD7C[];
// 100AAD80: using guessed type int dword_100AAD80[];
// 100AAD84: using guessed type char *off_100AAD84;
// 10230361: using guessed type char byte_10230361;

//----- (1002A570) --------------------------------------------------------
char sub_1002A570()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100AB2EA[v2 * 4];
      v4 = byte_100AB2E9[v2 * 4];
      v5 = byte_100AB2E8[v2 * 4];
      v6 = sub_1001E420(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100AB2EC[v2]],
             (&off_100AB2F0)[v2 * 4]);
      v7 = sub_10021F00(1, dword_100AB2EC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100AB2EC[v2]],
             (&off_100AB2F0)[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AB2EC: using guessed type int dword_100AB2EC[];
// 100AB2F0: using guessed type char *off_100AB2F0;
// 10230361: using guessed type char byte_10230361;

//----- (1002A6D0) --------------------------------------------------------
char sub_1002A6D0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10230361 )
  {
    sub_10034EA0(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1001E310(0);
    sub_10034EA0(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10034EA0(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1001E400(0);
    v2 = 0;
    do
    {
      sub_1001E330((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100AB500[v2];
      v4 = dword_100AB4FC[v2];
      v5 = dword_100AB4F8[v2];
      v6 = sub_1001E420(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_10095520[4 * dword_100AB504[v2]],
             *(_DWORD *)&off_100AB508[v2 * 4]);
      v7 = sub_100222F0(1, dword_100AB504[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1001E420(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_10095520[4 * dword_100AB504[v2]],
             *(_DWORD *)&off_100AB508[v2 * 4]);
      result = sub_1001E780(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10034EA0(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100AB4F8: using guessed type int dword_100AB4F8[];
// 100AB4FC: using guessed type int dword_100AB4FC[];
// 100AB500: using guessed type int dword_100AB500[];
// 100AB504: using guessed type int dword_100AB504[];
// 10230361: using guessed type char byte_10230361;

//----- (1002A830) --------------------------------------------------------
char **sub_1002A830()
{
  return off_10096C0C;
}
// 10096C0C: using guessed type char *off_10096C0C[3];

//----- (1002A840) --------------------------------------------------------
char __cdecl sub_1002A840(void *a1)
{
  return sub_1002BAB0(18, a1);
}

//----- (1002A850) --------------------------------------------------------
char __cdecl sub_1002A850(void *a1)
{
  return sub_1002BAB0(19, a1);
}

//----- (1002A860) --------------------------------------------------------
BOOL sub_1002A860()
{
  return sub_1002E640(9) || sub_1002E640(10);
}

//----- (1002A890) --------------------------------------------------------
int __usercall sub_1002A890@<eax>(char a1@<al>, int a2@<ecx>)
{
  int v2; // esi@3
  int result; // eax@3

  if ( a1 && a1 != 2 )
  {
    v2 = a2 - sub_1003FB70(a1);
    result = v2 + sub_1003FB70(0);
  }
  else
  {
    result = a2;
  }
  return result;
}

//----- (1002A8C0) --------------------------------------------------------
char __cdecl sub_1002A8C0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1002BAB0(21, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39.190575
     || *(float *)a1 < -39.190575) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (1002A920) --------------------------------------------------------
char __cdecl sub_1002A920(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_1002BAB0(22, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39.190575
     || *(float *)a1 < -39.190575) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (1002A980) --------------------------------------------------------
char __thiscall sub_1002A980(void *this)
{
  char v1; // al@1
  char result; // al@2
  char v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@2

  v1 = sub_1002E8C0(this);
  v3 = sub_1002EC00(v1, 1);
  if ( (unsigned __int8)sub_1002A860() )
  {
    result = sub_1002BA30(28, v3, &v4);
    if ( result != 1 || !(v4 & 0x800) )
      result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002A9E0) --------------------------------------------------------
char __thiscall sub_1002A9E0(void *this)
{
  char v1; // al@1
  char v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@2
  int v5; // [sp+8h] [bp-4h]@5

  v1 = sub_1002E8C0(this);
  v3 = sub_1002EC00(v1, 1);
  if ( (unsigned __int8)sub_1002A860() )
  {
    if ( sub_1002BA30(28, v3, &v4) != 1 || v4 & 0x2000 )
      return 0;
  }
  else if ( sub_10039DA0(&v5) != 1 || !(v5 & 0x10000) )
  {
    return 0;
  }
  return 1;
}

//----- (1002AA50) --------------------------------------------------------
char __cdecl sub_1002AA50(char a1, char a2, int *a3)
{
  char v3; // bl@1
  void *v4; // ecx@1
  void *v5; // ecx@2
  char result; // al@4
  int v7; // esi@9
  void *v8; // ecx@12
  int v9; // esi@14
  char v10; // [sp+8h] [bp-14h]@1
  char v11; // [sp+9h] [bp-13h]@1
  char v12; // [sp+Ah] [bp-12h]@1
  char v13; // [sp+Bh] [bp-11h]@1
  int v14; // [sp+Ch] [bp-10h]@1
  int v15; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1

  v3 = sub_1002BA30(16, a2, &v14);
  v12 = sub_1002BA30(17, a2, &v16);
  v10 = sub_10040330();
  v11 = sub_1002BA30(51, a2, &v15);
  v13 = sub_1002BA30(52, a2, &v17);
  switch ( a1 )
  {
    case 0:
    case 2:
    case 3:
      if ( sub_1002A9E0(v4) )
      {
        if ( !v3 )
          return 0;
        v7 = v14;
        if ( v10 == 1 )
          v7 -= sub_1003FB70(0);
        *a3 = sub_1002A890(a1, v7);
        result = 1;
      }
      else if ( v3 )
      {
        *a3 = sub_1002A890(a1, v14);
        result = 1;
      }
      else
      {
        if ( !v11 || !sub_1002A980(v5) )
          return 0;
        *a3 = sub_1002A890(a1, v15);
        result = 1;
      }
      return result;
    case 1:
      if ( sub_1002A9E0(v4) )
      {
        if ( !v3 )
          return 0;
        v9 = v14;
        if ( v10 == 1 )
          goto LABEL_15;
        *a3 = sub_1003FB70(0) + v9;
        result = 1;
      }
      else
      {
        if ( v12 )
        {
          v9 = v16;
LABEL_15:
          *a3 = v9;
          return 1;
        }
        if ( !v13 || !sub_1002A980(v8) )
          return 0;
        *a3 = v17;
        result = 1;
      }
      return result;
    default:
      sub_100129A0("..\\lib\\acl\\iop\\iop_ahrs_data_intf.c", 1859, 1, 0);
      return 0;
  }
}

//----- (1002AC00) --------------------------------------------------------
char __cdecl sub_1002AC00(char a1, int *a2, char a3)
{
  char result; // al@3
  char v4; // bl@4
  int v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  if ( a3 != 2 && sub_1002E640(a3 + 9) )
  {
    result = sub_1002AA50(a1, a3, a2);
  }
  else
  {
    v4 = sub_1002BA30(16, a3, &v5);
    if ( v4 )
      *a2 = sub_1002A890(a1, v5);
    result = v4;
  }
  return result;
}

//----- (1002AC70) --------------------------------------------------------
char __cdecl sub_1002AC70(char a1, int *a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  char v4; // al@1

  v3 = sub_1002E8C0(v2);
  v4 = sub_1002EC00(v3, 1);
  return sub_1002AC00(a1, a2, v4);
}

//----- (1002ACA0) --------------------------------------------------------
int __cdecl sub_1002ACA0(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_102ACCF0)();
  *a1 = result;
  return result;
}
// 102ACCF0: using guessed type int dword_102ACCF0;

//----- (1002ACC0) --------------------------------------------------------
char __cdecl sub_1002ACC0(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_10032330(a1, &v5, &v4) && sub_10012DA0(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_1003E0E0(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 1002ACC0: using guessed type char var_408[1028];

//----- (1002AD60) --------------------------------------------------------
char __cdecl sub_1002AD60(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003A190(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_10039F90(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1003A010(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1003A090(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_1003A110(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (1002AE70) --------------------------------------------------------
int __cdecl sub_1002AE70(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001CD60(&a1, 1u, (int)&unk_100AFDD8, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100AFDDC[2 * v1];
  }
  return result;
}
// 100AFDDC: using guessed type int dword_100AFDDC[];

//----- (1002AEC0) --------------------------------------------------------
BOOL __cdecl sub_1002AEC0(char a1, int a2)
{
  double v2; // st7@2
  unsigned __int8 v4; // [sp+8h] [bp-Ch]@1
  __int16 v5; // [sp+Ch] [bp-8h]@2

  if ( sub_1003A230(a1, &v4) )
  {
    v2 = (double)v5;
    *(_BYTE *)a2 = (v4 >> 3) & 1;
    *(float *)(a2 + 4) = v2 * 0.0001395089348079637;
  }
  else
  {
    *(_BYTE *)a2 = 1;
  }
  return *(_BYTE *)a2 == 0;
}

//----- (1002AF30) --------------------------------------------------------
char __thiscall sub_1002AF30(void *this)
{
  char v1; // bl@1
  char result; // al@3

  v1 = sub_1001A6D0((int)this);
  if ( !sub_1002B830() || v1 )
    result = v1;
  else
    result = *(_BYTE *)(dword_102AD56C + 141);
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (1002AF60) --------------------------------------------------------
int __cdecl sub_1002AF60(char a1, int a2, int *a3)
{
  char v3; // bl@1
  void *v4; // ecx@1
  int result; // eax@1
  bool v6; // cl@1
  double v7; // st7@4
  int v8; // ecx@6
  int v9; // ecx@6
  int v10; // [sp+14h] [bp-18h]@1
  __int16 v11; // [sp+1Eh] [bp-Eh]@6

  v3 = sub_1003A290(a1 + 3, &v10);
  result = sub_1001A710(v4);
  v6 = (v10 & 0x200) == 512;
  *(_BYTE *)(a2 + 1) = (v10 & 0x100) == 256;
  *(_BYTE *)(a2 + 3) = v6;
  if ( !v3 )
    *(_BYTE *)(a2 + 1) = 1;
  if ( *(_BYTE *)(a2 + 1) )
  {
    v7 = 0.0;
    *(_DWORD *)(a2 + 8) = 0;
LABEL_11:
    *(float *)(a2 + 4) = v7;
    *(_BYTE *)(a2 + 2) = 2;
    *a3 = 0;
    return result;
  }
  if ( !v6 )
  {
    result = v11 << 16;
    v7 = (double)((signed int)v11 << 16) * 0.000000001201706512077294;
    goto LABEL_11;
  }
  v8 = (v11 - 0x8000) << 16;
  *(_DWORD *)(a2 + 8) = v8;
  v9 = v8 - result;
  result = v9 ^ 2 * v9;
  if ( (v9 ^ 2 * v9) >= 0 )
  {
    *(_BYTE *)(a2 + 2) = 0;
  }
  else
  {
    *(_BYTE *)(a2 + 2) = 1;
    v9 = -v9;
  }
  *(float *)(a2 + 4) = (double)(2 * v9) * 0.000000004190951585769653;
  *a3 = v9;
  return result;
}

//----- (1002B060) --------------------------------------------------------
int __cdecl sub_1002B060(char a1, int a2)
{
  int v2; // ecx@0
  int result; // eax@4
  int v4; // [sp+0h] [bp-4h]@1

  v4 = v2;
  if ( sub_1002B830() && (a1 == 1 || a1 == 2) )
  {
    sub_1002AF60(a1 - 1, a2, &v4);
    result = dword_102AD56C;
    *(_BYTE *)(a2 + 2) = *(_BYTE *)(dword_102AD56C + 1229);
    *(_BYTE *)a2 = 1;
  }
  else
  {
    result = a2;
    *(float *)(a2 + 4) = 0.0;
    *(_BYTE *)(a2 + 1) = 1;
    *(_BYTE *)(a2 + 2) = 2;
    *(_BYTE *)(a2 + 3) = 1;
    *(_DWORD *)(a2 + 8) = 0;
    *(_BYTE *)a2 = 0;
  }
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (1002B0D0) --------------------------------------------------------
int __cdecl sub_1002B0D0(int a1)
{
  void *v1; // ecx@0
  char v2; // al@1

  v2 = sub_1002AF30(v1);
  return sub_1002B060(v2, a1);
}

//----- (1002B0F0) --------------------------------------------------------
int __cdecl sub_1002B0F0(signed int a1, char a2)
{
  int result; // eax@3
  int v3; // [sp+0h] [bp-4h]@1

  v3 = 0;
  switch ( (unsigned __int8)a1 )
  {
    case 0u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_1003E0A0(10018, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_1003E0A0(10022, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 1u:
      if ( a2 == 1 )
      {
        a1 = 136975;
        sub_1003E0A0(10019, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 118000;
        sub_1003E0A0(10023, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 3u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_1003E0A0(10020, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_1003E0A0(10024, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 4u:
      if ( a2 == 1 )
      {
        a1 = 117950;
        sub_1003E0A0(10021, &v3, 4, &a1);
        result = v3;
      }
      else
      {
        a1 = 108000;
        sub_1003E0A0(10025, &v3, 4, &a1);
        result = v3;
      }
      break;
    case 2u:
      result = sub_1003A320(a2);
      v3 = result;
      break;
    default:
      sub_100129A0("..\\lib\\adl\\iop_freq_intf.c", 180, 1, 0);
      result = v3;
      break;
  }
  return result;
}

//----- (1002B2B0) --------------------------------------------------------
char __cdecl sub_1002B2B0(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_100129A0("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100C2D68[8 * a1];
  *a4 = word_100C2D6A[a2 + 4 * a1];
  return 1;
}
// 100C2D6A: using guessed type __int16 word_100C2D6A[];

//----- (1002B310) --------------------------------------------------------
char __cdecl sub_1002B310(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x145u )
  {
    sub_100129A0("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 320, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_100C4630[16 * a1];
  *a4 = word_100C4638[a2 + 8 * a1];
  return 1;
}
// 100C4638: using guessed type __int16 word_100C4638[];

//----- (1002B380) --------------------------------------------------------
signed int sub_1002B380()
{
  return 1000;
}

//----- (1002B3A0) --------------------------------------------------------
int sub_1002B3A0()
{
  return sub_100322F0((int)off_100B03B0);
}
// 100B03B0: using guessed type int (*off_100B03B0[4])();

//----- (1002B3B0) --------------------------------------------------------
BOOL __cdecl sub_1002B3B0(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_1003DC90();
  for ( i = sub_1003EEE0(6, 0, 1, (int)&v4); i == 12; i = sub_1003EEE0(6, 0, 1, (int)&v4) )
  {
    if ( sub_1003DC90() - v1 >= a1 )
      break;
    sub_1003DE80(100);
  }
  return i == 12;
}

//----- (1002B420) --------------------------------------------------------
char __thiscall sub_1002B420(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1003DB80(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1002B440) --------------------------------------------------------
void __cdecl sub_1002B440(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_1003DB80(120, a1);
  sub_1003DB80(124, a2);
  sub_1003DB80(121, a3);
}

//----- (1002B470) --------------------------------------------------------
int __cdecl sub_1002B470(int a1)
{
  return sub_1003E040(3025, a1, 84);
}

//----- (1002B490) --------------------------------------------------------
signed int sub_1002B490()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_1003EF20(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (1002B4C0) --------------------------------------------------------
void __cdecl sub_1002B4C0(_BYTE *a1)
{
  sub_1003DB80(129, a1);
}

//----- (1002B4E0) --------------------------------------------------------
char __cdecl sub_1002B4E0(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_1003EEE0(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002B520) --------------------------------------------------------
int __cdecl sub_1002B520(int a1)
{
  return sub_1003E110(3025, a1, 84);
}

//----- (1002B540) --------------------------------------------------------
char __fastcall sub_1002B540(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_102AD554 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_1002B4E0(147, 0xCu, &v38);
  sub_1002B4E0(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_1003E0A0(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_1001D480(a1);
  if ( !result || result == 3 )
    result = sub_10016130(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_1003E110(2000, (int)&v20, 29);
  }
  return result;
}
// 102AD554: using guessed type char byte_102AD554;

//----- (1002B760) --------------------------------------------------------
char sub_1002B760()
{
  int *v0; // ecx@1

  sub_1002B3B0(0x9C40u);
  sub_10011A30(&off_100B08E8);
  return sub_1002B540(v0);
}
// 100B08E8: using guessed type int (__cdecl *off_100B08E8)(int, size_t, void *);

//----- (1002B780) --------------------------------------------------------
void sub_1002B780()
{
  dword_10230368 = -15;
}
// 10230368: using guessed type int dword_10230368;

//----- (1002B7A0) --------------------------------------------------------
signed int sub_1002B7A0()
{
  return sub_1003ED70((int)&off_100B0960);
}
// 100B0960: using guessed type char *off_100B0960;

//----- (1002B7B0) --------------------------------------------------------
int sub_1002B7B0()
{
  return (unsigned __int8)sub_1002B7A0() != 0 ? dword_10230368 : 0;
}
// 10230368: using guessed type int dword_10230368;

//----- (1002B7C0) --------------------------------------------------------
int sub_1002B7C0()
{
  int result; // eax@2

  if ( (unsigned __int8)sub_1002B7A0() )
    result = dword_10230368 + 55656;
  else
    result = 0;
  return result;
}
// 10230368: using guessed type int dword_10230368;

//----- (1002B7E0) --------------------------------------------------------
void sub_1002B7E0()
{
  dword_102AD570 = -15;
}
// 102AD570: using guessed type int dword_102AD570;

//----- (1002B7F0) --------------------------------------------------------
signed int sub_1002B7F0()
{
  return sub_1003ED70((int)&off_100B098C);
}
// 100B098C: using guessed type char *off_100B098C;

//----- (1002B800) --------------------------------------------------------
int sub_1002B800()
{
  int result; // eax@1

  result = 0;
  dword_1023036C = -15;
  dword_102AD56C = 0;
  dword_102AD560 = 0;
  dword_102AD564 = 0;
  dword_102AD568 = 0;
  return result;
}
// 1023036C: using guessed type int dword_1023036C;
// 102AD560: using guessed type int dword_102AD560;
// 102AD564: using guessed type int dword_102AD564;
// 102AD568: using guessed type int dword_102AD568;
// 102AD56C: using guessed type int dword_102AD56C;

//----- (1002B830) --------------------------------------------------------
char sub_1002B830()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_1003ED70((int)&off_100B09B8);
  if ( v0 )
  {
    dword_102AD56C = dword_1023036C;
    v1 = *(_BYTE *)(dword_1023036C + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_102AD56C + 36) < (unsigned int)sub_1003DC90() )
      v0 = 0;
    dword_102AD568 = dword_1023036C + 56116;
    result = v0;
    dword_102AD560 = dword_1023036C + 1516;
    dword_102AD564 = dword_1023036C + 20484;
  }
  else
  {
    dword_102AD56C = 0;
    dword_102AD560 = 0;
    dword_102AD564 = 0;
    dword_102AD568 = 0;
    result = 0;
  }
  return result;
}
// 100B09B8: using guessed type char *off_100B09B8;
// 1023036C: using guessed type int dword_1023036C;
// 102AD560: using guessed type int dword_102AD560;
// 102AD564: using guessed type int dword_102AD564;
// 102AD568: using guessed type int dword_102AD568;
// 102AD56C: using guessed type int dword_102AD56C;

//----- (1002B8D0) --------------------------------------------------------
void sub_1002B8D0()
{
  dword_102AD558 = -15;
}
// 102AD558: using guessed type int dword_102AD558;

//----- (1002B8E0) --------------------------------------------------------
char __cdecl sub_1002B8E0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_1002E8C0(v1);
  v3 = sub_1002EB20(v2);
  if ( sub_1003E040(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 1002B8E0: using guessed type char var_48[68];

//----- (1002B940) --------------------------------------------------------
signed int sub_1002B940()
{
  return sub_1003ED70((int)&off_100B09EC);
}
// 100B09EC: using guessed type char *off_100B09EC;

//----- (1002B950) --------------------------------------------------------
char __usercall sub_1002B950@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_1002B940()
    || sub_1003DDA0(33, 10) )
  {
    sub_100129A0("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_1003DC90()
                         - *(_DWORD *)(dword_102AD558 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_102AD558 + 37) )
  {
    memcpy(
      a3,
      (const void *)(dword_102AD558 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_102AD558 + 2 * v3 + 62));
    sub_1003DD40(33);
    result = 1;
  }
  else
  {
    sub_1003DD40(33);
    result = 0;
  }
  return result;
}
// 102AD558: using guessed type int dword_102AD558;

//----- (1002BA30) --------------------------------------------------------
char __cdecl sub_1002BA30(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_1002B950(a1, a2, a3);
    }
    else
    {
      v4 = sub_1003A4A0(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_10012A10(*(_BYTE *)v5)) )
      {
        result = sub_100136E0(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 1003A4A0: using guessed type _DWORD __cdecl sub_1003A4A0(char);

//----- (1002BAB0) --------------------------------------------------------
char __cdecl sub_1002BAB0(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_1002B8E0(a1);
  return sub_1002BA30(a1, v2, a2);
}

//----- (1002BAD0) --------------------------------------------------------
signed int __cdecl sub_1002BAD0(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 < 0x17u )
      result = *(_DWORD *)(a1 + 36);
  }
  return result;
}

//----- (1002BAF0) --------------------------------------------------------
double __cdecl sub_1002BAF0(signed int a1, char a2)
{
  return (double)(a1 >> (31 - a2)) / (double)(1 << a2) * 3.1415926535898;
}

//----- (1002BB30) --------------------------------------------------------
bool __cdecl sub_1002BB30(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_102ACD08[v2 / 4] && word_102ACD04[v2 / 2] && dword_102ACD00[v2 / 4] )
      result = 1;
  }
  return result;
}
// 102ACD00: using guessed type int dword_102ACD00[];
// 102ACD04: using guessed type __int16 word_102ACD04[];
// 102ACD08: using guessed type int dword_102ACD08[];

//----- (1002BB70) --------------------------------------------------------
int __cdecl sub_1002BB70(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_1002BB30(0, a1) )
    result = dword_102ACD08[3 * v1];
  else
    result = 0;
  return result;
}
// 102ACD08: using guessed type int dword_102ACD08[];

//----- (1002BBA0) --------------------------------------------------------
_BYTE *__cdecl sub_1002BBA0(_BYTE *a1)
{
  _BYTE *result; // eax@1

  result = a1;
  *a1 = 0;
  if ( !byte_102AD554 )
    result = (_BYTE *)(*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_102ACCE0)(146, 1, a1);
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD554: using guessed type char byte_102AD554;

//----- (1002BBD0) --------------------------------------------------------
char __cdecl sub_1002BBD0(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_102AD554 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_102ACCE0)(dword_102AD024, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD024: using guessed type int dword_102AD024;
// 102AD554: using guessed type char byte_102AD554;

//----- (1002BC20) --------------------------------------------------------
char __cdecl sub_1002BC20(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_102AD554 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_102ACCE0)(dword_102AD024, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102AD024: using guessed type int dword_102AD024;
// 102AD554: using guessed type char byte_102AD554;

//----- (1002BC70) --------------------------------------------------------
unsigned int sub_1002BC70()
{
  unsigned int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_102ACD00, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_102ACCD0)(512, &v6);
  v1 = 0;
  do
  {
    word_102ACD04[v1 / 2] = 0;
    dword_102ACD08[v1 / 4] = 0;
    dword_102ACD00[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_102ACD0C = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_102ACD10 = v7;
    dword_102ACD14 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_102ACD18;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_102ACCD0)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_102ACD10;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 102ACCD0: using guessed type int dword_102ACCD0;
// 102ACD00: using guessed type int dword_102ACD00[];
// 102ACD04: using guessed type __int16 word_102ACD04[];
// 102ACD08: using guessed type int dword_102ACD08[];
// 102ACD0C: using guessed type int dword_102ACD0C;
// 102ACD10: using guessed type int dword_102ACD10;
// 102ACD14: using guessed type int dword_102ACD14;
// 102ACD18: using guessed type int dword_102ACD18;

//----- (1002BD40) --------------------------------------------------------
__int16 sub_1002BD40()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_102ACD1C;
  v1 = dword_102ACD20;
  v2 = 1;
  v3 = dword_102ACD18;
  if ( (unsigned int)dword_102ACD20 >= 1 )
  {
    v4 = (unsigned __int16)word_102ACD1C;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_102ACCE0)(v3, 2, &v5);
      result = v5;
      word_102AD420[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102ACD18: using guessed type int dword_102ACD18;
// 102ACD1C: using guessed type __int16 word_102ACD1C;
// 102ACD20: using guessed type int dword_102ACD20;
// 102AD420: using guessed type __int16 word_102AD420[];

//----- (1002BDA0) --------------------------------------------------------
int __usercall sub_1002BDA0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (1002BE20) --------------------------------------------------------
char sub_1002BE20()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_102AD554 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_102ACCE0)(147, 12, &v17);
  byte_102AD554 = 1;
  dword_10230370 = 0;
  dword_10230374 = 0;
  dword_10230378 = 0;
  dword_1023037C = 0;
  byte_10230380 = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_102ACD00, 0, 0x708u);
  sub_1002BDA0((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_102ACD00, 0, 0x708u);
  }
  byte_102AD554 = 0;
  sub_1002BBA0(&v16);
  if ( v16 != 101 )
  {
    byte_102AD554 = 2;
    return (unsigned int)memset(dword_102ACD00, 0, 0x708u);
  }
  if ( byte_102AD554 )
    return (unsigned int)memset(dword_102ACD00, 0, 0x708u);
  sub_1002BC20(&unk_102AD408, &byte_102AD54D);
  byte_102AD54C = byte_102AD54D - 1;
  if ( byte_102AD554 )
    return (unsigned int)memset(dword_102ACD00, 0, 0x708u);
  result = sub_1002BBD0(&unk_102AD409, &unk_102AD40A);
  byte_102ACCF4 = 0;
  if ( byte_102AD554 )
    return (unsigned int)memset(dword_102ACD00, 0, 0x708u);
  return result;
}
// 10230370: using guessed type int dword_10230370;
// 10230374: using guessed type int dword_10230374;
// 10230378: using guessed type int dword_10230378;
// 1023037C: using guessed type int dword_1023037C;
// 10230380: using guessed type char byte_10230380;
// 102ACCE0: using guessed type int dword_102ACCE0;
// 102ACCF4: using guessed type char byte_102ACCF4;
// 102ACD00: using guessed type int dword_102ACD00[];
// 102AD54C: using guessed type char byte_102AD54C;
// 102AD54D: using guessed type char byte_102AD54D;
// 102AD554: using guessed type char byte_102AD554;

//----- (1002BFE0) --------------------------------------------------------
int (__cdecl *(*sub_1002BFE0())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_102ACCD0 = (int)off_100C5EB8;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_102ACCE0)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_1002BDA0((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_100B0AE0)[8 * v1];
      v3 = strlen((&off_100B0AE0)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_100B0AE4)[v1];
        dword_102ACCD0 = (int)(&off_100B0AE4)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 100B0AE0: using guessed type char *off_100B0AE0;
// 100B0AE4: using guessed type int (__cdecl *(*off_100B0AE4)[2])(int, int);
// 100C5EB8: using guessed type int (__cdecl *off_100C5EB8[2])(int, int);
// 102ACCD0: using guessed type int dword_102ACCD0;
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (1002C110) --------------------------------------------------------
void __cdecl sub_1002C110(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        sub_10041BF0(v9);
        *(double *)(a1 + 8) = v9;
        return;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
}

//----- (1002C210) --------------------------------------------------------
signed int __cdecl sub_1002C210(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1002C2C0) --------------------------------------------------------
bool sub_1002C2C0()
{
  return sub_1003DD40(99) == 0;
}

//----- (1002C2D0) --------------------------------------------------------
bool sub_1002C2D0()
{
  return sub_1003DDA0(99, 10000) == 0;
}

//----- (1002C2F0) --------------------------------------------------------
int __cdecl sub_1002C2F0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 0xDu, 0xDu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C320) --------------------------------------------------------
int __cdecl sub_1002C320(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 9u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C350) --------------------------------------------------------
int __cdecl sub_1002C350(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 8u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C380) --------------------------------------------------------
int __cdecl sub_1002C380(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 0x14u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C3B0) --------------------------------------------------------
signed int __cdecl sub_1002C3B0(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001AAF0(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1002C3E0) --------------------------------------------------------
int __cdecl sub_1002C3E0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 6u, 6u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C410) --------------------------------------------------------
int __cdecl sub_1002C410(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 7u, 7u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C440) --------------------------------------------------------
int __cdecl sub_1002C440(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 0xFu, 0xFu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C470) --------------------------------------------------------
int __cdecl sub_1002C470(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 8u, 8u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C4A0) --------------------------------------------------------
int __cdecl sub_1002C4A0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 0xEu, 0xEu, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C4D0) --------------------------------------------------------
int __cdecl sub_1002C4D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 0xBu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C500) --------------------------------------------------------
int __cdecl sub_1002C500(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 0x13u, 0x13u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C530) --------------------------------------------------------
int __cdecl sub_1002C530(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 2u, 2u, 0);
}

//----- (1002C550) --------------------------------------------------------
int __cdecl sub_1002C550(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 2u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C580) --------------------------------------------------------
int __cdecl sub_1002C580(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 3u, 3u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C5B0) --------------------------------------------------------
unsigned int __cdecl sub_1002C5B0(char *a1)
{
  return sub_1001A8E0(a1, -100, 100, 0, 0);
}

//----- (1002C5D0) --------------------------------------------------------
int __cdecl sub_1002C5D0(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 2u, 0, 0);
}

//----- (1002C5F0) --------------------------------------------------------
int __cdecl sub_1002C5F0(_BYTE *a1)
{
  return sub_1001ABE0(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (1002C610) --------------------------------------------------------
int __cdecl sub_1002C610(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 1u, 1u, 0);
}

//----- (1002C630) --------------------------------------------------------
int __cdecl sub_1002C630(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AB40(a1, 0, 0x31Cu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C660) --------------------------------------------------------
int __cdecl sub_1002C660(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AB40(a1, 0, 0x147u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C690) --------------------------------------------------------
int __cdecl sub_1002C690(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 3u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002C6C0) --------------------------------------------------------
unsigned int __cdecl sub_1002C6C0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1001A7A0((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1001AAF0((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_1001A7A0((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001AAF0((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001AAF0((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1002C9F0) --------------------------------------------------------
unsigned int __cdecl sub_1002C9F0(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_1001A7A0((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A8E0((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1002CE30) --------------------------------------------------------
unsigned int __cdecl sub_1002CE30(_BYTE *a1)
{
  return sub_1001A9D0(a1, -1, 5, -1, 0);
}

//----- (1002CE50) --------------------------------------------------------
int __cdecl sub_1002CE50(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 5u, 0, 0);
}

//----- (1002CE70) --------------------------------------------------------
int __cdecl sub_1002CE70(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 4u, 2u, 0);
}

//----- (1002CE90) --------------------------------------------------------
int __cdecl sub_1002CE90(_BYTE *a1)
{
  return sub_1001ABE0(a1, 0, 2u, 0, 0);
}

//----- (1002CEB0) --------------------------------------------------------
int __cdecl sub_1002CEB0(int a1)
{
  return sub_1001A7F0(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (1002CF00) --------------------------------------------------------
int __cdecl sub_1002CF00(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_1002CEB0((int)(a1 + 4));
  if ( !result )
    result = sub_1002CE70(a1);
  return result;
}

//----- (1002CF20) --------------------------------------------------------
int __cdecl sub_1002CF20(int a1)
{
  int result; // eax@1

  result = sub_1002CE50((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_1002CE50((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_1002CE50((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_1003A6E0((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_1001A7A0((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_1001A7A0((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_1001A7A0((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_1001A7A0((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (1002CFB0) --------------------------------------------------------
unsigned int __cdecl sub_1002CFB0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1002CE30((_BYTE *)a1);
  if ( !result )
    result = sub_1002CE30((_BYTE *)(a1 + 4));
  return result;
}

//----- (1002CFD0) --------------------------------------------------------
signed int __cdecl sub_1002CFD0(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_1001A7A0((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_1001A7A0((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (1002D020) --------------------------------------------------------
unsigned int __cdecl sub_1002D020(int a1)
{
  unsigned int result; // eax@1

  result = sub_1002CE30((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1002CE30((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_1002CE30((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_1002CE30((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_1001A7A0((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (1002D080) --------------------------------------------------------
int __cdecl sub_1002D080(_BYTE *a1)
{
  return sub_1001ABE0(a1, 0, 0x20u, 2u, 0);
}

//----- (1002D0A0) --------------------------------------------------------
unsigned int __cdecl sub_1002D0A0(_BYTE *a1)
{
  return sub_1001A9D0(a1, -1, 4, -1, 0);
}

//----- (1002D0C0) --------------------------------------------------------
int __cdecl sub_1002D0C0(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 9u, 0, 0);
}

//----- (1002D0E0) --------------------------------------------------------
int __cdecl sub_1002D0E0(_BYTE *a1)
{
  return sub_1001ABE0(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (1002D100) --------------------------------------------------------
signed int __cdecl sub_1002D100(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001ABE0(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1002D130) --------------------------------------------------------
int __cdecl sub_1002D130(_BYTE *a1)
{
  return sub_1001AB40(a1, 0, 0xFFFu, 640, 0);
}

//----- (1002D150) --------------------------------------------------------
int __cdecl sub_1002D150(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AB40(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002D190) --------------------------------------------------------
signed int __cdecl sub_1002D190(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001AB40(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1002D1C0) --------------------------------------------------------
int __cdecl sub_1002D1C0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_1002D100((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_1002D150((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002D150((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003AA20((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002D150((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1002D250) --------------------------------------------------------
int __cdecl sub_1002D250(int a1)
{
  int result; // eax@1

  result = sub_1001AAF0((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_1001AAF0((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (1002D280) --------------------------------------------------------
int __cdecl sub_1002D280(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 3u, 1u, 0);
}

//----- (1002D2A0) --------------------------------------------------------
unsigned int __cdecl sub_1002D2A0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1001A9D0((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_1001A9D0((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (1002D2D0) --------------------------------------------------------
int __cdecl sub_1002D2D0(int a1)
{
  int result; // eax@1

  result = sub_1001A7F0(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_1001A7F0(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_1001A7F0(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_1001A7F0(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_1001A7F0(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (1002D3C0) --------------------------------------------------------
int __cdecl sub_1002D3C0(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1001A7A0((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_1001AAF0((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_1002D2A0(a1 + 36);
        if ( !result )
        {
          result = sub_1001A7F0(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_1002D2D0(a1 + 8);
            if ( !result )
            {
              result = sub_1002D2A0(a1 + 28);
              if ( !result )
              {
                result = sub_1001AB40((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_1002C5D0((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_1002D250(a1 + 57);
                    if ( !result )
                    {
                      result = sub_1001A7A0((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_1002D280((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (1002D4D0) --------------------------------------------------------
int __cdecl sub_1002D4D0(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_10032720(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (1002D500) --------------------------------------------------------
signed int __cdecl sub_1002D500(int a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@9

  v2 = 0;
  if ( sub_1002C3B0((unsigned __int8 *)(a1 + 15), a2) == 1 )
    v2 = 1;
  if ( sub_1002C3B0((unsigned __int8 *)(a1 + 34), a2) == 1 )
    v2 = 1;
  if ( sub_1002C3B0((unsigned __int8 *)(a1 + 38), a2) == 1 )
    v2 = 1;
  if ( sub_1002C3B0((unsigned __int8 *)(a1 + 36), a2) == 1 )
    v2 = 1;
  result = sub_1001A7A0((_BYTE *)(a1 + 33), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C470((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C2F0((unsigned __int8 *)(a1 + 48), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C350((unsigned __int8 *)(a1 + 46), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C2F0((unsigned __int8 *)(a1 + 47), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C380((unsigned __int8 *)(a1 + 45), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C320((unsigned __int8 *)(a1 + 44), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C2F0((unsigned __int8 *)(a1 + 28), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C690((unsigned __int8 *)(a1 + 51), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C4D0((unsigned __int8 *)(a1 + 31), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_1003A7F0((_BYTE *)(a1 + 20), a2) == 1 )
    v2 = 1;
  result = sub_1002DB80((unsigned __int8 *)(a1 + 50), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C2F0((unsigned __int8 *)(a1 + 24), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C3E0((unsigned __int8 *)(a1 + 5), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C2F0((unsigned __int8 *)(a1 + 25), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C410((unsigned __int8 *)(a1 + 6), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C2F0((unsigned __int8 *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C440((unsigned __int8 *)(a1 + 3), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7F0(a1 + 40, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C2F0((unsigned __int8 *)(a1 + 26), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C470((unsigned __int8 *)(a1 + 9), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C2F0((unsigned __int8 *)(a1 + 8), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C4A0((unsigned __int8 *)(a1 + 7), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C4D0((unsigned __int8 *)(a1 + 1), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C580((unsigned __int8 *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C580((unsigned __int8 *)(a1 + 10), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 37), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C500((unsigned __int8 *)(a1 + 11), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C2F0((unsigned __int8 *)(a1 + 12), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0((_BYTE *)(a1 + 32), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002DB80((unsigned __int8 *)(a1 + 49), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7F0(a1 + 16, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002C580((unsigned __int8 *)(a1 + 35), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1002DA10) --------------------------------------------------------
int __cdecl sub_1002DA10(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1001ABE0(a1, 0, 0x3FFFFu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002DA40) --------------------------------------------------------
signed int __cdecl sub_1002DA40(_BYTE *a1, int a2)
{
  signed int v2; // ebx@1
  signed int result; // eax@1

  v2 = 0;
  result = sub_1001A7A0(a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7F0((int)(a1 + 4), -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1002DAB0) --------------------------------------------------------
int __cdecl sub_1002DAB0(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 0x64u, 0x64u, 0);
}

//----- (1002DB10) --------------------------------------------------------
int __cdecl sub_1002DB10(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_1001A7A0((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_1002DAB0((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (1002DB20) --------------------------------------------------------
int __cdecl sub_1002DB20(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 3u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002DB50) --------------------------------------------------------
int __cdecl sub_1002DB50(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 6u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002DB80) --------------------------------------------------------
int __cdecl sub_1002DB80(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 5u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1002DBB0) --------------------------------------------------------
signed int __cdecl sub_1002DBB0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001ABE0(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1002DBE0) --------------------------------------------------------
int __cdecl sub_1002DBE0(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_1001AAF0((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_1001AAF0((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (1002DC80) --------------------------------------------------------
int __cdecl sub_1002DC80(int a1)
{
  int result; // eax@1

  result = sub_1002C530((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_1003A950((_BYTE *)(a1 + 24));
    if ( !result )
    {
      result = sub_1001A7A0((_BYTE *)(a1 + 1), 0, 0);
      if ( !result )
      {
        result = sub_1001A7A0((_BYTE *)(a1 + 2), 0, 0);
        if ( !result )
          result = sub_1001A7F0(a1 + 20, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (1002DD10) --------------------------------------------------------
int __cdecl sub_1002DD10(int a1)
{
  int result; // eax@1

  result = sub_10032630((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_10032630((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_1003AA50((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_1002DD00(a1 + 24);
        if ( !result )
        {
          result = sub_1003AA50((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_1003AA00((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_1003AA50((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 1002DD00: using guessed type _DWORD __cdecl sub_1002DD00(_DWORD);

//----- (1002DD90) --------------------------------------------------------
unsigned int __cdecl sub_1002DD90(int a1)
{
  unsigned int result; // eax@1

  result = sub_1002C5B0((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_1002C5B0((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_1002C5B0((char *)a1);
      if ( !result )
        result = sub_1002C5B0((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (1002DDD0) --------------------------------------------------------
unsigned int __cdecl sub_1002DDD0(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_1002DD90(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_1002C5D0((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_1002C610((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (1002DE20) --------------------------------------------------------
int __cdecl sub_1002DE20(int a1)
{
  int result; // eax@1

  result = sub_1002C5F0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_1001AB40((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (1002DE50) --------------------------------------------------------
int __cdecl sub_1002DE50(int a1)
{
  int result; // eax@1

  result = sub_1002CE90((_BYTE *)a1);
  if ( !result )
    result = sub_1002D0E0((_BYTE *)(a1 + 4));
  return result;
}

//----- (1002DE80) --------------------------------------------------------
unsigned int __cdecl sub_1002DE80(int a1)
{
  unsigned int result; // eax@1

  result = sub_1002CE30((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1002CE30((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_1002D0A0((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (1002DEB0) --------------------------------------------------------
unsigned int __cdecl sub_1002DEB0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1002CE30((_BYTE *)a1);
  if ( !result )
    result = sub_1002D0C0((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (1002DED0) --------------------------------------------------------
unsigned int __cdecl sub_1002DED0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1002CE30((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1001AAF0((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_1002D0A0((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (1002DF10) --------------------------------------------------------
void __cdecl __noreturn sub_1002DF10(int a1)
{
  exit(a1 + 4);
}

//----- (1002E080) --------------------------------------------------------
signed int __cdecl sub_1002E080(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_1002C3B0((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_1002D190((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_1002C3B0((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (1002E0D0) --------------------------------------------------------
int __cdecl sub_1002E0D0(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@1

  v2 = 0;
  result = sub_1002DA10((_BYTE *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002DA40((_BYTE *)(a1 + 4), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1002E120) --------------------------------------------------------
int __cdecl sub_1002E120(_BYTE *a1, int a2)
{
  return sub_1001ABE0(a1, 0, 0x1FEu, 0, a2);
}

//----- (1002E140) --------------------------------------------------------
int __usercall sub_1002E140@<eax>(unsigned __int8 *a1@<eax>, int a2@<edi>)
{
  unsigned __int8 *v2; // esi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_1002C550(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( *v2 == 1 )
    result = sub_1002E0D0((int)(v2 + 4), a2);
  else
    result = sub_1002D500((int)(v2 + 4), a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (1002E190) --------------------------------------------------------
signed int __usercall sub_1002E190@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_1002E080(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_1001AAF0((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_1001A7A0((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_1002C9F0(v2 + 5, a2);
    else
      result = sub_1002C6C0(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_1002DBB0((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (1002E260) --------------------------------------------------------
int __usercall sub_1002E260@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>)
{
  unsigned __int8 *v2; // edi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_1002DB20(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002DB50(v2 + 1, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001A7A0(v2 + 2, 0, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002DB80(v2 + 3, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001ABE0(v2 + 8, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001ABE0(v2 + 12, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1002E120(v2 + 4, a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (1002E350) --------------------------------------------------------
int __cdecl sub_1002E350(unsigned __int8 *a1)
{
  return sub_1002E140(a1, 0);
}

//----- (1002E360) --------------------------------------------------------
int __cdecl sub_1002E360(unsigned __int8 *a1)
{
  return sub_1002E260(a1, 0);
}

//----- (1002E370) --------------------------------------------------------
signed int __cdecl sub_1002E370(int a1)
{
  return sub_1002E190(a1, 0);
}

//----- (1002E380) --------------------------------------------------------
char __cdecl sub_1002E380(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (1002E3C0) --------------------------------------------------------
int __cdecl sub_1002E3C0(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 1003EF10: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1002E430) --------------------------------------------------------
bool __cdecl sub_1002E430(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_1001D470(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100B2270[(unsigned __int8)v4](v3) )
    {
      sub_1002E3C0((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_10032770(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10012A10(2) )
    result = 0;
  else
    result = sub_100136E0(2, v5, a2) == 1 && !sub_1003A8F0(a2);
  return result;
}
// 100B2270: using guessed type int (__cdecl *off_100B2270[3])(char);

//----- (1002E4F0) --------------------------------------------------------
char __cdecl sub_1002E4F0(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_1002E430(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_10032750(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (1002E5B0) --------------------------------------------------------
char __thiscall sub_1002E5B0(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_10230388 = sub_100160D0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10230390, 0, 0x1540u);
  memset(&unk_102318D0, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_10230390;
  do
  {
    sub_10032540(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_102318D0 );
  v3 = 0;
  v4 = &unk_102318D0;
  do
  {
    result = sub_100325C0(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&dword_10233280 );
  return result;
}
// 10230388: using guessed type int dword_10230388;
// 10233280: using guessed type int dword_10233280;

//----- (1002E640) --------------------------------------------------------
char __cdecl sub_1002E640(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@3
  char v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@3
  char v6[19]; // [sp+Dh] [bp-17h]@5

  v1 = 0;
  v4 = 0;
  do
  {
    if ( v1 )
      break;
    sub_10032520(v4, (int)&v5);
    v2 = 0;
    do
    {
      if ( v1 )
        break;
      if ( v6[4 * v2] == a1 )
        v1 = 1;
      ++v2;
    }
    while ( v2 <= 1u );
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  return v1;
}
// 1002E640: using guessed type char var_17[19];

//----- (1002E6B0) --------------------------------------------------------
char __cdecl sub_1002E6B0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_10230388 != 1379255385;
  v7 = 0;
  v8 = dword_10230388 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1003DF80(86, 10);
      memset((char *)&unk_10230390 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10032540(a1, (int)&unk_10230390 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_10230668[v6] == a2 || byte_10230669[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_1003DF50(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10230388: using guessed type int dword_10230388;

//----- (1002E770) --------------------------------------------------------
char __cdecl sub_1002E770(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_10230388 != 1379255385;
  v7 = 0;
  v8 = dword_10230388 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_1003DF80(86, 10);
      memset((char *)&unk_10230390 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_10032540(a1, (int)&unk_10230390 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_10230688[v6] == a2 || byte_10230689[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_1003DF50(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10230388: using guessed type int dword_10230388;

//----- (1002E830) --------------------------------------------------------
char __cdecl sub_1002E830(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1002E6B0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1002E860) --------------------------------------------------------
char __cdecl sub_1002E860(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_1002E770(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (1002E890) --------------------------------------------------------
char __cdecl sub_1002E890(char a1)
{
  char result; // al@1

  result = sub_1003ABE0();
  if ( result == 2 )
    result = byte_100B2D7C[8 * sub_1001CD60(&a1, 4u, (int)&unk_100B2D78, 8, 7, 7)];
  return result;
}

//----- (1002E8C0) --------------------------------------------------------
char __thiscall sub_1002E8C0(void *this)
{
  char v1; // al@1

  v1 = (unsigned int)sub_1001D4B0(this);
  return sub_1002E890(v1);
}

//----- (1002E8D0) --------------------------------------------------------
char __cdecl sub_1002E8D0(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_100136E0(1, v2, a2) || sub_1002DD10((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002E980) --------------------------------------------------------
char __cdecl sub_1002E980(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+11h] [bp-CC3h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_1002E8D0(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 3;
  return result;
}

//----- (1002E9E0) --------------------------------------------------------
char __cdecl sub_1002E9E0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_1001CD60((_DWORD *)a2, 2u, (int)&unk_100B41E8, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100B41EC[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_1003DE00(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_1003DBF0();
        sub_1001D840(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_100129A0("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100B41EC: using guessed type int dword_100B41EC[];

//----- (1002EB00) --------------------------------------------------------
char __cdecl sub_1002EB00(int a1)
{
  return sub_1002E9E0(32, a1);
}

//----- (1002EB10) --------------------------------------------------------
char __cdecl sub_1002EB10(int a1)
{
  return sub_1002E9E0(31, a1);
}

//----- (1002EB20) --------------------------------------------------------
int __cdecl sub_1002EB20(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (1002EB30) --------------------------------------------------------
int __usercall sub_1002EB30@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_1003ABF0(a2, a1);
}

//----- (1002EB40) --------------------------------------------------------
char __usercall sub_1002EB40@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_1002EB30((char *)&v5, a2);
  v2 = sub_1002EB20(a1);
  if ( sub_1003E040(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 1002EB40: using guessed type char var_48[68];

//----- (1002EC00) --------------------------------------------------------
char __cdecl sub_1002EC00(char a1, char a2)
{
  return sub_1002EB40(a1, a2);
}

//----- (1002EC20) --------------------------------------------------------
int __cdecl sub_1002EC20(void *a1, void *a2, size_t a3, int a4, int a5)
{
  int result; // eax@8

  if ( a3 > 4 || a3 == 3 || a3 - 1 > 3 || ((unsigned int)a2 | (unsigned int)a1) & (a3 - 1) )
  {
    if ( sub_1003DDA0(a4, a5) )
    {
      result = -1;
    }
    else
    {
      memcpy(a1, a2, a3);
      sub_1003DD40(a4);
      result = 1;
    }
  }
  else
  {
    switch ( a3 )
    {
      case 1u:
        result = 0;
        *(_BYTE *)a1 = *(_BYTE *)a2;
        break;
      case 2u:
        *(_WORD *)a1 = *(_WORD *)a2;
        result = 0;
        break;
      case 4u:
        result = 0;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        break;
      default:
        memcpy(a1, a2, a3);
        result = 0;
        break;
    }
  }
  return result;
}

//----- (1002ECD0) --------------------------------------------------------
int __cdecl sub_1002ECD0(unsigned __int16 a1)
{
  int v1; // ecx@1
  unsigned __int16 v2; // ax@3
  int result; // eax@4

  v1 = sub_1002B7C0();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 0x2000), v2 < 0x2000u) )
    result = v1 + v2;
  else
    result = 0;
  return result;
}

//----- (1002ED10) --------------------------------------------------------
int __usercall sub_1002ED10@<eax>(unsigned __int16 a1@<di>)
{
  int v1; // eax@1
  unsigned __int16 v2; // cx@3
  int result; // eax@4

  v1 = sub_1002B7B0();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 14400), v2 < 0x3840u) )
    result = v1 + 24 * v2;
  else
    result = 0;
  return result;
}

//----- (1002ED50) --------------------------------------------------------
int __cdecl sub_1002ED50(unsigned __int16 a1)
{
  int result; // eax@1
  int v2; // esi@1

  result = sub_1002ED10(a1);
  v2 = result;
  if ( !result )
  {
    sub_100129A0("..\\lib\\acl\\dat\\dat_intf.c", 100, 0, 0);
    result = v2;
  }
  return result;
}

//----- (1002ED80) --------------------------------------------------------
bool __cdecl sub_1002ED80(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_1001CD60(&a2, 4u, (int)&dword_100B6140, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_1003E040((unsigned __int16)word_100B6144[a1 + 6 * v3], a3, (unsigned __int16)word_100B6148[6 * v3]) == 0;
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100B6140: using guessed type int dword_100B6140;
// 100B6144: using guessed type __int16 word_100B6144[];
// 100B6148: using guessed type __int16 word_100B6148[];

//----- (1002EE10) --------------------------------------------------------
bool __cdecl sub_1002EE10(char a1, char a2, void *a3)
{
  int v3; // eax@1
  int v4; // esi@3
  void *v5; // edi@3
  int (__cdecl *v6)(void *, _DWORD); // esi@4
  bool result; // al@6

  v3 = sub_1001CD60(&a1, 1u, (int)&unk_100B617C, 8, 2, 2);
  if ( v3 >= 2 || (unsigned __int8)a2 >= 3u )
  {
    result = 0;
  }
  else
  {
    v4 = (unsigned __int8)a2;
    v5 = a3;
    result = 0;
    if ( sub_100136E0(0, (unsigned __int16)word_100B617E[(unsigned __int8)a2 + 4 * v3], a3) )
    {
      v6 = (int (__cdecl *)(void *, _DWORD))dword_100B618C[v4];
      if ( !v6 || !v6(v5, 0) )
        result = 1;
    }
  }
  return result;
}
// 100B617E: using guessed type __int16 word_100B617E[];
// 100B618C: using guessed type int dword_100B618C[];

//----- (1002EE90) --------------------------------------------------------
bool __cdecl sub_1002EE90(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_1002EFD0(a1);
  v6 = sub_1001CD60(&a3, 1u, (int)&unk_100B6164, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_1001CD60(&dword_100B6168[2 * v6], 4u, (int)&dword_100B6140, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100B6148[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_1002ED80(v11, *(int *)((char *)&dword_100B6140 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100B6140: using guessed type int dword_100B6140;
// 100B6148: using guessed type __int16 word_100B6148[];

//----- (1002EF30) --------------------------------------------------------
signed int sub_1002EF30()
{
  return sub_1003ED70((int)&off_100B6268);
}
// 100B6268: using guessed type char *off_100B6268;

//----- (1002EF40) --------------------------------------------------------
char __cdecl sub_1002EF40(void *a1)
{
  char v1; // bl@1

  v1 = 0;
  if ( a1 && (unsigned __int8)sub_1002EF30() == 1 && !sub_1003DDA0(37, 100) )
  {
    qmemcpy(a1, (const void *)(dword_10233280 + 8), 0x34u);
    v1 = 1;
    sub_1003DD40(37);
  }
  return v1;
}
// 10233280: using guessed type int dword_10233280;

//----- (1002EF90) --------------------------------------------------------
bool sub_1002EF90()
{
  char v0; // bl@1
  unsigned int v2; // [sp+4h] [bp-4h]@1

  v0 = sub_10019F70((char *)&v2);
  return (unsigned __int8)sub_1002EF30() && v0 && v2 < *(_DWORD *)(dword_10233280 + 60) + 18;
}
// 10233280: using guessed type int dword_10233280;

//----- (1002EFD0) --------------------------------------------------------
char __cdecl sub_1002EFD0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_100129A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (1002F050) --------------------------------------------------------
char __cdecl sub_1002F050(unsigned __int16 a1, _WORD *a2)
{
  unsigned int v2; // ebx@2
  _WORD *v3; // edi@2
  char result; // al@2
  signed __int16 v5; // cx@2
  __int16 v6; // si@2
  __int16 v7; // dx@3

  if ( sub_1002D130(&a1) )
  {
    result = 0;
  }
  else
  {
    v2 = a1;
    v3 = a2;
    result = 1;
    *a2 = 0;
    v5 = 1;
    v6 = 0;
    do
    {
      v7 = v5 * (v2 & 7);
      v5 *= 10;
      v2 >>= 3;
      v6 += v7;
    }
    while ( (unsigned __int16)v5 <= 0x3E8u );
    *v3 = v6;
  }
  return result;
}

//----- (1002F0B0) --------------------------------------------------------
char __cdecl sub_1002F0B0(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_100325F0(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_1003E040(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_10032610((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (1002F220) --------------------------------------------------------
int __usercall sub_1002F220@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_1002F0B0(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 1002F220: using guessed type int var_2C[10];

//----- (1002F260) --------------------------------------------------------
int __usercall sub_1002F260@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_1002F0B0(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 1002F260: using guessed type int var_14[4];

//----- (1002F2A0) --------------------------------------------------------
signed int sub_1002F2A0()
{
  return sub_1003ED70((int)&off_100B8008);
}
// 100B8008: using guessed type char *off_100B8008;

//----- (1002F2B0) --------------------------------------------------------
char __cdecl sub_1002F2B0(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_1002F2A0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_102AD590 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_102AD590 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_102AD590);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102AD590: using guessed type int dword_102AD590;

//----- (1002F310) --------------------------------------------------------
char __cdecl sub_1002F310(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_1002F2A0() )
  {
    if ( (sub_10015290(a1)
       || *(_BYTE *)(dword_102AD590 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_102AD590 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_102AD590 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102AD590 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102AD590 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102AD590 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102AD590 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102AD590 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102AD590 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_102AD590 + 176))
      && *(_BYTE *)(dword_102AD590 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_102AD590 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_102AD590 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_102AD590 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_102AD590 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102AD590: using guessed type int dword_102AD590;

//----- (1002F430) --------------------------------------------------------
char __cdecl sub_1002F430(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_1002F2A0() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_102AD590 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_102AD590 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_102AD590 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_102AD590 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_102AD590);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102AD590: using guessed type int dword_102AD590;

//----- (1002F4B0) --------------------------------------------------------
char __cdecl sub_1002F4B0(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_100129A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_1002F260(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_1002F430(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_1002F220(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_1002F2B0(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_1002F0B0(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_1002F310(v6, a5);
        }
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_100129A0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002F660) --------------------------------------------------------
double __cdecl sub_1002F660(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_102ACCF0 + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_102ACCF0 + 12))() * v1);
}
// 102ACCF0: using guessed type int dword_102ACCF0;

//----- (1002F6B0) --------------------------------------------------------
char __usercall sub_1002F6B0@<al>(void *a1@<esi>)
{
  char result; // al@2
  bool v2; // zf@3
  void *v3; // [sp+0h] [bp-8h]@0

  if ( sub_10015020(4035, v3) )
  {
    result = 1;
  }
  else
  {
    v2 = (unsigned __int8)sub_1002B790(1, 741, 0, 4, a1) == 0;
    result = 1;
    if ( v2 )
      result = 0;
  }
  return result;
}

//----- (1002F6F0) --------------------------------------------------------
char __usercall sub_1002F6F0@<al>(float *a1@<esi>)
{
  char result; // al@1
  void *v2; // [sp+0h] [bp-8h]@0

  result = sub_10014720(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (1002F710) --------------------------------------------------------
char __cdecl sub_1002F710(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_1003E0A0(6081, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (1002F770) --------------------------------------------------------
char __cdecl sub_1002F770(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_1003E0A0(6937, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (1002F7D0) --------------------------------------------------------
char __cdecl sub_1002F7D0(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_1003E0A0(6938, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (1002F830) --------------------------------------------------------
char __usercall sub_1002F830@<al>(int a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  float v4; // ST14_4@5
  char result; // al@5
  float v6; // [sp+Ch] [bp-8h]@1
  float v7; // [sp+10h] [bp-4h]@1

  v1 = sub_100187B0(0x4B6u, &v6);
  v2 = sub_100187B0(0x4B7u, &v7);
  if ( v1 )
  {
    v3 = v6;
    if ( v2 )
    {
      if ( v7 <= v3 )
        v3 = v7;
      v4 = v3;
      result = sub_10019ED0(v4, a1);
    }
    else
    {
      result = sub_10019ED0(v6, a1);
    }
  }
  else if ( v2 )
  {
    result = sub_10019ED0(v7, a1);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002F8D0) --------------------------------------------------------
char __cdecl sub_1002F8D0(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_1002B790(1, 949, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002F920) --------------------------------------------------------
char __cdecl sub_1002F920(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_1002B790(1, 950, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002F970) --------------------------------------------------------
char __cdecl sub_1002F970(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_1002B790(0, 400, 0, 4, &v3) && (unsigned __int8)sub_1002B790(1, 527, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002F9D0) --------------------------------------------------------
char __cdecl sub_1002F9D0(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_1002B790(0, 401, 0, 4, &v3) && (unsigned __int8)sub_1002B790(1, 530, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002FA30) --------------------------------------------------------
char __usercall sub_1002FA30@<al>(float *a1@<esi>, char a2)
{
  char v2; // bl@1
  char result; // al@6
  float v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  float v6; // [sp+Ch] [bp-4h]@1
  char v7; // [sp+14h] [bp+4h]@2
  char v8; // [sp+14h] [bp+4h]@7

  v4 = 9.8999998e24;
  v6 = 9.8999998e24;
  v2 = 0;
  v5 = 0;
  if ( a2 )
  {
    v7 = sub_1002B790(6, 617, 0, 4, &v5);
    if ( sub_10015020(4026, &v4) )
    {
      v2 = 1;
      if ( v7 && v5 & 0x1000 && sub_10015020(4028, &v6) )
      {
LABEL_6:
        result = 1;
        *a1 = v6 + v4;
        return result;
      }
      goto LABEL_11;
    }
  }
  else
  {
    v8 = sub_1002B790(6, 620, 0, 4, &v5);
    if ( sub_10015020(4027, &v4) )
    {
      v2 = 1;
      if ( v8 && v5 & 0x1000 && sub_10015020(4029, &v6) )
        goto LABEL_6;
LABEL_11:
      *a1 = v4;
      return v2;
    }
  }
  return v2;
}

//----- (1002FB20) --------------------------------------------------------
char __cdecl sub_1002FB20(float a1, int a2)
{
  float v2; // ecx@0
  char v3; // al@3
  char result; // al@5
  float v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  if ( LOBYTE(a1) == 1 )
  {
    if ( !sub_10015020(65, &v5) )
      return 0;
    v3 = sub_10015020(498, &a1);
  }
  else
  {
    if ( !sub_10015020(61, &v5) )
      return 0;
    v3 = sub_10015020(477, &a1);
  }
  if ( v3 )
  {
    result = 1;
    *(float *)a2 = (a1 + v5) * 0.5;
    return result;
  }
  return 0;
}

//----- (1002FB90) --------------------------------------------------------
char __usercall sub_1002FB90@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_1002B790(1, 740, 0, 4, &v5);
  v2 = sub_1002B790(1, 2172, 0, 4, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( !v2 || (v5 = v3 - v6, LODWORD(v5) &= 0x7FFFFFFFu, v5 <= 304.8) )
    {
      *a1 = v3;
      return 1;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (1002FC10) --------------------------------------------------------
char __cdecl sub_1002FC10(float *a1)
{
  char result; // al@4
  int v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_1002B790(1, 120, 0, 4, &v3)
    && (unsigned __int8)sub_1002B790(1, 1775, 0, 4, &v2)
    && !(v2 & 0x7C0000) )
  {
    *a1 = v3;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002FC70) --------------------------------------------------------
char __cdecl sub_1002FC70(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_1002B790(1, 122, 0, 4, &v5) || !(unsigned __int8)sub_1002B790(1, 996, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (1002FD00) --------------------------------------------------------
char __cdecl sub_1002FD00(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_1002B790(1, 127, 0, 4, &v5) || !(unsigned __int8)sub_1002B790(1, 1004, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (1002FD90) --------------------------------------------------------
char __usercall sub_1002FD90@<al>(float *a1@<esi>)
{
  double v1; // st7@15
  double v2; // st6@19
  double v3; // st7@25
  double v4; // st7@31
  char result; // al@36
  char v6; // [sp+4h] [bp-2Ch]@2
  char v7; // [sp+5h] [bp-2Bh]@5
  char v8; // [sp+6h] [bp-2Ah]@8
  char v9; // [sp+7h] [bp-29h]@11
  float v10; // [sp+8h] [bp-28h]@2
  float v11; // [sp+Ch] [bp-24h]@21
  float v12; // [sp+10h] [bp-20h]@17
  float v13; // [sp+14h] [bp-1Ch]@14
  float v14; // [sp+18h] [bp-18h]@23
  float v15; // [sp+1Ch] [bp-14h]@29
  float v16; // [sp+20h] [bp-10h]@1
  float v17; // [sp+24h] [bp-Ch]@21
  double v18; // [sp+28h] [bp-8h]@21

  *a1 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 1744, 0, 4, &v16) )
    goto LABEL_40;
  v16 = v16 * 61.02374267578125;
  v10 = v16;
  if ( (unsigned __int8)sub_1002B790(1, 134, 0, 1, &v6) && !v6 )
    v10 = v10 + 39.90000152587891;
  if ( (unsigned __int8)sub_1002B790(1, 634, 0, 1, &v7) && !v7 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_1002B790(1, 649, 0, 1, &v8) && !v8 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_1002B790(1, 1757, 0, 1, &v9) && v9 )
    v10 = v10 + 13.5;
  if ( sub_10014720(&v13) )
    v1 = v13 * 1.799999952316284 + 32.0;
  else
    v1 = -65.0;
  v13 = v1;
  if ( (unsigned __int8)sub_1002B790(1, 1743, 0, 4, &v12) && v12 != 0.0 )
    v2 = v12 * 0.000145037702168338;
  else
    v2 = 3040.0;
  v12 = v2;
  v17 = v13 + 460.0;
  v18 = 0.0000344 - (v17 - 528.0) * 0.00000005;
  v11 = v18 * (v12 - 100.0) + 1.003999948501587;
  v11 = 100.0 - v17 * (v11 * 248.0) / v12;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  if ( (unsigned __int8)sub_1002B790(1, 1741, 0, 4, &v14) && v14 != 0.0 )
    v3 = v14 * 0.000145037702168338;
  else
    v3 = 3040.0;
  v14 = v3;
  v11 = (v14 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v11 * 124.0 * v17 / v14;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v4 = (unsigned __int8)sub_1002B790(1, 1742, 0, 4, &v15) && v15 != 0.0 ? v15 * 0.000145037702168338 : 3040.0;
  v15 = v4;
  v16 = (v15 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v16 * 124.0 * v17 / v15;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v17 = v12 * 631.0 / 250000.0;
  v10 = v17 + v10;
  v17 = 631.0 * ((v13 - 59.0) * 0.0004556);
  v17 = v17 + v10;
  v17 = (v17 - 300.0 + 100.0) / 100.0;
  if ( v17 <= 1.25 )
  {
    *a1 = v17;
    result = 1;
  }
  else
  {
LABEL_40:
    result = 0;
  }
  return result;
}

//----- (10030130) --------------------------------------------------------
char __usercall sub_10030130@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  *a1 = 0.0;
  if ( sub_100187B0(0x40Du, &v3) && sub_100187B0(0x40Eu, &v2) && v2 != 0.0 )
  {
    result = 1;
    *a1 = v3 / v2 * 11.35624027252197 + 0.1147093996405602;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100301A0) --------------------------------------------------------
char __usercall sub_100301A0@<al>(float *a1@<esi>)
{
  char result; // al@1
  float *v2; // [sp+0h] [bp-8h]@0

  result = sub_10014950(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (100301C0) --------------------------------------------------------
char __usercall sub_100301C0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_100187B0(0x4Fu, &v5);
  v2 = sub_100187B0(0x7EAu, &v6);
  if ( v1 )
  {
    if ( !v2 )
    {
      result = 1;
      *a1 = v5;
      return result;
    }
    v3 = v5;
    v5 = v6 - v5;
    LODWORD(v5) &= 0x7FFFFFFFu;
    if ( v5 <= 34473.789 )
    {
      result = 1;
      *a1 = (v6 + v3) * 0.5;
      return result;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (10030250) --------------------------------------------------------
void __usercall sub_10030250(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v1 = sub_100187B0(0x51u, &v4);
  v2 = sub_100187B0(0x7EBu, &v5);
  if ( v1 )
  {
    if ( !v2 )
    {
      *a1 = v4;
      return;
    }
    v3 = v4;
    v4 = v5 - v4;
    LODWORD(v4) &= 0x7FFFFFFFu;
    if ( v4 <= 5.0 )
    {
      *a1 = (v5 + v3) * 0.5;
      return;
    }
  }
  else if ( v2 )
  {
    *a1 = v5;
    return;
  }
  *a1 = 21.1;
}

//----- (100302E0) --------------------------------------------------------
char __cdecl sub_100302E0(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  float v3; // [sp+8h] [bp-18h]@1
  double v4; // [sp+Ch] [bp-14h]@1
  float v5; // [sp+14h] [bp-Ch]@2
  double v6; // [sp+18h] [bp-8h]@2

  v1 = sub_100301C0((float *)&v4);
  sub_10030250(&v3);
  if ( v1 )
  {
    v5 = (v3 + 67.77799987792969) / 27.77799987792969;
    v3 = (*(float *)&v4 + 517.0900268554688) / 4137139.5;
    v4 = v5 * 27.79999923706055;
    v5 = pow(315.0 - v4, 2.0);
    v6 = v5 * 5.470000147278498e-11;
    v5 = pow(v3 * 41.40000152587891, 2.0);
    v6 = v5 * v6;
    v5 = pow(215.0 - v4, 2.0);
    v5 = v6 - v5 * 0.00000005260000079942984 * 41.40000152587891 * v3 + 1.0;
    *a1 = v3 / (v4 + 205.3000030517578) * (1.0 / v5 * 127823.0) - 195.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10030400) --------------------------------------------------------
char __usercall sub_10030400@<al>(float *a1@<esi>, float a2)
{
  char v2; // bl@1
  double v3; // st7@3
  long double v4; // st7@3
  float v6; // [sp+0h] [bp-20h]@1
  float v7; // [sp+4h] [bp-1Ch]@1
  float v8; // [sp+8h] [bp-18h]@3
  float v9; // [sp+Ch] [bp-14h]@1
  int v10; // [sp+10h] [bp-10h]@3
  float v11; // [sp+14h] [bp-Ch]@5
  float v12; // [sp+18h] [bp-8h]@5
  float v13; // [sp+1Ch] [bp-4h]@5
  float v14; // [sp+24h] [bp+4h]@3
  float v15; // [sp+24h] [bp+4h]@3
  unsigned __int8 v16; // [sp+24h] [bp+4h]@3

  v2 = 0;
  v9 = a2 * 32.0 * 0.0005787039990536869;
  v7 = 0.0;
  v6 = 0.0;
  if ( sub_100187B0(0x4Fu, &v7) && sub_100187B0(0x51u, &v6) )
  {
    *(float *)&v10 = v7 / 101325.0;
    v14 = v6 + 273.0;
    v7 = v7 * 0.000145037702168338;
    v6 = v6 * 1.799999952316284 + 32.0;
    v15 = v14 * 0.08205779641866684 / *(float *)&v10;
    v3 = v15 * 0.002983009908348322;
    v16 = 0;
    v8 = v3;
    v4 = v9;
    do
    {
      if ( v16 >= 5u )
        break;
      v12 = pow(v4, 2.0);
      v11 = pow(v8 / v9, 2.0);
      v11 = (v9 - 0.5099999904632568 * v8) * (v11 * 5140.0 + v7 + 14.69999980926514)
          - (v6 + 460.0) * 10.71000003814697 * v8;
      v13 = v11;
      v11 = pow(v8, 2.0);
      v12 = -((v11 * 7864200.0 + 10710.0 * v12 * v6 + v12 * 510.0 * v7 - 10280000.0 * v9 * v8 + v12 * 4934097.0)
            / (v12
             * 1000.0));
      v13 = v13 / v12;
      v8 = v8 - v13;
      v4 = v9;
      v10 = LODWORD(v13) & 0x7FFFFFFF;
      if ( COERCE_FLOAT(LODWORD(v13) & 0x7FFFFFFF) < 0.001 )
      {
        v2 = 1;
        *a1 = v8 / 0.002983009908348322;
      }
      ++v16;
    }
    while ( !v2 );
  }
  return v2;
}

//----- (10030600) --------------------------------------------------------
char __usercall sub_10030600@<al>(float *a1@<esi>, float a2)
{
  char v2; // al@3
  char result; // al@5
  float v4; // [sp+4h] [bp-4h]@3

  if ( LOBYTE(a2) )
  {
    if ( !sub_10013680(1, 1516, 0, 4, &a2) )
      return 0;
    v2 = sub_10013680(0, 356, 0, 4, &v4);
  }
  else
  {
    if ( !sub_10013680(1, 2447, 0, 4, &a2) )
      return 0;
    v2 = sub_10013680(0, 357, 0, 4, &v4);
  }
  if ( v2 )
  {
    result = 1;
    *a1 = a2 - v4;
    return result;
  }
  return 0;
}

//----- (10030690) --------------------------------------------------------
char __usercall sub_10030690@<al>(float *a1@<eax>)
{
  return sub_10019A50(a1);
}

//----- (100306A0) --------------------------------------------------------
char __usercall sub_100306A0@<al>(float *a1@<eax>)
{
  return sub_10019B20(a1);
}

//----- (100306B0) --------------------------------------------------------
char __usercall sub_100306B0@<al>(float *a1@<eax>)
{
  return sub_10019BF0(a1);
}

//----- (100306C0) --------------------------------------------------------
char __usercall sub_100306C0@<al>(float *a1@<eax>)
{
  return sub_10019CC0(a1);
}

//----- (100306D0) --------------------------------------------------------
int __usercall sub_100306D0@<eax>(char a1@<dl>, int a2@<ecx>, float *a3)
{
  int result; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  result = sub_1002B790(a1, a2, 0, 4, &v4);
  if ( (_BYTE)result )
    *a3 = (double)v4 * 0.00000008381903171539307;
  return result;
}

//----- (10030700) --------------------------------------------------------
char __usercall sub_10030700@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  double v2; // st7@3
  char result; // al@9
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@2

  v1 = 0;
  if ( sub_10013680(6, 41, 0, 4, &v4) && sub_10013680(6, 42, 0, 4, &v5) )
  {
    v2 = (v5 + v4) * 0.5;
LABEL_8:
    *a1 = v2;
    v1 = 1;
    goto LABEL_9;
  }
  if ( sub_10013680(6, 41, 0, 4, &v4) )
  {
    v2 = v4;
    goto LABEL_8;
  }
  if ( sub_10013680(6, 42, 0, 4, &v5) )
  {
    v2 = v5;
    goto LABEL_8;
  }
LABEL_9:
  result = v1;
  *a1 = *a1 * 1.943844437599182;
  return result;
}

//----- (100307A0) --------------------------------------------------------
char __usercall sub_100307A0@<al>(float *a1@<esi>)
{
  char result; // al@6
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@3
  char v4; // [sp+7h] [bp-B5h]@4
  char v5; // [sp+8h] [bp-B4h]@5
  char v6; // [sp+9h] [bp-B3h]@2
  float v7; // [sp+14h] [bp-A8h]@6
  float v8; // [sp+20h] [bp-9Ch]@9

  if ( (unsigned __int8)sub_1002B790(6, 429, 0, 180, &v2) )
  {
    if ( v6 )
    {
LABEL_9:
      result = 1;
      *a1 = v8;
      return result;
    }
    if ( (!v3 || !v4) && v5 )
      goto LABEL_6;
  }
  if ( (unsigned __int8)sub_1002B790(6, 430, 0, 180, &v2) )
  {
    if ( v6 )
      goto LABEL_9;
    if ( (!v3 || !v4) && v5 )
    {
LABEL_6:
      result = 1;
      *a1 = v7;
      return result;
    }
  }
  return 0;
}

//----- (10030880) --------------------------------------------------------
char __cdecl sub_10030880(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( sub_10015020(87, &v3) && sub_10015020(88, &v2) )
  {
    result = 1;
    *a1 = (v2 + v3) * 0.5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100308D0) --------------------------------------------------------
char __usercall sub_100308D0@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@2
  char v4; // [sp+7h] [bp-B5h]@3
  float v5; // [sp+Ch] [bp-B0h]@5
  float v6; // [sp+18h] [bp-A4h]@9

  if ( (unsigned __int8)sub_1002B790(6, 429, 0, 180, &v2) )
  {
    if ( v3 && v4 )
      goto LABEL_9;
    if ( v2 )
    {
LABEL_5:
      result = 1;
      *a1 = v5;
      return result;
    }
  }
  if ( (unsigned __int8)sub_1002B790(6, 430, 0, 180, &v2) )
  {
    if ( v3 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v6;
      return result;
    }
    if ( v2 )
      goto LABEL_5;
  }
  return 0;
}

//----- (100309B0) --------------------------------------------------------
char __usercall sub_100309B0@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+5h] [bp-B7h]@4
  char v4; // [sp+6h] [bp-B6h]@3
  char v5; // [sp+7h] [bp-B5h]@2
  float v6; // [sp+10h] [bp-ACh]@5
  float v7; // [sp+1Ch] [bp-A0h]@9

  if ( (unsigned __int8)sub_1002B790(6, 429, 0, 180, &v2) )
  {
    if ( v5 && v4 )
      goto LABEL_9;
    if ( v3 )
    {
LABEL_5:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_1002B790(6, 430, 0, 180, &v2) )
  {
    if ( v5 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v7;
      return result;
    }
    if ( v3 )
      goto LABEL_5;
  }
  return 0;
}

//----- (10030A90) --------------------------------------------------------
char __usercall sub_10030A90@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+44h] [bp-78h]@2
  float v4; // [sp+50h] [bp-6Ch]@3

  if ( (unsigned __int8)sub_1002B790(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_1002B790(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10030B30) --------------------------------------------------------
char __usercall sub_10030B30@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+40h] [bp-7Ch]@2
  float v4; // [sp+48h] [bp-74h]@3

  if ( (unsigned __int8)sub_1002B790(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_1002B790(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10030BD0) --------------------------------------------------------
char __usercall sub_10030BD0@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+41h] [bp-7Bh]@2
  float v4; // [sp+4Ch] [bp-70h]@3

  if ( (unsigned __int8)sub_1002B790(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_1002B790(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10030C70) --------------------------------------------------------
char __usercall sub_10030C70@<al>(float *a1@<esi>)
{
  char result; // al@4
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+80h] [bp-3Ch]@2
  char v4; // [sp+81h] [bp-3Bh]@3
  float v5; // [sp+8Ch] [bp-30h]@7
  float v6; // [sp+98h] [bp-24h]@4

  if ( (unsigned __int8)sub_1002B790(6, 429, 0, 180, &v2) )
  {
    if ( v3 )
    {
LABEL_7:
      result = 1;
      *a1 = v5;
      return result;
    }
    if ( v4 )
    {
LABEL_4:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_1002B790(6, 430, 0, 180, &v2) )
  {
    if ( v3 )
      goto LABEL_7;
    if ( v4 )
      goto LABEL_4;
  }
  return 0;
}

//----- (10030D50) --------------------------------------------------------
char __cdecl sub_10030D50(float *a1)
{
  double v1; // st7@2
  char result; // al@5
  float v3; // ST04_4@5
  float v4; // [sp+0h] [bp-Ch]@1
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v4 = 9.8999998e24;
  v5 = sub_10019DD0();
  if ( sub_10019950(&v6) && (v1 = v5, v5 != 9.8999998e24) )
  {
    if ( v1 >= 3785.411865234375 || v6 <= 0.0001051503277267329 )
    {
      result = 1;
      *a1 = v4;
    }
    else
    {
      result = 1;
      v3 = v1 / v6;
      *a1 = v3;
    }
  }
  else
  {
    *a1 = v4;
    result = 0;
  }
  return result;
}

//----- (10030DF0) --------------------------------------------------------
bool __cdecl sub_10030DF0(float *a1)
{
  char v1; // bl@1
  bool v2; // al@1
  double v3; // st6@5
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10030D50(&v5);
  v2 = sub_10015D90(&v6);
  if ( !v1
    || !v2
    || v5 == 9.8999998e24
    || (LODWORD(v6) & 0x7F800000) == 2139095040
    || (v5 = v5 * v6, v3 = v5, v5 > 37040000.0) )
  {
    v5 = 9.8999998e24;
    v3 = (float)9.8999998e24;
  }
  *a1 = v3;
  return v2 && v1 && v3 != 9.8999998e24;
}

//----- (10030EA0) --------------------------------------------------------
char __usercall sub_10030EA0@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_1002B790(1, 90, 0, 4, &v2)
    && (unsigned __int8)sub_1002B790(1, 115, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10030F20) --------------------------------------------------------
char __usercall sub_10030F20@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_1002B790(1, 527, 0, 4, &v2)
    && (unsigned __int8)sub_1002B790(1, 530, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10030FB0) --------------------------------------------------------
char __usercall sub_10030FB0@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+0h] [bp-Ch]@1
  float v3; // [sp+4h] [bp-8h]@2
  float v4; // [sp+8h] [bp-4h]@3

  *a1 = 9.8999998e24;
  if ( sub_10015D90(&v2) && (v3 = v2, (LODWORD(v2) & 0x7F800000) != 2139095040) && sub_10019950(&v4) )
  {
    result = 1;
    if ( v4 > 0.0001051503277267329 )
      *a1 = v2 / v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10031020) --------------------------------------------------------
int __cdecl sub_10031020(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_1002B790(1, 74, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 75, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 76, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 77, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 78, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 79, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + unk_10071FA0 >= v6 )
  {
    v2 = unk_10071FA0;
  }
  else
  {
    v2 = unk_10071FA0;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10031250) --------------------------------------------------------
int __cdecl sub_10031250(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_1002B790(1, 99, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 100, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 101, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 102, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 103, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 104, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + unk_10071FA0 >= v6 )
  {
    v2 = unk_10071FA0;
  }
  else
  {
    v2 = unk_10071FA0;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (10031480) --------------------------------------------------------
int __cdecl sub_10031480(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_1002B790(1, 68, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 69, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 70, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 71, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 72, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 73, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + unk_10071FA0 >= v6 )
  {
    v2 = unk_10071FA0;
  }
  else
  {
    v2 = unk_10071FA0;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (100316B0) --------------------------------------------------------
int __cdecl sub_100316B0(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_1002B790(1, 93, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 94, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 95, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 96, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 97, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_1002B790(1, 98, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + unk_10071FA0 >= v6 )
  {
    v2 = unk_10071FA0;
  }
  else
  {
    v2 = unk_10071FA0;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (100318E0) --------------------------------------------------------
char __usercall sub_100318E0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-24h]@1
  float v4; // [sp+8h] [bp-20h]@1
  char v5; // [sp+Ch] [bp-1Ch]@1
  float v6; // [sp+18h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  v4 = sub_10019DD0();
  sub_1003E0A0(41109, &v5, 24, &unk_100B8130);
  if ( v6 != 9.8999998e24 && v4 != 9.8999998e24 )
  {
    v1 = 1;
    v3 = v4 - v6;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (10031970) --------------------------------------------------------
char __usercall sub_10031970@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@3
  float v3; // [sp+4h] [bp-20h]@1
  char v4; // [sp+8h] [bp-1Ch]@1
  float v5; // [sp+14h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  sub_1003E0A0(41109, &v4, 24, &unk_100B8130);
  if ( v5 != 9.8999998e24 )
  {
    v3 = v5;
    v1 = 1;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (100319E0) --------------------------------------------------------
bool __cdecl sub_100319E0(float *a1)
{
  bool v1; // bl@1
  bool result; // al@3
  float v3; // [sp+4h] [bp-4h]@1

  v3 = 9.8999998e24;
  v1 = sub_1003B300(&v3, 0, 0, 2) != 0;
  if ( 9.8999998e24 != v3 )
    v3 = sub_1003B290() + v3;
  result = v1;
  *a1 = v3;
  return result;
}

//----- (10031A40) --------------------------------------------------------
char __cdecl sub_10031A40(float a1, void *a2)
{
  __int16 v2; // cx@1
  char result; // al@4
  double v4; // st7@32
  double v5; // st7@69
  float v6; // ST0C_4@70
  float v7; // [sp+Ch] [bp-4h]@1
  float v8; // [sp+14h] [bp+4h]@32
  float v9; // [sp+14h] [bp+4h]@35

  HIBYTE(v2) = BYTE1(a1);
  v7 = 9.8999998e24;
  if ( (signed int)LOWORD(a1) > 301 )
  {
    switch ( LOWORD(a1) )
    {
      case 0x12Eu:
        v5 = 511.0;
        goto LABEL_70;
      case 0x12Fu:
        v5 = 1000.0;
        goto LABEL_70;
      case 0x191u:
        result = sub_10030130((float *)a2);
        break;
      case 0x192u:
        result = sub_1002FB20(0.0, (int)a2);
        break;
      case 0x193u:
        result = sub_1002FB20(COERCE_FLOAT(1), (int)a2);
        break;
      case 0x194u:
        result = sub_10030880((float *)a2);
        break;
      case 0x195u:
        result = sub_1002F830((int)a2);
        break;
      case 0x196u:
      case 0x197u:
        result = sub_1002FA30((float *)a2, LOWORD(a1) == 406);
        break;
      case 0x198u:
      case 0x199u:
        LOBYTE(v2) = LOWORD(a1) == 408;
        result = ((char (__usercall *)@<al>(float *@<esi>, __int16))sub_10030600)((float *)a2, v2);
        break;
      case 0x19Au:
        result = sub_10030700((float *)a2);
        break;
      case 0x19Bu:
        result = sub_1002F6B0(a2);
        break;
      case 0x19Cu:
        result = sub_100306A0((float *)a2);
        break;
      case 0x19Du:
        result = sub_100306B0((float *)a2);
        break;
      case 0x19Eu:
        result = sub_10030690((float *)a2);
        break;
      case 0x19Fu:
        result = sub_100306C0((float *)a2);
        break;
      case 0x1A0u:
        result = sub_1003E0A0(9145, a2, 4, &v7) == 0;
        break;
      default:
LABEL_88:
        sub_100129A0("..\\lib\\adl\\dat_custom_proc_prj.c", 724, 0, 0);
        result = 0;
        break;
    }
  }
  else if ( LOWORD(a1) == 301 )
  {
    v5 = 295.0;
LABEL_70:
    v6 = v5;
    result = sub_10030400((float *)a2, v6);
  }
  else
  {
    switch ( LOWORD(a1) )
    {
      case 0u:
        return sub_10030A90((float *)a2);
      case 1u:
        return sub_10030C70((float *)a2);
      case 2u:
        return sub_100308D0((float *)a2);
      case 3u:
        return sub_100309B0((float *)a2);
      case 4u:
        return sub_100307A0((float *)a2);
      case 5u:
        return sub_100302E0((float *)a2);
      case 7u:
        return sub_10030B30((float *)a2);
      case 6u:
        return sub_10030BD0((float *)a2);
      case 9u:
        return sub_1002F8D0((float *)a2);
      case 0xAu:
        return sub_1002F920((float *)a2);
      case 0xBu:
        return sub_1002FD90((float *)a2);
      case 0xDu:
        *(float *)a2 = sub_10019340();
        return 1;
      case 0x38u:
        return sub_100301C0((float *)a2);
      case 0x39u:
        sub_10030250((float *)a2);
        goto LABEL_18;
      case 0x3Au:
        return sub_1002FC70((float *)a2);
      case 0x3Bu:
        return sub_1002FD00((float *)a2);
      case 0x3Cu:
        return sub_1002FC10((float *)a2);
      case 0x3Du:
        return sub_1002FB90((float *)a2);
      case 8u:
        return sub_1002F6F0((float *)a2);
      case 0xCu:
        return sub_100301A0((float *)a2);
      case 0xEu:
        return sub_100199E0((float *)a2);
      case 0xFu:
        return sub_10019D60((float *)a2);
      case 0x10u:
        return sub_100198A0((float *)a2);
      case 0x11u:
        return sub_10019E30((float *)a2);
      case 0x12u:
        return sub_10019910((float *)a2);
      case 0x13u:
        return sub_10019930((float *)a2);
      case 0x14u:
        return sub_10019950((float *)a2);
      case 0x15u:
        v8 = sub_10019DD0();
        v4 = v8;
        *(float *)a2 = v8;
        goto LABEL_33;
      case 0x35u:
        v9 = sub_10019310();
        v4 = v9;
        *(float *)a2 = v9;
LABEL_33:
        if ( 9.8999998e24 == v4 )
          result = 0;
        else
LABEL_18:
          result = 1;
        break;
      case 0x16u:
        result = sub_1002F970((float *)a2);
        break;
      case 0x17u:
        result = sub_1002F9D0((float *)a2);
        break;
      case 0x18u:
        result = sub_10030D50((float *)a2);
        break;
      case 0x19u:
        result = sub_10030DF0((float *)a2);
        break;
      case 0x1Au:
        result = sub_10030EA0((float *)a2);
        break;
      case 0x1Bu:
        result = sub_10030F20((float *)a2);
        break;
      case 0x1Cu:
        result = sub_10030FB0((float *)a2);
        break;
      case 0x1Du:
        result = sub_10031020((float *)a2);
        break;
      case 0x1Eu:
        result = sub_10031250((float *)a2);
        break;
      case 0x1Fu:
        result = sub_10031480((float *)a2);
        break;
      case 0x20u:
        result = sub_100316B0((float *)a2);
        break;
      case 0x21u:
        result = sub_100306D0(6, 59, (float *)a2);
        break;
      case 0x22u:
        result = sub_100306D0(6, 60, (float *)a2);
        break;
      case 0x23u:
        result = sub_100306D0(6, 61, (float *)a2);
        break;
      case 0x24u:
        result = sub_100306D0(6, 62, (float *)a2);
        break;
      case 0x25u:
        result = sub_1002F710((float *)a2);
        break;
      case 0x26u:
        result = sub_1002F770((float *)a2);
        break;
      case 0x27u:
        result = sub_1002F7D0((float *)a2);
        break;
      case 0x2Au:
        result = sub_1003E0A0(9000, a2, 4, &v7) == 0;
        break;
      case 0x2Bu:
        result = sub_1003E0A0(9001, a2, 4, &v7) == 0;
        break;
      case 0x2Cu:
        result = sub_1003E0A0(9002, a2, 4, &v7) == 0;
        break;
      case 0x2Du:
        result = sub_1003E0A0(9003, a2, 4, &v7) == 0;
        break;
      case 0x2Eu:
        result = sub_1003E0A0(9004, a2, 4, &v7) == 0;
        break;
      case 0x2Fu:
        result = sub_1003E0A0(9005, a2, 4, &v7) == 0;
        break;
      case 0x30u:
        result = sub_1003E0A0(9006, a2, 4, &v7) == 0;
        break;
      case 0x31u:
        result = sub_1003E0A0(9007, a2, 4, &v7) == 0;
        break;
      case 0x32u:
        result = sub_1003E0A0(9008, a2, 4, &v7) == 0;
        break;
      case 0x33u:
        result = sub_1003E0A0(9009, a2, 4, &v7) == 0;
        break;
      case 0x34u:
        result = sub_1003E0A0(9010, a2, 4, &v7) == 0;
        break;
      case 0x28u:
        result = sub_100318E0((float *)a2);
        break;
      case 0x29u:
        result = sub_10031970((float *)a2);
        break;
      case 0x36u:
        result = sub_100319E0((float *)a2);
        break;
      case 0x37u:
        result = sub_1003B300((float *)a2, 0, 0, 2) != 0;
        break;
      default:
        goto LABEL_88;
    }
  }
  return result;
}

//----- (100322F0) --------------------------------------------------------
int __cdecl sub_100322F0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10233284 = *(_DWORD *)a1;
  dword_10233288 = *(_DWORD *)(a1 + 4);
  dword_1023328C = *(_DWORD *)(a1 + 8);
  dword_10233290 = *(_DWORD *)(a1 + 12);
  dword_102ACCF0 = (int)&dword_10233284;
  return result;
}
// 10233284: using guessed type int dword_10233284;
// 10233288: using guessed type int dword_10233288;
// 1023328C: using guessed type int dword_1023328C;
// 10233290: using guessed type int dword_10233290;
// 102ACCF0: using guessed type int dword_102ACCF0;

//----- (10032330) --------------------------------------------------------
char __cdecl sub_10032330(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_100B8320[4 * a1];
    *a3 = word_100B8322[2 * a1];
    result = 1;
  }
  else
  {
    sub_100129A0("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 100B8322: using guessed type __int16 word_100B8322[];

//----- (10032390) --------------------------------------------------------
signed int __cdecl sub_10032390(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_100B8B80;
    v6 = &unk_100B8B80;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_100B8B98;
    v6 = &unk_100B8B98;
    v5 = &a1;
  }
  v3 = sub_1001CD60(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (100323F0) --------------------------------------------------------
int __cdecl sub_100323F0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001CD60(&a1, 1u, (int)&unk_100B8BE0, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100B8BE4[2 * v1];
  return result;
}
// 100B8BE4: using guessed type int dword_100B8BE4[];

//----- (10032430) --------------------------------------------------------
signed int __cdecl sub_10032430(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_100B8BF0;
    v7 = &unk_100B8BF0;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_100B8C08;
    v7 = &unk_100B8C08;
    v6 = &a1;
  }
  v4 = sub_1001CD60(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (100324A0) --------------------------------------------------------
int __cdecl sub_100324A0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001CD60(&a1, 1u, (int)&unk_100B8C20, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_100B8C24[2 * v1];
  return result;
}
// 100B8C24: using guessed type int dword_100B8C24[];

//----- (100324E0) --------------------------------------------------------
int __cdecl sub_100324E0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001CD60(&a1, 1u, (int)&unk_100B8C38, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100B8C3C[2 * v1];
  return result;
}
// 100B8C3C: using guessed type int dword_100B8C3C[];

//----- (10032520) --------------------------------------------------------
char __cdecl sub_10032520(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10032390(a1, 11);
  return sub_1003E060(v2, a2, 24);
}

//----- (10032540) --------------------------------------------------------
char __cdecl sub_10032540(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100323F0(a1);
  return sub_1003E060(v2, a2, 2720);
}

//----- (10032570) --------------------------------------------------------
char __cdecl sub_10032570(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_10032430(a1, 11, 1);
  sub_1003E060(v2, a2, 36);
  v3 = sub_10032430(a1, 11, 0);
  return sub_1003E060(v3, a2 + 36, 32);
}

//----- (100325C0) --------------------------------------------------------
char __cdecl sub_100325C0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100324A0(a1);
  return sub_1003E060(v2, a2, 2192);
}

//----- (100325F0) --------------------------------------------------------
char __cdecl sub_100325F0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100324E0(a1);
  return sub_1003E060(v2, a2, 60);
}

//----- (10032610) --------------------------------------------------------
char __cdecl sub_10032610(int a1)
{
  return sub_1003E060(6453, a1, 5);
}

//----- (10032630) --------------------------------------------------------
int __cdecl sub_10032630(_BYTE *a1)
{
  return sub_1001AB40(a1, 0, 0x2710u, 5000, 0);
}

//----- (10032650) --------------------------------------------------------
int __cdecl sub_10032650(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 5u, 5u, 0);
}

//----- (10032670) --------------------------------------------------------
int __cdecl sub_10032670(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 6u, 0, 0);
}

//----- (10032690) --------------------------------------------------------
int __cdecl sub_10032690(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 0xEu, 1u, 0);
}

//----- (100326B0) --------------------------------------------------------
int __cdecl sub_100326B0(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 1u, 0, 0);
}

//----- (100326E0) --------------------------------------------------------
int __cdecl sub_100326E0(int a1)
{
  int result; // eax@1

  result = sub_10032650((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_100326D0(a1 + 12);
    if ( !result )
    {
      result = sub_100326B0((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_10032690((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 100326D0: using guessed type _DWORD __cdecl sub_100326D0(_DWORD);

//----- (10032720) --------------------------------------------------------
int __cdecl sub_10032720(int a1)
{
  int result; // eax@1

  result = sub_1003A820((void *)(a1 + 28));
  if ( !result )
    result = sub_100326E0(a1);
  return result;
}

//----- (10032740) --------------------------------------------------------
signed int __fastcall sub_10032740(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (10032750) --------------------------------------------------------
char __cdecl sub_10032750(unsigned __int8 a1)
{
  return byte_100BA634[6 * sub_10032740(a1)];
}

//----- (10032770) --------------------------------------------------------
__int16 __cdecl sub_10032770(unsigned __int8 a1)
{
  return word_100BA630[3 * sub_10032740(a1)];
}
// 100BA630: using guessed type __int16 word_100BA630[];

//----- (10032790) --------------------------------------------------------
int __cdecl sub_10032790(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001CD60(&a1, 1u, (int)&unk_100BC4C8, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100BC4CC[2 * v1];
  }
  else
  {
    sub_100129A0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100BC4CC: using guessed type int dword_100BC4CC[];

//----- (100327E0) --------------------------------------------------------
char __cdecl sub_100327E0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int, int, int); // eax@2

  v6 = sub_1001CD60(&a1, 1u, (int)&unk_100BC128, 16, 58, 57);
  if ( v6 == 57 )
  {
    sub_100129A0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2231, 0, 0);
  }
  else
  {
    v7 = (int (__cdecl *)(int, int, int, int, int, int))dword_100BC12C[4 * v6];
    if ( v7 )
      return v7(a1, a2, a3, a4, a5, a6);
  }
  return 0;
}
// 100BC12C: using guessed type int dword_100BC12C[];

//----- (10032850) --------------------------------------------------------
char sub_10032850()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_100136E0(1, 1309, &v1) )
    sub_1002DF10((int)&v1);
  return 0;
}

//----- (100328F0) --------------------------------------------------------
BOOL __cdecl sub_100328F0(int a1, int a2)
{
  return sub_1003E040(6455, a2, 252) == 0;
}

//----- (10032910) --------------------------------------------------------
char __cdecl sub_10032910(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_100328F0(a1, a5);
  }
  else
  {
    result = sub_10032850();
  }
  return result;
}

//----- (10032950) --------------------------------------------------------
char *__cdecl sub_10032950(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = (char *)&unk_10064984;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (100329A0) --------------------------------------------------------
int sub_100329A0()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_1003DBF0();
  result = 0;
  while ( 1 )
  {
    v3 = dword_102332B4[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_102332B4[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 102332B4: using guessed type int dword_102332B4[];

//----- (100329E0) --------------------------------------------------------
int __cdecl sub_100329E0(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10032A50) --------------------------------------------------------
signed int __cdecl sub_10032A50(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10032AF0) --------------------------------------------------------
int __usercall sub_10032AF0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10032A50(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032B20) --------------------------------------------------------
signed int __usercall sub_10032B20@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10032A50((_BYTE *)a3, (int)(&off_100BDAF8)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_100BDAFC[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_10042AEC(a3, (int)&unk_10065FA8, (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_10042AEC(a3, (int)&unk_10065FAC, (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_10042AEC(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 100BDAF8: using guessed type char *off_100BDAF8;

//----- (10032CF0) --------------------------------------------------------
char *__usercall sub_10032CF0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10032D50) --------------------------------------------------------
unsigned int __usercall sub_10032D50@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  unsigned int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10032A50((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032DE0) --------------------------------------------------------
int __usercall sub_10032DE0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_10032AF0(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10032E30) --------------------------------------------------------
char **__usercall sub_10032E30@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10032950(v6);
      if ( !sub_10032A50((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10032E90) --------------------------------------------------------
const char *__usercall sub_10032E90@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10032EB0) --------------------------------------------------------
int __usercall sub_10032EB0@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_102332A0[sub_100329A0()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102332A0: using guessed type int dword_102332A0[];

//----- (10032EF0) --------------------------------------------------------
int __usercall sub_10032EF0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10032B20(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10032F80) --------------------------------------------------------
int __usercall sub_10032F80@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (100330D0) --------------------------------------------------------
int __usercall sub_100330D0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_10034E20(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_100339B0(v3, v6, 0);
        v7 = -*v3;
        sub_10034E20(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_10034E20(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_100BD7B0);
      sub_1003D090(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_100BD7B0);
      sub_10034E20(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10033170) --------------------------------------------------------
int __usercall sub_10033170@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (100331B0) --------------------------------------------------------
char *__cdecl sub_100331B0(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10032CF0(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10032CF0(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10032CF0(result, v5, (int)&v20);
      v10 = (const char *)&unk_10064984;
    }
    LOBYTE(v9) = 0;
    sub_10032CF0(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10032CF0(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10032CF0(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10032CF0(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10034DB0(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 100331B0: using guessed type int var_61C[6];

//----- (10033360) --------------------------------------------------------
int __usercall sub_10033360@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10032950((char **)a1);
  result = sub_10034E40(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_100BD7B0);
  return result;
}

//----- (10033390) --------------------------------------------------------
int __usercall sub_10033390@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_100BD7B0);
  v2 = (unsigned int)sub_10032950((char **)a1);
  return sub_10034E20(10, v2);
}

//----- (100333C0) --------------------------------------------------------
void __cdecl sub_100333C0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10032950(v5);
            v7 = sub_10032950((char **)v3);
            if ( !sub_100329E0(v7, (int)v6) )
            {
              v8 = sub_10032950((char **)v3);
              sub_10034EE0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10032950((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10032950((char **)v3);
        sub_10034EE0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10032E90(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1001E420("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10032950((char **)v3);
            sub_10034F20(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_100329E0(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10032E90(v18);
                  v25 = sub_1001E420("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10032950((char **)v3);
                  sub_10034F20(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10032950((char **)v3);
                  sub_10034F20(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10032950((char **)v3);
              sub_10034F20(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10032950((char **)v3);
              sub_10034F20(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10032950((char **)v3);
              sub_10034F20(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_100333C0((int (**)(void))(*(_DWORD *)(v3 + 8) + v11 + 8), (char **)v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10032950((char **)v3);
            sub_10034F20(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10032950((char **)v3);
            sub_10034F20(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10032950((char **)v3);
          sub_10034F20(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10032950((char **)v3);
        sub_10034F20(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10032950(a2);
      sub_10034EE0(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10033830) --------------------------------------------------------
int sub_10033830()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_102332A0[sub_100329A0()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_100333C0(i, 0, &v2);
  }
  return v2;
}
// 102332A0: using guessed type int dword_102332A0[];

//----- (10033880) --------------------------------------------------------
void *sub_10033880()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_102332A0[0] = 0;
  dword_102332A4 = 0;
  dword_102332A8 = 0;
  dword_102332AC = 0;
  dword_102332B0 = 0;
  result = &unk_102332C8;
  dword_102332B4[0] = -1;
  dword_102332B8 = -1;
  dword_102332BC = -1;
  dword_102332C0 = -1;
  dword_102332C4 = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10033170((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 102332A0: using guessed type int dword_102332A0[];
// 102332A4: using guessed type int dword_102332A4;
// 102332A8: using guessed type int dword_102332A8;
// 102332AC: using guessed type int dword_102332AC;
// 102332B0: using guessed type int dword_102332B0;
// 102332B4: using guessed type int dword_102332B4[];
// 102332B8: using guessed type int dword_102332B8;
// 102332BC: using guessed type int dword_102332BC;
// 102332C0: using guessed type int dword_102332C0;
// 102332C4: using guessed type int dword_102332C4;

//----- (100338E0) --------------------------------------------------------
char *sub_100338E0()
{
  return (char *)&unk_102332C8 + 56 * sub_100329A0();
}

//----- (10033900) --------------------------------------------------------
char sub_10033900()
{
  return sub_100338E0()[33];
}

//----- (10033910) --------------------------------------------------------
char __cdecl sub_10033910(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_100338E0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_100349A0(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10033950) --------------------------------------------------------
int *__usercall sub_10033950@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_100338E0() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10032A50((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (100339A0) --------------------------------------------------------
char **sub_100339A0()
{
  return &off_100BDB60;
}
// 100BDB60: using guessed type char *off_100BDB60;

//----- (100339B0) --------------------------------------------------------
int __cdecl sub_100339B0(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_10022690();
  v3 = sub_100338E0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10033830();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10033360(a2);
    if ( a3 )
    {
      v7 = sub_100330D0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_100330D0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10033390(a2);
        return v7;
      }
    }
    sub_10033390(a2);
    result = v7;
  }
  return result;
}

//----- (10033A60) --------------------------------------------------------
int __cdecl sub_10033A60(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10032CF0(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10032CF0(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10032CF0(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10034DB0(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10032CF0(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10032CF0(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10032CF0(v14, "group-begin", (int)&v29);
          sub_10034DB0(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10032950(v15);
          sub_10033A60((int)v16[2], (int)v16[3], (int)v16[4], v17, a4);
          sub_10032950(v16);
          v18 = sub_100331B0((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10032CF0(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10032CF0(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10032CF0(v20, "group-end", (int)&v29);
          result = sub_10034DB0(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10032CF0(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10032CF0(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10032CF0(v21, a4, (int)&v28);
          v23 = (const char *)&unk_10064984;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10032CF0(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10032CF0(v24, *(const char **)v5, (int)&v30);
        result = sub_10034DB0(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10033A60: using guessed type int var_414[4];

//----- (10033C70) --------------------------------------------------------
char *__usercall sub_10033C70@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10032CF0(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10032CF0(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10034DB0(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10033A60(a3, (int)a4, a5, a2, 0);
    result = sub_100331B0(a3, a4, a5, 0);
  }
  return result;
}
// 10033C70: using guessed type int var_20C[2];

//----- (10033D30) --------------------------------------------------------
char *__cdecl sub_10033D30(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_102332A0[sub_100329A0()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10032950((char **)v2);
    sub_10033C70("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_100338E0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10033C70(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 102332A0: using guessed type int dword_102332A0[];

//----- (10033DD0) --------------------------------------------------------
int *__cdecl sub_10033DD0(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_102332A0[sub_100329A0()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10032950(v2);
      if ( !sub_10032A50(a1, (int)v4) )
      {
        v5 = sub_10032950(v3);
        sub_10033C70("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_100338E0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10032A50(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10033C70(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 102332A0: using guessed type int dword_102332A0[];

//----- (10033E90) --------------------------------------------------------
int __usercall sub_10033E90@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10032EB0(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_100339B0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10032EB0(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_100339B0((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10033360(v5);
        sub_100330D0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10033390(v8);
          v10 = sub_10032EB0(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10033FF0) --------------------------------------------------------
signed int __usercall sub_10033FF0@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_102332A0[sub_100329A0()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_100339B0((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 102332A0: using guessed type int dword_102332A0[];

//----- (10034060) --------------------------------------------------------
int __cdecl sub_10034060(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_100338E0();
  switch ( a1 )
  {
    case 9:
      sub_10034E20(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10032A50((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10032A50(v6, (int)"-q") )
            {
              sub_10033DD0(v6);
              v9 = sub_10033830();
              sub_10034E20(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10033D30(0);
              v8 = sub_10033830();
              sub_10034E20(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10033D30(1);
            v7 = sub_10033830();
            sub_10034E20(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10034EA0(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_10034E20(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10033D30(0);
        v4 = sub_10033830();
        sub_10034E20(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_10034E20(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_102332A0[sub_100329A0()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10034060 )
              v12(2, (int)&unk_100BD7B0);
          }
        }
      }
      sub_10022690();
      v3[34] = 0;
      return 0;
    case 3:
      sub_10034E20(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_102332A0[sub_100329A0()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10034EA0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_10033E90((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10034EA0(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10033FF0((int)v3);
    case 14:
      exit_0(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10034EA0(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10034060 )
          v15(3, (int)&unk_100BD7B0);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10034060: using guessed type int __cdecl sub_10034060(int, int);
// 102332A0: using guessed type int dword_102332A0[];

//----- (10034340) --------------------------------------------------------
char **sub_10034340()
{
  return off_100BD954;
}
// 100BD954: using guessed type char *off_100BD954[3];

//----- (10034350) --------------------------------------------------------
int __usercall sub_10034350@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10032DE0(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10032EF0(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_10034340();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (10034440) --------------------------------------------------------
int __cdecl sub_10034440(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_100338E0();
  *a1 = 0;
  v4 = sub_1001E420("Processing command '%s'", v2);
  sub_10034EA0(3, (int)&unk_100BE2C8, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10032F80(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_10033E90((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10033FF0((int)v3);
    v11 = 0;
    v6 = sub_100329A0();
    v7 = sub_10032E30((int (**)(void))dword_102332A0[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10032D50((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10032D50((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100339B0(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_100339B0(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_10034350(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10033950(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_10034350(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_10034340();
        result = sub_10034350(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 102332A0: using guessed type int dword_102332A0[];
// 10034440: using guessed type char var_2D4[720];

//----- (10034680) --------------------------------------------------------
int sub_10034680()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_10034440(&v4);
  if ( !sub_100338E0()[32] )
    sub_10034E20(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1001E420("%s %i, %s", "Command status:", v0, &v4);
    sub_10034EA0(3, (int)&unk_100BE2C8, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1001E420("%s %i", "Command status:", v0);
    sub_10034EA0(3, (int)&unk_100BE2C8, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (10034760) --------------------------------------------------------
int __cdecl sub_10034760(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_102332A0[sub_100329A0()] = a1;
  sub_100338E0()[32] = a3;
  sub_10022690();
  sub_100389F0(a2);
  v3 = sub_100339A0();
  sub_10034890(v3);
  return sub_10034680();
}
// 102332A0: using guessed type int dword_102332A0[];

//----- (100347B0) --------------------------------------------------------
int __cdecl sub_100347B0(int a1)
{
  return a1 + 9;
}

//----- (100347C0) --------------------------------------------------------
int __cdecl sub_100347C0(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_1003DBF0();
  memset(a1, 0, 0xDCu);
  sub_1001D840((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_100347B0(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_1003D0A0((int)a1, (int)v3);
}

//----- (10034840) --------------------------------------------------------
int __cdecl sub_10034840(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_1003D2B0(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (10034870) --------------------------------------------------------
signed int __cdecl sub_10034870(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  signed int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_1003F010(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_1003DC90();
    }
    else if ( v6 != -57 || (unsigned int)(sub_1003DC90() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_1003D0A0(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (10034890) --------------------------------------------------------
char __cdecl sub_10034890(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_100338E0() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_10038830("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_10034680() )
          v7 = 0;
      }
      v5 = sub_10038830("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_10034680() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (100349A0) --------------------------------------------------------
char __cdecl sub_100349A0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (100349D0) --------------------------------------------------------
bool __cdecl sub_100349D0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (10034A00) --------------------------------------------------------
bool __cdecl sub_10034A00(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10034A30) --------------------------------------------------------
bool __cdecl sub_10034A30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (10034A60) --------------------------------------------------------
bool __cdecl sub_10034A60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (10034A90) --------------------------------------------------------
bool __cdecl sub_10034A90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (10034AC0) --------------------------------------------------------
bool __cdecl sub_10034AC0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (10034B00) --------------------------------------------------------
bool __cdecl sub_10034B00(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (10034B40) --------------------------------------------------------
bool __cdecl sub_10034B40(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (10034B70) --------------------------------------------------------
bool __cdecl sub_10034B70(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (10034BA0) --------------------------------------------------------
char __cdecl sub_10034BA0(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (10034BD0) --------------------------------------------------------
bool __cdecl sub_10034BD0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (10034C00) --------------------------------------------------------
bool __cdecl sub_10034C00(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10034C30) --------------------------------------------------------
bool __cdecl sub_10034C30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (10034C60) --------------------------------------------------------
bool __cdecl sub_10034C60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (10034C90) --------------------------------------------------------
bool __cdecl sub_10034C90(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_100BE2C8, 9u);
}

//----- (10034CC0) --------------------------------------------------------
bool __cdecl sub_10034CC0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10034CF0) --------------------------------------------------------
bool __cdecl sub_10034CF0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (10034D20) --------------------------------------------------------
bool __cdecl sub_10034D20(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (10034D50) --------------------------------------------------------
bool __cdecl sub_10034D50(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (10034D80) --------------------------------------------------------
bool __cdecl sub_10034D80(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10034DB0) --------------------------------------------------------
int __cdecl sub_10034DB0(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_100338E0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10034E20) --------------------------------------------------------
int __cdecl sub_10034E20(int a1, char a2)
{
  return sub_10034DB0(a1, (int)&a2, 1);
}

//----- (10034E40) --------------------------------------------------------
int __cdecl sub_10034E40(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10034DB0(a1, (int)&v4, 2);
}

//----- (10034E70) --------------------------------------------------------
int __cdecl sub_10034E70(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10034DB0(a1, (int)&v5, 3);
}

//----- (10034EA0) --------------------------------------------------------
int __cdecl sub_10034EA0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10034DB0(a1, (int)&v6, 4);
}

//----- (10034EE0) --------------------------------------------------------
int __cdecl sub_10034EE0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10034DB0(a1, (int)&v7, 5);
}

//----- (10034F20) --------------------------------------------------------
int __cdecl sub_10034F20(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10034DB0(a1, (int)&v8, 6);
}

//----- (10034F70) --------------------------------------------------------
char __cdecl sub_10034F70(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_100338E0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10034FA0) --------------------------------------------------------
char __cdecl sub_10034FA0(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10034FB0) --------------------------------------------------------
char __cdecl sub_10034FB0(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  const char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = "/", v3) )
          v11 = (const char *)&unk_10064984;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_10039B30(v16) )
        sub_10039B10((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_10039B40((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 10039B30: using guessed type _DWORD __cdecl sub_10039B30(_DWORD);
// 10034FB0: using guessed type char var_104[255];

//----- (10035130) --------------------------------------------------------
signed int __cdecl sub_10035130(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (10035170) --------------------------------------------------------
signed int __cdecl sub_10035170(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10035210) --------------------------------------------------------
char __cdecl sub_10035210(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (10035270) --------------------------------------------------------
char __usercall sub_10035270@<al>(int a1@<edx>, int a2, void (__cdecl *a3)(int))
{
  char result; // al@6

  --*(_DWORD *)(a2 + 328);
  if ( *(_BYTE *)(a2 + 52) )
  {
    if ( a3 )
      a3(a2);
    sub_10039AF0(a1, *(_DWORD *)(a2 + 4 * *(_DWORD *)a2 + 36), *(_DWORD *)(a2 + 4 * *(_DWORD *)a2 + 36));
    *(_DWORD *)(a2 + 4 * *(_DWORD *)a2 + 36) = 0;
    if ( *(_DWORD *)a2 > 0 )
      --*(_DWORD *)a2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a2 + 312) = 5;
  *(_BYTE *)(a2 + 316) = 0;
  *(_DWORD *)(a2 + 320) = 0;
  return result;
}

//----- (100352E0) --------------------------------------------------------
char *__cdecl sub_100352E0(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_102333E0, v1, v2);
  *(&byte_102333E0 + v2) = 0;
  return &byte_102333E0;
}

//----- (10035380) --------------------------------------------------------
int __cdecl sub_10035380(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (100353F0) --------------------------------------------------------
bool __cdecl sub_100353F0(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_10042AEC(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_10042AEC(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (10035480) --------------------------------------------------------
char __cdecl sub_10035480(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (10035530) --------------------------------------------------------
char __cdecl sub_10035530(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (10035540) --------------------------------------------------------
char __usercall sub_10035540@<al>(int a1@<edx>, int a2, void (__cdecl *a3)(int))
{
  char v3; // bl@1

  v3 = 0;
  if ( !*(_BYTE *)(a2 + 52) && *(_DWORD *)(a2 + 324) > 0 || *(_DWORD *)(a2 + 4 * *(_DWORD *)a2 + 36) )
  {
    v3 = 1;
    if ( a3 )
      a3(a2);
  }
  if ( *(_DWORD *)(a2 + 4 * *(_DWORD *)a2 + 36) )
  {
    sub_10039AF0(a1, *(_DWORD *)a2, *(_DWORD *)(a2 + 4 * *(_DWORD *)a2 + 36));
    *(_DWORD *)(a2 + 4 * *(_DWORD *)a2 + 36) = 0;
    if ( *(_DWORD *)a2 > 0 )
      --*(_DWORD *)a2;
    v3 = 1;
  }
  *(_DWORD *)(a2 + 312) = 5;
  *(_BYTE *)(a2 + 316) = 0;
  *(_DWORD *)(a2 + 320) = 0;
  return v3;
}

//----- (100355C0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100355C0(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_10039BC0((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (10035610) --------------------------------------------------------
signed int __usercall sub_10035610@<eax>(int a1@<edx>, int a2, void (__cdecl *a3)(int))
{
  signed int result; // eax@1

  sub_10035540(a1, a2, a3);
  result = 1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 324) = 0;
  *(_DWORD *)(a2 + 328) = 0;
  *(_DWORD *)(a2 + 572) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  return result;
}

//----- (10035660) --------------------------------------------------------
const char *__cdecl sub_10035660(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (100356A0) --------------------------------------------------------
char __cdecl sub_100356A0(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // edx@1
  int v5; // ebp@1
  int v6; // eax@1
  char *v7; // ebp@1
  char *v8; // eax@11
  int v9; // ecx@12
  int v10; // ST44_4@13
  bool v11; // zf@18
  signed int v12; // edx@24
  const char *v13; // eax@32
  _BYTE *v14; // eax@39
  int v15; // eax@44
  bool v16; // sf@44
  char v17; // cl@45
  char *v18; // eax@50
  int v19; // edx@52
  int v20; // edi@53
  unsigned int v21; // eax@53
  const char *v22; // ecx@53
  _DWORD *v23; // edx@53
  int v24; // esi@57
  int v25; // eax@58
  _BYTE *v26; // ecx@58
  _BYTE *v27; // edx@58
  int v28; // eax@60
  _BYTE *v29; // ecx@60
  _BYTE *v30; // edx@60
  _BYTE *v31; // ecx@62
  _BYTE *v32; // edx@62
  signed int v33; // eax@64
  signed int v34; // edi@73
  int v35; // esi@74
  int v36; // ecx@76
  int v37; // edx@82
  int v38; // eax@83
  int *v39; // eax@106
  void *v40; // ebx@106
  void *v41; // edi@109
  void *v42; // esi@112
  const char *v43; // eax@114
  int v44; // ST30_4@123
  const char *v45; // eax@142
  const char *v46; // eax@148
  char *v48; // [sp-14h] [bp-340h]@69
  char v49; // [sp+12h] [bp-31Ah]@24
  char v50; // [sp+13h] [bp-319h]@21
  signed int v51; // [sp+18h] [bp-314h]@52
  void *v52; // [sp+18h] [bp-314h]@94
  void *v53; // [sp+1Ch] [bp-310h]@97
  void *v54; // [sp+20h] [bp-30Ch]@103
  void *v55; // [sp+24h] [bp-308h]@45
  char v56[508]; // [sp+28h] [bp-304h]@11
  char v57; // [sp+224h] [bp-108h]@44
  char v58; // [sp+227h] [bp-105h]@11
  char v59; // [sp+228h] [bp-104h]@123
  char v60; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v5 = sub_100329A0();
  LOBYTE(v6) = a1;
  v7 = (char *)&unk_102334E8 + 580 * v5;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v6) = sub_10035610(v4, (int)v7, 0);
      if ( v7[577] && !v7[578] )
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, "Resetting test status\r\n");
      return v6;
    case 1:
      LOBYTE(v6) = sub_10035130((int)v7);
      if ( v7[577] && !v7[578] )
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, "Clearing test status\r\n");
      return v6;
    case 11:
      LOBYTE(v6) = sub_10035610(v4, (int)v7, 0);
      return v6;
    case 4:
      sub_10034FB0((int)v7, *a2);
      if ( v7[577] && !v7[578] )
      {
        v8 = sub_100352E0((char *)a2[1]);
        _snprintf(v56, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v8);
        v58 = 0;
        sub_100355C0((int)v7, v56);
      }
      LOBYTE(v6) = 0;
      v9 = (int)&v7[16 * *(_DWORD *)v7 + 4];
      *(_DWORD *)v9 = 0;
      *(_DWORD *)(v9 + 4) = 0;
      *(_DWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 12) = 0;
      return v6;
    case 5:
      v10 = *a2;
      LOBYTE(v6) = sub_10034FA0((int)v7);
      if ( !(_BYTE)v6 && v7[577] && !v7[578] )
      {
        _snprintf(v56, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v6;
    case 6:
      LOBYTE(v6) = 0;
      *(_DWORD *)&v7[16 * *(_DWORD *)v7 + 8] = 0;
      *(_DWORD *)&v7[16 * *(_DWORD *)v7 + 4] = 0;
      v11 = v7[577] == 0;
      *((_DWORD *)v7 + 143) = 0;
      if ( !v11 && !v7[578] )
      {
        _snprintf(v56, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v58 = 0;
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, v56);
      }
      return v6;
    case 7:
      v50 = sub_100349A0((int)a2, a3);
      if ( !v50 && !v7[577] )
        goto LABEL_83;
      if ( v7[578] )
        goto LABEL_81;
      v12 = 0;
      v49 = 0;
      if ( a3 > 7 )
        v12 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v12 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v12 += strlen((const char *)a2[3]);
      if ( v12 > 100 )
        v49 = 1;
      v13 = sub_10035660((int)v7, (unsigned __int8)v50);
      _snprintf(v56, 0x200u, "%s ", v13);
      v58 = 0;
      sub_100355C0((int)v7, v56);
      if ( a3 > 7 )
      {
        _snprintf(v56, 0x200u, " ACT: %-17s", a2[7]);
        v58 = 0;
        sub_100355C0((int)v7, v56);
        if ( v49 )
          sub_100355C0((int)v7, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v56, 0x200u, " EXP: %-17s", a2[8]);
        v58 = 0;
        sub_100355C0((int)v7, v56);
        if ( v49 )
          sub_100355C0((int)v7, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v14 = (_BYTE *)a2[9];
        if ( v14 )
        {
          if ( *v14 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v56, 0x200u, " TOL: %-17s", a2[9]);
              v58 = 0;
              sub_100355C0((int)v7, v56);
              if ( v49 )
                sub_100355C0((int)v7, "\r\n     ");
            }
          }
        }
      }
      v15 = _snprintf(v56, 0x1FCu, " %s", a2[3]);
      v16 = v15 < 0;
      v57 = 0;
      if ( v15 > 0 )
      {
        do
        {
          v17 = *((_BYTE *)&v55 + v15 + 3);
          if ( v17 != 10 && v17 != 13 )
            break;
          *((_BYTE *)&v55 + --v15 + 4) = 0;
        }
        while ( v15 > 0 );
        v16 = v15 < 0;
      }
      if ( !v16 )
      {
        v18 = &v56[v15];
        *(_WORD *)v18 = 2573;
        v18[2] = 0;
      }
      sub_100355C0((int)v7, v56);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v19 = 10;
      v51 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v20 = v3[v19];
        v21 = 6;
        v22 = "Info: ";
        v23 = (_DWORD *)v3[v19];
        do
        {
          if ( *v23 != *(_DWORD *)v22 )
            goto LABEL_57;
          v21 -= 4;
          v22 += 4;
          ++v23;
        }
        while ( v21 >= 4 );
        if ( !v21 )
          goto LABEL_67;
LABEL_57:
        v24 = *(_BYTE *)v23 - *v22;
        if ( *(_BYTE *)v23 == *v22 )
        {
          v25 = v21 - 1;
          v26 = v22 + 1;
          v27 = (char *)v23 + 1;
          if ( !v25
            || (v24 = *v27 - *v26, *v27 == *v26)
            && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
             || (v24 = *v30 - *v29, *v30 == *v29)
             && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
          {
            v3 = a2;
LABEL_67:
            v33 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v33 = 1;
        if ( v24 <= 0 )
          v33 = -1;
LABEL_68:
        if ( v33 )
        {
          _snprintf(v56, 0x200u, "      Post Analysis: %s\r\n", v20);
          v48 = v56;
        }
        else
        {
          _snprintf(v56, 0x200u, "      Compare Info: %s\r\n", v20 + 6);
          v48 = v56;
        }
        v58 = 0;
        sub_100355C0((int)v7, v48);
        v19 = v51++ + 1;
      }
      while ( v51 < (signed int)a3 );
LABEL_72:
      if ( v7[309] )
      {
        v34 = 0;
        if ( *((_DWORD *)v7 + 143) > 0 )
        {
          v35 = (int)(v7 + 336);
          do
          {
            if ( v34 >= 20 )
              break;
            v36 = *(_DWORD *)(v35 - 4);
            if ( *(_DWORD *)(v35 + 4) )
              _snprintf(v56, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v34, v36, *(_DWORD *)v35, *(_DWORD *)(v35 + 4));
            else
              _snprintf(v56, 0x200u, "      Trace[%i]: %s:%s\r\n", v34, v36, *(_DWORD *)v35);
            v58 = 0;
            sub_100355C0((int)v7, v56);
            ++v34;
            v35 += 12;
          }
          while ( v34 < *((_DWORD *)v7 + 143) );
        }
        _snprintf(v56, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v58 = 0;
        sub_100355C0((int)v7, v56);
      }
LABEL_81:
      if ( v50 )
      {
        v37 = 16 * *(_DWORD *)v7;
        ++*(_DWORD *)&v7[v37 + 4];
        v6 = (int)&v7[v37 + 4];
      }
      else
      {
LABEL_83:
        v38 = 16 * *(_DWORD *)v7;
        ++*(_DWORD *)&v7[v38 + 8];
        v6 = (int)&v7[v38 + 8];
      }
      return v6;
    case 9:
      LOBYTE(v6) = sub_10035210((int)v7);
      if ( !(_BYTE)v6 && v7[577] && !v7[578] )
      {
        _snprintf(v56, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v6;
    case 3:
      LOBYTE(v6) = sub_10034CC0((const void **)a2, a3);
      if ( !(_BYTE)v6 && !v7[578] )
      {
        if ( v7[577]
          || sub_10034D80((const void **)a2, a3)
          || (LOBYTE(v6) = sub_10034BD0((const void **)a2, a3), (_BYTE)v6) )
        {
          if ( a3 <= 8 )
            v52 = &unk_10064984;
          else
            v52 = (void *)a2[8];
          if ( a3 <= 7 )
            v53 = &unk_10064984;
          else
            v53 = (void *)a2[7];
          if ( a3 <= 6 )
            v55 = &unk_10064984;
          else
            v55 = (void *)a2[6];
          if ( a3 <= 5 )
            v54 = &unk_10064984;
          else
            v54 = (void *)a2[5];
          if ( a3 <= 4 )
          {
            v39 = a2;
            v40 = &unk_10064984;
          }
          else
          {
            v39 = a2;
            v40 = (void *)a2[4];
          }
          if ( a3 <= 3 )
            v41 = &unk_10064984;
          else
            v41 = (void *)v39[3];
          if ( a3 )
            v42 = (void *)*v39;
          else
            v42 = &unk_10064984;
          v11 = sub_10034C90((const void **)a2, a3) == 0;
          v43 = (const char *)&unk_10064984;
          if ( v11 )
            v43 = "   ";
          _snprintf(v56, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v43, v42, v41, v40, v54, v55, v53, v52);
          v58 = 0;
          LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, v56);
        }
      }
      return v6;
    case 2:
      if ( v7[578] )
        return v6;
      if ( sub_100349D0((const void **)a2, a3) )
      {
        dword_102334E0 = 2;
        sub_100355C0((int)v7, (const char *)&word_100BF24C);
        sub_100355C0((int)v7, "   Command Format:\r\n");
        sub_100355C0(
          (int)v7,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_100355C0(
          (int)v7,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_100355C0(
          (int)v7,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_100355C0(
          (int)v7,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_100355C0((int)v7, "                                         strings depending upon the command\r\n");
        sub_100355C0((int)v7, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_100355C0(
          (int)v7,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_100355C0(
          (int)v7,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_100355C0((int)v7, (const char *)&word_100BF24C);
        sub_100355C0((int)v7, "   Notes:\r\n");
        sub_100355C0((int)v7, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_100355C0((int)v7, (const char *)&word_100BF24C);
        sub_100355C0(
          (int)v7,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_100355C0(
          (int)v7,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_100355C0(
          (int)v7,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_100355C0((int)v7, "       the suite name and the test case or test suite command.\r\n");
        sub_100355C0((int)v7, (const char *)&word_100BF24C);
        sub_100355C0(
          (int)v7,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_100355C0(
          (int)v7,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_100355C0((int)v7, "       without a test suite name.\r\n");
        sub_100355C0((int)v7, (const char *)&word_100BF24C);
        sub_100355C0((int)v7, "   Examples:\r\n");
        sub_100355C0(
          (int)v7,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_100355C0((int)v7, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_100355C0(
          (int)v7,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_100355C0(
          (int)v7,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_100355C0(
          (int)v7,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_100355C0(
          (int)v7,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_100355C0(
          (int)v7,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_100355C0(
          (int)v7,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_100355C0((int)v7, (const char *)&word_100BF24C);
        sub_100355C0((int)v7, "   Command                                 Description\r\n");
        LOBYTE(v6) = (unsigned int)sub_100355C0(
                                     (int)v7,
                                     "   --------------------------------        --------------------------------\r\n");
        return v6;
      }
      if ( sub_10034A60((const void **)a2, a3) )
      {
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, (const char *)&word_100BF24C);
        return v6;
      }
      if ( sub_10034A30((const void **)a2, a3) )
      {
        _snprintf(&v59, 0x100u, "%s %s", a2[3], a2[4]);
        v44 = a2[5];
        v60 = 0;
        _snprintf(
          v56,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_102334E0,
          &unk_10064984,
          &v59,
          6 - dword_102334E0,
          " ",
          v44);
        v58 = 0;
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, v56);
        return v6;
      }
      if ( sub_10034A90((const void **)a2, a3) )
      {
        LOBYTE(v6) = sub_10034AC0((int)a2, a3);
        if ( (_BYTE)v6 )
        {
          dword_102334E0 += 2;
          return v6;
        }
        if ( sub_10034B00((int)a2, a3) )
        {
          LOBYTE(v6) = 2;
          if ( dword_102334E0 < 2 )
            dword_102334E0 = 0;
          else
            dword_102334E0 -= 2;
          return v6;
        }
        _snprintf(
          v56,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_102334E0,
          &unk_10064984,
          a2[2],
          6 - dword_102334E0,
          " ",
          a2[2]);
LABEL_134:
        v58 = 0;
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, v56);
        return v6;
      }
      if ( sub_10034A00((const void **)a2, a3) )
      {
        _snprintf(
          v56,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_102334E0,
          &unk_10064984,
          a2[3],
          6 - dword_102334E0,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_10034B70((const void **)a2, a3) )
      {
        _snprintf(v56, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v58 = 0;
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, v56);
      }
      else if ( sub_10034B40((const void **)a2, a3) )
      {
        _snprintf(v56, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v58 = 0;
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, v56);
      }
      else
      {
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, "Unknown test help event\r\n");
      }
      return v6;
    case 8:
      if ( v7[577] && !v7[578] )
      {
        v45 = sub_10035660((int)v7, *(_DWORD *)&v7[16 * *(_DWORD *)v7 + 4]);
        _snprintf(v56, 0x200u, "\r\n   Test Case Results: %s\r\n", v45);
        v58 = 0;
        sub_100355C0((int)v7, v56);
        _snprintf(v56, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v7[16 * *(_DWORD *)v7 + 8]);
        v58 = 0;
        sub_100355C0((int)v7, v56);
        _snprintf(v56, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v7[16 * *(_DWORD *)v7 + 4]);
        v58 = 0;
        sub_100355C0((int)v7, v56);
      }
      v6 = (int)&v7[16 * *(_DWORD *)v7];
      if ( *(_DWORD *)(v6 + 4) )
        ++*(_DWORD *)(v6 + 12);
      else
        ++*(_DWORD *)(v6 + 16);
      return v6;
    case 10:
      if ( v7[577] && !v7[578] )
      {
        v46 = sub_10035660((int)v7, *(_DWORD *)&v7[16 * *(_DWORD *)v7 + 12]);
        _snprintf(v56, 0x200u, "\r\nTest Suite Results: %s\r\n", v46);
        v58 = 0;
        sub_100355C0((int)v7, v56);
        _snprintf(v56, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v7[16 * (*(_DWORD *)v7 + 1)]);
        v58 = 0;
        sub_100355C0((int)v7, v56);
        _snprintf(v56, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v7[16 * *(_DWORD *)v7 + 12]);
        v58 = 0;
        sub_100355C0((int)v7, v56);
      }
      LOBYTE(v6) = sub_10035270(v4, (int)v7, 0);
      return v6;
    case 12:
      LOBYTE(v6) = sub_10035540(v4, (int)v7, 0);
      return v6;
    case 13:
      if ( a3 >= 2 )
      {
        v6 = *((_DWORD *)v7 + 143);
        if ( v6 < 20 )
        {
          *(_DWORD *)&v7[12 * v6 + 332] = *a2;
          *(_DWORD *)&v7[12 * (*((_DWORD *)v7 + 143) + 28)] = a2[1];
          v6 = 3 * *((_DWORD *)v7 + 143);
          *(_DWORD *)&v7[12 * (*((_DWORD *)v7 + 143))++ + 340] = a2[2];
        }
      }
      return v6;
    case 14:
      --*((_DWORD *)v7 + 143);
      return v6;
    default:
      if ( !v7[578] )
        LOBYTE(v6) = (unsigned int)sub_100355C0((int)v7, "Unknown test event\r\n");
      return v6;
  }
}
// 100BF24C: using guessed type __int16 word_100BF24C;
// 102334E0: using guessed type int dword_102334E0;
// 100356A0: using guessed type char var_304[508];

//----- (10036450) --------------------------------------------------------
signed int __cdecl sub_10036450(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_102334E8 + 580 * sub_100329A0();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_10035170(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (100364D0) --------------------------------------------------------
char **__cdecl sub_100364D0(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_102334E8 + 580 * sub_100329A0();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_10035380((int)v1, a1, (int)".txt");
  return &off_100BE618;
}
// 100BE618: using guessed type char *off_100BE618;

//----- (10036510) --------------------------------------------------------
int (__cdecl *__cdecl sub_10036510(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_100329A0();
  return sub_100355C0((int)&unk_10234040 + 1812 * v1, a1);
}

//----- (10036530) --------------------------------------------------------
const char *sub_10036530()
{
  return "See version control for test execution date";
}

//----- (10036540) --------------------------------------------------------
__int64 sub_10036540()
{
  return 0i64;
}

//----- (10036550) --------------------------------------------------------
const char *sub_10036550()
{
  return "Not Available";
}

//----- (10036560) --------------------------------------------------------
int __usercall sub_10036560@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (100365B0) --------------------------------------------------------
signed int __cdecl sub_100365B0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_100329A0();
  return sub_10035170(a1, a2, (int)&unk_10234040 + 1812 * v2);
}

//----- (100365E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_100365E0(_DWORD *a1))(int)
{
  _DWORD *v1; // esi@1
  unsigned __int8 *v2; // edi@1
  unsigned __int8 *v3; // eax@1

  v1 = a1;
  sub_1003D6E0((int)&a1[151 * (*a1 + 1)]);
  v2 = (unsigned __int8 *)sub_10036550();
  sub_1003D830((int)&v1[151 * (*v1 + 1)], (int)"StartTime", v2);
  sub_1003D830((int)&v1[151 * (*v1 + 1)], (int)"EndTime", v2);
  v3 = (unsigned __int8 *)sub_10036530();
  sub_1003D830((int)&v1[151 * (*v1 + 1)], (int)"ExecutionTime", v3);
  sub_1003D830((int)&v1[151 * (*v1 + 1)], (int)"NumCmds", (unsigned __int8 *)"N/A");
  sub_1003D830((int)&v1[151 * (*v1 + 1)], (int)"NumCmdFaults", (unsigned __int8 *)"N/A");
  sub_1003D870((int)&v1[151 * (*v1 + 1)], (int)"NumCompares", v1[4 * *v1 + 1] + v1[4 * *v1 + 2]);
  sub_1003D870((int)&v1[151 * (*v1 + 1)], (int)"NumCompareFails", v1[4 * *v1 + 1]);
  return sub_1003D6E0((int)&v1[151 * (*v1 + 1)]);
}

//----- (10036700) --------------------------------------------------------
int __usercall sub_10036700@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  _DWORD *v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_1003D390((int)&a2[151 * (*a2 + 1)], (int)sub_10036510, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_10036540();
  v4 = sub_10038830("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_1003D7E0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_10038830("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_1003D7E0((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_1003D7E0((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_1003D760((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_1003D5F0((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_10038830("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10032A50(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_1003D830((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_1003D830((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_1003D760((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_1003D760((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_1003D830((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_100352E0(v3);
  sub_1003D830((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_1003D6E0((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_100387F0(i, &v15, &v16); ++i )
  {
    sub_1003D760((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_1003D830((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_1003D830((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_1003D6E0((int)&a2[151 * (*a2 + 1)]);
  }
  sub_1003D6E0((int)&a2[151 * (*a2 + 1)]);
  sub_1003D760((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_1003D5F0((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = &a2[4 * *a2 + 1];
  *v14 = 0;
  v14[1] = 0;
  v14[2] = 0;
  v14[3] = 0;
  return result;
}
// 10036700: using guessed type char var_103[253];

//----- (10036A80) --------------------------------------------------------
char __cdecl sub_10036A80(int a1, const void **a2, unsigned int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  const char *v7; // ebx@3
  int v8; // esi@4
  int v9; // ST14_4@5
  int v10; // eax@12
  const char *v11; // eax@13
  const char *v12; // eax@15
  int v13; // ST14_4@17
  int v14; // ecx@29
  const void *v15; // ST24_4@43
  int v16; // ST04_4@44
  _BYTE *v17; // eax@87
  _BYTE *v18; // eax@94
  _BYTE *v19; // eax@100
  int v20; // ST20_4@104
  unsigned int v21; // esi@105
  _DWORD *v22; // edx@106
  unsigned int v23; // eax@106
  const char *v24; // ecx@106
  int v25; // esi@110
  int v26; // eax@111
  _BYTE *v27; // ecx@111
  _BYTE *v28; // edx@111
  int v29; // eax@113
  _BYTE *v30; // ecx@113
  _BYTE *v31; // edx@113
  _BYTE *v32; // ecx@115
  _BYTE *v33; // edx@115
  bool v34; // zf@117
  bool v35; // sf@117
  signed int v36; // eax@117
  const char *v37; // eax@129
  const char *v38; // eax@131
  const char *v40; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v41; // [sp-Ch] [bp-120h]@73
  char v42; // [sp+9h] [bp-10Bh]@46
  char v43; // [sp+Ah] [bp-10Ah]@46
  char v44; // [sp+Bh] [bp-109h]@46
  const char *v45; // [sp+Ch] [bp-108h]@91
  signed int v46; // [sp+Ch] [bp-108h]@105
  char v47[255]; // [sp+10h] [bp-104h]@5
  char v48; // [sp+10Fh] [bp-5h]@44

  v4 = sub_100329A0();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_10234040 + 1812 * v4;
  switch ( a1 )
  {
    case 3:
      if ( sub_10034D20(a2, a3) )
      {
        v7 = (const char *)a2[3];
        do
        {
          v5 = sub_10036560(", \t", (int)v7);
          v8 = v5;
          if ( v5 )
          {
            strncpy(v47, v7, v5);
            v9 = (int)&v6[604 * (*(_DWORD *)v6 + 1)];
            v47[v8] = 0;
            sub_1003D760(v9, (int)"Req");
            sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"id", (unsigned __int8 *)v47);
            LOBYTE(v5) = (unsigned int)sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
            v7 += v8;
          }
          else
          {
            ++v7;
          }
        }
        while ( *v7 );
      }
      else if ( sub_10034CF0(a2, a3) )
      {
        if ( sub_10035480((int)v6, 3, 1, 0) )
          sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
        v10 = *((_DWORD *)v6 + 146);
        if ( v10 > 0 )
        {
          *((_DWORD *)v6 + 146) = v10 - 1;
          sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"RangeTested");
          v11 = "true";
          if ( *((_DWORD *)v6 + 144) <= 0 )
            v11 = "false";
          sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Normal", (unsigned __int8 *)v11);
          v12 = "true";
          if ( *((_DWORD *)v6 + 145) <= 0 )
            v12 = "false";
          sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Robustness", (unsigned __int8 *)v12);
          sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
          v13 = (int)&v6[604 * (*(_DWORD *)v6 + 1)];
          *((_DWORD *)v6 + 144) = 0;
          *((_DWORD *)v6 + 145) = 0;
          sub_1003D6E0(v13);
          sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"TestGroup");
        }
        LOBYTE(v5) = (unsigned int)sub_1003D5F0(
                                     (int)&v6[604 * (*(_DWORD *)v6 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10034C30(a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1003D830(
                                     (int)&v6[604 * (*(_DWORD *)v6 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v6 + 146);
      }
      else if ( sub_10034D50(a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1003D830(
                                     (int)&v6[604 * (*(_DWORD *)v6 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10034CC0(a2, a3) )
      {
        if ( sub_10035480((int)v6, 3, 1, 0) )
          sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
        LOBYTE(v5) = sub_100353F0((int)a2, a3, (int)v6);
        if ( (_BYTE)v5 )
          LOBYTE(v5) = sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"TestStep");
      }
      else if ( sub_10034C60(a2, a3) )
      {
        sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Results");
        v14 = (int)&v6[604 * (*(_DWORD *)v6 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_1003D5F0(v14, (int)"success", (unsigned __int8 *)"0");
          sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_1003D5F0(v14, (int)"success", (unsigned __int8 *)&unk_1006C380);
        }
        if ( v6[309] )
        {
          sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
        LOBYTE(v5) = sub_10035480((int)v6, 3, 0, 0);
        if ( (_BYTE)v5 )
          LOBYTE(v5) = (unsigned int)sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
      }
      else
      {
        LOBYTE(v5) = sub_10034C00(a2, a3);
        if ( (_BYTE)v5 )
        {
          if ( !sub_10035530((int)v6) )
            sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"TestStep");
          sub_1003D830((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v5) = sub_10035480((int)v6, 3, 0, 1);
          if ( (_BYTE)v5 )
            LOBYTE(v5) = (unsigned int)sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
        }
      }
      return v5;
    case 4:
      LOBYTE(v5) = sub_10034FB0((int)v6, (int)*a2);
      if ( (_BYTE)v5 )
        LOBYTE(v5) = sub_10036700((char *)a2[1], v6, (int)*a2);
      return v5;
    case 5:
      v15 = *a2;
      LOBYTE(v5) = sub_10034FA0((int)v6);
      if ( !(_BYTE)v5 )
      {
        sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"TestGroup");
        _snprintf(v47, 0x100u, "Test Group: %s", *a2);
        v16 = (int)&v6[604 * (*(_DWORD *)v6 + 1)];
        v48 = 0;
        sub_1003D830(v16, (int)"Method", (unsigned __int8 *)v47);
        LOBYTE(v5) = (unsigned int)sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
      }
      return v5;
    case 6:
      *((_DWORD *)v6 + 144) = 0;
      *((_DWORD *)v6 + 145) = 0;
      *((_DWORD *)v6 + 146) = 0;
      LOBYTE(v5) = sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"TestGroup");
      return v5;
    case 7:
      v42 = 0;
      v43 = 0;
      v44 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v43 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v44 = 1;
LABEL_55:
        v42 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v6 + 146) )
      {
        sub_1003D830(
          (int)&v6[604 * (*(_DWORD *)v6 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_1003D830((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v6 + 146);
      }
      if ( !sub_10035530((int)v6) )
        sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"TestStep");
      if ( sub_10034BA0((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Instruction");
          sub_1003D690((int)&v6[604 * (*(_DWORD *)v6 + 1)], (unsigned __int8 *)a2[3]);
          sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
        }
        ++*((_DWORD *)v6 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_1003D830((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v6 + 144);
      }
      sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Compare");
      if ( sub_100349A0((int)a2, a3) )
      {
        ++*(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4];
        sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8];
        sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v42 )
      {
        sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v44 )
        {
          sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v41 = (unsigned __int8 *)"true";
        v40 = "strict";
      }
      else
      {
        v41 = (unsigned __int8 *)a2[6];
        v40 = "datatype";
      }
      sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)v40, v41);
LABEL_77:
      if ( v6[309] )
      {
        sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Actual");
        if ( v43 )
          sub_1003D640((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v43 )
        {
          sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Expected");
          sub_1003D640((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
          if ( a3 > 9 )
          {
            v17 = a2[9];
            if ( v17 )
            {
              if ( *v17 )
              {
                sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Tolerance");
                sub_1003D640((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v42 )
          {
            v45 = "!";
            if ( memcmp(*a2, "NE", 3u) )
              v45 = (const char *)&unk_10064984;
            if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 && memcmp(a2[9], "0", 2u) )
              _snprintf(v47, 0x100u, "%s%s+/-%s", v45, a2[8], a2[9]);
            else
              _snprintf(v47, 0x100u, "%s%s", v45, a2[8]);
          }
          else if ( a3 > 9 && (v19 = a2[9]) != 0 && *v19 )
          {
            _snprintf(v47, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v47, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v20 = (int)&v6[604 * (*(_DWORD *)v6 + 1)];
          v48 = 0;
          sub_1003D760(v20, (int)"Expected");
          sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"expected", (unsigned __int8 *)v47);
          sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
        }
      }
      v21 = 10;
      v46 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_10035480((int)v6, 8, 1, 0) )
        sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
      sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"RangeTested");
      v37 = "true";
      if ( *((_DWORD *)v6 + 144) <= 0 )
        v37 = "false";
      sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Normal", (unsigned __int8 *)v37);
      v38 = "true";
      if ( *((_DWORD *)v6 + 145) <= 0 )
        v38 = "false";
      sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"Robustness", (unsigned __int8 *)v38);
      sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
      LOBYTE(v5) = (unsigned int)sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
      return v5;
    case 9:
      LOBYTE(v5) = sub_10035210((int)v6);
      return v5;
    case 10:
      LOBYTE(v5) = sub_10035270(v3, (int)v6, (void (__cdecl *)(int))sub_100365E0);
      return v5;
    case 0:
    case 11:
      sub_10035610(v3, (int)v6, (void (__cdecl *)(int))sub_100365E0);
      goto LABEL_139;
    case 1:
      sub_10035130((int)v6);
      goto LABEL_139;
    case 12:
      sub_10035540(v3, (int)v6, (void (__cdecl *)(int))sub_100365E0);
LABEL_139:
      LOBYTE(v5) = 0;
      *((_DWORD *)v6 + 144) = 0;
      *((_DWORD *)v6 + 145) = 0;
      *((_DWORD *)v6 + 146) = 0;
      return v5;
    default:
      return v5;
  }
  do
  {
    v22 = a2[v21];
    v23 = 6;
    v24 = "Info: ";
    do
    {
      if ( *v22 != *(_DWORD *)v24 )
        goto LABEL_110;
      v23 -= 4;
      v24 += 4;
      ++v22;
    }
    while ( v23 >= 4 );
    if ( !v23 )
      goto LABEL_120;
LABEL_110:
    v25 = *(_BYTE *)v22 - *v24;
    if ( *(_BYTE *)v22 == *v24 )
    {
      v26 = v23 - 1;
      v27 = v24 + 1;
      v28 = (char *)v22 + 1;
      if ( !v26
        || (v25 = *v28 - *v27, *v28 == *v27)
        && ((v29 = v26 - 1, v30 = v27 + 1, v31 = v28 + 1, !v29)
         || (v25 = *v31 - *v30, *v31 == *v30)
         && ((v32 = v30 + 1, v33 = v31 + 1, v29 == 1) || (v25 = *v33 - *v32, *v33 == *v32))) )
      {
        v21 = v46;
LABEL_120:
        v36 = 0;
        goto LABEL_121;
      }
    }
    v34 = v25 == 0;
    v35 = v25 < 0;
    v21 = v46;
    v36 = 1;
    if ( v35 || v34 )
      v36 = -1;
LABEL_121:
    if ( v36 )
    {
      sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"PostAnalysis");
      sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"note", (unsigned __int8 *)a2[v21]);
      sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
    }
    else
    {
      sub_1003D760((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"CompareInfo");
      sub_1003D5F0((int)&v6[604 * (*(_DWORD *)v6 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v21] + 6);
      sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
    }
    v46 = ++v21;
  }
  while ( v21 < a3 );
LABEL_125:
  sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
  LOBYTE(v5) = sub_10035480((int)v6, 7, 0, 1);
  if ( (_BYTE)v5 )
    LOBYTE(v5) = (unsigned int)sub_1003D6E0((int)&v6[604 * (*(_DWORD *)v6 + 1)]);
  return v5;
}
// 10036A80: using guessed type char var_104[255];

//----- (100378A0) --------------------------------------------------------
char **__cdecl sub_100378A0(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_10234040 + 1812 * sub_100329A0();
  *((_DWORD *)v1 + 146) = 0;
  sub_10035380((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_1003D390(v2, (int)sub_10036510, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_100BF3A8;
}
// 100BF3A8: using guessed type char *off_100BF3A8;

//----- (10037910) --------------------------------------------------------
char __thiscall sub_10037910(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_102363A8 = sub_100160D0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_102363B0, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_102363B0;
  do
  {
    result = sub_10032540(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 102363A8: using guessed type int dword_102363A8;

//----- (10037980) --------------------------------------------------------
char __usercall sub_10037980@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10013680(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10013680(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (100379C0) --------------------------------------------------------
void *__usercall sub_100379C0@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_102363A8 == 1379255385 )
    goto LABEL_4;
  v4 = sub_1003DF80(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_102363B0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_10032540(a1, (int)&unk_102363B0 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_102363B0 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_102363A8 != 1379255385 )
    result = (void *)sub_1003DF50(v4, 86);
  return result;
}
// 102363A8: using guessed type int dword_102363A8;

//----- (10037A60) --------------------------------------------------------
char __cdecl sub_10037A60(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10037980(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10037AA0) --------------------------------------------------------
bool __cdecl sub_10037AA0(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_100379C0(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10037B00) --------------------------------------------------------
char __cdecl sub_10037B00(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10037980(a2, 1, a3, a1);
  return result;
}

//----- (10037B40) --------------------------------------------------------
char __cdecl sub_10037B40(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_100379C0(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10037B70) --------------------------------------------------------
char __cdecl sub_10037B70(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10037980(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10037BB0) --------------------------------------------------------
char __cdecl sub_10037BB0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_100379C0(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10037BF0) --------------------------------------------------------
char __cdecl sub_10037BF0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10037980(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10037C30) --------------------------------------------------------
bool __cdecl sub_10037C30(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_100379C0(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10037C80) --------------------------------------------------------
char __cdecl sub_10037C80(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10037980(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10037CC0) --------------------------------------------------------
bool __cdecl sub_10037CC0(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_100379C0(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10037D00) --------------------------------------------------------
char __cdecl sub_10037D00(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10037980(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10037D40) --------------------------------------------------------
bool __cdecl sub_10037D40(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_100379C0(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (10037D80) --------------------------------------------------------
char __cdecl sub_10037D80(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10037980(1229, 1, a2, a1);
  return result;
}

//----- (10037DB0) --------------------------------------------------------
char __cdecl sub_10037DB0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100379C0(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10037DE0) --------------------------------------------------------
char __cdecl sub_10037DE0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10037980(1212, 16, a2, a1);
  return result;
}

//----- (10037E10) --------------------------------------------------------
char __cdecl sub_10037E10(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100379C0(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10037E40) --------------------------------------------------------
char __cdecl sub_10037E40(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10037980(2400, 65, a2, a1);
  return result;
}

//----- (10037E70) --------------------------------------------------------
char __cdecl sub_10037E70(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100379C0(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10037EA0) --------------------------------------------------------
char __cdecl sub_10037EA0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10037980(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10037EE0) --------------------------------------------------------
char __cdecl sub_10037EE0(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_100129A0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_100379C0(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10037F30) --------------------------------------------------------
char __cdecl sub_10037F30(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10037980(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (10037F70) --------------------------------------------------------
char __cdecl sub_10037F70(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_100379C0(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (10037FA0) --------------------------------------------------------
char __cdecl sub_10037FA0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10037980(22, 1, a2, a1);
  return result;
}

//----- (10037FD0) --------------------------------------------------------
char __cdecl sub_10037FD0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10037980(832, 4, a2, a1);
  return result;
}

//----- (10038000) --------------------------------------------------------
char __cdecl sub_10038000(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_100379C0(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10038030) --------------------------------------------------------
char __cdecl sub_10038030(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1002E380(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10037EE0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10037EA0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_10037F70(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10037F30(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10037AA0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10037A60(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10037CC0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10037C80(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10037D40(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10037D00(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10037B40(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10037B00(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10037BB0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10037B70(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_10037FA0(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10037E10(v6, a5);
        else
          result = sub_10037DE0(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10037C30(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10037BF0(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10037E70(v6, a5);
        else
          result = sub_10037E40(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10037DB0(v6, a5);
        else
          result = sub_10037D80(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10038000(v6, a5);
        else
          result = sub_10037FD0(v6, a5);
        break;
      default:
        sub_100129A0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 1003E370: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100383D0) --------------------------------------------------------
bool __cdecl sub_100383D0(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_102378F0 != 1379255385 )
    {
      sub_10032520(a1, (int)&byte_102378F8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_102378FD[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_102378FC[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 102378F0: using guessed type int dword_102378F0;

//----- (10038440) --------------------------------------------------------
bool __cdecl sub_10038440(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_102378F0 != 1379255385 )
      sub_10032520(a1, (int)&byte_102378F8[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_1023790C[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102378F0: using guessed type int dword_102378F0;
// 1023790C: using guessed type int dword_1023790C[];

//----- (100384A0) --------------------------------------------------------
bool __cdecl sub_100384A0(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_102378F0 != 1379255385 )
    {
      sub_10032520(a1, (int)&byte_102378F8[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_10237904[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 102378F0: using guessed type int dword_102378F0;
// 10237904: using guessed type int dword_10237904[];

//----- (10038510) --------------------------------------------------------
char __cdecl sub_10038510(char a1, _BYTE *a2)
{
  if ( dword_102378F0 != 1379255385 )
    sub_10032520(a1, (int)&byte_102378F8[24 * (unsigned __int8)a1]);
  *a2 = byte_102378F8[24 * (unsigned __int8)a1];
  return 1;
}
// 102378F0: using guessed type int dword_102378F0;

//----- (10038550) --------------------------------------------------------
char __thiscall sub_10038550(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_102378F0 = sub_100160D0(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_102378F8, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_102378F8;
  do
  {
    result = sub_10032520(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 102378F0: using guessed type int dword_102378F0;

//----- (100385C0) --------------------------------------------------------
char __cdecl sub_100385C0(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1001D0C0(a1);
  v3 = sub_1003F180(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (100385F0) --------------------------------------------------------
char __cdecl sub_100385F0(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1001D0C0(a1);
  v3 = sub_1003F1F0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10038620) --------------------------------------------------------
char __cdecl sub_10038620(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_1001D1B0(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_100384A0(v7, *a4, (int)a5);
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_100383D0(v7, *a4, (int)a5);
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_10038440(v7, *a4, (int)a5);
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10038510(v7, a5);
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_100385F0(v7, (int)a5);
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_100385C0(v7, (int)a5);
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_100129A0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (100387F0) --------------------------------------------------------
char __cdecl sub_100387F0(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_10237948[592 * a1]) || byte_10237998[v3]) )
  {
    *a2 = &byte_10237948[v3];
    *a3 = &byte_10237998[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10038830) --------------------------------------------------------
char *__cdecl sub_10038830(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_10237948;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_10237998[592 * v2];
}

//----- (100388A0) --------------------------------------------------------
char *__usercall sub_100388A0@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (100388D0) --------------------------------------------------------
void __cdecl sub_100388D0(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_10038830(v2 + 3, (int)&unk_10064984);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_100388D0(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (10038990) --------------------------------------------------------
void __cdecl sub_10038990(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  signed int v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  signed int v8; // edx@4
  char v9; // cl@5

  if ( dword_10237940 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_10237940;
    v4 = &byte_10237948[592 * dword_10237940] - a1;
    do
    {
      v5 = *v2;
      v2[v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_10237998[v3];
    v8 = &byte_10237998[v3] - a2;
    do
    {
      v9 = *v6;
      v6[v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_100388D0(v7);
    ++dword_10237940;
  }
}
// 10237940: using guessed type int dword_10237940;

//----- (100389F0) --------------------------------------------------------
void *__cdecl sub_100389F0(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // ecx@3
  char *v6; // edi@4
  char *v7; // esi@4
  char *v8; // eax@4
  const char *v9; // esi@6
  const char *v10; // ebx@6
  char *v11; // edi@6
  char *v12; // eax@6
  char v13; // [sp+4h] [bp-204h]@3

  result = memset(byte_10237948, 0, 0x73A0u);
  dword_10237940 = 0;
  if ( a1 )
  {
    v2 = sub_10039B40(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_10039D20((int)&v13, 512, v2) )
      {
        do
        {
          sub_100388A0(&v13);
          v6 = strstr(&v13, "=");
          v7 = strstr(&v13, "<Var name=\"");
          v8 = strstr(&v13, " value=\"");
          if ( v7 && v8 )
          {
            v9 = v7 + 11;
            v10 = v8 + 8;
            v11 = strchr(v9, 34);
            v12 = strchr(v10, 34);
            if ( v11 )
            {
              if ( v12 )
              {
                *v11 = 0;
                *v12 = 0;
                sub_10038990((char *)v9, (char *)v10);
              }
            }
          }
          else if ( v6 && !strpbrk(&v13, "<>") )
          {
            *v6 = 0;
            sub_10038990(&v13, v6 + 1);
          }
        }
        while ( sub_10039D20((int)&v13, 512, v3) );
      }
      result = (void *)sub_10039AF0(v4, v5, v3);
    }
    else
    {
      result = (void *)sub_10034F20(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 10237940: using guessed type int dword_10237940;

//----- (10038B80) --------------------------------------------------------
int sub_10038B80()
{
  return 0;
}

//----- (10038B90) --------------------------------------------------------
void __cdecl sub_10038B90(int a1)
{
  if ( a1 > 0 )
    exit_0(14);
}

//----- (10038BC0) --------------------------------------------------------
int __cdecl sub_10038BC0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10038BE0) --------------------------------------------------------
bool __cdecl sub_10038BE0(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (10038C10) --------------------------------------------------------
void *__cdecl sub_10038C10(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (10038C50) --------------------------------------------------------
unsigned int __usercall sub_10038C50@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (10038C70) --------------------------------------------------------
int __usercall sub_10038C70@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (10038C90) --------------------------------------------------------
char __cdecl sub_10038C90(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_10038BE0(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_10038BC0(a2);
  }
  return result;
}

//----- (10038CC0) --------------------------------------------------------
signed int __cdecl sub_10038CC0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  unsigned int *v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( v5[1] )
      {
        do
        {
          v10 = sub_10038C50((int)v5, v7, v9);
          v11 = (_BYTE *)sub_10038C50(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_10038C50(a4, v7, v9);
            sub_10038C70(v16, (int)&unk_100BFF48);
          }
          ++v9;
        }
        while ( v9 < v5[1] );
      }
      ++v7;
    }
    while ( v7 < *v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (10038DA0) --------------------------------------------------------
void __cdecl sub_10038DA0(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_10038C50((int)v3, v4, v6);
          v8 = sub_10038C50(a2, v4, v6);
          v9 = sub_10038C50(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (10038E50) --------------------------------------------------------
void *__usercall sub_10038E50@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  unsigned int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  unsigned int v34; // [sp+14h] [bp-Ch]@1
  unsigned int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_10038C50(a1, v31, v4);
      v6 = sub_10038C50(a2, 0, 0);
      sub_10038C70(v5, v6);
      v7 = sub_10038C50(a1, v33, v4);
      v8 = sub_10038C50(a2, *(_DWORD *)a2 - 1, 0);
      sub_10038C70(v7, v8);
      v9 = sub_10038C50(a1, v31, v34 - v4 - 1);
      v10 = sub_10038C50(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_10038C70(v9, v10);
      v11 = sub_10038C50(a1, v33, v34 - v4 - 1);
      v12 = sub_10038C50(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_10038C70(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_10038C50(a2, 0, 1);
    v16 = (void *)sub_10038C50(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_10038C50(a1, a3 + i, v18);
      v20 = sub_10038C50(a2, i, 0);
      sub_10038C70(v19, v20);
      v21 = sub_10038C50(a1, i + a3, v34 - v18 - 1);
      v22 = sub_10038C50(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_10038C70(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_10038C50(a2, i, 1);
    v25 = (void *)sub_10038C50(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_10038C50(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_10038C50(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (100390D0) --------------------------------------------------------
void __cdecl sub_100390D0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_10038C50(a1, v2, v4);
          v6 = sub_10038C50(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (100391A0) --------------------------------------------------------
char __cdecl sub_100391A0(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_10038BE0(a1);
  if ( result )
  {
    result = sub_10038BE0(a4);
    if ( result )
    {
      sub_10038C90(a3, a4);
      sub_10038C10(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (10039210) --------------------------------------------------------
int __usercall sub_10039210@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_10038C10(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_10038E50((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_10038C50((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_10038C50(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_10038C90((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_100391A0(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (10039570) --------------------------------------------------------
int __usercall sub_10039570@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_10038C10(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_10038DA0(v8, a3, (int)&v16);
  sub_10038C10(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_10039210(9u, v7, (int)&v16, (int)&unk_100BFF24, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_10038C50((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_10038C50(a6, v9, v11);
            sub_10038C70(v13, (int)&unk_100BFF48);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_10038C90(a5, (int)&v15);
  sub_10038C90(a5, (int)&v16);
  return v10;
}

//----- (10039680) --------------------------------------------------------
int __cdecl sub_10039680(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_10038C10(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_100390D0(a3, a8);
  if ( a1 )
    result = sub_10039570(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_10038CC0((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (10039810) --------------------------------------------------------
char __cdecl sub_10039810(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  int v6; // edx@6
  int v7; // ecx@6
  char *v8; // ebp@11
  int v9; // esi@11
  unsigned int v10; // ebx@11
  int v11; // edi@11
  char result; // al@20
  char v13; // [sp+8h] [bp-40h]@14
  unsigned int v14; // [sp+Ch] [bp-3Ch]@5
  __int16 v15; // [sp+10h] [bp-38h]@6
  int v16; // [sp+1Ah] [bp-2Eh]@8
  char v17; // [sp+20h] [bp-28h]@9
  int v18; // [sp+24h] [bp-24h]@11
  unsigned int v19; // [sp+28h] [bp-20h]@11
  unsigned __int16 v20; // [sp+2Eh] [bp-1Ah]@10
  char v21; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_10039B40((int)a2, 0);
      v5 = v4;
      v14 = v4;
      if ( v4 )
      {
        if ( sub_10039BA0(&v15, 14, v4) == 14
          && v15 == 19778
          && v16 == 54
          && sub_10039BA0(&v17, 40, v5) == 40
          && v20 == 24 )
        {
          sub_10038C10(v19, v18, 24, a1, a3);
          v8 = *(char **)(a3 + 12);
          v9 = v18 * (((unsigned int)v20 + 7) >> 3);
          v10 = 0;
          v11 = -(v18 * (((unsigned int)v20 + 7) >> 3)) & 3;
          v21 = 1;
          if ( v19 )
          {
            while ( sub_10039BA0(v8, v9, v14) == v9 && (!v11 || sub_10039BA0(&v13, v11, v14) == v11) )
            {
              ++v10;
              v8 += v9;
              if ( v10 >= v19 )
                goto LABEL_18;
            }
            v21 = 0;
          }
LABEL_18:
          v3 = v21;
          v5 = v14;
        }
        sub_10039AF0(v6, v7, v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10039960) --------------------------------------------------------
char __usercall sub_10039960@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  unsigned int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v11; // edx@2
  int v12; // ecx@2
  int v14; // [sp+10h] [bp-40h]@4
  int v15; // [sp+14h] [bp-3Ch]@4
  __int16 v16; // [sp+18h] [bp-38h]@1
  unsigned int v17; // [sp+1Ah] [bp-36h]@1
  __int16 v18; // [sp+1Eh] [bp-32h]@1
  __int16 v19; // [sp+20h] [bp-30h]@1
  int v20; // [sp+22h] [bp-2Eh]@1
  int v21; // [sp+28h] [bp-28h]@1
  int v22; // [sp+2Ch] [bp-24h]@1
  unsigned int v23; // [sp+30h] [bp-20h]@1
  __int16 v24; // [sp+34h] [bp-1Ch]@1
  __int16 v25; // [sp+36h] [bp-1Ah]@1
  int v26; // [sp+38h] [bp-18h]@1
  unsigned int v27; // [sp+3Ch] [bp-14h]@1
  int v28; // [sp+40h] [bp-10h]@1
  int v29; // [sp+44h] [bp-Ch]@1
  int v30; // [sp+48h] [bp-8h]@1
  int v31; // [sp+4Ch] [bp-4h]@1
  char v32; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v27 = v8;
  v17 = v8 + 54;
  v18 = 0;
  v19 = 0;
  v31 = 0;
  v30 = 0;
  v26 = 0;
  v28 = 0;
  v29 = 0;
  v32 = 0;
  v16 = 19778;
  v20 = 54;
  v21 = 40;
  v25 = a2;
  v23 = v5;
  v22 = a1;
  v24 = 1;
  v9 = sub_10039B40(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_10039BC0((int)&v16, 14, v9) == 14 && sub_10039BC0((int)&v21, 40, v10) == 40 )
    {
      v32 = 1;
      v14 = a4;
      v15 = 0;
      if ( v5 )
      {
        while ( sub_10039BC0(v14, v6, v10) == v6 && (!v7 || sub_10039BC0((int)&unk_100C00F0, v7, v10) == v7) )
        {
          v14 += v6;
          if ( ++v15 >= v5 )
          {
            sub_10039AF0(v11, v12, v10);
            return 1;
          }
        }
        v32 = 0;
      }
    }
    sub_10039AF0(v11, v12, v10);
  }
  return v32;
}

//----- (10039AB0) --------------------------------------------------------
char __cdecl sub_10039AB0(int a1, int a2)
{
  char result; // al@2

  if ( sub_10038BE0(a1) )
    result = sub_10039960(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (10039AF0) --------------------------------------------------------
BOOL __usercall sub_10039AF0@<eax>(int a1@<edx>, int a2@<ecx>, unsigned int a3)
{
  j_FIL_vfs_clean_invalidate_cache(a2, a1);
  return sub_1003E3A0(a3) == 0;
}
// 1003E390: using guessed type int __fastcall j_FIL_vfs_clean_invalidate_cache(_DWORD, _DWORD);

//----- (10039B10) --------------------------------------------------------
BOOL __cdecl sub_10039B10(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 1003E400: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (10039B40) --------------------------------------------------------
unsigned int __cdecl sub_10039B40(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10039BA0) --------------------------------------------------------
signed int __cdecl sub_10039BA0(void *a1, int a2, unsigned int a3)
{
  return sub_1003E4B0(a3, a1, a2);
}

//----- (10039BC0) --------------------------------------------------------
int __cdecl sub_10039BC0(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10039BE0) --------------------------------------------------------
char __cdecl sub_10039BE0(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  int v4; // edx@7
  int v5; // ecx@7
  unsigned int v6; // ebp@7
  int v7; // edx@8
  int v8; // ecx@8
  int v9; // esi@8
  bool i; // zf@8
  char v12; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_10039B40((int)a1, 0);
    if ( v3 )
    {
      v6 = sub_10039B40((int)a2, 1);
      if ( v6 )
      {
        v9 = sub_10039BA0(&v12, 512, v3);
        for ( i = v9 == 0; v9 > 0; i = v9 == 0 )
        {
          v9 -= sub_10039BC0((int)&v12, v9, v6);
          if ( !v9 )
            v9 = sub_10039BA0(&v12, 512, v3);
        }
        v2 = i;
        sub_10039AF0(v7, v8, v6);
      }
      sub_10039AF0(v4, v5, v3);
    }
    return v2;
  }
  return 1;
}

//----- (10039D20) --------------------------------------------------------
int __cdecl sub_10039D20(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_10039BA0(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (10039DA0) --------------------------------------------------------
char __cdecl sub_10039DA0(_DWORD *a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  char v3; // al@1
  char result; // al@3
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@2

  v2 = sub_1002E8C0(v1);
  v5 = sub_1002EC00(v2, 1);
  v3 = sub_1001CD60(&v5, 1u, (int)&unk_100C0154, 4, 3, 2);
  v5 = v3;
  if ( v3 != 2 && sub_100136E0(6, (unsigned __int16)word_100C0156[2 * (unsigned __int8)v3], &v6) )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100C0156: using guessed type __int16 word_100C0156[];

//----- (10039E10) --------------------------------------------------------
int __cdecl sub_10039E10(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_100C0ECC[2 * sub_1001CD60(&a1, 1u, (int)&unk_100C0EC8, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_100C0F0C[2 * sub_1001CD60(&a2, 1u, (int)&unk_100C0F08, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_100C0F3C[2 * sub_1001CD60(&a2, 1u, (int)&unk_100C0F38, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_100C0EE4[2 * sub_1001CD60(&a2, 1u, (int)&unk_100C0EE0, 8, 5, 5)];
  }
  return result;
}
// 100C0ECC: using guessed type int dword_100C0ECC[];
// 100C0EE4: using guessed type int dword_100C0EE4[];
// 100C0F0C: using guessed type int dword_100C0F0C[];
// 100C0F3C: using guessed type int dword_100C0F3C[];

//----- (10039EC0) --------------------------------------------------------
bool __usercall sub_10039EC0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_100CD107[44 * a1] - (unsigned __int8)byte_100CD102[44 * a1];
}

//----- (10039EF0) --------------------------------------------------------
char __usercall sub_10039EF0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_10039EC0(a1, a4, a5) )
  {
    v6 = a3
       + sub_10039E10(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_100CD102[44 * a1] - (unsigned __int8)byte_100CD107[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_10039E10(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (10039F90) --------------------------------------------------------
char __cdecl sub_10039F90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002AE70(a1);
  sub_1003E060(v5, (int)&v7, 3684);
  return sub_10039EF0(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (1003A010) --------------------------------------------------------
char __cdecl sub_1003A010(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002AE70(a1);
  sub_1003E060(v5, (int)&v7, 3684);
  return sub_10039EF0(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (1003A090) --------------------------------------------------------
char __cdecl sub_1003A090(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002AE70(a1);
  sub_1003E060(v5, (int)&v7, 3684);
  return sub_10039EF0(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (1003A110) --------------------------------------------------------
char __cdecl sub_1003A110(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_1002AE70(a1);
  sub_1003E060(v5, (int)&v7, 3684);
  return sub_10039EF0(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (1003A190) --------------------------------------------------------
char __cdecl sub_1003A190(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_100129A0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1003A230) --------------------------------------------------------
char __cdecl sub_1003A230(char a1, void *a2)
{
  char result; // al@3

  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  if ( a1 == 3 )
  {
    result = sub_100136E0(0, 170, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_100136E0(0, 171, a2);
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\iop\\iop_gs_intf.c", 123, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1003A290) --------------------------------------------------------
char __cdecl sub_1003A290(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  *(_DWORD *)a2 = 0;
  *((_DWORD *)a2 + 1) = 0;
  *((_DWORD *)a2 + 2) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  if ( a1 == 3 )
  {
    result = sub_100136E0(0, 176, a2);
  }
  else if ( a1 == 4 )
  {
    result = sub_100136E0(0, 183, a2);
  }
  return result;
}

//----- (1003A2E0) --------------------------------------------------------
bool __cdecl sub_1003A2E0(void *a1)
{
  char v1; // cl@1

  v1 = sub_100136E0(1, 1946, a1);
  *((_DWORD *)a1 + 1) /= 0x3E8u;
  return v1 && !sub_1002DE20((int)a1);
}

//----- (1003A320) --------------------------------------------------------
int __cdecl sub_1003A320(char a1)
{
  int result; // eax@2
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( a1 == 1 )
  {
    sub_1003E0E0(10026, (int)&v2, 4);
    result = v2;
  }
  else
  {
    sub_1003E0E0(10027, (int)&v2, 4);
    result = v2;
  }
  return result;
}

//----- (1003A370) --------------------------------------------------------
char __cdecl sub_1003A370(char a1)
{
  return byte_100C2D41[2 * (unsigned __int8)sub_1001CD60(&a1, 1u, (int)&unk_100C2D40, 2, 4, 3)];
}

//----- (1003A3A0) --------------------------------------------------------
char __cdecl sub_1003A3A0(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_100136E0(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_100129A0("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_1003A2E0(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_100136E0(1, 538, a2);
  }
  if ( !v4 || sub_1002DE20((int)v3) )
    return 0;
  return 1;
}

//----- (1003A420) --------------------------------------------------------
int __cdecl sub_1003A420(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_1003A3A0(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1003A470) --------------------------------------------------------
int __cdecl sub_1003A470(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1001CD60(&a1, 1u, (int)&unk_100C5D08, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_100C5D0C + 2 * v1);
  return result;
}
// 100C5D0C: using guessed type void *off_100C5D0C;

//----- (1003A4B0) --------------------------------------------------------
char __cdecl sub_1003A4B0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_102ACCE0)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (1003A500) --------------------------------------------------------
char __cdecl sub_1003A500(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_102ACCE0)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (1003A5B0) --------------------------------------------------------
char __cdecl sub_1003A5B0(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_102ACCE0)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (1003A610) --------------------------------------------------------
char __cdecl sub_1003A610(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_102ACCE0)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 102ACCE0: using guessed type int dword_102ACCE0;

//----- (1003A6E0) --------------------------------------------------------
int __cdecl sub_1003A6E0(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 0, 0, 0);
}

//----- (1003A700) --------------------------------------------------------
signed int __cdecl sub_1003A700(void *a1)
{
  return sub_1001AA90(a1, 0x20u, 0);
}

//----- (1003A720) --------------------------------------------------------
signed int __cdecl sub_1003A720(void *a1)
{
  return sub_1001AA90(a1, 0x1Cu, 0);
}

//----- (1003A740) --------------------------------------------------------
signed int __cdecl sub_1003A740(void *a1)
{
  return sub_1001AA90(a1, 0x10u, 0);
}

//----- (1003A760) --------------------------------------------------------
signed int __cdecl sub_1003A760(void *a1)
{
  return sub_1001AA90(a1, 0xCu, 0);
}

//----- (1003A780) --------------------------------------------------------
signed int __cdecl sub_1003A780(void *a1)
{
  return sub_1001AA90(a1, 8u, 0);
}

//----- (1003A7A0) --------------------------------------------------------
int __cdecl sub_1003A7A0(int a1)
{
  int result; // eax@1

  result = sub_1001AAF0((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_1001AAF0((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_1001AB40((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (1003A7F0) --------------------------------------------------------
signed int __cdecl sub_1003A7F0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001A9D0(a1, 2147483648, 0x7FFFFFFF, 0x7FFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1003A820) --------------------------------------------------------
int __cdecl sub_1003A820(void *a1)
{
  int result; // eax@1

  result = sub_1003A700((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1003A700((char *)a1 + 128);
    if ( !result )
    {
      result = sub_1003A780((char *)a1 + 120);
      if ( !result )
      {
        result = sub_1003A720((char *)a1 + 36);
        if ( !result )
        {
          result = sub_1003A7A0((int)a1 + 168);
          if ( !result )
          {
            result = sub_1003A7A0((int)a1 + 160);
            if ( !result )
            {
              result = sub_1003A7A0((int)a1 + 164);
              if ( !result )
              {
                result = sub_1003A740(a1);
                if ( !result )
                {
                  result = sub_1003A760((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_1003A760((char *)a1 + 24);
                    if ( !result )
                      result = sub_1003A780((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (1003A8F0) --------------------------------------------------------
signed int __cdecl sub_1003A8F0(void *a1)
{
  signed int result; // eax@1

  result = sub_1003A700((char *)a1 + 64);
  if ( !result )
  {
    result = sub_1003A720((char *)a1 + 36);
    if ( !result )
    {
      result = sub_1003A740(a1);
      if ( !result )
      {
        result = sub_1003A760((char *)a1 + 96);
        if ( !result )
        {
          result = sub_1003A760((char *)a1 + 24);
          if ( !result )
            result = sub_1003A780((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (1003A950) --------------------------------------------------------
int __cdecl sub_1003A950(_BYTE *a1)
{
  return sub_1001ABE0(a1, 0, 0xFFFFFFFu, 0, 0);
}

//----- (1003A970) --------------------------------------------------------
signed int __cdecl sub_1003A970(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001AB40(a1, 0, 0xFFFFu, 30, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1003A9A0) --------------------------------------------------------
signed int __cdecl sub_1003A9A0(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_1001AAF0(a1, 0, 0xFFu, 0xFFu, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1003A9D0) --------------------------------------------------------
int __cdecl sub_1003A9D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 4u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1003AA00) --------------------------------------------------------
int __cdecl sub_1003AA00(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 0x7Fu, 0, 0);
}

//----- (1003AA20) --------------------------------------------------------
int __cdecl sub_1003AA20(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AAF0(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1003AA50) --------------------------------------------------------
int __cdecl sub_1003AA50(unsigned __int8 *a1)
{
  return sub_1001AAF0(a1, 0, 3u, 0, 0);
}

//----- (1003AA70) --------------------------------------------------------
signed int __usercall sub_1003AA70@<eax>(void *a1@<eax>, int a2@<esi>)
{
  void *v2; // edi@1
  signed int result; // eax@1
  _BYTE *v4; // ebx@3
  int v5; // [sp+0h] [bp-8h]@0

  v2 = a1;
  result = sub_1001AA90(a1, 0x15u, v5);
  if ( !result || a2 == 2 )
  {
    v4 = (char *)v2 + 21;
    result = sub_1003A9D0((unsigned __int8 *)v2 + 21, a2);
    if ( !result || a2 == 2 )
    {
      sub_1003A970((_BYTE *)v2 + 22, a2);
      result = sub_1001A7A0((_BYTE *)v2 + 58, 0, a2);
      if ( !result || a2 == 2 )
      {
        switch ( *v4 )
        {
          case 0:
            result = sub_1002C660((_BYTE *)v2 + 24, a2);
            if ( !result || a2 == 2 )
            {
              result = sub_1002C630((_BYTE *)v2 + 26, a2);
              goto LABEL_16;
            }
            break;
          case 1:
            result = sub_1002C660((_BYTE *)v2 + 24, a2);
            if ( !result )
            {
              result = sub_1003D8D0((_BYTE *)v2 + 26, a2);
              goto LABEL_16;
            }
            break;
          case 2:
            result = sub_1002C660((_BYTE *)v2 + 24, a2);
            if ( !result )
            {
              result = sub_1001AA90((char *)v2 + 26, 0x1Fu, a2);
              goto LABEL_16;
            }
            break;
          case 3:
            goto LABEL_18;
          default:
            result = sub_1002DB80((unsigned __int8 *)v2 + 24, a2);
LABEL_16:
            if ( !result || a2 == 2 )
            {
LABEL_18:
              if ( *((_BYTE *)v2 + 58) )
              {
                sub_1003A9A0((unsigned __int8 *)v2 + 64, a2);
                result = sub_1003A9A0((unsigned __int8 *)v2 + 65, a2);
                if ( *v4 == 3 )
                  result = -4;
              }
              else
              {
                result = sub_1001AA90((char *)v2 + 68, 0x1Fu, a2);
                if ( !result || a2 == 2 )
                  result = sub_1001AA90((char *)v2 + 99, 0x1Fu, a2);
              }
            }
            break;
        }
      }
    }
  }
  return result;
}

//----- (1003ABD0) --------------------------------------------------------
signed int __cdecl sub_1003ABD0(void *a1, int a2)
{
  return sub_1003AA70(a1, a2);
}

//----- (1003ABE0) --------------------------------------------------------
char sub_1003ABE0()
{
  return 2;
}

//----- (1003ABF0) --------------------------------------------------------
int __cdecl sub_1003ABF0(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_1001CD60(&a1, 1u, (int)&unk_100C7B90, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_100C7B91 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (1003AC40) --------------------------------------------------------
int __cdecl sub_1003AC40(char a1, float a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  unsigned int v6; // esi@7
  int result; // eax@7
  double v8; // st6@11
  unsigned int v9; // ecx@14
  unsigned int v10; // edi@14
  char *v11; // edx@14
  signed int v12; // ebx@14
  int v13; // edx@56
  int v14; // edi@56
  char *v15; // ecx@56
  signed int v16; // ebp@56
  int v17; // ebp@63
  unsigned int v18; // ecx@63
  double v19; // st7@63
  signed int v20; // edi@64
  char *v21; // edx@64
  float *v22; // edx@81
  char v23; // [sp+Fh] [bp-4D9h]@7
  int v24; // [sp+18h] [bp-4D0h]@7
  float v25; // [sp+1Ch] [bp-4CCh]@61
  float v26; // [sp+20h] [bp-4C8h]@7
  float v27; // [sp+24h] [bp-4C4h]@11
  float v28[4]; // [sp+28h] [bp-4C0h]@11
  char v29; // [sp+38h] [bp-4B0h]@64
  float v30; // [sp+278h] [bp-270h]@7
  float v31; // [sp+27Ch] [bp-26Ch]@10
  float v32; // [sp+280h] [bp-268h]@9
  char v33; // [sp+284h] [bp-264h]@14
  char v34; // [sp+4C4h] [bp-24h]@56

  v5 = 0;
  if ( a3 )
    *(float *)a3 = 0.0;
  if ( a4 )
    *(float *)a4 = 0.0;
  if ( a5 )
    *(float *)a5 = 0.0;
  *(float *)&v24 = 9.8999998e24;
  v23 = 0;
  v6 = 0;
  memset(&v26, 0, 0x258u);
  result = sub_1003E040(42065, (int)&v30, 624);
  if ( !a1 )
  {
    if ( v30 == 0.0 )
    {
      v8 = 9.8999998e24;
    }
    else if ( v32 == 9.8999998e24 || v31 == 9.8999998e24 )
    {
      v8 = 9.8999998e24;
    }
    else
    {
      v6 = 1;
      v26 = v30;
      v28[0] = v32;
      v8 = 9.8999998e24;
      v27 = v31;
    }
    v9 = 12 * v6;
    v10 = 0;
    v11 = &v33;
    v12 = 6;
    do
    {
      if ( 0.0 != *(float *)v11
        && *(float *)((char *)&v26 + v10) < (double)*(float *)v11
        && v8 != *((float *)v11 + 2)
        && v8 != *((float *)v11 + 1) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *(float *)v11;
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 2);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 1);
      }
      if ( 0.0 != *((float *)v11 + 3)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 3)
        && v8 != *((float *)v11 + 5)
        && v8 != *((float *)v11 + 4) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 3);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 5);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 4);
      }
      if ( 0.0 != *((float *)v11 + 6)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 6)
        && v8 != *((float *)v11 + 8)
        && v8 != *((float *)v11 + 7) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 6);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 8);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 7);
      }
      if ( 0.0 != *((float *)v11 + 9)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 9)
        && v8 != *((float *)v11 + 11)
        && v8 != *((float *)v11 + 10) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 9);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 11);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 10);
      }
      if ( 0.0 != *((float *)v11 + 12)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 12)
        && v8 != *((float *)v11 + 14)
        && v8 != *((float *)v11 + 13) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 12);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 14);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 13);
      }
      if ( 0.0 != *((float *)v11 + 15)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 15)
        && v8 != *((float *)v11 + 17)
        && v8 != *((float *)v11 + 16) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 15);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 17);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 16);
      }
      if ( 0.0 != *((float *)v11 + 18)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 18)
        && v8 != *((float *)v11 + 20)
        && v8 != *((float *)v11 + 19) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 18);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 20);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 19);
      }
      if ( 0.0 != *((float *)v11 + 21)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 21)
        && v8 != *((float *)v11 + 23)
        && v8 != *((float *)v11 + 22) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 21);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 23);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 22);
      }
      v11 += 96;
      --v12;
    }
    while ( v12 );
    v13 = 12 * v6;
    v14 = 12 * v5;
    v15 = &v34;
    v16 = 1;
    do
    {
      if ( 0.0 != *(float *)v15
        && *(float *)((char *)&v26 + v14) < (double)*(float *)v15
        && v8 != *((float *)v15 + 2)
        && v8 != *((float *)v15 + 1) )
      {
        v14 = v13;
        *(float *)((char *)&v26 + v13) = *(float *)v15;
        ++v6;
        v13 += 12;
        *(float *)((char *)&v25 + v13) = *((float *)v15 + 2);
        *(int *)((char *)&v24 + v13) = *((int *)v15 + 1);
      }
      v15 += 12;
      --v16;
    }
    while ( v16 );
    v17 = 0;
    v18 = 0;
    v19 = a2;
    if ( (signed int)v6 < 4 )
    {
LABEL_80:
      if ( v18 < v6 )
      {
        v22 = &v26 + 3 * v18;
        do
        {
          if ( v23 )
            break;
          if ( v19 == *v22 )
          {
            v23 = 1;
            v17 = v18;
          }
          else
          {
            v25 = *v22 - v19;
            if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
            {
              v17 = v18;
              v24 = LODWORD(v25) & 0x7FFFFFFF;
            }
          }
          ++v18;
          v22 += 3;
        }
        while ( v18 < v6 );
      }
    }
    else
    {
      v20 = 3;
      v21 = &v29;
      while ( !v23 )
      {
        if ( v19 == *((float *)v21 - 6) )
        {
          v17 = v18;
          break;
        }
        v25 = *((float *)v21 - 6) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v18;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 - 3) )
        {
          v17 = v18 + 1;
          break;
        }
        v25 = *((float *)v21 - 3) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 2;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *(float *)v21 )
        {
          v17 = v18 + 2;
          break;
        }
        v25 = *(float *)v21 - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 1;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 + 3) )
        {
          v23 = 1;
          v17 = v20;
        }
        else
        {
          v25 = *((float *)v21 + 3) - v19;
          if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
          {
            v17 = v20;
            v24 = LODWORD(v25) & 0x7FFFFFFF;
          }
        }
        v18 += 4;
        v21 += 48;
        v20 += 4;
        if ( v18 >= v6 - 3 )
          goto LABEL_80;
      }
    }
    if ( a3 )
      *(float *)a3 = sub_1003D900(*(&v26 + 3 * v17));
    if ( a4 )
      *(float *)a4 = v28[3 * v17] * 0.02539999969303608;
    result = a5;
    if ( a5 )
      *(float *)a5 = 0.02539999969303608 * *(&v27 + 3 * v17);
  }
  return result;
}
// 1003AC40: using guessed type float var_4C0[4];

//----- (1003B290) --------------------------------------------------------
double sub_1003B290()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 0.0;
  v2 = 0.0;
  sub_1003E2F0(3875, &v1, 4, &v2);
  return v1;
}

//----- (1003B2C0) --------------------------------------------------------
double __cdecl sub_1003B2C0(int a1, float a2, float a3)
{
  int v3; // ecx@0
  double result; // st7@2

  if ( sub_10015F80(v3) == 24 )
  {
    *(float *)a1 = a2 * 453.5924;
    result = a2;
  }
  else
  {
    *(float *)a1 = a3 * 1000.0;
    result = a3;
  }
  return result;
}

//----- (1003B300) --------------------------------------------------------
char __cdecl sub_1003B300(float *a1, float *a2, float *a3, char a4)
{
  float *v4; // ecx@10
  signed int v5; // edx@10
  double v6; // st7@29
  double v7; // st7@34
  double v8; // st7@37
  double v9; // st6@37
  double v10; // st5@43
  double v11; // rtt@48
  double v12; // st5@48
  double v13; // st7@48
  char result; // al@48
  char v15; // [sp+22h] [bp-3EEh]@1
  char v16; // [sp+23h] [bp-3EDh]@1
  float v17; // [sp+24h] [bp-3ECh]@1
  float v18; // [sp+28h] [bp-3E8h]@1
  float v19; // [sp+2Ch] [bp-3E4h]@1
  float v20; // [sp+30h] [bp-3E0h]@1
  float v21; // [sp+34h] [bp-3DCh]@1
  float v22; // [sp+38h] [bp-3D8h]@1
  int v23; // [sp+3Ch] [bp-3D4h]@1
  int v24; // [sp+40h] [bp-3D0h]@1
  float v25; // [sp+44h] [bp-3CCh]@29
  int v26; // [sp+48h] [bp-3C8h]@10
  char v27; // [sp+4Ch] [bp-3C4h]@10
  char v28; // [sp+68h] [bp-3A8h]@10
  char v29; // [sp+6Ch] [bp-3A4h]@10
  char v30; // [sp+8Ch] [bp-384h]@10
  char v31; // [sp+ACh] [bp-364h]@10
  char v32; // [sp+CCh] [bp-344h]@10
  char v33; // [sp+ECh] [bp-324h]@10
  char v34; // [sp+10Ch] [bp-304h]@10
  char v35; // [sp+12Ch] [bp-2E4h]@10
  char v36; // [sp+14Ch] [bp-2C4h]@10
  char v37; // [sp+16Ch] [bp-2A4h]@10
  char v38; // [sp+18Ch] [bp-284h]@10
  char v39; // [sp+1ACh] [bp-264h]@10
  char v40; // [sp+1CCh] [bp-244h]@10
  char v41; // [sp+1ECh] [bp-224h]@10
  char v42; // [sp+20Ch] [bp-204h]@10
  char v43; // [sp+22Ch] [bp-1E4h]@10
  char v44; // [sp+24Ch] [bp-1C4h]@10
  char v45; // [sp+26Ch] [bp-1A4h]@10
  char v46; // [sp+28Ch] [bp-184h]@10
  char v47; // [sp+2ACh] [bp-164h]@10
  char v48; // [sp+2CCh] [bp-144h]@10
  char v49; // [sp+2ECh] [bp-124h]@10
  char v50; // [sp+30Ch] [bp-104h]@10
  char v51; // [sp+32Ch] [bp-E4h]@10
  char v52; // [sp+34Ch] [bp-C4h]@10
  char v53; // [sp+36Ch] [bp-A4h]@10
  char v54; // [sp+38Ch] [bp-84h]@10
  char v55; // [sp+3ACh] [bp-64h]@10
  char v56; // [sp+3CCh] [bp-44h]@10
  char v57; // [sp+3ECh] [bp-24h]@10

  v20 = 0.0;
  *(float *)&v24 = 0.0;
  *(float *)&v23 = 0.0;
  v21 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v22 = 0.0;
  v16 = 0;
  v17 = 0.0;
  v15 = 0;
  if ( a1 && 9.8999998e24 != *a1 )
    *a1 = 0.0;
  if ( a3 && 9.8999998e24 != *a3 )
    *a3 = 0.0;
  if ( a2 && 9.8999998e24 != *a2 )
    *a2 = 0.0;
  sub_1003B2C0((int)&v26, 5.0, 2.0);
  sub_1003E040(41113, (int)&v15, 1);
  sub_1003E040(9149, (int)&v16, 1);
  sub_1003E040(42004, (int)&v27, 32);
  sub_1003E040(42006, (int)&v29, 32);
  sub_1003E040(42008, (int)&v30, 32);
  sub_1003E040(42010, (int)&v31, 32);
  sub_1003E040(42012, (int)&v32, 32);
  sub_1003E040(42014, (int)&v33, 32);
  sub_1003E040(42016, (int)&v34, 32);
  sub_1003E040(42018, (int)&v35, 32);
  sub_1003E040(42020, (int)&v36, 32);
  sub_1003E040(42022, (int)&v37, 32);
  sub_1003E040(42024, (int)&v38, 32);
  sub_1003E040(42026, (int)&v39, 32);
  sub_1003E040(42028, (int)&v40, 32);
  sub_1003E040(42030, (int)&v41, 32);
  sub_1003E040(42032, (int)&v42, 32);
  sub_1003E040(42034, (int)&v43, 32);
  sub_1003E040(42036, (int)&v44, 32);
  sub_1003E040(42038, (int)&v45, 32);
  sub_1003E040(42040, (int)&v46, 32);
  sub_1003E040(42042, (int)&v47, 32);
  sub_1003E040(42044, (int)&v48, 32);
  sub_1003E040(42046, (int)&v49, 32);
  sub_1003E040(42048, (int)&v50, 32);
  sub_1003E040(42050, (int)&v51, 32);
  sub_1003E040(42052, (int)&v52, 32);
  sub_1003E040(42054, (int)&v53, 32);
  sub_1003E040(42056, (int)&v54, 32);
  sub_1003E040(42058, (int)&v55, 32);
  sub_1003E040(42060, (int)&v56, 32);
  sub_1003E040(42062, (int)&v57, 32);
  v4 = (float *)&v28;
  v5 = 30;
  do
  {
    if ( *((_BYTE *)v4 - 28) == 1 )
    {
      if ( 9.8999998e24 != *(v4 - 1) )
        v20 = *(v4 - 1) + v20;
      if ( a4 )
      {
        if ( 9.8999998e24 != *v4 )
        {
          v22 = *v4 + v22;
          if ( 9.8999998e24 != *v4 )
          {
            if ( 9.8999998e24 != *(v4 - 3) )
              v19 = *v4 * *(v4 - 3) + v19;
            if ( 9.8999998e24 != *(v4 - 2) )
              v18 = *v4 * *(v4 - 2) + v18;
          }
        }
      }
      if ( 9.8999998e24 != *(v4 - 1) )
      {
        if ( 9.8999998e24 != *(v4 - 3) )
          v19 = *(v4 - 3) * *(v4 - 1) + v19;
        if ( 9.8999998e24 != *(v4 - 2) )
          v18 = *(v4 - 2) * *(v4 - 1) + v18;
      }
    }
    v4 += 8;
    --v5;
  }
  while ( v5 );
  if ( v16 && a4 == 2 )
  {
    v25 = sub_10019DD0();
    v21 = sub_1003D900(v25);
    v21 = sub_10041C70(v21, *(float *)&v26);
    sub_1003AC40(0, v25, 0, (int)&v24, (int)&v23);
    *(float *)&v24 = *(float *)&v24 * 39.37007904052734;
    *(float *)&v23 = 39.37007904052734 * *(float *)&v23;
    v6 = v21;
    v18 = v21 * *(float *)&v24 + v18;
    v19 = v21 * *(float *)&v23 + v19;
  }
  else
  {
    v6 = v21;
  }
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v7 = v22 + v20;
    }
    else
    {
      if ( a4 != 2 )
      {
        v8 = 0.0;
        goto LABEL_40;
      }
      v7 = v6 + v20 + v22;
    }
  }
  else
  {
    v7 = v20;
  }
  v17 = v7;
  v8 = 0.0;
  v9 = v17;
  if ( v17 >= 0.0 )
    goto LABEL_41;
  v17 = 0.0;
LABEL_40:
  v9 = v17;
LABEL_41:
  if ( a1 )
    *a1 = v9;
  v10 = 0.02539999969303608;
  if ( a3 )
  {
    if ( v9 > v8 )
      *a3 = v18 / v9 * 0.02539999969303608;
    v10 = 0.02539999969303608;
  }
  if ( a2 )
  {
    v11 = v10;
    v12 = v8;
    v13 = v11;
    result = v15;
    if ( v12 < v9 )
      *a2 = v13 * (v19 / v9);
  }
  else
  {
    result = v15;
  }
  return result;
}

//----- (1003B890) --------------------------------------------------------
int __cdecl sub_1003B890(char a1)
{
  return sub_1001CD60(&a1, 1u, (int)&unk_100C8278, 8, 2, 2);
}

//----- (1003B8B0) --------------------------------------------------------
BOOL __cdecl sub_1003B8B0(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_10032790(a1);
  return sub_100136E0(0, 604, a2) && sub_10013080(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (1003B910) --------------------------------------------------------
int __usercall sub_1003B910@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_1003B890(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100C827C[2 * v1];
  return result;
}
// 100C827C: using guessed type int dword_100C827C[];

//----- (1003B940) --------------------------------------------------------
BOOL __cdecl sub_1003B940(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_1003B910(a1);
  return sub_1003E040(v2, a2, 16) == 0;
}

//----- (1003B970) --------------------------------------------------------
int __cdecl sub_1003B970(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_1003B940(a1, (int)a5);
  else
    result = sub_1003B8B0(a1, a5);
  return result;
}

//----- (1003B9A0) --------------------------------------------------------
char __cdecl sub_1003B9A0(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10013710(1, 1947, a1, (int)&v3);
}

//----- (1003B9C0) --------------------------------------------------------
BOOL __cdecl sub_1003B9C0(int a1)
{
  return sub_1003E040(6792, a1, 284) == 0;
}

//----- (1003B9E0) --------------------------------------------------------
char __cdecl sub_1003B9E0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_1003B9C0((int)a5);
  else
    result = sub_1003B9A0(a5);
  return result;
}

//----- (1003BA10) --------------------------------------------------------
bool __cdecl sub_1003BA10(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_1003E040((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (1003BA50) --------------------------------------------------------
signed int __usercall sub_1003BA50@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (1003BA70) --------------------------------------------------------
bool __cdecl sub_1003BA70(char a1, void *a2)
{
  int v2; // esi@1
  bool result; // al@5
  void *v4; // ecx@6
  int v5; // [sp+Ch] [bp-28h]@4
  char v6; // [sp+10h] [bp-24h]@2
  int v7; // [sp+24h] [bp-10h]@3
  __int16 v8; // [sp+28h] [bp-Ch]@8
  void *v9; // [sp+2Ch] [bp-8h]@8

  v2 = sub_1003BA50(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online()) == v2
    && sub_10013080(1, 0x6ACu, (int)&v6)
    && v7 == v2
    && sub_10013710(1, 1708, a2, (int)&v5) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_1003BA10(a1, a2);
  }
  else
  {
    v9 = sub_1001D4B0(v4);
    v8 = 1708;
    sub_100131E0(1, 0, &v8, 0, 8, 1);
    sub_10013320(1, 0, v2);
    result = 0;
  }
  return result;
}
// 1003E370: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (1003BB60) --------------------------------------------------------
bool __cdecl sub_1003BB60(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_1003BA10(a1, a5);
  else
    result = sub_1003BA70(a1, a5);
  return result;
}

//----- (1003BB90) --------------------------------------------------------
BOOL __cdecl sub_1003BB90(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (1003BBA0) --------------------------------------------------------
BOOL __usercall sub_1003BBA0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_1003BB90(a1) && *v2 < 3u && a2 == 24;
}

//----- (1003BBD0) --------------------------------------------------------
bool __cdecl sub_1003BBD0(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_1003BB90(a1) )
    {
      v6 = 10 * v5;
      if ( sub_1002E4F0((unsigned __int8)byte_100C9628[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_100136E0(1, (unsigned __int16)word_100C9620[v6], &Tm.tm_mon) || sub_1002DDD0((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_1003A420(a1, &v15) || v15 != dword_100C9640[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_100136E0(1, (unsigned __int16)word_100C9624[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 100C9620: using guessed type __int16 word_100C9620[];
// 100C9624: using guessed type __int16 word_100C9624[];
// 100C9640: using guessed type int dword_100C9640[];

//----- (1003BD80) --------------------------------------------------------
bool __cdecl sub_1003BD80(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_1003BB90(a1) )
    result = sub_1003E040((unsigned __int16)word_100C962A[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 100C962A: using guessed type __int16 word_100C962A[];

//----- (1003BDC0) --------------------------------------------------------
bool __cdecl sub_1003BDC0(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_1003A370(a1);
  if ( !(unsigned __int8)sub_1003BBA0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_1003BBD0(v9, a3, *a4, (int)a5);
  if ( sub_1002E4F0((unsigned __int8)byte_100C9628[20 * v6], (bool *)&v8) && v8 && sub_1003BD80(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 1003BDC0: using guessed type int var_20[7];

//----- (1003BEB0) --------------------------------------------------------
char __cdecl sub_1003BEB0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_10241580, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_100129A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_100325C0(a1, (int)byte_10241580);
    v3 = 4 * a2 - 64;
    v4 = byte_10241581[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_10241580[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (1003BF50) --------------------------------------------------------
bool __cdecl sub_1003BF50(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_10241580, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_100129A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_100325C0(a1, (int)byte_10241580);
    v3 = (char *)&unk_10241620 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (1003BFD0) --------------------------------------------------------
char __cdecl sub_1003BFD0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10241580, 0, 0x890u);
  sub_100325C0(a1, (int)byte_10241580);
  if ( a2 > 0x10u )
  {
    sub_100129A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_102418F0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_102418F4[2 * a2];
    result = 1;
  }
  return result;
}
// 102418F0: using guessed type int dword_102418F0[];
// 102418F4: using guessed type int dword_102418F4[];

//----- (1003C040) --------------------------------------------------------
char __cdecl sub_1003C040(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_100136E0(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_100136E0(0, 572, a2);
    }
    else
    {
      sub_100129A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_100136E0(0, 226, a2);
  }
  return result;
}

//----- (1003C0C0) --------------------------------------------------------
char __cdecl sub_1003C0C0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_10241580, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_100129A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1003C040(a1, byte_10241580);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_10241581[v4];
    *(_BYTE *)a3 = byte_10241580[v4];
  }
  return result;
}

//----- (1003C140) --------------------------------------------------------
char __cdecl sub_1003C140(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_10241580, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_100129A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_1003C040(a1, byte_10241580);
    v4 = (char *)&unk_10241620 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (1003C1C0) --------------------------------------------------------
char __cdecl sub_1003C1C0(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_10241580, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_1003C040(a1, byte_10241580);
    *(_DWORD *)a3 = dword_102418F0[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_102418F4[2 * a2];
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 102418F0: using guessed type int dword_102418F0[];
// 102418F4: using guessed type int dword_102418F4[];

//----- (1003C230) --------------------------------------------------------
char __cdecl sub_1003C230(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003D980(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_1003BFD0(v6, *a4, a5);
    else
      result = sub_1003C1C0(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_1003BEB0(v6, *a4, a5);
    else
      result = sub_1003C0C0(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_100129A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_1003BF50(v6, *a4, a5);
    else
      result = sub_1003C140(v6, *a4, a5);
  }
  return result;
}

//----- (1003C340) --------------------------------------------------------
char __cdecl sub_1003C340(char a1, void *a2)
{
  return sub_100136E0(6, (unsigned __int16)word_100CA16A[8 * (unsigned __int8)a1], a2);
}
// 100CA16A: using guessed type __int16 word_100CA16A[];

//----- (1003C360) --------------------------------------------------------
bool __cdecl sub_1003C360(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_1003E040(dword_100CA170[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100CA170: using guessed type int dword_100CA170[];

//----- (1003C3A0) --------------------------------------------------------
char __cdecl sub_1003C3A0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_1003D9C0(a1);
  if ( a2 )
    result = sub_1003C360(v6, (char *)a5);
  else
    result = sub_1003C340(v6, a5);
  return result;
}

//----- (1003C3E0) --------------------------------------------------------
BOOL sub_1003C3E0()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_1002E430(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (1003C440) --------------------------------------------------------
char __cdecl sub_1003C440(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_100136E0(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_1003C3E0() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_1002D3C0((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (1003C530) --------------------------------------------------------
BOOL __cdecl sub_1003C530(int a1, int a2)
{
  return sub_1003E040(6200, a2, 60) == 0;
}

//----- (1003C550) --------------------------------------------------------
char __cdecl sub_1003C550(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1003C530(a1, (int)a5);
  }
  else
  {
    result = sub_1003C440(a1, a5);
  }
  return result;
}

//----- (1003C590) --------------------------------------------------------
char __cdecl sub_1003C590(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_100136E0(2, 284, &v6) || sub_1002DB10((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (1003C640) --------------------------------------------------------
BOOL __cdecl sub_1003C640(int a1, int a2)
{
  return sub_1003E040(6169, a2, 40) == 0;
}

//----- (1003C660) --------------------------------------------------------
char __cdecl sub_1003C660(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_1003C640(a1, a5);
  }
  else
  {
    result = sub_1003C590(a1, a5);
  }
  return result;
}

//----- (1003C6A0) --------------------------------------------------------
char __cdecl sub_1003C6A0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_100136E0(2, 363, a1);
}

//----- (1003C6C0) --------------------------------------------------------
char __cdecl sub_1003C6C0(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_1003E040(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (1003C810) --------------------------------------------------------
char __cdecl sub_1003C810(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_1003C6C0(a5);
      else
        result = sub_1003C6A0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_1003C6C0(&unk_10241E10);
      else
        v7 = sub_1003C6A0(&unk_10241E10);
      v8 = v7;
      memcpy(a5, (char *)&unk_10241E10 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_1003C6C0(&unk_10241E10);
      else
        v9 = sub_1003C6A0(&unk_10241E10);
      v10 = v9;
      memcpy(a5, (char *)&unk_10244D18 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_1003C6C0(&unk_10241E10);
      else
        v11 = sub_1003C6A0(&unk_10241E10);
      v12 = v11;
      memcpy(a5, (char *)&unk_10245218 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_1003C6C0(&unk_10241E10);
      else
        v13 = sub_1003C6A0(&unk_10241E10);
      v14 = v13;
      memcpy(a5, &unk_102452C0, a6);
      result = v14;
      break;
    default:
      sub_100129A0("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1003C9B0) --------------------------------------------------------
char __cdecl sub_1003C9B0(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1003C9F0) --------------------------------------------------------
__int16 __usercall sub_1003C9F0@<ax>(unsigned __int8 a1@<al>)
{
  return word_100CCD20[a1];
}
// 100CCD20: using guessed type __int16 word_100CCD20[];

//----- (1003CA00) --------------------------------------------------------
char __cdecl sub_1003CA00(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_1003C9F0(a1);
    if ( sub_10013710(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1003CAD0) --------------------------------------------------------
char __cdecl sub_1003CAD0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_1003C9B0(a1);
  if ( a3 != 11 )
  {
    sub_100129A0("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_1003CA00(v7, a5);
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1003CB50) --------------------------------------------------------
char __cdecl sub_1003CB50(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_100129A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10013710(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10013710(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_1002E370((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_102452E8, (char *)&v6 + 1, 0x20u);
      byte_102452E0 = 1;
      byte_102452E1 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_10245308, (char *)&v6 + 1, 0x20u);
    byte_102452E1 = 1;
    byte_102452E2 = 1;
    return result;
  }
  return 0;
}
// 102452E0: using guessed type char byte_102452E0;
// 102452E1: using guessed type char byte_102452E1;
// 102452E2: using guessed type char byte_102452E2;

//----- (1003CC80) --------------------------------------------------------
char __cdecl sub_1003CC80(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10032570(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_100129A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (1003CD00) --------------------------------------------------------
bool __cdecl sub_1003CD00(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_102452E0 == 0;
    qmemcpy(a1, &unk_102452E8, 0x40u);
    result = !v1 && byte_102452E2;
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 102452E0: using guessed type char byte_102452E0;
// 102452E2: using guessed type char byte_102452E2;

//----- (1003CD50) --------------------------------------------------------
char __cdecl sub_1003CD50(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_100129A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_1002E830(15);
    v3 = 555;
  }
  else
  {
    result = sub_1002E830(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_102452E1 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_100131E0(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 1003E370: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 102452E1: using guessed type char byte_102452E1;

//----- (1003CE30) --------------------------------------------------------
__int16 __usercall sub_1003CE30@<ax>(unsigned __int8 a1@<al>)
{
  return word_100CCE30[a1];
}
// 100CCE30: using guessed type __int16 word_100CCE30[];

//----- (1003CE40) --------------------------------------------------------
char __cdecl sub_1003CE40(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_1003CE30(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_100131E0(1, v3, &v5, 1, HIWORD(v5) + 4, 1);
  return sub_10013320(1, v3, 0xFFFFFFF);
}

//----- (1003CED0) --------------------------------------------------------
char __cdecl sub_1003CED0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_100129A0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_102452E1 != 0 ? 25 : 11;
      sub_1003CE40(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_1003CE40(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 102452E1: using guessed type char byte_102452E1;

//----- (1003CF90) --------------------------------------------------------
bool __cdecl sub_1003CF90(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_1003CC80(a1, (int)a5);
    return 1;
  }
  if ( byte_102452E1 )
  {
    if ( sub_1003CB50(a1, &v6, 1) )
    {
LABEL_14:
      byte_102452E3 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_102452E3 >= 5u )
    {
      byte_102452E0 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_1003CB50(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_102452E3 >= 5u )
    {
      byte_102452E2 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_1003CC80(a1, (int)&v6);
    sub_1003CD50(a1, (int)&v6);
  }
  sub_1003CED0(a1, 11);
  return sub_1003CD00(a5);
}
// 1003E370: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 102452E0: using guessed type char byte_102452E0;
// 102452E1: using guessed type char byte_102452E1;
// 102452E2: using guessed type char byte_102452E2;
// 102452E3: using guessed type char byte_102452E3;

//----- (1003D090) --------------------------------------------------------
int __cdecl sub_1003D090(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1003D0A0) --------------------------------------------------------
int __cdecl sub_1003D0A0(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 1003EF80: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 1003EF90: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 1003EFA0: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 1003EFB0: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 1003F060: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (1003D1E0) --------------------------------------------------------
char __usercall sub_1003D1E0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (1003D2B0) --------------------------------------------------------
signed int __cdecl sub_1003D2B0(_DWORD *a1, char *a2)
{
  int *v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *v2;
    v10 = *v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_1003EFC0(v2[1], (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_1003D1E0((int)v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)v2 + 15, (char)a1);
          v3 = v10;
          *a2 = v8;
          v2[6] += v6;
        }
        else
        {
          v7 = v2[1];
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_1003D0A0((int)v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 1003F070: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (1003D390) --------------------------------------------------------
int __cdecl sub_1003D390(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (1003D3B0) --------------------------------------------------------
int (__cdecl *__usercall sub_1003D3B0@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (1003D3C0) --------------------------------------------------------
int __usercall sub_1003D3C0@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (1003D5F0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003D5F0(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1003D3B0(a1, (int)" ");
  sub_1003D3B0(a1, a2);
  sub_1003D3B0(a1, (int)&unk_100CD0A4);
  v3 = sub_1003D3C0(a3, a1);
  sub_1003D3B0(a1, v3);
  return sub_1003D3B0(a1, (int)&unk_100CD0A0);
}

//----- (1003D640) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003D640(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1003D3B0(a1, (int)" ");
  sub_1003D3B0(a1, a2);
  sub_1003D3B0(a1, (int)&unk_100CD0AC);
  v3 = sub_1003D3C0(a3, a1);
  sub_1003D3B0(a1, v3);
  return sub_1003D3B0(a1, (int)&unk_100CD0A8);
}

//----- (1003D690) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003D690(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_1003D3B0(a1, (int)&unk_100CD0B0);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_1003D3C0(a2, a1);
    result = sub_1003D3B0(a1, v3);
  }
  return result;
}

//----- (1003D6E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003D6E0(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_100CD0B8;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_1003D3B0(a1, dword_100CD00C[(signed int)result]);
      sub_1003D3B0(a1, (int)&unk_100CD0B4);
      sub_1003D3B0(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_100CD0B0;
    }
    result = sub_1003D3B0(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_1003D3B0(a1, (int)&word_100BF24C);
  }
  return result;
}
// 100BF24C: using guessed type __int16 word_100BF24C;
// 100CD00C: using guessed type int dword_100CD00C[];

//----- (1003D760) --------------------------------------------------------
int __cdecl sub_1003D760(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_1003D3B0(a1, (int)&unk_100CD0B0);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_1003D3B0(a1, *((_DWORD *)&off_100CD010 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_1003D3B0(a1, (int)&unk_100CD0BC);
  sub_1003D3B0(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (1003D7E0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003D7E0(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_1003D3C0(a2, a1);
    sub_1003D3B0(a1, v3);
    result = sub_1003D3B0(a1, (int)&word_100BF24C);
  }
  else
  {
    sub_1003D3B0(a1, (int)a2);
    result = sub_1003D3B0(a1, (int)&word_100BF24C);
  }
  return result;
}
// 100BF24C: using guessed type __int16 word_100BF24C;

//----- (1003D830) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003D830(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_1003D760(a1, a2);
  if ( a3 && *a3 )
    sub_1003D690(a1, a3);
  return sub_1003D6E0(a1);
}

//----- (1003D870) --------------------------------------------------------
int (__cdecl *__cdecl sub_1003D870(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_1003D830(a1, a2, (unsigned __int8 *)&v4);
}

//----- (1003D8D0) --------------------------------------------------------
int __cdecl sub_1003D8D0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_1001AB40(a1, 0, 0xFE2u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1003D900) --------------------------------------------------------
double __cdecl sub_1003D900(float a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@2
  double result; // st7@4
  float v5; // [sp+8h] [bp+4h]@4
  float v6; // [sp+8h] [bp+4h]@5
  float v7; // [sp+8h] [bp+4h]@6
  float v8; // [sp+8h] [bp+4h]@7

  v2 = (unsigned __int8)sub_10015EB0(v1);
  if ( (_BYTE)v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v6 = (float)778.90802 * a1;
        result = v6;
      }
      else
      {
        v5 = (float)850.76703 * a1;
        result = v5;
      }
    }
    else
    {
      v7 = (float)804.0722 * a1;
      result = v7;
    }
  }
  else
  {
    v8 = (float)718.95856 * a1;
    result = v8;
  }
  return result;
}

//----- (1003D980) --------------------------------------------------------
char __cdecl sub_1003D980(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_100129A0("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (1003D9C0) --------------------------------------------------------
char __cdecl sub_1003D9C0(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003D9E0) --------------------------------------------------------
void __cdecl sub_1003D9E0(int a1, int a2, int a3, float *a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@3
  int v7; // ebx@5
  float *v8; // eax@9
  char v9; // [sp+10h] [bp-8h]@5

  v5 = a1;
  *(float *)&a1 = *(double *)a1;
  *(float *)&a1 = *(float *)&a1 - 6.283185005187988;
  a1 &= 0x7FFFFFFFu;
  if ( *(float *)&a1 < 0.1
    || (*(float *)&a1 = *(double *)(v5 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (v6 = a2,
        *(float *)&a1 = *(double *)a2,
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (*(float *)&a1 = *(double *)(a2 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1) )
  {
    v8 = (float *)a5;
    *a4 = 9.9999996e24;
    *v8 = 9.9999996e24;
  }
  else
  {
    sub_10041C50(v5, (int)&v9);
    v7 = a3;
    if ( (_BYTE)a3 )
      *(float *)&a1 = sub_1003FAE0(a3);
    else
      sub_10012750(&v9, &a1);
    sub_1003DB10(v5, v6, v7, (int)a4, a5, *(float *)&a1);
  }
}
// 10012750: using guessed type _DWORD __cdecl sub_10012750(_DWORD, _DWORD);

//----- (1003DB10) --------------------------------------------------------
void __cdecl sub_1003DB10(int a1, int a2, int a3, int a4, int a5, float a6)
{
  double v6; // st7@4
  int v7; // [sp+18h] [bp+Ch]@6
  float v8; // [sp+18h] [bp+Ch]@6

  sub_10040BC0(a1, a2, (float *)a4, (float *)a5);
  if ( (_BYTE)a3 != 1 && *(float *)a4 > 25.0 )
  {
    if ( (_BYTE)a3 )
      v6 = sub_1003FAE0(a3);
    else
      v6 = a6;
    *(float *)&v7 = v6;
    v8 = *(float *)a5 - *(float *)&v7;
    *(float *)a5 = v8;
    *(float *)a5 = sub_10041C10(v8);
  }
}

//----- (1003DB80) --------------------------------------------------------
void __cdecl sub_1003DB80(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_1003F290(a1, a2);
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420E8: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (1003DBB0) --------------------------------------------------------
int __cdecl sub_1003DBB0(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420EE: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (1003DBD0) --------------------------------------------------------
int __cdecl sub_1003DBD0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420F4: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (1003DBF0) --------------------------------------------------------
int sub_1003DBF0()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 100420FA: using guessed type int TSK_pvg_get_id(void);

//----- (1003DC10) --------------------------------------------------------
int __cdecl sub_1003DC10(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042100: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (1003DC40) --------------------------------------------------------
__int16 __cdecl sub_1003DC40(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042106: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (1003DC60) --------------------------------------------------------
int __cdecl sub_1003DC60(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_smphr_stats(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 1004210C: using guessed type int __cdecl TSK_pvg_get_smphr_stats(_DWORD, _DWORD);

//----- (1003DC90) --------------------------------------------------------
int sub_1003DC90()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042112: using guessed type int TSK_pvg_get_timer(void);

//----- (1003DCB0) --------------------------------------------------------
int __cdecl sub_1003DCB0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042118: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003DCF0) --------------------------------------------------------
int __cdecl sub_1003DCF0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042124: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003DD20) --------------------------------------------------------
int __cdecl sub_1003DD20(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 1004212A: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (1003DD40) --------------------------------------------------------
int __cdecl sub_1003DD40(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042130: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (1003DD60) --------------------------------------------------------
signed int __cdecl sub_1003DD60(int a1, int a2)
{
  int v2; // esi@4
  signed int result; // eax@4

  if ( a2 && (!*(_DWORD *)(a2 + 4) || *(_DWORD *)a2) )
  {
    SYS_enter_krnl();
    v2 = TSK_pvg_reply_msg(a1, a2);
    SYS_exit_krnl();
    result = v2;
  }
  else
  {
    result = 20;
  }
  return result;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042136: using guessed type int __cdecl TSK_pvg_reply_msg(_DWORD, _DWORD);

//----- (1003DDA0) --------------------------------------------------------
int __cdecl sub_1003DDA0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 1004213C: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (1003DDD0) --------------------------------------------------------
int __cdecl sub_1003DDD0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042142: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (1003DE00) --------------------------------------------------------
int __cdecl sub_1003DE00(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042148: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (1003DE30) --------------------------------------------------------
signed int __cdecl sub_1003DE30(int a1, int a2)
{
  signed int result; // eax@3
  char v3; // [sp+0h] [bp-10h]@1
  int v4; // [sp+8h] [bp-8h]@4
  char v5; // [sp+Ch] [bp-4h]@3

  if ( sub_1003DC60(a1, (int)&v3) )
  {
    result = -1;
  }
  else if ( a2 == -2 )
  {
    result = v5 & 1;
  }
  else
  {
    result = v4 == a2;
  }
  return result;
}

//----- (1003DE80) --------------------------------------------------------
int __cdecl sub_1003DE80(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 1004214E: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (1003DEA0) --------------------------------------------------------
char __cdecl sub_1003DEA0(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_1003DC90();
  if ( sub_1003DD20(a1) == 5 )
    goto LABEL_4;
  while ( sub_1003DC90() < v2 )
  {
    sub_1003DE80(20);
    if ( sub_1003DD20(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_1003DD20(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (1003DF10) --------------------------------------------------------
int __cdecl sub_1003DF10(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_1003DBF0();
    sub_1003DCB0((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042154: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (1003DF50) --------------------------------------------------------
int __cdecl sub_1003DF50(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_1003DD40(a2);
  return result;
}
// 1006A470: using guessed type void *tsk_app_hdr_ptr;

//----- (1003DF80) --------------------------------------------------------
int __cdecl sub_1003DF80(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_1003DDA0(a1, a2);
  return result;
}
// 1006A470: using guessed type void *tsk_app_hdr_ptr;

//----- (1003DFA0) --------------------------------------------------------
bool __cdecl sub_1003DFA0(int a1)
{
  return sub_1003DE30(a1, -2) > 0;
}

//----- (1003DFC0) --------------------------------------------------------
int __cdecl sub_1003DFC0(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_100D9840[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_100D9844[2 * v1];
}
// 100D9840: using guessed type int dword_100D9840[];
// 100D9844: using guessed type int dword_100D9844[];

//----- (1003E000) --------------------------------------------------------
int __cdecl sub_1003E000(int a1, int a2, int a3)
{
  return reg_tag_dflt(a1 | 0x20000, a2, a3, 0);
}
// 1004215A: using guessed type int __cdecl reg_tag_dflt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E040) --------------------------------------------------------
int __cdecl sub_1003E040(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 1004216C: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E060) --------------------------------------------------------
char __cdecl sub_1003E060(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1003E040(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_100129A0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (1003E0A0) --------------------------------------------------------
int __cdecl sub_1003E0A0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_1003E040(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (1003E0E0) --------------------------------------------------------
int __cdecl sub_1003E0E0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_1003E040(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (1003E110) --------------------------------------------------------
int __cdecl sub_1003E110(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 10042172: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E130) --------------------------------------------------------
int __cdecl sub_1003E130(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_1003E110(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_1003F2C0() )
  {
    v4 = sub_1003DFC0(a1);
    if ( v4 != 42066 )
      v3 = sub_1003E110(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 1003F2C0: using guessed type int sub_1003F2C0(void);

//----- (1003E190) --------------------------------------------------------
int __cdecl sub_1003E190(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_1003E130(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_100129A0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (1003E1D0) --------------------------------------------------------
char __cdecl sub_1003E1D0(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_1003E110(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_100129A0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (1003E210) --------------------------------------------------------
int __cdecl sub_1003E210(int a1, unsigned __int8 a2)
{
  int result; // eax@2
  int v3; // [sp+4h] [bp-10h]@1
  int v4; // [sp+8h] [bp-Ch]@1
  int v5; // [sp+Ch] [bp-8h]@1

  memset(&unk_102464E8, 0, 0x5800u);
  v3 = 0;
  v4 = 0;
  v5 = 0;
  if ( a2 >= 3u )
    return -31;
  j_reg_get_tag_hdr(&v3, a1, a1);
  if ( HIWORD(v5) > 0x5800u )
    return -47;
  if ( !a2 )
    goto LABEL_8;
  if ( a2 != 2 )
  {
    if ( a2 == 1 && !(_BYTE)v3 )
      goto LABEL_8;
    return 0;
  }
  if ( !(_BYTE)v3 )
    return 0;
LABEL_8:
  sub_1003F2D0(a1, &unk_102464E8);
  if ( (unsigned __int16)a1 / 0x3E8u == 6 )
    result = sub_1003E130(a1, (int)&unk_102464E8, *(int *)((char *)&v5 + 2));
  else
    result = sub_1003E110(a1, (int)&unk_102464E8, *(int *)((char *)&v5 + 2));
  return result;
}
// 1003E020: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);

//----- (1003E2F0) --------------------------------------------------------
int __cdecl sub_1003E2F0(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_1003E040(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_1003E110(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (1003E3A0) --------------------------------------------------------
signed int __cdecl sub_1003E3A0(unsigned int a1)
{
  signed int result; // eax@7
  int v2; // eax@8
  int v3; // edx@9
  unsigned int v4; // [sp+4h] [bp+4h]@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return FIL_vfs_close();
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_100558A0(a1);
    if ( v4 && *(_DWORD *)(v4 + 732) )
    {
      --*(_DWORD *)(*(_DWORD *)(v4 + 732) + 124);
      if ( *(_BYTE *)(v4 + 8) )
        exit_1(v4);
      sub_1005D660(v4 + 116);
      result = 0;
      *(_DWORD *)v4 = -858993460;
    }
    else
    {
      result = -6;
    }
    return result;
  }
  if ( !a1 || (a1 & 3) != 2 )
    return FIL_vfs_close();
  v2 = 0;
  if ( !dword_10258D50 )
    goto LABEL_11;
  while ( 1 )
  {
    v3 = dword_10258D58[v2];
    if ( *(_DWORD *)v3 == a1 )
      break;
    if ( ++v2 >= (unsigned int)dword_10258D50 )
      goto LABEL_11;
  }
  if ( v2 != -1 )
  {
    sub_1003F590(
      v2,
      *(_DWORD *)(dword_10258D58[v2] + 12),
      *(_DWORD *)(v3 + 16),
      *(_BYTE *)(v3 + 32),
      *(_WORD *)(v3 + 20),
      *(_DWORD *)(v3 + 4));
    result = sub_1003E3A0(a1 & 0xFFFFFFFC);
  }
  else
  {
LABEL_11:
    result = -6;
  }
  return result;
}
// 1004219C: using guessed type int FIL_vfs_close(void);
// 10258D50: using guessed type int dword_10258D50;
// 10258D58: using guessed type int dword_10258D58[];

//----- (1003E3E0) --------------------------------------------------------
signed int __cdecl sub_1003E3E0(unsigned int a1)
{
  signed int result; // eax@3

  if ( a1 < 0xFFFFFFC2 && a1 )
    result = sub_1003E3A0(a1);
  else
    result = -6;
  return result;
}

//----- (1003E430) --------------------------------------------------------
int __cdecl sub_1003E430(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 100421B4: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E4B0) --------------------------------------------------------
signed int __cdecl sub_1003E4B0(unsigned int a1, void *a2, int a3)
{
  int v3; // eax@7
  unsigned int v4; // eax@4
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v4 = sub_100558A0(a1);
    return sub_10056760(v4, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v3 = sub_1003E730(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_1003F930(a1, a2, a3, v3, (unsigned __int64)v3 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 100421CC: using guessed type int FIL_vfs_read(void);

//----- (1003E500) --------------------------------------------------------
signed int __cdecl sub_1003E500(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_10055820(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_1003F930(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 100421D8: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E5A0) --------------------------------------------------------
signed int __cdecl sub_1003E5A0(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_10055880(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 100421EA: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E5F0) --------------------------------------------------------
__int64 __cdecl sub_1003E5F0(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 100421F0: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (1003E610) --------------------------------------------------------
int __cdecl sub_1003E610(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 100421F6: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (1003E640) --------------------------------------------------------
int __cdecl sub_1003E640(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 10042202: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E660) --------------------------------------------------------
char __cdecl sub_1003E660(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 772, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_1003E3A0(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1003E690) --------------------------------------------------------
char __cdecl sub_1003E690(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_1003E3A0(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1003E6C0) --------------------------------------------------------
int __cdecl sub_1003E6C0(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@3
  unsigned int v4; // ST00_4@4

  v2 = a2;
  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1;
    a1 = a2;
    result = j_FIL_vfs_ioctl(v4, 106, &a1, 4);
    if ( !result )
      return result;
  }
  else
  {
    result = -6;
  }
  *(_DWORD *)v2 = 0;
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 28) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  return result;
}
// 1003E420: using guessed type int __cdecl j_FIL_vfs_ioctl(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E710) --------------------------------------------------------
int __cdecl sub_1003E710(int a1, int a2, int a3)
{
  return j_FIL_vfs_read_dir_cnt(a1, a2, a3, -1);
}
// 1003E4F0: using guessed type int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003E730) --------------------------------------------------------
signed int __cdecl sub_1003E730(unsigned int a1, int a2, int a3)
{
  return sub_1003E5A0(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (1003E750) --------------------------------------------------------
int __cdecl sub_1003E750(int a1, int a2, int a3)
{
  return sub_1003E610(a1, a2, a3);
}

//----- (1003E770) --------------------------------------------------------
int __cdecl sub_1003E770(const char *a1)
{
  const char *v1; // edi@1
  int i; // esi@1
  int v3; // esi@3
  int result; // eax@3
  unsigned int v5; // eax@5
  unsigned int v6; // esi@5
  int v7; // ebx@7
  char *v8; // ebp@9
  char *v9; // eax@10
  char *v10; // edi@12
  char v11; // cl@13
  char v12; // dl@15
  unsigned int v13; // eax@16
  char *v14; // edi@16
  char v15; // cl@17
  int v16; // eax@19
  int v17; // eax@22
  signed int v18; // [sp+10h] [bp-1A0h]@9
  int v19; // [sp+18h] [bp-198h]@3
  unsigned int v20; // [sp+1Ch] [bp-194h]@5
  char v21; // [sp+20h] [bp-190h]@12
  char v22; // [sp+A0h] [bp-110h]@8

  v1 = a1;
  for ( i = 0; ; i = v19 )
  {
    v3 = i + 1;
    v19 = v3;
    result = j_FIL_vfs_rmdir(v1);
    if ( result != -30 || v3 >= 200000 )
      break;
    v5 = j_FIL_vfs_open(v1, 260, 0);
    v6 = v5;
    v20 = v5;
    if ( v5 < 0xFFFFFFC2 && v5 )
      v7 = sub_1003E710(v5, (int)&v22, 268);
    else
      v7 = v5;
    v8 = &v22;
    v18 = v7 < 0 ? 0 : v7;
    if ( (v7 < 0 ? 0 : v7) > 0 )
    {
      do
      {
        v9 = v8 + 24;
        if ( memcmp(".", v8 + 24, 2u) )
        {
          if ( memcmp("..", v8 + 24, 3u) )
          {
            strcpy(&v21, a1);
            v10 = (char *)&v20 + 3;
            do
              v11 = (v10++)[1];
            while ( v11 );
            *(_WORD *)v10 = *(_WORD *)"/";
            do
              v12 = *v9++;
            while ( v12 );
            v13 = v9 - (v8 + 24);
            v14 = (char *)&v20 + 3;
            do
              v15 = (v14++)[1];
            while ( v15 );
            qmemcpy(v14, v8 + 24, v13);
            v16 = *((_DWORD *)v8 + 5) & 0x1000 ? sub_1003E770(&v21) : j_FIL_vfs_delete(&v21);
            v7 = v16;
            if ( v16 )
              break;
          }
        }
        v17 = *((_WORD *)v8 + 2);
        v8 += v17;
        v18 -= v17;
      }
      while ( v18 > 0 );
      v1 = a1;
      v6 = v20;
    }
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_1003E3A0(v6);
    }
    if ( v7 )
      return v7;
  }
  return result;
}
// 1003E400: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E590: using guessed type int __cdecl j_FIL_vfs_rmdir(_DWORD);

//----- (1003E940) --------------------------------------------------------
int __cdecl sub_1003E940(int a1, unsigned int a2)
{
  unsigned int v2; // esi@1
  int v3; // edi@1

  v2 = j_FIL_vfs_open(a1, 4, 0);
  v3 = sub_1003E6C0(v2, a2);
  sub_1003E3E0(v2);
  return v3;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1003E970) --------------------------------------------------------
int __cdecl sub_1003E970(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 1003FA80: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1003E9D0) --------------------------------------------------------
signed int __cdecl sub_1003E9D0(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@3

  v1 = **(_DWORD **)(a1 + 16);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( *(_BYTE *)(v1 - 3) || *(_BYTE *)(a1 + 4) & 8 )
    {
      if ( *(_BYTE *)(a1 + 4) & 1 )
      {
        *(_BYTE *)(v1 - 3) = 0;
        result = 1;
      }
      else
      {
        sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 474, 1, 0);
        result = 0;
      }
    }
    else
    {
      sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 465, 1, 0);
      result = 1;
    }
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 455, 1, 0);
    result = 0;
  }
  return result;
}

//----- (1003EA50) --------------------------------------------------------
unsigned int __usercall sub_1003EA50@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  unsigned int v3; // eax@5
  char *v4; // edi@9
  char v5; // al@10
  unsigned int v6; // eax@12
  signed int v7; // ebx@15
  const char *v8; // eax@19
  unsigned int result; // eax@47
  unsigned int v10; // [sp+Ch] [bp-98h]@1
  int v11; // [sp+14h] [bp-90h]@29
  char v12; // [sp+1Dh] [bp-87h]@30
  char v13; // [sp+1Fh] [bp-85h]@9
  char v14; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v10 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
  }
  else
  {
    strncpy(&v14, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v4 = &v13;
      do
        v5 = (v4++)[1];
      while ( v5 );
      *(_DWORD *)v4 = 7368052;
    }
    v10 = j_FIL_vfs_open(*a1, 6, 1809);
    v6 = j_FIL_vfs_open(&v14, 14, 1809);
    v2 = v6;
    if ( v6 >= 0xFFFFFFC2 || !v6 )
    {
      sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v7 = sub_1003E730(v6, 0, 2);
    if ( v7 < 0 )
    {
      sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v8 = a1[2] + 12;
    if ( v7 < (signed int)v8 && sub_1003E750(v2, (int)v8, (unsigned __int64)(signed int)v8 >> 32) < 0 )
    {
      sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v3 = j_FIL_vfs_mmap(v2, 0, a1[2] + 12, 0);
    v1 = v3;
    if ( v3 < 0xFFFFFFC2 && v3 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v3 + 9) || *(_BYTE *)(v3 + 8) != 56 )
        {
          sub_1003E970((int)a1, v3 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v3 + 4) = sub_1003DC90();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v10 < 0xFFFFFFC2 && v10 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_1003E4B0(v10, &v11, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v11;
          v12 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_1003E640(v10, (int)&v11, 12, 0) != 12 )
          {
            sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v14, *a1) )
        sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_1003E3A0(v2);
LABEL_42:
  if ( v10 < 0xFFFFFFC2 && v10 )
    sub_1003E3A0(v10);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 1003E4A0: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1003E580: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (1003ED50) --------------------------------------------------------
int __usercall sub_1003ED50@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 1003FA80: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (1003ED70) --------------------------------------------------------
signed int __cdecl sub_1003ED70(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_1003DF80(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_1003DF50(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_1003ED50(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_1003EA50((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_1003DF50(v6, 81);
  return (unsigned __int8)v2;
}

//----- (1003EE40) --------------------------------------------------------
unsigned int __cdecl sub_1003EE40(LONG Value)
{
  char v1; // al@1
  unsigned int result; // eax@3
  unsigned int v3; // edi@3
  unsigned __int32 v4; // eax@5
  int v5; // ebx@5

  v1 = *(_BYTE *)(Value + 4);
  if ( v1 & 2 || !(v1 & 1) )
  {
    sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 360, 1, 0);
    result = 0;
  }
  else
  {
    result = sub_1003EA50((const char **)Value);
    v3 = result;
    if ( result < 0xFFFFFFC2 && result )
    {
      v4 = InterlockedExchange(*(volatile LONG **)(Value + 16), result);
      v5 = v4;
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        if ( *(_DWORD *)(Value + 8) < 0 )
          sub_100129A0("..\\lib\\acl\\kernel\\mem_usr_share.c", 388, 0, 0);
        sub_1003ED50(*(_DWORD *)(Value + 8), v5);
      }
      result = v3;
    }
  }
  return result;
}

//----- (1003EEE0) --------------------------------------------------------
__int16 __cdecl sub_1003EEE0(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042208: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003EF20) --------------------------------------------------------
__int16 __cdecl sub_1003EF20(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 1003EF10: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (1003EFC0) --------------------------------------------------------
int __cdecl sub_1003EFC0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 1004222C: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (1003F010) --------------------------------------------------------
int __cdecl sub_1003F010(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 10042082: using guessed type int SYS_enter_krnl(void);
// 10042232: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (1003F080) --------------------------------------------------------
int __cdecl sub_1003F080(int a1)
{
  void *v1; // ecx@0
  void *v2; // eax@1
  int v3; // eax@3

  v2 = (void *)a1;
  if ( !a1 )
    v2 = sub_1001D4B0(v1);
  a1 = (int)v2;
  v3 = sub_1001CD60(&a1, 4u, (int)&unk_100D7670, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D7674[2 * v3];
}
// 100D7674: using guessed type int dword_100D7674[];

//----- (1003F0C0) --------------------------------------------------------
int __cdecl sub_1003F0C0(int a1)
{
  void *v1; // ecx@0
  void *v2; // eax@1
  int v3; // eax@3

  v2 = (void *)a1;
  if ( !a1 )
    v2 = sub_1001D4B0(v1);
  a1 = (int)v2;
  v3 = sub_1001CD60(&a1, 4u, (int)&unk_100D76A8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D76AC[2 * v3];
}
// 100D76AC: using guessed type int dword_100D76AC[];

//----- (1003F100) --------------------------------------------------------
int __cdecl sub_1003F100(int a1)
{
  void *v1; // ecx@0
  void *v2; // eax@1
  int v3; // eax@3

  v2 = (void *)a1;
  if ( !a1 )
    v2 = sub_1001D4B0(v1);
  a1 = (int)v2;
  v3 = sub_1001CD60(&a1, 4u, (int)&unk_100D76E0, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D76E4[2 * v3];
}
// 100D76E4: using guessed type int dword_100D76E4[];

//----- (1003F140) --------------------------------------------------------
int __cdecl sub_1003F140(int a1)
{
  void *v1; // ecx@0
  void *v2; // eax@1
  int v3; // eax@3

  v2 = (void *)a1;
  if ( !a1 )
    v2 = sub_1001D4B0(v1);
  a1 = (int)v2;
  v3 = sub_1001CD60(&a1, 4u, (int)&unk_100D7718, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_100D771C[2 * v3];
}
// 100D771C: using guessed type int dword_100D771C[];

//----- (1003F180) --------------------------------------------------------
int __cdecl sub_1003F180(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_1003F0C0(a4);
    result = sub_1003E040(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_1003E040(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_1003F080(a4);
      result = sub_1003E040(v6, a3, 6);
    }
  }
  return result;
}

//----- (1003F1F0) --------------------------------------------------------
int __cdecl sub_1003F1F0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_1003F140(a3);
    result = sub_1003E040(v4, a1, 64);
    if ( result == -7 )
    {
      sub_1003DE80(100);
      v5 = sub_1003F140(a3);
      result = sub_1003E040(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_1003F100(a3);
    result = sub_1003E040(v6, a2, 8);
    if ( result == -7 )
    {
      sub_1003DE80(100);
      v7 = sub_1003F100(a3);
      result = sub_1003E040(v7, a2, 8);
    }
  }
  return result;
}

//----- (1003F290) --------------------------------------------------------
void __cdecl sub_1003F290(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_10016090(v2) && sub_100160F0(v3) != 1 )
    *a2 = 0;
}

//----- (1003F2D0) --------------------------------------------------------
int __cdecl sub_1003F2D0(int a1, void *a2)
{
  unsigned int v2; // eax@2
  unsigned int v3; // eax@5
  unsigned int v4; // eax@8
  unsigned int v5; // eax@11
  int v6; // ebp@16
  unsigned int v8; // [sp+Ch] [bp-9Ch]@1
  char v9; // [sp+10h] [bp-98h]@16
  int v10; // [sp+1Ah] [bp-8Eh]@16
  char v11; // [sp+20h] [bp-88h]@14

  v8 = 0;
  switch ( (unsigned __int16)a1 / 0x3E8u )
  {
    case 0xCu:
    case 0xEu:
      memset(word_10254E48, 0, 0x3E84u);
      v2 = 0;
      do
      {
        word_10254E48[v2] = -1;
        word_10254EE4[v2] = -1;
        v2 += 80;
      }
      while ( v2 < 8000 );
      memcpy(a2, word_10254E48, 0x3E84u);
      break;
    case 0x17u:
      memset(word_10254E48, 0, 0x3E84u);
      v3 = 0;
      do
      {
        word_10254E48[v3] = -2;
        word_10254EE4[v3] = -1;
        v3 += 80;
      }
      while ( v3 < 8000 );
      memcpy(a2, word_10254E48, 0x3E84u);
      v8 = sub_10041EF0((unsigned int *)"\aAHRS1 TAS", 64740, 0xFFFFFFFF);
      sub_1003E110(6948, (int)&v8, 4);
      break;
    case 0x15u:
    case 0x16u:
    case 0x18u:
      memset(word_10252F08, 0, 0x1F40u);
      v4 = 0;
      do
      {
        byte_10252F0E[v4 * 2] = 18;
        word_10252F08[v4] = -1;
        word_10252F0A[v4] = -1;
        word_10252F0C[v4] = -1;
        v4 += 4;
      }
      while ( v4 < 4000 );
      memcpy(a2, word_10252F08, 0x1F40u);
      break;
    case 0xDu:
    case 0xFu:
    case 0x19u:
      memset(byte_102514E8, 0, 0x1900u);
      v5 = 0;
      do
      {
        byte_102514E8[v5 * 2] = 0;
        word_102514EA[v5] = -1;
        v5 += 32;
      }
      while ( v5 < 3200 );
      memcpy(a2, byte_102514E8, 0x1900u);
      break;
    case 0x24u:
      memset(&v11, 0, 0x84u);
      sub_1003ABD0(&v11, 2);
      qmemcpy(a2, &v11, 0x84u);
      break;
    case 0x12u:
      memset(&unk_10252DE8, 0, 0x11Cu);
      memset(&unk_10252E24, 255, 0xC8u);
      dword_10252E08 = 0;
      byte_10252E12 = 0;
      qmemcpy(a2, &unk_10252DE8, 0x11Cu);
      break;
    default:
      j_reg_get_tag_hdr(&v9, a1, a1);
      v6 = v10;
      memset(&unk_1024BCE8, 0, (unsigned __int16)v10);
      if ( !sub_1003E000(a1, (int)&unk_1024BCE8, v6) )
        memcpy(a2, &unk_1024BCE8, (unsigned __int16)v10);
      break;
  }
  return 0;
}
// 1003E020: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);
// 102514EA: using guessed type __int16 word_102514EA[];
// 10252E08: using guessed type int dword_10252E08;
// 10252E12: using guessed type char byte_10252E12;
// 10252F08: using guessed type __int16 word_10252F08[];
// 10252F0A: using guessed type __int16 word_10252F0A[];
// 10252F0C: using guessed type __int16 word_10252F0C[];
// 10254E48: using guessed type __int16 word_10254E48[];
// 10254EE4: using guessed type __int16 word_10254EE4[];

//----- (1003F590) --------------------------------------------------------
unsigned int __cdecl sub_1003F590(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_10258D58[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_10258D10[a1];
  dword_10258D10[a1] = a3 + v9;
  dword_10258CD0[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_10258CD0[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 10258D10: using guessed type int dword_10258D10[];
// 10258D58: using guessed type int dword_10258D58[];

//----- (1003F740) --------------------------------------------------------
int __usercall sub_1003F740@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_10258D58[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_10258D58[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 10258D58: using guessed type int dword_10258D58[];

//----- (1003F7F0) --------------------------------------------------------
int __cdecl sub_1003F7F0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_1003F740(a1);
  v3 = &dword_10258D58[a1];
  v4 = sub_1003E500(
         *(_DWORD *)dword_10258D58[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_10258D58[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_10258D10[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 10258D10: using guessed type int dword_10258D10[];
// 10258D58: using guessed type int dword_10258D58[];

//----- (1003F8A0) --------------------------------------------------------
int __usercall sub_1003F8A0@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_10258D58[a1];
  v3 = (int *)(dword_10258D10[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_10258D58[a1] + 32)) % *(_WORD *)(dword_10258D58[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_1003F7F0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 10258D10: using guessed type int dword_10258D10[];
// 10258D58: using guessed type int dword_10258D58[];

//----- (1003F930) --------------------------------------------------------
int __cdecl sub_1003F930(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_10258D50 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_10258D58[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_10258D50 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_1003DDA0(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_10258D58[v6] + 28);
        v12 = sub_1003F8A0(v6, (unsigned int)v7 & *(_DWORD *)(dword_10258D58[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_10258D58[v6] + 4) != 138 )
        sub_1003DD40(*(_DWORD *)(dword_10258D58[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_10258D58[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_1003DD40(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 10258D50: using guessed type int dword_10258D50;
// 10258D58: using guessed type int dword_10258D58[];

//----- (1003FA90) --------------------------------------------------------
int __cdecl sub_1003FA90(float a1, float a2, float a3)
{
  float *v3; // ecx@0
  int result; // eax@4

  if ( (COERCE_UNSIGNED_INT(*v3) & 0x7F800000) == 2139095040 || a1 < (double)*v3 || a2 > (double)*v3 )
  {
    result = 0;
    *v3 = a3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003FAE0) --------------------------------------------------------
double __cdecl sub_1003FAE0(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_1002B830() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_102AD56C + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_102AD56C + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_102AD56C + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (1003FB70) --------------------------------------------------------
signed int __cdecl sub_1003FB70(char a1)
{
  return (signed int)(sub_1003FAE0(a1) * 683565248.0);
}

//----- (1003FB90) --------------------------------------------------------
signed int sub_1003FB90()
{
  signed int result; // eax@2

  if ( sub_1002B830() )
    result = *(_DWORD *)(dword_102AD56C + 840);
  else
    result = 0x3FFFF;
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (1003FBB0) --------------------------------------------------------
char __cdecl sub_1003FBB0(float *a1)
{
  float v1; // ST18_4@6
  char result; // al@6
  float v3; // ST18_4@6
  char v4; // [sp+1Bh] [bp-2Dh]@6
  float v5; // [sp+1Ch] [bp-2Ch]@6
  char v6; // [sp+20h] [bp-28h]@2
  char v7; // [sp+2Eh] [bp-1Ah]@2

  *a1 = 0.0;
  if ( !sub_1002B830()
    || (sub_10040380((int)&v6), v7)
    || *(_BYTE *)(dword_102AD56C + 661)
    && (!*(_BYTE *)(dword_102AD56C + 64)
     || (unsigned int)(*(_DWORD *)(dword_102AD56C + 36) - *(_DWORD *)(dword_102AD56C + 740)) >= 0x124F80) )
  {
    result = 0;
  }
  else
  {
    sub_1002C2D0();
    sub_100417A0(*(_BYTE *)(dword_102AD56C + 1201), &v4, &v5);
    *a1 = *(float *)(dword_102AD56C + 340);
    v1 = *(float *)(dword_102AD56C + 336);
    sub_10040EB0(12756274.0, -12756274.0);
    sub_1003FA90(514.44446, -514.44446, 0.0);
    *a1 = sub_1002C2B0(*(_DWORD *)(dword_102AD56C + 296)) * v1 + *a1;
    sub_1002C2C0();
    sub_10040EB0(10.0, 0.043196544);
    result = 1;
    v3 = *a1 * 0.0005399567889980972;
    *a1 = v3 / v5;
  }
  return result;
}
// 1002C2B0: using guessed type double __cdecl sub_1002C2B0(_DWORD);
// 102AD56C: using guessed type int dword_102AD56C;

//----- (1003FD20) --------------------------------------------------------
bool __cdecl sub_1003FD20(float *a1, float *a2, float *a3, _BYTE *a4, _BYTE *a5, _BYTE *a6)
{
  bool v6; // bl@1
  float *v7; // eax@4
  float v9; // [sp+18h] [bp-38h]@1
  _BYTE *v10; // [sp+1Ch] [bp-34h]@1
  _BYTE *v11; // [sp+20h] [bp-30h]@1
  _BYTE *v12; // [sp+24h] [bp-2Ch]@1
  char v13; // [sp+28h] [bp-28h]@1
  char v14; // [sp+36h] [bp-1Ah]@2

  *a1 = 0.0;
  *a2 = 9.9999996e24;
  v6 = 0;
  v12 = a4;
  *a3 = 0.0;
  *a4 = 0;
  v10 = a5;
  v11 = a6;
  sub_10040380((int)&v13);
  sub_1003FBB0(&v9);
  if ( sub_1002B830() )
  {
    sub_1002C2D0();
    if ( !v14 )
    {
      if ( sub_10040EB0(300.0, 1.0) )
      {
        *a1 = sub_1002C2B0(*(_DWORD *)(dword_102AD56C + 296)) * *(float *)(dword_102AD56C + 1220)
            + *(float *)(dword_102AD56C + 1216);
        v7 = (float *)(dword_102AD56C + 1224);
        *a2 = *(float *)(dword_102AD56C + 1224);
        *a3 = *a1 / *v7;
        v6 = *(_BYTE *)(dword_102AD56C + 1211) == 0;
        if ( !*(_BYTE *)(dword_102AD56C + 1211) )
        {
          LODWORD(v9) &= 0x7FFFFFFFu;
          if ( v9 <= 1.0 )
          {
            if ( *(_BYTE *)(dword_102AD56C + 288) )
              *v12 = 1;
          }
        }
      }
    }
    if ( v10 )
      *v10 = *(_BYTE *)(dword_102AD56C + 1212);
    if ( v11 )
      *v11 = *(_BYTE *)(dword_102AD56C + 821);
    sub_1002C2C0();
  }
  return v6;
}
// 1002C2B0: using guessed type double __cdecl sub_1002C2B0(_DWORD);
// 102AD56C: using guessed type int dword_102AD56C;

//----- (1003FEA0) --------------------------------------------------------
char __cdecl sub_1003FEA0(int a1)
{
  int v1; // eax@2
  char result; // al@2

  if ( sub_1002B830() )
  {
    sub_1002C2D0();
    v1 = dword_102AD56C + 1504;
    *(_DWORD *)a1 = *(_DWORD *)(dword_102AD56C + 1504);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v1 + 4);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v1 + 8);
    sub_1002C2C0();
    result = *(_BYTE *)a1;
  }
  else
  {
    *(float *)(a1 + 4) = 0.0;
    *(_BYTE *)a1 = 0;
    *(float *)(a1 + 8) = 0.0;
    result = *(_BYTE *)a1;
  }
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (1003FEF0) --------------------------------------------------------
char __cdecl sub_1003FEF0(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@2
  char v3; // al@3

  v1 = 0;
  if ( sub_1002B830() )
  {
    sub_1002C2D0();
    v2 = *(_BYTE *)(dword_102AD56C + 812);
    if ( v2 != -1 )
    {
      v3 = *(_BYTE *)(180 * v2 + dword_102AD560 + 671);
      if ( (v3 == 18 || v3 == 19 || v3 == 20 || v3 == 21 || v3 == 22) && (!a1 || v3 == 21) )
        v1 = 1;
    }
    sub_1002C2C0();
  }
  return v1;
}
// 102AD560: using guessed type int dword_102AD560;
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10040000) --------------------------------------------------------
char __cdecl sub_10040000(char a1, char a2, float *a3)
{
  char v3; // bl@1
  int v4; // edi@3
  int *v5; // eax@3
  double v6; // st7@7
  char v8; // [sp+Fh] [bp-31h]@1
  float v9; // [sp+10h] [bp-30h]@3
  float v10; // [sp+10h] [bp-30h]@11
  char v11; // [sp+18h] [bp-28h]@2
  char v12; // [sp+26h] [bp-1Ah]@2

  *a3 = 0.0;
  v3 = 0;
  v8 = sub_1003FEF0(0);
  if ( !sub_1002B830() )
    return v3;
  sub_10040380((int)&v11);
  if ( v12 )
    return v3;
  sub_1002C2D0();
  v9 = 0.0;
  v4 = *(_DWORD *)(dword_102AD56C + 296);
  v5 = (int *)(dword_102AD56C + 296);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      if ( a1 == 2 )
      {
        *a3 = *(float *)(dword_102AD56C + 560) - *(float *)(dword_102AD56C + 720);
        v3 = *(_BYTE *)(dword_102AD56C + 673);
      }
      goto LABEL_11;
    }
    *a3 = *(float *)(dword_102AD56C + 312);
    v6 = *(float *)(dword_102AD56C + 328);
    goto LABEL_10;
  }
  if ( !v8 )
  {
    *a3 = *(float *)(dword_102AD56C + 308);
    v6 = *(float *)(dword_102AD56C + 324);
LABEL_10:
    v4 = *v5;
    v9 = v6;
    v3 = 1;
  }
LABEL_11:
  sub_1002C2C0();
  v10 = sub_1002C2B0(v4) * v9 + *a3;
  *a3 = v10;
  if ( a1 != 2 )
    *a3 = v10 - sub_1003FAE0(a2);
  *a3 = sub_10041C10(*a3);
  return v3;
}
// 1002C2B0: using guessed type double __cdecl sub_1002C2B0(_DWORD);
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10040140) --------------------------------------------------------
char __cdecl sub_10040140(char a1, float *a2)
{
  char v2; // bl@1
  double v3; // st7@7
  char result; // al@13
  float v5; // [sp+8h] [bp-2Ch]@1
  char v6; // [sp+Ch] [bp-28h]@2
  char v7; // [sp+1Ah] [bp-1Ah]@2

  *a2 = 0.0;
  v2 = 0;
  v5 = 0.0;
  if ( !sub_1002B830() )
    return v2;
  sub_10040380((int)&v6);
  if ( v7 || sub_1003FEF0(1) )
    return v2;
  sub_1002C2D0();
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      *a2 = *(float *)(dword_102AD56C + 316);
      v3 = *(float *)(dword_102AD56C + 332);
    }
    else
    {
      if ( a1 != 2 )
        goto LABEL_11;
      *a2 = *(float *)(dword_102AD56C + 340);
      v3 = *(float *)(dword_102AD56C + 336);
    }
  }
  else
  {
    *a2 = *(float *)(dword_102AD56C + 304);
    v3 = *(float *)(dword_102AD56C + 320);
  }
  v5 = v3;
  v2 = 1;
LABEL_11:
  *a2 = sub_1002C2B0(*(_DWORD *)(dword_102AD56C + 296)) * v5 + *a2;
  sub_1002C2C0();
  if ( a1 == 1 )
  {
    *(_DWORD *)a2 = COERCE_UNSIGNED_INT(*a2) & 0x7FFFFFFF;
    return v2;
  }
  if ( a1 || !*(_BYTE *)(dword_102AD56C + 288) )
    return v2;
  result = v2;
  if ( (*(_DWORD *)a2 >> 31) & 1 )
    *a2 = 0.0;
  return result;
}
// 1002C2B0: using guessed type double __cdecl sub_1002C2B0(_DWORD);
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10040290) --------------------------------------------------------
bool __cdecl sub_10040290(float *a1, _BYTE *a2)
{
  bool result; // al@2
  char v3; // [sp+7h] [bp-9h]@2
  char v4; // [sp+8h] [bp-8h]@2
  char v5; // [sp+Ch] [bp-4h]@2

  if ( sub_1002B830() )
  {
    *a2 = *(_BYTE *)(dword_102AD56C + 1212);
    result = sub_1003FD20((float *)&v5, (float *)&v4, a1, &v3, a2, 0);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (100402E0) --------------------------------------------------------
char __cdecl sub_100402E0(void *a1)
{
  char result; // al@2

  if ( sub_1002B830() )
  {
    sub_1002C2D0();
    qmemcpy(a1, (const void *)(dword_102AD56C + 1356), 0x94u);
    result = sub_1002C2C0();
  }
  else
  {
    memset(a1, 0, 0x94u);
    result = (char)a1;
    *((float *)a1 + 11) = 9.9999996e24;
    *((float *)a1 + 12) = 9.9999996e24;
    *((_BYTE *)a1 + 1) = 0;
    *((float *)a1 + 14) = 9.9999996e24;
    *((_BYTE *)a1 + 25) = 0;
    *((float *)a1 + 15) = 9.9999996e24;
    *((_BYTE *)a1 + 7) = 1;
    *((float *)a1 + 18) = 9.9999996e24;
    *((_BYTE *)a1 + 10) = 0;
    *((float *)a1 + 17) = 9.9999996e24;
    *((_DWORD *)a1 + 9) = -1;
    *((float *)a1 + 20) = 9.9999996e24;
    *((_BYTE *)a1 + 19) = -1;
    *((float *)a1 + 24) = 9.9999996e24;
    *((_DWORD *)a1 + 10) = -1;
    *((float *)a1 + 26) = 9.9999996e24;
    *((_BYTE *)a1 + 20) = -1;
    *((float *)a1 + 27) = 9.9999996e24;
    *((_BYTE *)a1 + 8) = 0;
    *((float *)a1 + 31) = 9.9999996e24;
    *((_BYTE *)a1 + 9) = 0;
    *((float *)a1 + 32) = 9.9999996e24;
    *((_BYTE *)a1 + 13) = 0;
    *((float *)a1 + 33) = 9.9999996e24;
    *((_BYTE *)a1 + 15) = 0;
    *((float *)a1 + 34) = 9.9999996e24;
    *((_BYTE *)a1 + 14) = 0;
    *((float *)a1 + 16) = 9.9999996e24;
    *((_BYTE *)a1 + 16) = 0;
    *((float *)a1 + 35) = 9.9999996e24;
    *((_BYTE *)a1 + 17) = 0;
    *((float *)a1 + 36) = 9.9999996e24;
    *((_BYTE *)a1 + 24) = 0;
    *((float *)a1 + 19) = 9.9999996e24;
    *((float *)a1 + 21) = 9.9999996e24;
    *((float *)a1 + 22) = 9.9999996e24;
    *((float *)a1 + 23) = 9.9999996e24;
    *((float *)a1 + 25) = 9.9999996e24;
    *((float *)a1 + 28) = 9.9999996e24;
    *((float *)a1 + 29) = 0.0;
    *((float *)a1 + 30) = 9.9999996e24;
  }
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10040330) --------------------------------------------------------
char sub_10040330()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_1002B830() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_102AD56C + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_102AD56C + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_102AD56C + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10040380) --------------------------------------------------------
char __cdecl sub_10040380(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  char v3; // al@4
  unsigned __int8 v4; // al@16

  *(_DWORD *)(a1 + 16) = 0x3FFFF;
  *(_BYTE *)a1 = -1;
  *(_DWORD *)(a1 + 20) = 0x3FFFF;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = 1;
  *(_BYTE *)(a1 + 4) = 6;
  *(_BYTE *)(a1 + 5) = -1;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 11) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 1;
  *(_BYTE *)(a1 + 15) = 0;
  result = sub_1002B830();
  if ( result )
  {
    sub_1002C2D0();
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(dword_102AD56C + 815);
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(dword_102AD56C + 94);
    *(_BYTE *)(a1 + 11) = *(_BYTE *)(dword_102AD56C + 97);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_102AD560 + 239);
    *(_BYTE *)(a1 + 15) = *(_BYTE *)(dword_102AD56C + 826);
    strncpy((char *)(a1 + 24), (const char *)(dword_102AD56C + 872), 0xCu);
    *(_BYTE *)(a1 + 35) = 0;
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(dword_102AD56C + 784);
    *(_BYTE *)(a1 + 14) = 0;
    v2 = dword_102AD56C;
    if ( *(_BYTE *)(dword_102AD56C + 669) && !*(_BYTE *)(dword_102AD56C + 667)
      || (v3 = *(_BYTE *)(dword_102AD56C + 159)) != 0
      && *(_BYTE *)(dword_102AD56C + 667)
      && !*(_BYTE *)(dword_102AD56C + 661)
      && (v3 != 2 || -1.0 == *(float *)(dword_102AD56C + 116))
      || !*(_BYTE *)(dword_102AD56C + 672) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_102AD56C;
    }
    else if ( *(_BYTE *)(dword_102AD56C + 101) == 4
           && *(_BYTE *)(dword_102AD56C + 812) >= *(_BYTE *)(dword_102AD560 + 241)
           && !*(_BYTE *)(dword_102AD56C + 89)
           && -1.0 == *(float *)(dword_102AD56C + 116) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_102AD56C;
    }
    *(_BYTE *)(a1 + 9) = *(_BYTE *)(v2 + 816);
    *(_BYTE *)(a1 + 5) = *(_BYTE *)(dword_102AD560 + 241);
    v4 = *(_BYTE *)(a1 + 9) - 1;
    *(_BYTE *)(a1 + 10) = *(_BYTE *)(dword_102AD560 + 244);
    if ( v4 > 2u )
    {
      *(_BYTE *)(a1 + 9) = 0;
      *(_DWORD *)(a1 + 16) = 0x3FFFF;
      *(_DWORD *)(a1 + 20) = 0x3FFFF;
      *(_BYTE *)(a1 + 12) = 0;
      *(_BYTE *)a1 = -1;
      *(_BYTE *)(a1 + 2) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      *(_BYTE *)(a1 + 7) = -1;
      *(_BYTE *)(a1 + 14) = 1;
      result = sub_1002C2C0();
    }
    else
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(dword_102AD56C + 836);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(dword_102AD56C + 840);
      *(_BYTE *)a1 = *(_BYTE *)(dword_102AD56C + 812);
      *(_BYTE *)(a1 + 13) = *(_BYTE *)(dword_102AD56C + 825);
      if ( *(_DWORD *)(dword_102AD56C + 892) )
        *(_BYTE *)(a1 + 3) = 0;
      else
        *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_102AD56C + 288);
      *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_102AD56C + 288);
      *(_BYTE *)(a1 + 7) = *(_BYTE *)(dword_102AD56C + 813);
      *(_BYTE *)(a1 + 12) = *(_BYTE *)(dword_102AD560 + 4);
      result = sub_1002C2C0();
    }
  }
  return result;
}
// 102AD560: using guessed type int dword_102AD560;
// 102AD56C: using guessed type int dword_102AD56C;

//----- (100405D0) --------------------------------------------------------
void __cdecl sub_100405D0(float *a1, float *a2, float *a3, int a4)
{
  float v4; // [sp+0h] [bp-4h]@1

  sub_10040CD0(a1, a2, a4);
  v4 = sqrt(sub_10040D90(a4, a4));
  *a3 = v4;
  if ( v4 >= 0.1000000014901161 )
  {
    *(float *)a4 = *(float *)a4 / v4;
    *(float *)(a4 + 4) = *(float *)(a4 + 4) / *a3;
  }
  else
  {
    *(float *)(a4 + 4) = 1.0;
    *(float *)a4 = 0.0;
  }
}

//----- (10040630) --------------------------------------------------------
int __cdecl sub_10040630(float a1, float a2, int a3)
{
  float v3; // ST00_4@1
  float v4; // ST04_4@1
  float v5; // ST00_4@1
  float v6; // ST04_4@1
  double v7; // ST08_8@1
  float v8; // ST04_4@1
  float v9; // ST00_4@1
  float v10; // ST04_4@1
  float v11; // ST04_4@1
  double v12; // ST08_8@1
  float v13; // ST04_4@1
  float v14; // ST00_4@1
  float v15; // ST04_4@1
  float v16; // ST04_4@1
  double v17; // ST08_8@1
  float v18; // ST04_4@1
  float v19; // ST00_4@1
  float v20; // ST04_4@1
  float v21; // ST04_4@1
  double v22; // ST08_8@1
  float v23; // ST04_4@1
  float v24; // ST00_4@1
  float v25; // ST04_4@1
  int result; // eax@1
  float v27; // ST04_4@1
  float v28; // ST04_4@1
  float v29; // [sp+18h] [bp+8h]@1
  float v30; // [sp+18h] [bp+8h]@1

  v3 = sin(a2 * 4.0);
  v4 = v3;
  v5 = sin(a1 * 4.0);
  v6 = v4 - v5;
  v7 = v6 * 0.00001062759019987425 * 0.25;
  v8 = sin(a2 + a2);
  v9 = v8;
  v10 = sin(a1 + a1);
  v11 = v9 - v10;
  v12 = v7 - v11 * 0.00506310909986496 * 0.5;
  v13 = sin(a2 * 6.0);
  v14 = v13;
  v15 = sin(a1 * 6.0);
  v16 = v14 - v15;
  v17 = v12 - v16 * 0.00000002082037831030448 / 6.0;
  v18 = sin(a2 * 8.0);
  v19 = v18;
  v20 = sin(a1 * 8.0);
  v21 = v19 - v20;
  v22 = v21 * 3.932370748471747e-11 * 0.125 + v17;
  v23 = sin(a2 * 10.0);
  v24 = v23;
  v25 = sin(a1 * 10.0);
  result = a3;
  v27 = v24 - v25;
  v28 = v22 - v27 * 7.108452959288594e-14 / 10.0;
  v29 = a2 - a1;
  v30 = v29 * 1.005052447319031;
  *(float *)a3 = fabs((v28 + v30) * 6335439.327292892);
  return result;
}

//----- (100407F0) --------------------------------------------------------
void __cdecl sub_100407F0(int a1, int a2, float *a3, float *a4, float *a5)
{
  float v5; // ST38_4@1
  float v6; // ST38_4@1
  long double v7; // ST38_8@5
  long double v8; // ST48_8@5
  long double v9; // st7@5
  signed int v10; // ebx@5
  long double v11; // st5@5
  long double v12; // st7@5
  long double v13; // st7@6
  double v14; // st7@6
  double v15; // st4@6
  double v16; // st3@6
  double v17; // st2@8
  double v18; // STB8_8@8
  double v19; // ST60_8@10
  double v20; // ST50_8@10
  long double v21; // st7@10
  long double v22; // st7@10
  double v23; // [sp+40h] [bp-90h]@6
  double v24; // [sp+48h] [bp-88h]@6
  double v25; // [sp+50h] [bp-80h]@5
  double v26; // [sp+58h] [bp-78h]@5
  double v27; // [sp+60h] [bp-70h]@5
  double v28; // [sp+68h] [bp-68h]@6
  double v29; // [sp+70h] [bp-60h]@6
  double v30; // [sp+78h] [bp-58h]@5
  double v31; // [sp+80h] [bp-50h]@6
  double v32; // [sp+88h] [bp-48h]@6
  double v33; // [sp+90h] [bp-40h]@5
  double v34; // [sp+98h] [bp-38h]@5
  double v35; // [sp+A0h] [bp-30h]@8
  double v36; // [sp+A8h] [bp-28h]@6
  double v37; // [sp+B0h] [bp-20h]@5
  double v38; // [sp+C0h] [bp-10h]@5

  v5 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v6 = fabs(sub_10041C10(v5));
  if ( v6 >= 0.000001 )
  {
    v7 = sin(*(float *)a1) * 0.9966471893352525 / cos(*(float *)a1);
    v8 = sin(*(float *)a2) * 0.9966471893352525 / cos(*(float *)a2);
    v33 = 1.0 / sqrt(v7 * v7 + 1.0);
    v9 = 1.0 / sqrt(v8 * v8 + 1.0);
    v10 = 0;
    v37 = v9;
    v34 = v33 * v9;
    v25 = v34 * v8;
    v27 = v25 * v7;
    v26 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
    v11 = v9;
    v12 = v26;
    v30 = v11 * (v33 * v7);
    v38 = v27 + v27;
    do
    {
      v29 = sin(v12);
      v13 = cos(v26);
      v32 = v13;
      v24 = v25 - v13 * v30;
      v36 = sqrt(v29 * v37 * (v29 * v37) + v24 * v24);
      v28 = v13 * v34 + v27;
      v23 = sub_10041DD0(v36, v28);
      v14 = v29 * v34 / v36;
      v15 = 1.0 - v14 * v14;
      v16 = v38;
      v31 = v38;
      if ( v15 > 0.0 )
      {
        v16 = v28 - v38 / v15;
        v31 = v16;
      }
      ++v10;
      v35 = v16 * v16 + v16 * v16 - 1.0;
      v17 = v15 * ((4.0 - v15 * 3.0) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
      v18 = v26;
      v12 = 0.00335281066474748 * ((1.0 - v17) * (v14 * (v36 * (v16 + v35 * v28 * v17) * v17 + v23)))
          + *(float *)(a2 + 4)
          - *(float *)(a1 + 4);
      v26 = v12;
    }
    while ( fabs(v18 - v12) > 0.00000005 && v10 < 20 );
    v19 = sub_10041DD0(v29 * v37, v24);
    v20 = sub_10041DD0(v29 * v33, v32 * v25 - v30);
    v21 = sqrt(v15 * 0.006739496742276252 + 1.0);
    v22 = (v21 + 1.0 - 2.0) / (v21 + 1.0);
    *a3 = (0.25 * (v22 * v22) + 1.0)
        / (1.0 - v22)
        * ((v22 * 0.375 * v22 - 1.0)
         * v22
         * (v36
          * (v31
           + ((1.0 - v35 - v35) * (v36 * v36 * 4.0 - 3.0) * v31 * ((v22 * 0.375 * v22 - 1.0) * v22) / 6.0 - v35 * v28)
           * ((v22 * 0.375 * v22 - 1.0)
            * v22)
           * 0.25))
         + v23)
        * 6378137.0
        * 0.9966471893352525;
    *a4 = v19;
    *a5 = v20;
  }
  else
  {
    sub_10040630(*(float *)a1, *(float *)a2, (int)a3);
    if ( *(float *)a1 >= (double)*(float *)a2 )
    {
      *a4 = 3.1415925;
      *a5 = 3.1415925;
    }
    else
    {
      *a4 = 0.0;
      *a5 = 0.0;
    }
  }
}

//----- (10040BC0) --------------------------------------------------------
void __cdecl sub_10040BC0(int a1, int a2, float *a3, float *a4)
{
  float v4; // ST14_4@1
  float v5; // ST14_4@1
  float v6; // [sp+Ch] [bp-1Ch]@1
  float v7; // [sp+10h] [bp-18h]@1
  float v8; // [sp+14h] [bp-14h]@1
  float v9; // [sp+18h] [bp-10h]@1
  float v10; // [sp+1Ch] [bp-Ch]@1
  float v11; // [sp+20h] [bp-8h]@3
  float v12; // [sp+24h] [bp-4h]@3

  sub_10041C50(a1, (int)&v9);
  sub_10041C50(a2, (int)&v7);
  v4 = v10 - v8;
  v6 = sub_10041C10(v4);
  v5 = v9 - v7;
  if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) >= 0.0014486233 || COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF) >= 0.0014486233 )
  {
    sub_100407F0((int)&v9, (int)&v7, a3, a4, &v6);
  }
  else
  {
    sub_100405D0(&v9, &v7, a3, (int)&v11);
    *a4 = sub_10041E40(v11, v12);
  }
}

//----- (10040CA0) --------------------------------------------------------
double __cdecl sub_10040CA0(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (10040CD0) --------------------------------------------------------
void __cdecl sub_10040CD0(float *a1, float *a2, int a3)
{
  float *v3; // esi@1
  float *v4; // edi@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1
  float v7; // [sp+24h] [bp+4h]@1
  float v8; // [sp+24h] [bp+4h]@1
  float v9; // [sp+24h] [bp+4h]@1
  float v10; // [sp+24h] [bp+4h]@1
  float v11; // [sp+28h] [bp+8h]@1
  float v12; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v7 = (*a1 + *a2) * 0.5;
  sub_10041CE0(v7, (int)&v5, (int)&v6);
  v8 = 1.0 / (1.0 - *(float *)&v5 * (0.00669437999013 * *(float *)&v5));
  v11 = sqrt(v8) * 6378137.0;
  v9 = 0.99330562000987 * v11 * v8;
  v12 = v11 * *(float *)&v6;
  *(float *)(a3 + 4) = (*v4 - *v3) * v9;
  v10 = v4[1] - v3[1];
  *(float *)a3 = v10;
  *(float *)a3 = sub_10041C10(v10) * v12;
}

//----- (10040D90) --------------------------------------------------------
double __cdecl sub_10040D90(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)a1 * *(float *)a2);
}

//----- (10040DB0) --------------------------------------------------------
bool __cdecl sub_10040DB0(unsigned __int8 a1, float *a2)
{
  unsigned __int16 v2; // di@1
  int v3; // ecx@5
  __int16 i; // ax@5
  int v5; // eax@6
  bool v6; // cf@7
  bool result; // al@10

  *a2 = 0.0;
  v2 = 0;
  if ( *(_BYTE *)(dword_102AD56C + 812) == -1
    || *(_WORD *)(dword_102AD56C + 828) == -1
    || 9.9999996e24 == *(float *)(dword_102AD56C + 552)
    || 9.9999996e24 == *(float *)(dword_102AD56C + 568) )
  {
    result = 0;
  }
  else
  {
    *a2 = *(float *)(dword_102AD56C + 552);
    *a2 = sub_1002C2B0(*(_DWORD *)(dword_102AD56C + 544)) * *(float *)(dword_102AD56C + 568) + *a2;
    v3 = dword_102AD564;
    for ( i = *(_WORD *)(44 * *(_WORD *)(dword_102AD56C + 828) + dword_102AD564 + 332);
          i != -1;
          i = *(_WORD *)(v5 + dword_102AD564 + 332) )
    {
      v5 = 44 * i;
      if ( *(_BYTE *)(v5 + v3 + 324) > a1 )
        break;
      v6 = v2 < 0x1F4u;
      if ( v2 >= 0x1F4u )
        goto LABEL_10;
      ++v2;
      *a2 = *(float *)(v5 + v3 + 336) + *a2;
      v3 = dword_102AD564;
    }
    v6 = v2 < 0x1F4u;
LABEL_10:
    result = v6;
  }
  return result;
}
// 1002C2B0: using guessed type double __cdecl sub_1002C2B0(_DWORD);
// 102AD564: using guessed type int dword_102AD564;
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10040EB0) --------------------------------------------------------
int __cdecl sub_10040EB0(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (10040F00) --------------------------------------------------------
double __cdecl sub_10040F00(_BYTE *a1)
{
  _BYTE *v1; // esi@1
  bool v2; // al@1
  int v3; // edx@1
  double v4; // st7@5
  double v5; // st7@8
  float v6; // ST00_4@11
  double result; // st7@13
  double v8; // st7@14
  float v9; // [sp+4h] [bp-10h]@5
  float v10; // [sp+Ch] [bp-8h]@1
  float v11; // [sp+10h] [bp-4h]@5
  float v12; // [sp+18h] [bp+4h]@2
  float v13; // [sp+18h] [bp+4h]@4
  float v14; // [sp+18h] [bp+4h]@10
  float v15; // [sp+18h] [bp+4h]@14

  v1 = a1;
  *a1 = 0;
  v2 = sub_10040DB0(*(_BYTE *)(dword_102AD560 + 244), &v10);
  v3 = dword_102AD56C;
  if ( !v2 )
  {
    v12 = 0.30000001;
    goto LABEL_13;
  }
  if ( *(_BYTE *)(dword_102AD56C + 929) )
  {
    v13 = *(float *)(dword_102AD56C + 948) + v10;
    if ( *(float *)(dword_102AD56C + 964) + 305.0 >= v13 )
    {
      v12 = 0.30000001;
      goto LABEL_13;
    }
    v12 = v13 * 0.0005399567889980972 * *(float *)(dword_102AD56C + 976);
    v11 = 0.0005399567889980972 * *(float *)(dword_102AD56C + 944);
    v9 = v11;
    v4 = 1.0;
  }
  else
  {
    if ( *(_BYTE *)(dword_102AD560 + 237) )
      v5 = 1.0;
    else
      v5 = 0.30000001;
    v11 = v5;
    v14 = v10 + 3048.0;
    v12 = v14 * 0.0005399567889980972 * 0.03492077067494392;
    v9 = 0.057602592;
    v4 = v11;
  }
  v6 = v4;
  if ( sub_10040EB0(v6, v9) )
  {
    *v1 = 1;
    v3 = dword_102AD56C;
  }
LABEL_13:
  result = v12;
  if ( *(float *)(v3 + 84) < (double)v12 )
  {
    v8 = *(float *)(v3 + 84);
    *v1 = 0;
    v15 = v8;
    result = v15;
  }
  return result;
}
// 102AD560: using guessed type int dword_102AD560;
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10041040) --------------------------------------------------------
char __cdecl sub_10041040(float *a1)
{
  int v1; // ST10_4@1
  double v2; // st7@1
  int v3; // ST14_4@1
  int v4; // ST1C_4@1
  int v5; // ST24_4@1
  double v6; // st7@6
  double v7; // st7@10
  double v8; // st7@15
  double v9; // st7@18
  float v10; // ST04_4@26
  char v11; // dl@28
  char result; // al@31
  float v13; // [sp+0h] [bp-24h]@1
  float v14; // [sp+4h] [bp-20h]@1
  float v15; // [sp+14h] [bp-10h]@1
  float v16; // [sp+1Ch] [bp-8h]@1

  v13 = *(float *)(dword_102AD56C + 304);
  v1 = *(_DWORD *)(dword_102AD56C + 64);
  v14 = *(float *)(dword_102AD56C + 320);
  v2 = v13;
  v15 = *(float *)(dword_102AD56C + 72);
  v3 = *(_DWORD *)(dword_102AD56C + 68);
  v16 = *(float *)(dword_102AD56C + 80);
  v4 = *(_DWORD *)(dword_102AD56C + 76);
  v5 = *(_DWORD *)(dword_102AD56C + 84);
  if ( (LODWORD(v13) & 0x7F800000) == 2139095040 || v2 > 25512548.0 )
  {
    v13 = 25512548.0;
  }
  else if ( v2 < -25512548.0 )
  {
    v13 = -25512548.0;
  }
  v6 = v14;
  if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v6 > 1028.8889 || v6 < -1028.8889 )
    v14 = 0.0;
  v7 = v16;
  if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v7 > 2.0 )
  {
    v16 = 2.0;
  }
  else if ( v7 < -2.0 )
  {
    v16 = -2.0;
  }
  v8 = 1.0;
  if ( *(_BYTE *)(dword_102AD56C + 929) )
  {
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 1.0 )
      goto LABEL_25;
    v9 = v15;
  }
  else
  {
    v9 = v15;
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v9 > 0.30000001 )
    {
      v8 = 0.30000001;
      goto LABEL_25;
    }
  }
  if ( v9 >= 0.05760259181261063 )
    goto LABEL_26;
  v8 = 0.057602592;
LABEL_25:
  v15 = v8;
LABEL_26:
  v10 = sub_1002C2B0(*(_DWORD *)(dword_102AD56C + 296)) * v14 + v13;
  *a1 = v15 - v16 * v10;
  if ( v10 > 3704.0 )
    *a1 = 1.0;
  v11 = 0;
  if ( v15 + 0.009999999776482582 >= *a1 || *(_BYTE *)(dword_102AD56C + 812) > *(_BYTE *)(dword_102AD560 + 241) )
  {
    *a1 = v15;
    v11 = 1;
  }
  result = 1;
  if ( !*(_BYTE *)(dword_102AD560 + 237) )
    result = v11;
  return result;
}
// 1002C2B0: using guessed type double __cdecl sub_1002C2B0(_DWORD);
// 102AD560: using guessed type int dword_102AD560;
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10041270) --------------------------------------------------------
char __cdecl sub_10041270(float *a1)
{
  float v1; // ST00_4@1
  double v2; // st7@1
  int v3; // ST04_4@1
  int v4; // ST0C_4@1
  int v5; // ST08_4@1
  int v6; // ST18_4@1
  double v7; // st5@7
  double v8; // st6@7
  double v9; // st4@11
  float v10; // ST14_4@15
  float v11; // ST00_4@16
  float v12; // ST00_4@16
  char result; // al@17
  float v14; // [sp+10h] [bp-Ch]@1
  float v15; // [sp+10h] [bp-Ch]@8
  float v16; // [sp+14h] [bp-8h]@1

  v1 = *(float *)(dword_102AD56C + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_102AD56C + 64);
  v4 = *(_DWORD *)(dword_102AD56C + 72);
  v5 = *(_DWORD *)(dword_102AD56C + 68);
  v16 = *(float *)(dword_102AD56C + 80);
  v14 = *(float *)(dword_102AD56C + 76);
  v6 = *(_DWORD *)(dword_102AD56C + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  if ( (LODWORD(v14) & 0x7F800000) == 2139095040 || v14 > 2.0 )
  {
    v8 = 2.0;
    v15 = 2.0;
    goto LABEL_10;
  }
  v7 = v14;
  v8 = 2.0;
  if ( v14 < 0.05760259181261063 )
  {
    v15 = 0.057602592;
LABEL_10:
    v7 = v15;
  }
  v9 = v16;
  if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v9 > v8 )
  {
    v10 = v8;
    v9 = v10;
  }
  else if ( v9 < -2.0 )
  {
    v9 = (float)-2.0;
  }
  v11 = v2
      * v9
      * ((double)(unsigned int)(*(_DWORD *)(dword_102AD56C + 36) - *(_DWORD *)(dword_102AD56C + 68))
       / (double)1000);
  v12 = v7 + v11;
  *a1 = v12;
  if ( v12 < 1.990000009536743 )
  {
    result = 0;
  }
  else
  {
    *a1 = v8;
    result = 1;
  }
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (100413E0) --------------------------------------------------------
double __cdecl sub_100413E0(float a1)
{
  double v1; // st7@1
  double result; // st7@4
  float v3; // [sp+4h] [bp-4h]@1

  v1 = a1;
  v3 = *(float *)(dword_102AD56C + 48);
  if ( (LODWORD(a1) & 0x7F800000) == 2139095040 || v1 > 10.0 )
  {
    result = (float)10.0;
  }
  else if ( v3 <= v1 )
  {
    result = a1;
  }
  else
  {
    result = v3;
  }
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10041450) --------------------------------------------------------
char __cdecl sub_10041450(float *a1)
{
  float v1; // ST08_4@1
  double v2; // st7@1
  int v3; // ST10_4@1
  int v4; // ST18_4@1
  int v5; // ST14_4@1
  int v6; // ST24_4@1
  double v7; // st6@5
  double v8; // st5@5
  float v9; // ST1C_4@8
  double v10; // st5@9
  double v11; // st4@9
  float v12; // ST20_4@12
  float v13; // ST0C_4@13
  double v14; // st7@13
  char result; // al@17
  float v16; // [sp+0h] [bp-20h]@13
  float v17; // [sp+4h] [bp-1Ch]@5
  float v18; // [sp+14h] [bp-Ch]@1
  float v19; // [sp+18h] [bp-8h]@1

  v1 = *(float *)(dword_102AD56C + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_102AD56C + 64);
  v4 = *(_DWORD *)(dword_102AD56C + 72);
  v5 = *(_DWORD *)(dword_102AD56C + 68);
  v19 = *(float *)(dword_102AD56C + 80);
  v18 = *(float *)(dword_102AD56C + 76);
  v6 = *(_DWORD *)(dword_102AD56C + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  v17 = *(float *)(dword_102AD56C + 48);
  v7 = v18;
  v8 = 10.0;
  if ( (LODWORD(v18) & 0x7F800000) == 2139095040 || v7 > 10.0 || (v8 = v17, v17 > v7) )
  {
    v9 = v8;
    v7 = v9;
  }
  v10 = v19;
  v11 = 2.0;
  if ( (LODWORD(v19) & 0x7F800000) == 2139095040 || v10 > 2.0 || (v11 = -2.0, v10 < -2.0) )
  {
    v12 = v11;
    v10 = v12;
  }
  v16 = v2
      * v10
      * ((double)(unsigned int)(*(_DWORD *)(dword_102AD56C + 36) - *(_DWORD *)(dword_102AD56C + 68))
       / (double)1000);
  v13 = v7 + v16;
  v14 = v13;
  *a1 = v13;
  if ( (LODWORD(v16) >> 31) & 1 && *(float *)(dword_102AD56C + 72) >= v14 )
  {
    result = 1;
    *a1 = *(float *)(dword_102AD56C + 72);
  }
  else if ( (LODWORD(v16) >> 31) & 1 || *(float *)(dword_102AD56C + 72) > v14 )
  {
    result = 0;
  }
  else
  {
    *a1 = *(float *)(dword_102AD56C + 72);
    result = 1;
  }
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (100415F0) --------------------------------------------------------
char __cdecl sub_100415F0(float *a1)
{
  float v1; // ST04_4@1
  double v2; // st7@1
  int v3; // ST0C_4@1
  int v4; // ST14_4@1
  int v5; // ST10_4@1
  int v6; // ST20_4@1
  double v7; // st5@7
  double v8; // st6@7
  double v9; // st6@13
  float v10; // ST1C_4@15
  float v11; // ST08_4@16
  double v12; // st7@16
  char result; // al@20
  float v14; // [sp+0h] [bp-20h]@16
  float v15; // [sp+14h] [bp-Ch]@1
  float v16; // [sp+14h] [bp-Ch]@8
  float v17; // [sp+18h] [bp-8h]@1

  v1 = *(float *)(dword_102AD56C + 688);
  v2 = v1;
  v3 = *(_DWORD *)(dword_102AD56C + 64);
  v4 = *(_DWORD *)(dword_102AD56C + 72);
  v5 = *(_DWORD *)(dword_102AD56C + 68);
  v17 = *(float *)(dword_102AD56C + 80);
  v15 = *(float *)(dword_102AD56C + 76);
  v6 = *(_DWORD *)(dword_102AD56C + 84);
  if ( (LODWORD(v1) & 0x7F800000) == 2139095040 || v2 > 1028.8889 || v2 < 0.0 )
    v2 = (float)0.0;
  if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 2.0 )
  {
    v8 = 2.0;
    v16 = 2.0;
    goto LABEL_10;
  }
  v7 = v15;
  v8 = 2.0;
  if ( v15 < 0.05760259181261063 )
  {
    v16 = 0.057602592;
LABEL_10:
    v7 = v16;
  }
  if ( (LODWORD(v17) & 0x7F800000) != 2139095040 && v17 <= v8 )
  {
    v9 = v17;
    if ( v17 >= -2.0 )
      goto LABEL_16;
    v8 = -2.0;
  }
  v10 = v8;
  v9 = v10;
LABEL_16:
  v14 = v2
      * v9
      * ((double)(unsigned int)(*(_DWORD *)(dword_102AD56C + 36) - *(_DWORD *)(dword_102AD56C + 68))
       / (double)1000);
  v11 = v7 + v14;
  v12 = v11;
  *a1 = v11;
  if ( (LODWORD(v14) >> 31) & 1 && v12 <= 1.01 )
  {
    result = 1;
    *a1 = 1.0;
  }
  else if ( (LODWORD(v14) >> 31) & 1 || v12 < 0.9900000095367432 )
  {
    result = 0;
  }
  else
  {
    result = 1;
    *a1 = 1.0;
  }
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (100417A0) --------------------------------------------------------
unsigned int __cdecl sub_100417A0(char a1, _BYTE *a2, float *a3)
{
  _BYTE *v3; // esi@1
  float *v4; // edi@1
  int v5; // edx@1
  int v6; // ST14_4@1
  int v7; // ST18_4@1
  int v8; // ST1C_4@1
  int v9; // ST20_4@1
  double v10; // st7@3
  char v11; // bl@6
  unsigned int result; // eax@33
  float v13; // [sp+24h] [bp-4h]@1

  v3 = a2;
  *a2 = 1;
  v4 = a3;
  *a3 = 2.0;
  v5 = *(_DWORD *)(dword_102AD56C + 64);
  v6 = *(_DWORD *)(dword_102AD56C + 68);
  v7 = *(_DWORD *)(dword_102AD56C + 72);
  v8 = *(_DWORD *)(dword_102AD56C + 76);
  v9 = *(_DWORD *)(dword_102AD56C + 80);
  v13 = *(float *)(dword_102AD56C + 84);
  *(float *)&a2 = v13;
  if ( (LODWORD(v13) & 0x7F800000) == 2139095040 || v13 > 4.0 )
  {
    v13 = 4.0;
    v10 = 4.0;
  }
  else
  {
    v10 = 4.0;
    if ( v13 < 0.30000001 )
      v13 = 0.30000001;
  }
  v11 = a1;
  if ( !a1 && *(_BYTE *)(dword_102AD56C + 99) == a1 )
    v11 = 1;
  if ( BYTE3(v5) == 6 )
  {
    if ( (unsigned __int8)v11 < *(_BYTE *)(dword_102AD56C + 94) && *(_BYTE *)(dword_102AD56C + 816) )
      v11 = *(_BYTE *)(dword_102AD56C + 94);
    if ( -1.0 != *(float *)(dword_102AD56C + 116) )
      v11 = 5;
    switch ( v11 )
    {
      case 4:
        *v4 = sub_10040F00(&a1);
        *v3 = 4;
        break;
      case 3:
        *v4 = 0.30000001;
        *v3 = 3;
        break;
      case 2:
        *v4 = 1.0;
        *v3 = 2;
        break;
      case 0:
        *v4 = v10;
        *v3 = 0;
        break;
      case 5:
        *v4 = sub_100413E0(*(float *)(dword_102AD56C + 116));
        *v3 = 5;
        break;
      default:
        break;
    }
LABEL_30:
    if ( v11 == 5 )
      goto LABEL_33;
    goto LABEL_31;
  }
  if ( BYTE3(v5) == 2 )
  {
    sub_100415F0(v4);
    *v3 = 2;
    goto LABEL_30;
  }
  if ( BYTE3(v5) == 4 )
  {
    sub_10041040(v4);
    *v3 = 4;
    goto LABEL_30;
  }
  if ( BYTE3(v5) == 5 )
  {
    sub_10041450(v4);
    *v3 = 5;
    goto LABEL_30;
  }
  sub_10041270(v4);
  if ( v11 )
  {
    *v3 = 1;
    goto LABEL_30;
  }
  *v3 = 0;
LABEL_31:
  if ( v13 + 0.009999999776482582 < *v4 )
  {
    *v4 = v13;
    *v3 = *(_BYTE *)(dword_102AD56C + 1201);
  }
LABEL_33:
  result = *v3;
  if ( result >= 6 )
    result = 1;
  *v3 = result;
  return result;
}
// 102AD56C: using guessed type int dword_102AD56C;

//----- (10041990) --------------------------------------------------------
double __cdecl sub_10041990(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 != v4 && (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v11 = v2 + v9;
        result = v11;
      }
      else
      {
        v10 = v4;
        result = v10;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10041A30) --------------------------------------------------------
int __cdecl sub_10041A30(signed int a1, signed int a2)
{
  int result; // eax@2

  if ( a2 > 0 )
  {
    result = a2 * (a1 / a2);
    if ( a1 == result )
    {
      result = a1;
    }
    else if ( a1 < 0 )
    {
      result -= a2;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10041A70) --------------------------------------------------------
double __cdecl sub_10041A70(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10041B10) --------------------------------------------------------
double __cdecl sub_10041B10(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (10041B70) --------------------------------------------------------
double __cdecl sub_10041B70(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (10041BF0) --------------------------------------------------------
void __cdecl sub_10041BF0(double a1)
{
  sub_10041B10(a1, 3.1415926535898);
}

//----- (10041C10) --------------------------------------------------------
double __cdecl sub_10041C10(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_10041B70(a1, 3.1415927);
  return result;
}

//----- (10041C50) --------------------------------------------------------
int __cdecl sub_10041C50(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (10041C70) --------------------------------------------------------
double __cdecl sub_10041C70(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10041CE0) --------------------------------------------------------
int __cdecl sub_10041CE0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (10041D00) --------------------------------------------------------
int __cdecl sub_10041D00(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(double *)a2 = *(float *)a1;
  *(double *)(a2 + 8) = *(float *)(a1 + 4);
  return result;
}

//----- (10041D20) --------------------------------------------------------
int __cdecl sub_10041D20(float a1)
{
  double v1; // st7@1
  int result; // eax@3
  float v3; // [sp+8h] [bp+4h]@1
  float v4; // [sp+8h] [bp+4h]@2
  float v5; // [sp+8h] [bp+4h]@3

  v3 = sub_10041C10(a1);
  v1 = v3;
  if ( v3 < 0.0 )
  {
    v4 = v1 + 6.283185482025146;
    v1 = v4;
  }
  v5 = v1 * 180.0 / 3.1415926535898;
  result = (signed int)(v5 + 0.5);
  if ( result >= 360 )
    result = 0;
  return result;
}

//----- (10041D80) --------------------------------------------------------
double __cdecl sub_10041D80(float a1)
{
  double v1; // st7@1
  float v3; // [sp+8h] [bp+4h]@1
  float v4; // [sp+8h] [bp+4h]@2

  v3 = sub_10041C10(a1);
  v1 = v3;
  if ( v3 < 0.0 )
  {
    v4 = v1 + 6.283185482025146;
    v1 = v4;
  }
  return (float)(v1 * 180.0 / 3.1415926535898);
}

//----- (10041DD0) --------------------------------------------------------
double __cdecl sub_10041DD0(double a1, double a2)
{
  double result; // st7@1

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707963267949;
      else
        result = 1.5707963267949;
    }
  }
  else
  {
    result = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      result = result + 3.1415926535898;
      sub_10041BF0(result);
    }
  }
  return result;
}

//----- (10041E40) --------------------------------------------------------
double __cdecl sub_10041E40(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_10041C10(v4);
    }
    result = v3;
  }
  return result;
}

//----- (10041ED0) --------------------------------------------------------
unsigned int __cdecl sub_10041ED0(unsigned __int8 a1, unsigned int a2)
{
  return dword_100DA538[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 100DA538: using guessed type int dword_100DA538[];

//----- (10041EF0) --------------------------------------------------------
unsigned int __cdecl sub_10041EF0(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_100DA538[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_100DA538[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_100DA538[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_100DA538[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_100DA538[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_100DA538[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_100DA538[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_100DA538[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_100DA538[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_100DA538[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 100DA538: using guessed type int dword_100DA538[];

//----- (10042020) --------------------------------------------------------
int __cdecl sub_10042020(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (10042050) --------------------------------------------------------
int __cdecl sub_10042050(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (10042AEC) --------------------------------------------------------
int __cdecl sub_10042AEC(int a1, int a2, char a3)
{
  return vscan_fn(sub_10046EEA, a2, 0, &a3);
}
// 10042A84: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10046CA4) --------------------------------------------------------
int __cdecl sub_10046CA4(int a1)
{
  int result; // eax@1

  result = a1;
  dword_102590F4 = a1;
  return result;
}
// 102590F4: using guessed type int dword_102590F4;

//----- (10046EEA) --------------------------------------------------------
int __cdecl sub_10046EEA(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_100EE358;
  }
  else
  {
    v6 = &dword_102AE5E0[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_100EE358) : (v8 = &dword_102AE5E0[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1004F24C(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1004F24C(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1004F24C(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1004F24C(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1004F24C(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_100EE29C[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1004F24C(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1004F24C(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1004F24C(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1004F24C(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 10046DAA: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10046EAF: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 10046EC5: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 10048AAB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 100EE29C: using guessed type int (*off_100EE29C[3])();
// 102AE5E0: using guessed type int dword_102AE5E0[];
// 10046EEA: using guessed type char var_24[11];

//----- (10047B37) --------------------------------------------------------
int __cdecl sub_10047B37(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1004FDFD() + 8 && (void **)v2 != sub_1004FDFD() + 16 || !sub_1004FD9F((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_100EE358;
      else
        v9 = (_BYTE *)(dword_102AE5E0[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_1004FC7F((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_1004FC7F((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 1004FD5B: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (10048775) --------------------------------------------------------
signed int __cdecl sub_10048775(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_102590FC )
  {
    *a1 = dword_102590FC;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10046DAA: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102590FC: using guessed type int dword_102590FC;

//----- (100487AC) --------------------------------------------------------
signed int __cdecl sub_100487AC(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_102590FC )
  {
    *a1 = dword_10259108;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 10046DAA: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102590FC: using guessed type int dword_102590FC;
// 10259108: using guessed type int dword_10259108;

//----- (100493F2) --------------------------------------------------------
void sub_100493F2()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_102AE5E0;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_102AE6E0 );
}
// 102AE5E0: using guessed type int dword_102AE5E0[];
// 102AE6E0: using guessed type int dword_102AE6E0;

//----- (1004989F) --------------------------------------------------------
int (*sub_1004989F())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_100EC5F0;
  v1 = (int (**)(void))&unk_100EC5F0;
  if ( &unk_100EC5F0 < &unk_100EC5F0 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_100EC5F0 );
  }
  return result;
}

//----- (100498C3) --------------------------------------------------------
void __cdecl sub_100498C3()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_100EC5F8;
  if ( &unk_100EC5F8 < &unk_100EC5F8 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_100EC5F8 );
  }
}

//----- (1004DC14) --------------------------------------------------------
#error "1004DC19: positive sp value has been found (funcsize=0)"

//----- (1004DC1F) --------------------------------------------------------
#error "1004DC24: positive sp value has been found (funcsize=0)"

//----- (1004DC2A) --------------------------------------------------------
#error "1004DC2F: positive sp value has been found (funcsize=0)"

//----- (1004DC30) --------------------------------------------------------
#error "1004DC35: positive sp value has been found (funcsize=0)"

//----- (1004DC36) --------------------------------------------------------
#error "1004DC3B: positive sp value has been found (funcsize=0)"

//----- (1004DC3C) --------------------------------------------------------
#error "1004DC41: positive sp value has been found (funcsize=0)"

//----- (1004DC42) --------------------------------------------------------
#error "1004DC5D: positive sp value has been found (funcsize=0)"

//----- (1004DC63) --------------------------------------------------------
#error "1004DC78: positive sp value has been found (funcsize=0)"

//----- (1004DC7E) --------------------------------------------------------
#error "1004DC99: positive sp value has been found (funcsize=0)"

//----- (1004DC9A) --------------------------------------------------------
#error "1004DCA9: positive sp value has been found (funcsize=0)"

//----- (1004DCAA) --------------------------------------------------------
#error "1004DCBD: positive sp value has been found (funcsize=0)"

//----- (1004DCBE) --------------------------------------------------------
#error "1004DCCD: positive sp value has been found (funcsize=0)"

//----- (1004DCCE) --------------------------------------------------------
#error "1004DCED: positive sp value has been found (funcsize=0)"

//----- (1004DCF3) --------------------------------------------------------
#error "1004DD0C: positive sp value has been found (funcsize=0)"

//----- (1004DD12) --------------------------------------------------------
#error "1004DD31: positive sp value has been found (funcsize=0)"

//----- (1004DD32) --------------------------------------------------------
#error "1004DD45: positive sp value has been found (funcsize=0)"

//----- (1004DD46) --------------------------------------------------------
#error "1004DD5D: positive sp value has been found (funcsize=0)"

//----- (1004DD5E) --------------------------------------------------------
#error "1004DD71: positive sp value has been found (funcsize=0)"

//----- (1004DD72) --------------------------------------------------------
#error "1004DD91: positive sp value has been found (funcsize=0)"

//----- (1004DD97) --------------------------------------------------------
#error "1004DDB0: positive sp value has been found (funcsize=0)"

//----- (1004DDB6) --------------------------------------------------------
#error "1004DDD5: positive sp value has been found (funcsize=0)"

//----- (1004DDD6) --------------------------------------------------------
#error "1004DDE9: positive sp value has been found (funcsize=0)"

//----- (1004DDEA) --------------------------------------------------------
#error "1004DE01: positive sp value has been found (funcsize=0)"

//----- (1004DE02) --------------------------------------------------------
#error "1004DE15: positive sp value has been found (funcsize=0)"

//----- (1004DE16) --------------------------------------------------------
#error "1004DE35: positive sp value has been found (funcsize=0)"

//----- (1004DE3B) --------------------------------------------------------
#error "1004DE54: positive sp value has been found (funcsize=0)"

//----- (1004DE5A) --------------------------------------------------------
#error "1004DE79: positive sp value has been found (funcsize=0)"

//----- (1004DE7A) --------------------------------------------------------
#error "1004DE8D: positive sp value has been found (funcsize=0)"

//----- (1004DE8E) --------------------------------------------------------
#error "1004DEA5: positive sp value has been found (funcsize=0)"

//----- (1004DEA6) --------------------------------------------------------
#error "1004DEB9: positive sp value has been found (funcsize=0)"

//----- (1004DEBA) --------------------------------------------------------
#error "1004DED9: positive sp value has been found (funcsize=0)"

//----- (1004DEDF) --------------------------------------------------------
#error "1004DEF8: positive sp value has been found (funcsize=0)"

//----- (1004DEFE) --------------------------------------------------------
#error "1004DF1D: positive sp value has been found (funcsize=0)"

//----- (1004DF1E) --------------------------------------------------------
#error "1004DF31: positive sp value has been found (funcsize=0)"

//----- (1004DF32) --------------------------------------------------------
#error "1004DF49: positive sp value has been found (funcsize=0)"

//----- (1004DF4A) --------------------------------------------------------
#error "1004DF5D: positive sp value has been found (funcsize=0)"

//----- (1004DF5E) --------------------------------------------------------
#error "1004DF7D: positive sp value has been found (funcsize=0)"

//----- (1004DF83) --------------------------------------------------------
#error "1004DF9C: positive sp value has been found (funcsize=0)"

//----- (1004DFA2) --------------------------------------------------------
#error "1004DFC1: positive sp value has been found (funcsize=0)"

//----- (1004DFC2) --------------------------------------------------------
#error "1004DFD5: positive sp value has been found (funcsize=0)"

//----- (1004DFD6) --------------------------------------------------------
#error "1004DFED: positive sp value has been found (funcsize=0)"

//----- (1004DFEE) --------------------------------------------------------
#error "1004E001: positive sp value has been found (funcsize=0)"

//----- (1004E002) --------------------------------------------------------
#error "1004E021: positive sp value has been found (funcsize=0)"

//----- (1004E027) --------------------------------------------------------
#error "1004E040: positive sp value has been found (funcsize=0)"

//----- (1004E046) --------------------------------------------------------
#error "1004E065: positive sp value has been found (funcsize=0)"

//----- (1004E066) --------------------------------------------------------
#error "1004E079: positive sp value has been found (funcsize=0)"

//----- (1004E07A) --------------------------------------------------------
#error "1004E091: positive sp value has been found (funcsize=0)"

//----- (1004E092) --------------------------------------------------------
#error "1004E0A5: positive sp value has been found (funcsize=0)"

//----- (1004E87B) --------------------------------------------------------
int __cdecl sub_1004E87B(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10052039((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1004B951: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004E921) --------------------------------------------------------
int __cdecl sub_1004E921(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1005257B((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1004B951: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004EE42) --------------------------------------------------------
int sub_1004EE42()
{
  dword_102AE6F8 = _get_sse2_info();
  return 0;
}
// 1004EDE2: using guessed type int _get_sse2_info(void);
// 102AE6F8: using guessed type int dword_102AE6F8;

//----- (1004EE4F) --------------------------------------------------------
void sub_1004EE4F()
{
  dword_102AE5C4 = 0;
}
// 102AE5C4: using guessed type int dword_102AE5C4;

//----- (1004F12C) --------------------------------------------------------
int __cdecl sub_1004F12C(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_100EE358;
    }
    else
    {
      v7 = &dword_102AE5E0[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 10046DAA: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004FD5B: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (1004F24C) --------------------------------------------------------
int __cdecl sub_1004F24C(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_100EE358;
    }
    else
    {
      v2 = &dword_102AE5E0[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_100EE358) : (v4 = &dword_102AE5E0[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 10046DAA: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1004FD5B: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (1004F4C1) --------------------------------------------------------
signed int __cdecl sub_1004F4C1(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_10054AD7(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_102AE5E0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 10044ABB: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (1004F65D) --------------------------------------------------------
_WORD *__cdecl sub_1004F65D(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  char v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_102AE5E0[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_102AE5E0[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_1004F4C1(a1, 0, 0, 2u);
  if ( sub_1004FD9F(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 10044ABB: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10046DAA: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10048CC7: using guessed type int _getptd(void);
// 102AE5E0: using guessed type int dword_102AE5E0[];
// 1004F65D: using guessed type CHAR var_410[688];

//----- (1004FC7F) --------------------------------------------------------
_WORD *__cdecl sub_1004FC7F(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_102AE5E0[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_1004F65D(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_10054BE8(a1);
  return v6;
}
// 10046DAA: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10054B48: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (1004FD9F) --------------------------------------------------------
int __cdecl sub_1004FD9F(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_102AE5E0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 10046DAA: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (1004FDFD) --------------------------------------------------------
void **sub_1004FDFD()
{
  return &off_100EED58;
}
// 100EED58: using guessed type void *off_100EED58;

//----- (1004FE03) --------------------------------------------------------
signed int sub_1004FE03()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_102AE5C0;
  if ( !dword_102AE5C0 )
  {
    v0 = 512;
LABEL_5:
    dword_102AE5C0 = v0;
    goto LABEL_6;
  }
  if ( dword_102AE5C0 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_102AD5AC = v1;
  if ( v1 || (dword_102AE5C0 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_102AD5AC = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_100EED58;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&unk_100EEFD8 )
        break;
      v1 = dword_102AD5AC;
    }
    v5 = 0;
    v6 = &unk_100EED68;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_102AE5E0[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_100EEDC8 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 100490BB: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 100EED58: using guessed type void *off_100EED58;
// 102AE5C0: using guessed type int dword_102AE5C0;
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (100506B2) --------------------------------------------------------
int sub_100506B2()
{
  return _decode_pointer(dword_10259730);
}
// 10048AAB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10259730: using guessed type int dword_10259730;

//----- (1005086F) --------------------------------------------------------
int __cdecl sub_1005086F(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1025973C = a1;
  return result;
}
// 1025973C: using guessed type int dword_1025973C;

//----- (10050879) --------------------------------------------------------
int __cdecl sub_10050879(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10259748 = a1;
  return result;
}
// 10259748: using guessed type int dword_10259748;

//----- (10050883) --------------------------------------------------------
int __cdecl sub_10050883(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1025974C = a1;
  return result;
}
// 1025974C: using guessed type int dword_1025974C;

//----- (10050962) --------------------------------------------------------
int __cdecl sub_10050962(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10259750 = a1;
  return result;
}
// 10259750: using guessed type int dword_10259750;

//----- (10052039) --------------------------------------------------------
signed int __cdecl sub_10052039(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100EF1B8 - 1;
    v64 = v3;
    v65 = dword_100EF1B8 / 32;
    v9 = dword_100EF1B8 % 32;
    v10 = (int *)(&v60 + dword_100EF1B8 / 32);
    v66 = 31 - dword_100EF1B8 % 32;
    if ( (1 << (31 - dword_100EF1B8 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100EF1B4 - dword_100EF1B8 )
    {
      if ( v3 > dword_100EF1B4 )
      {
        if ( v3 < dword_100EF1B0 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100EF1C4 + v3;
          v50 = dword_100EF1BC / 32;
          v51 = dword_100EF1BC % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100EF1BC % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100EF1BC / 32;
          v44 = dword_100EF1BC % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100EF1BC % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100EF1C4 + dword_100EF1B0;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100EF1B4 - v64) / 32;
      v62 = v59;
      v18 = (dword_100EF1B4 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100EF1B8 - 1;
      v25 = dword_100EF1B8 / 32;
      v65 = dword_100EF1B8 / 32;
      v26 = (int *)(&v60 + dword_100EF1B8 / 32);
      v64 = 31 - dword_100EF1B8 % 32;
      if ( (1 << (31 - dword_100EF1B8 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100EF1B8 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100EF1BC + 1) / 32;
      v37 = (dword_100EF1BC + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100EF1BC));
  if ( dword_100EF1C0 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100EF1C0 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100EF1B0: using guessed type int dword_100EF1B0;
// 100EF1B4: using guessed type int dword_100EF1B4;
// 100EF1B8: using guessed type int dword_100EF1B8;
// 100EF1BC: using guessed type int dword_100EF1BC;
// 100EF1C0: using guessed type int dword_100EF1C0;
// 100EF1C4: using guessed type int dword_100EF1C4;

//----- (1005257B) --------------------------------------------------------
signed int __cdecl sub_1005257B(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_100EF1D0 - 1;
    v64 = v3;
    v65 = dword_100EF1D0 / 32;
    v9 = dword_100EF1D0 % 32;
    v10 = (int *)(&v60 + dword_100EF1D0 / 32);
    v66 = 31 - dword_100EF1D0 % 32;
    if ( (1 << (31 - dword_100EF1D0 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_100EF1CC - dword_100EF1D0 )
    {
      if ( v3 > dword_100EF1CC )
      {
        if ( v3 < dword_100EF1C8 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_100EF1DC + v3;
          v50 = dword_100EF1D4 / 32;
          v51 = dword_100EF1D4 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_100EF1D4 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_100EF1D4 / 32;
          v44 = dword_100EF1D4 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_100EF1D4 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_100EF1DC + dword_100EF1C8;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_100EF1CC - v64) / 32;
      v62 = v59;
      v18 = (dword_100EF1CC - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_100EF1D0 - 1;
      v25 = dword_100EF1D0 / 32;
      v65 = dword_100EF1D0 / 32;
      v26 = (int *)(&v60 + dword_100EF1D0 / 32);
      v64 = 31 - dword_100EF1D0 % 32;
      if ( (1 << (31 - dword_100EF1D0 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_100EF1D0 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_100EF1D4 + 1) / 32;
      v37 = (dword_100EF1D4 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_100EF1D4));
  if ( dword_100EF1D8 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_100EF1D8 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 100EF1C8: using guessed type int dword_100EF1C8;
// 100EF1CC: using guessed type int dword_100EF1CC;
// 100EF1D0: using guessed type int dword_100EF1D0;
// 100EF1D4: using guessed type int dword_100EF1D4;
// 100EF1D8: using guessed type int dword_100EF1D8;
// 100EF1DC: using guessed type int dword_100EF1DC;

//----- (10052EBC) --------------------------------------------------------
int sub_10052EBC()
{
  return 0;
}

//----- (10054A56) --------------------------------------------------------
signed int __cdecl sub_10054A56(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_102AE5E0[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_10258DC8 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 10258DC8: using guessed type int dword_10258DC8;
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (10054AD7) --------------------------------------------------------
signed int __cdecl sub_10054AD7(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_102AE5E0[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 10046DAA: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (10054BE8) --------------------------------------------------------
void __cdecl sub_10054BE8(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_102AE5E0[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (10054EE9) --------------------------------------------------------
int sub_10054EE9()
{
  return flsall(1);
}
// 10054E0F: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (10054EF2) --------------------------------------------------------
int __cdecl sub_10054EF2(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_1025976C )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_1025976C = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_10259770 = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_10259774 = _encode_pointer(v7);
    if ( sub_10048775(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_1025977C = _encode_pointer(v8);
      if ( dword_1025977C )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_10259778 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_10259778 == v23
    || dword_1025977C == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_10259778),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_1025977C),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_10259770 != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_10259770);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_10259774 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_10259774);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_100487AC(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_1025976C);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 10046CAE: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10048A34: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 10048AA2: using guessed type int _encoded_null(void);
// 10048AAB: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 1025976C: using guessed type int dword_1025976C;
// 10259770: using guessed type int dword_10259770;
// 10259774: using guessed type int dword_10259774;
// 10259778: using guessed type int dword_10259778;
// 1025977C: using guessed type int dword_1025977C;

//----- (10055641) --------------------------------------------------------
signed int __cdecl sub_10055641(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_10054AD7(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_102AE5E0[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_102AE5E0[0] + 68) & 1)
    && (v1 = sub_10054AD7(2), sub_10054AD7(1) == v1)
    || (v2 = (void *)sub_10054AD7(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_10054A56(a1);
  *(_BYTE *)(dword_102AE5E0[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10044ABB: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 102AE5E0: using guessed type int dword_102AE5E0[];

//----- (10055820) --------------------------------------------------------
signed int __cdecl sub_10055820(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_100558A0(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_100567C0(v4, a4, 0) == a4 )
      result = sub_10056760(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10055880) --------------------------------------------------------
signed int __cdecl sub_10055880(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_100558A0(a1);
  return sub_100567C0(v3, a2, a3);
}

//----- (100558A0) --------------------------------------------------------
unsigned int __cdecl sub_100558A0(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (100558C0) --------------------------------------------------------
bool __cdecl sub_100558C0(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10055990) --------------------------------------------------------
int __cdecl sub_10055990(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (100559B0) --------------------------------------------------------
int __cdecl sub_100559B0(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10055990(a1 + 20);
  return result;
}

//----- (100559F0) --------------------------------------------------------
signed int __cdecl sub_100559F0(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_1003E500(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_1003E500(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10055AB0) --------------------------------------------------------
int __cdecl sub_10055AB0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10055AF0) --------------------------------------------------------
int __usercall sub_10055AF0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_1005A520(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_1003E5F0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_1003E610(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10055BA0) --------------------------------------------------------
signed int __usercall sub_10055BA0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_1003E640(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1005A970((void *)(v2 + 555), v7);
  }
  else
  {
    sub_100559F0(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_1003E500(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_1003E500(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_1005A840(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_1003E640(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_1003E640(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (10055D70) --------------------------------------------------------
char __usercall sub_10055D70@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_1005A4D0(a2, a3, a1 + 212);
}

//----- (10055D80) --------------------------------------------------------
int __usercall sub_10055D80@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10055AF0(result + 148, result);
  return result;
}

//----- (10055DA0) --------------------------------------------------------
char __usercall sub_10055DA0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (10055DC0) --------------------------------------------------------
unsigned int __usercall sub_10055DC0@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  unsigned int result; // eax@1

  v2 = sub_10041ED0(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_10041ED0(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10055E00) --------------------------------------------------------
int __fastcall sub_10055E00(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10055E20) --------------------------------------------------------
int __usercall sub_10055E20@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_1003E730(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_1003E610(v4, v3, 0);
}
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10055E60) --------------------------------------------------------
signed int __usercall sub_10055E60@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_10055E00(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_10041EF0(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_10055D70(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_1005C720(a2 + 28, 4);
      else
        v22 = sub_1005C720(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_10055D70(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10056070) --------------------------------------------------------
int __cdecl sub_10056070(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_10055D80(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10019F70(&v23);
    sub_10014EA0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_100559B0(v1, (int)&v24);
  v13 = sub_1003E5F0(v31);
  if ( v3 == v31 )
  {
    result = sub_1003E430(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_1003E730(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_1003E430(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_1003E730(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10055990(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10055E20(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_1003E5F0(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 1003E630: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (100562E0) --------------------------------------------------------
signed int __cdecl sub_100562E0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_1003E730(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10055E60(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10056380) --------------------------------------------------------
unsigned int __usercall sub_10056380@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_10055DA0(a1);
  *v3 ^= v2;
  return sub_10055DC0(v1, *v3);
}

//----- (100563A0) --------------------------------------------------------
unsigned int __usercall sub_100563A0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  unsigned int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10056380(a2);
  return result;
}

//----- (100563D0) --------------------------------------------------------
signed int __usercall sub_100563D0@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_10055DC0(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_1003E500(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (100564C0) --------------------------------------------------------
char __usercall sub_100564C0@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_1005A480(a1, a2, a3 + 212);
  else
    result = sub_100563A0(a2, a3 + 148);
  return result;
}

//----- (100564F0) --------------------------------------------------------
signed int __usercall sub_100564F0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10055BA0(v3, v1);
  else
    result = sub_100563D0(v3, v1);
  return result;
}

//----- (10056520) --------------------------------------------------------
signed int __cdecl sub_10056520(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10055AB0(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_1005E190(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_100564F0(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10056570) --------------------------------------------------------
signed int __cdecl sub_10056570(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_1003E500(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_100564C0(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_1003E500(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_1005A520(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_10055E00(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_1005F550(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_10041EF0(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_10041EF0(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (10056760) --------------------------------------------------------
signed int __cdecl sub_10056760(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_10056570(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_100558C0(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (100567C0) --------------------------------------------------------
signed int __cdecl sub_100567C0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10056520(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10055AB0(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10056520(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_10056760(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (10056950) --------------------------------------------------------
signed int __usercall sub_10056950@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_100E91F0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_100E85F0[2 * (unsigned __int8)v68] ^ dword_100E89F0[2 * BYTE1(v65)] ^ dword_100E8DF0[2 * (unsigned __int8)(v66 >> 16)] ^ dword_100E91F0[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_100E91F0[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_100E91F0[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_100E91F0[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_100E91F0[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_100E91F0[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_100E91F0[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_100E91F0[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_100E91F0[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_100E95F0[(unsigned __int8)v57] ^ dword_100EA1F0[v58 >> 24] ^ dword_100E99F0[BYTE1(v59)] ^ dword_100E9DF0[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_100E95F0[(unsigned __int8)v59] ^ dword_100E9DF0[(unsigned __int8)(v58 >> 16)] ^ dword_100EA1F0[v57 >> 24] ^ dword_100E99F0[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_100E95F0[(unsigned __int8)v60] ^ dword_100E99F0[BYTE1(v58)] ^ dword_100E9DF0[(unsigned __int8)(v57 >> 16)] ^ dword_100EA1F0[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_100E95F0[(unsigned __int8)v58] ^ dword_100E99F0[BYTE1(v57)] ^ dword_100E9DF0[(unsigned __int8)(v59 >> 16)] ^ dword_100EA1F0[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100E91F0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_100E91F0[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_100E91F0[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100E91F0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_100E91F0[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_100E85F0[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_100E89F0[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_100E8DF0[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_100E91F0[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 100E95F0: using guessed type int dword_100E95F0[];
// 100E99F0: using guessed type int dword_100E99F0[];
// 100E9DF0: using guessed type int dword_100E9DF0[];
// 100EA1F0: using guessed type int dword_100EA1F0[];

//----- (10057A00) --------------------------------------------------------
int __usercall sub_10057A00@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_10056950(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (10057A60) --------------------------------------------------------
signed int __usercall sub_10057A60@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_100EA1F0[(unsigned __int8)v9] ^ dword_100E95F0[BYTE1(v9)] ^ dword_100E99F0[(unsigned __int8)(v9 >> 16)] ^ dword_100E9DF0[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_100EA1F0[(unsigned __int8)v129] ^ dword_100E95F0[BYTE1(v129)] ^ dword_100E99F0[(unsigned __int8)(v129 >> 16)] ^ dword_100E9DF0[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_100EA1F0[(unsigned __int8)v133] ^ dword_100E95F0[BYTE1(v133)] ^ dword_100E99F0[(unsigned __int8)(v133 >> 16)] ^ dword_100E9DF0[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_100EA1F0[(unsigned __int8)v137] ^ dword_100E95F0[BYTE1(v137)] ^ dword_100E99F0[(unsigned __int8)(v137 >> 16)] ^ dword_100E9DF0[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_100EA1F0[(unsigned __int8)v141] ^ dword_100E95F0[BYTE1(v141)] ^ dword_100E99F0[(unsigned __int8)(v141 >> 16)] ^ dword_100E9DF0[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_100EA1F0[(unsigned __int8)v145] ^ dword_100E95F0[BYTE1(v145)] ^ dword_100E99F0[(unsigned __int8)(v145 >> 16)] ^ dword_100E9DF0[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_100EA1F0[(unsigned __int8)v149] ^ dword_100E95F0[BYTE1(v149)] ^ dword_100E99F0[(unsigned __int8)(v149 >> 16)] ^ dword_100E9DF0[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_100EA1F0[(unsigned __int8)v153] ^ dword_100E95F0[BYTE1(v153)] ^ dword_100E99F0[(unsigned __int8)(v153 >> 16)] ^ dword_100E9DF0[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_100EA1F0[(unsigned __int8)v157] ^ dword_100E95F0[BYTE1(v157)] ^ dword_100E99F0[(unsigned __int8)(v157 >> 16)] ^ dword_100E9DF0[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_100EA1F0[(unsigned __int8)v161] ^ dword_100E95F0[BYTE1(v161)] ^ dword_100E99F0[(unsigned __int8)(v161 >> 16)] ^ dword_100E9DF0[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_100EA1F0[(unsigned __int8)v77] ^ dword_100E95F0[BYTE1(v77)] ^ dword_100E99F0[(unsigned __int8)(v77 >> 16)] ^ dword_100E9DF0[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_100EA1F0[(unsigned __int8)v82] ^ dword_100E95F0[BYTE1(v82)] ^ dword_100E99F0[(unsigned __int8)(v82 >> 16)] ^ dword_100E9DF0[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_100EA1F0[(unsigned __int8)v89] ^ dword_100E95F0[BYTE1(v89)] ^ dword_100E99F0[(unsigned __int8)(v89 >> 16)] ^ dword_100E9DF0[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_100EA1F0[(unsigned __int8)v94] ^ dword_100E95F0[BYTE1(v94)] ^ dword_100E99F0[(unsigned __int8)(v94 >> 16)] ^ dword_100E9DF0[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_100EA1F0[(unsigned __int8)v100] ^ dword_100E95F0[BYTE1(v100)] ^ dword_100E99F0[(unsigned __int8)(v100 >> 16)] ^ dword_100E9DF0[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_100EA1F0[(unsigned __int8)v100] ^ dword_100E95F0[BYTE1(v100)] ^ dword_100E99F0[(unsigned __int8)(v100 >> 16)] ^ dword_100E9DF0[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_100EA1F0[(unsigned __int8)v108] ^ dword_100E95F0[BYTE1(v108)] ^ dword_100E99F0[(unsigned __int8)(v108 >> 16)] ^ dword_100E9DF0[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_100EA1F0[(unsigned __int8)v114] ^ dword_100E95F0[BYTE1(v114)] ^ dword_100E99F0[(unsigned __int8)(v114 >> 16)] ^ dword_100E9DF0[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_100EA1F0[(unsigned __int8)v120] ^ dword_100E95F0[BYTE1(v120)] ^ dword_100E99F0[(unsigned __int8)(v120 >> 16)] ^ dword_100E9DF0[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_100EA1F0[(unsigned __int8)v19] ^ dword_100E95F0[BYTE1(v19)] ^ dword_100E99F0[(unsigned __int8)(v19 >> 16)] ^ dword_100E9DF0[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_100E95F0[(unsigned __int8)v23] ^ dword_100E99F0[BYTE1(v23)] ^ dword_100E9DF0[(unsigned __int8)(v23 >> 16)] ^ dword_100EA1F0[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_100EA1F0[(unsigned __int8)v26] ^ dword_100E95F0[BYTE1(v26)] ^ dword_100E99F0[(unsigned __int8)(v26 >> 16)] ^ dword_100E9DF0[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_100E95F0[(unsigned __int8)v31] ^ dword_100E99F0[BYTE1(v31)] ^ dword_100E9DF0[(unsigned __int8)(v31 >> 16)] ^ dword_100EA1F0[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_100EA1F0[(unsigned __int8)v35] ^ dword_100E95F0[BYTE1(v35)] ^ dword_100E99F0[(unsigned __int8)(v35 >> 16)] ^ dword_100E9DF0[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_100E95F0[(unsigned __int8)v41] ^ dword_100E99F0[BYTE1(v41)] ^ dword_100E9DF0[(unsigned __int8)(v41 >> 16)] ^ dword_100EA1F0[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_100EA1F0[(unsigned __int8)v43] ^ dword_100E95F0[BYTE1(v43)] ^ dword_100E99F0[(unsigned __int8)(v43 >> 16)] ^ dword_100E9DF0[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_100E95F0[(unsigned __int8)v47] ^ dword_100E99F0[BYTE1(v47)] ^ dword_100E9DF0[(unsigned __int8)(v47 >> 16)] ^ dword_100EA1F0[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_100EA1F0[(unsigned __int8)v52] ^ dword_100E95F0[BYTE1(v52)] ^ dword_100E99F0[(unsigned __int8)(v52 >> 16)] ^ dword_100E9DF0[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_100E95F0[(unsigned __int8)v58] ^ dword_100E99F0[BYTE1(v58)] ^ dword_100E9DF0[(unsigned __int8)(v58 >> 16)] ^ dword_100EA1F0[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_100EA1F0[(unsigned __int8)v60] ^ dword_100E95F0[BYTE1(v60)] ^ dword_100E99F0[(unsigned __int8)(v60 >> 16)] ^ dword_100E9DF0[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_100E95F0[(unsigned __int8)v66] ^ dword_100E99F0[BYTE1(v66)] ^ dword_100E9DF0[(unsigned __int8)(v66 >> 16)] ^ dword_100EA1F0[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_100EA1F0[(unsigned __int8)v69] ^ dword_100E95F0[BYTE1(v69)] ^ dword_100E99F0[(unsigned __int8)(v69 >> 16)] ^ dword_100E9DF0[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 100E95F0: using guessed type int dword_100E95F0[];
// 100E99F0: using guessed type int dword_100E99F0[];
// 100E9DF0: using guessed type int dword_100E9DF0[];
// 100EA1F0: using guessed type int dword_100EA1F0[];

//----- (100587E0) --------------------------------------------------------
void *__usercall sub_100587E0@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10058800) --------------------------------------------------------
unsigned int __cdecl sub_10058800(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_1003DC90();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 1003DCE0: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (10058860) --------------------------------------------------------
int __usercall sub_10058860@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = 271733878;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (100588A0) --------------------------------------------------------
int __usercall sub_100588A0@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (10059FC0) --------------------------------------------------------
unsigned int __usercall sub_10059FC0@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_100EA618[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_100EA628[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_100588A0(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_100588A0(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 100EA618: using guessed type int dword_100EA618[];
// 100EA628: using guessed type int dword_100EA628[];

//----- (1005A0C0) --------------------------------------------------------
void *__usercall sub_1005A0C0@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  char *v3; // ebp@1
  unsigned int v4; // ebx@1
  int v5; // edi@1
  size_t v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (char *)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*((_DWORD *)v3 + 1);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy(&v3[v5 + 28], v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_100588A0((int)v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy(&v3[v5 + 28], v9, v4);
}

//----- (1005A140) --------------------------------------------------------
void *__usercall sub_1005A140@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_10059FC0(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_10058860(v3 + 64);
    result = sub_1005A0C0(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_1005A0C0(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (1005A1E0) --------------------------------------------------------
int __usercall sub_1005A1E0@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_1005A140(a1, 0, 0);
  sub_10059FC0(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_10058860(a1 + 64);
  sub_1005A0C0(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_1005A0C0(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_10059FC0(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (1005A2A0) --------------------------------------------------------
int __usercall sub_1005A2A0@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_10058860(a2 + 64);
    sub_1005A0C0(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_1005A0C0(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (1005A300) --------------------------------------------------------
int __usercall sub_1005A300@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  char *v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = &a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_100588A0((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *((_DWORD *)v8 + 1) = v9;
    v12 = v18;
    *((_DWORD *)v8 + 2) = result;
    v1 += 20;
    *((_DWORD *)v8 + 3) = v11;
    *((_DWORD *)v8 + 4) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 1005A300: using guessed type char var_40[64];

//----- (1005A3C0) --------------------------------------------------------
int __usercall sub_1005A3C0@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_1005A300((char *)a1);
  return sub_1005A300(v8);
}

//----- (1005A480) --------------------------------------------------------
char __cdecl sub_1005A480(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_1005A140(a3 + 296, a2, a1);
    sub_10057A00(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005A4D0) --------------------------------------------------------
char __cdecl sub_1005A4D0(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10057A00(a3, (int)a1, a2);
    sub_1005A140(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005A520) --------------------------------------------------------
bool __cdecl sub_1005A520(int a1, int a2)
{
  if ( a2 )
    sub_1005A1E0(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (1005A550) --------------------------------------------------------
unsigned int __usercall sub_1005A550@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  unsigned int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_100587E0(&v24);
  sub_1005A2A0(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_1005A140((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_1005A140((int)&v23, v12, (char *)&v31);
          sub_1005A1E0((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 1005A550: using guessed type char var_14[16];

//----- (1005A760) --------------------------------------------------------
int __usercall sub_1005A760@<eax>(void *a1@<eax>, int a2)
{
  char *v2; // ebx@1
  signed int v3; // esi@1

  v2 = (char *)a1;
  memset(a1, 0, 0x210u);
  *((_DWORD *)v2 + 131) = a2;
  sub_1005A3C0((int)v2);
  v3 = 20;
  do
  {
    sub_1005A300(v2);
    --v3;
  }
  while ( v3 );
  return sub_1005A3C0((int)v2);
}

//----- (1005A7B0) --------------------------------------------------------
char *__cdecl sub_1005A7B0(int a1, int a2)
{
  char *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_1005A3C0(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (1005A840) --------------------------------------------------------
signed int __cdecl sub_1005A840(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_1005A550(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_10057A60(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_100587E0((void *)(a6 + 296));
      sub_1005A2A0(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 1005A840: using guessed type char var_40[8];
// 1005A840: using guessed type __int16 var_38[26];

//----- (1005A970) --------------------------------------------------------
bool __cdecl sub_1005A970(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_1005A760(&v4, (int)sub_10058800);
  if ( v2 )
    sub_1005A7B0(a2, (int)&v4);
  return v2;
}

//----- (1005A9F0) --------------------------------------------------------
BOOL __usercall sub_1005A9F0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_100EAE30[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_100EAD30[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_100EAC30[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (1005AA90) --------------------------------------------------------
int __usercall sub_1005AA90@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (1005AB20) --------------------------------------------------------
unsigned int __fastcall sub_1005AB20(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (1005AB40) --------------------------------------------------------
int __usercall sub_1005AB40@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (1005ABD0) --------------------------------------------------------
int __usercall sub_1005ABD0@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_100EAE30[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_100EAE30[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_100EA638[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_100EAF30[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_100EAD30[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_100EAC30[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_100EA6C0[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_100EAFA8[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 100EA638: using guessed type int dword_100EA638[];
// 100EA6C0: using guessed type int dword_100EA6C0[];
// 100EAF30: using guessed type int dword_100EAF30[];
// 100EAFA8: using guessed type int dword_100EAFA8[];

//----- (1005B050) --------------------------------------------------------
int __usercall sub_1005B050@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_1005AB40(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (1005B100) --------------------------------------------------------
void *__usercall sub_1005B100@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (1005B160) --------------------------------------------------------
int __usercall sub_1005B160@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (1005B330) --------------------------------------------------------
signed int __usercall sub_1005B330@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_1005AB20(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (1005B3B0) --------------------------------------------------------
_WORD *__fastcall sub_1005B3B0(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (1005B420) --------------------------------------------------------
unsigned int __usercall sub_1005B420@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (1005B5D0) --------------------------------------------------------
unsigned int __usercall sub_1005B5D0@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (1005B6A0) --------------------------------------------------------
int __usercall sub_1005B6A0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (1005B750) --------------------------------------------------------
int __usercall sub_1005B750@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (1005B790) --------------------------------------------------------
unsigned int __usercall sub_1005B790@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_1005D560(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005B7F0) --------------------------------------------------------
signed int __usercall sub_1005B7F0@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (1005B8D0) --------------------------------------------------------
int __usercall sub_1005B8D0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (1005BE70) --------------------------------------------------------
int __usercall sub_1005BE70@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_1005AA90(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_1005AA90(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_1005AA90(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (1005C0B0) --------------------------------------------------------
int __usercall sub_1005C0B0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_1005B050(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_1005B050(a1, a3, a4);
  }
  return result;
}

//----- (1005C150) --------------------------------------------------------
signed int __usercall sub_1005C150@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_1005B6A0(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_1005B6A0(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_1005B6A0(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_1005B160(a1, a2);
  return sub_1005B330(a1, v16, v5);
}

//----- (1005C330) --------------------------------------------------------
unsigned int __usercall sub_1005C330@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_1005B790(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (1005C470) --------------------------------------------------------
int __usercall sub_1005C470@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_100EA6AC[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_1005B8D0(a1, a1 + 2936, a2 - 1);
  return sub_1005B8D0(v24, v24 + 5228, a3 - 1);
}

//----- (1005C720) --------------------------------------------------------
signed int __cdecl sub_1005C720(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_1005B750(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_1005B750(v9, *(_WORD *)(a1 + 30));
      sub_1005B750(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_1005D560(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_1005B100(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_100EB028 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_1005BE70(v2);
    }
    else
    {
      sub_1005C0B0(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_1005B100(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_1005B750(v2, *(_WORD *)(a1 + 30));
    sub_1005B750(v13, *(_WORD *)(a1 + 28));
    sub_1005B100(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 100EB028: using guessed type int (__cdecl *off_100EB028)(int, int);

//----- (1005C9E0) --------------------------------------------------------
signed int __usercall sub_1005C9E0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_1005B7F0(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_1005B7F0(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_1005C150(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_100EA6AC[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100EA6AB[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100EA6AA[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_100EA6A9[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (1005CAB0) --------------------------------------------------------
_WORD *__usercall sub_1005CAB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_1005C150(a2, a2 + 5628);
  sub_1005C150(v4, v4 + 5640);
  v8 = sub_1005C9E0(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_1005C0B0(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_1005ABD0(v4, (int)&unk_100EA738, (int)&unk_100EABB8);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_1005C470(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_1005ABD0(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_1005B3B0(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_1005AB40(v4);
  return result;
}

//----- (1005CCD0) --------------------------------------------------------
signed int __cdecl sub_1005CCD0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1005C330(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_1005B420(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_1005B5D0(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_1005A9F0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_1005A9F0(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_1005CAB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1005B100(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_1005CAB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1005B100(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1005CFE0) --------------------------------------------------------
signed int __cdecl sub_1005CFE0(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_1005C330(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_1005B420(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_1005B5D0(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_1005A9F0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_1005CAB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_1005B100(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_1005A9F0(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_1005CAB0(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_1005B100(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_1005A9F0(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_1005CAB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1005B100(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1005D3F0) --------------------------------------------------------
signed int __cdecl sub_1005D3F0(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_1005C330(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_1005CAB0(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_1005B100(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_1005CAB0(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_1005B100(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_1005CAB0(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_1005B100(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1005D560) --------------------------------------------------------
_BYTE *__cdecl sub_1005D560(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  _BYTE *result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = (_BYTE *)(v4 | (v5 << 16));
  }
  else
  {
    result = a2 + 1;
  }
  return result;
}

//----- (1005D660) --------------------------------------------------------
signed int __cdecl sub_1005D660(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1005D680) --------------------------------------------------------
signed int __usercall sub_1005D680@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 1005D680: using guessed type int var_78[14];
// 1005D680: using guessed type int var_3C[15];

//----- (1005DB20) --------------------------------------------------------
int (__cdecl *__usercall sub_1005DB20@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (1005DB70) --------------------------------------------------------
int __usercall sub_1005DB70@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (1005DB90) --------------------------------------------------------
signed int __cdecl sub_1005DB90(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100EB210[a1];
  v51 = dword_100EB210[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100EB210[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100EB210[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100EB210[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100EB210[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100EB210: using guessed type int dword_100EB210[];

//----- (1005DF40) --------------------------------------------------------
int __usercall sub_1005DF40@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (1005E080) --------------------------------------------------------
signed int __usercall sub_1005E080@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_1005D680(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (1005E0D0) --------------------------------------------------------
signed int __usercall sub_1005E0D0@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_1005D680(a7, a6, a4, 257, (int)&unk_100EB2A8, (int)&unk_100EB328, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_1005D680(a8, &a6[a4], a5, 0, (int)&unk_100EB3A8, (int)&unk_100EB420, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005E170) --------------------------------------------------------
int __usercall sub_1005E170@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100EB498;
  *a4 = &unk_100EC498;
  return 0;
}

//----- (1005E190) --------------------------------------------------------
signed int __cdecl sub_1005E190(int a1)
{
  signed int result; // eax@2
  int v2; // ecx@3
  int v3; // esi@3

  if ( a1 )
  {
    v2 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    v3 = *(_DWORD *)(v2 + 20);
    *(_BYTE *)v2 = *(_DWORD *)(v2 + 12) != 0 ? 7 : 0;
    sub_1005DB20(0, v3, a1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (1005E1A0) --------------------------------------------------------
int __usercall sub_1005E1A0@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  signed int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_1005DB90(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100EB210[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100EB210[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100EB210[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100EB210[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_1005DF40(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_1005DF40(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_1005DF40(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_1005DF40(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100EB210: using guessed type int dword_100EB210[];

//----- (1005E840) --------------------------------------------------------
int __usercall sub_1005E840@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  signed int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_1005E170(&v67, &v69, &v66, &v68);
          sub_1005DB70(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_1005DF40(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100EB258[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100EB258[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_1005E080(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_1005E0D0(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_1005DB70(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_1005E1A0(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_1005DF40(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_1005DF40(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_1005DF40(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100EB210[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100EB210[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_1005DF40(v7, v3, v58);
}
// 100EB210: using guessed type int dword_100EB210[];
// 100EB258: using guessed type int dword_100EB258[];

//----- (1005F220) --------------------------------------------------------
signed int __usercall sub_1005F220@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_1005E840(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_1005DB20((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (1005F550) --------------------------------------------------------
signed int __cdecl sub_1005F550(int a1, int a2)
{
  return sub_1005F220(a1, a2);
}

#error "There were 50 decompilation failure(s) on 1403 function(s)"
