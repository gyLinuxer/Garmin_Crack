/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __cdecl sub_10001000(__int16 a1, int a2);
char __cdecl sub_10001060(unsigned __int16 a1);
int sub_100010F0();
char sub_10001100();
char __cdecl sub_10001180(int a1);
void sub_100011F0();
signed int sub_10001200();
char __cdecl sub_10001210(char a1);
void sub_100012B0();
signed int sub_100012C0();
char __cdecl sub_100012D0(char a1);
// char __usercall sub_10001380@<al>(char a1@<dl>, int a2@<ecx>, int a3);
char __cdecl sub_100013D0(int a1, int a2, char a3);
char __cdecl sub_100013F0(int a1, int a2);
char __cdecl sub_10001460(int a1, int a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, char a8);
char sub_10001500();
int sub_10001510();
char sub_10001520();
void sub_10001530();
int (__cdecl *sub_10001540())(_DWORD);
int __cdecl sub_10001550(char, char, char, char, int, void *, size_t); // idb
void *__cdecl sub_10001600(int a1);
// signed int __usercall sub_100016C0@<eax>(unsigned int a1@<eax>, int a2, char *a3, unsigned __int16 a4);
signed int sub_100018A0();
void *sub_100018F0();
void *sub_10001910();
void *sub_10001930();
char __cdecl sub_10001950(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7);
void *sub_10001AF0();
// char __usercall sub_10001B40@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int16 a3@<di>, unsigned int a4);
char __cdecl sub_10001C10(char *a1);
int sub_10001EF0();
char __cdecl sub_100021B0(int a1, int a2);
char __cdecl sub_100021E0(int a1, int a2);
char sub_10002250();
void sub_10002260();
char __thiscall sub_10002270(void *this);
char __cdecl sub_100022C0(int a1, int a2);
char __cdecl sub_100023C0(int a1, int a2);
char __cdecl sub_100023F0(int a1, int a2);
char __cdecl sub_10002430(int a1, int a2);
char __cdecl sub_10002510(int a1, int a2);
// char __usercall sub_10002550@<al>(int a1@<ebx>, int a2, int a3);
char __cdecl sub_10002770(int a1, int a2);
char __cdecl sub_100027A0(int a1, int a2);
char __cdecl sub_100027E0(int a1, int a2);
char __cdecl sub_10002880(int a1, int a2);
char __cdecl sub_100028B0(int a1, int a2);
char __thiscall sub_10002940(void *this);
// char __usercall sub_100029D0@<al>(void *a1@<ecx>, unsigned __int8 a2@<sil>);
char __cdecl sub_10002A40(int a1, int a2);
char __cdecl sub_10002AA0(int a1, int a2);
char __cdecl sub_10002B20(int a1, int a2);
char sub_10002B60();
char __cdecl sub_10002B90(int a1, int a2);
void *sub_10002C60();
signed int __thiscall sub_10002CB0(void *this);
void sub_10002DE0();
char sub_10002E00();
void __thiscall sub_10002EC0(void *this);
void sub_10002F00();
int __cdecl sub_10002FA0(char a1);
unsigned int __cdecl sub_10002FF0(int a1);
int sub_10003060();
void __noreturn sub_10003650();
char __thiscall sub_10003860(void *this);
int sub_10003CE0();
void *sub_10003D10();
unsigned int __cdecl sub_10003DF0(int a1);
// int __usercall sub_10003E30@<eax>(void (__cdecl *a1)(int, int, int, int)@<esi>, int a2, int a3, int a4, int a5);
char __cdecl sub_10003E70(int a1);
char __cdecl sub_10003F60(int a1, char a2);
char __cdecl sub_10003FF0(int a1, void *a2, size_t a3, void *a4, size_t a5);
char __cdecl sub_10004110(int a1, int a2);
int __cdecl sub_10004420(__int16 a1);
_BYTE *__cdecl sub_10004460(_DWORD **a1, __int16 a2, char a3);
int __cdecl sub_10004490(void *, int, int, int, int, int, int, int); // idb
int __cdecl sub_10004510(int a1, int a2);
// _BYTE *__usercall sub_10004530@<eax>(_BYTE *a1@<eax>, int a2@<ecx>, char a3@<bl>, int a4);
// signed int __usercall sub_10004600@<eax>(int a1@<eax>, __int16 a2, char a3, char a4, int a5, int a6);
// int __usercall sub_10004650@<eax>(int a1@<edi>, int a2, int a3);
// int __usercall sub_100046A0@<eax>(int result@<eax>, int a2@<edx>, unsigned int a3@<ecx>);
// signed int __usercall sub_100046C0@<eax>(int a1@<eax>, __int16 a2@<di>, char a3);
// unsigned int __usercall sub_10004720@<eax>(unsigned int result@<eax>, int a2@<ecx>);
// int __usercall sub_10004750@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10004790@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4);
// signed int __usercall sub_100048C0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>, char a5);
// int __usercall sub_10004910@<eax>(int a1@<eax>, int a2@<esi>);
// int (__cdecl *__usercall sub_10004960@<eax>(int a1@<esi>, int a2))(int, int);
// void *__usercall sub_10004990@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6, int a7, void *a8, int a9);
// int (__cdecl *__usercall sub_10004A30@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int (__cdecl *a4)(int, int)))(int, int);
// char __usercall sub_10004AF0@<al>(int a1@<eax>, int a2@<ecx>, int a3);
int (__cdecl *__cdecl sub_10004C30(int a1))(int, int);
int (__cdecl *__cdecl sub_10004C50(int a1, int a2))(int, int);
int __cdecl sub_10004CA0(void *, int, int, int); // idb
int __cdecl sub_10004CE0(void *, int, char, int, int, int, int, int); // idb
char __cdecl sub_10004D50(int a1, int a2, __int16 a3, char a4, int a5, int a6);
_DWORD **__cdecl sub_10004E50(int a1, int a2);
// char __usercall sub_10004ED0@<al>(int a1@<ecx>, int a2@<eax>, int a3, int a4, void *a5);
// int (__cdecl *__usercall sub_10005050@<eax>(char a1@<al>, int a2@<edx>, __int16 a3@<cx>, unsigned int a4))(int, unsigned int);
// signed int __usercall sub_100050D0@<eax>(int a1@<eax>, unsigned int *a2, int a3);
// signed int __usercall sub_10005230@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// _DWORD *__usercall sub_10005290@<eax>(char a1@<al>, __int16 a2@<cx>, char a3@<bl>, int a4, unsigned int a5, unsigned int a6);
signed int __cdecl sub_10005380(unsigned int *a1, int a2, int a3);
int __cdecl sub_10005540(void *, int, int, int); // idb
char __cdecl sub_10005570(int a1, int a2, void *a3, size_t a4);
// signed int __usercall sub_10005620@<eax>(char a1@<al>, int a2@<edx>, __int16 a3@<cx>, unsigned int *a4);
int (__cdecl *__cdecl sub_10005650(int a1, int a2))(int, int);
// int (__cdecl *__usercall sub_100056B0@<eax>(int a1@<esi>))(int, int);
int __cdecl sub_100056F0(void *, int, char, int, int, int, int, int); // idb
char __cdecl sub_10005740(int a1, int a2, int a3);
int sub_10005880(); // weak
int sub_100058A0(); // weak
// char __usercall sub_100058E0@<al>(char a1@<dl>, int a2@<ecx>, unsigned int *a3@<esi>);
int __cdecl sub_100059A0(void *, int); // idb
char __cdecl sub_10005A50(char *a1, char a2, int a3, char *a4);
char __cdecl sub_10005AF0(int a1);
// char __usercall sub_10005B50@<al>(unsigned __int8 a1@<bl>, int a2@<esi>);
int sub_10005B80(); // weak
char __cdecl sub_10005BF0(int a1);
// char __usercall sub_10005C20@<al>(int a1@<esi>);
char __cdecl sub_10005CA0(int a1);
char sub_10005D10();
int __cdecl sub_10005DC0(int a1);
void __cdecl sub_10005DE0(int a1, int a2);
char sub_10005FC0();
int sub_10005FE0(void); // weak
int __cdecl sub_10005FF0(int, int, int, void *, int, int); // idb
int __cdecl sub_100061D0(int a1, int a2, _WORD *a3, _BYTE *a4);
int __cdecl sub_10006230(int a1, int a2, int a3);
// signed int __usercall sub_100062F0@<eax>(_BYTE *a1@<eax>, void *a2@<edx>, int a3@<ecx>, _BYTE *a4);
unsigned int __cdecl sub_10006380(int a1, int a2, int a3, int a4, _WORD *a5);
int __cdecl sub_10006430(int, int, void *, int, int); // idb
int __cdecl sub_10006500(char a1, int a2);
// void *__cdecl operator new(unsigned int, void *); idb
int __cdecl sub_10006520(int a1, char *a2);
_DWORD *__cdecl sub_10006540(int a1, int a2, void *a3, int a4, void *a5);
// char __usercall sub_100065C0@<al>(int a1@<edi>, int a2@<esi>, int a3);
// int __usercall sub_10006610@<eax>(int a1@<edx>, _BYTE *a2@<ecx>, int a3, int a4, _DWORD *a5, int a6);
// int __usercall sub_100066D0@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// signed int __usercall sub_100067B0@<eax>(unsigned int a1@<eax>, _BYTE *a2@<edi>);
// unsigned int __usercall sub_10006800@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4, _DWORD *a5);
// char __usercall sub_10006980@<al>(int a1@<eax>, int a2@<esi>);
char __cdecl sub_100069A0(int a1);
char __cdecl sub_100069F0(int a1, int a2, int a3, int a4, int a5, void *a6, int a7, int a8, int a9, int a10, int a11);
BOOL __cdecl sub_10006F60(int a1, int a2, unsigned int a3, int a4);
unsigned int __cdecl sub_10007110(int a1, int a2, int a3, unsigned int a4);
char __cdecl sub_100072B0(__int16 a1, int a2);
int __cdecl sub_10007370(__int16 a1);
int sub_100073A0();
int __cdecl sub_100074B0(_DWORD *a1);
int __cdecl sub_100075C0(_DWORD *a1);
char sub_100076D0();
int __cdecl sub_10007A00(char *, int); // idb
char __cdecl sub_10007AC0(char *a1, int a2);
char __cdecl sub_10007CE0(int a1, int a2);
int sub_10007E20();
char sub_10008000();
int sub_100081D0();
char __cdecl sub_10008660(int a1);
char __thiscall sub_100088E0(void *this);
char __cdecl sub_10008960(char a1);
int __cdecl sub_10008A60(unsigned __int8 a1, char a2);
void __cdecl sub_10008AD0(__int16 a1);
int __cdecl sub_10008B40(unsigned __int8 a1, int a2);
int sub_10008BD0(); // weak
char __thiscall sub_10008C40(void *this);
char sub_10008D60();
char sub_10008E80();
signed int sub_10008F30();
char sub_10008F70();
char sub_100092C0();
char __cdecl sub_100094A0(unsigned __int16 a1);
char __thiscall sub_10009C10(void *this);
char __cdecl sub_10009C40(char a1);
char __cdecl sub_10009C90(void *a1);
char __cdecl sub_10009CD0(void *a1, int a2, int a3, __int16 a4);
char __cdecl sub_10009D30(int a1, int a2);
char __cdecl sub_10009DC0(__int16 a1);
char __cdecl sub_10009E30(int a1, int a2);
char __cdecl sub_10009F80(int a1, int a2);
void *__cdecl sub_1000A0D0(int a1, int a2);
int __cdecl sub_1000A1D0(int a1);
int __cdecl sub_1000A210(int a1, int a2);
char __cdecl sub_1000A250(int a1, int a2);
int __cdecl sub_1000A3A0(int a1, int a2);
char sub_1000A3E0();
char __cdecl sub_1000A410(char a1, char a2, char a3);
char __cdecl sub_1000A460(char a1, char a2, char a3);
char sub_1000A4B0();
char __cdecl sub_1000A4E0(char a1);
char sub_1000A510();
char __cdecl sub_1000A540(bool a1);
char sub_1000A570();
char __cdecl sub_1000A5A0(char a1);
char __cdecl sub_1000A5D0(__int16 a1, char a2);
char sub_1000A600();
char __cdecl sub_1000A630(char a1);
char sub_1000A660();
char sub_1000A690();
char __cdecl sub_1000A6C0(char a1);
char __cdecl sub_1000A6F0(int a1, int a2);
char sub_1000A740();
// char __usercall sub_1000A860@<al>(unsigned __int16 a1@<ax>, int a2, int a3, unsigned __int16 a4, int a5);
// char __usercall sub_1000AB20@<al>(__int16 a1@<ax>, __int16 a2@<cx>, int a3);
int __cdecl sub_1000AB40(int a1, int a2, unsigned int a3, unsigned int a4, char a5, char a6);
// int __usercall sub_1000ADF0@<eax>(int a1@<edi>, int a2, int a3, int a4, unsigned int a5, int a6, int a7);
// char __usercall sub_1000AFE0@<al>(unsigned __int8 a1@<al>, char a2);
char __cdecl sub_1000B330(char a1);
void *sub_1000B380();
int sub_1000B390();
signed int sub_1000B4F0();
char sub_1000B640();
// int __usercall sub_1000B750@<eax>(int result@<eax>, char a2@<bl>, char a3);
// char __usercall sub_1000B7C0@<al>(_WORD *a1@<eax>, void *a2@<ecx>);
// int __usercall sub_1000BC40@<eax>(int result@<eax>);
// char __usercall sub_1000BC80@<al>(int a1@<eax>, char a2@<dl>);
// char __usercall sub_1000BCF0@<al>(char a1@<al>, unsigned __int8 a2, char a3);
// char __usercall sub_1000BD80@<al>(int a1@<eax>, char a2@<dl>);
// char __usercall sub_1000BDF0@<al>(int a1@<eax>, char a2@<dl>);
// char __usercall sub_1000BE60@<al>(int a1@<eax>, char a2@<cl>, char a3@<bl>);
void sub_1000BFA0();
// int __usercall sub_1000C050@<eax>(int a1@<eax>);
void sub_1000C0D0();
int sub_1000C470();
void __noreturn sub_1000C710();
char __cdecl sub_1000C7F0(int a1);
char __cdecl sub_1000C800(int a1);
_BYTE *__cdecl sub_1000C830(int a1);
void *__cdecl sub_1000C900(int a1);
void *sub_1000C9F0();
void __cdecl sub_1000CA30(char *a1, unsigned __int8 a2);
char __cdecl sub_1000CA60(unsigned __int8 a1, _WORD *a2);
char __cdecl sub_1000CA90(int a1);
char sub_1000CBB0();
char __cdecl sub_1000CBE0(char a1, int a2, int a3, int a4, char a5, char *a6);
int sub_1000CC30();
// char __usercall sub_1000CC70@<al>(int a1@<esi>, int a2);
// char __usercall sub_1000CDF0@<al>(void *a1@<ecx>, int a2@<esi>, int a3);
// int __usercall sub_1000CE80@<eax>(int result@<eax>, char a2);
int __cdecl sub_1000CEA0(_DWORD); // weak
char __cdecl sub_1000CEB0(int a1, char a2);
char __cdecl sub_1000CF70(char a1);
// char __usercall sub_1000CFA0@<al>(void *a1@<ecx>, int a2@<ebx>, char a3);
char __cdecl sub_1000D060(int a1);
char __cdecl sub_1000D160(char a1, int a2, int a3, int a4, int a5, int a6);
void sub_1000D260();
char __cdecl sub_1000D280(__int16 a1);
void *sub_1000D450();
char *__cdecl sub_1000D490(unsigned __int8 a1);
char __cdecl sub_1000D4A0(unsigned __int8 a1, int a2);
char __cdecl sub_1000D510(char a1, __int16 a2);
int __cdecl sub_1000D770(unsigned __int8 a1);
// char __usercall sub_1000D880@<al>(void *a1@<edi>, unsigned __int8 a2);
int sub_1000D930();
BOOL sub_1000DA00();
BOOL __thiscall sub_1000DA30(void *this);
int sub_1000DA60(); // weak
// char __usercall sub_1000DAB0@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>);
signed int __cdecl sub_1000DBE0(int a1, int a2, void *a3, int a4);
// int __usercall sub_1000DCB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4);
bool __cdecl sub_1000DD00(unsigned __int8 a1);
char __fastcall sub_1000DE10(unsigned __int8 a1);
char __cdecl sub_1000DEE0(unsigned __int8 a1, __int16 a2, char a3);
char __cdecl sub_1000E190(int a1, char a2);
char __cdecl sub_1000E560(int a1);
// int __usercall sub_1000E7A0@<eax>(unsigned __int8 a1@<al>);
char sub_1000E7E0();
char __thiscall sub_1000E990(void *this);
void *sub_1000EC70();
char sub_1000EC80();
int sub_1000ED00();
BOOL sub_1000EDA0();
int (__cdecl *__cdecl sub_1000EDD0(int a1, char a2))(int, int);
signed int __cdecl sub_1000EEA0(int a1, int a2, int a3, unsigned int a4);
char sub_1000F0E0();
char __thiscall sub_1000F160(void *this);
int sub_1000F230();
// int __usercall sub_1000F2B0@<eax>(int a1@<eax>);
// int __usercall sub_1000F2C0@<eax>(int a1@<eax>);
int sub_1000F2D0();
char sub_1000F2F0();
char sub_1000F310();
char sub_1000F330();
char sub_1000F350();
char sub_1000F370();
char sub_1000F390();
int sub_1000F3B0();
char __cdecl sub_1000F3E0(int a1);
void *__cdecl sub_1000F760(char a1);
int sub_1000F7A0(); // weak
int sub_1000F7C0(); // weak
// int __usercall sub_1000F7F0@<eax>(unsigned int *a1@<ebx>, int a2, int a3, unsigned __int8 a4, int a5);
int sub_1000F920(); // weak
// char __usercall sub_1000F980@<al>(int a1@<edi>, unsigned int a2@<esi>, int a3);
int sub_1000FA50(); // weak
int sub_1000FAC0(); // weak
void __cdecl sub_1000FB50(char a1);
void __cdecl sub_1000FC60(int a1, float a2, float a3);
bool __cdecl sub_1000FF70(void *a1, int a2, int a3, int a4, int a5, int a6);
char __cdecl sub_100100F0(int a1, int a2, void *a3, size_t a4);
int __cdecl sub_10010210(char a1);
// size_t __usercall sub_10010230@<eax>(int a1@<eax>, _DWORD *a2@<edi>, int a3@<esi>, int a4, int a5);
void *__cdecl sub_10010270(char a1);
int __cdecl sub_100102C0(int a1);
char __thiscall sub_10010310(void *this);
int __cdecl sub_100103D0(char *a1, char a2);
int sub_10010470(); // weak
int __cdecl sub_10010570(int a1);
int __cdecl sub_10010730(int a1);
// int __usercall sub_10010920@<eax>(int a1@<eax>, int a2);
int __cdecl sub_10010BF0(int a1);
// int __usercall sub_10010DE0@<eax>(int a1@<eax>, int a2);
// int __usercall sub_10010FB0@<eax>(int a1@<eax>, int a2);
char sub_10011320();
int sub_10011570();
void __cdecl sub_100116D0(unsigned int a1, unsigned __int8 a2);
unsigned __int8 __fastcall sub_100118D0(void *a1);
// int __usercall sub_10011970@<eax>(int result@<eax>, int a2, int a3, size_t a4, char a5);
void __cdecl sub_10011D00(int a1, unsigned int a2);
void sub_10011F20();
char sub_100120D0();
char __cdecl sub_10012260(int a1);
char __cdecl sub_10012360(int a1);
char __cdecl sub_10012430(int a1);
// signed __int16 __usercall sub_10012500@<ax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_10012520@<eax>(int a1@<esi>, signed int a2);
// int __usercall sub_10012720@<eax>(int a1@<eax>, int a2@<esi>, int a3);
char __cdecl sub_10012840(int a1, int a2);
signed __int16 __cdecl sub_100128C0(int a1, int a2);
char __cdecl sub_100128D0(int a1, int a2, void *a3, unsigned __int16 a4);
int __cdecl sub_10012AC0(int a1, int a2);
char __cdecl sub_10012B10(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5);
int __cdecl sub_10012D20(int a1);
int __cdecl sub_10012DD0(int a1);
char __cdecl sub_10012E80(int a1);
int __cdecl sub_10013280(int a1);
char __cdecl sub_10013610(int a1, char a2, int a3, const void *a4, int a5);
char __cdecl sub_10013920(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6);
char __cdecl sub_10013C10(int a1, int a2, int a3);
char __cdecl sub_10013ED0(int a1, int a2, void *a3, char a4, int a5);
char __cdecl sub_10014160(int a1, unsigned __int16 a2, int a3, void *a4, char a5, int a6);
int __cdecl sub_100143F0(int a1);
char __cdecl sub_100144B0(int a1, int a2, void *a3);
char __cdecl sub_100144D0(int a1, int a2, void *a3, unsigned __int16 *a4);
int __cdecl sub_10014500(int a1);
char __cdecl sub_10014650(int a1, int a2);
char sub_100146D0();
int __cdecl sub_100146E0(int a1);
int __cdecl sub_100146F0(int a1, int a2, unsigned __int16 a3, char a4, char a5);
int __cdecl sub_100147A0(int a1);
char __cdecl sub_100147B0(int a1, int a2);
char sub_10014950();
signed int sub_10014AD0();
int sub_10014C30();
int sub_10014C60();
int __cdecl sub_10014DC0(char a1);
signed int sub_10014DE0();
// signed int __usercall sub_10014E30@<eax>(char a1@<al>, int a2@<ecx>);
// int __usercall sub_10014ED0@<eax>(char a1@<al>);
// int __usercall sub_10014EF0@<eax>(char a1@<al>);
// signed __int16 __usercall sub_10014F10@<ax>(char a1@<al>, unsigned __int16 a2@<si>);
char __cdecl sub_10015140(char a1, unsigned __int16 a2, _BYTE *a3);
char __cdecl sub_10015290(char a1, unsigned __int16 a2, void *a3);
char __cdecl sub_10015400(char a1, unsigned __int16 a2, int a3);
char __cdecl sub_10015560(int a1, int a2, void *a3, char a4, int a5, int a6);
char __cdecl sub_10015710(char a1, int a2, int a3);
char __cdecl sub_10015820(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6);
char __cdecl sub_10015A90(char a1, int a2, __int16 a3, __int16 a4, void *a5);
char __cdecl sub_10015AC0(char a1, int a2, void *a3);
char __cdecl sub_10015AF0(char a1, int a2, void *a3, int a4);
const char *__cdecl sub_10015B20(int a1, unsigned __int16 a2);
int __cdecl sub_10015B50(char a1, int a2);
char __cdecl sub_10015C70(int a1, int a2);
// int __usercall sub_10015E00@<eax>(char *a1@<edi>, size_t a2@<esi>, int a3);
int __cdecl sub_10015E70(char a1, int a2, int a3);
int __cdecl sub_10015EB0(char a1, int a2, int a3);
int __cdecl sub_10015EF0(char a1, int a2, int a3);
char __thiscall sub_10015F30(void *this);
char __cdecl sub_10015FE0(int a1, int a2);
char sub_100161D0();
char __cdecl sub_10016230(char a1);
char __cdecl sub_100162A0(unsigned __int8 a1);
char __cdecl sub_10016340(unsigned __int8 a1);
char __cdecl sub_100163D0(__int16 a1);
char __cdecl sub_10016420(int a1, int a2);
char __cdecl sub_100164F0(int a1, int a2);
char __cdecl sub_100165C0(int a1, int a2);
bool __thiscall sub_100165F0(void *this);
// bool __usercall sub_10016640@<al>(unsigned __int8 a1@<al>);
int __cdecl sub_10016800(char a1);
// int __usercall sub_10016820@<eax>(unsigned __int8 a1@<al>);
char __fastcall sub_100169B0(unsigned __int8 a1);
signed int sub_100169D0();
// int __usercall sub_10016A10@<eax>(int result@<eax>, char a2@<dl>);
void *sub_10016A30();
char __thiscall sub_10016A90(void *this);
char __cdecl sub_10016C30(int a1, int a2);
char sub_10016D00();
// char __usercall sub_10017350@<al>(int a1@<edx>, _DWORD *a2@<ecx>, int a3@<esi>);
// int __usercall sub_100173A0@<eax>(int result@<eax>, unsigned int a2@<edx>, __int16 a3@<si>);
char __fastcall sub_100173D0(int a1, int a2);
// char __usercall sub_10017400@<al>(int a1@<eax>, int a2@<edi>);
// char __usercall sub_10017600@<al>(int a1@<edx>, char *a2);
char __cdecl sub_100176E0(int a1, char a2, int a3, char a4);
int __thiscall sub_10017770(void *this);
char sub_10017840();
char sub_100178E0();
char sub_10017970();
char sub_10017C00();
signed int sub_10017D70();
char __cdecl sub_10017D90(__int16 a1);
char __cdecl sub_10017DC0(__int16 a1);
void *__fastcall sub_10017DD0(int a1, int a2);
// bool __usercall sub_10017E20@<al>(float a1@<ecx>, int *a2@<esi>);
void *__thiscall sub_10017ED0(void *this);
// char __usercall sub_10017F00@<al>(int a1@<edi>);
// const void *__usercall sub_100181B0@<eax>(const void *result@<eax>);
// char __usercall sub_100181D0@<al>(void *a1@<ecx>, char a2@<bl>);
int sub_10018280();
int __cdecl sub_100183B0(int a1);
void *sub_100183E0();
int sub_100183F0(void); // weak
// void *__usercall sub_10018400@<eax>(const void *a1@<esi>);
int sub_100184B0();
// signed int __usercall sub_100184F0@<eax>(void *a1@<ecx>, int a2@<esi>);
signed int __cdecl sub_10018580(int a1);
void sub_10018900();
signed int sub_10018A40();
char sub_10018B00();
char *__cdecl sub_10018B20(char a1);
char sub_10018B70();
char sub_10018BD0();
char *__cdecl sub_10018C40(unsigned __int16 a1);
char sub_10018C90();
// char *__usercall sub_10018E50@<eax>(char *result@<eax>, float *a2@<ecx>);
// _BYTE *__usercall sub_10018EA0@<eax>(_BYTE *result@<eax>);
// _BYTE *__usercall sub_10018EB0@<eax>(_BYTE *result@<eax>);
// char __usercall sub_10018EC0@<al>(int a1@<eax>);
// _DWORD *__usercall sub_10018EE0@<eax>(_DWORD *result@<eax>);
// int __usercall sub_10018EF0@<eax>(int result@<eax>);
// unsigned __int8 __usercall sub_10018F00@<al>(unsigned __int8 result@<al>);
// char *__usercall sub_10018F20@<eax>(char a1@<bl>);
char sub_10018F50();
signed int __thiscall sub_10018FA0(void *this);
char sub_10018FE0();
char sub_100190E0();
char sub_10019140();
// char __usercall sub_10019240@<al>(int a1@<eax>);
// char __usercall sub_10019510@<al>(int a1@<esi>);
char __cdecl sub_10019630(unsigned __int8 *a1, char a2);
// char *__usercall sub_10019660@<eax>(char *a1@<eax>);
int __cdecl sub_10019670(char *a1, int a2);
char sub_10019980();
char sub_10019990();
char __cdecl sub_100199A0(char a1);
int __cdecl sub_100199F0(unsigned __int8 a1);
char __thiscall sub_10019A30(void *this);
signed int sub_10019B30();
// _BYTE *__usercall sub_10019B40@<eax>(char a1@<bl>, int a2@<esi>);
// _DWORD *__usercall sub_10019BE0@<eax>(int a1@<ecx>, int a2@<esi>);
// signed int __usercall sub_10019C00@<eax>(int a1@<eax>, int a2@<edx>, void *a3@<ecx>);
signed int sub_10019C20();
// char __usercall sub_10019CA0@<al>(int a1@<esi>, char a2, int a3, char a4, int a5, int a6, int a7, int a8, __int16 a9, int a10);
// char __usercall sub_1001A0E0@<al>(const void *a1@<eax>, int a2@<ebx>, char a3, unsigned __int16 a4);
int sub_1001A170();
char __cdecl sub_1001A210(char a1, int a2, char a3, int a4, const char *a5, int a6, int a7, __int16 a8, int a9);
_BYTE *__cdecl sub_1001A280(char a1);
// _BYTE *__usercall sub_1001A340@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>);
// __int16 __usercall sub_1001A660@<ax>(unsigned __int64 a1@<edx:eax>);
char __thiscall sub_1001A870(void *this);
// _BYTE *__usercall sub_1001AB90@<eax>(int a1@<esi>);
char __thiscall sub_1001AE10(int this);
char __cdecl sub_1001AF80(int a1, int a2);
void __thiscall sub_1001B080(int *this);
char __cdecl sub_1001B110(void *a1, int a2);
int __cdecl sub_1001B140(int a1);
unsigned int __cdecl sub_1001B170(char *a1);
int __cdecl sub_1001B190(unsigned __int8 *a1);
int __cdecl sub_1001B1B0(_BYTE *a1);
int __cdecl sub_1001B1D0(unsigned __int8 *a1);
int __cdecl sub_1001B1F0(int a1);
unsigned int __cdecl sub_1001B220(int a1, int a2);
unsigned int __cdecl sub_1001B550(int a1, int a2);
_DWORD __cdecl sub_1001B990(_DWORD); // weak
int __cdecl sub_1001B9A0(int a1);
unsigned int __cdecl sub_1001B9D0(_BYTE *a1);
int __cdecl sub_1001B9F0(unsigned __int8 *a1);
int __cdecl sub_1001BA10(unsigned __int8 *a1);
int __cdecl sub_1001BA30(_BYTE *a1);
int __cdecl sub_1001BA50(int a1);
// void __cdecl __noreturn exit(int);
int __cdecl sub_1001BAA0(unsigned __int8 *a1);
int __cdecl sub_1001BAC0(int a1);
unsigned int __cdecl sub_1001BB50(int a1);
signed int __cdecl sub_1001BB70(int a1);
unsigned int __cdecl sub_1001BBC0(int a1);
int __cdecl sub_1001BC20(_BYTE *a1);
unsigned int __cdecl sub_1001BC40(_BYTE *a1);
int __cdecl sub_1001BC60(unsigned __int8 *a1);
int __cdecl sub_1001BC80(_BYTE *a1);
signed int __cdecl sub_1001BCA0(_BYTE *a1, int a2);
int __cdecl sub_1001BCD0(_BYTE *a1);
int __cdecl sub_1001BCF0(_BYTE *a1, int a2);
signed int __cdecl sub_1001BD30(_BYTE *a1, int a2);
int __cdecl sub_1001BD60(int a1, int a2);
int __cdecl sub_1001BDF0(int a1);
int __cdecl sub_1001BE20(unsigned __int8 *a1);
unsigned int __cdecl sub_1001BE40(int a1);
int __cdecl sub_1001BE70(int a1);
int __cdecl sub_1001BF60(int a1);
signed int __cdecl sub_1001C070(unsigned __int8 *a1, int a2);
int __cdecl sub_1001C0A0(int a1);
int __cdecl sub_1001C0D0(int a1);
int __cdecl sub_1001C100(int a1);
int __cdecl sub_1001C130(unsigned __int8 *a1);
int __cdecl sub_1001C150(int a1);
int __cdecl sub_1001C1C0(int a1);
int __cdecl sub_1001C1D0(int a1);
int __cdecl sub_1001C1F0(int a1);
int __cdecl sub_1001C210(int a1);
int __cdecl sub_1001C270(unsigned __int8 *a1, int a2);
int __cdecl sub_1001C2A0(unsigned __int8 *a1, int a2);
int __cdecl sub_1001C2D0(unsigned __int8 *a1, int a2);
signed int __cdecl sub_1001C300(_BYTE *a1, int a2);
int __cdecl sub_1001C330(int a1, int a2);
_DWORD __cdecl sub_1001C3D0(_DWORD); // weak
int __cdecl sub_1001C3E0(int a1);
unsigned int __cdecl sub_1001C460(int a1);
unsigned int __cdecl sub_1001C4A0(int a1);
int __cdecl sub_1001C4F0(int a1);
signed int __cdecl sub_1001C520(int a1);
int __cdecl sub_1001C8F0(int a1);
unsigned int __cdecl sub_1001C920(int a1);
unsigned int __cdecl sub_1001C950(int a1);
unsigned int __cdecl sub_1001C970(int a1);
void __cdecl __noreturn sub_1001C9B0(int a1);
signed int __cdecl sub_1001CB20(int a1, int a2);
int __cdecl sub_1001CB70(_BYTE *a1, int a2);
// time_t __cdecl static _mkgmtime(struct tm *Tm);
// signed int __usercall sub_1001CB90@<eax>(int a1@<eax>, int a2@<edi>);
// int __usercall sub_1001CC60@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>);
int __cdecl sub_1001CD50(unsigned __int8 *a1);
signed int __cdecl sub_1001CD60(int a1);
char __cdecl sub_1001CD70(unsigned __int8 a1);
int __thiscall sub_1001CDA0(void *this);
unsigned __int8 __cdecl sub_1001CE30(unsigned __int8 a1, char a2);
char __cdecl sub_1001CE50(int a1);
// char __usercall sub_1001CF90@<al>(unsigned __int8 a1@<al>);
char __cdecl sub_1001CFE0(int a1);
char sub_1001D140();
// char __usercall sub_1001D2B0@<al>(unsigned __int8 a1@<al>, char a2@<cl>);
unsigned __int8 __cdecl sub_1001D2E0(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_1001D390(int a1, int a2);
char __thiscall sub_1001D5E0(void *this);
char __cdecl sub_1001D740(char a1, unsigned int a2, int a3);
bool __cdecl sub_1001D8B0(int a1, int a2, int a3);
char __cdecl sub_1001D8D0(int a1, int a2, int a3);
char __cdecl sub_1001D930(int a1, int a2, int a3);
char __cdecl sub_1001D990(int a1, int a2, int a3);
char __cdecl sub_1001DA10(int a1, int a2, int a3);
bool __cdecl sub_1001DAA0(int a1, int a2, int a3);
bool __cdecl sub_1001DAC0(int a1, int a2, int a3);
char __cdecl sub_1001DAE0(char a1, int a2, int a3);
char __cdecl sub_1001DBB0(int a1, int a2, int a3);
bool __cdecl sub_1001DC10(int a1, int a2, int a3);
char __cdecl sub_1001DC30(int a1, int a2, int a3);
char __cdecl sub_1001DC60(char a1, int a2, int a3);
bool __cdecl sub_1001DE20(int a1, int a2, int a3);
char __cdecl sub_1001DE40(int a1, int a2, int a3);
char __cdecl sub_1001DEE0(int a1, int a2, int a3);
char __cdecl sub_1001DF40(int a1, int a2, int a3);
char __cdecl sub_1001E000(char a1, int a2, int a3);
char __cdecl sub_1001E0E0(int a1, int a2, int a3);
char __cdecl sub_1001E190(int a1, int a2, int a3);
char __cdecl sub_1001E200(int a1, int a2, int a3);
char __cdecl sub_1001E270(int a1, int a2, int a3);
char __cdecl sub_1001E320(int a1, int a2, int a3);
char __cdecl sub_1001E400(int a1, unsigned int a2, int a3);
char *__cdecl sub_1001E4E0(unsigned __int8 a1);
char __cdecl sub_1001E500(char a1, char a2, unsigned int a3, int a4);
char __cdecl sub_1001E550(char a1, unsigned __int8 a2);
char __cdecl sub_1001E5D0(unsigned __int8 a1);
char *__cdecl sub_1001E5F0(unsigned __int8 a1);
unsigned __int8 __cdecl sub_1001E610(unsigned __int8 a1);
char __cdecl sub_1001E640(char a1, unsigned __int8 a2);
char __cdecl sub_1001E6F0(unsigned __int8 a1, int a2, unsigned int *a3);
char __cdecl sub_1001E8E0(char a1);
char __thiscall sub_1001E900(void *this);
signed int sub_1001E970();
int sub_1001E9D0();
// char __usercall sub_1001EA70@<al>(void *a1@<edi>, int a2@<esi>, char a3, int a4, int a5);
_BYTE *__cdecl sub_1001EAF0(int a1, unsigned __int8 a2);
char __cdecl sub_1001EB50(unsigned __int8 a1, char a2, int a3);
HANDLE __cdecl sub_1001EC00(_BYTE *a1, DWORD a2);
// int __usercall sub_1001F2A0@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6);
bool __cdecl sub_1001F800(int a1, int a2, int a3, size_t Count, int a5, int a6, int a7, int a8);
char __cdecl sub_1001FAA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
HANDLE __cdecl sub_1001FBF0(int a1, unsigned __int8 a2);
char __cdecl sub_1001FC60(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_1001FDD0(unsigned int a1, char a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, _DWORD *a6);
int __cdecl sub_1001FF20(unsigned __int8 a1);
char __cdecl sub_1001FF50(unsigned __int8 a1, _BYTE *a2, _BYTE *a3, _BYTE *a4);
char __fastcall sub_1001FFA0(unsigned __int8 a1);
char __cdecl sub_100201C0(unsigned __int8 a1);
char sub_100202C0();
char __cdecl sub_10020350(int a1, int a2);
char __cdecl sub_100203B0(int a1, int a2, __int16 a3);
int __cdecl sub_10020400(int a1, int a2);
char __cdecl sub_10020450(int a1);
__int16 __thiscall sub_10020500(void *this);
char __cdecl sub_10020530(int a1, int a2, unsigned __int16 a3);
char __cdecl sub_10020690(const void *a1, unsigned __int16 a2, int a3);
char __cdecl sub_100206D0(int a1, int a2);
int __cdecl sub_10020760(int a1, __int16 a2, int a3);
char __cdecl sub_10020810(int a1, int a2);
int sub_10020860();
int __cdecl sub_100208B0(char a1);
int __cdecl sub_100208E0(int a1, int a2);
char **sub_10020980();
void *sub_10020990();
int __cdecl sub_100209D0(int, float, float); // idb
char *__cdecl sub_10020A60(char *a1, char *a2, size_t a3);
int (**sub_10020AA0())();
__int32 __cdecl j_j__atol(const char *);
// int __usercall sub_10020AC0@<eax>(int a1@<edi>, int a2@<esi>);
int __cdecl sub_10020B70(int a1, int a2);
char **sub_10020BD0();
int __cdecl sub_10020BE0(int a1);
int __cdecl sub_10020C00(int *a1, char a2);
int __cdecl sub_10020C20(int a1);
int __cdecl sub_10020C40(int a1, int a2, int a3);
int __cdecl sub_10020C60(int a1, int a2);
unsigned int __cdecl sub_10020C80(int a1, char a2, char a3);
void sub_10020D80();
void sub_10020D90();
char __thiscall sub_10020DA0(void *this);
char __cdecl sub_10020DC0(void *a1, char *a2);
char sub_10020E40();
char sub_10020E80();
char sub_10020EC0();
char sub_10020F00();
char sub_10020F40();
char sub_10020F80();
char sub_10020FC0();
char sub_10021000();
signed int sub_10021040();
BOOL __cdecl sub_10021070(int a1);
BOOL sub_10021090();
char __cdecl sub_100210F0(int a1);
bool __cdecl sub_10021180(void *a1);
bool sub_100211E0();
// _BYTE *__usercall sub_10021240@<eax>(_BYTE *result@<eax>);
// char *__usercall sub_10021250@<eax>(const char *a1@<eax>);
// char *__usercall sub_10021260@<eax>(const char *a1@<esi>);
// char __usercall sub_100212B0@<al>(int a1@<esi>, unsigned __int8 a2);
// char __usercall sub_100212F0@<al>(int a1@<esi>, unsigned __int8 a2);
// signed int __usercall sub_10021330@<eax>(int a1@<esi>);
// char __usercall sub_10021370@<al>(const char *a1@<eax>, int a2@<edi>);
// char __usercall sub_100213C0@<al>(const char *a1@<eax>, int a2);
// char __usercall sub_10021950@<al>(_BYTE *a1@<eax>);
// char *__usercall sub_10021990@<eax>(char *result@<eax>);
char __cdecl sub_100219C0(int a1, char a2);
// char __usercall sub_10021CD0@<al>(char *a1@<ecx>, int a2@<ebx>);
// char __usercall sub_10021DE0@<al>(char *a1@<eax>, int a2);
// char __usercall sub_10021F70@<al>(int a1@<ebx>, char *a2, int a3);
char __cdecl sub_10022190(int a1, char *a2, int a3);
// char __usercall sub_10022490@<al>(char *a1@<eax>, int a2@<edi>, unsigned __int8 a3);
char __cdecl sub_100225E0(int a1, char *a2);
char __cdecl sub_10022810(char a1, char *a2, int *a3, char *a4);
char __cdecl sub_10022930(char a1, char a2);
char __cdecl sub_10022A10(void *a1, char a2, int a3, int a4);
char sub_10022B00();
int __cdecl sub_10022BC0(int *a1, unsigned int a2, int a3);
void sub_10022C40();
signed int sub_10022C50();
char __cdecl sub_10022C60(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4);
// char __usercall sub_10022C90@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6);
// char __usercall sub_10022D30@<al>(int a1@<ebx>, _BYTE *a2, int *a3);
int __cdecl sub_10022F80(int, int, int, void *, int); // idb
char __cdecl sub_10023010(__int64 a1);
double __cdecl sub_10023040(float a1);
// int __usercall sub_10023100@<eax>(int a1@<edi>, int a2, int a3, char a4);
int __cdecl sub_100231E0(int a1);
char __cdecl sub_10023220(unsigned int a1, unsigned int *a2, _BYTE *a3, _BYTE *a4);
int __cdecl sub_10023250(int a1);
// signed int __usercall sub_10023290@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
signed int __thiscall sub_100232D0(int this);
// signed int __usercall sub_10023380@<eax>(int a1@<edi>);
signed int __thiscall sub_10023410(int this);
// char __usercall sub_100234B0@<al>(int a1@<eax>, char a2);
// int __usercall sub_10023500@<eax>(int a1@<esi>);
// char __usercall sub_10023520@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6);
// void *__usercall sub_100235E0@<eax>(int a1@<eax>, char *a2@<esi>);
// __int16 __usercall sub_10023640@<ax>(int a1@<eax>, int a2@<esi>, int a3);
char __cdecl sub_100237B0(unsigned int a1, int a2);
void *__cdecl sub_10023A30(unsigned int a1, char *a2);
signed int __cdecl sub_10023A80(unsigned __int8 a1);
// signed int __usercall sub_10023B00@<eax>(int a1@<edi>, unsigned __int8 a2);
signed int __cdecl sub_10023B70(unsigned __int8 a1);
// int __usercall sub_10023BE0@<eax>(int a1@<eax>, char a2);
// void __usercall sub_10023C70(int a1@<edi>, int a2, int a3);
__int16 __cdecl sub_10023CB0(unsigned int a1, char a2, int a3);
int __cdecl sub_10024190(__int64 a1);
double __cdecl sub_10024240(unsigned int a1);
double __cdecl sub_100242C0(int a1);
int __cdecl sub_10024330(int a1, int a2);
char __cdecl sub_100244C0(int a1, int a2);
__int16 __cdecl sub_10024530(int a1, int a2);
signed int __cdecl sub_10024570(unsigned __int8 a1);
int __cdecl sub_100245D0(int a1, int a2);
char __cdecl sub_10024640(unsigned __int8 a1, char *a2);
signed int __cdecl sub_100246D0(unsigned __int8 a1);
int __cdecl sub_10024750(int, char, void *); // idb
signed int __cdecl sub_100247D0(unsigned __int8 a1);
char __cdecl sub_10024830(unsigned __int8 a1, unsigned __int8 a2);
char __cdecl sub_100248D0(int a1);
int __cdecl sub_10024900(int a1, int a2, _BYTE *a3, _BYTE *a4, int a5, int a6, float *a7);
// int __usercall sub_10024A00@<eax>(float *a1@<esi>, float a2, float a3, float a4, float a5, int a6);
// double __usercall sub_10024AA0@<st0>(int a1@<eax>, int a2@<ecx>, int a3@<esi>, unsigned int a4);
char __cdecl sub_10024BA0(unsigned __int8 a1);
int __cdecl sub_10024BE0(unsigned __int8 a1, int a2, _BYTE *a3, _BYTE *a4, int a5, int a6, float *a7);
void __cdecl sub_10024C30(int a1, unsigned __int8 a2, float *a3, float *a4);
char __cdecl sub_10025030(float *a1);
void __cdecl sub_10025090(unsigned __int8 a1, int *a2, float *a3, float *a4);
char __cdecl sub_100252B0(char a1, char *a2);
void __cdecl sub_10025380(int a1);
int __cdecl sub_10025610(int, void *, void *); // idb
int __cdecl sub_100257C0(unsigned __int8 a1);
char __cdecl sub_100257F0(unsigned __int8 a1, int a2, char a3, int a4);
// signed int __usercall sub_10025870@<eax>(signed int result@<eax>, int a2@<ecx>);
// char __usercall sub_10025890@<al>(int a1@<eax>, unsigned __int8 a2);
int __cdecl sub_10025930(int a1);
// signed int __usercall sub_10025970@<eax>(unsigned __int8 a1@<bl>, int a2);
int __fastcall sub_10025AE0(int a1, int a2);
void __cdecl sub_10025B10(unsigned int a1, int a2);
char __cdecl sub_10025C50(unsigned int a1, int a2);
signed int __cdecl sub_10025D00(unsigned __int8 a1);
// signed int __usercall sub_10025E20@<eax>(unsigned __int8 a1@<dl>, int a2@<ecx>, _DWORD *a3);
// void __usercall sub_10025F30(int a1@<ecx>, int a2@<esi>);
signed int __cdecl sub_10025F60(const char *a1, int a2, signed int *a3);
char __cdecl sub_10026050(unsigned int a1, int a2);
double *__cdecl sub_10026170(char a1, char a2, double *a3);
int __cdecl sub_100262A0(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_100262D0(int a1, int a2);
int __cdecl sub_10026430(int a1, int a2, int a3, _BYTE *a4);
unsigned int __cdecl sub_100264B0(unsigned int a1, _BYTE *a2, _BYTE *a3);
// int __usercall sub_100264D0@<eax>(int a1@<edi>, int a2, int *a3);
char __cdecl sub_10026530(int a1, int a2);
char __cdecl sub_100266B0(char a1, char a2, int a3);
char __cdecl sub_10026830(char a1, int a2, int a3);
char __cdecl sub_100269B0(char *a1, char a2, int a3);
char sub_10026B50();
char __cdecl sub_10026C30(char a1);
int __cdecl sub_10026C80(unsigned __int8 a1);
unsigned __int8 __cdecl sub_10026CC0(unsigned int a1);
int __cdecl sub_10026CF0(unsigned int a1, unsigned __int8 a2, char a3);
int __cdecl sub_10026D70(unsigned int a1);
char __cdecl sub_10026DA0(__int64 a1);
double __cdecl sub_10026E40(unsigned int a1);
signed int __cdecl sub_10026EB0(unsigned __int8 a1);
char __cdecl sub_10026EF0(unsigned __int8 a1);
signed int __cdecl sub_10026F30(unsigned __int8 a1, unsigned __int8 a2);
signed int __cdecl sub_10026F90(unsigned __int8 a1);
char __cdecl sub_10026FD0(int a1);
char __cdecl sub_10027010(int a1);
char __cdecl sub_10027050(int a1);
char __cdecl sub_10027090(int a1);
char __cdecl sub_100270D0(int a1);
char __cdecl sub_10027110(unsigned __int8 a1);
char __cdecl sub_10027150(unsigned __int8 a1);
char __cdecl sub_10027190(unsigned __int8 a1);
char __cdecl sub_100271D0(unsigned __int8 a1);
char __cdecl sub_10027210(unsigned __int8 a1);
signed int __cdecl sub_10027250(int a1, _WORD *a2, _BYTE *a3);
// char __usercall sub_10027350@<al>(unsigned __int16 a1@<ax>, void *a2);
// int __usercall sub_100273B0@<eax>(int result@<eax>, int a2@<ecx>);
int __cdecl sub_100273D0(unsigned __int16 a1, int a2);
signed int __cdecl sub_10027440(int a1, _WORD *a2, _BYTE *a3);
signed int __cdecl sub_10027490(int a1);
int sub_100274F0();
char __cdecl sub_10027590(float *a1);
char __cdecl sub_10027850(int a1, float *a2);
double __cdecl sub_10027870(unsigned int a1);
char *__cdecl sub_10027920(unsigned __int8 a1);
signed int sub_100279E0();
int sub_10027A00();
int sub_10027A60();
char *sub_10027AD0();
int __cdecl sub_10027BA0(const void *a1);
signed int __cdecl sub_10027C50(int a1);
float sub_10027CA0();
void __cdecl sub_10027D00(unsigned int a1, char *a2, float *a3, int a4, char a5);
void __cdecl sub_10028040(signed int a1, char *a2);
_DWORD __cdecl sub_10028080(_DWORD, _DWORD); // weak
int __cdecl sub_10028090(int a1);
void __cdecl sub_100282C0(unsigned int a1, int a2);
char __cdecl sub_100284A0(unsigned int a1, int a2);
int __cdecl sub_10028510(_BYTE *a1, _BYTE *a2);
int sub_10028540();
int __fastcall sub_10028550(unsigned __int8 a1);
int __fastcall sub_10028570(unsigned __int8 a1);
void *__cdecl sub_10028590(char a1, void *a2);
int __cdecl sub_10028660(int a1);
char sub_10028820();
char *__cdecl sub_10028980(int a1, char *a2, int a3, char *a4, int a5);
char sub_10028AB0();
char __cdecl sub_10028AC0(char *a1, int a2, char a3, char *a4, int a5);
char __cdecl sub_10028BC0(char *a1, int a2, char a3, char *a4);
int sub_10028C30();
int __cdecl sub_10028C70(__int16 a1);
int __cdecl sub_10028CC0(char, __int16, char *); // idb
int __cdecl sub_10028D30(char a1, __int16 a2, char a3);
int __cdecl sub_10028D90(char a1, __int16 a2, char a3);
// int __usercall sub_10028DF0@<eax>(int a1@<edx>, int a2@<ecx>, int a3);
int __cdecl sub_10028EA0(unsigned __int8 a1);
int __cdecl sub_10028EE0(char a1, __int16 a2, _BYTE *a3, char a4);
void sub_10028F40();
signed int sub_10028F50();
signed int sub_10028F60();
signed int sub_10028F70();
char __cdecl sub_10028F80(char a1, int a2, void *a3);
BOOL __cdecl sub_10029030(unsigned int a1);
char __thiscall sub_100290A0(void *this);
void __cdecl sub_100290C0(_BYTE *a1, _BYTE *a2, _BYTE *a3);
int __cdecl sub_100290F0(int a1);
signed int sub_10029110();
void __cdecl sub_10029140(_BYTE *a1);
char __cdecl sub_10029160(int a1, size_t a2, void *a3);
int __cdecl sub_100291A0(int a1);
char __fastcall sub_100291C0(int *a1);
char sub_100293E0();
void sub_10029400();
signed int sub_10029410();
char __cdecl sub_10029420(void *a1);
bool sub_10029470();
void sub_100294B0();
char __cdecl sub_100294C0(unsigned __int8 a1);
signed int sub_10029520();
// char __usercall sub_10029530@<al>(unsigned __int8 a1@<al>, char a2, void *a3);
char __cdecl sub_10029610(int a1, char a2, void *a3);
char __cdecl sub_10029690(int a1, void *a2);
int __cdecl sub_100296B0(char a1);
char __cdecl sub_10029700(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10029770(char a1, _WORD *a2);
char __cdecl sub_100297B0(unsigned int a1);
signed int sub_10029810();
signed int sub_10029820();
signed int sub_10029830();
// char __usercall sub_10029840@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7);
char __cdecl sub_100299A0(_BYTE *a1);
char __cdecl sub_100299D0(unsigned __int8 a1, _BYTE *a2);
char __cdecl sub_10029A00(char a1, char a2, int a3);
char __cdecl sub_10029A30(unsigned __int8 a1, char a2);
char __cdecl sub_10029AB0(unsigned __int8 a1, int a2);
char __cdecl sub_10029AF0(int a1, void *a2);
bool __cdecl sub_10029B80(unsigned __int8 a1, _BYTE *a2, int a3);
// void *__usercall sub_10029BE0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>);
signed int sub_10029C30();
int __fastcall sub_1002BA30(int a1, int a2);
int sub_1002BA40();
char sub_1002BA70();
void *sub_1002BB10();
signed int sub_1002BB20();
int __cdecl sub_1002BB30(double, double); // idb
void sub_1002BB80();
signed int sub_1002BB90();
// char __usercall sub_1002BBA0@<al>(float *a1@<esi>);
signed int sub_1002BC10();
bool __cdecl sub_1002BC40(char a1, int a2);
char __cdecl sub_1002BE60(float *a1);
char sub_1002BEA0();
bool __cdecl sub_1002BF10(float *a1);
bool __cdecl sub_1002BFC0(float *a1);
signed int sub_1002C020();
int sub_1002C050();
bool __cdecl sub_1002C060(signed int a1, signed int a2, _BYTE *a3);
void __cdecl sub_1002C0D0(const char *a1, unsigned int a2, int a3);
int __cdecl sub_1002C120(int a1, _BYTE *a2, int a3);
signed int __cdecl sub_1002C170(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_1002C1E0(void *, size_t); // idb
int __cdecl sub_1002C210(int, char *, int); // idb
int __cdecl sub_1002C270(char *, size_t, char *, va_list); // idb
int sub_1002C2B0(char *arg0, size_t arg4, char *arg8, ...);
int __cdecl sub_1002C2E0(const char *a1, _BYTE *a2, int a3);
int __cdecl sub_1002C320(int a1, int a2);
double sub_1002C340(void); // weak
char __thiscall sub_1002C360(void *this);
char __thiscall sub_1002C3A0(void *this);
char __fastcall sub_1002C3D0(int a1);
char __thiscall sub_1002C420(void *this);
int sub_1002C450();
char __fastcall sub_1002C480(int a1);
char __cdecl sub_1002C4D0(int a1);
bool __thiscall sub_1002C4F0(void *this);
int __cdecl sub_1002C500(int, char *); // idb
char __thiscall sub_1002C560(void *this);
char __thiscall sub_1002C580(void *this);
char __thiscall sub_1002C5A0(void *this);
int __thiscall sub_1002C5C0(void *this);
char __thiscall sub_1002C5E0(void *this);
char __thiscall sub_1002C600(void *this);
int __cdecl sub_1002C620(char a1);
char __thiscall sub_1002C630(void *this);
int __thiscall sub_1002C660(void *this);
bool __cdecl sub_1002C680(char a1);
int __cdecl sub_1002C6F0(int a1, unsigned int a2);
int __cdecl sub_1002C7E0(int a1, int a2, int a3);
int __cdecl sub_1002C820(int *a1, unsigned int a2);
__int16 __cdecl sub_1002C910(int a1, unsigned int a2);
int __cdecl sub_1002C960(int *a1, unsigned int a2);
int __cdecl sub_1002C990(signed __int64 a1);
__int16 __cdecl sub_1002C9E0(unsigned int *a1, _WORD *a2, _WORD *a3);
_DWORD *__cdecl sub_1002CA60(unsigned int a1, unsigned int a2, _DWORD *a3);
char __cdecl sub_1002CB10(int a1, int a2);
char __cdecl sub_1002CC30(int a1);
char __cdecl sub_1002CC40(int a1);
char __cdecl sub_1002CC50(int a1);
char __cdecl sub_1002CC60(int a1);
char __cdecl sub_1002CC70(int a1);
char __cdecl sub_1002CC80(int a1);
int __cdecl sub_1002CC90(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_1002CE20(_DWORD *a1, unsigned int a2, int a3, int a4, int a5);
char sub_1002CF40();
char __cdecl sub_1002CF60(char a1, _DWORD *a2);
// __int16 __usercall sub_1002CFA0@<ax>(int a1@<edi>, char a2);
// signed __int16 __usercall sub_1002D140@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>);
char __cdecl sub_1002D390(signed __int16 a1);
char __cdecl sub_1002D420(char a1, int a2);
int __cdecl sub_1002D440(signed __int16 a1);
char __cdecl sub_1002D550(unsigned __int16 a1);
char __cdecl sub_1002D5F0(char a1);
char __cdecl sub_1002D630(char a1);
char __cdecl sub_1002D6A0(char a1);
signed int __cdecl sub_1002D710(char a1);
char __cdecl sub_1002D790(char a1);
char __cdecl sub_1002D800(char a1);
char __cdecl sub_1002D8B0(int a1);
char __cdecl sub_1002D9C0(int a1);
char __cdecl sub_1002DAC0(char a1);
char __cdecl sub_1002DAE0(char a1);
char __thiscall sub_1002DB00(void *this);
char __cdecl sub_1002DB10(char a1);
int __cdecl sub_1002DB40(char a1);
signed int __fastcall sub_1002DB70(unsigned __int8 a1);
char __cdecl sub_1002DB80(unsigned __int8 a1);
__int16 __cdecl sub_1002DBA0(unsigned __int8 a1);
__int16 __cdecl sub_1002DBC0(unsigned __int8 a1);
char __cdecl sub_1002DBE0(int a1, int a2);
char __cdecl sub_1002DC10(int a1);
unsigned __int8 __cdecl sub_1002DC80(unsigned __int8 a1);
int __cdecl sub_1002DCB0(char, float, int, int, int); // idb
double sub_1002E300();
char __cdecl sub_1002E330(float a1);
unsigned __int8 __cdecl sub_1002E3E0(unsigned __int8 a1);
double __cdecl sub_1002E410(int a1, float a2, float a3);
char sub_1002E450();
char __cdecl sub_1002E4C0(unsigned __int8 a1, char a2);
double __cdecl sub_1002E500(_DWORD); // weak
char __cdecl sub_1002E600(float *a1, float *a2, float *a3, char a4);
double sub_1002EB90();
double sub_1002ECD0();
__int16 __cdecl sub_1002ED10(unsigned __int16 a1);
char __cdecl sub_1002ED20(bool *a1);
bool __thiscall sub_1002EE60(void *this);
int __cdecl sub_1002EE90(int a1, signed int a2, signed int a3);
int __cdecl sub_1002EEB0(int, double, double); // idb
int __cdecl sub_1002EF90(int, float, float); // idb
char __cdecl sub_1002F080(float *a1);
char __cdecl sub_1002F3A0(bool *a1, unsigned int a2);
void sub_1002F4A0();
char __cdecl sub_1002F4C0(float a1, float a2, int a3);
// char __usercall sub_1002F520@<al>(float *a1@<esi>);
char __thiscall sub_1002F5C0(void *this);
char __cdecl sub_1002F620(float *a1);
char __cdecl sub_1002F660(float *a1);
char __cdecl sub_1002F770(float *a1);
// char __usercall sub_1002F7B0@<al>(void *a1@<ecx>, float *a2@<esi>, char a3);
// char __usercall sub_1002F840@<al>(void *a1@<ecx>, float *a2@<esi>, char a3);
// char __usercall sub_1002F8D0@<al>(void *a1@<ecx>, float *a2@<esi>, char a3);
// char __usercall sub_1002F960@<al>(void *a1@<ecx>, float *a2@<esi>, char a3);
// char __usercall sub_1002F9F0@<al>(float *a1@<eax>, void *a2@<ecx>);
// char __usercall sub_1002FA20@<al>(void *a1@<ecx>, float *a2@<esi>, char a3);
char __cdecl sub_1002FAC0(float *a1);
char __cdecl sub_1002FBB0(float *a1);
char __cdecl sub_1002FC10(float *a1);
char __cdecl sub_1002FD90(float *a1);
char __cdecl sub_1002FDF0(float *a1);
char __cdecl sub_1002FE50(int a1, float a2);
char __cdecl sub_1002FFA0(void *a1);
bool __cdecl sub_10030050(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_100300C0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10030120(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10030190(char a1, _BYTE *a2);
char __thiscall sub_100301D0(void *this);
char __cdecl sub_10030240(char a1, int a2);
char __cdecl sub_10030270(char a1, int a2);
char __cdecl sub_100302A0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6);
char __cdecl sub_10030470(char a1, void *a2, void *a3, __int16 a4);
void *sub_100304B0();
__int16 sub_10030550();
char sub_100305A0();
__int16 sub_100305F0();
int __thiscall sub_10030640(void *this);
char __thiscall sub_10030660(void *this);
char __cdecl sub_100306F0(char a1);
char __cdecl sub_10030760(int a1, char a2);
char __cdecl sub_10030820(int a1, char a2);
char __cdecl sub_100308E0(int a1, char a2);
char sub_100309A0();
char __cdecl sub_100309D0(unsigned __int8 a1, char *a2, unsigned __int8 *a3);
char __cdecl sub_10030A60(unsigned __int8 a1, char *a2, unsigned __int8 *a3);
char __cdecl sub_10030B10(char a1);
char __cdecl sub_10030B40(char a1);
char __cdecl sub_10030B70(char a1);
bool sub_10030BA0();
bool sub_10030BE0();
BOOL sub_10030C20();
void sub_10030C40();
signed int sub_10030C50();
void sub_10030C60();
char __cdecl sub_10030C70(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4);
int __cdecl sub_10030D40(char a1, __int16 a2, int a3);
signed int sub_10030DB0();
unsigned __int8 __cdecl sub_10030DC0(unsigned __int8 a1, int a2, unsigned __int8 a3);
char __cdecl sub_10030E90(unsigned __int8 a1, __int16 a2, char *a3);
void sub_10030F50();
int __cdecl sub_10030F60(char, int, __int16, __int16, void *); // idb
signed int sub_10030F70();
int sub_10030F80();
int sub_10030F90();
int __cdecl sub_10030FB0(unsigned __int8 *a1);
unsigned int __cdecl sub_10030FD0(void *a1);
unsigned int __cdecl sub_10030FF0(void *a1);
unsigned int __cdecl sub_10031010(void *a1);
unsigned int __cdecl sub_10031030(void *a1);
unsigned int __cdecl sub_10031050(void *a1);
int __cdecl sub_10031070(int a1);
int __cdecl sub_100310C0(int a1);
int __cdecl sub_10031120(int a1);
int __cdecl sub_10031170(void *); // idb
unsigned int __cdecl sub_10031240(void *a1);
int __cdecl sub_100312A0(char *a1, char a2);
bool __cdecl sub_10031310(int a1, void *a2);
char __cdecl sub_100313D0(int a1, bool *a2);
int __cdecl sub_10031490(int *a1);
// char __usercall sub_100314C0@<al>(int a1@<eax>, int a2@<ecx>);
int __cdecl sub_10031560(const char *a1);
char __cdecl sub_100315A0(void *a1);
signed int __cdecl sub_100315F0(unsigned int a1, int a2);
char **sub_10031990();
char sub_100319A0();
char __cdecl sub_100319D0(char a1);
char __cdecl sub_10031A10(char a1);
signed int __cdecl sub_10031A50(char a1);
char __cdecl sub_10031AA0(char a1);
char __cdecl sub_10031AC0(char a1);
char __cdecl sub_10031B00(char a1);
char __cdecl sub_10031B40(char a1);
signed int __cdecl sub_10031B80(char a1);
char __cdecl sub_10031BC0(char a1);
char __cdecl sub_10031C00(int a1);
// char __usercall sub_10031C40@<al>(int a1@<edi>, char a2, unsigned __int8 a3);
char __cdecl sub_10031C70(char a1);
char __cdecl sub_10031C90(char a1);
char __cdecl sub_10031CB0(char a1);
char __cdecl sub_10031CD0(char a1);
char __cdecl sub_10031D00(char a1);
char __cdecl sub_10031D30(char a1);
char __cdecl sub_10031D70(char a1, char a2, char *a3, char *a4);
// char __usercall sub_10031F80@<al>(char a1@<bl>, char *a2@<edi>, char a3, char a4, char *a5);
char __cdecl sub_100321C0(char a1, char a2, char *a3, char *a4);
signed int __cdecl sub_100321F0(unsigned __int8 a1);
bool __cdecl sub_10032320(int a1);
char __cdecl sub_10032340(unsigned __int8 a1, unsigned __int8 a2);
char __thiscall sub_10032470(void *this);
char __cdecl sub_100324A0(char a1);
BOOL sub_10032520();
char __cdecl sub_10032560(unsigned __int8 a1);
char __cdecl sub_10032600(char *a1);
char __cdecl sub_10032630(int a1);
int __cdecl sub_10032680(unsigned __int8 a1);
char __cdecl sub_100326C0(void *a1);
char __cdecl sub_100326E0(void *a1);
bool __thiscall sub_10032830(void *this);
char __cdecl sub_10032850(unsigned __int8 a1);
char __cdecl sub_100328C0(int a1, char a2, char a3, int a4, void *a5, size_t a6);
// void __usercall sub_10032A60(void *a1@<ecx>, bool *a2@<esi>);
// void __usercall sub_10032A90(_BYTE *a1@<esi>, unsigned __int16 a2);
signed int sub_10032AE0();
int sub_10032AF0();
char sub_10032B20();
char __cdecl sub_10032B60(char a1);
// char __usercall sub_10032C60@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5);
char __cdecl sub_10032CF0(int a1, unsigned __int16 a2);
char __cdecl sub_10032DD0(const void *a1);
int __cdecl sub_10032E40(unsigned __int8 a1);
int __cdecl sub_10032EB0(unsigned __int8 a1);
bool __cdecl sub_10032F40(int a1, void *a2, int a3);
bool __cdecl sub_10032FC0(int a1, void *a2, int a3);
char __cdecl sub_10033040(unsigned __int16 a1);
char __cdecl sub_100330B0(unsigned __int16 a1, char a2);
char __cdecl sub_10033120(int a1, int a2);
bool __cdecl sub_10033230(int a1, void *a2);
bool __cdecl sub_10033260(int a1, void *a2);
char __cdecl sub_10033290(int a1, int a2);
char __cdecl sub_10033300(int a1, int a2);
char __cdecl sub_10033370(_BYTE *a1);
unsigned int __cdecl sub_100333C0(int a1, int a2, size_t a3, int a4, int a5);
int sub_10033520(); // weak
unsigned int __cdecl sub_10033540(int a1, int a2, size_t a3, int a4);
char sub_10033570();
char sub_10033580();
char __cdecl sub_10033590(int a1, int a2);
BOOL __cdecl sub_10033640(int a1, int a2);
char __cdecl sub_10033660(int a1, char a2, int a3, int a4, int a5);
bool __thiscall sub_100336A0(void *this);
char __cdecl sub_100336C0(char a1);
signed int __cdecl sub_10033700(_BYTE *a1, char a2, int a3);
int __cdecl sub_10033750(int, double, double, int, int, int); // idb
int __cdecl sub_100338A0(int, float, float, int, int); // idb
unsigned int __cdecl sub_10033990(char *a1, char a2, char a3, char a4, int a5);
unsigned int __cdecl sub_100339E0(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5);
unsigned int __cdecl sub_10033AA0(void *a1, size_t a2, int a3);
int __cdecl sub_10033B00(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5);
int __cdecl sub_10033B50(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5);
int __cdecl sub_10033BF0(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5);
int __cdecl sub_10033CA0(float, float); // idb
bool __cdecl sub_10033CF0(float *a1);
int sub_10033D90();
char __cdecl sub_10033DC0(void *a1);
char __cdecl sub_10033E20(float *a1);
char __cdecl sub_10033F20(void *a1);
char __cdecl sub_10033F80(void *a1);
char __cdecl sub_10033FE0(float *a1);
char __cdecl sub_10034010(float *a1);
char __cdecl sub_100340B0(int a1);
// void *__usercall sub_100340F0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4);
void *__cdecl sub_10034120(void *a1);
char sub_10034150();
int __cdecl sub_10034180(int a1);
int __cdecl sub_100341A0(int a1);
char __cdecl sub_100341C0(char a1);
char __cdecl sub_10034240(unsigned __int16 a1, _WORD *a2);
char __fastcall sub_100342A0(int a1);
char __cdecl sub_100342F0(unsigned int a1);
char __cdecl sub_10034360(char a1);
char __cdecl sub_100343B0(char a1);
char __cdecl sub_100343E0(char a1);
char __cdecl sub_10034410(char a1);
// char __usercall sub_10034460@<al>(unsigned __int8 a1@<al>, _BYTE *a2);
char __cdecl sub_10034490(void *a1, int a2);
char __cdecl sub_10034740(void *a1);
BOOL sub_10034760();
// int __usercall sub_10034790@<eax>(char a1@<al>, int a2@<ecx>);
char __thiscall sub_100347C0(void *this);
char __thiscall sub_10034820(void *this);
char __cdecl sub_10034890(char a1, char a2, int *a3);
char __cdecl sub_10034A40(char a1, int *a2, char a3);
char __cdecl sub_10034AB0(char a1, int *a2);
int __cdecl sub_10034AE0(unsigned int a1, _BYTE *a2, unsigned int a3);
signed int __cdecl sub_10034BE0(int a1);
// signed int __usercall sub_10034C00@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10);
// int (__cdecl *__usercall sub_100350A0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD);
// int __usercall sub_100350F0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5);
signed int __cdecl sub_10035110(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_100354C0@<eax>(int a1@<edi>, int a2@<esi>, int a3);
// signed int __usercall sub_10035600@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4);
// signed int __usercall sub_10035650@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9);
// int __usercall sub_100356F0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4);
signed int __cdecl sub_10035710(int a1, int a2, int a3, int a4);
void __cdecl sub_10035800(int a1);
// int __usercall sub_10035810@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10035EB0@<eax>(int a1@<eax>, int a2, int a3);
// signed int __usercall sub_10036890@<eax>(int a1@<edi>, int a2);
signed int __cdecl sub_10036BC0(int a1, int *a2, int a3, int a4, int a5, int a6, int a7);
signed int __cdecl sub_10036C40(int a1, int a2);
char __cdecl sub_10036C60(char a1, _BYTE *a2, _BYTE *a3, char a4);
char __thiscall sub_10036CA0(void *this);
// void __usercall sub_10036D60(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6);
char __cdecl sub_10036DC0(unsigned __int8 a1);
// char __usercall sub_10036E00@<al>(void *a1@<ecx>, int a2@<esi>);
char __cdecl sub_10036E40(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_100373C0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10037420(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10037470(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_100374F0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10037CA0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_10037D80(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_10037E10(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_10038020(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_10038240(char a1, unsigned __int16 a2, int a3, int a4, int a5);
void __cdecl sub_100382A0(char a1, unsigned __int16 a2, int a3, int a4, int a5);
char __cdecl sub_10038300(int a1, void *a2);
int __cdecl sub_10038370(int a1);
char __cdecl sub_100383A0(int a1, void *a2);
int __cdecl sub_10038430(__int16 a1, char a2, char a3, char a4);
char __cdecl sub_10038470(char a1);
signed int __cdecl sub_10038510(char a1, char a2);
int __cdecl sub_10038570(char a1);
signed int __cdecl sub_100385B0(char a1, char a2, char a3);
int __cdecl sub_10038620(char a1);
int __cdecl sub_10038660(char a1);
char __cdecl sub_100386A0(int a1, int a2);
char __cdecl sub_100386C0(char a1, int a2);
char __cdecl sub_100386E0(char a1, int a2);
char __cdecl sub_10038710(char a1, int a2);
char __cdecl sub_10038760(char a1, int a2);
char __cdecl sub_10038790(int a1);
char __cdecl sub_100387B0(char a1, int a2);
char __cdecl sub_100387D0(int a1);
int __cdecl sub_100387F0(int, float); // idb
char sub_10038820();
bool __thiscall sub_10038840(void *this);
char sub_10038860();
BOOL __cdecl sub_10038900(int a1, int a2);
char __cdecl sub_10038920(int a1, char a2, int a3, int a4, int a5);
unsigned int __cdecl sub_10038960(unsigned int a1);
int __cdecl sub_10038980(int a1);
bool __cdecl sub_10038990(int a1);
int __cdecl sub_10038A60(int a1);
int __cdecl sub_10038A80(int a1, int a2);
bool __cdecl sub_10038AC0(int a1);
signed int __cdecl sub_10038B20(int a1, void *a2, unsigned __int16 a3, __int16 a4);
signed int __cdecl sub_10038BE0(int a1, int a2, int a3);
int __cdecl sub_10038C90(int a1);
signed int __cdecl sub_10038CB0(_BYTE *a1, _BYTE *a2, int a3);
// int __usercall sub_10038D10@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_10038E20@<eax>(int a1@<eax>, int a2@<esi>);
// signed int __usercall sub_10038ED0@<eax>(int a1@<eax>, int a2@<esi>);
// char __usercall sub_100390A0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>);
// int __usercall sub_100390B0@<eax>(int result@<eax>);
// char __usercall sub_100390D0@<al>(int a1@<eax>);
// int __usercall sub_100390F0@<eax>(int a1@<esi>, unsigned __int8 a2);
int __cdecl sub_10039130(unsigned int a1);
int __fastcall sub_100392E0(int a1, int a2);
// int __usercall sub_10039300@<eax>(int result@<eax>, int a2@<ecx>);
// int __usercall sub_10039310@<eax>(int a1@<esi>);
// signed int __usercall sub_10039350@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10039560(void *); // idb
int __cdecl sub_100395C0(int, int, void *, int); // idb
signed int __cdecl sub_100396C0(int a1, unsigned __int64 a2);
signed int __cdecl sub_100398C0(int a1, int a2);
int __cdecl sub_100398E0(int a1);
int __cdecl sub_10039B50(void *, int, char); // idb
signed int __cdecl sub_10039C20(unsigned int a1, int a2, int a3);
// int __usercall sub_10039CC0@<eax>(int a1@<eax>);
// int __usercall sub_10039CE0@<eax>(int a1@<edi>, int a2);
// signed int __usercall sub_10039D10@<eax>(int a1@<eax>, int a2@<ebx>);
int __cdecl sub_10039D80(int, char *, int); // idb
// void __cdecl __noreturn exit_0(int);
signed int __cdecl sub_10039EF0(int a1);
// char __usercall sub_10039F50@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>);
// signed int __usercall sub_10039F80@<eax>(int a1@<eax>);
// BOOL __usercall sub_10039FB0@<eax>(int a1@<ebx>, int a2);
signed int __cdecl sub_10039FF0(unsigned int a1);
signed int __cdecl sub_1003A040(int a1, int a2);
// bool __usercall sub_1003A230@<al>(int a1@<eax>);
int __cdecl sub_1003A260(int, int, char, void *, int); // idb
signed int __cdecl sub_1003A370(unsigned int a1, int a2, int a3);
signed int __cdecl sub_1003A3D0(unsigned int a1, int a2, int a3);
int __cdecl sub_1003A560(int a1, char *a2, int a3, void *a4, int a5);
int __cdecl sub_1003A750(unsigned __int8 *a1);
int __cdecl sub_1003A770(unsigned __int8 *a1, int a2);
int __cdecl sub_1003A7A0(unsigned __int8 *a1);
int __cdecl sub_1003A7C0(_BYTE *a1);
int __cdecl sub_1003A7E0(unsigned __int8 *a1);
int __cdecl sub_1003A800(unsigned __int8 *a1);
int __cdecl sub_1003A820(unsigned __int8 *a1);
int __cdecl sub_1003A840(unsigned __int8 *a1);
_DWORD __cdecl sub_1003A860(_DWORD); // weak
int __cdecl sub_1003A870(int a1);
int __cdecl sub_1003A8B0(int a1);
signed int __cdecl sub_1003A8D0(int a1, int a2);
bool __cdecl sub_1003A930(signed int a1);
int sub_1003A9A0();
char sub_1003ACC0();
char sub_1003AEE0();
char sub_1003B0E0();
char sub_1003B260();
char sub_1003B3E0();
char sub_1003B550();
char sub_1003B650();
char sub_1003B7B0();
char sub_1003B910();
char sub_1003BA70();
char sub_1003BBE0();
char sub_1003BD40();
char sub_1003BEA0();
char sub_1003C0C0();
char sub_1003C220();
char sub_1003C380();
char sub_1003C4E0();
char sub_1003C650();
char sub_1003C7B0();
char sub_1003C910();
char sub_1003CB30();
char sub_1003CD30();
char sub_1003CEB0();
char sub_1003D030();
char sub_1003D1A0();
char sub_1003D290();
char sub_1003D3F0();
char sub_1003D550();
char sub_1003D6B0();
char sub_1003D820();
char sub_1003D980();
char sub_1003DAE0();
char sub_1003DCE0();
char sub_1003DE40();
char sub_1003DFA0();
char sub_1003E100();
char sub_1003E270();
char sub_1003E3D0();
char sub_1003E530();
char sub_1003EAD0();
char sub_1003ECE0();
char sub_1003EED0();
char sub_1003F040();
char sub_1003F1B0();
char sub_1003F310();
char sub_1003F400();
char sub_1003F560();
char sub_1003F6C0();
char sub_1003F820();
char sub_1003F990();
char sub_1003FAF0();
char sub_1003FC50();
char sub_1003FE50();
char sub_1003FFB0();
char sub_10040110();
char sub_10040270();
char sub_100403E0();
char sub_10040540();
char sub_100406A0();
char sub_100408B0();
char sub_10040AA0();
char sub_10040C10();
char sub_10040D80();
char sub_10040EE0();
char sub_10040FD0();
char sub_10041130();
char sub_10041290();
char sub_100413F0();
char sub_10041560();
char sub_100416C0();
char sub_10041820();
char sub_10041A20();
char sub_10041B80();
char sub_10041CE0();
char sub_10041E40();
char sub_10041FB0();
char sub_10042110();
char **sub_10042270();
double __cdecl sub_10042280(_DWORD); // weak
bool sub_10042290();
bool sub_100422A0();
int __cdecl sub_100422C0(_BYTE *a1);
char __cdecl sub_100422F0(_BYTE *a1, _BYTE *a2);
char __cdecl sub_10042340(_BYTE *a1, _BYTE *a2);
int sub_10042390();
__int16 sub_10042460();
// int __usercall sub_100424C0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4);
signed int __cdecl sub_10042540(int a1);
unsigned __int8 sub_10042630();
char sub_10042700();
int (__cdecl *(*sub_100428C0())[2])(int, int);
signed int __cdecl sub_100429F0(_BYTE *a1, _BYTE *a2, int a3);
signed int __cdecl sub_10042A30(int a1);
unsigned __int8 __cdecl sub_10042A50(const char *a1, int a2);
double __cdecl sub_10042B90(signed int a1, char a2);
void __cdecl sub_10042BD0(_BYTE *a1, signed int a2, int a3);
bool __cdecl sub_10042C70(unsigned int a1, unsigned __int16 a2);
int __cdecl sub_10042CB0(unsigned __int16 a1);
double sub_10042CE0();
double sub_10042D10();
// void __usercall sub_10042D40(int a1@<esi>, int a2, float a3);
// char __usercall sub_10042EA0@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3);
// char __usercall sub_10042F90@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4);
char __cdecl sub_10043270(float *a1);
char __cdecl sub_100432A0(float *a1);
char __cdecl sub_100432D0(float *a1);
char __cdecl sub_10043340(float *a1);
char __cdecl sub_10043360(float *a1);
char __cdecl sub_10043380(float *a1);
char __cdecl sub_10043410(float *a1);
char __cdecl sub_10043480(float *a1);
char __cdecl sub_10043550(float *a1);
char __cdecl sub_10043620(float *a1);
char __cdecl sub_100436F0(float *a1);
char __cdecl sub_10043790(float *a1);
double sub_10043800();
char __cdecl sub_10043860(float *a1);
char __cdecl sub_100438E0(float *a1);
char __cdecl sub_10043980(float *a1);
char __thiscall sub_100439A0(void *this);
double __cdecl sub_100439C0(char a1);
double sub_10043A40(void); // weak
int __cdecl sub_10043A50(int a1);
signed int __cdecl sub_10043B50(int a1, int a2);
char __cdecl sub_10043BF0(char a1);
char __thiscall sub_10043C20(void *this);
char __cdecl sub_10043C30(char a1, void *a2);
char __cdecl sub_10043CE0(char a1);
char sub_10043D40();
int __cdecl sub_10043DC0(char a1);
// int __usercall sub_10043DD0@<eax>(char *a1@<eax>, char a2@<cl>);
// char __usercall sub_10043DE0@<al>(char a1@<bl>, char a2);
char __cdecl sub_10043EA0(char a1, char a2);
int __cdecl sub_10043EC0(char a1);
_DWORD __cdecl sub_10043EF0(char); // weak
int __cdecl sub_10043F00(char a1);
char __cdecl sub_10043F20(unsigned __int8 a1);
int __cdecl sub_10043F40(int, void *); // idb
// int __usercall sub_10043FA0@<eax>(char a1@<al>);
BOOL __cdecl sub_10043FD0(char a1, int a2);
int __cdecl sub_10044000(int, char, int, int, void *); // idb
char __cdecl sub_10044030(void *a1);
BOOL __cdecl sub_10044050(int a1);
char __cdecl sub_10044070(int a1, char a2, int a3, int a4, void *a5);
bool __cdecl sub_100440A0(unsigned __int8 a1, char a2, unsigned int a3);
bool __cdecl sub_10044130(char a1, char a2, void *a3);
bool __cdecl sub_100441B0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6);
bool __cdecl sub_10044250(char a1, void *a2);
// signed int __usercall sub_10044290@<eax>(char a1@<al>);
bool __cdecl sub_100442B0(char a1, void *a2);
bool __cdecl sub_100443A0(char a1, char a2, int a3, int a4, void *a5);
BOOL __cdecl sub_100443D0(unsigned __int8 a1);
// BOOL __usercall sub_100443E0@<eax>(unsigned __int8 a1@<al>, char a2);
bool __cdecl sub_10044410(char a1, char a2, unsigned __int8 a3, int a4);
bool __cdecl sub_100445C0(unsigned __int8 a1, int a2);
bool __cdecl sub_10044600(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6);
char __cdecl sub_100446F0(char a1, unsigned __int8 a2, int a3);
bool __cdecl sub_10044790(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10044810(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10044880(char a1, void *a2);
char __cdecl sub_10044900(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10044980(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10044A00(char a1, unsigned __int8 a2, int a3);
char __cdecl sub_10044A70(char a1, char a2, char a3, unsigned __int8 *a4, int a5);
char __cdecl sub_10044B80(char a1, void *a2);
bool __cdecl sub_10044BA0(unsigned __int8 a1, char *a2);
char __cdecl sub_10044BE0(int a1, char a2, int a3, int a4, void *a5);
BOOL sub_10044C20();
char __cdecl sub_10044C80(int a1, char *a2);
BOOL __cdecl sub_10044D70(int a1, int a2);
char __cdecl sub_10044D90(int a1, char a2, int a3, int a4, char *a5);
char __cdecl sub_10044DD0(char a1);
// __int16 __usercall sub_10044E10@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10044E20(unsigned __int8 a1, char *a2);
char __cdecl sub_10044EF0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6);
char __cdecl sub_10044F70(unsigned __int16 a1);
char __cdecl sub_10045010(char a1, char a2, char a3, int a4, void *a5);
int __cdecl sub_10045120(char a1);
char __cdecl sub_10045170(char a1, int a2);
// int __usercall sub_100452E0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3);
// int __usercall sub_10045320@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3);
signed int sub_10045360();
char __cdecl sub_10045370(unsigned __int8 a1, unsigned __int16 a2, int a3);
char __cdecl sub_100453D0(char a1, void *a2);
char __cdecl sub_100454F0(unsigned __int8 a1, unsigned __int8 a2, int a3);
char __cdecl sub_10045570(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6);
char __cdecl sub_10045720(unsigned __int16 a1, char *a2, char a3);
char __cdecl sub_10045850(char a1, int a2);
bool __cdecl sub_100458D0(void *a1);
char __cdecl sub_10045920(char a1, int a2);
// __int16 __usercall sub_10045A00@<ax>(unsigned __int8 a1@<al>);
char __cdecl sub_10045A10(unsigned __int8 a1, int *a2, const void *a3);
char __cdecl sub_10045AA0(unsigned __int8 a1, char a2);
bool __cdecl sub_10045B60(__int16 a1, char a2, int a3, int a4, void *a5);
char __thiscall sub_10045C60(void *this);
// char __usercall sub_10045CD0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4);
// void *__usercall sub_10045D10@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4);
char __cdecl sub_10045DB0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10045DF0(char a1, char a2, void *a3);
char __cdecl sub_10045E50(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10045E90(char a1, char a2, void *a3);
char __cdecl sub_10045EC0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10045F00(char a1, char a2, void *a3);
char __cdecl sub_10045F40(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10045F80(char a1, char a2, void *a3);
char __cdecl sub_10045FD0(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10046010(char a1, char a2, void *a3);
char __cdecl sub_10046050(char a1, unsigned __int8 a2, void *a3);
bool __cdecl sub_10046090(char a1, char a2, void *a3);
char __cdecl sub_100460D0(char a1, void *a2);
char __cdecl sub_10046100(char a1, void *a2);
char __cdecl sub_10046130(char a1, void *a2);
char __cdecl sub_10046160(char a1, void *a2);
char __cdecl sub_10046190(char a1, void *a2);
char __cdecl sub_100461C0(char a1, void *a2);
char __cdecl sub_100461F0(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_10046230(char a1, char a2, void *a3);
char __cdecl sub_10046280(char a1, unsigned __int8 a2, void *a3);
char __cdecl sub_100462C0(char a1, char a2, void *a3);
char __cdecl sub_100462F0(char a1, void *a2);
char __cdecl sub_10046320(char a1, void *a2);
char __cdecl sub_10046350(char a1, void *a2);
char __cdecl sub_10046380(int a1, char a2, char a3, int a4, void *a5);
double __cdecl sub_10046720(int a1);
int __cdecl sub_10046770(int a1);
double __cdecl sub_100467B0(float a1);
char __cdecl sub_10046830(unsigned __int16 a1, float *a2);
double __cdecl sub_10046950(float a1);
// char __usercall sub_100469B0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3);
char __cdecl sub_10046EF0(int a1, float *a2);
// char __usercall sub_10046F50@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5);
// double __usercall sub_10047060@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4);
unsigned __int8 __cdecl sub_10047160(int a1, int a2, char a3, void *a4);
char __cdecl sub_100472F0(unsigned __int16 a1, void *a2);
char __cdecl sub_10047350(int a1, int a2, void *a3);
char __cdecl sub_100475F0(unsigned __int16 a1, void *a2);
// int __usercall sub_10047640@<eax>(unsigned __int16 a1@<di>);
int __cdecl sub_10047680(unsigned __int16 a1);
BOOL __cdecl sub_100476B0(unsigned __int16 a1);
int __cdecl sub_100476D0(unsigned __int8 *a1, int a2);
int __cdecl sub_10047700(_BYTE *a1, int a2);
char *__cdecl sub_10047730(char **a1);
int sub_10047780();
int __cdecl sub_100477C0(_BYTE *a1, int a2);
signed int __cdecl sub_10047830(_BYTE *a1, int a2);
// int __usercall sub_100478D0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>);
// signed int __usercall sub_10047900@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5);
// char *__usercall sub_10047AD0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>);
// int __usercall sub_10047B30@<eax>(int a1@<esi>, int a2, _DWORD *a3);
// int __usercall sub_10047BC0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4);
// char **__usercall sub_10047C10@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3);
// const char *__usercall sub_10047C70@<eax>(int a1@<eax>);
// int __usercall sub_10047C90@<eax>(unsigned int a1@<ebx>);
// int __usercall sub_10047CD0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5);
// int __usercall sub_10047D60@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4);
// int __usercall sub_10047EB0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>);
// int __usercall sub_10047F50@<eax>(int result@<eax>);
char *__cdecl sub_10047F90(int a1, char *a2, int a3, const char *a4);
// int __usercall sub_10048140@<eax>(int a1@<eax>);
// int __usercall sub_10048170@<eax>(int a1@<esi>);
void __cdecl sub_100481A0(int (**a1)(void), char **a2, _DWORD *a3);
int sub_10048610();
void *sub_10048660();
char *sub_100486C0();
char sub_100486E0();
char __cdecl sub_100486F0(int a1, int a2, unsigned int a3);
// int *__usercall sub_10048730@<eax>(_DWORD *a1@<ebx>, int a2);
char **sub_10048780();
int __cdecl sub_10048790(_DWORD *a1, int a2, int a3);
int __cdecl sub_10048840(int a1, int a2, int a3, const char *a4, const char *a5);
// char *__usercall sub_10048A50@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6);
char *__cdecl sub_10048B10(char a1);
int *__cdecl sub_10048BB0(_BYTE *a1);
// int __usercall sub_10048C70@<eax>(int a1@<eax>);
// signed int __usercall sub_10048DD0@<eax>(int a1@<esi>);
int __cdecl sub_10048E40(int, int); // weak
char **sub_10049120();
// int __usercall sub_10049130@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6);
int __cdecl sub_10049220(char *a1);
int sub_10049460();
int __cdecl sub_10049540(int a1, int a2, char a3);
int __cdecl sub_10049590(int a1);
int __cdecl sub_100495A0(void *); // idb
int __cdecl sub_10049620(int a1, int a2);
signed int __cdecl sub_10049650(int a1, int a2, int a3);
char __cdecl sub_10049670(_DWORD *a1);
char __cdecl sub_10049780(int a1, unsigned int a2);
bool __cdecl sub_100497B0(const void **a1, int a2);
bool __cdecl sub_100497E0(const void **a1, int a2);
bool __cdecl sub_10049810(const void **a1, int a2);
bool __cdecl sub_10049840(const void **a1, int a2);
bool __cdecl sub_10049870(const void **a1, int a2);
bool __cdecl sub_100498A0(int a1, int a2);
bool __cdecl sub_100498E0(int a1, int a2);
bool __cdecl sub_10049920(const void **a1, int a2);
bool __cdecl sub_10049950(const void **a1, int a2);
char __cdecl sub_10049980(int a1, unsigned int a2);
bool __cdecl sub_100499B0(const void **a1, int a2);
bool __cdecl sub_100499E0(const void **a1, int a2);
bool __cdecl sub_10049A10(const void **a1, int a2);
bool __cdecl sub_10049A40(const void **a1, int a2);
bool __cdecl sub_10049A70(const void **a1, int a2);
bool __cdecl sub_10049AA0(const void **a1, int a2);
bool __cdecl sub_10049AD0(const void **a1, int a2);
bool __cdecl sub_10049B00(const void **a1, int a2);
bool __cdecl sub_10049B30(const void **a1, int a2);
bool __cdecl sub_10049B60(const void **a1, int a2);
int __cdecl sub_10049B90(int a1, int a2, int a3);
// void __cdecl __noreturn exit_1(int);
int __cdecl sub_10049C00(int a1, char a2);
int __cdecl sub_10049C20(int a1, int a2, int a3);
int __cdecl sub_10049C50(int a1, int a2, int a3, int a4);
int __cdecl sub_10049C80(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10049CC0(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_10049D00(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
char __cdecl sub_10049D50(int a1);
char __cdecl sub_10049D80(int a1);
char __cdecl sub_10049D90(int a1, int a2);
signed int __cdecl sub_10049F10(int a1);
signed int __cdecl sub_10049F50(int a1, int a2, int a3);
char __cdecl sub_10049FF0(int a1);
char __cdecl sub_1004A050(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1004A0C0(char *a1);
int __cdecl sub_1004A160(int a1, int a2, int a3);
bool __cdecl sub_1004A1D0(int a1, unsigned int a2, int a3);
char __cdecl sub_1004A260(int a1, int a2, char a3, char a4);
char __cdecl sub_1004A310(int a1);
char __cdecl sub_1004A320(int a1, void (__cdecl *a2)(int));
int (__cdecl *__cdecl sub_1004A3A0(int a1, const char *a2))(const char *);
signed int __cdecl sub_1004A3F0(int a1, void (__cdecl *a2)(int));
char *__cdecl sub_1004A440(int a1, int a2, int a3, size_t a4, char *a5);
int sub_1004A5C0();
const char *__cdecl sub_1004A5D0(unsigned int a1);
int __cdecl sub_1004A5F0(int a1, int a2, int a3, int a4);
int __cdecl sub_1004A6A0(int a1);
int __cdecl sub_1004A6C0(int a1);
char *sub_1004A6E0(char *a1, ...);
// char *__usercall sub_1004A720@<eax>(char a1@<al>, unsigned __int8 a2@<cl>);
// char __usercall sub_1004A740@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5);
int sub_1004A920(); // weak
int sub_1004A940(); // weak
int __cdecl sub_1004A960(int a1, int a2);
int __cdecl sub_1004A9C0(int a1);
int __cdecl sub_1004A9D0(int a1, int a2);
int __cdecl sub_1004AA30(int a1);
bool __cdecl sub_1004AA40(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1004AB80(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8);
bool __cdecl sub_1004AF30(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9);
bool __cdecl sub_1004B380(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9);
bool __cdecl sub_1004B840(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1004BC00(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9);
bool __cdecl sub_1004C000(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1004C3C0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9);
bool __cdecl sub_1004C900(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9);
bool __cdecl sub_1004CCE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9);
bool __cdecl sub_1004D0A0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1004D440(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9);
bool __cdecl sub_1004D840(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
bool __cdecl sub_1004DBE0(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9);
bool __cdecl sub_1004E1C0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9);
bool __cdecl sub_1004E5B0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9);
int sub_1004E950();
// BOOL __usercall sub_1004E980@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6);
// bool __usercall sub_1004EAF0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9);
char __cdecl sub_1004ED60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
bool __cdecl sub_1004F060(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
bool __cdecl sub_1004F110(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8);
const char *__cdecl sub_1004F150(int a1, int a2);
char __cdecl sub_1004F190(int a1, int *a2, unsigned int a3);
signed int __cdecl sub_1004FF40(int a1, int a2);
char **__cdecl sub_1004FFC0(int a1);
int (__cdecl *__cdecl sub_10050000(const char *a1))(const char *);
const char *sub_10050020();
__int64 sub_10050030();
const char *sub_10050040();
// int __usercall sub_10050050@<eax>(_BYTE *a1@<edi>, int a2);
signed int __cdecl sub_100500A0(int a1, int a2);
int sub_100500D0(); // weak
// int __usercall sub_100501F0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3);
char __cdecl sub_10050570(int a1, const void **a2, unsigned int a3);
char **__cdecl sub_10051390(int a1);
int __cdecl sub_10051400(int *a1, int a2);
_DWORD __cdecl sub_10051420(_DWORD, _DWORD); // weak
char __cdecl sub_10051430(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_10051490(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4);
char __cdecl sub_100514F0(_DWORD *a1);
__int16 *__cdecl sub_10051560(char a1, unsigned __int16 a2);
int __cdecl sub_100517D0(unsigned __int8 a1, char a2);
int __cdecl sub_10051850(unsigned __int8 a1, char a2);
int __cdecl sub_100518D0(unsigned __int8 a1, char a2);
void *__cdecl sub_10051950(unsigned __int8 a1, char a2);
int __cdecl sub_100519D0(char a1);
int __cdecl sub_100519F0(char a1);
int __cdecl sub_10051A10(char a1);
void *__cdecl sub_10051A30(char a1, unsigned __int8 a2, char a3);
void *__cdecl sub_10051AF0(unsigned __int8 a1, char a2, char a3);
void *__cdecl sub_10051B90(unsigned __int8 a1, char a2, char a3);
char sub_10051C60();
BOOL __fastcall sub_10051C70(int a1);
void *__cdecl sub_10051CA0(char a1);
char sub_10051CF0();
int *__cdecl sub_10051F80(char a1);
void *__cdecl sub_10051FE0(char a1);
int __cdecl sub_10052040(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10052110(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4);
int __cdecl sub_100523B0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10052480(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10052550(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10052620(unsigned __int8 a1, char a2);
int __cdecl sub_100526B0(unsigned __int8 a1, char a2);
int __cdecl sub_10052740(unsigned __int8 a1, char a2);
int __cdecl sub_100527D0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_100528A0(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10052970(unsigned __int8 a1, char a2);
int __cdecl sub_10052A00(unsigned __int8 a1, char a2);
int __cdecl sub_10052A90(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_10052B30(unsigned __int8 a1, char a2);
int __cdecl sub_10052B50(unsigned __int8 a1, char a2);
char __cdecl sub_10052B70(unsigned __int16 a1, _BYTE *a2, _WORD *a3);
char __cdecl sub_10052BD0(char a1, __int16 a2, unsigned __int16 *a3);
void *__cdecl sub_10052C30(char a1);
int __cdecl sub_10052C90(unsigned __int8 a1, char a2);
int __cdecl sub_10052D10(unsigned __int8 a1);
int __cdecl sub_10052D30(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10052E00(unsigned __int8 a1, char a2);
int __cdecl sub_10052E90(unsigned __int8 a1, unsigned __int8 a2, char a3);
int __cdecl sub_10052F60(int a1, unsigned __int8 a2, char a3);
int __cdecl sub_10053000(unsigned __int8 a1, char a2);
void *__cdecl sub_10053020(char a1);
void *__cdecl sub_10053080(char a1);
void *__cdecl sub_100530E0(char a1);
int __cdecl sub_10053140(char a1, char a2);
void *__cdecl sub_100531E0(char a1);
void *__cdecl sub_10053240(char a1);
char __cdecl sub_100532A0(char a1);
// signed int __usercall sub_100532C0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10054370@<eax>(int a1@<esi>, int a2, unsigned int a3);
// signed int __usercall sub_100543D0@<eax>(int a1@<eax>, int a2, int a3);
// void *__usercall sub_10055150@<eax>(void *a1@<eax>);
unsigned int __cdecl sub_10055170(int a1, unsigned int a2);
// int __usercall sub_100551D0@<eax>(int result@<eax>);
// int __usercall sub_10055210@<eax>(int result@<eax>);
// unsigned int __usercall sub_10056930@<eax>(int a1@<esi>, int a2);
// void *__usercall sub_10056A30@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3);
// void *__usercall sub_10056AB0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3);
// int __usercall sub_10056B50@<eax>(int a1@<edi>, int a2, size_t a3);
// int __usercall sub_10056C10@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3);
// int __usercall sub_10056C70@<eax>(char *a1@<edi>);
// int __usercall sub_10056D30@<eax>(int a1@<ebx>);
char __cdecl sub_10056DF0(char *a1, size_t a2, int a3);
char __cdecl sub_10056E40(char *a1, unsigned int a2, int a3);
bool __cdecl sub_10056E90(int a1, int a2);
// int __usercall sub_10056EC0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7);
// int __usercall sub_100570D0@<eax>(void *a1@<eax>, int a2);
char *__cdecl sub_10057120(int a1, int a2);
signed int __cdecl sub_100571B0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6);
bool __cdecl sub_100572E0(void *a1, int a2);
// BOOL __usercall sub_10057360@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// int __usercall sub_10057400@<eax>(int result@<eax>);
unsigned int __fastcall sub_10057490(unsigned int a1, int a2);
// int __usercall sub_100574B0@<eax>(int result@<eax>);
// int __usercall sub_10057540@<eax>(int result@<eax>, int a2, int a3);
// int __usercall sub_100579C0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>);
// void *__usercall sub_10057A70@<eax>(int a1@<edi>);
// int __usercall sub_10057AD0@<eax>(int result@<eax>, int a2@<edx>);
// signed int __usercall sub_10057CA0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>);
_WORD *__fastcall sub_10057D20(int a1, int a2);
// signed int __usercall sub_10057D90@<eax>(int a1@<esi>);
// unsigned int __usercall sub_10057E50@<eax>(int a1@<esi>, unsigned int a2);
// unsigned int __usercall sub_10058000@<eax>(int a1@<esi>, int a2);
// int __usercall sub_100580D0@<eax>(int result@<eax>, int a2@<edi>, int a3);
// int __usercall sub_10058180@<eax>(int result@<eax>, __int16 a2@<cx>);
// unsigned int __usercall sub_100581C0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3);
// signed int __usercall sub_10058220@<eax>(signed int result@<eax>, int a2@<ecx>, int a3);
// int __usercall sub_10058300@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>);
_WORD *__fastcall sub_100588A0(int a1, int a2);
signed int __cdecl sub_10058900(int a1);
// int __usercall sub_10058990@<eax>(int a1@<eax>);
// int __usercall sub_10058BD0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4);
// signed int __usercall sub_10058C70@<eax>(int a1@<esi>, int a2);
// unsigned int __usercall sub_10058E50@<eax>(int a1@<edi>);
// int __usercall sub_10058F90@<eax>(int a1@<eax>, int a2, int a3, int a4);
signed int __cdecl sub_10059240(int a1, int a2);
signed int __cdecl sub_10059500(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
// signed int __usercall sub_100596B0@<eax>(int a1@<eax>);
// _WORD *__usercall sub_10059780@<eax>(int a1@<eax>, int a2@<ecx>, int a3);
signed int __cdecl sub_100599A0(int a1, int a2);
signed int __cdecl sub_10059CB0(int a1, int a2);
signed int __cdecl sub_1005A0C0(int a1, int a2);
signed int __cdecl sub_1005A230(unsigned int a1);
signed int __cdecl sub_1005A310(unsigned int a1, int a2, int a3, int a4);
signed int __cdecl sub_1005A370(unsigned int a1, int a2, int a3);
BOOL __cdecl sub_1005A390(unsigned int a1);
BOOL __cdecl sub_1005A3B0(int a1);
_DWORD __cdecl sub_1005A3D0(_DWORD); // weak
unsigned int __cdecl sub_1005A3E0(int a1, char a2);
signed int __cdecl sub_1005A440(void *a1, int a2, unsigned int a3);
int __cdecl sub_1005A460(int a1, int a2, int a3);
char __cdecl sub_1005A480(const char *a1, const char *a2);
int __cdecl sub_1005A5C0(int a1, int a2, unsigned int a3);
char __cdecl sub_1005A640(int a1, int a2);
char __cdecl sub_1005A690(int a1, int a2);
char __cdecl sub_1005A740(int a1, int a2);
char __cdecl sub_1005A7A0(int a1, int a2);
bool __cdecl sub_1005A870(void *a1);
char __cdecl sub_1005A8B0(char a1);
char __cdecl sub_1005A8E0(char a1, void *a2);
int __cdecl sub_1005A960(char a1, _DWORD *a2);
char sub_1005A9B0();
int __cdecl sub_1005A9C0(char a1, char *a2);
int __cdecl sub_1005AA10(char a1, char a2);
// bool __usercall sub_1005AAC0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3);
// char __usercall sub_1005AAF0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6);
char __cdecl sub_1005AB90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1005AC10(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1005AC90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
char __cdecl sub_1005AD10(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5);
// char __usercall sub_1005AD90@<al>(void *a1@<esi>);
// char __usercall sub_1005ADD0@<al>(float *a1@<esi>);
char __cdecl sub_1005ADF0(float *a1);
char __cdecl sub_1005AE50(float *a1);
char __cdecl sub_1005AEB0(float *a1);
// char __usercall sub_1005AF10@<al>(int a1@<esi>);
char __cdecl sub_1005AFB0(float *a1);
char __cdecl sub_1005B000(float *a1);
char __cdecl sub_1005B050(float *a1);
char __cdecl sub_1005B0B0(float *a1);
// char __usercall sub_1005B110@<al>(float *a1@<esi>, char a2);
char __cdecl sub_1005B200(float a1, int a2);
// char __usercall sub_1005B270@<al>(float *a1@<esi>);
char __cdecl sub_1005B2F0(float *a1);
char __cdecl sub_1005B350(float *a1);
char __cdecl sub_1005B3E0(float *a1);
// char __usercall sub_1005B470@<al>(float *a1@<esi>);
// char __usercall sub_1005B810@<al>(float *a1@<esi>);
// char __usercall sub_1005B880@<al>(float *a1@<esi>);
// char __usercall sub_1005B8A0@<al>(float *a1@<esi>);
// void __usercall sub_1005B930(float *a1@<esi>);
char __cdecl sub_1005B9C0(float *a1);
// char __usercall sub_1005BAE0@<al>(float *a1@<esi>, float a2);
// char __usercall sub_1005BCE0@<al>(float *a1@<esi>, float a2);
// char __usercall sub_1005BD70@<al>(float *a1@<eax>);
// char __usercall sub_1005BD80@<al>(float *a1@<eax>);
// char __usercall sub_1005BD90@<al>(float *a1@<eax>);
// char __usercall sub_1005BDA0@<al>(float *a1@<eax>);
// int __usercall sub_1005BDB0@<eax>(char a1@<dl>, int a2@<ecx>, float *a3);
// char __usercall sub_1005BDE0@<al>(float *a1@<esi>);
// char __usercall sub_1005BE80@<al>(float *a1@<esi>);
char __cdecl sub_1005BF60(float *a1);
// char __usercall sub_1005BFB0@<al>(float *a1@<esi>);
// char __usercall sub_1005C090@<al>(float *a1@<esi>);
// char __usercall sub_1005C170@<al>(float *a1@<esi>);
// char __usercall sub_1005C210@<al>(float *a1@<esi>);
// char __usercall sub_1005C2B0@<al>(float *a1@<esi>);
// char __usercall sub_1005C350@<al>(float *a1@<esi>);
char __cdecl sub_1005C430(float *a1);
bool __cdecl sub_1005C4D0(float *a1);
// char __usercall sub_1005C580@<al>(float *a1@<esi>);
// char __usercall sub_1005C600@<al>(float *a1@<esi>);
// char __usercall sub_1005C690@<al>(float *a1@<esi>);
int __cdecl sub_1005C700(float *a1);
int __cdecl sub_1005C930(float *a1);
int __cdecl sub_1005CB60(float *a1);
int __cdecl sub_1005CD90(float *a1);
// char __usercall sub_1005CFC0@<al>(float *a1@<esi>);
// char __usercall sub_1005D050@<al>(float *a1@<esi>);
bool __cdecl sub_1005D0C0(float *a1);
char __cdecl sub_1005D120(float a1, void *a2);
int __cdecl sub_1005D9D0(int a1);
char __cdecl sub_1005D9E0(signed int a1, _DWORD *a2, _DWORD *a3);
char *__cdecl sub_1005DA20(const char *a1, int a2);
// char *__usercall sub_1005DA90@<eax>(char *result@<eax>);
void __cdecl sub_1005DAC0(char *a1);
void __cdecl sub_1005DB80(char *a1, char *a2);
void *__cdecl sub_1005DBE0(int a1);
int __cdecl sub_1005DD70(int a1, int a2);
// char __usercall sub_1005DEB0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5);
signed int __cdecl sub_1005DF80(_DWORD *a1, char *a2);
int sub_1005E060();
void __cdecl sub_1005E070(int a1);
int __cdecl sub_1005E0A0(int a1);
bool __cdecl sub_1005E0C0(int a1);
void *__cdecl sub_1005E0F0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5);
// unsigned int __usercall sub_1005E130@<eax>(int a1@<edx>, int a2, int a3);
// int __usercall sub_1005E150@<eax>(int result@<eax>, int a2@<ecx>);
char __cdecl sub_1005E170(void (__cdecl *a1)(_DWORD), int a2);
signed int __cdecl sub_1005E1A0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5);
void __cdecl sub_1005E280(int a1, int a2, int a3);
// void *__usercall sub_1005E330@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3);
void __cdecl sub_1005E5B0(int a1, int a2);
char __cdecl sub_1005E680(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4);
// int __usercall sub_1005E6F0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9);
// int __usercall sub_1005EA50@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7);
int __cdecl sub_1005EB60(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10);
char __cdecl sub_1005ECF0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3);
// char __usercall sub_1005EE40@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5);
char __cdecl sub_1005EF90(int a1, int a2);
int __cdecl sub_1005EFD0(int a1, int a2, int a3);
// int (__cdecl *__usercall sub_1005EFF0@<eax>(int a1@<eax>, int a2@<ecx>))(int);
// int __usercall sub_1005F000@<eax>(unsigned __int8 *a1@<eax>, int a2);
int (__cdecl *__cdecl sub_1005F230(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1005F280(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1005F2D0(int a1, unsigned __int8 *a2))(int);
int (__cdecl *__cdecl sub_1005F320(int a1))(int);
int __cdecl sub_1005F3A0(int a1, int a2);
int (__cdecl *__cdecl sub_1005F420(int a1, unsigned __int8 *a2, char a3))(int);
int (__cdecl *__cdecl sub_1005F470(int a1, int a2, unsigned __int8 *a3))(int);
int (__cdecl *__cdecl sub_1005F4B0(int a1, int a2, int a3))(int);
bool __thiscall sub_1005F510(void *this);
char __cdecl sub_1005F550(char a1, void *a2);
char __cdecl sub_1005F600(float a1, int a2);
char __cdecl sub_1005F6A0(int a1, float *a2);
int __cdecl sub_1005F800(void *, void *, size_t, int, int); // idb
int __cdecl sub_1005F8B0(unsigned __int16 a1);
char __cdecl sub_1005F8F0(float a1, int a2, int a3);
double __cdecl sub_1005F9A0(float a1, float a2);
void __cdecl sub_1005F9C0(int a1, int a2, int a3, int a4, int a5, float a6);
// void __usercall sub_1005FA30(int a1@<ebx>, int a2@<edi>, float a3, float a4);
// void __usercall sub_1005FD20(int a1@<esi>);
void __cdecl sub_1005FD90(int a1, float a2, float a3, int a4);
void __cdecl sub_1005FFA0(int a1, float a2, float a3, int a4);
int __cdecl sub_10060050(int, float, float, int, int, float); // idb
char __cdecl sub_100600E0(int a1, float a2, int a3, float a4, char a5, int a6);
char __cdecl sub_10060340(int a1, float a2, int a3, float a4, int a5);
char sub_100603F0();
void __cdecl sub_10060410(int a1, int a2, int a3, float *a4, int a5);
int __cdecl sub_10060540(int, float, float, int, int); // idb
char __cdecl sub_100605B0(float a1, int a2, int a3);
int __cdecl sub_10060810(int a1);
int sub_10060830();
int __cdecl sub_10060850(int a1, int a2, int a3);
int __cdecl sub_10060880(int a1, int a2);
__int16 __cdecl sub_100608B0(int a1);
int __cdecl sub_100608D0(int a1, int a2);
int sub_10060900();
int __cdecl sub_10060920(int a1, int a2, int a3, int a4);
int sub_10060950();
int j_TSK_pvg_get_us_timer(void); // weak
int __cdecl sub_100609B0(int a1, int a2, int a3, int a4);
int __cdecl sub_100609E0(int a1);
int __cdecl sub_10060A00(int a1);
signed int __cdecl sub_10060A20(int a1, int a2);
int __cdecl sub_10060A60(int a1, int a2);
int __cdecl sub_10060A90(int a1, int a2);
int __cdecl sub_10060AC0(int a1, int a2, int a3, int a4);
int __cdecl sub_10060AF0(int a1, int a2);
int __cdecl sub_10060B20(int a1);
signed int __cdecl sub_10060B40(int a1, int a2);
int __cdecl sub_10060B90(int a1);
char __cdecl sub_10060BB0(int a1, int a2);
int __cdecl sub_10060C20(_BYTE *a1);
int __cdecl sub_10060C60(int a1, int a2);
int __cdecl sub_10060C90(int a1, int a2);
bool __cdecl sub_10060CB0(int a1);
int __cdecl sub_10060CD0(int a1);
int __cdecl j_REG_pvg_flush_que(_DWORD, _DWORD, _DWORD); // weak
unsigned int __cdecl sub_10060D20(unsigned int a1);
int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_reg_get_xfil_tag_data(_DWORD, _DWORD, _DWORD); // weak
int __fastcall nullsub_1(_DWORD, _DWORD); // weak
int __cdecl sub_10060D80(int a1, int a2, int a3);
int __cdecl sub_10060DA0(int a1, int a2, __int16 a3, int a4, int a5);
char __cdecl sub_10060E00(int a1, int a2, int a3);
int __cdecl sub_10060E40(int, void *, int, void *); // idb
int __cdecl sub_10060E80(int a1, int a2, int a3);
int __cdecl sub_10060EB0(int a1, int a2, int a3);
int __cdecl sub_10060ED0(int a1, int a2, int a3);
int __cdecl sub_10060EF0(int a1, int a2, int a3);
int __cdecl sub_10060F50(int a1, int a2, int a3);
char __cdecl sub_10060F90(int a1, int a2, int a3);
int __cdecl j_REG_pvg_xfil_read_data(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_REG_pvg_xfil_shld_rqst_tag(_DWORD); // weak
int __cdecl j_REG_pvg_xfil_write_data(_DWORD, _DWORD); // weak
int __cdecl sub_10061000(int, void *, int, void *); // idb
int sub_10061050(void); // weak
int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD); // weak
signed int __cdecl sub_10061070(unsigned int a1);
signed int __cdecl sub_100610B0(unsigned int a1);
int __cdecl j_FIL_vfs_delete(_DWORD); // weak
int j_FIL_vfs_dyn_linker(void); // weak
int __cdecl sub_100610F0(int, void *); // idb
int __cdecl sub_10061120(int a1, int a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_100611A0(unsigned int a1, void *a2, int a3);
int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD); // weak
signed int __cdecl sub_100611F0(unsigned int a1, void *a2, int a3, int a4, int a5);
int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD); // weak
int __cdecl j_FIL_vfs_rmdir(_DWORD); // weak
signed int __cdecl sub_10061290(unsigned int a1, int a2, int a3, int a4);
__int64 __cdecl sub_100612E0(int a1);
int j_FIL_vfs_sync_all(void); // weak
int __cdecl sub_10061310(int a1, int a2, int a3);
int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_10061340(int a1, int a2, int a3, char a4);
char __cdecl sub_10061360(int a1);
char __cdecl sub_10061390(int a1);
int __cdecl sub_100613C0(int a1, int a2, int a3);
signed int __cdecl sub_100613E0(unsigned int a1, int a2, int a3);
int __cdecl sub_10061400(int a1, int a2, int a3);
int __cdecl sub_10061420(const char *a1);
int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD); // weak
int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD); // weak
int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_put(_DWORD); // weak
int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD); // weak
int __cdecl j_HWM_pvg_log_err(_DWORD); // weak
int __cdecl j_HWM_pvg_read_reg(_DWORD); // weak
int sub_10061680();
int __cdecl sub_100616A0(int a1, int a2);
signed int __cdecl sub_10061700(int a1);
// int __usercall sub_10061780@<eax>(const char **a1@<esi>);
// int __usercall sub_10061A80@<eax>(int a1@<eax>, int a2@<ecx>);
signed int __cdecl sub_10061AA0(int a1);
int __cdecl sub_10061B70(LONG Value); // idb
__int16 sub_10061C00();
void __cdecl sub_10061C40(int a1, _BYTE *a2);
int __cdecl sub_10061C70(int a1, int a2);
int __cdecl sub_10061C90(char a1);
__int16 __cdecl sub_10061CC0(int a1, int a2, int a3, int a4);
int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD); // weak
__int16 __cdecl sub_10061D00(int a1, _DWORD *a2, _BYTE *a3);
int __cdecl sub_10061D60(int a1);
int __cdecl sub_10061DA0(int a1);
int __cdecl sub_10061DE0(int a1);
int __cdecl sub_10061E20(int a1);
int __cdecl sub_10061E60(int a1, int a2, int a3, int a4);
int __cdecl sub_10061ED0(int a1, int a2, int a3);
int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_create_id(_DWORD); // weak
int __cdecl sub_10061FB0(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl sub_10062000(int a1, int a2, int a3, __int16 a4, int a5);
int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD); // weak
int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD); // weak
int sub_10062070(void); // weak
unsigned int __cdecl sub_10062080(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6);
// int __usercall sub_10062230@<eax>(int a1@<esi>);
int __cdecl sub_100622E0(int a1, unsigned __int64 a2);
// int __usercall sub_10062390@<eax>(int a1@<ebx>, unsigned __int64 a2);
unsigned int __cdecl sub_10062420(int a1, void *a2, int a3, int a4, int a5);
bool sub_10062570();
__int16 __cdecl sub_10062590(unsigned __int16 a1);
int __cdecl j_mem_unmap(_DWORD, _DWORD); // weak
void __cdecl sub_10062620(__int16 a1, _BYTE *a2);
double __cdecl sub_10062650(char a1);
signed int __cdecl sub_100626E0(char a1);
signed int sub_10062700();
char __cdecl sub_10062720(char a1);
char __cdecl sub_10062790(char a1, char a2, float *a3);
char __cdecl sub_100628D0(char a1, float *a2);
char __cdecl sub_10062A20(int a1);
char sub_10062C70();
void __cdecl sub_10062CC0(float *a1, float *a2, float *a3, int a4);
int __cdecl sub_10062D20(float, float, int); // idb
void __cdecl sub_10062EE0(int a1, int a2, float *a3, float *a4, float *a5);
void __cdecl sub_100632B0(int a1, int a2, float *a3, float *a4);
int __cdecl sub_10063390(int a1, float a2, float *a3, int a4, float *a5);
double __cdecl sub_10063470(float a1);
void __cdecl sub_100634A0(float *a1, float *a2, int a3);
double __cdecl sub_10063560(int a1, int a2);
char __cdecl sub_10063580(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7);
char *__cdecl sub_100646C0(int a1, int a2, int a3, int a4);
char __cdecl sub_10064730(int a1, int a2);
char *__cdecl sub_10064780(int a1, int a2);
signed int __cdecl sub_100647D0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
char __cdecl sub_10064920(__int16 a1, __int16 a2);
char *__cdecl sub_100649C0(int a1, int a2);
char *__cdecl sub_10064B70(int a1, int a2);
int __cdecl sub_10064D20(int a1, __int16 a2, __int16 a3, char a4);
int __cdecl sub_10065270(int a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_100654D0(int a1, int a2, char a3);
int __cdecl sub_100655C0(int a1, __int16 a2, __int16 a3);
char __cdecl sub_10065620(int a1, __int16 a2, __int16 a3, __int16 a4, char a5);
char __cdecl sub_100660A0(int a1);
char __cdecl sub_10066150(int a1);
int __cdecl sub_100662C0(int a1);
char *__cdecl sub_10066320(int a1);
unsigned int __cdecl sub_10066470(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10066530(int a1, int a2);
unsigned int __cdecl sub_10066650(int a1, int a2);
int __cdecl sub_100667F0(int a1, int a2, int a3);
int __cdecl sub_10066870(int a1, int a2, int a3);
int __cdecl sub_100668E0(int a1, int a2, int a3);
char __cdecl sub_10066960(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10066A70(int a1, signed int a2, signed int a3);
int __cdecl sub_10066B60(int a1, signed int a2, int a3, int a4);
int __cdecl sub_10066C60(int a1, int a2);
char *__cdecl sub_10066D90(int a1, signed int a2, int a3, int *a4);
char *__cdecl sub_10066ED0(int a1, signed int a2, int a3, int *a4);
int __cdecl sub_10067120(int a1, signed int a2, int a3);
int __cdecl sub_10067260(int a1, signed int a2, int a3);
int __cdecl sub_100673A0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5);
int __cdecl sub_100674B0(int a1, signed int a2, signed int a3);
int __cdecl sub_10067980(int a1);
int __cdecl sub_10067A90(int a1, _DWORD *a2);
int __cdecl sub_10067CA0(int a1);
int __cdecl sub_10067E30(int a1, int *a2, int *a3);
int __cdecl sub_10067ED0(int a1);
int __cdecl sub_10067EF0(signed int a1, signed int a2);
double __cdecl sub_10067F30(float a1, float a2);
double __cdecl sub_10067FD0(double a1, double a2);
double __cdecl sub_10068030(float a1, float a2);
int __cdecl sub_100680B0(double); // idb
double __cdecl sub_100680D0(float a1);
int __cdecl sub_10068110(int a1, int a2);
int __cdecl sub_10068130(signed int a1, signed int a2);
double __cdecl sub_10068180(float a1, float a2);
int __cdecl sub_100681F0(float); // idb
int __cdecl sub_10068220(float, int, int); // idb
int __cdecl sub_10068240(int a1, int a2);
double __cdecl sub_10068260(double a1, double a2);
double __cdecl sub_100682D0(float a1, float a2);
int __cdecl sub_10068360(unsigned __int8 a1, unsigned int a2);
unsigned int __cdecl sub_10068380(unsigned int *a1, signed int a2, unsigned int a3);
int __cdecl sub_100684B0(int a1, int a2, int a3);
int __cdecl sub_100684E0(float, int, int); // idb
// int __cdecl SIM_proc_rqst(_DWORD); weak
// int SYS_exit_krnl(void); weak
// int __cdecl SYS_pvg_is_booting(_DWORD); weak
// int SYS_enter_krnl(void); weak
// int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_crit_lvl(_DWORD); weak
// int TSK_pvg_get_id(void); weak
// int __cdecl TSK_pvg_get_mon_data(_DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_get_run_state(_DWORD); weak
// int __cdecl TSK_pvg_get_smphr_stats(_DWORD, _DWORD); weak
// int TSK_pvg_get_timer(void); weak
// int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_release_smphr(_DWORD); weak
// int __cdecl TSK_pvg_reply_msg(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD); weak
// int __cdecl TSK_pvg_set_proc_status(_DWORD); weak
// int __cdecl TSK_pvg_suspend(_DWORD); weak
// int __cdecl TSK_pvg_wait_evnt(_DWORD); weak
// int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_read_from_xml(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_close(void); weak
// int FIL_vfs_fstat(void); weak
// int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int FIL_vfs_read(void); weak
// int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_size(_DWORD); weak
// int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD); weak
// int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD); weak
// int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD); weak
// int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD); weak
// int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD); weak
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memset(void *, int, size_t);
// char *__cdecl strncpy(char *, const char *, size_t);
// int sprintf(char *, const char *, ...);
// int _snprintf(char *, size_t, const char *, ...);
// _DWORD __thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *); idb
// double __cdecl _atof_l(const char *String, _locale_t Locale);
double __cdecl sub_10068FB6(char *String);
__int32 __cdecl j__atol(const char *);
// int __cdecl isalpha(int);
// int __cdecl isdigit(int);
// int __cdecl isxdigit(int);
// int __cdecl isspace(int);
// int __cdecl isalnum(int);
// int __cdecl isprint(int);
// char *__cdecl strstr(const char *, const char *);
// int __cdecl strncmp(const char *, const char *, size_t);
// void *__cdecl memcpy_0(void *, const void *, size_t);
// int __cdecl fclose(FILE *);
// size_t __cdecl fread_s(void *DstBuf, size_t DstSize, size_t ElementSize, size_t Count, FILE *File);
size_t __cdecl sub_10069C2F(void *DstBuf, size_t ElementSize, size_t Count, FILE *File);
// FILE *__cdecl _fsopen(const char *, const char *, int);
FILE *__cdecl sub_10069D0E(char *a1, char *a2);
// char *__cdecl strchr(const char *, int);
// char *__cdecl strrchr(const char *, int);
// int __cdecl tolower(int);
// void *__cdecl memchr(const void *, int, size_t);
// int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
// int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1006AAB7(int a1, int a2, char a3);
// char *__cdecl strncat(char *, const char *, size_t);
// double __cdecl floor(double);
// char *__cdecl strpbrk(const char *, const char *);
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
int __cdecl sub_1006B96A(int, FILE *); // idb
int __cdecl sub_1006C4FF(int a1);
// int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl _encode_pointer(_DWORD); weak
// int _encoded_null(void); weak
// _DWORD __cdecl _decode_pointer(_DWORD); weak
// int _getptd(void); weak
// _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __cdecl free(void *);
signed int __cdecl sub_1006ED03(signed int a1);
// int __cdecl _fileno(FILE *);
// _DWORD __cdecl flsall(_DWORD); weak
int sub_1006F03E();
void **sub_1006F047();
signed int sub_1006F04D();
// _DWORD __cdecl _lock_file2(_DWORD, _DWORD); weak
// _DWORD __cdecl _unlock_file2(_DWORD, _DWORD); weak
int __cdecl sub_1006F3E6(FILE *); // idb
// int __cdecl _read(int, void *, unsigned int);
int sub_1006FEDF();
signed int __cdecl sub_10070214(_DWORD *a1);
signed int __cdecl sub_1007024B(_DWORD *a1);
// int __cdecl _malloc_crt(size_t); idb
// _DWORD __cdecl _calloc_crt(size_t, _DWORD); weak
void sub_100707DE();
int (*sub_10070C8B())(void);
void __cdecl sub_10070CAF(); // idb
// int __cdecl isleadbyte(int);
// int __cdecl __check_float_string(int, void *, int); idb
// int __fastcall _inc(_DWORD, _DWORD); weak
// _DWORD __cdecl _whiteout(_DWORD); weak
int __cdecl sub_10072F0F(FILE *, int, struct localeinfo_struct *, int); // idb
// _DWORD __cdecl _unlock(_DWORD); weak
// _DWORD __cdecl _mtinitlocknum(_DWORD); weak
// _DWORD __cdecl _lock(_DWORD); weak
void sub_1007668B();
// int _get_sse2_info(void); weak
int sub_10076743();
DWORD __cdecl sub_10076750(int a1, int a2, int a3, DWORD dwMoveMethod);
// __int64 __cdecl _lseeki64(int, __int64, int);
_WORD *__cdecl sub_100768EC(int a1, int a2, DWORD nNumberOfBytesToWrite);
_WORD *__cdecl sub_10076F0E(int a1, int a2, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _getbuf(_DWORD); weak
int __cdecl sub_1007702E(signed int a1);
int __cdecl sub_100772B5(int, int, struct localeinfo_struct *); // idb
int __cdecl sub_1007735B(int, int, struct localeinfo_struct *); // idb
signed int __cdecl sub_10077E18(int a1, int a2);
signed int __cdecl sub_1007835A(int a1, int a2);
int __cdecl sub_10079567(int, HANDLE hHandle); // idb
signed int __cdecl sub_100795E4(signed int a1);
signed int __cdecl sub_10079665(signed int a1);
// _DWORD __cdecl __lock_fhandle(_DWORD); weak
void __cdecl sub_10079776(signed int a1);
int __cdecl sub_1007A7EB(int a1);
// _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD); weak
int sub_1007ADA9();
int __cdecl sub_1007AF66(int a1);
int __cdecl sub_1007AF70(int a1);
int __cdecl sub_1007AF7A(int a1);
int __cdecl sub_1007B6DC(int, FILE *); // idb
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *, const char *, size_t);
int sub_1007B924();
// int __cdecl _putwch_nolock(__int16 Buffer); idb
DWORD __cdecl sub_1007D357(int a1, LONG lDistanceToMove, DWORD dwMoveMethod);
signed int __cdecl sub_1007D3C9(signed int a1, int a2);
signed int __cdecl sub_1007D485(_DWORD *a1);
int __cdecl sub_1007D4B9(int a1, int a2, int a3);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetLastError();
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_10015CD0; // weak
_UNKNOWN loc_1001EBE0; // weak
_UNKNOWN loc_100355C0; // weak
// extern _UNKNOWN SIM_intf; weak
void *tsk_app_hdr_ptr = &tsk_app_hdr; // weak
__int16 word_1007F968 = 2573; // weak
_UNKNOWN unk_1007F988; // weak
char word_1007F98C[] = { '/', '\0' }; // idb
char *off_1007F9D0 = "/shr_mem/iop_arnc_adc_intf.shr"; // weak
char *off_1007FA04 = "/shr_mem/iop_arnc_ahrs_intf.shr"; // weak
char byte_10080D49 = '\0'; // idb
char byte_100823E8[] = { '\x11' }; // weak
int (__cdecl *off_100823EC)(int) = &sub_1000D060; // weak
int (__cdecl *off_100823F0[2])(char, int, int, int, int, int) = { &sub_1000D160, &sub_1000D160 }; // weak
int (__cdecl *off_100823F4)(char, int, int, int, int, int) = &sub_1000D160; // weak
int dword_100823F8[] = { 0 }; // weak
int (__cdecl *off_100823FC)(int) = &sub_1000CA90; // weak
int (*off_10082400)() = &sub_1000CBB0; // weak
int (__cdecl *off_10082404)(int, char) = &sub_1000CEB0; // weak
int (__cdecl *off_10082408)(char, int, int, int, char, char *) = &sub_1000CBE0; // weak
int dword_1008240C[] = { 0 }; // weak
char *off_10082414 = "/shr_mem/iop_d_cnfg_mngr_intf.shr"; // weak
_UNKNOWN unk_100839C0; // weak
char byte_100839C1[] = { '\0' }; // weak
char byte_10084910[] = { '\x01' }; // weak
char byte_10084911[] = { '\'' }; // weak
char byte_10084912[] = { '!' }; // weak
int dword_10084914[] = { 2097152 }; // weak
char *off_1008499C = "/shr_mem/iop_log_intf.shr"; // weak
char byte_10086518[] = { '\0' }; // weak
char *off_100865B8 = "AMD "; // idb
__int16 word_10087020[] = { 363 }; // weak
char *off_10087028 = "/shr_mem/iop_gdl59_intf.shr"; // weak
int dword_1008703C[] = { 64 }; // weak
char byte_10088468[] = { '\x01' }; // weak
_UNKNOWN unk_100884C0; // weak
char *off_10088B44 = "/shr_mem/gdl69_xm_audio_intf.shr"; // weak
int dword_100899F0[] = { 3824 }; // weak
char aReceiverFailur[17] = "RECEIVER FAILURE"; // weak
__int16 word_1008A628[] = { 1800 }; // weak
_UNKNOWN unk_1008A7E0; // weak
int dword_1008A930[] = { 1761805953 }; // weak
int dword_1008A934[] = { 1761805953 }; // weak
_UNKNOWN unk_1008A980; // weak
char byte_1008A981[1010] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'L',
  ' ',
  '6',
  '9',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x02',
  'R',
  'E',
  'Q',
  'U',
  'E',
  'S',
  'T',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'L',
  ' ',
  '6',
  '9',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x03',
  'V',
  'E',
  'R',
  'I',
  'F',
  'Y',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'L',
  ' ',
  '6',
  '9',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x04',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'L',
  ' ',
  '6',
  '9',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x06',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'L',
  ' ',
  '6',
  '9',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\a',
  'G',
  'D',
  'L',
  ' ',
  '6',
  '9',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  'U',
  'R',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  'G',
  'D',
  'L',
  ' ',
  '6',
  '9',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'F',
  'A',
  'I',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\t',
  'G',
  'D',
  'L',
  ' ',
  '6',
  '9',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  ' ',
  'C',
  'A',
  'N',
  'C',
  'E',
  'L',
  'L',
  'E',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\n',
  'S',
  'T',
  'O',
  'R',
  'I',
  'N',
  'G',
  ' ',
  'G',
  'D',
  'L',
  ' ',
  '6',
  '9',
  ' ',
  'C',
  'O',
  'N',
  'F',
  'I',
  'G',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_1008C20C; // weak
char byte_1008C20D[] = { '\0' }; // weak
_UNKNOWN unk_1008C228; // weak
char byte_1008C229[] = { '\0' }; // weak
int dword_1008CDC0[] = { 2175 }; // weak
char byte_1008CDD0[] = { '\0' }; // weak
int dword_1008CDD8[] = { 286262543 }; // weak
int dword_1008CDE0[] = { 8 }; // weak
_UNKNOWN unk_1008CDFC; // weak
__int16 word_1008D860[] = { 27 }; // weak
char byte_1008D862[] = { '\x03' }; // weak
char byte_1008D868[] = { '\0' }; // weak
_UNKNOWN unk_1008D874; // weak
__int16 word_1008D876[] = { 213 }; // weak
char byte_1008D878[] = { '\x03' }; // weak
_UNKNOWN unk_10091800; // weak
_UNKNOWN unk_10098C64; // weak
_UNKNOWN unk_10098C68; // weak
char *off_10099378[574] =
{
  "GET_HSDB",
  "INST_DATA",
  "XMWX_PROD_REQ",
  "XMWX_NEW_WX_NOTIFY",
  "PROD_STATUS_GDL_90",
  "PROD_DATA_GDL_90",
  "BFG_CMND",
  "BFG_STRIKE_DATA",
  "BFG_HDG",
  "BFG_STATUS",
  "BFG_FLT_CODE",
  "BFG_MSG",
  "BFG_SYS_DATA",
  "BFG_TRGR_CNT",
  "CDU_FAN_FAIL_MFD_1",
  "CDU_FAN_FAIL_PFD_1",
  "CDU_FAN_FAIL_PFD_2",
  "GSD_1_TICK",
  "GSD_2_TICK",
  "PROD_STATUS_GSD_1",
  "PROD_STATUS_GSD_2",
  "PROD_STATUS_ALT_ENC",
  "PROD_DATA_ALT_ENC",
  "ALT_ENC",
  "IRID_PHN_STS_1",
  "IRID_PHN_STS_2",
  "SET_PHN_VOL",
  "GIA_FAN_FAIL_GIA_1",
  "GIA_FAN_FAIL_GIA_2",
  "SYSTEM_ID",
  "DLMS_STS",
  "PROD_DATA_GTS",
  "PROD_DATA_GTS_FPGA",
  "PROD_DATA_GTS_AUDIO",
  "PROD_DATA_GTS_RGN_LIST",
  "RGN_NOTIFICATION",
  "RGN_BUFFER",
  "RGN_ACK",
  "PROD_STATUS_GTS",
  "GFDS_REG_DATA_COPY",
  "PROD_DATA_GIA_1",
  "PROD_DATA_COM_1",
  "PROD_DATA_GMU_1",
  "PROD_DATA_GPS_1",
  "PROD_DATA_GS_1",
  "PROD_DATA_NAV_1",
  "PROD_DATA_GTX_1",
  "PROD_DATA_GTX_2",
  "PROD_DATA_GEA_1",
  "PROD_DATA_GEA_2",
  "PROD_DATA_GEA_3",
  "PROD_DATA_GDC_1",
  "PROD_DATA_GDC_2",
  "PROD_DATA_GRS_1",
  "PROD_DATA_GRS_2",
  "PROD_DATA_ADF_1",
  "PROD_DATA_ADF_2",
  "PROD_DATA_WX500_1",
  "PROD_STATUS_GEA_1",
  "XMWX_PTP_DATA_MAP",
  "PROD_DATA_PTCH_MON",
  "PROD_DATA_PTCH_CTL",
  "PROD_DATA_ROLL_MON",
  "PROD_DATA_ROLL_CTL",
  "PROD_DATA_YAW_MON",
  "PROD_DATA_YAW_CTL",
  "PROD_DATA_PTCH_TR_M",
  "PROD_DATA_PTCH_TR_C",
  "PROD_DATA_ROLL_TR_M",
  "PROD_DATA_ROLL_TR_C",
  "PROD_DATA_YAW_TR_M",
  "PROD_DATA_YAW_TR_C",
  "PROD_DATA_GIA_2",
  "PROD_DATA_COM_2",
  "PROD_DATA_GMU_2",
  "PROD_DATA_GPS_2",
  "PROD_DATA_GS_2",
  "PROD_DATA_NAV_2",
  "PORT_STATUS_PFD_1",
  "PORT_STATUS_MFD_1",
  "PORT_STATUS_PFD_2",
  "PROD_STATUS_GMA_1",
  "PORT_STATUS_GIA_1",
  "PORT_STATUS_GIA_2",
  "PROD_STATUS_GMA_2",
  "PROD_STATUS_GTX_1",
  "PROD_STATUS_GTX_2",
  "PROD_STATUS_GEA_2",
  "PROD_STATUS_GEA_3",
  "PROD_STATUS_WX500_1",
  "PROD_STATUS_GDC_1",
  "XMWX_PTP_DATA_FRAG",
  "DSCRT_IN_IRID_HTR_OK_1",
  "DSCRT_IN_IRID_HTR_OK_2",
  "DSCRT_OUT_IRID_PWR_ON_1",
  "DSCRT_OUT_IRID_PWR_ON_2",
  "GDL59_GSRVR_STATUS",
  "HB_RATE",
  "BLOOD_O2_PCT",
  "CO_FINGER_AVAIL",
  "CO_SYS_FAIL",
  "CO_SNSR_FAIL",
  "PROD_DATA_CO_DETECTOR",
  "PROD_DATA_STEC",
  "PROD_DATA_GWX",
  "PROD_DATA_MFD_1",
  "PROD_DATA_PFD_1",
  "PROD_DATA_PFD_2",
  "PROD_STATUS_GIA_1",
  "PROD_STATUS_GDC_2",
  "PROD_STATUS_GRS_1",
  "PROD_STATUS_GRS_2",
  "PROD_STATUS_ADF_1",
  "PROD_STATUS_ADF_2",
  "PROD_DATA_GMA_1",
  "PROD_DATA_GMA_2",
  "PROD_STATUS_COM_1",
  "PROD_STATUS_GMU_1",
  "PROD_STATUS_GPS_1",
  "PROD_STATUS_GS_1",
  "PROD_STATUS_NAV_1",
  "FPGA_DATA_GSD_1",
  "FPGA_DATA_GSD_2",
  "RGN_LIST_DATA_GSD_1",
  "RGN_LIST_DATA_GSD_2",
  "PROD_DATA_GTS_MVAR",
  "GDL59_CMD_IRID_NET",
  "GDU_PROD_VER",
  "PROD_DATA_GDL59_WIFI",
  "PROD_STATUS_GDL59_ROUTER",
  "PROD_DATA_GDL59_RTR_FS",
  "ACTV_CAS_ALERTS",
  "ACTV_LOG_ALERTS",
  "ACTV_SYS_ALERTS",
  "XMWX_CHNL_SLCT_REQ",
  "PROD_STATUS_PIT_MON",
  "PROD_STATUS_PIT_CTL",
  "PROD_STATUS_ROL_MON",
  "PROD_STATUS_ROL_CTL",
  "PROD_STATUS_YAW_MON",
  "PROD_STATUS_YAW_CTL",
  "PROD_STATUS_PIT_T_M",
  "PROD_STATUS_PIT_T_C",
  "PROD_STATUS_ROL_T_M",
  "PROD_STATUS_ROL_T_C",
  "PROD_STATUS_YAW_T_M",
  "PROD_STATUS_YAW_T_C",
  "PROD_STATUS_GIA_2",
  "PROD_STATUS_IRID_1",
  "PROD_STATUS_IRID_2",
  "PROD_STATUS_COM_2",
  "PROD_STATUS_GMU_2",
  "PROD_STATUS_GPS_2",
  "PROD_STATUS_GS_2",
  "PROD_STATUS_NAV_2",
  "XMWX_CHNL_SLCT_CNFRM",
  "PROD_STATUS_STEC",
  "PROD_STATUS_GWX",
  "PROD_STATUS_MFD_1",
  "PROD_STATUS_PFD_1",
  "PROD_STATUS_PFD_2",
  "TCAS_ALT",
  "TCAS_ALT_LIM_A",
  "TCAS_ALT_LIM_B",
  "TCAS_ALT_SRC",
  "TCAS_CFG",
  "TCAS_DB",
  "TCAS_EQUIP_ID",
  "TCAS_FLT_SUMRY",
  "TCAS_GA_EQUIP_ID",
  "TCAS_HDG",
  "TCAS_RTS",
  "TCAS_VERT_RA",
  "GROSS_WEIGHT",
  "FMS_NAV_DATA",
  "TAWS_ALERT",
  "TAWS_STATUS",
  "OEM_DATA",
  "PFD_1_KEY_LOG",
  "MFD_1_KEY_LOG",
  "PFD_2_KEY_LOG",
  "CFGD_MINIMUM",
  "CFGD_REFERENCES",
  "CFGD_WEIGHT_UNIT",
  "PROD_DATA_GDC_1_FPGA",
  "PROD_DATA_GRS_1_FPGA",
  "PROD_DATA_GMU_1_FPGA",
  "PROD_DATA_GRS_1_MV_DB",
  "PROD_DATA_GDC_2_FPGA",
  "PROD_DATA_GRS_2_FPGA",
  "PROD_DATA_GMU_2_FPGA",
  "PROD_DATA_GRS_2_MV_DB",
  "XMWX_ACTV_CHNL_INFO",
  "XMWX_CHNL_INFO_REQ",
  "XMWX_CHNL_INFO_RESP",
  "XFIL_REG_TAG_TBL_PFD_1",
  "XFIL_REG_TAG_TBL_MFD_1",
  "XFIL_REG_TAG_TBL_PFD_2",
  "XFIL_REG_DATA_RQST",
  "XFIL_REG_DATA_MFD_1",
  "XFIL_REG_DATA_PFD_1",
  "XFIL_REG_DATA_PFD_2",
  "XMWX_PRGRM_INFO_REQ",
  "XMWX_PRGRM_INFO_RESP",
  "XMWX_SYS_DATA_REQ",
  "XMWX_SYS_DATA_RESP",
  "XMWX_VOLUME_IND",
  "XMWX_VOLUME_REQ",
  "XMWX_MUTE_IND",
  "XMWX_MUTE_REQ",
  "PROD_DATA_GDL69",
  "PROD_STATUS_GDL69",
  "XMWX_ACTVTN_STS",
  "XMWX_ACTVTN_QUERY",
  "XMWX_GET_VOLUME",
  "XMWX_VOLUME_STS",
  "XMWX_PRESET_QUERY",
  "XMWX_PRESET_RESP",
  "XMWX_PRESET_STORE",
  "XMWX_START_ACTVTN",
  "XMWX_END_ACTVTN",
  "XMWX_ACTVTN_IND",
  "PROD_DATA_GWX_FPGA",
  "PROD_DATA_GWX_RGN_LIST",
  "XMWX_SGNL_QUALITY_REQ",
  "XMWX_SGNL_QUALITY_RESP",
  "XMWX_CNFG_SET",
  "XMWX_CNFG_REQ",
  "XMWX_CNFG_RESP",
  "XMWX_SET_DIAG_MODE",
  "XMWX_DIAG_DATA_REQ",
  "XMWX_DIAG_DATA_RESP",
  "XMWX_PRESET_SELECT",
  "TRFC_PROD_SELECT",
  "TCAS_STANDBY_MODE_DSCRT",
  "TCAS_TEST_MODE_DSCRT",
  "PROD_DATA_GIA_1_CERT_FCS",
  "PROD_DATA_CERT_P_MON",
  "PROD_DATA_CERT_P_CTL",
  "PROD_DATA_CERT_R_MON",
  "PROD_DATA_CERT_R_CTL",
  "PROD_DATA_CERT_Y_MON",
  "PROD_DATA_CERT_Y_CTL",
  "PROD_DATA_CERT_P_TR_M",
  "PROD_DATA_CERT_P_TR_C",
  "PROD_DATA_CERT_R_TR_M",
  "PROD_DATA_CERT_R_TR_C",
  "PROD_DATA_CERT_Y_TR_M",
  "PROD_DATA_CERT_Y_TR_C",
  "PROD_DATA_GIA_2_CERT_FCS",
  "GDL59_RPT_STATUS",
  "FADEC_STATUS",
  "PROD_DATA_FADEC",
  "PROD_DATA_FUEL_QTY_1",
  "PROD_DATA_GCU_1",
  "PROD_DATA_GMC_1",
  "PROD_DATA_FUEL_QTY_2",
  "PROD_DATA_MFD_1_FPGA",
  "PROD_DATA_PFD_1_FPGA",
  "PROD_DATA_PFD_2_FPGA",
  "PROD_STATUS_GCU_1",
  "PROD_STATUS_GMC_1",
  "FUEL_QTY_1_STATUS",
  "FUEL_QTY_2_STATUS",
  "A429_DIAG_DATA_GIA_2",
  "A429_DIAG_DATA_GIA_1",
  "A429_DIAG_CTRL_GIA_2",
  "A429_DIAG_CTRL_GIA_1",
  "CO_LEVEL",
  "CO_LEVEL_ALARM",
  "CO_DETECTOR_RESET",
  "CO_DETECTOR_STATUS",
  "LIGHT_INPUT_MFD_1",
  "LIGHT_INPUT_PFD_1",
  "LIGHT_INPUT_PFD_2",
  "PROD_DATA_GIA_1_AUDIO",
  "PROD_DATA_GIA_2_AUDIO",
  "PROD_DATA_GSD_1",
  "PROD_DATA_GSD_2",
  "REGION_DATA",
  "PORT_STATUS_GSD_1",
  "PORT_STATUS_GSD_2",
  "PFD1_STALL_WARN_DBG",
  "PFD2_STALL_WARN_DBG",
  "MFD1_STALL_WARN_DBG",
  "PHONE_CMD_ACK",
  "PHONE_CMD",
  "GDL59_STATUS",
  "PROD_DATA_GDL59_ROUTER",
  "PROD_DATA_IRID_1",
  "PROD_DATA_IRID_2",
  "PROD_DATA_GDL59",
  "GDL59_PBX_STATUS",
  "GDL59_SETTINGS",
  "GDL59_CFG_ACT",
  "GDL59_CFG_CRC",
  "GDL59_MODE",
  "PROD_STATUS_GDL59",
  "GDL59_SET_VOLUME",
  "GDL59_VOLUME",
  "WIFI_SETTINGS",
  "WIFI_SCAN",
  "WIFI_STATUS",
  "GDL59_SEND_RPT",
  "GDL59_CNCL_RPT",
  "GDL59_ALRT_DATA",
  "GDL59_STATUS_DET",
  "GFDS_CFG",
  "GFDS_REG_DATA",
  "GFDS_LOGIN",
  "PROD_DATA_FP_L_1",
  "PROD_DATA_FP_R_1",
  "PROD_DATA_FP_L_2",
  "PROD_DATA_FP_R_2",
  "PROD_DATA_FP_L_3",
  "PROD_DATA_FP_R_3",
  "PROD_DATA_FP_L_4",
  "PROD_DATA_FP_R_4",
  "PROD_DATA_FP_L_5",
  "PROD_DATA_FP_R_5",
  "PROD_DATA_FP_C_1",
  "PROD_DATA_FP_C_2",
  "DSCRT_OUT_OEMDIAG_1",
  "DSCRT_OUT_OEMDIAG_2",
  "DSCRT_OUT_OEMDIAG_3",
  "DSCRT_OUT_OEMDIAG_4",
  "DSCRT_OUT_OEMDIAG_5",
  "DSCRT_OUT_OEMDIAG_6",
  "DSCRT_OUT_OEMDIAG_7",
  "DSCRT_OUT_OEMDIAG_8",
  "DSCRT_OUT_OEMDIAG_9",
  "DSCRT_OUT_OEMDIAG_10",
  "USER_EVENT",
  "TCAS_ALT_BCKP",
  "HDG_MODE",
  "RGN_LIST_DATA_GDL59",
  "PROD_DATA_GDL59_BB",
  "PROD_DATA_GDL59_RTR_BB",
  "DLMS_CONNECT",
  "DLMS_CONNECT_RSLT",
  "DLMS_DISCONNECT",
  "DLMS_DATAGRAM",
  "SMS_TX",
  "SMS_RX",
  "SMS_CMD",
  "SMS_CMD_RSLT",
  "SMS_TX_RSLT",
  "DTP_DATAGRAM",
  "LRU_PKT_ENBL",
  "GIA_1_ARINC_BUS_NAMES",
  "GIA_2_ARINC_BUS_NAMES",
  "PROD_DATA_NAV_1_FPGA",
  "PROD_DATA_NAV_1_BB",
  "PROD_DATA_NAV_2_FPGA",
  "PROD_DATA_NAV_2_BB",
  "PROD_STATUS_DIG_GMA_1",
  "PROD_STATUS_DIG_GMA_2",
  "PROD_STATUS_DIG_GMA_1_AUX",
  "PROD_STATUS_DIG_GMA_2_AUX",
  "PROD_DATA_DIG_GMA_1_SYS",
  "PROD_DATA_DIG_GMA_2_SYS",
  "PROD_DATA_DIG_GMA_1_AUX_SYS",
  "PROD_DATA_DIG_GMA_2_AUX_SYS",
  "ASR_AUDIO_DATA",
  "ASR_GRAMMAR_ACK",
  "ASR_RESULTS",
  "ASR_GRAMMAR_CMD",
  "PROD_DATA_DIG_GMA_1_AUX_BBL",
  "PROD_DATA_DIG_GMA_2_AUX_BBL",
  "PROD_DATA_DIG_GMA_1_AUX_RGN",
  "PROD_DATA_DIG_GMA_2_AUX_RGN",
  "PROD_DATA_DIG_GMA_1_BBL",
  "PROD_DATA_DIG_GMA_2_BBL",
  "PROD_DATA_DIG_GMA_1_RGN",
  "PROD_DATA_DIG_GMA_2_RGN",
  "PROD_DATA_DIG_GMA_1_FPGA",
  "PROD_DATA_DIG_GMA_2_FPGA",
  "PROD_DATA_DIG_GMA_1_AUD",
  "PROD_DATA_DIG_GMA_2_AUD",
  "ASR_STATUS_GMA_1_AUX",
  "ASR_STATUS_GMA_2_AUX",
  "PROD_DATA_DIG_GMA_1_AUX_ASR1",
  "PROD_DATA_DIG_GMA_2_AUX_ASR1",
  "PROD_DATA_DIG_GMA_1_AUX_ASR2",
  "PROD_DATA_DIG_GMA_2_AUX_ASR2",
  "PROD_DATA_DIG_GMA_1_AUX_ASR3",
  "PROD_DATA_DIG_GMA_2_AUX_ASR3",
  "GSD_1_ARINC_BUS_NAMES",
  "GSD_2_ARINC_BUS_NAMES",
  "XFIL_REG_TAG_TBL_GTC_1",
  "XFIL_REG_TAG_TBL_GTC_2",
  "XFIL_REG_DATA_GTC_1",
  "XFIL_REG_DATA_GTC_2",
  "PROD_STATUS_GTC_1",
  "PROD_STATUS_GTC_2",
  "PROD_DATA_GTC_1",
  "PROD_DATA_GTC_2",
  "PROD_DATA_GCU_2",
  "PROD_STATUS_GCU_2",
  "LIGHT_INPUT_GTC_1",
  "LIGHT_INPUT_GTC_2",
  "ADSB_UPLINK_MSG",
  "PROD_DATA_DIG_GMA_1_ARC",
  "PROD_DATA_DIG_GMA_2_ARC",
  "PROD_DATA_GTX_1_SYS",
  "PROD_DATA_GTX_1_FPGA",
  "PROD_DATA_GTX_1_BBL",
  "PROD_DATA_GTX_1_AUDIO",
  "PROD_DATA_GTX_2_SYS",
  "PROD_DATA_GTX_2_FPGA",
  "PROD_DATA_GTX_2_BBL",
  "PROD_DATA_GTX_2_AUDIO",
  "PROD_STATUS_GDL_90_ADSB",
  "BBL_PROD_DATA_GIA_1",
  "BBL_PROD_DATA_GIA_2",
  "PROD_DATA_GDC_1_BB",
  "PROD_DATA_GDC_1_RGN_LIST",
  "PROD_DATA_GDC_2_BB",
  "PROD_DATA_GDC_2_RGN_LIST",
  "PROD_DATA_GTC_1_FPGA",
  "PROD_DATA_GTC_2_FPGA",
  "PROD_DATA_GTC_1_BB",
  "PROD_DATA_GTC_2_BB",
  "PROD_DATA_GDR_BBL",
  "PROD_DATA_GDR_RGN",
  "PROD_DATA_GDR_SYS",
  "PROD_DATA_GDR_AUX_BBL",
  "PROD_DATA_GDR_AUX_RGN",
  "PROD_DATA_GDR_AUX_SYS",
  "PROD_STATUS_GDR",
  "PROD_STATUS_GDR_AUX",
  "PROD_DATA_GEA_4",
  "PROD_STATUS_GEA_4",
  "CVR_STATUS",
  "CVR_LRU_ID",
  "NWS_MON_MAINTENANCE_1",
  "NWS_CMD_MAINTENANCE_1",
  "FLAPS_MAINTENANCE_1",
  "FLAPS_MAINTENANCE_2",
  "SPOILERON_MAINT_MSG_1",
  "SPOILERON_MAINT_MSG_2",
  "SPOILERON_MAINT_MSG_3",
  "SPOILERON_MAINT_MSG_4",
  "PROD_DATA_GRS_1_BB",
  "PROD_DATA_GRS_1_RGN_LIST",
  "PROD_DATA_GRS_2_BB",
  "PROD_DATA_GRS_2_RGN_LIST",
  "GSD_3_TICK",
  "PROD_STATUS_GSD_3",
  "FPGA_DATA_GSD_3",
  "RGN_LIST_DATA_GSD_3",
  "PROD_DATA_GSD_3",
  "PORT_STATUS_GSD_3",
  "GSD_3_ARINC_BUS_NAMES",
  "BCU_INBRD_MAINT_1",
  "BCU_OUTBRD_MAINT_1",
  "A429_DIAG_CTRL_GSD_1",
  "A429_DIAG_CTRL_GSD_2",
  "A429_DIAG_CTRL_GSD_3",
  "A429_DIAG_DATA_GSD_1",
  "A429_DIAG_DATA_GSD_2",
  "A429_DIAG_DATA_GSD_3",
  "PROD_STATUS_GTC_3",
  "PROD_STATUS_GTC_4",
  "PROD_DATA_GTC_3",
  "PROD_DATA_GTC_4",
  "PROD_DATA_GTC_3_FPGA",
  "PROD_DATA_GTC_4_FPGA",
  "PROD_DATA_GTC_3_BB",
  "PROD_DATA_GTC_4_BB",
  "LIGHT_INPUT_GTC_3",
  "LIGHT_INPUT_GTC_4",
  "XFIL_REG_TAG_TBL_GTC_3",
  "XFIL_REG_TAG_TBL_GTC_4",
  "XFIL_REG_DATA_GTC_3",
  "XFIL_REG_DATA_GTC_4",
  "REGION_DATA_RQST",
  "MON_LOG_ENTRY",
  "PROD_DATA_GRA_SYS",
  "PROD_DATA_GRA_CPU2",
  "PROD_DATA_GRA_BB",
  "PROD_DATA_GRA_RGN_LIST",
  "PROD_STATUS_GRA_1",
  "PROD_STATUS_GRA_2",
  "LOG_FLDRS_INFO_REQ",
  "LOG_FLDRS_INFO_RSP",
  "LOG_FLIGHT_INFO_REQ",
  "LOG_FLIGHT_INFO_RSP",
  "PROD_DATA_GEA_7XXX_1",
  "PROD_DATA_GEA_7XXX_2",
  "PROD_DATA_GEA_7XXX_3",
  "PROD_DATA_GEA_7XXX_4",
  "GRA_1_MODE",
  "GRA_2_MODE",
  "GRA_CONFIG",
  "GSD_1_A429_PORT_1",
  "GSD_1_A429_PORT_2",
  "GSD_1_A429_PORT_3",
  "GSD_1_A429_PORT_4",
  "GSD_1_A429_PORT_5",
  "GSD_1_A429_PORT_6",
  "GSD_1_A429_PORT_7",
  "GSD_1_A429_PORT_8",
  "GSD_1_A429_PORT_9",
  "GSD_1_A429_PORT_10",
  "GSD_1_A429_PORT_11",
  "GSD_1_A429_PORT_12",
  "GSD_1_A429_PORT_13",
  "GSD_1_A429_PORT_14",
  "GSD_1_A429_PORT_15",
  "GSD_2_A429_PORT_1",
  "GSD_2_A429_PORT_2",
  "GSD_2_A429_PORT_3",
  "GSD_2_A429_PORT_4",
  "GSD_2_A429_PORT_5",
  "GSD_2_A429_PORT_6",
  "GSD_2_A429_PORT_7",
  "GSD_2_A429_PORT_8",
  "GSD_2_A429_PORT_9",
  "GSD_2_A429_PORT_10",
  "GSD_2_A429_PORT_11",
  "GSD_2_A429_PORT_12",
  "GSD_2_A429_PORT_13",
  "GSD_2_A429_PORT_14",
  "GSD_2_A429_PORT_15",
  "GSD_3_A429_PORT_1",
  "GSD_3_A429_PORT_2",
  "GSD_3_A429_PORT_3",
  "GSD_3_A429_PORT_4",
  "GSD_3_A429_PORT_5",
  "GSD_3_A429_PORT_6",
  "GSD_3_A429_PORT_7",
  "GSD_3_A429_PORT_8",
  "GSD_3_A429_PORT_9",
  "GSD_3_A429_PORT_10",
  "GSD_3_A429_PORT_11",
  "GSD_3_A429_PORT_12",
  "GSD_3_A429_PORT_13",
  "GSD_3_A429_PORT_14",
  "GSD_3_A429_PORT_15",
  "GIA_1_A429_PORT_1",
  "GIA_1_A429_PORT_2",
  "GIA_1_A429_PORT_3",
  "GIA_1_A429_PORT_4",
  "GIA_1_A429_PORT_5",
  "GIA_1_A429_PORT_6",
  "GIA_1_A429_PORT_7",
  "GIA_1_A429_PORT_8",
  "GIA_2_A429_PORT_1",
  "GIA_2_A429_PORT_2",
  "GIA_2_A429_PORT_3",
  "GIA_2_A429_PORT_4",
  "GIA_2_A429_PORT_5",
  "GIA_2_A429_PORT_6",
  "GIA_2_A429_PORT_7",
  "GIA_2_A429_PORT_8",
  "RGN_ACK_VAR",
  "EDU_N1_L_TRIM",
  "EDU_N1_R_TRIM",
  "EDU_L_ITT_TRIM",
  "EDU_R_ITT_TRIM",
  "CMD_DATA",
  "CMD_ACK",
  "DSPL_PANE_PFD_1_SETTINGS",
  "DSPL_PANE_PFD_2_SETTINGS",
  "DSPL_PANE_MFD_1_LEFT_SETTINGS",
  "DSPL_PANE_MFD_1_RIGHT_SETTINGS",
  "PFD_1_SETTINGS",
  "PFD_2_SETTINGS",
  "PFD_1_SLIP_SKID_ANGLE",
  "PFD_2_SLIP_SKID_ANGLE",
  "DRIFT_ANGLE",
  "CMC_TX_STATUS",
  "/shr_mem/iop_d_pkt_intf.shr"
}; // weak
char *off_10099C6C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
_UNKNOWN unk_10099C80; // weak
char *off_1009A338 = "/shr_mem/iop_d_pkt_names_intf.shr"; // weak
int dword_1009ACEC[] = { 88 }; // weak
__int16 word_1009B19C[] = { 836 }; // weak
char *off_1009B1BC = "/shr_mem/iop_a_pkt_intf.shr"; // weak
char *off_1009B1D0 = "/shr_mem/iop_b_pkt_intf.shr"; // weak
char *off_1009B1E4 = "/shr_mem/iop_c_pkt_intf.shr"; // weak
char *off_1009B1F8 = "/shr_mem/iop_d_dbg_pkt_intf.shr"; // weak
char *off_1009B20C = "/shr_mem/iop_d_pkt_intf.shr"; // weak
char *off_1009B220 = "/shr_mem/iop_m_pkt_intf.shr"; // weak
_UNKNOWN unk_1009BD80; // weak
char aStop_accel[11] = "STOP_ACCEL"; // weak
_UNKNOWN unk_1009C328; // weak
char aSkey1[6] = "SKEY1"; // weak
_UNKNOWN unk_1009C808; // weak
char aCrs_k[6] = "CRS_k"; // weak
_UNKNOWN unk_1009C900; // weak
char aGdu_key[8] = "GDU_KEY"; // weak
_UNKNOWN unk_1009CAC4; // weak
char byte_1009D630[] = { 'a' }; // weak
int dword_1009D634[] = { 65536 }; // weak
void *off_1009D638 = &unk_1009D500; // weak
int (__cdecl *off_1009D6D8[3])(char) = { &sub_1002D790, &sub_1002D6A0, &sub_1002D5F0 }; // weak
char byte_1009D6E7[] = { '\x01' }; // weak
_UNKNOWN unk_1009D6EC; // weak
_UNKNOWN unk_1009D6F8; // weak
int dword_1009D728[] = { 1 }; // weak
char byte_1009D744[] = { '\x18' }; // weak
char byte_1009D748[] = { '!' }; // weak
char byte_1009D749[] = { '\x11' }; // weak
char *off_1009D74C = "/shr_mem/iop_prod_data_intf.shr"; // weak
char *off_1009E1B0 = "/shr_mem/iop_sms_intf.shr"; // weak
_UNKNOWN unk_1009E73C; // weak
char *off_1009F650 = "/shr_mem/iop_tcas_intf.shr"; // weak
char *off_1009F704 = "/shr_mem/iop_trfc_intf.shr"; // weak
int dword_100A04A8[] = { 32768 }; // weak
int dword_100A04AC[] = { 0 }; // weak
int (__cdecl *off_100A04B0)(int, int, int, __int16) = &sub_10009CD0; // weak
int (__cdecl *off_100A04B4)(int) = &sub_10009C90; // weak
char *off_100A04C8 = "/shr_mem/iop_d_upld_mngr_intf.shr"; // weak
char byte_100A15F8[] = { '\0' }; // weak
char byte_100A1608[] = { '\x01' }; // weak
__int16 word_100A160A[] = { 1800 }; // weak
_UNKNOWN unk_100A2618; // weak
int (__cdecl *off_100A261C)(char, int, int) = &sub_1001D740; // weak
char byte_100A2740[] = { '\0' }; // weak
char byte_100A2741[] = { '\x1B' }; // weak
char *off_100A2770 = "/shr_mem/gdl69_xm_wx_intf.shr"; // weak
_UNKNOWN unk_100A33D8; // weak
__int16 word_100A33DC[] = { 256 }; // weak
_UNKNOWN unk_100A3990; // weak
int dword_100A3994[] = { 1 }; // weak
char *off_100A3A90[3] = { ".\\test\\nav_test_suite_2.c", "$Id$", &off_100A3A40 }; // weak
int (*off_100A3AA4[4])() = { &sub_10042270, &sub_10031990, &sub_10020980, &sub_10020BD0 }; // weak
_UNKNOWN unk_100A3AB8; // weak
char *off_100A3B48[3] = { ".\\test\\wwwx_test_suite.c", "$Id$", &off_100A3B20 }; // weak
char byte_100A3B5C[] = { '' }; // weak
char byte_100A5DE0[] = { '\x03' }; // weak
char byte_100A5DE1[20] =
{
  'F',
  'E',
  'W',
  '\0',
  '\x04',
  'S',
  'C',
  'T',
  '\0',
  '\x05',
  'B',
  'K',
  'N',
  '\0',
  '\x06',
  'O',
  'V',
  'C',
  '\0',
  '\0'
}; // idb
char byte_100A5DF8[] = { '\v' }; // weak
char aVc[3] = "VC"; // idb
_UNKNOWN unk_100A5FA4; // weak
char *off_100A6A7C = "/shr_mem/udb_intf.shr"; // weak
char byte_100A6A90[] = { ' ' }; // weak
char byte_100A6A98[] = { ' ' }; // weak
_UNKNOWN unk_100A6AA0; // weak
char byte_100A8A48[] = { '\0' }; // weak
char byte_100A8A49[] = { '\0' }; // weak
char byte_100A8A4A[] = { '\xFF' }; // weak
char byte_100A8A4B[] = { '\xFF' }; // weak
char byte_100A8A4C[] = { '\xFF' }; // weak
char byte_100A9758[] = { '\x05' }; // weak
char byte_100A975C[] = { '\b' }; // weak
int dword_100A9760[] = { 9 }; // weak
char a______[7] = "______"; // weak
_UNKNOWN unk_100A9D70; // weak
_UNKNOWN unk_100AA300; // weak
char aWgs84[21] = "WGS 84              "; // weak
_UNKNOWN unk_100AC4D0; // weak
char *off_100ADBA8 = "/shr_mem/mon_log_intf.shr"; // weak
char *off_100ADBBC = "/shr_mem/mon_main_intf.shr"; // weak
int (__cdecl *off_100AE0F8)(int, size_t, void *) = &sub_10029160; // weak
char *off_100AE19C = "/shr_mem/iop_tcas_ii_intf.shr"; // weak
char *off_100AE1D0 = "/shr_mem/iop_fltr_data_intf.shr"; // weak
_UNKNOWN unk_100AF8C4; // weak
_UNKNOWN unk_100AF8D0; // weak
int dword_100AF8D4[] = { 0 }; // weak
void *off_100AF8D8 = &unk_100AE7A8; // weak
__int16 word_100AF8DC[] = { 978 }; // weak
_UNKNOWN unk_100AFC70; // weak
int dword_100AFC74[] = { 0 }; // weak
_UNKNOWN unk_100AFE88; // weak
char *off_100AFEC8 = "/shr_mem/iop_cnfg_mngr_intf.shr"; // weak
char *off_100AFEDC = "/shr_mem/iop_prod_enbl_intf.shr"; // weak
char *off_100B37E0 = "/shr_mem/nav_intf.shr"; // weak
char *off_100B3D6C = "/shr_mem/tws_intf.shr"; // weak
char *off_100B3D98 = "/shr_mem/pvt_intf.shr"; // weak
int (*off_100B42D8[4])() = { &sub_1002C040, &sub_1002C020, &sub_1002C030, &sub_1002C020 }; // weak
_BYTE word_100B55A6[26] =
{
  0,
  0,
  0,
  0,
  31,
  0,
  59,
  0,
  90,
  0,
  120,
  0,
  151,
  0,
  181,
  0,
  212,
  0,
  243,
  0,
  17,
  1,
  48,
  1,
  78,
  1
}; // idb
_UNKNOWN unk_100B60B8; // weak
int dword_100B60BC[] = { 1312 }; // weak
_UNKNOWN unk_100B7020; // weak
_UNKNOWN unk_100B7038; // weak
char asc_100B70B8[2] = "+"; // weak
__int16 word_100B70BA[] = { 111 }; // weak
char byte_100B70BC[] = { '\x06' }; // weak
__int16 word_100B8480[] = { 701 }; // weak
_UNKNOWN unk_100B8500; // weak
_UNKNOWN unk_100B8508; // weak
char byte_100B8510[] = { '\x01' }; // weak
__int16 word_100B8A70[] = { 53 }; // weak
__int16 word_100B8A72[] = { 445 }; // weak
__int16 word_100B8A74[] = { 139 }; // weak
__int16 word_100B8A76[] = { 447 }; // weak
__int16 word_100B8A78[] = { 143 }; // weak
__int16 word_100B8A7A[] = { 141 }; // weak
__int16 word_100B8A7C[] = { 137 }; // weak
__int16 word_100B8A7E[] = { 354 }; // weak
__int16 word_100B8A80[] = { 468 }; // weak
char *off_100B971C = "/shr_mem/prx_intf.shr"; // weak
char *off_100B9C78 = "/shr_mem/iop_rgn_data_intf.shr"; // weak
char *off_100B9CE8 = "/shr_mem/dat_intf.shr"; // weak
int (__cdecl *off_100BA230[3])(char) = { &sub_1002D790, &sub_1002D6A0, &sub_1002D5F0 }; // weak
char *off_100BA600[3] = { ".\\test\\tst_tsk_common.c", "$Id$", &off_100BA470 }; // weak
_UNKNOWN unk_100BA614; // weak
_UNKNOWN unk_100BACD0; // weak
_UNKNOWN unk_100BAD98; // weak
_UNKNOWN unk_100BAE00; // weak
_UNKNOWN unk_100BAE64; // weak
_UNKNOWN unk_100BBD30; // weak
__int16 word_100BBD32[] = { 82 }; // weak
char byte_100BBDAD[] = { '\x1E' }; // weak
int dword_100BC2E0[] = { 2175 }; // weak
int dword_100BCAF4[] = { 69 }; // weak
char byte_100BE3A1[] = { '\x01' }; // weak
char byte_100BE3A2[] = { '\x01' }; // weak
_UNKNOWN unk_100BE420; // weak
char byte_100BE422[] = { '\x06' }; // weak
char byte_100BE423[] = { '\xFF' }; // weak
char *off_100BE58C = "/shr_mem/iop_gma_dig_intf.shr"; // weak
_UNKNOWN unk_100BEE68; // weak
char byte_100BEE69[] = { '\x0E' }; // weak
int dword_100BF488 = 1391376; // weak
_UNKNOWN unk_100C0C48; // weak
_UNKNOWN unk_100C0CC2; // weak
_UNKNOWN unk_100C0CF0; // weak
_UNKNOWN unk_100C2AD0; // weak
__int16 word_100C2AD2[] = { 492 }; // weak
char byte_100C2AE0[] = { '@' }; // weak
char byte_100C2AE1[] = { '\x04' }; // weak
int dword_100C2B78[] = { 0 }; // weak
int dword_100C2BC0[] = { 16 }; // weak
_UNKNOWN unk_100C2C10; // weak
_UNKNOWN unk_100C2C90; // weak
_UNKNOWN unk_100C2D10; // weak
_UNKNOWN unk_100C2D88; // weak
_UNKNOWN unk_100C2E00; // weak
_UNKNOWN unk_100C3E00; // weak
__int16 word_100C442E[] = { 1 }; // weak
_UNKNOWN unk_100C4F58; // weak
_UNKNOWN unk_100C4F70; // weak
_UNKNOWN unk_100C4FB8; // weak
int dword_100C4FBC[] = { 6767 }; // weak
_UNKNOWN unk_100C4FC8; // weak
_UNKNOWN unk_100C4FE0; // weak
_UNKNOWN unk_100C4FF8; // weak
int dword_100C4FFC[] = { 6769 }; // weak
_UNKNOWN unk_100C5010; // weak
int dword_100C5014[] = { 6093 }; // weak
_UNKNOWN unk_100C5038; // weak
char off_100C8860[] = { '\\', '', '\f', '\x10' }; // idb
int dword_100C887C = 1; // idb
char byte_100C8898[] = { '\x01' }; // weak
void *off_100C889C = &unk_100A3AB8; // weak
char *off_100C88A0[2] = { "2", "fail_normal_1" }; // weak
char off_100C88A4[8] = { '0', '', '\f', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100C8928[] = { '\0' }; // weak
char byte_100C8929[] = { '\0' }; // weak
int dword_100C892C[] = { 0 }; // weak
char *off_100C8930 = "0, 0, 0"; // weak
double dbl_100C8B98[] = {  0.0 }; // weak
double dbl_100C8BA0[] = {  0.0 }; // weak
double dbl_100C8BA8[] = {  0.0 }; // weak
int dword_100C8BB0[] = { 0 }; // weak
char off_100C8BB4[32] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
float flt_100C97B8[] = {  0.0 }; // weak
float flt_100C97BC[] = {  0.0 }; // weak
float flt_100C97C0[] = {  0.0 }; // weak
int dword_100C97C4[] = { 0 }; // weak
char off_100C97C8[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_100C9F4C[3] =
{
  "..\\lib\\utf\\utf_validate.c",
  "..\\lib\\utf\\utf_validate.c",
  &off_100DEBA8
}; // weak
int dword_100C9F60[] = { 0 }; // weak
int dword_100C9F64[] = { 0 }; // weak
int dword_100C9F68[] = { 0 }; // weak
int dword_100C9F6C[] = { 0 }; // weak
char *off_100C9F70 = "0, 0, 0"; // weak
__int16 word_100CA6F8[] = { 0 }; // weak
__int16 word_100CA6FA[] = { 0 }; // weak
__int16 word_100CA6FC[] = { 0 }; // weak
int dword_100CA700[] = { 0 }; // weak
char *off_100CA704 = "0, 0, 0"; // weak
int dword_100CAD08[] = { 0 }; // weak
int dword_100CAD0C[] = { 0 }; // weak
int dword_100CAD10[] = { 0 }; // weak
int dword_100CAD14[] = { 0 }; // weak
char off_100CAD18[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100CB4A0[] = { 0 }; // weak
int dword_100CB4A4[] = { 0 }; // weak
int dword_100CB4A8[] = { 0 }; // weak
int dword_100CB4AC[] = { 0 }; // weak
int dword_100CB4B0[] = { 0 }; // weak
int dword_100CB4B4[] = { 0 }; // weak
int dword_100CB4B8[] = { 0 }; // weak
char off_100CB4BC[32] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100CC0C0[] = { '\0' }; // weak
char byte_100CC0C1[] = { '\0' }; // weak
char byte_100CC0C2[] = { '\0' }; // weak
int dword_100CC0C4[] = { 0 }; // weak
char *off_100CC0C8 = "0, 0, 0"; // weak
int dword_100CC550[] = { 0 }; // weak
int dword_100CC554[] = { 0 }; // weak
int dword_100CC558[] = { 0 }; // weak
int dword_100CC55C[] = { 0 }; // weak
char *off_100CC560 = "0, 0, 0"; // weak
int dword_100CCCE8[] = { 0 }; // weak
int dword_100CCCEC[] = { 0 }; // weak
int dword_100CCCF0[] = { 0 }; // weak
int dword_100CCCF4[] = { 0 }; // weak
char off_100CCCF8[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100CD058[] = { 0 }; // weak
__int16 word_100CD05A[] = { 0 }; // weak
__int16 word_100CD05C[] = { 0 }; // weak
int dword_100CD060[] = { 0 }; // weak
char *off_100CD064 = "0, 0, 0"; // weak
int dword_100CD318[] = { 0 }; // weak
int dword_100CD31C[] = { 0 }; // weak
int dword_100CD320[] = { 0 }; // weak
int dword_100CD324[] = { 0 }; // weak
char off_100CD328[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100CD688[] = { 0 }; // weak
int dword_100CD68C[] = { 0 }; // weak
int dword_100CD690[] = { 0 }; // weak
int dword_100CD694[] = { 0 }; // weak
int dword_100CD698[] = { 0 }; // weak
int dword_100CD69C[] = { 0 }; // weak
int dword_100CD6A0[] = { 0 }; // weak
char *off_100CD6A4 = "0, 0, 0"; // weak
char byte_100CDC08[] = { '\0' }; // weak
char byte_100CDC09[] = { '\0' }; // weak
char byte_100CDC0A[] = { '\0' }; // weak
int dword_100CDC0C[] = { 0 }; // weak
char *off_100CDC10 = "0, 0, 0"; // weak
int dword_100CDE18[] = { 0 }; // weak
int dword_100CDE1C[] = { 0 }; // weak
int dword_100CDE20[] = { 0 }; // weak
int dword_100CDE24[] = { 0 }; // weak
char off_100CDE28[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100CE188[] = { '\x01' }; // weak
void *off_100CE18C = &unk_100A3AB8; // weak
char *off_100CE190[2] = { "2", "fail_robust_1" }; // weak
char off_100CE194[8] = { '', '', '\f', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100CE218[] = { '\0' }; // weak
char byte_100CE219[] = { '\0' }; // weak
int dword_100CE21C[] = { 0 }; // weak
char *off_100CE220 = "0, 0, 0"; // weak
double dbl_100CE488[] = {  0.0 }; // weak
double dbl_100CE490[] = {  0.0 }; // weak
double dbl_100CE498[] = {  0.0 }; // weak
int dword_100CE4A0[] = { 0 }; // weak
char *off_100CE4A4 = "0, 0, 0"; // weak
float flt_100CF0A8[] = {  0.0 }; // weak
float flt_100CF0AC[] = {  0.0 }; // weak
float flt_100CF0B0[] = {  0.0 }; // weak
int dword_100CF0B4[] = { 0 }; // weak
char off_100CF0B8[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100CF840[] = { 0 }; // weak
int dword_100CF844[] = { 0 }; // weak
int dword_100CF848[] = { 0 }; // weak
int dword_100CF84C[] = { 0 }; // weak
char *off_100CF850 = "0, 0, 0"; // weak
__int16 word_100CFFD8[] = { 0 }; // weak
__int16 word_100CFFDA[] = { 0 }; // weak
__int16 word_100CFFDC[] = { 0 }; // weak
int dword_100CFFE0[] = { 0 }; // weak
char *off_100CFFE4 = "0, 0, 0"; // weak
int dword_100D05E8[] = { 0 }; // weak
int dword_100D05EC[] = { 0 }; // weak
int dword_100D05F0[] = { 0 }; // weak
int dword_100D05F4[] = { 0 }; // weak
char off_100D05F8[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100D0D80[] = { 0 }; // weak
int dword_100D0D84[] = { 0 }; // weak
int dword_100D0D88[] = { 0 }; // weak
int dword_100D0D8C[] = { 0 }; // weak
int dword_100D0D90[] = { 0 }; // weak
int dword_100D0D94[] = { 0 }; // weak
int dword_100D0D98[] = { 0 }; // weak
char off_100D0D9C[32] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100D19A0[] = { '\0' }; // weak
char byte_100D19A1[] = { '\0' }; // weak
char byte_100D19A2[] = { '\0' }; // weak
int dword_100D19A4[] = { 0 }; // weak
char *off_100D19A8 = "0, 0, 0"; // weak
int dword_100D1E30[] = { 0 }; // weak
int dword_100D1E34[] = { 0 }; // weak
int dword_100D1E38[] = { 0 }; // weak
int dword_100D1E3C[] = { 0 }; // weak
char *off_100D1E40 = "0, 0, 0"; // weak
int dword_100D25C8[] = { 0 }; // weak
int dword_100D25CC[] = { 0 }; // weak
int dword_100D25D0[] = { 0 }; // weak
int dword_100D25D4[] = { 0 }; // weak
char off_100D25D8[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100D2938[] = { 0 }; // weak
__int16 word_100D293A[] = { 0 }; // weak
__int16 word_100D293C[] = { 0 }; // weak
int dword_100D2940[] = { 0 }; // weak
char *off_100D2944 = "0, 0, 0"; // weak
int dword_100D2BF8[] = { 0 }; // weak
int dword_100D2BFC[] = { 0 }; // weak
int dword_100D2C00[] = { 0 }; // weak
int dword_100D2C04[] = { 0 }; // weak
char off_100D2C08[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100D2F68[] = { 0 }; // weak
int dword_100D2F6C[] = { 0 }; // weak
int dword_100D2F70[] = { 0 }; // weak
int dword_100D2F74[] = { 0 }; // weak
int dword_100D2F78[] = { 0 }; // weak
int dword_100D2F7C[] = { 0 }; // weak
int dword_100D2F80[] = { 0 }; // weak
char *off_100D2F84 = "0, 0, 0"; // weak
char byte_100D34E8[] = { '\0' }; // weak
char byte_100D34E9[] = { '\0' }; // weak
char byte_100D34EA[] = { '\0' }; // weak
int dword_100D34EC[] = { 0 }; // weak
char *off_100D34F0 = "0, 0, 0"; // weak
int dword_100D36F8[] = { 0 }; // weak
int dword_100D36FC[] = { 0 }; // weak
int dword_100D3700[] = { 0 }; // weak
int dword_100D3704[] = { 0 }; // weak
char off_100D3708[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100D3A68[] = { '\x01' }; // weak
void *off_100D3A6C = &unk_100A3AB8; // weak
void *off_100D3A70 = &unk_100A3AB8; // weak
char off_100D3A74[8] = { '\x18', '', '\f', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100D3AB8[] = { '\0' }; // weak
char byte_100D3AB9[] = { '\0' }; // weak
int dword_100D3ABC[] = { 0 }; // weak
char *off_100D3AC0 = "0, 0, 0"; // weak
double dbl_100D3D28[] = {  0.0 }; // weak
double dbl_100D3D30[] = {  0.0 }; // weak
double dbl_100D3D38[] = {  0.0 }; // weak
int dword_100D3D40[] = { 0 }; // weak
char *off_100D3D44 = "0, 0, 0"; // weak
float flt_100D4948[] = {  0.0 }; // weak
float flt_100D494C[] = {  0.0 }; // weak
float flt_100D4950[] = {  0.0 }; // weak
int dword_100D4954[] = { 0 }; // weak
char off_100D4958[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100D50E0[] = { 0 }; // weak
int dword_100D50E4[] = { 0 }; // weak
int dword_100D50E8[] = { 0 }; // weak
int dword_100D50EC[] = { 0 }; // weak
char *off_100D50F0 = "0, 0, 0"; // weak
__int16 word_100D5878[] = { 0 }; // weak
__int16 word_100D587A[] = { 0 }; // weak
__int16 word_100D587C[] = { 0 }; // weak
int dword_100D5880[] = { 0 }; // weak
char *off_100D5884 = "0, 0, 0"; // weak
int dword_100D5E88[] = { 0 }; // weak
int dword_100D5E8C[] = { 0 }; // weak
int dword_100D5E90[] = { 0 }; // weak
int dword_100D5E94[] = { 0 }; // weak
char off_100D5E98[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100D6620[] = { 0 }; // weak
int dword_100D6624[] = { 0 }; // weak
int dword_100D6628[] = { 0 }; // weak
int dword_100D662C[] = { 0 }; // weak
int dword_100D6630[] = { 0 }; // weak
int dword_100D6634[] = { 0 }; // weak
int dword_100D6638[] = { 0 }; // weak
char off_100D663C[32] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100D7240[] = { '\0' }; // weak
char byte_100D7241[] = { '\0' }; // weak
char byte_100D7242[] = { '\0' }; // weak
int dword_100D7244[] = { 0 }; // weak
char *off_100D7248 = "0, 0, 0"; // weak
int dword_100D76D0[] = { 0 }; // weak
int dword_100D76D4[] = { 0 }; // weak
int dword_100D76D8[] = { 0 }; // weak
int dword_100D76DC[] = { 0 }; // weak
char *off_100D76E0 = "0, 0, 0"; // weak
int dword_100D7E68[] = { 0 }; // weak
int dword_100D7E6C[] = { 0 }; // weak
int dword_100D7E70[] = { 0 }; // weak
int dword_100D7E74[] = { 0 }; // weak
char off_100D7E78[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100D81D8[] = { 0 }; // weak
__int16 word_100D81DA[] = { 0 }; // weak
__int16 word_100D81DC[] = { 0 }; // weak
int dword_100D81E0[] = { 0 }; // weak
char *off_100D81E4 = "0, 0, 0"; // weak
int dword_100D8498[] = { 0 }; // weak
int dword_100D849C[] = { 0 }; // weak
int dword_100D84A0[] = { 0 }; // weak
int dword_100D84A4[] = { 0 }; // weak
char off_100D84A8[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100D8808[] = { 0 }; // weak
int dword_100D880C[] = { 0 }; // weak
int dword_100D8810[] = { 0 }; // weak
int dword_100D8814[] = { 0 }; // weak
int dword_100D8818[] = { 0 }; // weak
int dword_100D881C[] = { 0 }; // weak
int dword_100D8820[] = { 0 }; // weak
char *off_100D8824 = "0, 0, 0"; // weak
char byte_100D8D88[] = { '\0' }; // weak
char byte_100D8D89[] = { '\0' }; // weak
char byte_100D8D8A[] = { '\0' }; // weak
int dword_100D8D8C[] = { 0 }; // weak
char *off_100D8D90 = "0, 0, 0"; // weak
int dword_100D8F98[] = { 0 }; // weak
int dword_100D8F9C[] = { 0 }; // weak
int dword_100D8FA0[] = { 0 }; // weak
int dword_100D8FA4[] = { 0 }; // weak
char off_100D8FA8[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100D9308[] = { '\x01' }; // weak
void *off_100D930C = &unk_100A3AB8; // weak
void *off_100D9310 = &unk_100A3AB8; // weak
char off_100D9314[8] = { '', '', '\f', '\x10', '\x01', '\0', '\0', '\0' }; // idb
char byte_100D9358[] = { '\0' }; // weak
char byte_100D9359[] = { '\0' }; // weak
int dword_100D935C[] = { 0 }; // weak
char *off_100D9360 = "0, 0, 0"; // weak
double dbl_100D95C8[] = {  0.0 }; // weak
double dbl_100D95D0[] = {  0.0 }; // weak
double dbl_100D95D8[] = {  0.0 }; // weak
int dword_100D95E0[] = { 0 }; // weak
char *off_100D95E4 = "0, 0, 0"; // weak
float flt_100DA1E8[] = {  0.0 }; // weak
float flt_100DA1EC[] = {  0.0 }; // weak
float flt_100DA1F0[] = {  0.0 }; // weak
int dword_100DA1F4[] = { 0 }; // weak
char off_100DA1F8[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100DA980[] = { 0 }; // weak
int dword_100DA984[] = { 0 }; // weak
int dword_100DA988[] = { 0 }; // weak
int dword_100DA98C[] = { 0 }; // weak
char *off_100DA990 = "0, 0, 0"; // weak
__int16 word_100DB118[] = { 0 }; // weak
__int16 word_100DB11A[] = { 0 }; // weak
__int16 word_100DB11C[] = { 0 }; // weak
int dword_100DB120[] = { 0 }; // weak
char *off_100DB124 = "0, 0, 0"; // weak
int dword_100DB728[] = { 0 }; // weak
int dword_100DB72C[] = { 0 }; // weak
int dword_100DB730[] = { 0 }; // weak
int dword_100DB734[] = { 0 }; // weak
char off_100DB738[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100DBEC0[] = { 0 }; // weak
int dword_100DBEC4[] = { 0 }; // weak
int dword_100DBEC8[] = { 0 }; // weak
int dword_100DBECC[] = { 0 }; // weak
int dword_100DBED0[] = { 0 }; // weak
int dword_100DBED4[] = { 0 }; // weak
int dword_100DBED8[] = { 0 }; // weak
char off_100DBEDC[32] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_100DCAE0[] = { '\0' }; // weak
char byte_100DCAE1[] = { '\0' }; // weak
char byte_100DCAE2[] = { '\0' }; // weak
int dword_100DCAE4[] = { 0 }; // weak
char *off_100DCAE8 = "0, 0, 0"; // weak
int dword_100DCF70[] = { 0 }; // weak
int dword_100DCF74[] = { 0 }; // weak
int dword_100DCF78[] = { 0 }; // weak
int dword_100DCF7C[] = { 0 }; // weak
char *off_100DCF80 = "0, 0, 0"; // weak
int dword_100DD708[] = { 0 }; // weak
int dword_100DD70C[] = { 0 }; // weak
int dword_100DD710[] = { 0 }; // weak
int dword_100DD714[] = { 0 }; // weak
char off_100DD718[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
__int16 word_100DDA78[] = { 0 }; // weak
__int16 word_100DDA7A[] = { 0 }; // weak
__int16 word_100DDA7C[] = { 0 }; // weak
int dword_100DDA80[] = { 0 }; // weak
char *off_100DDA84 = "0, 0, 0"; // weak
int dword_100DDD38[] = { 0 }; // weak
int dword_100DDD3C[] = { 0 }; // weak
int dword_100DDD40[] = { 0 }; // weak
int dword_100DDD44[] = { 0 }; // weak
char off_100DDD48[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_100DE0A8[] = { 0 }; // weak
int dword_100DE0AC[] = { 0 }; // weak
int dword_100DE0B0[] = { 0 }; // weak
int dword_100DE0B4[] = { 0 }; // weak
int dword_100DE0B8[] = { 0 }; // weak
int dword_100DE0BC[] = { 0 }; // weak
int dword_100DE0C0[] = { 0 }; // weak
char *off_100DE0C4 = "0, 0, 0"; // weak
char byte_100DE628[] = { '\0' }; // weak
char byte_100DE629[] = { '\0' }; // weak
char byte_100DE62A[] = { '\0' }; // weak
int dword_100DE62C[] = { 0 }; // weak
char *off_100DE630 = "0, 0, 0"; // weak
int dword_100DE838[] = { 0 }; // weak
int dword_100DE83C[] = { 0 }; // weak
int dword_100DE840[] = { 0 }; // weak
int dword_100DE844[] = { 0 }; // weak
char off_100DE848[20] =
{
  '',
  '',
  '\f',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_100DF828; // weak
char a006D0170[11] = "006-D0170-"; // weak
char *off_100E2AE4 = "006-D0170-"; // weak
int (__cdecl *(*off_100E2AE8)[2])(int, int) = &off_1011C11C; // weak
_UNKNOWN unk_100E3894; // weak
_UNKNOWN unk_100E39E0; // weak
_UNKNOWN unk_100E39E4; // weak
wchar_t a___0[8] = L":;<=>?@"; // weak
wchar_t aAbcde_0[6] = L"ABCDE"; // weak
_UNKNOWN unk_100E4EA8; // weak
char byte_100E4EAC[] = { '\0' }; // weak
_UNKNOWN unk_100F700A; // weak
int dword_100F700C = 9429; // idb
int dword_100F7D04[] = { 9826 }; // weak
_UNKNOWN unk_100F7D08; // weak
_UNKNOWN unk_100F7E80; // weak
__int16 word_100F7E82[] = { 301 }; // weak
__int16 word_100F7E84[] = { 302 }; // weak
__int16 word_100F7E86[] = { 303 }; // weak
__int16 word_100F7E88[] = { 304 }; // weak
__int16 word_100F7E8A[] = { 305 }; // weak
__int16 word_100F7E8C[] = { 306 }; // weak
__int16 word_100F7E8E[] = { 307 }; // weak
_UNKNOWN unk_100FB2F8; // weak
void *off_100FB2FC = &unk_100FB070; // weak
char byte_100FB4A0[] = { '7' }; // weak
int dword_100FB4A4[] = { 6829 }; // weak
int dword_100FC318 = 64; // weak
__int16 word_100FC31C[] = { 6782 }; // weak
__int16 word_100FC320[] = { 128 }; // weak
_UNKNOWN unk_100FC33C; // weak
_DWORD dword_100FC340[4] = { 64, 24, 62, 18 }; // idb
_UNKNOWN unk_100FC354; // weak
__int16 word_100FC356[] = { 420 }; // weak
int dword_100FC364[] = { 0 }; // weak
__int16 word_100FD750[] = { 1565 }; // weak
__int16 word_100FD754[] = { 534 }; // weak
char byte_100FD758[] = { '\x04' }; // weak
__int16 word_100FD75A[] = { 6512 }; // weak
int dword_100FD770[] = { 118000 }; // weak
__int16 word_100FE29A[] = { 233 }; // weak
int dword_100FE2A0[] = { 6201 }; // weak
__int16 word_100FF150[] = { 114 }; // weak
_UNKNOWN unk_100FF988; // weak
int dword_100FF98C[] = { 6006 }; // weak
char *off_10100838 = "/shr_mem/iop_gtx_intf.shr"; // weak
__int16 word_10100958[] = { 551 }; // weak
__int16 word_10102714[] = { 464 }; // weak
__int16 word_10102760[] = { 241 }; // weak
_UNKNOWN unk_10102F20; // weak
char *off_101030C4[3] = { "***global-commands***", "..\\lib\\utf\\utf_runner.c", &off_101030D8 }; // weak
char *off_10103268 = "true"; // weak
char byte_1010326C[] = { '\x01' }; // weak
char *off_101032D0 = "failure listener"; // weak
_UNKNOWN unk_10103A58; // weak
char *off_10103C08[5] = { "FAIL", "PASS", "normal", "robust", "EQ" }; // weak
char *off_10103C10[3] = { "normal", "robust", "EQ" }; // weak
char *off_10103C18 = "EQ"; // weak
char *off_10103C34[7] =
{
  "Low Level Testing",
  "Software Integration Testing",
  "Hardware/Software Integration Testing",
  "FALSE",
  "TRUE",
  "?INVALID-BOOL?",
  "*INVALID-BOOL*"
}; // weak
char *off_10103C40[4] = { "FALSE", "TRUE", "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
char *off_10103C48[2] = { "?INVALID-BOOL?", "*INVALID-BOOL*" }; // weak
_UNKNOWN unk_10103F00; // weak
_UNKNOWN unk_10103F44; // weak
char *off_101042F8 = "printf_listener"; // weak
char *off_10105088 = "gate_listener"; // weak
_UNKNOWN unk_101060B8; // weak
__int16 word_101060BA[] = { 565 }; // weak
_UNKNOWN unk_101068D0; // weak
_UNKNOWN unk_101068D4; // weak
_UNKNOWN unk_101068D8; // weak
_UNKNOWN unk_101068DC; // weak
_UNKNOWN unk_101068E0; // weak
_UNKNOWN unk_101068E4; // weak
_UNKNOWN unk_10106F98; // weak
void *off_10106F9C = &unk_101068D0; // weak
_UNKNOWN unk_10107048; // weak
void *off_1010704C = &unk_101068D0; // weak
void *off_10107058 = &unk_101068D4; // weak
void *off_10107064 = &unk_101068D8; // weak
void *off_10107070 = &unk_101068DC; // weak
void *off_1010707C = &unk_101068E0; // weak
void *off_10107508 = &unk_10106940; // weak
void *off_10107514 = &unk_1010690C; // weak
void *off_10107520 = &unk_1010698C; // weak
void *off_1010752C = &unk_101069C0; // weak
void *off_10107538 = &unk_10106A90; // weak
void *off_10107544 = &unk_10106A7C; // weak
void *off_10107550 = &unk_10106B6C; // weak
void *off_1010755C = &unk_10106B90; // weak
void *off_10107568 = &unk_10106BB4; // weak
void *off_10107574 = &unk_10106BD8; // weak
void *off_10107580 = &unk_101068E0; // weak
void *off_10107598 = &unk_101068D0; // weak
void *off_101075A4 = &unk_101068D4; // weak
void *off_101075B0 = &unk_10106EE4; // weak
void *off_101075BC = &unk_101068DC; // weak
void *off_101075C8 = &unk_101068E0; // weak
void *off_101075D4 = &unk_101068E4; // weak
void *off_101075E0 = &unk_101068D0; // weak
void *off_101075EC = &unk_10106EF0; // weak
void *off_101075F8 = &unk_101068D8; // weak
void *off_10107604 = &unk_101068DC; // weak
void *off_10107610 = &unk_101068E0; // weak
void *off_1010761C = &unk_101068E4; // weak
_UNKNOWN unk_10107628; // weak
void *off_1010762C = &unk_101068D4; // weak
void *off_10107638 = &unk_10106B5C; // weak
_UNKNOWN unk_101078EC; // weak
_UNKNOWN unk_101078F0; // weak
_UNKNOWN unk_101078F4; // weak
_UNKNOWN unk_101078FC; // weak
_UNKNOWN unk_10107900; // weak
_UNKNOWN unk_101079A8; // weak
_UNKNOWN unk_101079B8; // weak
_UNKNOWN unk_10107AAC; // weak
_UNKNOWN unk_10107AE8; // weak
_UNKNOWN unk_10107AEC; // weak
_UNKNOWN unk_10107AF0; // weak
_UNKNOWN unk_10107B44; // weak
_UNKNOWN unk_10107B68; // weak
void *off_1010BD4C = &unk_1010B658; // weak
void *off_1010BD54 = &unk_1010B65C; // weak
void *off_1010BD5C = &unk_1010B660; // weak
void *off_1010BD64 = &unk_1010B664; // weak
void *off_1010BD6C = &unk_1010B668; // weak
void *off_1010C610 = &unk_1010B658; // weak
void *off_1010C618 = &unk_1010B65C; // weak
void *off_1010C620 = &unk_1010B660; // weak
void *off_1010C628 = &unk_1010B664; // weak
void *off_1010C630 = &unk_1010B668; // weak
void *off_1010C7A0 = &unk_1010B658; // weak
void *off_1010C7A8 = &unk_1010B65C; // weak
void *off_1010C7B0 = &unk_1010B660; // weak
void *off_1010C7B8 = &unk_1010B664; // weak
void *off_1010C7C0 = &unk_1010B668; // weak
void *off_1010C840 = &unk_1010B658; // weak
void *off_1010C848 = &unk_1010B65C; // weak
void *off_1010C850 = &unk_1010B660; // weak
void *off_1010C858 = &unk_1010B664; // weak
void *off_1010C860 = &unk_1010B668; // weak
void *off_1010C9FC = &unk_1010B658; // weak
void *off_1010CA04 = &unk_1010B65C; // weak
void *off_1010CA0C = &unk_1010B660; // weak
void *off_1010CA14 = &unk_1010B664; // weak
void *off_1010CA1C = &unk_1010B668; // weak
void *off_1010CB58 = &unk_1010B658; // weak
void *off_1010CB60 = &unk_1010B65C; // weak
void *off_1010CB68 = &unk_1010B660; // weak
void *off_1010CB70 = &unk_1010B664; // weak
void *off_1010CB78 = &unk_1010B668; // weak
void *off_1010CBD0 = &unk_1010B658; // weak
void *off_1010CBD8 = &unk_1010B65C; // weak
void *off_1010CBE0 = &unk_10108438; // weak
void *off_1010CBE8 = &unk_1010B664; // weak
void *off_1010CBF0 = &unk_1010B668; // weak
void *off_1010CBF8 = &unk_1010AD10; // weak
void *off_1010CC00 = &unk_1010B65C; // weak
void *off_1010CC08 = &unk_1010AD20; // weak
void *off_1010CC10 = &unk_1010B664; // weak
void *off_1010CC18 = &unk_1010B668; // weak
void *off_1010CC20 = &unk_1010A8C0; // weak
void *off_1010CC28 = &unk_1010A9E0; // weak
void *off_1010CC30 = &unk_1010AAD8; // weak
void *off_1010CC38 = &unk_1010AB58; // weak
void *off_1010CC40 = &unk_1010AC7C; // weak
void *off_1010CC4C = &unk_1010B658; // weak
void *off_1010CC54 = &unk_1010B65C; // weak
void *off_1010CC5C = &unk_1010B660; // weak
void *off_1010CC64 = &unk_1010B664; // weak
void *off_1010CC6C = &unk_1010B668; // weak
void *off_1010D4BC = &unk_1010B658; // weak
void *off_1010D4C4 = &unk_1010B65C; // weak
void *off_1010D4CC = &unk_1010B660; // weak
void *off_1010D4D4 = &unk_1010B664; // weak
void *off_1010D4DC = &unk_1010B668; // weak
void *off_1010D9DC = &unk_1010B658; // weak
void *off_1010D9E4 = &unk_1010B9D4; // weak
void *off_1010D9EC = &unk_1010B660; // weak
void *off_1010D9F4 = &unk_1010B664; // weak
void *off_1010D9FC = &unk_1010B668; // weak
void *off_1010DA04 = &unk_1010BA24; // weak
void *off_1010DA0C = &unk_1010BA34; // weak
void *off_1010DA14 = &unk_1010BA6C; // weak
void *off_1010DA1C = &unk_1010B664; // weak
void *off_1010DA24 = &unk_1010B668; // weak
void *off_1010DA2C = &unk_1010B658; // weak
void *off_1010DA54 = &unk_1010B658; // weak
char byte_1010DB00[] = { '\x01' }; // weak
__int16 word_1010DB02[] = { 3020 }; // weak
_UNKNOWN unk_1010E280; // weak
_UNKNOWN unk_1010E284; // weak
_UNKNOWN unk_1010E288; // weak
_UNKNOWN unk_1010E310; // weak
_UNKNOWN unk_1010E384; // weak
void *off_1010E464 = &unk_1010E3BC; // weak
void *off_1010E46C = &unk_1010E3C0; // weak
void *off_1010E474 = &unk_1010E428; // weak
void *off_1010E47C = &unk_1010E42C; // weak
void *off_1010E484 = &unk_1010E45C; // weak
int dword_1010E48C[] = { 67108864 }; // weak
void *off_10110898 = &unk_10110884; // weak
void *off_101108A4 = &unk_1010F948; // weak
void *off_101108B0 = &unk_1010F9C8; // weak
void *off_101108BC = &unk_1010FA28; // weak
void *off_101108C8 = &unk_1010F934; // weak
void *off_101108D4 = &unk_10110884; // weak
void *off_10110914 = &unk_10110884; // weak
void *off_10110920 = &unk_10110888; // weak
void *off_1011092C = &unk_1011088C; // weak
void *off_10110938 = &unk_10110890; // weak
void *off_10110944 = &unk_10110894; // weak
void *off_101111D4 = &unk_10110884; // weak
void *off_101111E0 = &unk_10110888; // weak
void *off_101111EC = &unk_1011088C; // weak
void *off_101111F8 = &unk_10110890; // weak
void *off_10111204 = &unk_10110894; // weak
_UNKNOWN unk_10111A40; // weak
_UNKNOWN unk_10111A44; // weak
_UNKNOWN unk_10111A48; // weak
_UNKNOWN unk_10111A4C; // weak
_UNKNOWN unk_10111A50; // weak
_UNKNOWN unk_10111A54; // weak
_UNKNOWN unk_10111A58; // weak
_UNKNOWN unk_10111A84; // weak
_UNKNOWN unk_10111AA8; // weak
_UNKNOWN unk_10111AD8; // weak
_UNKNOWN unk_10111B50; // weak
_UNKNOWN unk_10111C48; // weak
_UNKNOWN unk_10111C54; // weak
_UNKNOWN unk_10111C68; // weak
void *off_10111C78 = &unk_10111ACC; // weak
void *off_10111C88 = &unk_10111BB8; // weak
void *off_10111C98 = &unk_10111BE8; // weak
void *off_10111CA8 = &unk_10111C18; // weak
void *off_10111CB8 = &unk_10111A50; // weak
void *off_10111CC8 = &unk_10111A54; // weak
_UNKNOWN unk_10111CD8; // weak
_UNKNOWN unk_10111CDC; // weak
_UNKNOWN unk_10111D10; // weak
_UNKNOWN unk_10111D40; // weak
_UNKNOWN unk_10111D80; // weak
_UNKNOWN unk_10111DA8; // weak
_UNKNOWN unk_10111DAC; // weak
_UNKNOWN unk_10111DC8; // weak
_UNKNOWN unk_10111E0C; // weak
_UNKNOWN unk_10111E20; // weak
char byte_10116132[] = { '\x04' }; // weak
char byte_10116137[] = { '\a' }; // weak
_WORD dword_10116970[512] =
{
  25542,
  42339,
  31992,
  33916,
  30702,
  39287,
  31734,
  36219,
  62207,
  3570,
  27606,
  48491,
  28638,
  45423,
  50577,
  21701,
  12384,
  20528,
  258,
  769,
  26574,
  43367,
  11094,
  32043,
  65255,
  6654,
  55221,
  25303,
  43853,
  59051,
  30444,
  39542,
  51855,
  17866,
  33311,
  40322,
  51593,
  16585,
  32250,
  34685,
  64239,
  5626,
  22962,
  60249,
  18318,
  51527,
  61691,
  3056,
  44353,
  60589,
  54451,
  26580,
  41567,
  64930,
  44869,
  60079,
  39971,
  49052,
  42067,
  63396,
  29412,
  38514,
  49307,
  23488,
  46965,
  49847,
  64993,
  7421,
  37693,
  44691,
  9804,
  27174,
  13932,
  23094,
  16254,
  16703,
  63477,
  759,
  52355,
  20428,
  13416,
  23604,
  42321,
  62629,
  58833,
  13541,
  61945,
  2289,
  29154,
  37745,
  55467,
  29656,
  12642,
  21297,
  5418,
  16149,
  1032,
  3076,
  51093,
  21191,
  9030,
  25891,
  50077,
  24259,
  6192,
  10264,
  38455,
  41366,
  1290,
  3845,
  39471,
  46490,
  1806,
  2311,
  4644,
  13842,
  32795,
  39808,
  58079,
  15842,
  60365,
  9963,
  10062,
  26919,
  45695,
  52658,
  30186,
  40821,
  2322,
  6921,
  33565,
  40579,
  11352,
  29740,
  6708,
  11802,
  6966,
  11547,
  28380,
  45678,
  23220,
  61018,
  41051,
  64416,
  21156,
  63058,
  15222,
  19771,
  54967,
  25046,
  45949,
  52915,
  10578,
  31529,
  58333,
  16099,
  12126,
  28975,
  33811,
  38788,
  21414,
  62803,
  53689,
  26833,
  0,
  0,
  60865,
  11501,
  8256,
  24608,
  64739,
  8188,
  45433,
  51377,
  23478,
  60763,
  27348,
  48746,
  52109,
  18123,
  48743,
  55742,
  14706,
  19257,
  19092,
  56906,
  19608,
  54348,
  22704,
  59480,
  53125,
  19151,
  53435,
  27600,
  61381,
  10991,
  43599,
  58794,
  64493,
  5883,
  17286,
  50499,
  19866,
  55117,
  13158,
  21811,
  34065,
  38021,
  17802,
  53061,
  63977,
  4345,
  516,
  1538,
  32766,
  33151,
  20640,
  61520,
  15480,
  17468,
  40741,
  47775,
  43083,
  58280,
  20898,
  62289,
  41821,
  65187,
  16512,
  49216,
  36613,
  35471,
  37439,
  44434,
  40225,
  48285,
  14448,
  18488,
  62961,
  1269,
  48227,
  57276,
  46711,
  49590,
  55983,
  30170,
  8514,
  25377,
  4128,
  12304,
  65509,
  6911,
  62461,
  3827,
  53951,
  28114,
  52609,
  19661,
  3096,
  5132,
  4902,
  13587,
  60611,
  12268,
  24510,
  57695,
  38709,
  41623,
  17544,
  52292,
  5934,
  14615,
  50323,
  22468,
  42837,
  62119,
  32508,
  33406,
  15738,
  18237,
  25800,
  44132,
  23994,
  59229,
  6450,
  11033,
  29670,
  38259,
  24768,
  41056,
  33049,
  39041,
  20382,
  53583,
  56483,
  32732,
  8772,
  26146,
  10836,
  32298,
  36923,
  43920,
  34827,
  33672,
  18060,
  51782,
  61127,
  10734,
  47211,
  54200,
  5160,
  15380,
  56999,
  31198,
  24252,
  57950,
  2838,
  7435,
  56237,
  30427,
  57563,
  15328,
  12900,
  22066,
  14964,
  20026,
  2580,
  7690,
  18834,
  56137,
  1548,
  2566,
  9288,
  27684,
  23736,
  58460,
  49823,
  24002,
  54205,
  28371,
  44099,
  61356,
  25284,
  42594,
  37177,
  43153,
  38193,
  42133,
  58579,
  14308,
  31218,
  35705,
  59349,
  13031,
  51339,
  17352,
  14190,
  22839,
  28122,
  46957,
  36097,
  35981,
  54705,
  25813,
  20124,
  53838,
  43337,
  57513,
  27864,
  46188,
  22188,
  64086,
  62707,
  2036,
  60111,
  9706,
  26058,
  44901,
  31476,
  36474,
  44615,
  59822,
  2064,
  6152,
  47727,
  54714,
  30960,
  34936,
  9546,
  28453,
  11868,
  29230,
  7224,
  9244,
  42583,
  61862,
  46195,
  51124,
  50839,
  20934,
  59595,
  9192,
  56737,
  31965,
  29928,
  40052,
  7998,
  8479,
  19350,
  56651,
  48481,
  56509,
  35597,
  34443,
  35343,
  34186,
  28896,
  36976,
  15996,
  16958,
  46449,
  50357,
  26316,
  43622,
  18576,
  55368,
  774,
  1283,
  63223,
  502,
  3612,
  4622,
  25026,
  41825,
  13674,
  24373,
  22446,
  63831,
  47465,
  53433,
  34327,
  37254,
  49561,
  22721,
  7482,
  10013,
  40487,
  47518,
  57817,
  14561,
  63723,
  5112,
  38955,
  45976,
  4386,
  13073,
  27090,
  47977,
  55721,
  28889,
  36359,
  35214,
  37939,
  42900,
  39725,
  46747,
  7740,
  8734,
  34581,
  37511,
  59849,
  8425,
  52871,
  18894,
  21930,
  65365,
  10320,
  30760,
  57253,
  31455,
  35843,
  36748,
  41305,
  63649,
  35081,
  32905,
  3354,
  5901,
  48997,
  55999,
  59095,
  12774,
  17028,
  50754,
  26832,
  47208,
  16770,
  49985,
  39209,
  45209,
  11610,
  30509,
  3870,
  4367,
  45179,
  52144,
  21672,
  64596,
  47981,
  54971,
  5676,
  14870
}; // idb
_WORD dword_10116D70[512] =
{
  50853,
  25443,
  63620,
  31868,
  61081,
  30583,
  63117,
  31611,
  65293,
  62194,
  54973,
  27499,
  57009,
  28527,
  37204,
  50629,
  24656,
  12336,
  515,
  257,
  52905,
  26471,
  22141,
  11051,
  59161,
  65278,
  46434,
  55255,
  19942,
  43947,
  60570,
  30326,
  36677,
  51914,
  8093,
  33410,
  35136,
  51657,
  64135,
  32125,
  61205,
  64250,
  45803,
  22873,
  36553,
  18247,
  64267,
  61680,
  16876,
  44461,
  45927,
  54484,
  24573,
  41634,
  17898,
  44975,
  9151,
  40092,
  21495,
  42148,
  58518,
  29298,
  39771,
  49344,
  30146,
  47031,
  57628,
  65021,
  15790,
  37779,
  19562,
  9766,
  27738,
  13878,
  32321,
  16191,
  62722,
  63479,
  33615,
  52428,
  26716,
  13364,
  20980,
  42405,
  53556,
  58853,
  63752,
  61937,
  58003,
  29041,
  43891,
  55512,
  25171,
  12593,
  10815,
  5397,
  2060,
  1028,
  38226,
  51143,
  18021,
  8995,
  40286,
  50115,
  12328,
  6168,
  14241,
  38550,
  2575,
  1285,
  12213,
  39578,
  3593,
  1799,
  9270,
  4626,
  7067,
  32896,
  57149,
  58082,
  52518,
  60395,
  20073,
  10023,
  32717,
  45746,
  60063,
  30069,
  4635,
  2313,
  7582,
  33667,
  22644,
  11308,
  13358,
  6682,
  13869,
  6939,
  56498,
  28270,
  46318,
  23130,
  23547,
  41120,
  42230,
  21074,
  30285,
  15163,
  46945,
  54998,
  32206,
  46003,
  21115,
  10537,
  56638,
  58339,
  24177,
  12079,
  5015,
  33924,
  42741,
  21331,
  47464,
  53713,
  0,
  0,
  49452,
  60909,
  16480,
  8224,
  58143,
  64764,
  31176,
  45489,
  46829,
  23387,
  54462,
  27242,
  36166,
  52171,
  26585,
  48830,
  29259,
  14649,
  38110,
  19018,
  39124,
  19532,
  45288,
  22616,
  34122,
  53199,
  47979,
  53456,
  50474,
  61423,
  20453,
  43690,
  60694,
  64507,
  34501,
  17219,
  39639,
  19789,
  26197,
  13107,
  4500,
  34181,
  35535,
  17733,
  59664,
  63993,
  1030,
  514,
  65153,
  32639,
  41200,
  20560,
  30788,
  15420,
  9658,
  40863,
  19427,
  43176,
  41715,
  20817,
  24062,
  41891,
  32960,
  16448,
  1418,
  36751,
  16301,
  37522,
  8636,
  40349,
  28744,
  14392,
  61700,
  62965,
  25567,
  48316,
  30657,
  46774,
  44917,
  56026,
  16995,
  8481,
  8240,
  4112,
  58650,
  65535,
  64782,
  62451,
  49005,
  53970,
  33100,
  52685,
  6164,
  3084,
  9781,
  4883,
  49967,
  60652,
  48865,
  24415,
  13730,
  38807,
  35020,
  17476,
  11833,
  5911,
  37719,
  50372,
  22002,
  42919,
  64642,
  32382,
  31303,
  15677,
  51372,
  25700,
  47847,
  23901,
  12843,
  6425,
  59029,
  29555,
  49312,
  24672,
  6552,
  33153,
  40657,
  20303,
  41855,
  56540,
  17510,
  8738,
  21630,
  10794,
  15275,
  37008,
  2947,
  34952,
  36042,
  17990,
  50985,
  61166,
  27603,
  47288,
  10300,
  5140,
  42873,
  57054,
  48354,
  24158,
  5661,
  2827,
  44406,
  56283,
  56123,
  57568,
  25686,
  12850,
  29774,
  14906,
  5150,
  2570,
  37595,
  18761,
  3082,
  1542,
  18540,
  9252,
  47332,
  23644,
  40797,
  49858,
  48494,
  54227,
  17391,
  44204,
  50342,
  25186,
  14760,
  37265,
  12708,
  38293,
  54071,
  58596,
  62091,
  31097,
  54578,
  59367,
  35651,
  51400,
  28249,
  14135,
  55991,
  28013,
  396,
  36237,
  45412,
  54741,
  40146,
  20046,
  18912,
  43433,
  55476,
  27756,
  44282,
  22102,
  62215,
  62708,
  53029,
  60138,
  51887,
  25957,
  62606,
  31354,
  18409,
  44718,
  4120,
  2056,
  28629,
  47802,
  61576,
  30840,
  19055,
  9509,
  23666,
  11822,
  14372,
  7196,
  22513,
  42662,
  29639,
  46260,
  38737,
  50886,
  52003,
  59624,
  41340,
  56797,
  59548,
  29812,
  15905,
  7967,
  38621,
  19275,
  25052,
  48573,
  3462,
  35723,
  3973,
  35466,
  57488,
  28784,
  31810,
  15934,
  29124,
  46517,
  52394,
  26214,
  37080,
  18504,
  1541,
  771,
  63233,
  63222,
  7186,
  3598,
  49827,
  24929,
  27231,
  13621,
  44793,
  22359,
  27088,
  47545,
  6033,
  34438,
  39256,
  49601,
  14887,
  7453,
  10169,
  40606,
  55608,
  57825,
  60179,
  63736,
  11187,
  39064,
  8755,
  4369,
  53947,
  26985,
  43376,
  55769,
  1929,
  36494,
  13223,
  38036,
  11702,
  39835,
  15394,
  7710,
  5522,
  34695,
  51488,
  59881,
  34633,
  52942,
  43775,
  21845,
  20600,
  10280,
  42362,
  57311,
  911,
  35980,
  23032,
  41377,
  2432,
  35209,
  6679,
  3341,
  26074,
  49087,
  55089,
  59110,
  33990,
  16962,
  53432,
  26728,
  33475,
  16705,
  10672,
  39321,
  23159,
  11565,
  7697,
  3855,
  31691,
  45232,
  43260,
  21588,
  28118,
  48059,
  11322,
  5654
}; // idb
_WORD dword_10117170[512] =
{
  42339,
  25542,
  33916,
  31992,
  39287,
  30702,
  36219,
  31734,
  3570,
  62207,
  48491,
  27606,
  45423,
  28638,
  21701,
  50577,
  20528,
  12384,
  769,
  258,
  43367,
  26574,
  32043,
  11094,
  6654,
  65255,
  25303,
  55221,
  59051,
  43853,
  39542,
  30444,
  17866,
  51855,
  40322,
  33311,
  16585,
  51593,
  34685,
  32250,
  5626,
  64239,
  60249,
  22962,
  51527,
  18318,
  3056,
  61691,
  60589,
  44353,
  26580,
  54451,
  64930,
  41567,
  60079,
  44869,
  49052,
  39971,
  63396,
  42067,
  38514,
  29412,
  23488,
  49307,
  49847,
  46965,
  7421,
  64993,
  44691,
  37693,
  27174,
  9804,
  23094,
  13932,
  16703,
  16254,
  759,
  63477,
  20428,
  52355,
  23604,
  13416,
  62629,
  42321,
  13541,
  58833,
  2289,
  61945,
  37745,
  29154,
  29656,
  55467,
  21297,
  12642,
  16149,
  5418,
  3076,
  1032,
  21191,
  51093,
  25891,
  9030,
  24259,
  50077,
  10264,
  6192,
  41366,
  38455,
  3845,
  1290,
  46490,
  39471,
  2311,
  1806,
  13842,
  4644,
  39808,
  32795,
  15842,
  58079,
  9963,
  60365,
  26919,
  10062,
  52658,
  45695,
  40821,
  30186,
  6921,
  2322,
  40579,
  33565,
  29740,
  11352,
  11802,
  6708,
  11547,
  6966,
  45678,
  28380,
  61018,
  23220,
  64416,
  41051,
  63058,
  21156,
  19771,
  15222,
  25046,
  54967,
  52915,
  45949,
  31529,
  10578,
  16099,
  58333,
  28975,
  12126,
  38788,
  33811,
  62803,
  21414,
  26833,
  53689,
  0,
  0,
  11501,
  60865,
  24608,
  8256,
  8188,
  64739,
  51377,
  45433,
  60763,
  23478,
  48746,
  27348,
  18123,
  52109,
  55742,
  48743,
  19257,
  14706,
  56906,
  19092,
  54348,
  19608,
  59480,
  22704,
  19151,
  53125,
  27600,
  53435,
  10991,
  61381,
  58794,
  43599,
  5883,
  64493,
  50499,
  17286,
  55117,
  19866,
  21811,
  13158,
  38021,
  34065,
  53061,
  17802,
  4345,
  63977,
  1538,
  516,
  33151,
  32766,
  61520,
  20640,
  17468,
  15480,
  47775,
  40741,
  58280,
  43083,
  62289,
  20898,
  65187,
  41821,
  49216,
  16512,
  35471,
  36613,
  44434,
  37439,
  48285,
  40225,
  18488,
  14448,
  1269,
  62961,
  57276,
  48227,
  49590,
  46711,
  30170,
  55983,
  25377,
  8514,
  12304,
  4128,
  6911,
  65509,
  3827,
  62461,
  28114,
  53951,
  19661,
  52609,
  5132,
  3096,
  13587,
  4902,
  12268,
  60611,
  57695,
  24510,
  41623,
  38709,
  52292,
  17544,
  14615,
  5934,
  22468,
  50323,
  62119,
  42837,
  33406,
  32508,
  18237,
  15738,
  44132,
  25800,
  59229,
  23994,
  11033,
  6450,
  38259,
  29670,
  41056,
  24768,
  39041,
  33049,
  53583,
  20382,
  32732,
  56483,
  26146,
  8772,
  32298,
  10836,
  43920,
  36923,
  33672,
  34827,
  51782,
  18060,
  10734,
  61127,
  54200,
  47211,
  15380,
  5160,
  31198,
  56999,
  57950,
  24252,
  7435,
  2838,
  30427,
  56237,
  15328,
  57563,
  22066,
  12900,
  20026,
  14964,
  7690,
  2580,
  56137,
  18834,
  2566,
  1548,
  27684,
  9288,
  58460,
  23736,
  24002,
  49823,
  28371,
  54205,
  61356,
  44099,
  42594,
  25284,
  43153,
  37177,
  42133,
  38193,
  14308,
  58579,
  35705,
  31218,
  13031,
  59349,
  17352,
  51339,
  22839,
  14190,
  46957,
  28122,
  35981,
  36097,
  25813,
  54705,
  53838,
  20124,
  57513,
  43337,
  46188,
  27864,
  64086,
  22188,
  2036,
  62707,
  9706,
  60111,
  44901,
  26058,
  36474,
  31476,
  59822,
  44615,
  6152,
  2064,
  54714,
  47727,
  34936,
  30960,
  28453,
  9546,
  29230,
  11868,
  9244,
  7224,
  61862,
  42583,
  51124,
  46195,
  20934,
  50839,
  9192,
  59595,
  31965,
  56737,
  40052,
  29928,
  8479,
  7998,
  56651,
  19350,
  56509,
  48481,
  34443,
  35597,
  34186,
  35343,
  36976,
  28896,
  16958,
  15996,
  50357,
  46449,
  43622,
  26316,
  55368,
  18576,
  1283,
  774,
  502,
  63223,
  4622,
  3612,
  41825,
  25026,
  24373,
  13674,
  63831,
  22446,
  53433,
  47465,
  37254,
  34327,
  22721,
  49561,
  10013,
  7482,
  47518,
  40487,
  14561,
  57817,
  5112,
  63723,
  45976,
  38955,
  13073,
  4386,
  47977,
  27090,
  28889,
  55721,
  35214,
  36359,
  42900,
  37939,
  46747,
  39725,
  8734,
  7740,
  37511,
  34581,
  8425,
  59849,
  18894,
  52871,
  65365,
  21930,
  30760,
  10320,
  31455,
  57253,
  36748,
  35843,
  63649,
  41305,
  32905,
  35081,
  5901,
  3354,
  55999,
  48997,
  12774,
  59095,
  50754,
  17028,
  47208,
  26832,
  49985,
  16770,
  45209,
  39209,
  30509,
  11610,
  4367,
  3870,
  52144,
  45179,
  64596,
  21672,
  54971,
  47981,
  14870,
  5676
}; // idb
_WORD dword_10117570[512] =
{
  25443,
  50853,
  31868,
  63620,
  30583,
  61081,
  31611,
  63117,
  62194,
  65293,
  27499,
  54973,
  28527,
  57009,
  50629,
  37204,
  12336,
  24656,
  257,
  515,
  26471,
  52905,
  11051,
  22141,
  65278,
  59161,
  55255,
  46434,
  43947,
  19942,
  30326,
  60570,
  51914,
  36677,
  33410,
  8093,
  51657,
  35136,
  32125,
  64135,
  64250,
  61205,
  22873,
  45803,
  18247,
  36553,
  61680,
  64267,
  44461,
  16876,
  54484,
  45927,
  41634,
  24573,
  44975,
  17898,
  40092,
  9151,
  42148,
  21495,
  29298,
  58518,
  49344,
  39771,
  47031,
  30146,
  65021,
  57628,
  37779,
  15790,
  9766,
  19562,
  13878,
  27738,
  16191,
  32321,
  63479,
  62722,
  52428,
  33615,
  13364,
  26716,
  42405,
  20980,
  58853,
  53556,
  61937,
  63752,
  29041,
  58003,
  55512,
  43891,
  12593,
  25171,
  5397,
  10815,
  1028,
  2060,
  51143,
  38226,
  8995,
  18021,
  50115,
  40286,
  6168,
  12328,
  38550,
  14241,
  1285,
  2575,
  39578,
  12213,
  1799,
  3593,
  4626,
  9270,
  32896,
  7067,
  58082,
  57149,
  60395,
  52518,
  10023,
  20073,
  45746,
  32717,
  30069,
  60063,
  2313,
  4635,
  33667,
  7582,
  11308,
  22644,
  6682,
  13358,
  6939,
  13869,
  28270,
  56498,
  23130,
  46318,
  41120,
  23547,
  21074,
  42230,
  15163,
  30285,
  54998,
  46945,
  46003,
  32206,
  10537,
  21115,
  58339,
  56638,
  12079,
  24177,
  33924,
  5015,
  21331,
  42741,
  53713,
  47464,
  0,
  0,
  60909,
  49452,
  8224,
  16480,
  64764,
  58143,
  45489,
  31176,
  23387,
  46829,
  27242,
  54462,
  52171,
  36166,
  48830,
  26585,
  14649,
  29259,
  19018,
  38110,
  19532,
  39124,
  22616,
  45288,
  53199,
  34122,
  53456,
  47979,
  61423,
  50474,
  43690,
  20453,
  64507,
  60694,
  17219,
  34501,
  19789,
  39639,
  13107,
  26197,
  34181,
  4500,
  17733,
  35535,
  63993,
  59664,
  514,
  1030,
  32639,
  65153,
  20560,
  41200,
  15420,
  30788,
  40863,
  9658,
  43176,
  19427,
  20817,
  41715,
  41891,
  24062,
  16448,
  32960,
  36751,
  1418,
  37522,
  16301,
  40349,
  8636,
  14392,
  28744,
  62965,
  61700,
  48316,
  25567,
  46774,
  30657,
  56026,
  44917,
  8481,
  16995,
  4112,
  8240,
  65535,
  58650,
  62451,
  64782,
  53970,
  49005,
  52685,
  33100,
  3084,
  6164,
  4883,
  9781,
  60652,
  49967,
  24415,
  48865,
  38807,
  13730,
  17476,
  35020,
  5911,
  11833,
  50372,
  37719,
  42919,
  22002,
  32382,
  64642,
  15677,
  31303,
  25700,
  51372,
  23901,
  47847,
  6425,
  12843,
  29555,
  59029,
  24672,
  49312,
  33153,
  6552,
  20303,
  40657,
  56540,
  41855,
  8738,
  17510,
  10794,
  21630,
  37008,
  15275,
  34952,
  2947,
  17990,
  36042,
  61166,
  50985,
  47288,
  27603,
  5140,
  10300,
  57054,
  42873,
  24158,
  48354,
  2827,
  5661,
  56283,
  44406,
  57568,
  56123,
  12850,
  25686,
  14906,
  29774,
  2570,
  5150,
  18761,
  37595,
  1542,
  3082,
  9252,
  18540,
  23644,
  47332,
  49858,
  40797,
  54227,
  48494,
  44204,
  17391,
  25186,
  50342,
  37265,
  14760,
  38293,
  12708,
  58596,
  54071,
  31097,
  62091,
  59367,
  54578,
  51400,
  35651,
  14135,
  28249,
  28013,
  55991,
  36237,
  396,
  54741,
  45412,
  20046,
  40146,
  43433,
  18912,
  27756,
  55476,
  22102,
  44282,
  62708,
  62215,
  60138,
  53029,
  25957,
  51887,
  31354,
  62606,
  44718,
  18409,
  2056,
  4120,
  47802,
  28629,
  30840,
  61576,
  9509,
  19055,
  11822,
  23666,
  7196,
  14372,
  42662,
  22513,
  46260,
  29639,
  50886,
  38737,
  59624,
  52003,
  56797,
  41340,
  29812,
  59548,
  7967,
  15905,
  19275,
  38621,
  48573,
  25052,
  35723,
  3462,
  35466,
  3973,
  28784,
  57488,
  15934,
  31810,
  46517,
  29124,
  26214,
  52394,
  18504,
  37080,
  771,
  1541,
  63222,
  63233,
  3598,
  7186,
  24929,
  49827,
  13621,
  27231,
  22359,
  44793,
  47545,
  27088,
  34438,
  6033,
  49601,
  39256,
  7453,
  14887,
  40606,
  10169,
  57825,
  55608,
  63736,
  60179,
  39064,
  11187,
  4369,
  8755,
  26985,
  53947,
  55769,
  43376,
  36494,
  1929,
  38036,
  13223,
  39835,
  11702,
  7710,
  15394,
  34695,
  5522,
  59881,
  51488,
  52942,
  34633,
  21845,
  43775,
  10280,
  20600,
  57311,
  42362,
  35980,
  911,
  41377,
  23032,
  35209,
  2432,
  3341,
  6679,
  49087,
  26074,
  59110,
  55089,
  16962,
  33990,
  26728,
  53432,
  16705,
  33475,
  39321,
  10672,
  11565,
  23159,
  3855,
  7697,
  45232,
  31691,
  21588,
  43260,
  48059,
  28118,
  5654,
  11322
}; // idb
int dword_10117970[] = { 99 }; // weak
int dword_10117D70[] = { 25344 }; // weak
int dword_10118170[] = { 6488064 }; // weak
int dword_10118570[] = { 1660944384 }; // weak
int dword_10118998[] = { 128 }; // weak
int dword_101189A8[] = { 0 }; // weak
int dword_101189B8[] = { 0 }; // weak
char byte_10118A29[] = { '\0' }; // weak
char byte_10118A2A[] = { '\0' }; // weak
char byte_10118A2B[] = { '\0' }; // weak
char byte_10118A2C[] = { '\x10' }; // weak
int dword_10118A40[] = { 0 }; // weak
_UNKNOWN unk_10118AB8; // weak
_UNKNOWN unk_10118F38; // weak
char byte_10118FB0[] = { '\0' }; // weak
char byte_101190B0[] = { '\0' }; // weak
char byte_101191B0[] = { '\0' }; // weak
int dword_101192B0[] = { 0 }; // weak
int dword_10119328[] = { 0 }; // weak
__int16 word_101193A0[] = { 0 }; // weak
__int16 word_101193A2[] = { 0 }; // weak
__int16 word_101193A4[] = { 0 }; // weak
__int16 word_101193A6[] = { 0 }; // weak
int (__cdecl *off_101193A8)(int, int) = &sub_1005A0C0; // weak
void *off_10119554 = &unk_10118AB8; // weak
void *off_10119568 = &unk_10118F38; // weak
_UNKNOWN unk_1011957C; // weak
_UNKNOWN unk_10119598; // weak
int (__cdecl *off_1011C11C[2])(int, int) = { &sub_1005A740, &sub_1005A7A0 }; // weak
_UNKNOWN unk_1011DE50; // weak
char byte_1011DE51[] = { '\0' }; // weak
_UNKNOWN unk_1011DE78; // weak
_UNKNOWN unk_1011DE79; // weak
_UNKNOWN unk_1011E790; // weak
int dword_1011E794[] = { 0 }; // weak
_UNKNOWN unk_1011E7A8; // weak
int dword_1011E7AC[] = { 0 }; // weak
_UNKNOWN unk_1011E7D0; // weak
int dword_1011E7D4[] = { 0 }; // weak
_UNKNOWN unk_1011E800; // weak
int dword_1011E804[] = { 0 }; // weak
_UNKNOWN unk_1011EA80; // weak
_UNKNOWN unk_1011ED00; // weak
_UNKNOWN unk_1011ED24; // weak
_UNKNOWN unk_1011EEC8; // weak
int dword_1011F07C[] = { 0 }; // weak
_UNKNOWN off_1011F080; // weak
_UNKNOWN unk_1011F110; // weak
_UNKNOWN unk_1011F114; // weak
_UNKNOWN unk_1011F118; // weak
_UNKNOWN unk_1011F11C; // weak
_UNKNOWN unk_1011F120; // weak
_UNKNOWN unk_1011F124; // weak
_UNKNOWN unk_1011F128; // weak
_UNKNOWN unk_1011F12C; // weak
char byte_1011F130[] = { '\x01' }; // weak
__int16 word_1011F132[] = { 3020 }; // weak
char byte_101209F8[] = { '\x01' }; // weak
__int16 word_10120A00[] = { 3020 }; // weak
__int16 word_10123C48[] = { 100 }; // weak
char byte_10125AD0[] = { '\0' }; // weak
int dword_10125AD4[] = { 29 }; // weak
_UNKNOWN unk_101267C8; // weak
int dword_101267CC[] = { 3535 }; // weak
_UNKNOWN unk_10126800; // weak
int dword_10126804[] = { 6813 }; // weak
_UNKNOWN unk_10126838; // weak
int dword_1012683C[] = { 9036 }; // weak
_UNKNOWN unk_10126870; // weak
int dword_10126874[] = { 6763 }; // weak
int dword_10128470[] = { 6103 }; // weak
int dword_10128474[] = { 8000 }; // weak
__int16 word_10128AC8[] = { 0 }; // weak
int dword_10128ACC[] = { 106639 }; // weak
int dword_10128AD0[] = { 4294791889 }; // weak
int (__cdecl *off_10129110[16])(int, int) =
{
  &sub_100649C0,
  &sub_100649C0,
  &sub_100649C0,
  &sub_10064B70,
  &sub_10064B70,
  &sub_10064B70,
  &sub_10064B70,
  &sub_100649C0,
  &sub_10064780,
  &sub_10064730,
  &sub_10064730,
  &sub_10064780,
  &sub_10064780,
  &sub_10064730,
  &sub_10064730,
  &sub_10064780
}; // weak
int (__cdecl *off_10129130[8])(int, int) =
{
  &sub_10064780,
  &sub_10064730,
  &sub_10064730,
  &sub_10064780,
  &sub_10064780,
  &sub_10064730,
  &sub_10064730,
  &sub_10064780
}; // weak
int dword_10129158 = 0; // idb
int dword_10129A98[] = { 0 }; // weak
_UNKNOWN unk_101380C0; // weak
_UNKNOWN unk_101380C8; // weak
int __security_cookie = 3141592654; // weak
int (*off_1013A2A4[3])() = { &_fptrap, &_fptrap, &_fptrap }; // weak
void *off_1013A8D0 = &unk_10A09C20; // weak
_UNKNOWN unk_1013A8E0; // weak
_UNKNOWN unk_1013A940; // weak
char byte_1013AB50 = '\0'; // weak
_UNKNOWN unk_1013AC58; // weak
int dword_1013B1B0 = 1024; // weak
int dword_1013B1B4 = 4294966273; // weak
int dword_1013B1B8 = 53; // weak
int dword_1013B1BC = 11; // weak
int dword_1013B1C0 = 64; // weak
int dword_1013B1C4 = 1023; // weak
int dword_1013B1C8 = 128; // weak
int dword_1013B1CC = 4294967169; // weak
int dword_1013B1D0 = 24; // weak
int dword_1013B1D4 = 8; // weak
int dword_1013B1D8 = 32; // weak
int dword_1013B1DC = 127; // weak
char byte_1013B7E0 = '\0'; // weak
int dword_1013B8E8 = 0; // weak
int dword_1013B8EC = 0; // weak
int dword_1013B8F0 = 0; // weak
int dword_1013B8F4 = 0; // weak
int dword_1013B8F8 = 0; // weak
int dword_101410F8; // weak
int dword_101410FC; // weak
char byte_10141100; // weak
int dword_10141104; // weak
int dword_10141108; // weak
int dword_1014110C; // weak
int dword_10141110; // weak
char byte_10146910; // weak
int dword_10146918; // weak
int dword_1014691C; // weak
_UNKNOWN unk_10146920; // weak
char byte_10146924; // weak
char byte_10146925; // weak
char byte_10146926; // weak
int dword_10146928; // idb
float flt_10146930[]; // weak
_UNKNOWN unk_10146934; // weak
char byte_101470F8; // weak
char byte_101470F9; // weak
char byte_101470FA; // weak
char byte_101470FB; // weak
__int16 word_101470FC; // weak
_UNKNOWN unk_10147100; // weak
float flt_1014A5D0; // weak
int dword_1014A5D8[]; // weak
int dword_1014A5DC[]; // weak
int dword_1014A5E0[]; // weak
int dword_1014A5E4[]; // weak
int dword_1014A5E8; // weak
int dword_1014A5F4; // weak
int dword_1014A5F8; // weak
int dword_1014A604; // weak
int dword_1014A608; // weak
int dword_1014A614; // weak
int dword_1014A628; // weak
int dword_1014A62C[]; // weak
int dword_1014A630[]; // weak
int dword_1014A634; // weak
int dword_1014A638; // weak
_UNKNOWN unk_1014A640; // weak
_UNKNOWN unk_1014E4C0; // weak
int dword_10152340; // weak
int dword_10152344; // weak
char byte_10152348[12288]; // idb
char byte_10155348; // weak
char byte_10155349; // weak
char byte_1015534A; // weak
char byte_1015534B; // weak
char byte_1015534C; // weak
_UNKNOWN unk_10155378; // weak
char byte_101555FE[]; // weak
char byte_101555FF[]; // weak
char byte_10155600[]; // weak
char byte_10155601[]; // weak
int dword_10184D30[]; // weak
int dword_10184D34[]; // weak
int dword_10184D38[]; // weak
int dword_10185B40; // weak
int dword_10185B4C; // weak
__int16 word_10185B50; // weak
int dword_10185B54; // weak
int dword_10185B58[]; // weak
int dword_10186008[]; // weak
char byte_101864B8; // weak
int dword_101864BC; // weak
_UNKNOWN unk_101864C0; // weak
_UNKNOWN unk_101F3C48; // weak
int dword_101F3C58; // weak
_UNKNOWN unk_101F3C5C; // weak
_UNKNOWN unk_10325476; // weak
char byte_103E0640; // weak
int dword_103E0644; // weak
_UNKNOWN unk_103E0648; // weak
_UNKNOWN unk_103E2E48; // weak
char byte_103E2F70[]; // weak
char byte_103E2F71[]; // weak
char byte_103E2F72[]; // weak
char byte_103E2F73[]; // weak
_UNKNOWN unk_10419D30; // weak
char byte_10419D35[]; // weak
char byte_10419D36[]; // weak
char byte_10419D37[]; // weak
int dword_10419D44; // weak
int dword_10419D79; // weak
char byte_10427EC6[78]; // idb
int dword_10427F14; // weak
__int16 word_10427F18; // weak
int dword_10427F1C; // weak
int dword_10427F20[]; // weak
char byte_10428AD8; // weak
int dword_10428ADC; // weak
int dword_10428AE0; // weak
_UNKNOWN unk_10428AE8; // weak
char byte_1042CE68; // weak
char byte_1042CE69; // weak
char byte_1042CE6A; // weak
char byte_1042CE6B; // weak
int dword_1042CE6C; // weak
_UNKNOWN unk_1042CE70; // weak
_UNKNOWN unk_1042CE73; // weak
_UNKNOWN unk_1042CE75; // weak
_UNKNOWN unk_1042CE76; // weak
_UNKNOWN unk_1042CEE0; // weak
char byte_1042E4B8; // weak
_UNKNOWN unk_1042E4BC; // weak
char byte_1042E4C8[100]; // idb
_UNKNOWN unk_1042E52C; // weak
char byte_1042E531; // weak
char byte_1042E532; // weak
char byte_1042ED7C; // weak
int dword_1042ED80; // weak
__int16 word_1042ED88; // weak
__int16 word_1042ED8A; // weak
__int16 word_1042ED8C; // weak
__int16 word_1042ED8E; // weak
_UNKNOWN unk_1042ED90; // weak
_UNKNOWN unk_104389C8; // weak
_UNKNOWN unk_10439768; // weak
char byte_1043978E; // weak
char byte_1043978F; // weak
_UNKNOWN unk_10439790; // weak
char byte_10439791; // weak
char byte_1043BE6B; // weak
int dword_1043BE6C; // weak
int dword_1043BE70; // weak
int dword_1043BE74; // weak
int dword_1043BE78; // weak
int dword_1043BE7C; // weak
int dword_1043BE80; // weak
int dword_1043BE84; // weak
int dword_1043BE88; // weak
int dword_1043BE8C; // weak
char byte_1043BE90; // weak
char byte_1043BE91; // weak
char byte_1043BE92; // weak
char byte_1043BE93; // weak
int dword_1043BE94; // weak
_UNKNOWN unk_1043BE98; // weak
int dword_1043BF80; // weak
int dword_1043BF84; // weak
_UNKNOWN unk_1043BF88; // weak
_UNKNOWN unk_1043BF90; // weak
int dword_1043D3C4; // weak
_UNKNOWN unk_1043D3C8; // weak
int dword_1043D3D8; // weak
_UNKNOWN unk_1043D3DC; // weak
_UNKNOWN unk_1043D3F0; // weak
_UNKNOWN unk_1043D3F8; // weak
char byte_1043D488[]; // weak
char byte_1043D588; // weak
int dword_1043D58C; // weak
int dword_1043D590; // weak
int dword_1043D594; // weak
int dword_1043D598; // weak
int dword_1043D59C; // weak
int dword_1043D5A0; // weak
int dword_1043D5A4; // weak
int dword_1043D5A8; // weak
int dword_1043D5AC; // weak
int dword_1043D5B0; // weak
int dword_1043D5B4; // weak
_UNKNOWN unk_1043D5B8; // weak
_UNKNOWN unk_1043D5BC; // weak
int dword_1043D614[]; // weak
int dword_1043D618[]; // weak
int dword_1043D61C[]; // weak
int dword_1043D620[]; // weak
int dword_1043D624[]; // weak
int dword_1043D628[]; // weak
int dword_1043D62C[]; // weak
int dword_1043D630[]; // weak
int dword_1043D634[]; // weak
int dword_1043D638[]; // weak
_UNKNOWN unk_1043D640; // weak
char byte_1043D670[]; // weak
char byte_1043D671[]; // weak
char byte_1043D672[]; // weak
__int16 word_1043D67C[]; // weak
_UNKNOWN unk_1043D760; // weak
char byte_1043D7E0[]; // weak
char byte_1043D7E1[]; // weak
int dword_1043D7E4[]; // weak
int dword_1043D7E8[]; // weak
int dword_1043D7EC[]; // weak
__int16 word_1043D7F0[]; // weak
float flt_1043D7F4[]; // weak
char byte_1043D7F8[]; // weak
char byte_1043D7F9[]; // weak
char byte_1043D860[]; // weak
char byte_1043D861[]; // weak
char byte_1043D862[]; // weak
char byte_1043D863[]; // weak
char byte_1043D864[]; // weak
char byte_1043D865[]; // weak
_UNKNOWN unk_104400B8; // weak
_UNKNOWN unk_10440868; // weak
char byte_1044089A[]; // weak
_UNKNOWN unk_10440968; // weak
_UNKNOWN unk_104410F0; // weak
int dword_104410F8[]; // weak
char byte_10441114; // weak
char byte_10441115; // weak
char byte_10441116; // weak
_UNKNOWN unk_10441118; // weak
_UNKNOWN unk_10441140; // weak
_UNKNOWN unk_10441618; // weak
int dword_10441628; // weak
int dword_10441670; // weak
int dword_10441674; // weak
_UNKNOWN unk_10441678; // weak
int dword_104416CC; // weak
int dword_104416D0; // weak
int dword_104416D4; // weak
int dword_104416D8; // weak
int dword_104416DC; // weak
int dword_104416E0; // weak
int dword_104416E4; // weak
int dword_104416E8; // weak
int dword_104416EC; // weak
int dword_104416F0; // weak
int dword_104416F8; // weak
char byte_104416FC; // weak
char byte_104416FD; // weak
char byte_104416FE; // weak
char byte_104416FF; // weak
_UNKNOWN unk_10441700; // weak
char byte_10441701; // weak
char byte_10441702; // weak
char byte_10441703; // weak
int dword_10441A5C; // weak
_UNKNOWN unk_10441A60; // weak
char byte_105026DA; // weak
char byte_105026DB; // weak
int dword_105026DC; // weak
_UNKNOWN unk_105026E0; // weak
_UNKNOWN unk_1050DE28; // weak
int dword_1050DE38; // weak
int dword_1050DE80[]; // weak
_UNKNOWN unk_1050E650; // weak
_UNKNOWN unk_10624DD3; // weak
_UNKNOWN unk_107FC150; // weak
int dword_107FC160; // weak
_UNKNOWN unk_107FC380; // weak
_UNKNOWN unk_107FC3D4; // weak
_UNKNOWN unk_107FC400; // weak
_UNKNOWN unk_107FC470; // weak
_UNKNOWN unk_107FC480; // weak
int dword_107FC484; // weak
int dword_107FC490; // weak
int dword_107FC498; // weak
int dword_107FC4D8; // weak
int dword_107FC4DC; // weak
_UNKNOWN unk_107FCC90; // weak
void *dword_107FD440; // idb
int dword_107FD444; // weak
_BYTE byte_107FD448[904]; // idb
int dword_107FD7D0; // weak
int dword_107FD7D4; // weak
int dword_107FD7D8; // weak
int dword_107FD7DC; // weak
int dword_107FD7E0; // weak
int dword_107FD7E4; // weak
int dword_107FD7E8; // weak
int dword_107FD7EC; // weak
int dword_107FD7F0; // weak
int dword_107FD7F4; // weak
int dword_107FD7F8; // weak
int dword_107FD7FC; // weak
__int16 word_107FD800; // weak
char byte_107FD802; // weak
int dword_107FD808[]; // weak
int dword_107FD80C; // weak
int dword_107FD810; // weak
int dword_107FD814; // weak
int dword_107FD818[]; // weak
int dword_107FD81C; // weak
void *dword_107FD820; // idb
int dword_107FD824; // weak
char byte_107FD828[]; // weak
_UNKNOWN unk_107FDB00; // weak
_UNKNOWN unk_107FDB20; // weak
_UNKNOWN unk_107FDB48; // weak
int dword_107FE2C8; // weak
int dword_107FE2CC; // weak
int dword_107FE2D0; // weak
__int16 word_107FE2D4; // weak
char byte_107FE2D8[]; // weak
char byte_107FE388[]; // weak
_UNKNOWN unk_107FE438; // weak
_UNKNOWN unk_107FE7A8; // weak
_UNKNOWN unk_107FE828; // weak
int dword_107FECC8; // weak
int dword_107FECCC; // weak
int dword_107FECD0; // weak
int dword_107FECD4; // weak
char byte_107FECD8; // weak
void *dword_107FECDC; // idb
char *dword_107FECE0; // idb
char byte_107FECE4; // weak
char byte_107FECE5; // weak
char byte_107FECE6; // weak
char byte_107FECE7; // weak
float flt_107FECE8; // weak
char byte_107FECEC; // weak
int dword_107FECF0; // weak
int dword_107FECF4; // weak
char byte_107FECF8; // weak
char byte_107FECF9; // weak
char byte_107FECFA; // weak
int dword_107FECFC; // weak
int dword_107FED00; // weak
char byte_107FED08; // weak
__int16 word_107FED0A; // weak
int dword_107FED0C; // weak
int dword_107FED14; // weak
char byte_107FEDB9; // weak
char byte_107FEDBA; // weak
char byte_107FEDBB; // weak
int dword_107FEDBC; // weak
int dword_1080AD7C; // weak
int dword_1080B09C; // weak
int dword_10810970; // weak
int dword_10810974; // weak
int dword_10810978; // weak
_UNKNOWN unk_10810A08; // weak
_UNKNOWN unk_10931CC0; // weak
char byte_1093D408; // weak
char byte_1093D409[]; // weak
int dword_1093D440; // weak
char byte_1093D444[]; // weak
int dword_1093D448; // weak
CHAR byte_1093D450[128]; // idb
char byte_1093D4D0[128]; // idb
int dword_1093D550; // weak
char dword_1093D554[]; // idb
char byte_1093D558[128]; // idb
_UNKNOWN unk_1093D5D8; // weak
char byte_1093D778; // weak
char byte_1093D779; // weak
int dword_1093D77C; // weak
int dword_1093D780; // weak
int dword_1093D784; // weak
int dword_1093D788; // weak
int dword_1093D78C; // weak
char byte_1093D790; // weak
int dword_10942F94; // weak
int dword_10942F98; // weak
int dword_10942F9C; // weak
int dword_10942FA0; // weak
_UNKNOWN unk_10942FA8; // weak
float flt_10943350[]; // weak
char byte_10943418; // weak
float flt_10943420[]; // weak
char byte_109434E8[]; // weak
int dword_1094351C; // weak
char byte_10943520; // weak
char byte_10943521; // weak
int dword_10943524; // weak
int dword_10943528; // weak
__int16 word_10943530; // weak
__int16 word_10943534; // weak
__int16 word_10943538; // weak
int dword_1094353C; // weak
void (__cdecl *dword_10943540[8])(_DWORD, _DWORD, _DWORD); // idb
_UNKNOWN unk_10943560; // weak
char byte_1094DCC0; // weak
char byte_1094DCC1; // weak
int dword_1094DCC4; // weak
int dword_1094DCC8; // weak
int dword_1094DCCC; // weak
_UNKNOWN unk_1094DCD0; // weak
_UNKNOWN unk_1094DCD1; // weak
_UNKNOWN unk_1094DCE7; // weak
_UNKNOWN unk_1094DCE8; // weak
_UNKNOWN unk_1094DCE9; // weak
_UNKNOWN unk_1094DCEA; // weak
_UNKNOWN unk_1094DCEC; // weak
_UNKNOWN unk_1094DCF0; // weak
_UNKNOWN unk_1094DCF4; // weak
_UNKNOWN unk_1094DD14; // weak
_UNKNOWN unk_1094DD34; // weak
_UNKNOWN unk_1094DD54; // weak
_UNKNOWN unk_1094DD74; // weak
_UNKNOWN unk_1094DD94; // weak
_UNKNOWN unk_1094DDB4; // weak
_UNKNOWN unk_1094DDD4; // weak
_UNKNOWN unk_1094DDF4; // weak
_UNKNOWN unk_1094DE14; // weak
_UNKNOWN unk_1094DE34; // weak
_UNKNOWN unk_1094DE54; // weak
_UNKNOWN unk_1094DE74; // weak
_UNKNOWN unk_1094DE94; // weak
_UNKNOWN unk_1094DEB4; // weak
_UNKNOWN unk_1094DED4; // weak
_UNKNOWN unk_1094DEF4; // weak
_UNKNOWN unk_1094DF14; // weak
_UNKNOWN unk_1094DF34; // weak
_UNKNOWN unk_1094DF54; // weak
_UNKNOWN unk_1094DF74; // weak
_UNKNOWN unk_1094DF94; // weak
_UNKNOWN unk_1094DFB4; // weak
_UNKNOWN unk_1094DFD4; // weak
_UNKNOWN unk_1094DFF4; // weak
_UNKNOWN unk_1094E014; // weak
_UNKNOWN unk_1094E034; // weak
_UNKNOWN unk_1094E054; // weak
_UNKNOWN unk_1094E074; // weak
_UNKNOWN unk_1094E078; // weak
_UNKNOWN unk_1094E07C; // weak
_UNKNOWN unk_1094E080; // weak
_UNKNOWN unk_1094E084; // weak
_UNKNOWN unk_1094E088; // weak
_UNKNOWN unk_1094E08C; // weak
_UNKNOWN unk_1094E0AC; // weak
_UNKNOWN unk_1094E0CC; // weak
_UNKNOWN unk_1094E0EC; // weak
_UNKNOWN unk_1094E10C; // weak
_UNKNOWN unk_1094E12C; // weak
_UNKNOWN unk_1094E14C; // weak
_UNKNOWN unk_1094E16C; // weak
_UNKNOWN unk_1094E18C; // weak
_UNKNOWN unk_1094E18D; // weak
_UNKNOWN unk_1094E18E; // weak
_UNKNOWN unk_1094E1E0; // weak
_UNKNOWN unk_1094E200; // weak
_UNKNOWN unk_1094E220; // weak
_UNKNOWN unk_1094E224; // weak
_UNKNOWN unk_1094E228; // weak
_UNKNOWN unk_1094E22C; // weak
_UNKNOWN unk_1094E24C; // weak
_UNKNOWN unk_1094E26C; // weak
_UNKNOWN unk_1094E28C; // weak
_UNKNOWN unk_1094E2AC; // weak
_UNKNOWN unk_1094E2CC; // weak
_UNKNOWN unk_1094E2EC; // weak
_UNKNOWN unk_1094E30C; // weak
_UNKNOWN unk_1094E32C; // weak
_UNKNOWN unk_1094E34C; // weak
_UNKNOWN unk_1094E394; // weak
_UNKNOWN unk_1094E3DC; // weak
_UNKNOWN unk_1094E424; // weak
_UNKNOWN unk_1094E46C; // weak
_UNKNOWN unk_1094E4B4; // weak
_UNKNOWN unk_1094E4FC; // weak
_UNKNOWN unk_1094E544; // weak
_UNKNOWN unk_1094E58C; // weak
_UNKNOWN unk_1094E5D4; // weak
_UNKNOWN unk_1094E61C; // weak
_UNKNOWN unk_1094E664; // weak
_UNKNOWN unk_1094E6AC; // weak
_UNKNOWN unk_1094E6F4; // weak
_UNKNOWN unk_1094E73C; // weak
_UNKNOWN unk_1094E784; // weak
_UNKNOWN unk_1094E7CC; // weak
_UNKNOWN unk_1094E814; // weak
_UNKNOWN unk_1094E85C; // weak
_UNKNOWN unk_1094E8A4; // weak
_UNKNOWN unk_1094E8EC; // weak
_UNKNOWN unk_1094E934; // weak
_UNKNOWN unk_1094E97C; // weak
_UNKNOWN unk_1094E9C4; // weak
_UNKNOWN unk_1094EA0C; // weak
_UNKNOWN unk_1094EA54; // weak
_UNKNOWN unk_1094EA9C; // weak
_UNKNOWN unk_1094EAE4; // weak
_UNKNOWN unk_1094EB2C; // weak
_UNKNOWN unk_1094EB74; // weak
_UNKNOWN unk_1094EBBC; // weak
_UNKNOWN unk_1094EBD4; // weak
_UNKNOWN unk_1094EBF4; // weak
_UNKNOWN unk_1094EC14; // weak
_UNKNOWN unk_1094EC18; // weak
_UNKNOWN unk_1094ECBC; // weak
_UNKNOWN unk_1094ED60; // weak
_UNKNOWN unk_1094EE04; // weak
_UNKNOWN unk_1094EEA8; // weak
_UNKNOWN unk_1094EF4C; // weak
_UNKNOWN unk_1094EFF0; // weak
_UNKNOWN unk_1094F094; // weak
_UNKNOWN unk_1094F138; // weak
_UNKNOWN unk_1094F1DC; // weak
_UNKNOWN unk_1094F280; // weak
_UNKNOWN unk_1094F324; // weak
_UNKNOWN unk_1094F3C8; // weak
_UNKNOWN unk_1094F46C; // weak
_UNKNOWN unk_1094F510; // weak
_UNKNOWN unk_1094F5B4; // weak
_UNKNOWN unk_1094F658; // weak
_UNKNOWN unk_1094F6FC; // weak
_UNKNOWN unk_1094F7A0; // weak
_UNKNOWN unk_1094F844; // weak
_UNKNOWN unk_1094F8E8; // weak
_UNKNOWN unk_1094F98C; // weak
_UNKNOWN unk_1094FA30; // weak
_UNKNOWN unk_1094FAD4; // weak
_UNKNOWN unk_1094FB78; // weak
_UNKNOWN unk_1094FC1C; // weak
_UNKNOWN unk_1094FCC0; // weak
_UNKNOWN unk_1094FD64; // weak
_UNKNOWN unk_1094FE08; // weak
_UNKNOWN unk_1094FEAC; // weak
_UNKNOWN unk_1094FF50; // weak
_UNKNOWN unk_1094FFF4; // weak
_UNKNOWN unk_10950098; // weak
_UNKNOWN unk_1095013C; // weak
_UNKNOWN unk_109501E0; // weak
_UNKNOWN unk_10950284; // weak
_UNKNOWN unk_10950328; // weak
_UNKNOWN unk_109503CC; // weak
_UNKNOWN unk_10950470; // weak
_UNKNOWN unk_10950514; // weak
_UNKNOWN unk_109505B8; // weak
_UNKNOWN unk_1095065C; // weak
_UNKNOWN unk_10950700; // weak
_UNKNOWN unk_109507A4; // weak
_UNKNOWN unk_10950848; // weak
_UNKNOWN unk_109508EC; // weak
_UNKNOWN unk_10950990; // weak
_UNKNOWN unk_10950A34; // weak
_UNKNOWN unk_10950AD8; // weak
_UNKNOWN unk_10950B7C; // weak
_UNKNOWN unk_10950C20; // weak
_UNKNOWN unk_10950CC4; // weak
_UNKNOWN unk_10950D68; // weak
_UNKNOWN unk_10950E0C; // weak
_UNKNOWN unk_10950EB0; // weak
_UNKNOWN unk_10950F54; // weak
_UNKNOWN unk_10950FF8; // weak
_UNKNOWN unk_1095109C; // weak
_UNKNOWN unk_10951140; // weak
_UNKNOWN unk_109511E4; // weak
_UNKNOWN unk_10951288; // weak
_UNKNOWN unk_1095132C; // weak
_UNKNOWN unk_109513D0; // weak
_UNKNOWN unk_10951474; // weak
_UNKNOWN unk_10951518; // weak
_UNKNOWN unk_109515BC; // weak
_UNKNOWN unk_10951660; // weak
_UNKNOWN unk_10951704; // weak
_UNKNOWN unk_109517A8; // weak
_UNKNOWN unk_1095184C; // weak
_UNKNOWN unk_109518F0; // weak
_UNKNOWN unk_10951994; // weak
_UNKNOWN unk_10951A38; // weak
_UNKNOWN unk_10951ADC; // weak
_UNKNOWN unk_10951B80; // weak
_UNKNOWN unk_10951C24; // weak
_UNKNOWN unk_10951CC8; // weak
_UNKNOWN unk_10951D6C; // weak
_UNKNOWN unk_10951E10; // weak
_UNKNOWN unk_10951EB4; // weak
_UNKNOWN unk_10951F58; // weak
_UNKNOWN unk_10951FFC; // weak
_UNKNOWN unk_109520A0; // weak
_UNKNOWN unk_10952144; // weak
_UNKNOWN unk_109521E8; // weak
_UNKNOWN unk_1095228C; // weak
_UNKNOWN unk_10952330; // weak
_UNKNOWN unk_109523D4; // weak
_UNKNOWN unk_10952478; // weak
_UNKNOWN unk_1095251C; // weak
_UNKNOWN unk_109525C0; // weak
_UNKNOWN unk_10952664; // weak
_UNKNOWN unk_10952708; // weak
_UNKNOWN unk_109527AC; // weak
_UNKNOWN unk_10952850; // weak
_UNKNOWN unk_109528F4; // weak
_UNKNOWN unk_10952998; // weak
_UNKNOWN unk_10952A3C; // weak
_UNKNOWN unk_10952AE0; // weak
_UNKNOWN unk_10952B84; // weak
_UNKNOWN unk_10952C28; // weak
_UNKNOWN unk_10952C48; // weak
_UNKNOWN unk_10952C68; // weak
_UNKNOWN unk_10952C88; // weak
_UNKNOWN unk_10952CA8; // weak
_UNKNOWN unk_10952CD0; // weak
_UNKNOWN unk_10952CEC; // weak
_UNKNOWN unk_10952D08; // weak
_UNKNOWN unk_10952D24; // weak
_UNKNOWN unk_10952D40; // weak
_UNKNOWN unk_10952D5C; // weak
_UNKNOWN unk_10952D78; // weak
_UNKNOWN unk_10952D94; // weak
_UNKNOWN unk_10952DB0; // weak
_UNKNOWN unk_10952DCC; // weak
_UNKNOWN unk_10952DE8; // weak
_UNKNOWN unk_10952E04; // weak
_UNKNOWN unk_10952E20; // weak
_UNKNOWN unk_10952E3C; // weak
_UNKNOWN unk_10952E58; // weak
_UNKNOWN unk_10952E74; // weak
_UNKNOWN unk_10952E90; // weak
_UNKNOWN unk_10952EAC; // weak
_UNKNOWN unk_10952EC8; // weak
_UNKNOWN unk_10952EE4; // weak
_UNKNOWN unk_10952F00; // weak
_UNKNOWN unk_10952F1C; // weak
_UNKNOWN unk_10952F38; // weak
_UNKNOWN unk_10952F54; // weak
_UNKNOWN unk_10952F70; // weak
_UNKNOWN unk_10952F8C; // weak
_UNKNOWN unk_10952FA8; // weak
_UNKNOWN unk_10952FC4; // weak
_UNKNOWN unk_10952FE0; // weak
_UNKNOWN unk_10952FFC; // weak
_UNKNOWN unk_10953018; // weak
_UNKNOWN unk_10953034; // weak
_UNKNOWN unk_10953050; // weak
_UNKNOWN unk_1095306C; // weak
_UNKNOWN unk_10953088; // weak
_UNKNOWN unk_109530A4; // weak
_UNKNOWN unk_109530C0; // weak
_UNKNOWN unk_109530DC; // weak
_UNKNOWN unk_109530F8; // weak
_UNKNOWN unk_10953114; // weak
_UNKNOWN unk_10953130; // weak
_UNKNOWN unk_1095314C; // weak
_UNKNOWN unk_10953168; // weak
_UNKNOWN unk_10953184; // weak
_UNKNOWN unk_109531A0; // weak
_UNKNOWN unk_109531BC; // weak
_UNKNOWN unk_109531D8; // weak
_UNKNOWN unk_109531F4; // weak
_UNKNOWN unk_10953210; // weak
_UNKNOWN unk_1095322C; // weak
_UNKNOWN unk_10953248; // weak
_UNKNOWN unk_10953264; // weak
_UNKNOWN unk_10953280; // weak
_UNKNOWN unk_1095329C; // weak
_UNKNOWN unk_109532B8; // weak
_UNKNOWN unk_109532D4; // weak
_UNKNOWN unk_109532F0; // weak
_UNKNOWN unk_1095330C; // weak
_UNKNOWN unk_10953328; // weak
_UNKNOWN unk_10953344; // weak
_UNKNOWN unk_10953360; // weak
_UNKNOWN unk_1095337C; // weak
_UNKNOWN unk_10953398; // weak
_UNKNOWN unk_109533B4; // weak
_UNKNOWN unk_109533D0; // weak
_UNKNOWN unk_109533EC; // weak
_UNKNOWN unk_10953408; // weak
_UNKNOWN unk_10953424; // weak
_UNKNOWN unk_10953440; // weak
_UNKNOWN unk_1095345C; // weak
_UNKNOWN unk_10953478; // weak
_UNKNOWN unk_10953494; // weak
_UNKNOWN unk_109534B0; // weak
_UNKNOWN unk_109534CC; // weak
_UNKNOWN unk_109534E8; // weak
_UNKNOWN unk_10953504; // weak
_UNKNOWN unk_10953520; // weak
_UNKNOWN unk_1095353C; // weak
_UNKNOWN unk_10953558; // weak
_UNKNOWN unk_10953574; // weak
_UNKNOWN unk_10953590; // weak
_UNKNOWN unk_109535AC; // weak
_UNKNOWN unk_109535C8; // weak
_UNKNOWN unk_109535E4; // weak
_UNKNOWN unk_10953600; // weak
_UNKNOWN unk_1095361C; // weak
_UNKNOWN unk_10953638; // weak
_UNKNOWN unk_10953654; // weak
_UNKNOWN unk_10953670; // weak
_UNKNOWN unk_1095368C; // weak
_UNKNOWN unk_109536A8; // weak
_UNKNOWN unk_109536C4; // weak
_UNKNOWN unk_109536E0; // weak
_UNKNOWN unk_109536FC; // weak
_UNKNOWN unk_10953718; // weak
_UNKNOWN unk_10953734; // weak
_UNKNOWN unk_10953750; // weak
_UNKNOWN unk_1095376C; // weak
_UNKNOWN unk_10953788; // weak
_UNKNOWN unk_109537A4; // weak
_UNKNOWN unk_109537C0; // weak
_UNKNOWN unk_109537C4; // weak
_UNKNOWN unk_109537C8; // weak
_UNKNOWN unk_109537CC; // weak
_UNKNOWN unk_109537D0; // weak
_UNKNOWN unk_109537D4; // weak
_UNKNOWN unk_109537D8; // weak
_UNKNOWN unk_109537DC; // weak
_UNKNOWN unk_109537E0; // weak
_UNKNOWN unk_109537E4; // weak
_UNKNOWN unk_109537E8; // weak
_UNKNOWN unk_109537EC; // weak
_UNKNOWN unk_109537F0; // weak
_UNKNOWN unk_109537F4; // weak
_UNKNOWN unk_109537F8; // weak
_UNKNOWN unk_109537FC; // weak
_UNKNOWN unk_10953800; // weak
_UNKNOWN unk_10953804; // weak
_UNKNOWN unk_10953808; // weak
_UNKNOWN unk_109538EC; // weak
_UNKNOWN unk_10954AAC; // weak
_UNKNOWN unk_10954AB0; // weak
_UNKNOWN unk_10954AD8; // weak
_UNKNOWN unk_10954B00; // weak
_UNKNOWN unk_10954B40; // weak
_UNKNOWN unk_10954BC0; // weak
_UNKNOWN unk_10954BC4; // weak
_UNKNOWN unk_10954BC8; // weak
_UNKNOWN unk_10954BCA; // weak
_UNKNOWN unk_10954BCC; // weak
_UNKNOWN unk_10954BCD; // weak
_UNKNOWN unk_10954BCE; // weak
_UNKNOWN unk_10954BD0; // weak
_UNKNOWN unk_10954C34; // weak
_UNKNOWN unk_10954C3C; // weak
_UNKNOWN unk_10954C44; // weak
_UNKNOWN unk_10954C4C; // weak
_UNKNOWN unk_10954C54; // weak
_UNKNOWN unk_10954C5C; // weak
_UNKNOWN unk_10954C64; // weak
_UNKNOWN unk_10954C6C; // weak
_UNKNOWN unk_10954C74; // weak
_UNKNOWN unk_10954C7C; // weak
_UNKNOWN unk_10954C84; // weak
_UNKNOWN unk_10954C8C; // weak
_UNKNOWN unk_10954C94; // weak
_UNKNOWN unk_10954C9C; // weak
_UNKNOWN unk_10954CA4; // weak
_UNKNOWN unk_10954CAC; // weak
_UNKNOWN unk_10954CB4; // weak
_UNKNOWN unk_10954CBC; // weak
_UNKNOWN unk_10954CC4; // weak
_UNKNOWN unk_10954CCC; // weak
_UNKNOWN unk_10954CD4; // weak
_UNKNOWN unk_10954CDC; // weak
_UNKNOWN unk_10954CE4; // weak
_UNKNOWN unk_10954CEC; // weak
_UNKNOWN unk_10954CF4; // weak
_UNKNOWN unk_10954CFC; // weak
_UNKNOWN unk_10954D04; // weak
_UNKNOWN unk_10954D0C; // weak
_UNKNOWN unk_10954D14; // weak
_UNKNOWN unk_10954D1C; // weak
_UNKNOWN unk_10954D24; // weak
_UNKNOWN unk_10954D2C; // weak
_UNKNOWN unk_10954D34; // weak
_UNKNOWN unk_10954D3C; // weak
_UNKNOWN unk_10954D44; // weak
_UNKNOWN unk_10954D4C; // weak
_UNKNOWN unk_10954D54; // weak
_UNKNOWN unk_10954D5C; // weak
_UNKNOWN unk_10954D64; // weak
_UNKNOWN unk_10954D6C; // weak
_UNKNOWN unk_10954F54; // weak
_UNKNOWN unk_10954F64; // weak
_UNKNOWN unk_10954F74; // weak
_UNKNOWN unk_10954F84; // weak
_UNKNOWN unk_10954F85; // weak
_UNKNOWN unk_10954F86; // weak
_UNKNOWN unk_10954F88; // weak
_UNKNOWN unk_10954F8C; // weak
_UNKNOWN unk_10955034; // weak
_UNKNOWN unk_10955038; // weak
_UNKNOWN unk_1095503C; // weak
_UNKNOWN unk_1095508C; // weak
_UNKNOWN unk_10955090; // weak
_UNKNOWN unk_10955094; // weak
_UNKNOWN unk_10955184; // weak
_UNKNOWN unk_10955274; // weak
_UNKNOWN unk_10955278; // weak
_UNKNOWN unk_10955280; // weak
_UNKNOWN unk_10955288; // weak
_UNKNOWN unk_10955290; // weak
_UNKNOWN unk_10955298; // weak
_UNKNOWN unk_109552A0; // weak
_UNKNOWN unk_109552A8; // weak
_UNKNOWN unk_109552B0; // weak
_UNKNOWN unk_109552B8; // weak
_UNKNOWN unk_109552C0; // weak
_UNKNOWN unk_109552C8; // weak
_UNKNOWN unk_109552D0; // weak
_UNKNOWN unk_109552D4; // weak
_UNKNOWN unk_109552D8; // weak
_UNKNOWN unk_109552DC; // weak
_UNKNOWN unk_10955330; // weak
_UNKNOWN unk_10955384; // weak
_UNKNOWN unk_1095538C; // weak
_UNKNOWN unk_10955390; // weak
_UNKNOWN unk_10955394; // weak
_UNKNOWN unk_10955398; // weak
_UNKNOWN unk_1095539C; // weak
_UNKNOWN unk_109555A4; // weak
_UNKNOWN unk_10955704; // weak
_UNKNOWN unk_1095571C; // weak
_UNKNOWN unk_10955734; // weak
_UNKNOWN unk_1095573E; // weak
_UNKNOWN unk_10955740; // weak
_UNKNOWN unk_10955750; // weak
_UNKNOWN unk_10955754; // weak
_UNKNOWN unk_10955758; // weak
_UNKNOWN unk_1095575C; // weak
_UNKNOWN unk_1095575D; // weak
_UNKNOWN unk_10955760; // weak
_UNKNOWN unk_109557B0; // weak
_UNKNOWN unk_109557B4; // weak
_UNKNOWN unk_109557B5; // weak
_UNKNOWN unk_109557B6; // weak
_UNKNOWN unk_109557B7; // weak
_UNKNOWN unk_109557CB; // weak
_UNKNOWN unk_109557CC; // weak
_UNKNOWN unk_109557CD; // weak
_UNKNOWN unk_109557CE; // weak
_UNKNOWN unk_109557D0; // weak
_UNKNOWN unk_10955870; // weak
_UNKNOWN unk_109558C0; // weak
_UNKNOWN unk_109558C4; // weak
_UNKNOWN unk_109558C8; // weak
_UNKNOWN unk_109558CC; // weak
_UNKNOWN unk_109558D0; // weak
_UNKNOWN unk_109558D4; // weak
_UNKNOWN unk_109558D8; // weak
_UNKNOWN unk_109558DC; // weak
_UNKNOWN unk_109558E0; // weak
_UNKNOWN unk_109558E4; // weak
_UNKNOWN unk_109558E8; // weak
_UNKNOWN unk_109558EC; // weak
_UNKNOWN unk_109558F0; // weak
_UNKNOWN unk_10955A30; // weak
_UNKNOWN unk_10955A3C; // weak
_UNKNOWN unk_10955A84; // weak
_UNKNOWN unk_10955A85; // weak
_UNKNOWN unk_10955AB0; // weak
_UNKNOWN unk_10955AE0; // weak
_UNKNOWN unk_10955B08; // weak
_UNKNOWN unk_10955B0C; // weak
_UNKNOWN unk_10955B10; // weak
_UNKNOWN unk_10955B14; // weak
_UNKNOWN unk_10955B44; // weak
_UNKNOWN unk_10955B45; // weak
_UNKNOWN unk_10955B46; // weak
_UNKNOWN unk_10955B48; // weak
_UNKNOWN unk_10955B4C; // weak
_UNKNOWN unk_10955B50; // weak
_UNKNOWN unk_10955B54; // weak
_UNKNOWN unk_10955B58; // weak
_UNKNOWN unk_10955B5C; // weak
_UNKNOWN unk_10955B60; // weak
_UNKNOWN unk_10955B64; // weak
_UNKNOWN unk_10955B68; // weak
_UNKNOWN unk_10955B6C; // weak
_UNKNOWN unk_10955ECC; // weak
_UNKNOWN unk_10955ED0; // weak
_UNKNOWN unk_10955EDA; // weak
_UNKNOWN unk_10955EE4; // weak
int dword_109576A0; // weak
char byte_109576A8[100]; // idb
int dword_1095770C; // weak
int dword_10957710; // weak
int dword_10957714; // weak
int dword_10957718; // weak
int dword_1095771C; // weak
int dword_10957720; // weak
int dword_10957724; // weak
int dword_10957728; // weak
float flt_1095772C; // weak
float flt_10957730; // weak
char byte_10957734; // weak
int dword_10957738; // weak
int dword_10957740; // weak
char byte_10957748[]; // weak
char byte_1095774C[]; // weak
char byte_1095774D[]; // weak
int dword_10957754[]; // weak
int dword_1095775C[]; // weak
char byte_10957790; // weak
char byte_10957791; // weak
char byte_10957792; // weak
char byte_10957793; // weak
_UNKNOWN unk_109577B4; // weak
int dword_109578F8; // weak
_UNKNOWN unk_10957900; // weak
char byte_10957919[]; // weak
char byte_10957BD8[]; // weak
char byte_10957BD9[]; // weak
char byte_10957BF8[]; // weak
char byte_10957BF9[]; // weak
_UNKNOWN unk_10958E40; // weak
int dword_1095A7F0; // weak
int dword_1095A7F4; // weak
int dword_1095A7FC[]; // weak
_UNKNOWN unk_1095A810; // weak
_UNKNOWN unk_1095D718; // weak
_UNKNOWN unk_1095DC18; // weak
_UNKNOWN unk_1095DCC0; // weak
int dword_1095DCE0; // weak
char byte_1095DCE4; // weak
char byte_1095DCE5; // weak
char byte_1095DCE8; // weak
_UNKNOWN unk_1095DD2A; // weak
_UNKNOWN unk_1095DD52; // weak
char byte_1095DD7B[]; // weak
char byte_1095DD86[]; // weak
float flt_1095FC68; // weak
float flt_1095FC6C; // weak
int dword_1095FC70; // weak
char byte_1095FC78[]; // weak
char byte_1095FC82[]; // weak
_UNKNOWN unk_1095FC91; // weak
_UNKNOWN unk_1095FCB9; // weak
_UNKNOWN unk_1095FCBE; // weak
_UNKNOWN unk_1095FEAA; // weak
_UNKNOWN unk_1095FF51; // weak
_UNKNOWN unk_1095FF52; // weak
_UNKNOWN unk_1095FF71; // weak
_UNKNOWN unk_1095FF98; // weak
_UNKNOWN unk_1095FF99; // weak
_UNKNOWN unk_1095FFB8; // weak
char byte_10960144; // weak
__int16 word_10960718[]; // weak
__int16 word_1096071A[]; // weak
__int16 word_1096071C[]; // weak
__int16 word_1096071E[]; // weak
__int16 word_10960720[]; // weak
__int16 word_10960EE8[]; // weak
__int16 word_10960EEA[]; // weak
__int16 word_10960EEC[]; // weak
__int16 word_10960EEE[]; // weak
__int16 word_10960EF0[]; // weak
_UNKNOWN unk_109616B8; // weak
_UNKNOWN unk_10961742; // weak
_UNKNOWN unk_10965540; // weak
_UNKNOWN unk_10965541; // weak
_UNKNOWN unk_109655C2; // weak
_UNKNOWN unk_109655DD; // weak
_UNKNOWN unk_109655E2; // weak
_UNKNOWN unk_109658B1; // weak
_UNKNOWN unk_109658B2; // weak
_UNKNOWN unk_10965931; // weak
char byte_10965DD2; // weak
char byte_10965DD3; // weak
int dword_10965DD4; // weak
int dword_10965DD8; // weak
int dword_10965DDC; // weak
int dword_10965DE0; // weak
char byte_10965DE4; // weak
char byte_109C83C0[]; // weak
char byte_109C83C1[]; // weak
_UNKNOWN unk_109C8460; // weak
int dword_109C8730[]; // weak
int dword_109C8734[]; // weak
char byte_109C8C50; // weak
char byte_109C8C51; // weak
char byte_109C8C52; // weak
char byte_109C8C53; // weak
_UNKNOWN unk_109C8C58; // weak
_UNKNOWN unk_109C8C78; // weak
int dword_109C8C98; // weak
_UNKNOWN unk_109C8CA0; // weak
int dword_109CA1E0; // weak
int dword_109CA1E4; // weak
int dword_109CA1E8; // weak
int dword_109CA1EC; // weak
int dword_109CA1F8[]; // weak
int dword_109CA1FC; // weak
int dword_109CA200; // weak
int dword_109CA204; // weak
int dword_109CA208; // weak
int dword_109CA20C[]; // weak
int dword_109CA210; // weak
int dword_109CA214; // weak
int dword_109CA218; // weak
int dword_109CA21C; // weak
_UNKNOWN unk_109CA220; // weak
char byte_109CA338; // idb
char byte_109CA438[254]; // idb
char byte_109CA536[]; // weak
char byte_109CA537[]; // weak
char byte_109CA938[2800]; // idb
char byte_109CB428[1022]; // idb
char byte_109CB826[]; // weak
char byte_109CB827[]; // weak
char byte_109CB828[1022]; // idb
char byte_109CBC26[]; // weak
char byte_109CBC27[]; // weak
char byte_109CBC28[1022]; // idb
char byte_109CC026[]; // weak
char byte_109CC027[]; // weak
int dword_109CF028[]; // weak
int dword_109CF03C[]; // weak
char byte_109CF050[2800]; // idb
char byte_109CFB40[2800]; // idb
char byte_109D0630[2800]; // idb
int dword_109D1120[]; // weak
int dword_109D1134[]; // weak
char byte_109D1148[2796]; // idb
char byte_109D1C34[]; // weak
char byte_109D1C38[559]; // idb
char byte_109D1E67[]; // weak
int dword_109D2728[]; // weak
int dword_109D273C[]; // weak
char byte_109D2750[2800]; // idb
int dword_109D3240; // weak
_UNKNOWN unk_109D3248; // weak
_UNKNOWN unk_109D3DA0; // weak
__int16 word_109D6108[]; // weak
char byte_109D610A[]; // weak
__int16 word_109D610C; // weak
char byte_109D610E; // weak
int dword_109D6AD8[]; // weak
int dword_109D6ADC[]; // weak
int dword_109D6AE0[]; // weak
int dword_109D6AE4[]; // weak
int dword_109D6AE8[]; // weak
int dword_109D6AEC[]; // weak
int dword_109D6AF0[]; // weak
int dword_109D6AF4[]; // weak
int dword_109D6AF8[]; // weak
int dword_109D6AFC[]; // weak
int dword_109D6B00[]; // weak
int dword_109D6B04[]; // weak
int dword_109D6B08[]; // weak
int dword_109D6B34; // weak
int dword_109D6B38; // weak
int dword_109D6B3C; // weak
int dword_109D6B40; // weak
int dword_109D6B44; // weak
int dword_109D6B48; // weak
int dword_109D6B4C; // weak
int dword_109D6B50; // weak
int dword_109D6B54; // weak
int dword_109D6B58; // weak
int dword_109E4350; // weak
char byte_109E4358[]; // weak
char byte_109E43A8[]; // weak
_DWORD dword_109FF070[16]; // idb
int dword_109FF0B0[]; // weak
int dword_109FF0F0; // weak
int dword_109FF0F8[]; // weak
int dword_109FF168; // weak
int dword_109FF494; // weak
int dword_109FF4F0; // weak
int dword_109FF4FC; // weak
int dword_109FF7B8; // weak
int dword_109FFAE0; // weak
int dword_109FFAEC; // weak
int dword_109FFAF8; // weak
int dword_109FFAFC; // weak
int dword_109FFBC8; // weak
int dword_109FFBCC; // weak
int dword_109FFBD0; // weak
int dword_109FFBD4; // weak
int dword_109FFBD8; // weak
int dword_109FFBDC; // weak
char byte_109FFDC8[]; // weak
int dword_109FFDCC; // weak
int dword_10A000A0; // weak
_UNKNOWN unk_10A000C0; // weak
_UNKNOWN unk_10A05900; // weak
_UNKNOWN unk_10A085E0; // weak
int dword_10A08A5C; // weak
int dword_10A08A60; // weak
__int16 word_10A08A64; // weak
char byte_10A08A80; // weak
char byte_10A08A81; // weak
char byte_10A08A82; // weak
char byte_10A08A83; // weak
int dword_10A08A84; // weak
int dword_10A08A8C; // weak
int dword_10A08A90; // weak
int dword_10A08A94; // weak
int dword_10A08A98; // weak
int dword_10A08A9C; // weak
int dword_10A08AA0; // weak
int dword_10A08AA4; // weak
int dword_10A08AA8; // weak
int dword_10A08AAC; // weak
int dword_10A08AB0; // weak
int dword_10A08AB4; // weak
int dword_10A08AB8; // weak
int dword_10A08ABC; // weak
int dword_10A08AC0; // weak
int dword_10A08AC4; // weak
int dword_10A08AC8; // weak
int dword_10A08ACC; // weak
int dword_10A08AD0; // weak
int dword_10A08AD4; // weak
_UNKNOWN unk_10A08AE0; // weak
__int16 word_10A08CE0; // weak
int dword_10A09200; // weak
int dword_10A09204; // weak
char byte_10A09208; // weak
int dword_10A0920C; // weak
char byte_10A09210; // weak
int dword_10A09214; // weak
char byte_10A09218; // weak
int dword_10A0921C; // weak
int dword_10A09220; // weak
int dword_10A09228; // weak
char byte_10A0922C; // weak
char byte_10A0922D; // weak
int dword_10A09240[]; // weak
__int16 word_10A09244[]; // weak
int dword_10A09248[]; // weak
int dword_10A0924C; // weak
int dword_10A09250; // weak
int dword_10A09254; // weak
int dword_10A09258; // weak
__int16 word_10A0925C; // weak
int dword_10A09260; // weak
int dword_10A09264; // weak
__int16 word_10A09268; // weak
__int16 word_10A092A4; // weak
int dword_10A092A8; // weak
int dword_10A092C4; // weak
__int16 word_10A092C8; // weak
int dword_10A09308; // weak
int dword_10A09338; // weak
int dword_10A09380; // weak
int dword_10A09428; // weak
int dword_10A09434; // weak
int dword_10A09444; // weak
__int16 word_10A09448; // weak
int dword_10A09450; // weak
__int16 word_10A09454; // weak
int dword_10A0945C; // weak
__int16 word_10A09460; // weak
int dword_10A09564; // weak
int dword_10A095D0; // weak
int dword_10A095DC; // weak
__int16 word_10A095E0; // weak
int dword_10A09684; // weak
__int16 word_10A09688; // weak
_UNKNOWN unk_10A09948; // weak
_UNKNOWN unk_10A09949; // weak
_UNKNOWN unk_10A0994A; // weak
__int16 word_10A09960[]; // weak
__int16 word_10A09962; // weak
__int16 word_10A09964; // weak
__int16 word_10A09966; // weak
__int16 word_10A09968; // weak
__int16 word_10A0996A; // weak
__int16 word_10A0996C; // weak
__int16 word_10A0996E; // weak
__int16 word_10A09984; // weak
__int16 word_10A09986; // weak
char byte_10A09A8C; // weak
char byte_10A09A8D; // weak
int dword_10A09A90; // weak
char byte_10A09A94; // weak
int dword_10A09A98; // weak
int dword_10A09AA0; // weak
char byte_10A09AA4; // weak
int dword_10A09AA8; // weak
int dword_10A09AAC; // weak
int dword_10A09AB0; // weak
int dword_10A09AB4; // weak
int dword_10A09AB8; // weak
int dword_10A09ABC; // weak
int dword_10A09AC0; // weak
int dword_10A09AC4; // weak
int dword_10A09AC8; // weak
int dword_10A09ACC; // weak
int dword_10A09AD0; // weak
int dword_10A09AEC; // weak
UINT uNumber; // idb
int dword_10A09B00[]; // weak
int dword_10A09C00; // weak
void *dword_10A09C18; // idb
int dword_10A0AC20; // weak
int dword_10A0AC28; // weak


//----- (10001000) --------------------------------------------------------
char __cdecl sub_10001000(__int16 a1, int a2)
{
  unsigned __int8 v2; // bl@2
  char result; // al@2

  if ( a1 == 571 )
  {
    v2 = byte_1013B7E0;
    memcpy(
      (void *)(dword_10A09AD0 + 6916 * (unsigned __int8)byte_1013B7E0),
      *(const void **)(*(_DWORD *)(a2 + 48) + 8),
      0x1B04u);
    sub_10028EA0(v2);
    result = byte_1013B7E0++ + 1;
    if ( (unsigned __int8)byte_1013B7E0 >= 0xAu )
      byte_1013B7E0 = 0;
  }
  return result;
}
// 1013B7E0: using guessed type char byte_1013B7E0;
// 10A09AD0: using guessed type int dword_10A09AD0;

//----- (10001060) --------------------------------------------------------
char __cdecl sub_10001060(unsigned __int16 a1)
{
  char result; // al@1
  char v2; // [sp+0h] [bp-1B08h]@1

  memset(&v2, 0, 0x1B04u);
  result = sub_10028F80(1, a1, &v2);
  if ( result )
  {
    sub_10015560(2, 571, &v2, 0, 6916, 1);
    result = sub_10015710(2, 571, 4);
  }
  return result;
}

//----- (100010F0) --------------------------------------------------------
int sub_100010F0()
{
  return sub_10060A90(2, 0x80000);
}

//----- (10001100) --------------------------------------------------------
char sub_10001100()
{
  int v0; // edx@1
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // ecx@1
  void *v4; // ecx@1
  void *v5; // ecx@1
  char result; // al@2
  unsigned int v7; // [sp+0h] [bp-4h]@1

  sub_10061050();
  sub_1002C050();
  sub_10020D90();
  sub_1002BB80();
  sub_1002BB10();
  sub_1002BA40();
  nullsub_1(v1, v0);
  sub_1002BA30(v3, v2);
  sub_10029C30();
  sub_10014DE0();
  sub_10029810();
  sub_10002CB0(v4);
  sub_100294B0();
  sub_10020D80();
  sub_10029400();
  sub_100011F0();
  sub_100012B0();
  sub_10022C40();
  sub_10060B20(5);
  sub_10002C60();
  sub_100293E0();
  v7 = (unsigned int)&v7 ^ __security_cookie;
  memset(&unk_1043BE98, 0, 0xE8u);
  dword_1043BE74 = 0;
  dword_1043BE78 = 0;
  dword_1043BE7C = 0;
  dword_1043BE80 = 0;
  dword_1043BE84 = 0;
  dword_1043BE88 = 0;
  dword_1043BE8C = 0;
  byte_1043BE90 = 0;
  memset(&unk_10439790, 0, 0x26DBu);
  LOBYTE(dword_1043BE74) = -1;
  byte_1043BE6B = 2;
  dword_1043BE6C = sub_10060900();
  dword_1043D3C4 = sub_10060900();
  dword_1043BE70 = sub_10060900();
  dword_1043BE94 = sub_10060900();
  dword_1043BF80 = sub_10060900();
  byte_1043BE92 = 0;
  dword_1043D3D8 = 0;
  byte_1043978E = 1;
  sub_1000B380();
  sub_1000B4F0();
  byte_1043BE93 = 0;
  sub_1000C9F0();
  byte_1043BE91 = 0;
  if ( (unsigned __int8)sub_10032520() || (result = sub_1002C5E0(v5), result == 2) )
    result = sub_10060A90(48, 16);
  return result;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10061050: using guessed type int sub_10061050(void);
// 1043978E: using guessed type char byte_1043978E;
// 1043BE6B: using guessed type char byte_1043BE6B;
// 1043BE6C: using guessed type int dword_1043BE6C;
// 1043BE70: using guessed type int dword_1043BE70;
// 1043BE74: using guessed type int dword_1043BE74;
// 1043BE78: using guessed type int dword_1043BE78;
// 1043BE7C: using guessed type int dword_1043BE7C;
// 1043BE80: using guessed type int dword_1043BE80;
// 1043BE84: using guessed type int dword_1043BE84;
// 1043BE88: using guessed type int dword_1043BE88;
// 1043BE8C: using guessed type int dword_1043BE8C;
// 1043BE90: using guessed type char byte_1043BE90;
// 1043BE91: using guessed type char byte_1043BE91;
// 1043BE92: using guessed type char byte_1043BE92;
// 1043BE93: using guessed type char byte_1043BE93;
// 1043BE94: using guessed type int dword_1043BE94;
// 1043BF80: using guessed type int dword_1043BF80;
// 1043D3C4: using guessed type int dword_1043D3C4;
// 1043D3D8: using guessed type int dword_1043D3D8;

//----- (10001180) --------------------------------------------------------
char __cdecl sub_10001180(int a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@2
  unsigned int v3; // ecx@2
  int v4; // esi@3
  int v5; // edx@5
  char result; // al@9
  unsigned int v7; // [sp+8h] [bp-4h]@1

  v1 = 0;
  v7 = sub_10060900();
  if ( *(_BYTE *)(a1 + 1) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    v3 = 0;
    if ( v2 )
    {
      v4 = 0;
      do
      {
        if ( v1 )
          break;
        v5 = *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8 * v3 + 4);
        if ( v7 < v5 + *(_DWORD *)(*(_DWORD *)(a1 + 16) + v4 + 12) )
        {
          if ( v5 )
            v1 = 1;
        }
        ++v3;
        v4 += 24;
      }
      while ( v3 < v2 );
      result = v1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100011F0) --------------------------------------------------------
void sub_100011F0()
{
  dword_1013B8E8 = -15;
}
// 1013B8E8: using guessed type int dword_1013B8E8;

//----- (10001200) --------------------------------------------------------
signed int sub_10001200()
{
  return sub_10061AA0((int)&off_1007F9D0);
}
// 1007F9D0: using guessed type char *off_1007F9D0;

//----- (10001210) --------------------------------------------------------
char __cdecl sub_10001210(char a1)
{
  int v1; // ecx@3
  int v2; // eax@3
  char result; // al@6
  char v4; // [sp+8h] [bp-20h]@3
  int v5; // [sp+18h] [bp-10h]@5
  int v6; // [sp+20h] [bp-8h]@5

  if ( (unsigned __int8)sub_10001200() != 1 )
    goto LABEL_6;
  switch ( a1 )
  {
    case 3:
    case 5:
      qmemcpy(&v4, (const void *)dword_1013B8E8, 0x20u);
      v1 = dword_1013B8E8 + 608;
      v2 = dword_1013B8E8 + 32;
      break;
    case 4:
    case 6:
      qmemcpy(&v4, (const void *)(dword_1013B8E8 + 304), 0x20u);
      v1 = dword_1013B8E8 + 608;
      v2 = dword_1013B8E8 + 336;
      break;
    default:
      goto LABEL_6;
  }
  v5 = v1;
  v6 = v2;
  if ( sub_10001180((int)&v4) )
    result = 2;
  else
LABEL_6:
    result = 1;
  return result;
}
// 1013B8E8: using guessed type int dword_1013B8E8;

//----- (100012B0) --------------------------------------------------------
void sub_100012B0()
{
  dword_1013B8EC = -15;
}
// 1013B8EC: using guessed type int dword_1013B8EC;

//----- (100012C0) --------------------------------------------------------
signed int sub_100012C0()
{
  return sub_10061AA0((int)&off_1007FA04);
}
// 1007FA04: using guessed type char *off_1007FA04;

//----- (100012D0) --------------------------------------------------------
char __cdecl sub_100012D0(char a1)
{
  int v1; // ecx@3
  int v2; // eax@3
  char result; // al@6
  char v4; // [sp+8h] [bp-20h]@3
  int v5; // [sp+18h] [bp-10h]@5
  int v6; // [sp+20h] [bp-8h]@5

  if ( (unsigned __int8)sub_100012C0() != 1 )
    goto LABEL_6;
  switch ( a1 )
  {
    case 1:
    case 7:
    case 9:
      qmemcpy(&v4, (const void *)dword_1013B8EC, 0x20u);
      v1 = dword_1013B8EC + 320;
      v2 = dword_1013B8EC + 32;
      break;
    case 2:
    case 8:
    case 0xA:
      qmemcpy(&v4, (const void *)(dword_1013B8EC + 160), 0x20u);
      v1 = dword_1013B8EC + 320;
      v2 = dword_1013B8EC + 192;
      break;
    default:
      goto LABEL_6;
  }
  v5 = v1;
  v6 = v2;
  if ( sub_10001180((int)&v4) )
    result = 2;
  else
LABEL_6:
    result = 1;
  return result;
}
// 1013B8EC: using guessed type int dword_1013B8EC;

//----- (10001380) --------------------------------------------------------
char __usercall sub_10001380@<al>(char a1@<dl>, int a2@<ecx>, int a3)
{
  __int16 v4; // [sp+0h] [bp-52Ch]@1
  int v5; // [sp+4h] [bp-528h]@1
  int v6; // [sp+8h] [bp-524h]@1
  char v7; // [sp+Ch] [bp-520h]@1

  v5 = a3;
  v4 = -32697;
  v6 = a2;
  v7 = a1;
  return sub_1002CC40((int)&v4);
}

//----- (100013D0) --------------------------------------------------------
char __cdecl sub_100013D0(int a1, int a2, char a3)
{
  return sub_10001380(a3, a2, a1);
}

//----- (100013F0) --------------------------------------------------------
char __cdecl sub_100013F0(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@2
  char v4; // [sp+8h] [bp-14h]@2
  char v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+10h] [bp-Ch]@1
  char v7; // [sp+14h] [bp-8h]@2

  result = sub_100144D0(a1, a2, &v6, (unsigned __int16 *)&v5);
  if ( result )
  {
    v3 = sub_10012AC0(a1, a2);
    v4 = 2;
    if ( !v7 )
      v4 = 3;
    result = sub_100013D0(v3, v6, v4);
  }
  return result;
}

//----- (10001460) --------------------------------------------------------
char __cdecl sub_10001460(int a1, int a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, char a8)
{
  int v8; // eax@1
  char result; // al@1
  int v10; // [sp+4h] [bp-18h]@1
  int v11; // [sp+8h] [bp-14h]@1
  int v12; // [sp+Ch] [bp-10h]@1
  int v13; // [sp+10h] [bp-Ch]@1
  int v14; // [sp+14h] [bp-8h]@1

  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = a6;
  v8 = sub_10060900();
  sub_10013920(655, a7, 1, (int)&byte_10A08A80, &v10, v8);
  result = sub_10013C10(655, a1, (int)&byte_10A08A80);
  if ( a8 )
    result = sub_100013D0(a1, v10, 1);
  return result;
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10001500) --------------------------------------------------------
char sub_10001500()
{
  return *(_BYTE *)(dword_101410F8 + 3);
}
// 101410F8: using guessed type int dword_101410F8;

//----- (10001510) --------------------------------------------------------
int sub_10001510()
{
  return dword_1013B8F4;
}
// 1013B8F4: using guessed type int dword_1013B8F4;

//----- (10001520) --------------------------------------------------------
char sub_10001520()
{
  return *(_BYTE *)(dword_101410F8 + 1);
}
// 101410F8: using guessed type int dword_101410F8;

//----- (10001530) --------------------------------------------------------
void sub_10001530()
{
  ++dword_1013B8F4;
}
// 1013B8F4: using guessed type int dword_1013B8F4;

//----- (10001540) --------------------------------------------------------
int (__cdecl *sub_10001540())(_DWORD)
{
  int (__cdecl *result)(_DWORD); // eax@1

  result = sub_1000CEA0;
  if ( sub_1000CEA0 )
    result = (int (__cdecl *)(_DWORD))sub_1000CEA0(17);
  return result;
}
// 1000CEA0: using guessed type int __cdecl sub_1000CEA0(_DWORD);

//----- (10001550) --------------------------------------------------------
int __cdecl sub_10001550(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7)
{
  int v7; // eax@2
  int result; // eax@6

  *(_BYTE *)(dword_101410F8 + 3) = a3;
  if ( a5 )
  {
    v7 = dword_101410F8 + 5;
    *(_WORD *)v7 = *(_WORD *)a5;
    *(_BYTE *)(v7 + 2) = *(_BYTE *)(a5 + 2);
  }
  if ( a7 > 0x27100 )
  {
    *(_DWORD *)(dword_101410F8 + 160008) = 0;
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 1412, 0, 0);
  }
  else
  {
    memcpy((void *)(dword_101410F8 + 8), a6, a7);
    *(_DWORD *)(dword_101410F8 + 160008) = a7;
  }
  result = dword_101410F8;
  *(_BYTE *)(dword_101410F8 + 4) = a4;
  LOBYTE(result) = a2;
  *(_BYTE *)(dword_101410F8 + 2) = a2;
  *(_BYTE *)(dword_101410F8 + 1) = a1;
  return result;
}
// 101410F8: using guessed type int dword_101410F8;

//----- (10001600) --------------------------------------------------------
void *__cdecl sub_10001600(int a1)
{
  int v1; // eax@7
  int (__cdecl *v2)(_DWORD, _DWORD, _DWORD, int, int, int); // ecx@8
  void *result; // eax@9

  *(_BYTE *)dword_101410F8 = a1;
  switch ( (unsigned __int8)a1 )
  {
    case 7u:
      dword_1013B8F0 = sub_10060900();
      break;
    case 8u:
      dword_10141104 = sub_10060900();
      break;
    case 9u:
      dword_10141108 = sub_10060900();
      break;
  }
  v1 = sub_1002CC90((_DWORD *)(dword_101410F8 + 2), 1u, (int)byte_100823E8, 44, 1, 57);
  if ( v1 >= 57
    || (v2 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, int))*(&off_10082408 + 11 * v1)) == 0
    || (result = (void *)v2(
                           *(_BYTE *)(dword_101410F8 + 2),
                           *(_BYTE *)(dword_101410F8 + 3),
                           *(_BYTE *)(dword_101410F8 + 4),
                           dword_101410F8 + 5,
                           a1,
                           dword_101410F8 + 160012),
        !(_BYTE)result) )
  {
    result = memset((void *)(dword_101410F8 + 160012), 0, 0x64u);
  }
  return result;
}
// 10082408: using guessed type int (__cdecl *off_10082408)(char, int, int, int, char, char *);
// 1013B8F0: using guessed type int dword_1013B8F0;
// 101410F8: using guessed type int dword_101410F8;
// 10141104: using guessed type int dword_10141104;
// 10141108: using guessed type int dword_10141108;

//----- (100016C0) --------------------------------------------------------
signed int __usercall sub_100016C0@<eax>(unsigned int a1@<eax>, int a2, char *a3, unsigned __int16 a4)
{
  __int16 v4; // bx@1
  unsigned int v5; // edx@1
  unsigned int v6; // esi@1
  signed int result; // eax@2
  void *v8; // eax@3
  unsigned int v9; // ecx@5
  int v10; // edx@13
  signed int v11; // ebx@13
  char *v12; // ecx@14
  int v13; // esi@14
  int v14; // eax@18
  unsigned int v15; // edi@18
  int v16; // eax@19
  unsigned int v17; // edx@19
  int v18; // eax@20
  int v19; // ecx@23
  bool v20; // cf@34
  char v21; // [sp+Ah] [bp-96h]@17
  char v22; // [sp+Bh] [bp-95h]@17
  int v23; // [sp+Ch] [bp-94h]@1
  int v24; // [sp+10h] [bp-90h]@18
  char *v25; // [sp+14h] [bp-8Ch]@14
  int v26; // [sp+18h] [bp-88h]@13
  int v27[32]; // [sp+20h] [bp-80h]@7

  v4 = word_10A08CE0;
  v5 = 0;
  v6 = a1;
  v23 = 0;
  if ( word_10A08CE0 == 1491 )
  {
    result = 0;
  }
  else
  {
    v8 = &unk_10A08AE0;
    do
    {
      if ( *((_WORD *)v8 + 2) == v4 )
      {
        v9 = *(_WORD *)v8;
        if ( v6 >= v9 && v6 < v9 + *((_WORD *)v8 + 1) )
        {
          v27[v23++] = (int)v8;
          if ( *((_DWORD *)v8 + 2) == -1 && *((_DWORD *)v8 + 3) == -1 )
            return 0;
        }
      }
      v5 += 16;
      v8 = (char *)v8 + 16;
    }
    while ( v5 < 0x200 );
    if ( v23 )
    {
      v10 = 0;
      v11 = 0;
      v26 = 0;
      if ( a4 )
      {
        v12 = a3;
        v13 = a2 - (_DWORD)a3;
        v25 = a3;
        while ( !v11 )
        {
          v22 = v12[v13];
          v21 = *v12;
          if ( v22 != *v12 )
          {
            v14 = 0;
            v15 = 8 * v10;
            v11 = -34;
            v24 = 0;
            if ( v23 > 0 )
            {
              while ( 1 )
              {
                v16 = v27[v14];
                v17 = *(_DWORD *)(v16 + 8);
                if ( v15 + 7 >= v17 )
                {
                  v18 = *(_DWORD *)(v16 + 12);
                  if ( v15 < v18 + v17 )
                    break;
                }
LABEL_31:
                v14 = v24++ + 1;
                if ( v24 >= v23 )
                  goto LABEL_34;
              }
              if ( v17 & 7 || v18 & 7 )
              {
                v19 = 0;
                while ( 1 )
                {
                  if ( (1 << v19) & (unsigned __int8)(v21 ^ v22) )
                  {
                    if ( v19 + v15 < v17 || v19 + v15 >= v18 + v17 )
                    {
                      v11 = -34;
                      goto LABEL_31;
                    }
                    v11 = 0;
                  }
                  if ( (unsigned int)++v19 >= 8 )
                    goto LABEL_31;
                }
              }
              v11 = 0;
            }
          }
LABEL_34:
          v10 = v26 + 1;
          v12 = v25 + 1;
          v20 = v26++ + 1 < (unsigned int)a4;
          ++v25;
          if ( !v20 )
          {
            if ( !v11 )
              goto LABEL_37;
            break;
          }
          v13 = a2 - (_DWORD)a3;
        }
        sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 2449, 0, "no perm for reg_tag bits\n");
      }
LABEL_37:
      result = v11;
    }
    else
    {
      sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 2367, 0, "no perm for reg_tag\n");
      result = -34;
    }
  }
  return result;
}
// 10A08CE0: using guessed type __int16 word_10A08CE0;
// 100016C0: using guessed type int var_80[32];

//----- (100018A0) --------------------------------------------------------
signed int sub_100018A0()
{
  signed int result; // eax@2

  if ( sub_10061B70((LONG)&off_10082414) )
  {
    *(_BYTE *)dword_101410F8 = 0;
    *(_BYTE *)(dword_101410F8 + 2) = 67;
    result = sub_10061700((int)&off_10082414);
  }
  else
  {
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 2504, 1, 0);
    result = sub_10061700((int)&off_10082414);
  }
  return result;
}
// 10082414: using guessed type char *off_10082414;
// 101410F8: using guessed type int dword_101410F8;

//----- (100018F0) --------------------------------------------------------
void *sub_100018F0()
{
  void *result; // eax@1

  result = (void *)(sub_10060900() - dword_10141108);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10001600(0);
  return result;
}
// 10141108: using guessed type int dword_10141108;

//----- (10001910) --------------------------------------------------------
void *sub_10001910()
{
  void *result; // eax@1

  result = (void *)(sub_10060900() - dword_1013B8F0);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10001600(0);
  return result;
}
// 1013B8F0: using guessed type int dword_1013B8F0;

//----- (10001930) --------------------------------------------------------
void *sub_10001930()
{
  void *result; // eax@1

  result = (void *)(sub_10060900() - dword_10141104);
  if ( (unsigned int)result >= 0x2710 )
    result = sub_10001600(0);
  return result;
}
// 10141104: using guessed type int dword_10141104;

//----- (10001950) --------------------------------------------------------
char __cdecl sub_10001950(char a1, char a2, char a3, char a4, int a5, void *a6, size_t a7)
{
  int v7; // eax@5
  char result; // al@9

  if ( *(_BYTE *)dword_101410F8 == 11 )
    sub_1002CF40();
  if ( *(_BYTE *)dword_101410F8 )
    sub_10001600(0);
  *(_BYTE *)(dword_101410F8 + 3) = a3;
  v7 = dword_101410F8 + 5;
  *(_WORD *)v7 = *(_WORD *)a5;
  *(_BYTE *)(v7 + 2) = *(_BYTE *)(a5 + 2);
  if ( a7 >= 0x27100 )
  {
    *(_DWORD *)(dword_101410F8 + 160008) = 0;
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 1198, 0, 0);
  }
  else
  {
    memcpy((void *)(dword_101410F8 + 8), a6, a7);
    *(_DWORD *)(dword_101410F8 + 160008) = a7;
    *(_BYTE *)(dword_101410F8 + a7 + 8) = 0;
  }
  *(_BYTE *)(dword_101410F8 + 4) = a4;
  *(_BYTE *)(dword_101410F8 + 2) = a2;
  *(_BYTE *)(dword_101410F8 + 1) = a1;
  dword_101410FC = 0;
  dword_1013B8F4 = 0;
  byte_10141100 = 0;
  switch ( a1 )
  {
    case 0:
      result = (unsigned int)sub_10001600(9);
      break;
    case 1:
      result = (unsigned int)sub_10001600(5);
      byte_10141100 = 1;
      break;
    case 2:
      result = (unsigned int)sub_10001600(2);
      break;
    case 3:
      result = (unsigned int)sub_10001600(1);
      break;
    case 4:
    case 6:
      result = (unsigned int)sub_10001600(6);
      break;
    case 5:
      if ( a3 )
        goto LABEL_16;
      result = (unsigned int)sub_10001600(6);
      goto LABEL_17;
    case 7:
LABEL_16:
      result = (unsigned int)sub_10001600(2);
LABEL_17:
      if ( a4 == 11 )
        byte_10141100 = 1;
      break;
    default:
      result = sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 1301, 0, 0);
      break;
  }
  return result;
}
// 1013B8F4: using guessed type int dword_1013B8F4;
// 101410F8: using guessed type int dword_101410F8;
// 101410FC: using guessed type int dword_101410FC;
// 10141100: using guessed type char byte_10141100;

//----- (10001AF0) --------------------------------------------------------
void *sub_10001AF0()
{
  void *result; // eax@1

  dword_101410F8 = -15;
  sub_100018A0();
  result = memset(&unk_10A08AE0, 0, 0x200u);
  word_10A08CE0 = 0;
  dword_10141108 = 0;
  dword_1013B8F0 = 0;
  dword_10141104 = 0;
  dword_1014110C = 0;
  return result;
}
// 1013B8F0: using guessed type int dword_1013B8F0;
// 101410F8: using guessed type int dword_101410F8;
// 10141104: using guessed type int dword_10141104;
// 10141108: using guessed type int dword_10141108;
// 1014110C: using guessed type int dword_1014110C;
// 10A08CE0: using guessed type __int16 word_10A08CE0;

//----- (10001B40) --------------------------------------------------------
char __usercall sub_10001B40@<al>(char *a1@<eax>, int a2@<ebx>, unsigned __int16 a3@<di>, unsigned int a4)
{
  char *v4; // esi@1
  signed int v5; // eax@1
  unsigned int v6; // eax@2
  _DWORD *v7; // ecx@2
  char *v8; // edx@2
  int v9; // esi@6
  int v10; // eax@7
  _BYTE *v11; // ecx@7
  _BYTE *v12; // edx@7
  int v13; // eax@9
  _BYTE *v14; // ecx@9
  _BYTE *v15; // edx@9
  _BYTE *v16; // ecx@11
  _BYTE *v17; // edx@11
  signed int v18; // eax@13
  unsigned __int16 v20; // [sp+0h] [bp-8h]@0

  v4 = a1;
  v5 = sub_100016C0(a4, a2, a1, v20);
  if ( !v5 )
  {
    v6 = a3;
    v7 = (_DWORD *)a2;
    v8 = v4;
    if ( a3 < 4u )
    {
LABEL_5:
      if ( !v6 )
        goto LABEL_15;
    }
    else
    {
      while ( *(_DWORD *)v8 == *v7 )
      {
        v6 -= 4;
        ++v7;
        v8 += 4;
        if ( v6 < 4 )
          goto LABEL_5;
      }
    }
    v9 = (unsigned __int8)*v8 - *(_BYTE *)v7;
    if ( (unsigned __int8)*v8 != *(_BYTE *)v7
      || (v10 = v6 - 1, v11 = (char *)v7 + 1, v12 = v8 + 1, v10)
      && ((v9 = *v12 - *v11, *v12 != *v11)
       || (v13 = v10 - 1, v14 = v11 + 1, v15 = v12 + 1, v13)
       && ((v9 = *v15 - *v14, *v15 != *v14)
        || (v16 = v14 + 1, v17 = v15 + 1, v13 != 1) && (v9 = *v17 - *v16, *v17 != *v16))) )
    {
      v18 = 1;
      if ( v9 <= 0 )
        v18 = -1;
      goto LABEL_16;
    }
LABEL_15:
    v18 = 0;
LABEL_16:
    if ( v18 )
    {
      if ( a4 > 0x1B31 )
        LOBYTE(v5) = sub_10060ED0(a4, a2, a3);
      else
        LOBYTE(v5) = sub_10060EF0(a4, a2, a3);
    }
    else
    {
      LOBYTE(v5) = 0;
    }
  }
  return v5;
}

//----- (10001C10) --------------------------------------------------------
char __cdecl sub_10001C10(char *a1)
{
  int v1; // ecx@0
  char v2; // al@1
  int v3; // esi@1
  _WORD *v4; // esi@2
  int v5; // ebp@3
  int v6; // esi@4
  int v7; // ST24_4@4
  int v8; // ST20_4@4
  int v9; // edi@4
  char v10; // bl@4
  int v11; // eax@4
  __int16 v12; // di@4
  int v13; // eax@6
  int v14; // eax@11
  bool v15; // sf@17
  unsigned __int8 v16; // of@17
  char result; // al@20
  char v18; // ST18_1@23
  char v19; // al@23
  char v20; // [sp+Bh] [bp-99h]@1
  unsigned __int16 v21; // [sp+Ch] [bp-98h]@1
  _WORD *v22; // [sp+10h] [bp-94h]@2
  int v23; // [sp+14h] [bp-90h]@1
  int v24; // [sp+18h] [bp-8Ch]@1
  char v25[4]; // [sp+1Ch] [bp-88h]@1
  int v26; // [sp+20h] [bp-84h]@4
  int v27; // [sp+24h] [bp-80h]@4
  unsigned int v28; // [sp+28h] [bp-7Ch]@4
  char *v29; // [sp+30h] [bp-74h]@1
  char v30; // [sp+34h] [bp-70h]@6
  char v31; // [sp+3Ch] [bp-68h]@8

  v29 = a1;
  v2 = *a1;
  v23 = v1;
  v20 = 0;
  v25[0] = v2;
  v3 = sub_10029770(v2, &v21);
  sub_10060D80(9171, (int)&word_10A08CE0, 2);
  sub_10060D80(6451, (int)&unk_10A08AE0, 512);
  v24 = 0;
  if ( !v21 )
    goto LABEL_18;
  v4 = (_WORD *)(v3 + 2);
  v22 = v4;
  do
  {
    v5 = 0;
    if ( !*v4 )
      goto LABEL_16;
    while ( 1 )
    {
      v6 = v5 + *(v22 - 1);
      v7 = v5 + *(v22 - 1);
      v8 = v5 + *(v22 - 1);
      v26 = 0;
      v27 = 0;
      v28 = 0;
      j_reg_get_tag_hdr(&v26, v8, v7);
      v9 = *(unsigned int *)((char *)&v28 + 2);
      memset(&dword_10141110, 0, HIWORD(v28));
      v10 = 0;
      v11 = sub_10060D80(v6, (int)&dword_10141110, v9);
      v12 = HIWORD(v28);
      if ( v11 )
      {
        v10 = 1;
        memset(&dword_10141110, 0, HIWORD(v28));
      }
      memcpy(&dword_1013B8F8, &dword_10141110, (unsigned __int16)v12);
      v13 = sub_10060DA0(v6, (int)&dword_10141110, v12, v23, (int)&v30);
      if ( !v13 )
        break;
      if ( v13 != -24 )
      {
        sub_1002C2B0(&v31, 0x64u, "error %i reading reg %i from xml\n", v13, v6);
        sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 1946, 0, &v31);
        goto LABEL_15;
      }
LABEL_12:
      if ( ++v5 >= *v22 )
        goto LABEL_16;
    }
    v20 = 1;
    if ( v10 )
      dword_1013B8F8 = ~dword_10141110;
    v14 = (unsigned __int8)sub_10001B40((char *)&dword_1013B8F8, (int)&dword_10141110, HIWORD(v28), v6);
    if ( !(_BYTE)v14 )
      goto LABEL_12;
    sub_1002C2B0(&v31, 0x64u, "error %i writing reg %i oem_id %i\n", v14, v6, (unsigned __int16)word_10A08CE0);
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 1967, 0, &v31);
LABEL_15:
    v20 = 0;
LABEL_16:
    if ( v5 != *v22 )
      break;
    v4 = v22 + 2;
    v16 = __OFSUB__(v24 + 1, v21);
    v15 = v24++ + 1 - v21 < 0;
    v22 += 2;
  }
  while ( v15 ^ v16 );
LABEL_18:
  if ( !sub_10061390(v23) )
  {
    v20 = 0;
    sub_10028BC0(
      "..\\lib\\adl\\iop_cnfg_mngr.c",
      1996,
      0,
      "The file being loaded was deleted during the upload process.");
    goto LABEL_20;
  }
  if ( v20 == 1 )
  {
    if ( *((_DWORD *)v29 + 2) )
    {
      sub_10001600(1);
      v18 = v25[0];
      v19 = sub_10001520();
      sub_10001550(v19, v18, 0, 11, 0, 0, 0);
      sub_100146D0();
      result = v20;
    }
    else
    {
      sub_10001600(7);
      sub_100146D0();
      result = v20;
    }
  }
  else
  {
LABEL_20:
    sub_10001600(8);
    result = v20;
  }
  return result;
}
// 10060D50: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);
// 1013B8F8: using guessed type int dword_1013B8F8;
// 10141110: using guessed type int dword_10141110;
// 10A08CE0: using guessed type __int16 word_10A08CE0;

//----- (10001EF0) --------------------------------------------------------
int sub_10001EF0()
{
  char v0; // bl@1
  int v1; // esi@1
  int v2; // ecx@2
  int (__cdecl *v3)(char, int, int, int, int, int); // esi@3
  char v4; // al@5
  void (__cdecl *v5)(_DWORD); // ecx@12
  int result; // eax@14
  bool v7; // cf@14
  int (__cdecl *v8)(_DWORD, _DWORD, int); // esi@17
  int (__cdecl *v9)(_DWORD, _DWORD, _DWORD, int); // esi@21
  int v10; // edi@23
  char *v11; // eax@23
  int v12; // edx@23
  char v13; // cl@24
  int v14; // ebp@25
  int (__cdecl *v15)(_DWORD, _DWORD, _DWORD, int, int, _DWORD); // esi@29
  char v16; // [sp+8h] [bp-68h]@11

  v0 = 0;
  v1 = sub_1002CC90((_DWORD *)(dword_101410F8 + 2), 1u, (int)byte_100823E8, 44, 1, 57);
  if ( v1 < 57 )
  {
    v2 = dword_101410F8;
    switch ( *(_BYTE *)dword_101410F8 )
    {
      case 1:
        v3 = off_100823F0[11 * v1];
        goto LABEL_4;
      case 0:
        break;
      case 2:
        v8 = (int (__cdecl *)(_DWORD, _DWORD, int))*(&off_100823EC + 11 * v1);
        goto LABEL_18;
      case 3:
        v8 = (int (__cdecl *)(_DWORD, _DWORD, int))*(&off_100823FC + 11 * v1);
LABEL_18:
        if ( !v8 )
          goto LABEL_9;
        v4 = v8(*(_BYTE *)(dword_101410F8 + 2), *(_BYTE *)(dword_101410F8 + 4), dword_101410F8 + 5);
        goto LABEL_6;
      case 4:
        v9 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int))*(&off_10082400 + 11 * v1);
        if ( !v9 )
          goto LABEL_9;
        v4 = v9(
               *(_BYTE *)(dword_101410F8 + 2),
               *(_BYTE *)(dword_101410F8 + 3),
               *(_BYTE *)(dword_101410F8 + 4),
               dword_101410F8 + 5);
        goto LABEL_6;
      case 5:
        v10 = dword_101410F8 + 8;
        v11 = (char *)(dword_101410F8 + 8);
        v12 = dword_101410F8 + 9;
        do
          v13 = *v11++;
        while ( v13 );
        v14 = (int)&v11[-v12];
        if ( sub_1002C170(&v11[v10 - 4] - v12, ".ini", 5) && !sub_1002C170((_BYTE *)(v10 + v14 - 5), ".greg", 6) )
          v0 = sub_10001C10(&byte_100823E8[44 * v1]);
        j_FIL_vfs_sync_all();
        goto LABEL_7;
      case 6:
        v15 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD, int, int, _DWORD))*(&off_100823F4 + 11 * v1);
        if ( !v15 )
          goto LABEL_9;
        v4 = v15(
               *(_BYTE *)(dword_101410F8 + 2),
               *(_BYTE *)(dword_101410F8 + 3),
               *(_BYTE *)(dword_101410F8 + 4),
               dword_101410F8 + 5,
               dword_101410F8 + 8,
               *(_DWORD *)(dword_101410F8 + 160008));
        goto LABEL_6;
      case 0xB:
        v3 = (int (__cdecl *)(char, int, int, int, int, int))dword_100823F8[11 * v1];
        goto LABEL_4;
      case 7:
        sub_10001910();
        break;
      case 8:
        sub_10001930();
        break;
      case 0xA:
        v3 = (int (__cdecl *)(char, int, int, int, int, int))*(&off_10082404 + 11 * v1);
LABEL_4:
        if ( !v3 )
          goto LABEL_9;
        v4 = v3(
               *(_BYTE *)(dword_101410F8 + 2),
               *(_BYTE *)(dword_101410F8 + 3),
               *(_BYTE *)(dword_101410F8 + 4),
               dword_101410F8 + 5,
               dword_101410F8 + 8,
               *(_DWORD *)(dword_101410F8 + 160008));
LABEL_6:
        v0 = v4;
LABEL_7:
        if ( v0 != 1 )
          goto LABEL_8;
        break;
      case 9:
        sub_100018F0();
        break;
      default:
        sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 972, 0, 0);
LABEL_8:
        v2 = dword_101410F8;
LABEL_9:
        if ( (unsigned int)++dword_101410FC > 0x32 || (unsigned int)sub_10001510() > 0x32 )
        {
          sprintf(&v16, "EXCEEDED RETRIES CNFG_PROD %d STATE %d\n", *(_BYTE *)(v2 + 2), *(_BYTE *)v2);
          sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr.c", 1009, 0, &v16);
          sub_10001600(8);
        }
        break;
    }
  }
  v5 = (void (__cdecl *)(_DWORD))dword_1008240C[11 * dword_1014110C];
  if ( v5 )
    v5((unsigned __int8)byte_100823E8[44 * dword_1014110C]);
  result = dword_1014110C + 1;
  v7 = (unsigned int)dword_1014110C++ >= 0xFFFFFFFF;
  if ( !v7 )
    dword_1014110C = 0;
  return result;
}
// 10061300: using guessed type int j_FIL_vfs_sync_all(void);
// 100823EC: using guessed type int (__cdecl *off_100823EC)(int);
// 100823F0: using guessed type int (__cdecl *off_100823F0[2])(char, int, int, int, int, int);
// 100823F4: using guessed type int (__cdecl *off_100823F4)(char, int, int, int, int, int);
// 100823F8: using guessed type int dword_100823F8[];
// 100823FC: using guessed type int (__cdecl *off_100823FC)(int);
// 10082400: using guessed type int (*off_10082400)();
// 10082404: using guessed type int (__cdecl *off_10082404)(int, char);
// 1008240C: using guessed type int dword_1008240C[];
// 101410F8: using guessed type int dword_101410F8;
// 101410FC: using guessed type int dword_101410FC;
// 1014110C: using guessed type int dword_1014110C;

//----- (100021B0) --------------------------------------------------------
char __cdecl sub_100021B0(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  result = sub_100144B0(a1, a2, (char *)&v4 + 3);
  if ( result == 1 )
    result = sub_1002D440(168);
  return result;
}

//----- (100021E0) --------------------------------------------------------
char __cdecl sub_100021E0(int a1, int a2)
{
  int v2; // ecx@0
  char result; // al@1
  int v4; // [sp-2h] [bp-4h]@1

  v4 = v2;
  result = sub_100144B0(a1, a2, (char *)&v4 + 3);
  if ( result == 1 )
  {
    if ( BYTE3(v4) == 1 )
    {
      if ( byte_10146910 != 1 )
      {
        result = sub_1002D550(0xA7u);
        byte_10146910 = 1;
      }
    }
    else if ( byte_10146910 == 1 )
    {
      result = sub_1002D440(167);
      byte_10146910 = 0;
    }
  }
  return result;
}
// 10146910: using guessed type char byte_10146910;

//----- (10002250) --------------------------------------------------------
char sub_10002250()
{
  return sub_1002D550(0xA8u);
}

//----- (10002260) --------------------------------------------------------
void sub_10002260()
{
  byte_10146910 = 0;
}
// 10146910: using guessed type char byte_10146910;

//----- (10002270) --------------------------------------------------------
char __thiscall sub_10002270(void *this)
{
  char v1; // al@1
  unsigned __int8 v2; // al@1
  __int16 v3; // ax@1
  void *v4; // ecx@1
  char v5; // al@1
  unsigned __int8 v6; // al@1
  __int16 v7; // ax@1

  v1 = sub_1002DB00(this);
  v2 = sub_1002D790(v1);
  v3 = sub_1002DBA0(v2);
  sub_100164F0((unsigned __int16)v3, (int)&byte_10A08A80);
  v5 = sub_1002DB00(v4);
  v6 = sub_1002D6A0(v5);
  v7 = sub_1002DBA0(v6);
  return sub_100164F0((unsigned __int16)v7, (int)&byte_10A08A80);
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (100022C0) --------------------------------------------------------
char __cdecl sub_100022C0(int a1, int a2)
{
  signed __int16 v2; // bp@1
  signed __int16 v3; // bx@1
  unsigned __int16 v4; // di@5
  char *v5; // esi@6
  bool v6; // zf@8
  int v7; // eax@13
  char v9; // [sp+10h] [bp-528h]@7
  char v10; // [sp+ACh] [bp-48Ch]@8
  char v11; // [sp+ADh] [bp-48Bh]@10
  __int16 v12; // [sp+B0h] [bp-488h]@7
  char v13; // [sp+14Ch] [bp-3ECh]@1

  memset(&v13, 0, 0x3E8u);
  v2 = 0;
  v3 = 1000;
  if ( (_WORD)a1 == 135 )
  {
    v2 = 1000;
  }
  else if ( (_WORD)a1 == 137 )
  {
    v2 = 2000;
    v3 = 415;
  }
  v4 = 0;
  if ( v3 )
  {
    v5 = &v13;
    do
    {
      v12 = v4 + v2;
      if ( sub_1002DBE0((int)&v12, (int)&v9) )
      {
        v6 = v10 == 0;
        *v5 = -128;
        if ( !v6 )
          *v5 = -96;
        if ( v11 )
          *v5 |= 0x40u;
      }
      ++v4;
      ++v5;
    }
    while ( v4 < (unsigned __int16)v3 );
  }
  v7 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v13, v7);
}

//----- (100023C0) --------------------------------------------------------
char __cdecl sub_100023C0(int a1, int a2)
{
  void *v2; // ecx@0
  int v3; // eax@1
  char v5; // [sp+1h] [bp-1h]@1

  v5 = sub_10020DA0(v2);
  v3 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v5, v3);
}

//----- (100023F0) --------------------------------------------------------
char __cdecl sub_100023F0(int a1, int a2)
{
  int v2; // eax@1
  float v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = 0.0;
  LOBYTE(v5) = sub_1002E330(COERCE_FLOAT(&v4));
  v2 = sub_10060900();
  return sub_10013610(a1, v5, a2, &v4, v2);
}

//----- (10002430) --------------------------------------------------------
char __cdecl sub_10002430(int a1, int a2)
{
  signed int v2; // esi@1
  double v3; // st7@3
  int v4; // eax@5
  char v6; // [sp+8h] [bp-320h]@2
  int v7; // [sp+30h] [bp-2F8h]@3
  char v8; // [sp+44h] [bp-2E4h]@3
  int v9; // [sp+50h] [bp-2D8h]@1
  char v10[4]; // [sp+54h] [bp-2D4h]@3
  int v11; // [sp+58h] [bp-2D0h]@3
  float v12; // [sp+5Ch] [bp-2CCh]@3
  char v13[708]; // [sp+60h] [bp-2C8h]@3

  v2 = 0;
  v9 = 0;
  do
  {
    if ( sub_10029AB0(v2, (int)&v6) )
    {
      sub_1002C120((int)&v13[24 * v9], &v8, 12);
      v3 = sub_1002E500(v2);
      *(&v12 + 6 * v9) = v3;
      *(&v11 + 6 * v9) = v7;
      v10[24 * v9++] = sub_1002DC80(v2);
    }
    ++v2;
  }
  while ( v2 < 30 );
  v4 = sub_10060900();
  return sub_10013920(a1, 24 * v9 + 4, 1, a2, &v9, v4);
}
// 1002E500: using guessed type double __cdecl sub_1002E500(_DWORD);
// 10002430: using guessed type char var_2C8[708];
// 10002430: using guessed type char var_2D4[4];

//----- (10002510) --------------------------------------------------------
char __cdecl sub_10002510(int a1, int a2)
{
  int v2; // ecx@0
  char v3; // al@1
  int v4; // eax@1
  int v6; // [sp+0h] [bp-4h]@1

  v3 = sub_1002C480(v2);
  v6 = (unsigned __int16)sub_1002ED10((unsigned __int8)v3);
  v4 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v6, v4);
}

//----- (10002550) --------------------------------------------------------
char __usercall sub_10002550@<al>(int a1@<ebx>, int a2, int a3)
{
  signed int v3; // eax@1
  signed int v4; // eax@3
  double v5; // st7@6
  int v6; // edx@6
  int v7; // ecx@6
  double v8; // st7@10
  int v9; // edx@10
  int v10; // ecx@10
  int v11; // eax@11
  __int64 v13; // [sp-4h] [bp-58h]@0
  double v14; // [sp+4h] [bp-50h]@1
  int v15; // [sp+Ch] [bp-48h]@6
  int v16; // [sp+10h] [bp-44h]@6
  double v17; // [sp+14h] [bp-40h]@6
  int v18; // [sp+20h] [bp-34h]@10
  char v19; // [sp+2Ch] [bp-28h]@6

  memset(&dword_10146918, 0, 0x7E0u);
  v3 = sub_100247D0(0);
  LODWORD(v14) = v3;
  if ( v3 == 0x3FFFF || (LODWORD(v13) = v3, sub_10023010(v13)) )
  {
    v4 = sub_10024570(0);
    LODWORD(v14) = v4;
  }
  else
  {
    v4 = LODWORD(v14);
  }
  if ( v4 != 0x3FFFF )
  {
    sub_100237B0(v4, (int)&v15);
    v5 = sub_10023040(*(float *)&v14);
    v6 = v16;
    v7 = v15;
    flt_10146930[5 * (unsigned __int8)byte_10146926] = v5;
    sub_1002EEB0((int)(&dword_10146928 + 5 * (unsigned __int8)byte_10146926), COERCE_DOUBLE(__PAIR__(v6, v7)), v17);
    sub_1002C120((int)&unk_10146934 + 20 * (unsigned __int8)byte_10146926, &v19, 7);
    ++byte_10146926;
  }
  sub_10022D30(a1, (_BYTE *)&v14 + 4, (int *)&v14);
  if ( LODWORD(v14) != 0x3FFFF )
  {
    sub_1005F8F0(*((float *)&v14 + 1), (int)&unk_10146920, (int)&dword_1014691C);
    if ( dword_1014691C == 0x7FFFFFFF )
      dword_1014691C = 0;
    sub_100237B0(LODWORD(v14), (int)&v15);
    dword_10146918 = v18;
    v8 = sub_10023040(*(float *)&v14);
    v9 = v16;
    v10 = v15;
    flt_10146930[5 * (unsigned __int8)byte_10146926] = v8;
    sub_1002EEB0((int)(&dword_10146928 + 5 * (unsigned __int8)byte_10146926), COERCE_DOUBLE(__PAIR__(v9, v10)), v17);
    sub_1002C120((int)&unk_10146934 + 20 * (unsigned __int8)byte_10146926, &v19, 7);
    byte_10146924 = byte_10146926;
    byte_10146925 = byte_10146926++;
  }
  v11 = sub_10060900();
  return sub_10013920(a2, 20 * (unsigned __int8)byte_10146926 + 16, 1, a3, &dword_10146918, v11);
}
// 10146918: using guessed type int dword_10146918;
// 1014691C: using guessed type int dword_1014691C;
// 10146924: using guessed type char byte_10146924;
// 10146925: using guessed type char byte_10146925;
// 10146926: using guessed type char byte_10146926;
// 10146930: using guessed type float flt_10146930[];

//----- (10002770) --------------------------------------------------------
char __cdecl sub_10002770(int a1, int a2)
{
  int v2; // eax@1
  float v4; // [sp+0h] [bp-4h]@1

  v4 = sub_1002ECD0() * 0.001000000047497451;
  v2 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v4, v2);
}

//----- (100027A0) --------------------------------------------------------
char __cdecl sub_100027A0(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+0h] [bp-8h]@1

  v4 = 4;
  sub_10060D80(3206, (int)&v4, 8);
  v2 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v4, v2);
}

//----- (100027E0) --------------------------------------------------------
char __cdecl sub_100027E0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int v4; // eax@6
  int v6; // [sp+8h] [bp-1E8h]@1
  char v7[12]; // [sp+Ch] [bp-1E4h]@3
  char v8[468]; // [sp+18h] [bp-1D8h]@3

  v2 = 0;
  v6 = 0;
  v3 = 0;
  while ( 1 )
  {
    if ( sub_10029B80(v3, &v7[24 * v2], (int)&v8[24 * v2]) )
      ++v6;
    if ( ++v3 >= 20 )
      break;
    v2 = v6;
  }
  v4 = sub_10060900();
  return sub_10013920(a1, 24 * v6 + 4, v6 != 0, a2, &v6, v4);
}
// 100027E0: using guessed type char var_1D8[468];
// 100027E0: using guessed type char var_1E4[12];

//----- (10002880) --------------------------------------------------------
char __cdecl sub_10002880(int a1, int a2)
{
  int v2; // eax@1
  char v4; // [sp+0h] [bp-2Ch]@1

  sub_1002FFA0(&v4);
  v2 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v4, v2);
}

//----- (100028B0) --------------------------------------------------------
char __cdecl sub_100028B0(int a1, int a2)
{
  int v2; // eax@1
  int v4; // [sp+4h] [bp-20h]@1
  int v5; // [sp+8h] [bp-1Ch]@1
  char v6[4]; // [sp+Ch] [bp-18h]@1
  int v7; // [sp+10h] [bp-14h]@1
  int v8; // [sp+14h] [bp-10h]@1
  int v9; // [sp+18h] [bp-Ch]@1
  char v10; // [sp+1Ch] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  *(_DWORD *)v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  sub_10060D80(6103, (int)&v4, 8);
  _snprintf(v6, 0x11u, "%lX%08lX", v5, v4);
  v2 = sub_10060900();
  return sub_10013610(a1, 1, a2, v6, v2);
}

//----- (10002940) --------------------------------------------------------
char __thiscall sub_10002940(void *this)
{
  unsigned __int8 v1; // ST04_1@1
  char v2; // bl@1
  char v3; // al@1
  unsigned int v5; // [sp+4h] [bp-8h]@1

  v1 = (unsigned __int8)this;
  v5 = 0;
  v2 = 4;
  v3 = sub_1002DB00(this);
  if ( sub_10030050(v3, v1, (int)&v5) == 1 )
  {
    switch ( BYTE1(v5) )
    {
      case 1u:
      case 2u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
        return sub_100012D0(SBYTE1(v5));
      case 3u:
      case 4u:
      case 5u:
      case 6u:
        return sub_10001210(SBYTE1(v5));
      case 0u:
        return 3;
      default:
        return v2;
    }
  }
  return v2;
}

//----- (100029D0) --------------------------------------------------------
char __usercall sub_100029D0@<al>(void *a1@<ecx>, unsigned __int8 a2@<sil>)
{
  char v2; // bl@1
  char v3; // al@1
  int v5; // [sp+4h] [bp-4h]@1

  v2 = 0;
  v5 = 0;
  v3 = sub_1002DB00(a1);
  if ( sub_10030120(v3, a2, (int)&v5) == 1 )
  {
    switch ( (unsigned __int8)v5 )
    {
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
        return sub_100162A0(a2);
      case 0u:
      case 1u:
        return 3;
      default:
        return v2;
    }
  }
  return v2;
}

//----- (10002A40) --------------------------------------------------------
char __cdecl sub_10002A40(int a1, int a2)
{
  void *v2; // ecx@0
  unsigned __int8 v3; // si@1
  signed int v4; // edi@1
  char v5; // al@3
  int v6; // eax@8
  int v8; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v8 = 0;
  v4 = -2;
  do
  {
    if ( (unsigned int)(v4 + 2) > 1 )
    {
      if ( (unsigned int)v4 > 1 )
        goto LABEL_7;
      v5 = sub_10002940((void *)v4);
    }
    else
    {
      v5 = sub_100029D0(v2, v3);
    }
    *((_BYTE *)&v8 + v4 + 2) = v5;
LABEL_7:
    ++v4;
    ++v3;
  }
  while ( v4 < 2 );
  v6 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v8, v6);
}

//----- (10002AA0) --------------------------------------------------------
char __cdecl sub_10002AA0(int a1, int a2)
{
  int v2; // eax@1
  __int16 v4; // [sp+0h] [bp-10h]@1
  __int16 v5; // [sp+2h] [bp-Eh]@1
  __int16 v6; // [sp+4h] [bp-Ch]@1
  __int16 v7; // [sp+6h] [bp-Ah]@1
  __int16 v8; // [sp+8h] [bp-8h]@1
  __int16 v9; // [sp+Ah] [bp-6h]@1
  __int16 v10; // [sp+Ch] [bp-4h]@1

  v4 = sub_10061680();
  v5 = j_HWM_pvg_get_anlg_outp(3);
  v6 = sub_10061C00();
  v8 = j_HWM_pvg_get_frmt_adc(10);
  v7 = j_HWM_pvg_get_frmt_adc(9);
  v10 = j_HWM_pvg_get_frmt_adc(18);
  v9 = j_HWM_pvg_get_frmt_adc(17);
  v2 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v4, v2);
}
// 100615F0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);
// 10061600: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);

//----- (10002B20) --------------------------------------------------------
char __cdecl sub_10002B20(int a1, int a2)
{
  int v2; // eax@1
  __int16 v4; // [sp+0h] [bp-4h]@1
  __int16 v5; // [sp+2h] [bp-2h]@1

  v4 = sub_10030550();
  v5 = sub_100305F0();
  v2 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v4, v2);
}

//----- (10002B60) --------------------------------------------------------
char sub_10002B60()
{
  char v1; // [sp+1h] [bp-1h]@1

  v1 = sub_10021000();
  return byte_100839C1[2 * sub_1002CC90(&v1, 1u, (int)&unk_100839C0, 2, 11, 0)];
}

//----- (10002B90) --------------------------------------------------------
char __cdecl sub_10002B90(int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // esi@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // edi@1
  int v9; // eax@1
  char v11; // [sp+Ch] [bp-Ch]@1
  unsigned int v12; // [sp+10h] [bp-8h]@1

  v2 = 1 << sub_10002B60();
  v3 = v2 | (1 << sub_10020FC0());
  v4 = v3 | (1 << sub_10020F80());
  v5 = v4 | (1 << sub_10020F40());
  v6 = v5 | (1 << sub_10020F00());
  v7 = v6 | (1 << sub_10020EC0());
  v8 = v7 | (1 << sub_10020E40());
  v12 = (v8 | (unsigned int)(1 << sub_10020E80())) >> 1;
  v11 = sub_100305A0();
  v9 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v11, v9);
}

//----- (10002C60) --------------------------------------------------------
void *sub_10002C60()
{
  void *v0; // ecx@1
  void *v1; // ecx@1
  void *v2; // ecx@1
  void *v3; // ecx@1
  void *result; // eax@1

  sub_10016A30();
  sub_10002270(v0);
  sub_10001540();
  sub_10018B00();
  sub_1001A170();
  sub_10019B30();
  sub_10018FA0(v1);
  sub_1000D450();
  sub_1001CDA0(v2);
  sub_10005FE0();
  sub_10008F30();
  sub_10017D70();
  sub_1002C5E0(v3);
  sub_10016D00();
  sub_10003D10();
  dword_1014A628 = 0;
  dword_1014A62C[0] = 0;
  dword_1014A630[0] = 0;
  dword_1014A634 = 0;
  dword_1014A638 = 0;
  LOBYTE(dword_1014A628) = 1;
  result = sub_10010270(1);
  dword_1014A62C[0] = (int)result;
  dword_1014A630[0] = (int)sub_1000F7A0;
  dword_1014A634 = 4;
  return result;
}
// 10005FE0: using guessed type int sub_10005FE0(void);
// 1000F7A0: using guessed type int sub_1000F7A0();
// 1014A628: using guessed type int dword_1014A628;
// 1014A62C: using guessed type int dword_1014A62C[];
// 1014A630: using guessed type int dword_1014A630[];
// 1014A634: using guessed type int dword_1014A634;
// 1014A638: using guessed type int dword_1014A638;

//----- (10002CB0) --------------------------------------------------------
signed int __thiscall sub_10002CB0(void *this)
{
  unsigned int v1; // esi@7
  bool v2; // al@10
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = this;
  sub_10030F50();
  sub_10014C60();
  sub_10001AF0();
  sub_10030C60();
  sub_1002F4A0();
  sub_10021040();
  sub_10028F50();
  sub_10030C40();
  ((void (__cdecl *)(void *))loc_10015CD0)(v4);
  sub_100202C0();
  byte_101470F9 = sub_10030B40(1) && sub_10030B40(14) || sub_10030B40(39) && sub_10030B40(40);
  byte_101470FB = sub_10030B40(4);
  byte_101470F8 = sub_10030C20();
  sub_10002260();
  v1 = 0;
  do
  {
    v2 = !sub_10030B40(byte_10084910[8 * v1]) && !sub_10030B40(byte_10084911[8 * v1]);
    *((_BYTE *)&word_101470FC + v1++) = v2;
  }
  while ( v1 < 2 );
  word_10A08A64 = 0;
  BYTE3(v4) = 2;
  byte_101470FA = 2;
  sub_10061000(2120, &byte_101470FA, 1, (char *)&v4 + 3);
  sub_10028F40();
  sub_10061B70((LONG)&off_1008499C);
  return sub_10061700((int)&off_1008499C);
}
// 1008499C: using guessed type char *off_1008499C;
// 101470F8: using guessed type char byte_101470F8;
// 101470F9: using guessed type char byte_101470F9;
// 101470FA: using guessed type char byte_101470FA;
// 101470FB: using guessed type char byte_101470FB;
// 101470FC: using guessed type __int16 word_101470FC;
// 10A08A64: using guessed type __int16 word_10A08A64;

//----- (10002DE0) --------------------------------------------------------
void sub_10002DE0()
{
  if ( byte_101470FB )
    sub_10018900();
  if ( byte_101470F8 )
    sub_10018FE0();
}
// 101470F8: using guessed type char byte_101470F8;
// 101470FB: using guessed type char byte_101470FB;

//----- (10002E00) --------------------------------------------------------
char sub_10002E00()
{
  unsigned int v0; // eax@1
  char v2; // [sp+0h] [bp-ECh]@2
  char v3; // [sp+10h] [bp-DCh]@5
  char v4; // [sp+74h] [bp-78h]@1
  char v5; // [sp+84h] [bp-68h]@5

  LOBYTE(v0) = sub_10015AC0(2, 243, &v4);
  if ( (_BYTE)v0 )
  {
    LOBYTE(v0) = sub_10015AC0(2, 247, &v2);
    if ( (_BYTE)v0 )
    {
      v0 = sub_10031240(&v4);
      if ( !v0 )
      {
        v0 = sub_10031240(&v2);
        if ( !v0 )
        {
          byte_101470F9 = 0;
          v0 = strcmp(&v5, &v3);
          if ( v0 )
            LOBYTE(v0) = sub_1002D550(0x10u);
        }
      }
    }
  }
  return v0;
}
// 101470F9: using guessed type char byte_101470F9;

//----- (10002EC0) --------------------------------------------------------
void __thiscall sub_10002EC0(void *this)
{
  if ( sub_1002C660(this) != 4 || (flt_1014A5D0 = 0.0, sub_10025030(&flt_1014A5D0) != 1) || 0.0 == flt_1014A5D0 )
    word_101470FC = 257;
}
// 101470FC: using guessed type __int16 word_101470FC;
// 1014A5D0: using guessed type float flt_1014A5D0;

//----- (10002F00) --------------------------------------------------------
void sub_10002F00()
{
  unsigned int v0; // esi@1
  float v1; // ST14_4@4
  char v2; // [sp+10h] [bp-78h]@3
  char String; // [sp+20h] [bp-68h]@4

  v0 = 0;
  do
  {
    if ( !*((_BYTE *)&word_101470FC + v0) && sub_10031310((unsigned __int8)byte_10084912[8 * v0], &v2) )
    {
      v1 = sub_10068FB6(&String);
      if ( (signed int)v1 >= (signed int)flt_1014A5D0 || !sub_10060A90(9, dword_10084914[2 * v0]) )
        *((_BYTE *)&word_101470FC + v0) = 1;
    }
    ++v0;
  }
  while ( v0 < 2 );
}
// 10084914: using guessed type int dword_10084914[];
// 101470FC: using guessed type __int16 word_101470FC;
// 1014A5D0: using guessed type float flt_1014A5D0;

//----- (10002FA0) --------------------------------------------------------
int __cdecl sub_10002FA0(char a1)
{
  __int16 v2; // [sp+0h] [bp-10h]@1
  char v3; // [sp+4h] [bp-Ch]@1
  char v4; // [sp+5h] [bp-Bh]@1

  v2 = -32757;
  v3 = a1;
  v4 = 1;
  return sub_10060AC0(48, (int)&v2, 60000, 1);
}

//----- (10002FF0) --------------------------------------------------------
unsigned int __cdecl sub_10002FF0(int a1)
{
  int v1; // ecx@0
  int v2; // ecx@1
  void *v3; // ecx@1
  unsigned int result; // eax@1

  j_HWM_pvg_hsdb_get_lrus_online(v1);
  j_HWM_pvg_hsdb_get_lrus_online(v2);
  result = sub_1002C660(v3);
  if ( result == 4 )
  {
    result = *(_DWORD *)(a1 + 4);
    if ( result > 0x269D )
    {
      if ( result == 9886 )
        result = sub_10002FA0(1);
    }
    else
    {
      switch ( result )
      {
        case 0x269Du:
          result = sub_10002FA0(3);
          break;
        case 0x84Au:
          result = sub_10002FA0(4);
          break;
        case 0x23EBu:
          result = sub_10002FA0(2);
          break;
      }
    }
  }
  return result;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);

//----- (10003060) --------------------------------------------------------
int sub_10003060()
{
  int result; // eax@1
  void *v1; // ecx@1
  signed __int16 v2; // si@1
  unsigned __int16 v3; // bx@2
  signed int v4; // edi@10
  char *v5; // esi@10
  char v6; // dl@14
  unsigned __int16 v7; // ax@14
  unsigned int v8; // eax@18
  int v9; // eax@37
  char v10; // [sp-70h] [bp-5C8h]@42
  int v11; // [sp-28h] [bp-580h]@40
  int v12; // [sp-8h] [bp-560h]@14
  int *v13; // [sp-4h] [bp-55Ch]@14
  char v14; // [sp+Fh] [bp-549h]@38
  int v15; // [sp+10h] [bp-548h]@1
  char *v16; // [sp+14h] [bp-544h]@38
  int v17; // [sp+18h] [bp-540h]@38
  int v18; // [sp+1Ch] [bp-53Ch]@38
  char v19; // [sp+20h] [bp-538h]@49
  unsigned __int16 v20; // [sp+28h] [bp-530h]@1
  char v21[4]; // [sp+2Ch] [bp-52Ch]@7
  int v22; // [sp+30h] [bp-528h]@7
  int v23; // [sp+34h] [bp-524h]@43
  int v24; // [sp+38h] [bp-520h]@43
  int v25; // [sp+3Ch] [bp-51Ch]@47
  int v26; // [sp+40h] [bp-518h]@47
  unsigned __int16 v27; // [sp+44h] [bp-514h]@47
  int v28; // [sp+46h] [bp-512h]@47
  __int16 v29; // [sp+4Ch] [bp-50Ch]@34
  int v30; // [sp+B8h] [bp-4A0h]@43
  int v31; // [sp+BCh] [bp-49Ch]@43
  int v32; // [sp+C0h] [bp-498h]@43
  int v33; // [sp+C4h] [bp-494h]@43
  size_t v34; // [sp+548h] [bp-10h]@23

  result = sub_10060880((int)&v20, (int)&v15);
  v2 = 1;
  if ( result != 1 )
  {
    v3 = 0;
    do
    {
      LOWORD(v1) = v20;
      if ( (signed int)v20 > 32769 )
      {
        switch ( v20 )
        {
          case 0x8013u:
            if ( v21[1] == 17 )
              sub_10001950(v21[0], 17, v21[2], v21[3], (int)&v22, (char *)&v22 + 3, v34);
            break;
          case 0x8030u:
            sub_10012840(*(int *)v21, (int)&byte_10A08A80);
            break;
          case 0x8002u:
            sub_10013C10(*(int *)v21, v22, (int)&byte_10A08A80);
            break;
          case 0x8003u:
            sub_100183B0(*(int *)v21);
            break;
          case 0x8004u:
            sub_100190E0();
            break;
          case 0x801Fu:
            sub_10019140();
            break;
          case 0x8005u:
            sub_10018B20(v21[0]);
            break;
          case 0x801Eu:
            sub_100199F0(v21[0]);
            break;
          case 0x800Bu:
            sub_10014C30();
            break;
          case 0x8011u:
            sub_10015B50(v21[0], (int)&byte_10A08A80);
            break;
          case 0x803Fu:
            sub_100146F0(*(int *)v21, (int)&v22 + 2, v22, v2, v2);
            break;
          case 0x802Cu:
            v29 = word_10A08A64;
            sub_10015FE0((int)v21, (int)&byte_10A08A80);
            word_10A08A64 += v2;
            break;
          case 0x803Cu:
            sub_1001B110(v21, (int)&byte_10A08A80);
            break;
          case 0x802Fu:
            if ( sub_10015AC0(v3, 321, &unk_10147100) )
            {
              v9 = sub_10060900();
              sub_10013610(363, v2, (int)&byte_10A08A80, &unk_10147100, v9);
            }
            break;
          case 0x8031u:
            v14 = sub_100092C0();
            v13 = (int *)&v16;
            v18 = 0;
            v16 = &v14;
            v17 = 1;
            v12 = v15;
            goto LABEL_53;
          case 0x8032u:
            v14 = sub_10008F70();
            v13 = (int *)&v16;
            v18 = 0;
            v16 = &v14;
            v17 = 1;
            v12 = v15;
            goto LABEL_53;
          case 0x8033u:
            qmemcpy(&v11, &v22, 0x28u);
            sub_10008A60(v21[0], v11);
            v18 = 0;
            v14 = 1;
            v16 = &v14;
            v17 = 1;
            sub_10060A20(v15, (int)&v16);
            break;
          case 0x8034u:
            sub_100088E0(v1);
            break;
          case 0x8035u:
            qmemcpy(&v10, v21, 0x70u);
            sub_10008960(v10);
            v18 = 0;
            v14 = 1;
            v16 = &v14;
            v17 = 1;
            sub_10060A20(v15, (int)&v16);
            break;
          case 0x8006u:
            sub_1001A210(v33, v22, v21[0], v23, (const char *)&v24, v30, v31, *(__int16 *)&v21[2], v32);
            break;
          case 0x8007u:
            sub_1001A280(v2);
            break;
          case 0x8017u:
            sub_10016340(v21[0]);
            break;
          case 0x8043u:
            sub_10001060(*(unsigned __int16 *)v21);
            break;
          case 0x8048u:
            sub_10001460(*(int *)v21, v22, v23, v24, v25, v26, v27, v28);
            break;
          case 0x804Bu:
            sub_1000E560((int)v21);
            break;
          case 0x804Au:
            if ( sub_1000D4A0(v21[1], (int)&v19) == 1 )
            {
              v18 = 1;
              v16 = &v19;
              v17 = 8;
            }
            else
            {
              v18 = 0;
            }
            v13 = (int *)&v16;
            v12 = v15;
LABEL_53:
            sub_10060A20(v12, (int)v13);
            break;
          default:
            break;
        }
      }
      else if ( (signed int)v20 >= 0x8000 )
      {
        if ( v20 == -32767 )
        {
          v4 = *(_DWORD *)v21;
          v5 = (char *)&v22;
        }
        else
        {
          v5 = v21;
          v4 = (HIWORD(v22) + 15) & 0xFFFFFFFC;
        }
        do
        {
          if ( v5[4] == (_BYTE)v3 )
          {
            sub_10013610(*((_WORD *)v5 + 1), v5[1], (int)&byte_10A08A80, v5 + 12, *((_DWORD *)v5 + 2));
          }
          else
          {
            v6 = v5[1];
            v13 = (int *)*((_DWORD *)v5 + 2);
            v7 = *((_WORD *)v5 + 3);
            v12 = (int)(v5 + 12);
            sub_10013920(*((_WORD *)v5 + 1), v7, v6, (int)&byte_10A08A80, v5 + 12, (int)v13);
          }
          if ( *v5 == 1 && *(_DWORD *)(52 * *(_WORD *)(dword_10A08AA8 + 2 * *((_WORD *)v5 + 1)) + dword_10A08AA0 + 36) )
          {
            (*(void (__cdecl **)(_DWORD, char *))(52 * *(_WORD *)(dword_10A08AA8 + 2 * *((_WORD *)v5 + 1))
                                                + dword_10A08AA0
                                                + 36))(
              *((_WORD *)v5 + 1),
              &byte_10A08A80);
            v3 = 0;
          }
          v8 = (*((_WORD *)v5 + 3) + 15) & 0xFFFFFFFC;
          v5 += v8;
          v4 -= v8;
        }
        while ( *((_WORD *)v5 + 3) > v3 && v4 > 0 );
      }
      else if ( v20 == 1 )
      {
        sub_10002FF0((int)&v20);
      }
      else if ( v20 == 2 )
      {
        sub_10020760(*(int *)v21, v22, 0xFFFFFFF);
      }
      result = sub_10060880((int)&v20, (int)&v15);
      v2 = 1;
    }
    while ( result != 1 );
  }
  return result;
}
// 10A08A64: using guessed type __int16 word_10A08A64;
// 10A08A80: using guessed type char byte_10A08A80;
// 10A08AA0: using guessed type int dword_10A08AA0;
// 10A08AA8: using guessed type int dword_10A08AA8;

//----- (10003650) --------------------------------------------------------
void __noreturn sub_10003650()
{
  char v0; // bl@1
  signed int v1; // esi@1
  void *v2; // ecx@3
  void *v3; // ecx@5
  void *v4; // ecx@8
  void *v5; // ecx@8
  void *v6; // ecx@8
  void *v7; // ecx@9
  char v8; // al@16
  void *v9; // ecx@22
  void *v10; // ecx@24
  int *v11; // ecx@29
  char v12; // [sp+9h] [bp-21Bh]@1
  char v13; // [sp+Ah] [bp-21Ah]@1
  char v14; // [sp+Bh] [bp-219h]@15
  char v15; // [sp+Ch] [bp-218h]@3
  int v16; // [sp+10h] [bp-214h]@20
  char v17; // [sp+14h] [bp-210h]@21
  char v18; // [sp+78h] [bp-1ACh]@20
  char v19; // [sp+DCh] [bp-148h]@20
  char v20; // [sp+140h] [bp-E4h]@3

  v12 = 4;
  v13 = 20;
  v0 = 40;
  v1 = 200;
  if ( !sub_10060BB0(8, 20000) )
    sub_10028BC0("..\\lib\\adl\\iop_d_main.c", 332, 1, 0);
  sub_100319A0();
  sub_100315A0(&v20);
  sub_10060C20(&v15);
  sub_10002EC0(v2);
  while ( 1 )
  {
    sub_10060C20(&v15);
    if ( v15 & 1 )
    {
      sub_10012E80((int)&byte_10A08A80);
      sub_10013280((int)&byte_10A08A80);
      sub_100161D0();
      sub_10002DE0();
      if ( byte_101470F9 )
        sub_10002E00();
      if ( --v13 <= 0 )
      {
        sub_10003CE0();
        sub_10005D10();
        sub_1000E990(v4);
        if ( sub_1002C660(v5) == 4 && sub_1002C5E0(v6) == 1 )
          sub_1000F160(v7);
        sub_100143F0((int)&byte_10A08A80);
        v13 = 20;
      }
      if ( --v12 <= 0 )
      {
        sub_10020860();
        v12 = 4;
      }
      if ( --v0 <= 0 )
      {
        if ( sub_1002ED20((bool *)&v14) )
        {
          v8 = v14;
        }
        else
        {
          v8 = 2;
          v14 = 2;
        }
        if ( v8 != byte_101470FA )
        {
          byte_101470FA = v8;
          sub_10060ED0(2120, (int)&byte_101470FA, 1);
          if ( v14 == 1 )
          {
            sub_10025090(0, &v16, (float *)&v18, (float *)&v19);
            if ( v16 > 0 )
              sub_10060ED0(2167, (int)&v17, 4);
          }
        }
        sub_10002F00();
        sub_10016A90(v9);
        sub_10031490((int *)&v20);
        v0 = 40;
      }
      if ( (signed __int16)--v1 <= 0 )
      {
        if ( sub_1002C5E0(v3) == 1 )
        {
          if ( sub_10003860(v10) )
            sub_1002D550(0x4Au);
          else
            sub_1002D440(74);
        }
        v1 = 200;
      }
      sub_10001EF0();
      sub_1001B080(v11);
    }
    if ( v15 & 2 )
      sub_10003060();
  }
}
// 101470F9: using guessed type char byte_101470F9;
// 101470FA: using guessed type char byte_101470FA;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10003860) --------------------------------------------------------
char __thiscall sub_10003860(void *this)
{
  int v1; // ecx@1
  int v2; // ebp@1
  void *v3; // ecx@1
  int v4; // ebp@1
  char result; // al@2
  unsigned __int8 v6; // bl@3
  int v7; // eax@4
  unsigned __int8 v8; // al@8
  int v9; // edx@9
  char v10; // si@14
  char v11; // bl@14
  char v12; // al@15
  char v13; // al@17
  char v14; // bl@20
  char v15; // al@21
  char v16; // al@23
  char v17; // si@28
  char v18; // bl@28
  char v19; // al@29
  char v20; // al@31
  char v21; // bl@34
  char v22; // al@35
  char v23; // al@37
  char v24; // bl@40
  char v25; // al@41
  char v26; // al@43
  char v27; // bl@46
  char v28; // al@47
  char v29; // al@49
  char v30; // si@54
  char v31; // bl@54
  char v32; // al@55
  char v33; // al@57
  char v34; // bl@60
  char v35; // al@61
  char v36; // al@63
  char v37; // [sp+6h] [bp-19Ah]@15
  char v38; // [sp+7h] [bp-199h]@17
  char v39; // [sp+8h] [bp-198h]@15
  int v40; // [sp+Ch] [bp-194h]@1
  int v41; // [sp+10h] [bp-190h]@1
  int v42[83]; // [sp+14h] [bp-18Ch]@9
  char v43; // [sp+160h] [bp-40h]@7
  int v44[11]; // [sp+170h] [bp-30h]@10

  v40 = sub_1002C5C0(this);
  v2 = j_HWM_pvg_hsdb_get_lrus_online(v1);
  v4 = sub_1002C660(v3) | v2;
  if ( sub_10060D80(6447, (int)&v41, 336) )
  {
    result = 0;
  }
  else
  {
    v6 = 0;
    while ( 1 )
    {
      v7 = *(&v41 + 7 * v6);
      if ( v7 )
      {
        if ( v7 & v40 && v7 & v4 && !j_HWM_pvg_hsdb_get_router_entry(v7, &v43) )
          break;
      }
LABEL_12:
      if ( ++v6 >= 0xCu )
      {
        LOBYTE(v40) = 0;
LABEL_14:
        v10 = v40;
        v11 = 0;
        while ( 1 )
        {
          v39 = v11;
          v12 = sub_1002D630(v10);
          if ( sub_100321C0(v12, 0, &v39, &v37) )
          {
            if ( v37 == 1 )
            {
              v13 = sub_1002D630(v10);
              if ( sub_10031D70(v13, 0, &v39, &v38) )
              {
                if ( v38 == 1 )
                  goto LABEL_69;
              }
            }
          }
          if ( (unsigned __int8)++v11 >= 2u )
          {
            v14 = 0;
            while ( 1 )
            {
              v39 = v14;
              v15 = sub_1002D630(v10);
              if ( sub_100321C0(v15, 2, &v39, &v37) )
              {
                if ( v37 == 1 )
                {
                  v16 = sub_1002D630(v10);
                  if ( sub_10031D70(v16, 2, &v39, &v38) )
                  {
                    if ( v38 == 1 )
                      goto LABEL_69;
                  }
                }
              }
              if ( (unsigned __int8)++v14 >= 2u )
              {
                LOBYTE(v40) = v40 + 1;
                if ( (unsigned __int8)v40 < 3u )
                  goto LABEL_14;
                LOBYTE(v40) = 0;
LABEL_28:
                v17 = v40;
                v18 = 0;
                while ( 1 )
                {
                  v39 = v18;
                  v19 = sub_10031B40(v17);
                  if ( sub_100321C0(v19, 0, &v39, &v37) )
                  {
                    if ( v37 == 1 )
                    {
                      v20 = sub_10031B40(v17);
                      if ( sub_10031D70(v20, 0, &v39, &v38) )
                      {
                        if ( v38 == 1 )
                          goto LABEL_69;
                      }
                    }
                  }
                  if ( (unsigned __int8)++v18 >= 8u )
                  {
                    v21 = 0;
                    while ( 1 )
                    {
                      v39 = v21;
                      v22 = sub_10031B40(v17);
                      if ( sub_100321C0(v22, 1, &v39, &v37) )
                      {
                        if ( v37 == 1 )
                        {
                          v23 = sub_10031B40(v17);
                          if ( sub_10031D70(v23, 1, &v39, &v38) )
                          {
                            if ( v38 == 1 )
                              goto LABEL_69;
                          }
                        }
                      }
                      if ( (unsigned __int8)++v21 >= 5u )
                      {
                        v24 = 0;
                        while ( 1 )
                        {
                          v39 = v24;
                          v25 = sub_10031B40(v17);
                          if ( sub_100321C0(v25, 2, &v39, &v37) )
                          {
                            if ( v37 == 1 )
                            {
                              v26 = sub_10031B40(v17);
                              if ( sub_10031D70(v26, 2, &v39, &v38) )
                              {
                                if ( v38 == 1 )
                                  goto LABEL_69;
                              }
                            }
                          }
                          if ( (unsigned __int8)++v24 >= 8u )
                          {
                            v27 = 0;
                            while ( 1 )
                            {
                              v39 = v27;
                              v28 = sub_10031B40(v17);
                              if ( sub_100321C0(v28, 9, &v39, &v37) )
                              {
                                if ( v37 == 1 )
                                {
                                  v29 = sub_10031B40(v17);
                                  if ( sub_10031D70(v29, 9, &v39, &v38) )
                                  {
                                    if ( v38 == 1 )
                                      goto LABEL_69;
                                  }
                                }
                              }
                              if ( (unsigned __int8)++v27 >= 2u )
                              {
                                LOBYTE(v40) = v40 + 1;
                                if ( (unsigned __int8)v40 < 2u )
                                  goto LABEL_28;
                                LOBYTE(v40) = 0;
LABEL_54:
                                v30 = v40;
                                v31 = 0;
                                while ( 1 )
                                {
                                  v39 = v31;
                                  v32 = sub_10031A10(v30);
                                  if ( sub_100321C0(v32, 1, &v39, &v37) )
                                  {
                                    if ( v37 == 1 )
                                    {
                                      v33 = sub_10031A10(v30);
                                      if ( sub_10031D70(v33, 1, &v39, &v38) )
                                      {
                                        if ( v38 == 1 )
                                          goto LABEL_69;
                                      }
                                    }
                                  }
                                  if ( (unsigned __int8)++v31 > 0x10u )
                                  {
                                    v34 = 16;
                                    while ( 1 )
                                    {
                                      v39 = v34;
                                      v35 = sub_10031A10(v30);
                                      if ( sub_100321C0(v35, 2, &v39, &v37) )
                                      {
                                        if ( v37 == 1 )
                                        {
                                          v36 = sub_10031A10(v30);
                                          if ( sub_10031D70(v36, 2, &v39, &v38) )
                                          {
                                            if ( v38 == 1 )
                                              goto LABEL_69;
                                          }
                                        }
                                      }
                                      if ( (unsigned __int8)++v34 > 0x28u )
                                      {
                                        LOBYTE(v40) = v40 + 1;
                                        if ( (unsigned __int8)v40 < 3u )
                                          goto LABEL_54;
                                        return 0;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v8 = 0;
    while ( 1 )
    {
      v9 = v42[v8 + 7 * v6];
      if ( v9 )
      {
        if ( v9 != v44[v8] )
          break;
      }
      if ( ++v8 >= 6u )
        goto LABEL_12;
    }
LABEL_69:
    result = 1;
  }
  return result;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 10061630: using guessed type int __cdecl j_HWM_pvg_hsdb_get_router_entry(_DWORD, _DWORD);
// 10003860: using guessed type int var_18C[83];
// 10003860: using guessed type int var_30[11];

//----- (10003CE0) --------------------------------------------------------
int sub_10003CE0()
{
  unsigned int v0; // esi@1
  int result; // eax@2

  v0 = 0;
  do
  {
    sub_10060A60(79, 5000);
    sub_10005CA0(dword_1014A5D8[v0]);
    result = sub_10060A00(79);
    v0 += 4;
  }
  while ( v0 < 20 );
  return result;
}
// 1014A5D8: using guessed type int dword_1014A5D8[];

//----- (10003D10) --------------------------------------------------------
void *sub_10003D10()
{
  unsigned int v0; // edi@1
  void *result; // eax@3
  int v2; // esi@7

  memset(dword_1014A5D8, 0, 0x50u);
  v0 = 0;
  do
  {
    switch ( v0 )
    {
      case 0u:
        dword_1014A5E4[0] = sub_100321F0(2u);
        result = sub_1000F760(1);
        dword_1014A5D8[0] = (int)result;
        break;
      case 1u:
        dword_1014A5F4 = 0x8000;
        result = sub_1000D490(0);
        dword_1014A5E8 = (int)result;
        break;
      case 2u:
        dword_1014A604 = sub_100321F0(0x10u);
        result = sub_1000D490(1u);
        dword_1014A5F8 = (int)result;
        break;
      case 3u:
        dword_1014A614 = sub_100321F0(2u);
        result = sub_1000D490(2u);
        dword_1014A608 = (int)result;
        break;
      default:
        v2 = 4 * v0;
        dword_1014A5E4[v2] = sub_100321F0(0x10u);
        result = sub_1000EC70();
        dword_1014A5D8[v2] = (int)result;
        break;
    }
    ++v0;
  }
  while ( v0 < 5 );
  return result;
}
// 1014A5D8: using guessed type int dword_1014A5D8[];
// 1014A5E4: using guessed type int dword_1014A5E4[];
// 1014A5E8: using guessed type int dword_1014A5E8;
// 1014A5F4: using guessed type int dword_1014A5F4;
// 1014A5F8: using guessed type int dword_1014A5F8;
// 1014A604: using guessed type int dword_1014A604;
// 1014A608: using guessed type int dword_1014A608;
// 1014A614: using guessed type int dword_1014A614;

//----- (10003DF0) --------------------------------------------------------
unsigned int __cdecl sub_10003DF0(int a1)
{
  unsigned int result; // eax@1
  int *v2; // edx@1

  result = 0;
  v2 = dword_1014A5D8;
  while ( __PAIR__(*(_WORD *)(*v2 + 46), *(_WORD *)(*v2 + 44)) != a1 )
  {
    ++result;
    v2 += 4;
    if ( result >= 5 )
      return -1;
  }
  return result;
}
// 1014A5D8: using guessed type int dword_1014A5D8[];

//----- (10003E30) --------------------------------------------------------
int __usercall sub_10003E30@<eax>(void (__cdecl *a1)(int, int, int, int)@<esi>, int a2, int a3, int a4, int a5)
{
  int result; // eax@2

  if ( a1 )
  {
    sub_10060A60(79, 5000);
    a1(a2, a3, a4, a5);
    result = sub_10060A00(79);
  }
  return result;
}

//----- (10003E70) --------------------------------------------------------
char __cdecl sub_10003E70(int a1)
{
  signed int v1; // edi@1
  int v2; // edi@5
  int v3; // edx@5
  __int16 v4; // cx@5
  __int16 v5; // ax@5
  int v6; // edx@5
  char result; // al@6
  char v8; // [sp+Ch] [bp-74h]@3
  int v9; // [sp+10h] [bp-70h]@5
  int v10; // [sp+14h] [bp-6Ch]@5
  int v11; // [sp+18h] [bp-68h]@5
  char v12; // [sp+1Ch] [bp-64h]@3

  v1 = sub_10003DF0(*(_DWORD *)(a1 + 2));
  if ( v1 < 0 )
    sub_10028BC0("..\\lib\\acl\\iop\\dlms\\iop_dlms_hsdb.c", 153, 0, 0);
  if ( sub_10012B10(33, (int)&byte_10A08A80, &v12, (unsigned __int16 *)&v8, 0x64u)
    && v1 >= 0
    && (v2 = 4 * v1,
        dword_1014A5DC[v2] = *(_DWORD *)(a1 + 20),
        dword_1014A5E0[v2] = *(_DWORD *)(a1 + 24),
        v3 = *(_DWORD *)(a1 + 2),
        v4 = *(_WORD *)(a1 + 16),
        v11 = 0,
        v9 = v3,
        LOBYTE(v3) = *(_BYTE *)(a1 + 1),
        v10 = 0,
        v5 = *(_WORD *)(a1 + 12),
        LOWORD(v11) = v4,
        BYTE2(v11) = v3,
        v6 = dword_1014A5E4[v2],
        HIWORD(v10) = v5,
        BYTE3(v11) = *(_BYTE *)a1,
        sub_10013ED0(408, v6, &v9, 1, (int)&byte_10A08A80)) )
  {
    result = 0;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\dlms\\iop_dlms_hsdb.c", 194, 0, 0);
    result = 13;
  }
  return result;
}
// 1014A5DC: using guessed type int dword_1014A5DC[];
// 1014A5E0: using guessed type int dword_1014A5E0[];
// 1014A5E4: using guessed type int dword_1014A5E4[];
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10003F60) --------------------------------------------------------
char __cdecl sub_10003F60(int a1, char a2)
{
  signed int v2; // eax@1
  int v3; // eax@3
  char result; // al@3
  int v5; // [sp-Ch] [bp-1Ch]@2
  char v6; // [sp-8h] [bp-18h]@2
  int v7; // [sp+4h] [bp-Ch]@3
  int v8; // [sp+8h] [bp-8h]@3

  v2 = sub_10003DF0(a1);
  if ( v2 >= 0 )
  {
    v3 = dword_1014A5E4[4 * v2];
    v8 = 0;
    v7 = a1;
    LOBYTE(v8) = a2;
    result = sub_10013ED0(410, v3, &v7, 1, (int)&byte_10A08A80);
    if ( result )
      return result;
    v6 = 0;
    v5 = 240;
  }
  else
  {
    v6 = 0;
    v5 = 227;
  }
  return sub_10028BC0("..\\lib\\acl\\iop\\dlms\\iop_dlms_hsdb.c", v5, v6, 0);
}
// 1014A5E4: using guessed type int dword_1014A5E4[];
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10003FF0) --------------------------------------------------------
char __cdecl sub_10003FF0(int a1, void *a2, size_t a3, void *a4, size_t a5)
{
  signed int v5; // edi@1
  char result; // al@2
  char v7; // bl@7
  int v8; // [sp+10h] [bp-5BCh]@3
  int v9; // [sp+14h] [bp-5B8h]@3
  char v10[1456]; // [sp+18h] [bp-5B4h]@3

  v5 = sub_10003DF0(a1);
  if ( v5 >= 0 )
  {
    v9 = 0;
    v8 = a1;
    LOWORD(v9) = a3;
    memcpy(v10, a2, a3);
    if ( a4 && a5 )
    {
      BYTE2(v9) = a5;
      memcpy(&v10[a3], a4, a5);
    }
    else
    {
      BYTE2(v9) = 0;
    }
    v7 = sub_10014160(411, v9 + BYTE2(v9) + 8, dword_1014A5E4[4 * v5], &v8, 1, (int)&byte_10A08A80);
    if ( !v7 )
      sub_10028BC0("..\\lib\\acl\\iop\\dlms\\iop_dlms_hsdb.c", 309, 0, 0);
    result = v7;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\dlms\\iop_dlms_hsdb.c", 274, 0, 0);
    result = 0;
  }
  return result;
}
// 1014A5E4: using guessed type int dword_1014A5E4[];
// 10A08A80: using guessed type char byte_10A08A80;
// 10003FF0: using guessed type char var_5B4[1456];

//----- (10004110) --------------------------------------------------------
char __cdecl sub_10004110(int a1, int a2)
{
  int v2; // eax@4
  signed int v3; // eax@7
  int v4; // esi@9
  signed int v5; // eax@12
  unsigned int v6; // ecx@19
  unsigned int v7; // esi@19
  char *v8; // edi@20
  unsigned int v9; // ebx@20
  signed int v10; // ebp@22
  unsigned int v11; // edi@26
  int *v12; // ebp@26
  int v14; // [sp+4h] [bp-63Ch]@5
  int v15; // [sp+8h] [bp-638h]@19
  char v16; // [sp+Ch] [bp-634h]@17
  char v17; // [sp+14h] [bp-62Ch]@20
  int v18; // [sp+70h] [bp-5D0h]@11
  int v19; // [sp+77h] [bp-5C9h]@14
  int v20; // [sp+7Ch] [bp-5C4h]@5
  unsigned __int16 v21; // [sp+80h] [bp-5C0h]@6
  unsigned __int8 v22; // [sp+82h] [bp-5BEh]@6
  int v23; // [sp+83h] [bp-5BDh]@10
  int v24; // [sp+634h] [bp-Ch]@19
  char v25; // [sp+638h] [bp-8h]@19

  switch ( (unsigned __int16)a1 )
  {
    case 0x21u:
      v14 = 0;
      LOBYTE(v2) = sub_10012B10(a1, a2, &v16, (unsigned __int16 *)&v14, 0x64u);
      if ( (_BYTE)v2 )
      {
        LOBYTE(v2) = v14;
        if ( (unsigned __int16)v14 >= 4u )
        {
          v6 = (unsigned __int16)v14 - 4;
          v7 = v6 / 0xC;
          v15 = sub_1002C660((void *)v6);
          LOBYTE(v2) = 0;
          v24 = 0;
          v25 = 0;
          if ( v7 )
          {
            v8 = &v17;
            v9 = v7;
            do
            {
              if ( *((_DWORD *)v8 - 1) == v15 )
              {
                v10 = sub_10003DF0(*(_DWORD *)v8);
                if ( v10 >= 0 )
                {
                  LOBYTE(v2) = sub_10003E30(
                                 (void (__cdecl *)(int, int, int, int))dword_1014A5DC[4 * v10],
                                 dword_1014A5D8[4 * v10],
                                 (unsigned __int8)v8[4],
                                 v8[5],
                                 (unsigned __int8)v8[6]);
                  *((_BYTE *)&v24 + v10) = 1;
                }
                else
                {
                  LOBYTE(v2) = sub_10028BC0("..\\lib\\acl\\iop\\dlms\\iop_dlms_hsdb.c", 396, 0, 0);
                }
              }
              v8 += 12;
              --v9;
            }
            while ( v9 );
          }
          v11 = 0;
          v12 = dword_1014A5D8;
          do
          {
            if ( !*((_BYTE *)&v24 + v11) )
              LOBYTE(v2) = sub_10003E30((void (__cdecl *)(int, int, int, int))v12[1], *v12, 4, 0, 0);
            ++v11;
            v12 += 4;
          }
          while ( v11 < 5 );
        }
      }
      break;
    case 0x199u:
      LOBYTE(v2) = sub_100144B0(a1, a2, &v18);
      if ( (_BYTE)v2 )
      {
        v5 = sub_10003DF0(v18);
        LOBYTE(v2) = v5 >= 0 ? (unsigned __int8)sub_10003E30(
                                                  (void (__cdecl *)(int, int, int, int))dword_1014A5DC[4 * v5],
                                                  dword_1014A5D8[4 * v5],
                                                  v19,
                                                  0,
                                                  0) : sub_10028BC0(
                                                         "..\\lib\\acl\\iop\\dlms\\iop_dlms_hsdb.c",
                                                         432,
                                                         0,
                                                         0);
        if ( (_BYTE)v19 == 8 )
          LOBYTE(v2) = sub_100211E0();
      }
      break;
    case 0x19Bu:
      v14 = 0;
      LOBYTE(v2) = sub_10012B10(a1, a2, &v20, (unsigned __int16 *)&v14, 0x5B6u);
      if ( (_BYTE)v2 )
      {
        LOBYTE(v2) = v14;
        if ( (unsigned __int16)v14 == v22 + v21 + 8 )
        {
          v3 = sub_10003DF0(v20);
          if ( v3 >= 0 )
          {
            v2 = 16 * v3;
            v4 = v2;
            if ( *(int *)((char *)dword_1014A5E0 + v2) )
            {
              sub_10060A60(79, 5000);
              (*(void (__cdecl **)(_DWORD, int, char *, _DWORD))((char *)dword_1014A5E0 + v4))(
                *(int *)((char *)dword_1014A5D8 + v4),
                v23,
                (char *)&v23 + 1,
                v21);
              LOBYTE(v2) = sub_10060A00(79);
            }
          }
          else
          {
            LOBYTE(v2) = sub_10028BC0("..\\lib\\acl\\iop\\dlms\\iop_dlms_hsdb.c", 455, 0, 0);
          }
        }
      }
      break;
    default:
      LOBYTE(v2) = sub_10028BC0("..\\lib\\acl\\iop\\dlms\\iop_dlms_hsdb.c", 476, 1, 0);
      break;
  }
  return v2;
}
// 1014A5D8: using guessed type int dword_1014A5D8[];
// 1014A5DC: using guessed type int dword_1014A5DC[];
// 1014A5E0: using guessed type int dword_1014A5E0[];

//----- (10004420) --------------------------------------------------------
int __cdecl sub_10004420(__int16 a1)
{
  unsigned int v1; // edi@2
  int result; // eax@3

  if ( a1 == 33 )
  {
    v1 = 0;
    do
    {
      result = sub_10003E30((void (__cdecl *)(int, int, int, int))dword_1014A5DC[v1], dword_1014A5D8[v1], 13, 0, 0);
      v1 += 4;
    }
    while ( v1 < 20 );
  }
  return result;
}
// 1014A5D8: using guessed type int dword_1014A5D8[];
// 1014A5DC: using guessed type int dword_1014A5DC[];

//----- (10004460) --------------------------------------------------------
_BYTE *__cdecl sub_10004460(_DWORD **a1, __int16 a2, char a3)
{
  _DWORD *v3; // ecx@1
  _BYTE *result; // eax@2

  v3 = *a1;
  if ( *a1 == a1 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      result = v3 - 4;
      if ( *((_WORD *)v3 - 7) == a2 && *result == a3 )
        break;
      v3 = (_DWORD *)*v3;
      if ( v3 == a1 )
        goto LABEL_5;
    }
  }
  return result;
}

//----- (10004490) --------------------------------------------------------
int __cdecl sub_10004490(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // eax@1
  int result; // eax@3

  memset(a1, 0, 0x2Cu);
  v8 = a4 - 12;
  if ( (unsigned int)(a4 - 12) > 0x7A0 )
    v8 = 1952;
  *(_DWORD *)a1 = v8;
  *((_DWORD *)a1 + 1) = a5;
  *((_DWORD *)a1 + 2) = a2 + 0x1DF7E0u / a3;
  *((_DWORD *)a1 + 3) = sub_10060900();
  *((_DWORD *)a1 + 5) = (char *)a1 + 16;
  *((_DWORD *)a1 + 4) = (char *)a1 + 16;
  *((_DWORD *)a1 + 7) = (char *)a1 + 24;
  *((_DWORD *)a1 + 6) = (char *)a1 + 24;
  result = a8;
  *((_DWORD *)a1 + 8) = a6;
  *((_DWORD *)a1 + 9) = a7;
  *((_DWORD *)a1 + 10) = a8;
  return result;
}

//----- (10004510) --------------------------------------------------------
int __cdecl sub_10004510(int a1, int a2)
{
  unsigned __int8 v2; // al@1
  unsigned __int8 v3; // cl@1
  int result; // eax@2

  v2 = *(_BYTE *)(a1 + 40);
  v3 = *(_BYTE *)(a2 + 40);
  if ( v2 <= v3 )
    result = -(v2 != v3);
  else
    result = 1;
  return result;
}

//----- (10004530) --------------------------------------------------------
_BYTE *__usercall sub_10004530@<eax>(_BYTE *a1@<eax>, int a2@<ecx>, char a3@<bl>, int a4)
{
  int v4; // edi@1
  _BYTE *v5; // esi@1
  int v6; // ebp@1
  _BYTE *result; // eax@1
  int (__cdecl *v8)(int, int, char, _BYTE *); // eax@2
  int v9; // esi@3
  int v10; // ecx@5
  unsigned int v11; // eax@5
  int *v12; // edi@7
  int **v13; // eax@9
  int v14; // eax@9
  char v15; // [sp+0h] [bp-14h]@0
  int v16; // [sp+10h] [bp-4h]@1

  v4 = a2;
  v5 = a1;
  *a1 = 3;
  v6 = *(_DWORD *)(v4 + 8) + *(_DWORD *)(v4 + 12);
  v16 = a2 + 16;
  result = sub_10004460((_DWORD **)(a2 + 16), a4, v15);
  if ( !result )
  {
    v8 = *(int (__cdecl **)(int, int, char, _BYTE *))(v4 + 32);
    if ( v8 && (v9 = v8(v4, a4, a3, v5)) != 0 )
    {
      *(_WORD *)(v9 + 2) = a4;
      v10 = *(_DWORD *)(v9 + 44);
      *(_DWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 12) = 0;
      *(_DWORD *)(v9 + 24) = 0;
      *(_BYTE *)v9 = a3;
      *(_DWORD *)(v9 + 4) = v10;
      *(_DWORD *)(v9 + 28) = v6;
      v11 = (unsigned int)(v10 + (*(_DWORD *)v4 >> 1)) / *(_DWORD *)v4;
      if ( v11 <= 3 )
        v11 = 3;
      v12 = (int *)(v9 + 16);
      *(_DWORD *)(v9 + 32) = v11;
      if ( (int *)*v12 != v12 )
        sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1055, 1, 0);
      v13 = *(int ***)(v16 + 4);
      *(_DWORD *)(v16 + 4) = v12;
      *(_DWORD *)(v9 + 20) = v13;
      *v12 = v16;
      *v13 = v12;
      v14 = *(_DWORD *)(v9 + 40);
      *(_DWORD *)v14 = *(_DWORD *)(v9 + 44);
      *(_DWORD *)(v14 + 4) = -1;
      *(_DWORD *)(v14 + 8) = v6;
      result = (_BYTE *)v9;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10004600) --------------------------------------------------------
signed int __usercall sub_10004600@<eax>(int a1@<eax>, __int16 a2, char a3, char a4, int a5, int a6)
{
  int v6; // edx@1

  v6 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)v6 = 0;
  *(_DWORD *)(v6 + 4) = 0;
  *(_DWORD *)(v6 + 8) = 0;
  *(_DWORD *)(v6 + 12) = 0;
  **(_BYTE **)(a1 + 4) = 3;
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 4) = a4;
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 1) = a3;
  *(_WORD *)(*(_DWORD *)(a1 + 4) + 2) = a2;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = a5;
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = a6;
  return 16;
}

//----- (10004650) --------------------------------------------------------
int __usercall sub_10004650@<eax>(int a1@<edi>, int a2, int a3)
{
  unsigned int v3; // eax@1
  unsigned int v4; // esi@1
  int result; // eax@3

  v3 = *(_DWORD *)(a1 + 44);
  v4 = *(_DWORD *)(a1 + 48);
  if ( v4 >= v3 )
  {
    v4 = v3 - 1;
    memcpy(*(void **)(a1 + 40), (const void *)(*(_DWORD *)(a1 + 40) + 8), 8 * (v3 - 1));
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8 * v4) = a2;
  result = a3;
  *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8 * v4 + 4) = a3;
  *(_DWORD *)(a1 + 48) = v4 + 1;
  return result;
}

//----- (100046A0) --------------------------------------------------------
int __usercall sub_100046A0@<eax>(int result@<eax>, int a2@<edx>, unsigned int a3@<ecx>)
{
  if ( a3 < *(_DWORD *)(result + 44) )
  {
    result = *(_DWORD *)(result + 40);
    *(_DWORD *)(result + a3 + 4) = a2;
  }
  else
  {
    *(_DWORD *)(result + 24) = a2;
  }
  return result;
}

//----- (100046C0) --------------------------------------------------------
signed int __usercall sub_100046C0@<eax>(int a1@<eax>, __int16 a2@<di>, char a3)
{
  int v3; // esi@1
  _BYTE *v4; // eax@1
  signed int result; // eax@2
  unsigned int v6; // edx@3
  int i; // esi@3
  int v8; // ecx@4
  int v9; // [sp+0h] [bp-10h]@0
  int v10; // [sp+Ch] [bp-4h]@1

  v3 = a1;
  v4 = sub_10004530(&v10, a1, a3, v9);
  if ( v4 )
  {
    v6 = *((_DWORD *)v4 + 6);
    for ( i = *(_DWORD *)(v3 + 12) - 1; v6 < *((_DWORD *)v4 + 1); *(_DWORD *)(v8 + 8) = i )
    {
      v8 = v6 + *((_DWORD *)v4 + 10);
      v6 = *(_DWORD *)(v8 + 4);
    }
    result = 0;
  }
  else
  {
    result = sub_10004600(v3, a2, a3, v10, 0, 0);
  }
  return result;
}

//----- (10004720) --------------------------------------------------------
unsigned int __usercall sub_10004720@<eax>(unsigned int result@<eax>, int a2@<ecx>)
{
  int v2; // esi@1

  v2 = a2 - 12;
  if ( result > a2 - 12 )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1826, 0, "truncating fragment");
    result = v2;
  }
  return result;
}

//----- (10004750) --------------------------------------------------------
int __usercall sub_10004750@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  **(_BYTE **)(a1 + 4) = 2;
  *(_BYTE *)(*(_DWORD *)(a1 + 4) + 1) = *(_BYTE *)a2;
  *(_WORD *)(*(_DWORD *)(a1 + 4) + 2) = *(_WORD *)(a2 + 2);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) = a3;
  return (unsigned __int8)(*(int (__cdecl **)(int, int, _DWORD, signed int))(a1 + 36))(a1, a2, *(_DWORD *)(a1 + 4), 8) != 0 ? 0xFFFFFFF9 : 0;
}

//----- (10004790) --------------------------------------------------------
int __usercall sub_10004790@<eax>(int a1@<ecx>, int a2@<edi>, int a3@<esi>, int a4)
{
  int (__cdecl *v4)(int, int, int); // eax@1
  int result; // eax@3
  int v6; // ecx@4
  unsigned int v7; // edx@4
  int v8; // eax@6
  unsigned int v9; // ebp@6
  int v10; // ebx@6
  int (__cdecl *v11)(int, unsigned int, unsigned int); // eax@7
  int v12; // eax@8
  int v13; // eax@9
  int v14; // eax@12
  char v15; // [sp+3h] [bp-5h]@4
  unsigned int v16; // [sp+4h] [bp-4h]@4
  int v17; // [sp+4h] [bp-4h]@12

  v4 = *(int (__cdecl **)(int, int, int))(a2 + 40);
  if ( !v4 || (unsigned __int8)v4(a2, a3, a1) )
  {
    v6 = a4;
    v7 = *(_DWORD *)a2;
    v16 = *(_DWORD *)a2;
    v15 = (*(_DWORD *)(a3 + 8) >> 1) & 1;
    if ( !a4 || (*(_DWORD *)(a3 + 8) >> 1) & 1 )
    {
      v9 = *(_DWORD *)(a2 + 4);
      *(_BYTE *)v9 = 0;
      *(_BYTE *)(v9 + 1) = *(_BYTE *)a3;
      *(_WORD *)(v9 + 2) = *(_WORD *)(a3 + 2);
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(a3 + 8);
      v11 = *(int (__cdecl **)(int, unsigned int, unsigned int))(a3 + 72);
      v10 = v9 + 12;
      if ( v11 )
      {
        v12 = v11(a3, v9 + 12, v7);
        v6 = a4;
        v10 += v12;
        v7 = v16 - v12;
        *(_DWORD *)(a3 + 60) = v12;
      }
      v13 = *(_DWORD *)(a3 + 60) + *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a3 + 76) = v6;
      *(_DWORD *)(v9 + 4) = v13;
    }
    else
    {
      v8 = *(_DWORD *)(a2 + 4);
      v9 = *(_DWORD *)a2;
      *(_BYTE *)v8 = 1;
      *(_BYTE *)(v8 + 1) = *(_BYTE *)a3;
      *(_WORD *)(v8 + 2) = *(_WORD *)(a3 + 2);
      *(_DWORD *)(v8 + 4) = a4 + *(_DWORD *)(a3 + 60);
      v10 = v8 + 8;
    }
    if ( v7 > *(_DWORD *)(a3 + 4) - v6 )
      v7 = *(_DWORD *)(a3 + 4) - v6;
    v14 = (*(int (__cdecl **)(int, int, int, unsigned int))(a3 + 68))(a3, v6, v10, v7);
    v17 = v14;
    if ( v14 > 0 )
    {
      if ( v15 )
        *(_DWORD *)(v9 + 4) = v14 + *(_DWORD *)(a3 + 60);
      if ( (unsigned __int8)(*(int (__cdecl **)(int, int, _DWORD, int))(a2 + 36))(
                              a2,
                              a3,
                              *(_DWORD *)(a2 + 4),
                              v10 + v14 - *(_DWORD *)(a2 + 4)) )
      {
        result = -15;
      }
      else
      {
        *(_DWORD *)(a3 + 28) = *(_DWORD *)(a2 + 8) + *(_DWORD *)(a2 + 12);
        result = v17;
      }
    }
    else
    {
      result = (v14 != -7) - 15;
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100048C0) --------------------------------------------------------
signed int __usercall sub_100048C0@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<edi>, int a4@<esi>, char a5)
{
  unsigned int v5; // eax@1
  signed int v6; // eax@3
  signed int result; // eax@4

  v5 = *(_DWORD *)(a3 + 4);
  if ( a1 + a2 > v5 )
    a2 = v5 - a1;
  v6 = sub_10004600(a4, *(_WORD *)(a3 + 2), *(_BYTE *)a3, a5, a1, a2);
  if ( (unsigned __int8)(*(int (__cdecl **)(int, int, _DWORD, signed int))(a4 + 36))(a4, a3, *(_DWORD *)(a4 + 4), v6) )
  {
    result = -7;
  }
  else
  {
    result = 0;
    *(_DWORD *)(a3 + 28) = *(_DWORD *)(a4 + 8) + *(_DWORD *)(a4 + 12);
  }
  return result;
}

//----- (10004910) --------------------------------------------------------
int __usercall sub_10004910@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  int v3; // eax@1
  int result; // eax@1

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 4);
  *(_BYTE *)v3 = 4;
  *(_BYTE *)(v3 + 1) = *(_BYTE *)v2;
  *(_WORD *)(v3 + 2) = *(_WORD *)(v2 + 2);
  result = (*(int (__cdecl **)(int, int, int, signed int))(a2 + 36))(a2, v2, v3, 4);
  if ( (_BYTE)result )
  {
    if ( (_BYTE)result == 2 )
      result = sub_10004650(v2, *(_DWORD *)(v2 + 12), *(_DWORD *)(v2 + 24) - *(_DWORD *)(v2 + 12));
  }
  else
  {
    ++*(_DWORD *)(v2 + 52);
    *(_DWORD *)(v2 + 28) = *(_DWORD *)(a2 + 8) + *(_DWORD *)(a2 + 12);
  }
  return result;
}

//----- (10004960) --------------------------------------------------------
int (__cdecl *__usercall sub_10004960@<eax>(int a1@<esi>, int a2))(int, int)
{
  int v2; // ecx@1
  _DWORD *v3; // edx@1
  int v4; // eax@1
  int (__cdecl *result)(int, int); // eax@1

  v2 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD **)(a1 + 20);
  v4 = a1 + 16;
  *(_DWORD *)(v2 + 4) = v3;
  *v3 = v2;
  *(_DWORD *)v4 = v4;
  *(_DWORD *)(v4 + 4) = v4;
  result = *(int (__cdecl **)(int, int))(a1 + 36);
  if ( result )
    result = (int (__cdecl *)(int, int))result(a1, a2);
  return result;
}

//----- (10004990) --------------------------------------------------------
void *__usercall sub_10004990@<eax>(int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4, int a5, int a6, int a7, void *a8, int a9)
{
  int v9; // edi@1
  int v10; // edx@1
  int v11; // esi@1
  void *result; // eax@8
  int v13; // [sp+1Ch] [bp+Ch]@4

  v9 = a2;
  v10 = a9;
  v11 = 0;
  if ( a6 == a9 )
  {
    if ( v9 == a7 )
    {
      sub_100046A0(a5, *(_DWORD *)(a1 + 4), a3);
      v10 = a9;
    }
    else
    {
      v13 = *(_DWORD *)(a1 + 4);
      sub_100046A0(a5, v9, a3);
      v10 = a9;
      v11 = v9 + *(_DWORD *)(a5 + 40);
      *(_DWORD *)v11 = a7 - v9;
      *(_DWORD *)(v11 + 4) = v13;
    }
  }
  else
  {
    if ( v9 != a7 )
    {
      v11 = v9 + *(_DWORD *)(a5 + 40);
      *(_DWORD *)v11 = a7 - v9;
      *(_DWORD *)(v11 + 4) = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a1 + 4) = v9;
    }
    *(_DWORD *)a1 = a9 - a6;
  }
  result = memcpy((void *)(v10 + *(_DWORD *)(a5 + 40)), a8, v9 - v10);
  if ( v11 )
  {
    result = (void *)a4;
    *(_DWORD *)(v11 + 8) = *(_DWORD *)(a4 + 8) + *(_DWORD *)(a4 + 12);
  }
  return result;
}

//----- (10004A30) --------------------------------------------------------
int (__cdecl *__usercall sub_10004A30@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int (__cdecl *a4)(int, int)))(int, int)
{
  int v4; // edi@1
  unsigned int v5; // edx@1
  int (__cdecl *result)(int, int); // eax@1
  int v7; // esi@1
  int v8; // ebx@9

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 24);
  result = *(int (__cdecl **)(int, int))(a1 + 4);
  v7 = a2;
  if ( v5 < (unsigned int)result )
  {
    if ( *(_BYTE *)(v4 + 8) & 1 && v5 > *(_DWORD *)(v4 + 12) )
    {
      result = (int (__cdecl *)(int, int))sub_10004750(a2, v4, v5);
      if ( (signed int)result < 0 )
        return result;
      v5 = *(_DWORD *)(v4 + 24);
      *(_DWORD *)(v4 + 12) = v5;
    }
    for ( ; v5 < *(_DWORD *)(v4 + 4); v5 = *(_DWORD *)(v8 + 4) )
    {
      v8 = v5 + *(_DWORD *)(v4 + 40);
      if ( a3 )
      {
        result = a4;
        *(_DWORD *)(v8 + 8) += a4;
      }
      else if ( *(_DWORD *)(v7 + 12) > *(_DWORD *)(v8 + 8) )
      {
        if ( !*(_DWORD *)(v4 + 32) )
          return sub_10004960(v4, 10);
        result = (int (__cdecl *)(int, int))sub_100048C0(v5, *(_DWORD *)v8, v4, v7, 1);
        if ( (signed int)result < 0 )
          return result;
        *(_DWORD *)(v8 + 8) = *(_DWORD *)(v4 + 28);
        --*(_DWORD *)(v4 + 32);
      }
    }
  }
  else
  {
    result = (int (__cdecl *)(int, int))sub_10004750(a2, v4, (int)result);
    if ( (signed int)result >= 0 )
      result = sub_10004960(v4, 0);
  }
  return result;
}

//----- (10004AF0) --------------------------------------------------------
char __usercall sub_10004AF0@<al>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // esi@1
  char v4; // al@1
  int v5; // edi@1
  int v6; // eax@2
  int v7; // ebx@2
  int v8; // ebp@2
  int v9; // ecx@2
  int v10; // eax@5
  unsigned int i; // ecx@11
  int v12; // eax@17
  bool v13; // al@21
  char v15; // [sp+13h] [bp-5h]@1
  int v16; // [sp+14h] [bp-4h]@2

  v3 = a1;
  v4 = (*(_DWORD *)(a1 + 8) >> 1) & 1;
  v5 = a2;
  v15 = v4;
  if ( *(_DWORD *)(v3 + 48) )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v3 + 40);
      v7 = *(_DWORD *)(v3 + 48) - 1;
      v8 = *(_DWORD *)(v6 + 8 * v7 + 4);
      v9 = *(_DWORD *)(v6 + 8 * v7);
      v16 = *(_DWORD *)(v6 + 8 * v7);
      if ( !v8 )
        v8 = *(_DWORD *)(v3 + 4) - v9;
      if ( !*(_DWORD *)(v3 + 32) )
        goto LABEL_18;
      LOBYTE(v9) = 1;
      v10 = sub_10004790(v9, v5, v3, *(_DWORD *)(v6 + 8 * v7));
      if ( v10 <= 0 )
LABEL_19:
        return -v10;
      --*(_DWORD *)(v3 + 32);
      if ( v10 < v8 )
      {
        *(_DWORD *)(*(_DWORD *)(v3 + 40) + 8 * v7) = v10 + v16;
        *(_DWORD *)(*(_DWORD *)(v3 + 40) + 8 * v7 + 4) = v8 - v10;
      }
      else
      {
        --*(_DWORD *)(v3 + 48);
      }
      if ( !*(_DWORD *)(v3 + 48) )
      {
        v4 = v15;
        break;
      }
    }
  }
  for ( i = *(_DWORD *)(v3 + 24); i < *(_DWORD *)(v3 + 4); v4 = v15 )
  {
    if ( v4 && *(_DWORD *)(v3 + 24) > *(_DWORD *)(v3 + 12) )
      break;
    LOBYTE(i) = 0;
    v10 = sub_10004790(i, v5, v3, *(_DWORD *)(v3 + 24));
    if ( v10 <= 0 )
      goto LABEL_19;
    *(_DWORD *)(v3 + 24) += v10;
    i = *(_DWORD *)(v3 + 24);
  }
  if ( a3 <= 0 )
  {
    if ( v4 )
      v13 = *(_DWORD *)(v3 + 24) > *(_DWORD *)(v3 + 12);
    else
      v13 = *(_DWORD *)(v3 + 24) >= *(_DWORD *)(v3 + 4);
    if ( v13 && !*(_DWORD *)(v3 + 48) && *(_DWORD *)(v5 + 12) - *(_DWORD *)(v3 + 28) > 0 )
    {
      if ( *(_DWORD *)(v3 + 52) >= 3u )
      {
LABEL_18:
        LOBYTE(v12) = 10;
        return v12;
      }
      sub_10004910(v3, v5);
    }
    LOBYTE(v12) = 15;
    return v12;
  }
  *(_DWORD *)(v3 + 28) = *(_DWORD *)(v5 + 8) + *(_DWORD *)(v5 + 12);
  LOBYTE(v12) = 15;
  return v12;
}

//----- (10004C30) --------------------------------------------------------
int (__cdecl *__cdecl sub_10004C30(int a1))(int, int)
{
  return sub_10004960(a1, 13);
}

//----- (10004C50) --------------------------------------------------------
int (__cdecl *__cdecl sub_10004C50(int a1, int a2))(int, int)
{
  _DWORD *i; // edi@1
  int (__cdecl *result)(int, int); // eax@2
  _DWORD *j; // edi@3

  for ( i = (_DWORD *)(a1 + 24); (_DWORD *)*i != i; result = sub_10004960(*i - 16, a2) )
    ;
  for ( j = (_DWORD *)(a1 + 16); (_DWORD *)*j != j; result = sub_10004960(*j - 16, a2) )
    ;
  return result;
}

//----- (10004CA0) --------------------------------------------------------
int __cdecl sub_10004CA0(void *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // esi@1
  int result; // eax@1

  v4 = a1;
  memset(a1, 0, 0x50u);
  v4[5] = v4 + 4;
  v4[4] = v4 + 4;
  result = a2;
  *((_DWORD *)a1 + 9) = a2;
  *((_DWORD *)a1 + 10) = a3;
  *((_DWORD *)a1 + 11) = a4;
  return result;
}

//----- (10004CE0) --------------------------------------------------------
int __cdecl sub_10004CE0(void *a1, int a2, char a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD *v8; // esi@1
  int result; // eax@1

  v8 = a1;
  memset(a1, 0, 0x50u);
  v8[5] = v8 + 4;
  v8[4] = v8 + 4;
  *((_DWORD *)a1 + 9) = a2;
  *((_DWORD *)a1 + 10) = a4;
  *((_DWORD *)a1 + 11) = a5;
  *((_BYTE *)a1 + 56) = a3;
  result = a8;
  *((_DWORD *)a1 + 12) = 0;
  *((_DWORD *)a1 + 16) = a6;
  *((_DWORD *)a1 + 17) = a7;
  *((_DWORD *)a1 + 19) = 0;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 18) = a8;
  return result;
}

//----- (10004D50) --------------------------------------------------------
char __cdecl sub_10004D50(int a1, int a2, __int16 a3, char a4, int a5, int a6)
{
  int v6; // esi@1
  int *v7; // ebp@2
  unsigned int v8; // eax@3
  int v9; // edx@5
  int v10; // esi@6
  int *v11; // eax@8
  char result; // al@8
  int *v13; // eax@10
  int v14; // [sp+18h] [bp+8h]@1

  v6 = a2;
  v14 = a2 + 16;
  if ( *(_DWORD *)v14 != v14 || (v7 = (int *)(a1 + 24), sub_10004460((_DWORD **)(a1 + 24), a3, a4)) )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 755, 0, 0);
    result = 0;
  }
  else
  {
    *(_BYTE *)v6 = a4;
    *(_WORD *)(v6 + 2) = a3;
    *(_DWORD *)(v6 + 4) = a5;
    *(_DWORD *)(v6 + 8) = a6;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 24) = 0;
    *(_DWORD *)(v6 + 28) = *(_DWORD *)(a1 + 8) + sub_10060900();
    v8 = (unsigned int)(*(_DWORD *)(v6 + 4) + (*(_DWORD *)a1 >> 1)) / *(_DWORD *)a1;
    if ( v8 <= 3 )
      v8 = 3;
    *(_DWORD *)(v6 + 32) = v8;
    *(_DWORD *)(v6 + 48) = 0;
    *(_DWORD *)(v6 + 52) = 0;
    *(_DWORD *)(v6 + 76) = 0;
    *(_DWORD *)(v6 + 60) = 0;
    v9 = *v7;
    if ( (int *)*v7 == v7 )
    {
      v10 = v14;
    }
    else
    {
      while ( 1 )
      {
        v10 = v14;
        if ( sub_10004510(v9, v14) > 0 )
          break;
        v9 = *(_DWORD *)v9;
        if ( (int *)v9 == v7 )
        {
          v11 = *(int **)(v9 + 4);
          *(_DWORD *)(v9 + 4) = v14;
          *(_DWORD *)(v14 + 4) = v11;
          *(_DWORD *)v14 = v9;
          *v11 = v14;
          return 1;
        }
      }
    }
    v13 = *(int **)(v9 + 4);
    *(_DWORD *)(v9 + 4) = v10;
    *(_DWORD *)(v10 + 4) = v13;
    *(_DWORD *)v10 = v9;
    *v13 = v10;
    result = 1;
  }
  return result;
}

//----- (10004E50) --------------------------------------------------------
_DWORD **__cdecl sub_10004E50(int a1, int a2)
{
  int v2; // eax@1
  int v3; // edi@1
  int (__cdecl *v4)(int, int); // ebx@1
  _DWORD *v5; // ebp@1
  _DWORD *v6; // eax@1
  _DWORD *v7; // esi@1
  _DWORD **result; // eax@3
  _DWORD *v9; // ebx@3
  int v10; // esi@4
  bool v11; // zf@6

  v2 = sub_10060900();
  v3 = a1;
  v4 = (int (__cdecl *)(int, int))(v2 - *(_DWORD *)(a1 + 12));
  v5 = (_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 12) = v2;
  v6 = *(_DWORD **)(a1 + 16);
  v7 = **(_DWORD ***)(a1 + 16);
  if ( (_DWORD *)*v5 != v5 )
  {
    do
    {
      sub_10004A30((int)(v6 - 4), a1, a2, v4);
      v6 = v7;
      v7 = (_DWORD *)*v7;
    }
    while ( v6 != v5 );
  }
  result = *(_DWORD ***)(a1 + 24);
  v9 = *result;
  if ( result != (_DWORD **)(a1 + 24) )
  {
    do
    {
      v10 = (int)(result - 4);
      LOBYTE(a1) = sub_10004AF0((int)(result - 4), v3, a2);
      if ( (unsigned __int8)a1 < 0xFu )
        sub_10004960(v10, a1);
      result = (_DWORD **)v9;
      v11 = v9 == (_DWORD *)(v3 + 24);
      v9 = (_DWORD *)*v9;
    }
    while ( !v11 );
  }
  return result;
}

//----- (10004ED0) --------------------------------------------------------
char __usercall sub_10004ED0@<al>(int a1@<ecx>, int a2@<eax>, int a3, int a4, void *a5)
{
  unsigned int v5; // ebx@1
  int v6; // eax@2
  unsigned int v7; // ebp@3
  unsigned int v8; // esi@5
  int v9; // ecx@6
  unsigned int v10; // edi@7
  int v12; // [sp+4h] [bp-8h]@7
  unsigned int v13; // [sp+8h] [bp-4h]@5

  v5 = a1;
  if ( a2 )
  {
    v7 = a1 + a2;
    if ( a1 + a2 <= (unsigned int)a1 || (LOBYTE(v6) = a4, v7 > *(_DWORD *)(a4 + 4)) )
    {
      LOBYTE(v6) = sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1182, 0, 0);
    }
    else
    {
      v8 = *(_DWORD *)(a4 + 24);
      v13 = -1;
      if ( v8 < v7 )
      {
        v9 = *(_DWORD *)(a4 + 40);
        while ( 1 )
        {
          v6 = v9 + v8;
          v10 = v8 + *(_DWORD *)(v9 + v8);
          v12 = v9 + v8;
          if ( v5 < v10 && v7 > v8 )
            break;
          v13 = v8;
          v8 = *(_DWORD *)(v6 + 4);
          if ( v8 >= v7 )
            return v6;
        }
        if ( v5 < v8 )
        {
          sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1206, 0, "invld frag start, truncated");
          a5 = (char *)a5 + v8 - v5;
          v6 = v12;
          v5 = v8;
        }
        if ( v7 > v10 )
        {
          sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1214, 0, "invld frag size, truncated");
          v6 = v12;
          v7 = v10;
        }
        if ( v5 > v8 && v5 < v8 + 12 )
        {
          sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1226, 0, "truncating fragment");
          a5 = (char *)a5 + v8 + 12 - v5;
          v5 = v8 + 12;
          v6 = v12;
        }
        if ( v7 != v10 )
        {
          v7 = sub_10004720(v7, v10);
          v6 = v12;
        }
        if ( v5 < v7 )
          LOBYTE(v6) = (unsigned int)sub_10004990(v6, v7, v13, a3, a4, v8, v10, a5, v5);
        else
          LOBYTE(v6) = sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1238, 0, "fragment dropped (too small)");
      }
    }
  }
  else
  {
    LOBYTE(v6) = sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1168, 0, 0);
  }
  return v6;
}

//----- (10005050) --------------------------------------------------------
int (__cdecl *__usercall sub_10005050@<eax>(char a1@<al>, int a2@<edx>, __int16 a3@<cx>, unsigned int a4))(int, unsigned int)
{
  int (__cdecl *result)(int, unsigned int); // eax@1
  int v5; // esi@1
  unsigned int v6; // eax@2
  int v7; // eax@3
  unsigned int v8; // edi@5

  result = (int (__cdecl *)(int, unsigned int))sub_10004460((_DWORD **)(a2 + 24), a3, a1);
  v5 = (int)result;
  if ( result )
  {
    v6 = *((_DWORD *)result + 15);
    if ( a4 > v6 )
      v7 = a4 - v6;
    else
      v7 = 0;
    v8 = v7 + *(_DWORD *)(v5 + 76);
    if ( v8 > *(_DWORD *)(v5 + 4) )
    {
      sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1402, 0, "truncating invalid ACK");
      v8 = *(_DWORD *)(v5 + 4);
    }
    result = *(int (__cdecl **)(int, unsigned int))(v5 + 64);
    *(_DWORD *)(v5 + 12) = v8;
    if ( result )
      result = (int (__cdecl *)(int, unsigned int))result(v5, v8);
    if ( v8 < *(_DWORD *)(v5 + 4) )
    {
      if ( *(_BYTE *)(v5 + 8) & 2 )
        ++*(_BYTE *)v5;
    }
    else
    {
      result = (int (__cdecl *)(int, unsigned int))sub_10004960(v5, 0);
    }
  }
  return result;
}

//----- (100050D0) --------------------------------------------------------
signed int __usercall sub_100050D0@<eax>(int a1@<eax>, unsigned int *a2, int a3)
{
  int v3; // edi@1
  unsigned int v4; // eax@1
  _BYTE *v5; // eax@3
  int v6; // esi@3
  signed int result; // eax@4
  unsigned int v8; // eax@11
  int v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 4);
  v10 = v4 + 12;
  LOBYTE(v9) = 4;
  if ( !v4 || v4 + 12 < v4 )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1487, 0, 0);
    LOBYTE(v9) = 3;
    return sub_10004600((int)a2, *(_WORD *)(v3 + 2), *(_BYTE *)(v3 + 1), v9, 0, 0);
  }
  v5 = sub_10004530(&v9, (int)a2, *(_BYTE *)(v3 + 1), *(_WORD *)(v3 + 2));
  v6 = (int)v5;
  if ( !v5 )
    return sub_10004600((int)a2, *(_WORD *)(v3 + 2), *(_BYTE *)(v3 + 1), v9, 0, 0);
  if ( *((_DWORD *)v5 + 11) >= v10 )
  {
    if ( *((_DWORD *)v5 + 6) && *((_DWORD *)v5 + 1) != *(_DWORD *)(v3 + 4) )
    {
      sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1525, 0, 0);
      sub_10004960(v6, 8);
      result = sub_10004600((int)a2, *(_WORD *)(v3 + 2), *(_BYTE *)(v3 + 1), 2, 0, 0);
    }
    else
    {
      *((_DWORD *)v5 + 1) = *(_DWORD *)(v3 + 4);
      *((_DWORD *)v5 + 2) = *(_DWORD *)(v3 + 8);
      v8 = (*((_DWORD *)v5 + 1) + (*a2 >> 1)) / *a2;
      if ( v8 <= 3 )
        v8 = 3;
      *(_DWORD *)(v6 + 32) = v8;
      sub_10004ED0(0, a3 - 12, (int)a2, v6, (void *)(v3 + 12));
      result = 0;
    }
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1513, 0, 0);
    sub_10004960(v6, 11);
    result = sub_10004600((int)a2, *(_WORD *)(v3 + 2), *(_BYTE *)(v3 + 1), 3, 0, 0);
  }
  return result;
}

//----- (10005230) --------------------------------------------------------
signed int __usercall sub_10005230@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // eax@1
  int v5; // ecx@1
  signed int result; // eax@2

  v3 = a3 - 8;
  v4 = sub_10004530(&a3, a1, *(_BYTE *)(a2 + 1), *(_WORD *)(a2 + 2));
  v5 = *(_DWORD *)(a2 + 4);
  if ( v4 )
  {
    sub_10004ED0(v5, v3, a1, (int)v4, (void *)(a2 + 8));
    result = 0;
  }
  else
  {
    result = sub_10004600(a1, *(_WORD *)(a2 + 2), *(_BYTE *)(a2 + 1), a3, v5, v3);
  }
  return result;
}

//----- (10005290) --------------------------------------------------------
_DWORD *__usercall sub_10005290@<eax>(char a1@<al>, __int16 a2@<cx>, char a3@<bl>, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6; // ebp@1
  _DWORD *result; // eax@1
  int v8; // esi@1
  unsigned int v9; // eax@2
  int v10; // ecx@3
  unsigned int v11; // ecx@12
  unsigned int v12; // ecx@13
  void (__cdecl *v13)(int, _DWORD); // eax@18

  v6 = a6;
  result = sub_10004460((_DWORD **)(a4 + 24), a2, a1);
  v8 = (int)result;
  if ( result )
  {
    v9 = result[15];
    if ( a5 > v9 )
    {
      v10 = a5 - v9;
    }
    else
    {
      v6 = a6 - v9;
      v10 = 0;
    }
    result = (_DWORD *)(v10 + *(_DWORD *)(v8 + 76));
    if ( a3 )
    {
      if ( a3 == 1 )
      {
        v11 = *(_DWORD *)(v8 + 24);
        if ( (unsigned int)result < v11 )
        {
          v12 = v11 - (_DWORD)result;
          if ( v6 <= v12 )
            v12 = v6;
          result = (_DWORD *)sub_10004650(v8, (int)result, v12);
        }
      }
      else if ( a3 == 3 )
      {
        result = sub_10004960(v8, 12);
      }
      else
      {
        if ( a3 != 2 )
          sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1733, 0, 0);
        result = sub_10004960(v8, 8);
      }
    }
    else
    {
      if ( *(_DWORD *)(v8 + 24) < *(_DWORD *)(v8 + 4) )
        sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 1674, 0, "suspicious IOP_DTP_NACK_FILE_RECVD");
      v13 = *(void (__cdecl **)(int, _DWORD))(v8 + 64);
      if ( v13 )
        v13(v8, *(_DWORD *)(v8 + 4));
      result = sub_10004960(v8, 0);
    }
  }
  return result;
}

//----- (10005380) --------------------------------------------------------
signed int __cdecl sub_10005380(unsigned int *a1, int a2, int a3)
{
  signed int result; // eax@3

  switch ( *(_BYTE *)a2 )
  {
    case 0:
      if ( (unsigned int)(a3 - 12) > 0x7A0 )
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 650, 0, "DTP pkt 0x00 sz invld");
        result = 0;
      }
      else
      {
        result = sub_100050D0(a2, a1, a3);
      }
      break;
    case 1:
      if ( (unsigned int)(a3 - 8) > 0x7A0 )
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 662, 0, "DTP pkt 0x01 sz invld");
        result = 0;
      }
      else
      {
        result = sub_10005230((int)a1, a2, a3);
      }
      break;
    case 2:
      if ( a3 == 8 )
      {
        if ( *(_DWORD *)(a2 + 4) )
        {
          sub_10005050(*(_BYTE *)(a2 + 1), (int)a1, *(_WORD *)(a2 + 2), *(_DWORD *)(a2 + 4));
          result = 0;
        }
        else
        {
          sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 676, 0, "invld DTP ack");
          result = 0;
        }
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 681, 0, "DTP pkt 0x02 sz invld");
        result = 0;
      }
      break;
    case 3:
      if ( a3 == 16 )
      {
        sub_10005290(
          *(_BYTE *)(a2 + 1),
          *(_WORD *)(a2 + 2),
          *(_BYTE *)(a2 + 4),
          (int)a1,
          *(_DWORD *)(a2 + 8),
          *(_DWORD *)(a2 + 12));
        result = 0;
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 699, 0, "DTP pkt 0x03 sz invld");
        result = 0;
      }
      break;
    case 4:
      if ( a3 == 4 )
      {
        result = sub_100046C0((int)a1, *(_WORD *)(a2 + 2), *(_BYTE *)(a2 + 1));
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 711, 0, "DTP pkt 0x04 sz invld");
        result = 0;
      }
      break;
    default:
      sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp.c", 716, 0, "DTP pkt id invld");
      result = 0;
      break;
  }
  return result;
}

//----- (10005540) --------------------------------------------------------
int __cdecl sub_10005540(void *a1, int a2, int a3, int a4)
{
  memset(a1, 0, 0x58u);
  return sub_10004CA0(a1, a2, a3, a4);
}

//----- (10005570) --------------------------------------------------------
char __cdecl sub_10005570(int a1, int a2, void *a3, size_t a4)
{
  char v4; // cl@2
  size_t v6; // ecx@7
  size_t v7; // ecx@8
  char v8; // [sp+4h] [bp-Ch]@10
  char v9; // [sp+5h] [bp-Bh]@8
  __int16 v10; // [sp+6h] [bp-Ah]@8
  int v11; // [sp+8h] [bp-8h]@8
  size_t v12; // [sp+Ch] [bp-4h]@10

  if ( *(_BYTE *)(a1 + 50) >= 4u )
    return 1;
  v4 = *(_BYTE *)a3;
  if ( *(_BYTE *)a3 == 4 && *(_BYTE *)(a1 + 48) == 1 )
    return 2;
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      v6 = 0;
      goto LABEL_11;
    }
    v9 = *((_BYTE *)a3 + 1);
    v10 = *((_WORD *)a3 + 1);
    v11 = *((_DWORD *)a3 + 1);
    v7 = a4 - 8;
  }
  else
  {
    v9 = *((_BYTE *)a3 + 1);
    v10 = *((_WORD *)a3 + 1);
    v11 = 0;
    v7 = a4 - 12;
  }
  v12 = v7;
  v8 = 0;
  v6 = 12;
LABEL_11:
  if ( sub_10003FF0(*(_DWORD *)(a1 + 44), a3, a4, &v8, v6) )
  {
    --*(_DWORD *)(a1 + 68);
    ++*(_DWORD *)(a1 + 72);
    return 0;
  }
  return 1;
}

//----- (10005620) --------------------------------------------------------
signed int __usercall sub_10005620@<eax>(char a1@<al>, int a2@<edx>, __int16 a3@<cx>, unsigned int *a4)
{
  char v5; // [sp+0h] [bp-8h]@1
  char v6; // [sp+1h] [bp-7h]@1
  __int16 v7; // [sp+2h] [bp-6h]@1
  int v8; // [sp+4h] [bp-4h]@1

  v6 = a1;
  v7 = a3;
  v5 = 2;
  v8 = a2;
  return sub_10005380(a4, (int)&v5, 8);
}

//----- (10005650) --------------------------------------------------------
int (__cdecl *__cdecl sub_10005650(int a1, int a2))(int, int)
{
  int v2; // ecx@1
  int v3; // edx@3
  int v4; // eax@3
  _DWORD *v5; // esi@3
  int (__cdecl *result)(int, int); // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 80) = 0;
    *(_DWORD *)(a1 + 80) = 0;
    if ( (_BYTE)a2 )
    {
      v3 = *(_DWORD *)(v2 + 16);
      v4 = v2 + 16;
      v5 = *(_DWORD **)(v2 + 20);
      *(_DWORD *)(v3 + 4) = v5;
      *v5 = v3;
      *(_DWORD *)v4 = v4;
      *(_DWORD *)(v4 + 4) = v4;
      (*(void (__cdecl **)(int, int))(v2 + 36))(v2, a2);
    }
  }
  result = *(int (__cdecl **)(int, int))(a1 + 84);
  if ( result )
    result = (int (__cdecl *)(int, int))result(a1, a2);
  return result;
}

//----- (100056B0) --------------------------------------------------------
int (__cdecl *__usercall sub_100056B0@<eax>(int a1@<esi>))(int, int)
{
  int v1; // ecx@1
  _DWORD *v2; // edx@1
  int v3; // eax@1
  int (__cdecl *result)(int, int); // eax@1

  v1 = *(_DWORD *)(a1 + 16);
  v2 = *(_DWORD **)(a1 + 20);
  v3 = a1 + 16;
  *(_DWORD *)(v1 + 4) = v2;
  *v2 = v1;
  *(_DWORD *)v3 = v3;
  *(_DWORD *)(v3 + 4) = v3;
  result = *(int (__cdecl **)(int, int))(a1 + 80);
  if ( result )
  {
    *((_DWORD *)result + 20) = 0;
    result = sub_10004C30(*(_DWORD *)(a1 + 80));
    *(_DWORD *)(a1 + 80) = 0;
  }
  return result;
}

//----- (100056F0) --------------------------------------------------------
int __cdecl sub_100056F0(void *a1, int a2, char a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax@1

  memset(a1, 0, 0x58u);
  sub_10004CE0(a1, (int)sub_10005650, a3, a4, a5, a6, a7, a8);
  result = a2;
  *((_DWORD *)a1 + 21) = a2;
  return result;
}

//----- (10005740) --------------------------------------------------------
char __cdecl sub_10005740(int a1, int a2, int a3)
{
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // ecx@1
  unsigned __int8 v6; // al@1
  char result; // al@2
  _DWORD *v8; // ebx@4
  _DWORD *v9; // eax@7
  int v10; // ecx@12
  _DWORD *v11; // edx@12
  int v12; // eax@12
  int v13; // [sp+8h] [bp-4h]@1
  int v14; // [sp+14h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v5 = *(_DWORD *)(a2 + 12);
  v14 = *(_DWORD *)a2;
  v6 = *(_BYTE *)(a1 + 50);
  v13 = v5;
  if ( v6 > 4u )
    return v6 - 4;
  if ( a3 )
  {
    v8 = (_DWORD *)(a3 + 16);
    if ( (_DWORD *)*v8 != v8
      || sub_10004460((_DWORD **)(a1 + 16), *(_WORD *)(v4 + 4), *(_BYTE *)(v4 + 6))
      || sub_10004460((_DWORD **)(a1 + 56), *(_WORD *)(v4 + 4), *(_BYTE *)(v4 + 6)) )
    {
      sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp_dlms.c", 594, 0, 0);
      return 8;
    }
    *(_DWORD *)(v14 + 80) = a3;
    *(_DWORD *)(a3 + 80) = v14;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 24) = 0;
    *(_WORD *)(a3 + 2) = *(_WORD *)(v4 + 4);
    *(_BYTE *)a3 = *(_BYTE *)(v4 + 6);
    v9 = *(_DWORD **)(a1 + 60);
    v5 = v13;
    *(_DWORD *)(a1 + 60) = v8;
    *v8 = a1 + 56;
    v3 = a1;
    *(_DWORD *)(a3 + 20) = v9;
    *v9 = v8;
  }
  if ( *(_BYTE *)(v3 + 48) == 1 )
    v5 |= 2u;
  if ( sub_10004D50(v3, v14, *(_WORD *)(v4 + 4), *(_BYTE *)(v4 + 6), *(_DWORD *)(v4 + 8), v5) )
  {
    result = 0;
  }
  else
  {
    if ( a3 )
    {
      v10 = *(_DWORD *)(a3 + 16);
      v11 = *(_DWORD **)(a3 + 20);
      v12 = a3 + 16;
      *(_DWORD *)(v10 + 4) = v11;
      *v11 = v10;
      *(_DWORD *)v12 = v12;
      *(_DWORD *)(v12 + 4) = v12;
    }
    sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp_dlms.c", 656, 0, 0);
    result = 8;
  }
  return result;
}

//----- (100058E0) --------------------------------------------------------
char __usercall sub_100058E0@<al>(char a1@<dl>, int a2@<ecx>, unsigned int *a3@<esi>)
{
  char result; // al@1
  char v4; // al@7
  int v5; // eax@7
  int v6; // ecx@7
  char v7; // [sp+0h] [bp-14h]@7
  char v8; // [sp+1h] [bp-13h]@7
  __int16 v9; // [sp+2h] [bp-12h]@7
  char v10; // [sp+4h] [bp-10h]@7
  int v11; // [sp+8h] [bp-Ch]@7
  int v12; // [sp+Ch] [bp-8h]@7

  result = *(_BYTE *)a2;
  if ( *(_BYTE *)a2 && result != 1 )
  {
    result = sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp_dlms.c", 1018, 0, 0);
  }
  else if ( a1 & 2 )
  {
    if ( a1 & 4 )
      result = sub_10005620(*(_BYTE *)(a2 + 1), *(_DWORD *)(a2 + 4) + *(_DWORD *)(a2 + 8), *(_WORD *)(a2 + 2), a3);
  }
  else
  {
    v4 = *(_BYTE *)(a2 + 1);
    v9 = *(_WORD *)(a2 + 2);
    v8 = v4;
    v5 = *(_DWORD *)(a2 + 4);
    v6 = *(_DWORD *)(a2 + 8);
    v7 = 3;
    v10 = 1;
    v11 = v5;
    v12 = v6;
    result = sub_10005380(a3, (int)&v7, 16);
  }
  return result;
}

//----- (100059A0) --------------------------------------------------------
int __cdecl sub_100059A0(void *a1, int a2)
{
  unsigned int v2; // ebx@1
  int v3; // eax@4
  _DWORD *v4; // esi@6
  __int16 v5; // cx@6
  int v6; // edi@6
  int result; // eax@6

  v2 = *(_DWORD *)(a2 + 20);
  if ( v2 && v2 >= 0x19 && v2 <= 0x7B8 )
  {
    v3 = v2 - 12;
  }
  else
  {
    v3 = *(_BYTE *)(a2 + 4) != 1 ? 2048 : 1951;
    v2 = *(_BYTE *)(a2 + 4) != 1 ? 2048 : 1951;
  }
  v4 = a1;
  sub_10004490(
    a1,
    *(_DWORD *)(a2 + 8),
    *(_DWORD *)(a2 + 12),
    v3,
    *(_DWORD *)(a2 + 16),
    (int)sub_100058A0,
    (int)sub_10005570,
    (int)sub_10005880);
  *((_BYTE *)a1 + 48) = *(_BYTE *)(a2 + 4);
  *((_BYTE *)a1 + 49) = *(_BYTE *)(a2 + 5);
  *((_BYTE *)a1 + 50) = 4;
  *((_DWORD *)a1 + 11) = *(_DWORD *)a2;
  v5 = *(_WORD *)(a2 + 24);
  v4[15] = v4 + 14;
  *((_DWORD *)a1 + 16) = v2;
  v4[14] = v4 + 14;
  *((_WORD *)a1 + 26) = v5;
  *((_DWORD *)a1 + 17) = 0;
  *((_DWORD *)a1 + 18) = 0;
  *((_DWORD *)a1 + 19) = 0;
  v6 = *(_DWORD *)(a2 + 12);
  result = 858993461 * v6;
  *((_DWORD *)a1 + 20) = 9 * v6 / 0xAu;
  return result;
}
// 10005880: using guessed type int sub_10005880();
// 100058A0: using guessed type int sub_100058A0();

//----- (10005A50) --------------------------------------------------------
char __cdecl sub_10005A50(char *a1, char a2, int a3, char *a4)
{
  signed int v4; // eax@3
  int v5; // eax@4
  int v7; // [sp+4h] [bp-Ch]@4
  int v8; // [sp+8h] [bp-8h]@4
  int v9; // [sp+Ch] [bp-4h]@4

  if ( a2 & 1 )
  {
    if ( a4 == (char *)12 )
    {
      v7 = *(_DWORD *)a3;
      v5 = *(_DWORD *)(a3 + 8);
      v8 = *(_DWORD *)(a3 + 4);
      v9 = v5;
      LOBYTE(v4) = sub_100058E0(a2, (int)&v7, (unsigned int *)a1);
    }
    else
    {
      LOBYTE(v4) = sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp_dlms.c", 913, 0, "invalid tx result size");
    }
  }
  else
  {
    v4 = sub_10005380((unsigned int *)a1, a3, (int)a4);
    if ( v4 )
      LOBYTE(v4) = sub_10005570((int)a1, 0, *((void **)a1 + 1), v4);
  }
  return v4;
}

//----- (10005AF0) --------------------------------------------------------
char __cdecl sub_10005AF0(int a1)
{
  int v1; // ebp@1
  _DWORD *v2; // edi@1
  int v3; // esi@2
  char result; // al@3

  v1 = a1;
  LOBYTE(a1) = *(_BYTE *)(a1 + 50) - 4;
  sub_10004C50(v1, a1);
  v2 = (_DWORD *)(v1 + 56);
  while ( (_DWORD *)*v2 != v2 )
  {
    v3 = *v2 - 16;
    sub_100056B0(v3);
    (*(void (__cdecl **)(int, int))(v3 + 36))(v3, a1);
  }
  result = *(_BYTE *)(v1 + 50);
  if ( result != 6 && result != 8 && result != 9 )
    *(_BYTE *)(v1 + 50) = 4;
  return result;
}

//----- (10005B50) --------------------------------------------------------
char __usercall sub_10005B50@<al>(unsigned __int8 a1@<bl>, int a2@<esi>)
{
  _DWORD *v2; // eax@1

  *(_BYTE *)(a2 + 50) = a1;
  v2 = (_DWORD *)sub_10060900();
  *(_DWORD *)(a2 + 76) = v2;
  if ( a1 <= 4u )
  {
    if ( a1 == 4 )
    {
      v2 = (_DWORD *)(a2 + 24);
      if ( (_DWORD *)*v2 == v2 )
      {
        *(_BYTE *)(a2 + 50) = 11;
        LOBYTE(v2) = sub_10005AF0(a2);
      }
    }
  }
  else
  {
    LOBYTE(v2) = sub_10005AF0(a2);
  }
  return (unsigned int)v2;
}

//----- (10005BF0) --------------------------------------------------------
char __cdecl sub_10005BF0(int a1)
{
  _DWORD *v1; // eax@1

  LOBYTE(v1) = 4;
  if ( *(_BYTE *)(a1 + 50) > 4u )
  {
    *(_BYTE *)(a1 + 50) = 4;
    *(_DWORD *)(a1 + 76) = sub_10060900();
    v1 = (_DWORD *)(a1 + 24);
    if ( (_DWORD *)*v1 == v1 )
    {
      *(_BYTE *)(a1 + 50) = 11;
      LOBYTE(v1) = sub_10005AF0(a1);
    }
  }
  return (unsigned int)v1;
}

//----- (10005C20) --------------------------------------------------------
char __usercall sub_10005C20@<al>(int a1@<esi>)
{
  int v1; // edx@1
  char v2; // cl@1
  int v3; // eax@1
  int v4; // ecx@1
  char v5; // al@1
  char v6; // bl@1
  _DWORD *v7; // eax@1
  char v9; // [sp+4h] [bp-1Ch]@1
  char v10; // [sp+5h] [bp-1Bh]@1
  int v11; // [sp+6h] [bp-1Ah]@1
  int v12; // [sp+Ch] [bp-14h]@1
  int v13; // [sp+10h] [bp-10h]@1
  int v14; // [sp+14h] [bp-Ch]@1
  int (*v15)(); // [sp+18h] [bp-8h]@1
  char (__cdecl *v16)(char *, char, int, char *); // [sp+1Ch] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 44);
  v2 = *(_BYTE *)(a1 + 48);
  v9 = *(_BYTE *)(a1 + 49);
  v3 = *(_WORD *)(a1 + 52);
  v11 = v1;
  v10 = v2;
  v4 = *(_DWORD *)(a1 + 64);
  v12 = a1;
  v13 = v3;
  v14 = v4;
  v15 = sub_10005B80;
  v16 = sub_10005A50;
  v5 = sub_10003E70((int)&v9);
  v6 = v5;
  *(_BYTE *)(a1 + 50) = v5;
  v7 = (_DWORD *)sub_10060900();
  *(_DWORD *)(a1 + 76) = v7;
  if ( (unsigned __int8)v6 > 4u )
    goto LABEL_5;
  if ( v6 == 4 )
  {
    v7 = (_DWORD *)(a1 + 24);
    if ( (_DWORD *)*v7 == v7 )
    {
      *(_BYTE *)(a1 + 50) = 11;
LABEL_5:
      LOBYTE(v7) = sub_10005AF0(a1);
      return (unsigned int)v7;
    }
  }
  return (unsigned int)v7;
}
// 10005B80: using guessed type int sub_10005B80();

//----- (10005CA0) --------------------------------------------------------
char __cdecl sub_10005CA0(int a1)
{
  _DWORD *v1; // eax@1
  _DWORD *v2; // edi@1
  bool v3; // cf@2

  LOBYTE(v1) = (unsigned int)sub_10004E50(a1, *(_DWORD *)(a1 + 72));
  v2 = (_DWORD *)(a1 + 24);
  if ( (_DWORD *)*v2 == v2 )
    goto LABEL_4;
  v3 = *(_BYTE *)(a1 + 50) < 4u;
  if ( *(_BYTE *)(a1 + 50) == 4 )
  {
    LOBYTE(v1) = sub_10005C20(a1);
LABEL_4:
    v3 = *(_BYTE *)(a1 + 50) < 4u;
  }
  if ( v3 && (_DWORD *)*v2 == v2 )
  {
    v1 = (_DWORD *)(a1 + 16);
    if ( (_DWORD *)*v1 == v1 )
    {
      v1 = (_DWORD *)(a1 + 56);
      if ( (_DWORD *)*v1 == v1 )
      {
        sub_10003F60(*(_DWORD *)(a1 + 44), 1);
        *(_BYTE *)(a1 + 50) = 4;
        v1 = (_DWORD *)sub_10060900();
        *(_DWORD *)(a1 + 76) = v1;
        if ( (_DWORD *)*v2 == v2 )
        {
          *(_BYTE *)(a1 + 50) = 11;
          LOBYTE(v1) = sub_10005AF0(a1);
        }
      }
    }
  }
  return (unsigned int)v1;
}

//----- (10005D10) --------------------------------------------------------
char sub_10005D10()
{
  int v0; // eax@1
  int v1; // ecx@1
  char v3; // [sp+0h] [bp-51Ch]@3
  char v4; // [sp+2h] [bp-51Ah]@3
  char v5; // [sp+3h] [bp-519h]@3

  sub_10060A60(79, 5000);
  sub_10004E50(dword_1014A62C[0], 0);
  LOBYTE(v0) = sub_10060A00(79);
  if ( (_BYTE)dword_1014A638 )
  {
    v0 = j_HWM_pvg_hsdb_get_lrus_online(v1);
    if ( v0 & dword_1014A634 )
    {
      memset(&v3, 0, 0x518u);
      v4 = dword_1014A628;
      v5 = 1;
      LOBYTE(v0) = sub_10014160(418, 4u, dword_1014A634, &v3, 1, (int)&byte_10A08A80);
      if ( (_BYTE)v0 )
        LOBYTE(dword_1014A638) = 0;
    }
  }
  return v0;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 1014A628: using guessed type int dword_1014A628;
// 1014A62C: using guessed type int dword_1014A62C[];
// 1014A634: using guessed type int dword_1014A634;
// 1014A638: using guessed type int dword_1014A638;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10005DC0) --------------------------------------------------------
int __cdecl sub_10005DC0(int a1)
{
  int result; // eax@1

  result = dword_1014A62C[0];
  if ( dword_1014A62C[0] == a1 )
    LOBYTE(dword_1014A638) = 1;
  return result;
}
// 1014A62C: using guessed type int dword_1014A62C[];
// 1014A638: using guessed type int dword_1014A638;

//----- (10005DE0) --------------------------------------------------------
void __cdecl sub_10005DE0(int a1, int a2)
{
  int v2; // eax@4
  int v3; // esi@4
  signed int v4; // esi@7
  int v5; // eax@8
  int v6; // [sp+8h] [bp-520h]@2
  int v7; // [sp+Ch] [bp-51Ch]@2
  char v8; // [sp+10h] [bp-518h]@7

  if ( (_WORD)a1 == 418 )
  {
    v6 = 0;
    if ( sub_10012B10(a1, a2, &v7, (unsigned __int16 *)&v6, 0x518u) )
    {
      if ( (unsigned __int16)v6 == (unsigned __int16)v7 + 4 )
      {
        v2 = sub_1002CC90((int *)((char *)&v7 + 2), 1u, (int)&dword_1014A628, 20, 1, -1);
        v3 = v2;
        if ( v2 >= 0 )
        {
          if ( BYTE3(v7) )
          {
            ((void (*)(void))dword_1014A630[5 * v2])();
          }
          else
          {
            sub_10060A60(79, 5000);
            v4 = sub_10005380((unsigned int *)dword_1014A62C[5 * v3], (int)&v8, (unsigned __int16)v7);
            sub_10060A00(79);
            if ( v4 )
            {
              LOWORD(v7) = v4;
              v5 = sub_10012AC0(a1, a2);
              if ( !sub_10014160(418, v7 + 4, v5, &v7, 1, a2) )
                sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp_hsdb.c", 246, 0, 0);
            }
          }
        }
        else
        {
          sub_10028BC0("..\\lib\\acl\\iop\\iop_dtp_hsdb.c", 218, 0, 0);
        }
      }
    }
  }
}
// 1014A628: using guessed type int dword_1014A628;
// 1014A62C: using guessed type int dword_1014A62C[];
// 1014A630: using guessed type int dword_1014A630[];

//----- (10005FC0) --------------------------------------------------------
char sub_10005FC0()
{
  unsigned int v0; // eax@1
  int v1; // ecx@1
  char v2; // al@2
  int v3; // edx@2
  signed int v4; // edi@2
  char i; // bl@2
  void *v6; // ecx@6
  unsigned int v7; // esi@6
  int v9; // [sp+0h] [bp-4h]@2

  LOBYTE(v0) = sub_100324A0(2);
  if ( (_BYTE)v0 )
  {
    v9 = v1;
    v2 = sub_10032560(1u);
    v3 = dword_103E0644;
    v4 = 0;
    for ( i = v2; dword_103E0644 != dword_10152344; v3 = dword_103E0644 )
    {
      if ( v4 >= 20 )
        break;
      sub_10006430((int)&unk_10428AE8 + 432 * v3, (int)&byte_1015534C, &unk_103E0648, 10240, (int)sub_10007CE0);
      ++v4;
      dword_103E0644 = (dword_103E0644 + 1) % 0x28u;
    }
    if ( i == 2 )
    {
      v7 = sub_10060900();
      if ( byte_1015534A != 2 )
      {
        byte_103E0640 = 1;
        byte_10428AD8 = 1;
        byte_101864B8 = 1;
LABEL_12:
        byte_10155348 = 15;
        goto LABEL_13;
      }
      if ( !byte_1015534B && sub_1002C5E0(v6) == 4 && v7 > dword_101864BC )
      {
        byte_103E0640 = sub_1001F800(
                          (int)"FISB",
                          (int)"FISB_precip.dat",
                          (int)&unk_101864C0,
                          0x6D788u,
                          (int)&unk_101F3C5C,
                          2017764,
                          (int)&v9,
                          (int)&dword_101F3C58);
        byte_10428AD8 = sub_1001F800(
                          (int)"FISB",
                          (int)"FISB_metars.dat",
                          (int)&unk_103E2E48,
                          0x45C94u,
                          0,
                          0,
                          (int)&v9,
                          0);
        byte_101864B8 = sub_1001F800((int)"FISB", (int)"FISB_tafs.dat", (int)&unk_10155378, 0x31144u, 0, 0, (int)&v9, 0);
        dword_101864BC = v7 + 600000;
        goto LABEL_12;
      }
    }
LABEL_13:
    LOBYTE(v0) = sub_100076D0();
    if ( (_BYTE)v0 || i != 2 )
      goto LABEL_31;
    if ( v4 >= dword_10152340 )
    {
      v0 = sub_10060900();
      if ( dword_10428AE0 >= v0 )
      {
LABEL_31:
        byte_1015534A = i;
        return v0;
      }
      ++dword_10152340;
    }
    else
    {
      if ( byte_10428AD8 )
      {
        byte_10428AD8 = 0;
        sub_10007E20();
        if ( byte_1015534B )
        {
          if ( (unsigned int)++dword_10427F1C > 5 )
          {
            dword_10427F1C = 0;
            sub_1001FAA0((int)"FISB", (int)"FISB_metars.dat", (int)&unk_103E2E48, 285844, 0, 0, 0);
          }
        }
      }
      if ( byte_103E0640 )
      {
        byte_103E0640 = 0;
        sub_10008000();
        if ( byte_1015534B )
          sub_1001FAA0(
            (int)"FISB",
            (int)"FISB_precip.dat",
            (int)&unk_101864C0,
            448392,
            (int)&unk_101F3C5C,
            2017764,
            (int)&dword_101F3C58);
      }
      if ( byte_101864B8 )
      {
        byte_101864B8 = 0;
        sub_100081D0();
        if ( byte_1015534B )
        {
          if ( (unsigned int)++dword_10185B54 > 5 )
          {
            dword_10185B54 = 0;
            sub_1001FAA0((int)"FISB", (int)"FISB_tafs.dat", (int)&unk_10155378, 201028, 0, 0, 0);
          }
        }
      }
      byte_10155348 = 1;
      dword_10152340 = 2;
    }
    v0 = sub_10060900() + 10000;
    dword_10428AE0 = v0;
    goto LABEL_31;
  }
  return v0;
}
// 10152340: using guessed type int dword_10152340;
// 10152344: using guessed type int dword_10152344;
// 10155348: using guessed type char byte_10155348;
// 1015534A: using guessed type char byte_1015534A;
// 1015534B: using guessed type char byte_1015534B;
// 1015534C: using guessed type char byte_1015534C;
// 10185B54: using guessed type int dword_10185B54;
// 101864B8: using guessed type char byte_101864B8;
// 101864BC: using guessed type int dword_101864BC;
// 101F3C58: using guessed type int dword_101F3C58;
// 103E0640: using guessed type char byte_103E0640;
// 103E0644: using guessed type int dword_103E0644;
// 10427F1C: using guessed type int dword_10427F1C;
// 10428AD8: using guessed type char byte_10428AD8;
// 10428AE0: using guessed type int dword_10428AE0;

//----- (10005FF0) --------------------------------------------------------
int __cdecl sub_10005FF0(int a1, int a2, int a3, void *a4, int a5, int a6)
{
  __int16 v6; // ax@1
  bool v7; // zf@1
  char v8; // al@7
  char v9; // al@10
  size_t v10; // edi@15
  char v12; // [sp+Ch] [bp-14h]@1

  sub_10020C40((int)&v12, a2, a1);
  *(_BYTE *)(a3 + 12) = sub_10020C80((int)&v12, 1, 0);
  *(_BYTE *)(a3 + 5) = sub_10020C80((int)&v12, 1, 0);
  *(_BYTE *)(a3 + 4) = sub_10020C80((int)&v12, 1, 0);
  v6 = sub_10020C80((int)&v12, 11, 0);
  v7 = *(_BYTE *)(a3 + 12) == 0;
  *(_WORD *)(a3 + 2) = v6;
  if ( v7 )
  {
    *(_BYTE *)(a3 + 13) = 0;
    *(_BYTE *)(a3 + 14) = 0;
  }
  else
  {
    *(_BYTE *)(a3 + 13) = sub_10020C80((int)&v12, 4, 0);
    *(_BYTE *)(a3 + 14) = sub_10020C80((int)&v12, 4, 0);
  }
  if ( *(_BYTE *)(a3 + 5) )
    *(_DWORD *)(a3 + 8) = sub_10020C80((int)&v12, 20, 0);
  else
    *(_DWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 32) = sub_10020C80((int)&v12, 1, 0);
  v8 = sub_10020C80((int)&v12, 2, 0);
  *(_BYTE *)(a3 + 15) = v8;
  if ( v8 & 2 )
  {
    *(_BYTE *)(a3 + 16) = sub_10020C80((int)&v12, 4, 0);
    *(_BYTE *)(a3 + 17) = sub_10020C80((int)&v12, 5, 0);
  }
  else
  {
    *(_BYTE *)(a3 + 16) = 0;
    *(_BYTE *)(a3 + 17) = 0;
  }
  *(_BYTE *)(a3 + 18) = sub_10020C80((int)&v12, 5, 0);
  v9 = sub_10020C80((int)&v12, 6, 0);
  v7 = (*(_BYTE *)(a3 + 15) & 1) == 0;
  *(_BYTE *)(a3 + 19) = v9;
  if ( v7 )
    *(_BYTE *)(a3 + 20) = 0;
  else
    *(_BYTE *)(a3 + 20) = sub_10020C80((int)&v12, 6, 0);
  if ( *(_BYTE *)(a3 + 32) )
  {
    *(_BYTE *)a3 = 0;
    *(_WORD *)(a3 + 34) = 0;
    *(_WORD *)(a3 + 40) = 0;
    *(_DWORD *)(a3 + 36) = 0;
    *(_BYTE *)a6 = 1;
  }
  else
  {
    v10 = a2 - sub_10020C00((int *)&v12, 1);
    sub_10020C60((int)&v12, 8 * v10);
    *(_BYTE *)a3 = 1;
    *(_DWORD *)(a3 + 28) = a4;
    *(_DWORD *)(a3 + 24) = v10;
    memcpy(a4, (const void *)(a2 + a1 - v10), v10);
    memset((char *)a4 + v10, 0, a5 - v10);
    *(_WORD *)(a3 + 34) = 0;
    *(_DWORD *)(a3 + 36) = 0;
    *(_WORD *)(a3 + 40) = 0;
    *(_BYTE *)a6 = 0;
  }
  return sub_10020C00((int *)&v12, 1);
}

//----- (100061D0) --------------------------------------------------------
int __cdecl sub_100061D0(int a1, int a2, _WORD *a3, _BYTE *a4)
{
  char v5; // [sp+0h] [bp-14h]@1

  sub_10020C40((int)&v5, a2, a1);
  *a3 = sub_10020C80((int)&v5, 9, 0);
  sub_10020C60((int)&v5, 3);
  *a4 = sub_10020C80((int)&v5, 4, 0);
  return sub_10020C00((int *)&v5, 1);
}

//----- (10006230) --------------------------------------------------------
int __cdecl sub_10006230(int a1, int a2, int a3)
{
  char v4; // [sp+4h] [bp-14h]@1

  sub_10020C40((int)&v4, a2, a1);
  *(_DWORD *)(a3 + 4) = sub_10020C80((int)&v4, 23, 1) << 8;
  *(_DWORD *)(a3 + 8) = sub_10020C80((int)&v4, 24, 1) << 8;
  *(_BYTE *)a3 = sub_10020C80((int)&v4, 1, 0);
  *(_BYTE *)(a3 + 12) = sub_10020C80((int)&v4, 1, 0);
  sub_10020C60((int)&v4, 1);
  *(_BYTE *)(a3 + 13) = sub_10020C80((int)&v4, 1, 0);
  *(_BYTE *)(a3 + 14) = sub_10020C80((int)&v4, 5, 0);
  *(_BYTE *)(a3 + 15) = sub_10020C80((int)&v4, 4, 0);
  return sub_10020C00((int *)&v4, 1);
}

//----- (100062F0) --------------------------------------------------------
signed int __usercall sub_100062F0@<eax>(_BYTE *a1@<eax>, void *a2@<edx>, int a3@<ecx>, _BYTE *a4)
{
  signed int v4; // esi@2
  signed int result; // eax@4

  if ( *a1 )
  {
    v4 = (unsigned __int8)a3;
    *a1 = 0;
    if ( (signed int)(unsigned __int8)a3 > 0 )
      memset(a2, 32, (unsigned __int8)a3);
    result = v4;
  }
  else
  {
    a3 = (unsigned __int8)a3;
    switch ( (unsigned __int8)a3 )
    {
      case 0u:
      case 0x1Du:
        *(_BYTE *)a2 = 0;
        result = 0;
        *a4 = 1;
        break;
      case 0x1Cu:
        *a1 = 1;
        goto LABEL_8;
      case 0x1Bu:
      case 0x1Fu:
LABEL_8:
        result = 0;
        break;
      default:
        *(_BYTE *)a2 = byte_10086518[a3];
        result = 1;
        break;
    }
  }
  return result;
}

//----- (10006380) --------------------------------------------------------
unsigned int __cdecl sub_10006380(int a1, int a2, int a3, int a4, _WORD *a5)
{
  unsigned int v5; // esi@1
  int v6; // eax@4
  char v8; // [sp+12h] [bp-16h]@1
  char v9; // [sp+13h] [bp-15h]@1
  char v10; // [sp+14h] [bp-14h]@1

  sub_10020C40((int)&v10, a2, a1);
  v8 = 0;
  v9 = 0;
  v5 = 0;
  do
  {
    if ( (unsigned int)sub_10020C20((int)&v10) < 6 )
      break;
    if ( v5 >= a4 - 1 )
      break;
    v6 = sub_10020C80((int)&v10, 6, 0);
    v5 += sub_100062F0(&v9, (void *)(v5 + a3), v6, &v8);
  }
  while ( !v8 );
  *(_BYTE *)(v5 + a3) = 0;
  *a5 = sub_10020C00((int *)&v10, 1);
  return v5;
}

//----- (10006430) --------------------------------------------------------
int __cdecl sub_10006430(int a1, int a2, void *a3, int a4, int a5)
{
  int result; // eax@1
  unsigned int v6; // esi@2
  unsigned __int16 v7; // di@3
  int v8; // esi@3
  int v9; // [sp+6h] [bp-16h]@3
  char v10; // [sp+Ch] [bp-10h]@1
  char v11; // [sp+19h] [bp-3h]@1

  result = sub_10006230(a1, 8, (int)&v10);
  if ( v11 )
  {
    v6 = 0;
    do
    {
      result = sub_100061D0(a1 + v6 + 8, 424 - v6, (_WORD *)&v9 + 1, (_BYTE *)&v9 + 1);
      v7 = HIWORD(v9);
      v8 = result + v6;
      if ( HIWORD(v9) )
      {
        result = HIWORD(v9);
        if ( (unsigned int)HIWORD(v9) + v8 <= 0x1A8 && !BYTE1(v9) )
        {
          LOBYTE(v9) = 0;
          result = sub_10005FF0(a1 + v8 + 8, HIWORD(v9), a2, a3, a4, (int)&v9);
          if ( !(_BYTE)v9 )
          {
            if ( *(_BYTE *)a2 )
            {
              result = ((int (__cdecl *)(char *, int))a5)(&v10, a2);
              *(_BYTE *)a2 = 0;
            }
          }
        }
      }
      v6 = v7 + v8;
    }
    while ( v6 < 0x1A6 && v7 );
  }
  return result;
}

//----- (10006500) --------------------------------------------------------
int __cdecl sub_10006500(char a1, int a2)
{
  JUMPOUT(a1, 0, operator new);
  return -1 - a2;
}

//----- (10006520) --------------------------------------------------------
int __cdecl sub_10006520(int a1, char *a2)
{
  char v2; // cl@2
  int result; // eax@2

  if ( a1 >= 0 )
  {
    v2 = 0;
    result = a1;
  }
  else
  {
    v2 = 1;
    result = -1 - a1;
  }
  if ( a2 )
    *a2 = v2;
  return result;
}

//----- (10006540) --------------------------------------------------------
_DWORD *__cdecl sub_10006540(int a1, int a2, void *a3, int a4, void *a5)
{
  int v5; // esi@1
  _DWORD *result; // eax@1

  v5 = a2;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 8) = a4;
  *(_DWORD *)(a1 + 12) = a5;
  *(_DWORD *)(a1 + 16) = -1;
  memset(a3, 255, 12 * a2);
  result = memset(a5, 255, 36 * a4);
  if ( a2 )
  {
    result = a3;
    do
    {
      *result = 0x7FFFFFFF;
      result += 3;
      --v5;
    }
    while ( v5 );
  }
  return result;
}

//----- (100065C0) --------------------------------------------------------
char __usercall sub_100065C0@<al>(int a1@<edi>, int a2@<esi>, int a3)
{
  unsigned int v3; // eax@1
  int v4; // eax@2
  unsigned int v5; // edx@2

  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 < *(_DWORD *)(a2 + 8) )
  {
    do
    {
      v4 = *(_DWORD *)(a2 + 12) + 36 * v3;
      v5 = *(_DWORD *)(v4 + 32);
      *(_DWORD *)v4 = -1;
      *(_DWORD *)(v4 + 4) = -1;
      *(_DWORD *)(v4 + 8) = -1;
      *(_DWORD *)(v4 + 12) = -1;
      *(_DWORD *)(v4 + 16) = -1;
      *(_DWORD *)(v4 + 20) = -1;
      *(_DWORD *)(v4 + 24) = -1;
      *(_DWORD *)(v4 + 28) = -1;
      *(_DWORD *)(v4 + 32) = -1;
      v3 = v5;
    }
    while ( v5 < *(_DWORD *)(a2 + 8) );
  }
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 4) = -1;
  return 1;
}

//----- (10006610) --------------------------------------------------------
int __usercall sub_10006610@<eax>(int a1@<edx>, _BYTE *a2@<ecx>, int a3, int a4, _DWORD *a5, int a6)
{
  int result; // eax@1
  int v7; // esi@2
  signed __int16 v8; // dx@2
  char v9; // bl@2
  int i; // edi@2
  _BYTE *v11; // ecx@6
  _BYTE *v12; // ecx@9
  bool v13; // zf@9
  int v14; // [sp+10h] [bp-Ch]@1
  int v15; // [sp+14h] [bp-8h]@1
  signed int v16; // [sp+18h] [bp-4h]@1

  result = 0;
  v15 = 0;
  v14 = a1;
  v16 = 4;
  do
  {
    *(_DWORD *)(a4 + 4 * (*a5)++) = a6 + result;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    for ( i = 0; v7 < a3; ++v7 )
    {
      if ( *(_BYTE *)(v7 + v14) == v9 )
      {
        ++v8;
      }
      else
      {
        if ( v8 )
        {
          *a2 = v8;
          v11 = a2 + 1;
          *v11++ = HIBYTE(v8);
          *v11 = v9;
          a2 = v11 + 1;
          i += 3;
        }
        v9 = *(_BYTE *)(v7 + v14);
        v8 = 1;
      }
    }
    *a2 = v8;
    v12 = a2 + 1;
    *v12++ = HIBYTE(v8);
    *v12 = v9;
    a2 = v12 + 1;
    v13 = v16-- == 1;
    result = v15 + i + 3;
    v15 += i + 3;
    v14 += 4000;
  }
  while ( !v13 );
  return result;
}

//----- (100066D0) --------------------------------------------------------
int __usercall sub_100066D0@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  signed int v3; // ecx@2
  int v4; // ebx@4
  int v5; // edi@4
  int v6; // ebx@4
  int v7; // ecx@6
  unsigned int v8; // edx@8
  unsigned int v9; // ecx@9
  int v10; // eax@10
  int v12; // [sp+Ch] [bp-8h]@1
  int v13; // [sp+10h] [bp-4h]@1

  v13 = 0;
  v12 = 0;
  if ( a1 < 0 )
    v3 = -1 - a1;
  else
    v3 = a1;
  v4 = a1 < 0;
  LOBYTE(v4) = a1 >= 0;
  v5 = 2 * (a1 >= 0) - 1;
  v6 = v4 - 1;
  if ( v6 + v5 * (v3 / 450) < 1200 )
  {
    v7 = a1 < 0 ? -1 - a1 : a1;
    v8 = (signed int)(v7 + ((unsigned __int64)(-1851608123i64 * v7) >> 32)) >> 8;
    if ( (signed int)(v6 + v5 * (v8 + (v8 >> 31))) > -1200 )
    {
      v9 = 0;
      if ( *(_DWORD *)a2 )
      {
        v10 = *(_DWORD *)(a2 + 4);
        while ( *(_DWORD *)v10 != a1 )
        {
          if ( !v12 && *(_DWORD *)(v10 + 8) == -1 )
            v12 = v10;
          ++v9;
          v10 += 12;
          if ( v9 >= *(_DWORD *)a2 )
            goto LABEL_18;
        }
        v13 = *(_DWORD *)(a2 + 4) + 12 * v9;
      }
    }
  }
LABEL_18:
  if ( a3 )
    *a3 = v12;
  return v13;
}

//----- (100067B0) --------------------------------------------------------
signed int __usercall sub_100067B0@<eax>(unsigned int a1@<eax>, _BYTE *a2@<edi>)
{
  unsigned int v2; // esi@1
  signed int result; // eax@1
  unsigned int v4; // edx@1
  _BYTE *v5; // ecx@2
  int v6; // ecx@6
  signed int v7; // eax@6

  v2 = a1;
  result = -1;
  v4 = 0;
  if ( v2 )
  {
    v5 = a2;
    while ( *v5 != -1 )
    {
      ++v4;
      v5 += 36;
      if ( v4 >= v2 )
        return result;
    }
    v6 = (int)&a2[36 * v4];
    v7 = 4;
    do
    {
      *(_BYTE *)v6 = 0;
      *(_BYTE *)(v6 + 1) = 0;
      v6 += 2;
      --v7;
    }
    while ( v7 );
    *(_DWORD *)&a2[36 * v4 + 32] = -1;
    result = v4;
  }
  return result;
}

//----- (10006800) --------------------------------------------------------
unsigned int __usercall sub_10006800@<eax>(int a1@<eax>, int a2@<ecx>, int a3, int a4, _DWORD *a5)
{
  int v5; // esi@1
  unsigned int result; // eax@1
  unsigned int v7; // edi@1
  int v8; // eax@3
  int v9; // eax@3
  unsigned __int8 v10; // dl@3
  int v11; // esi@7
  int v12; // ecx@8
  signed int v13; // ebp@8
  int v14; // edi@8
  char *v15; // ebx@9
  int v16; // ecx@14
  size_t v17; // esi@14
  bool v18; // sf@16
  unsigned __int8 v19; // of@16
  unsigned __int8 v20; // [sp+Bh] [bp-21h]@3
  int v21; // [sp+Ch] [bp-20h]@7
  int v22; // [sp+10h] [bp-1Ch]@7
  unsigned int v23; // [sp+14h] [bp-18h]@1
  int v24; // [sp+18h] [bp-14h]@2
  int v25; // [sp+1Ch] [bp-10h]@7
  int v26; // [sp+20h] [bp-Ch]@2
  int v27; // [sp+24h] [bp-8h]@1
  int v28; // [sp+28h] [bp-4h]@3

  v5 = a1;
  result = sub_10006520(a2, (char *)&v27);
  v7 = result;
  v23 = result;
  if ( v5 > 0 )
  {
    v24 = a4;
    v26 = v5;
    do
    {
      v8 = sub_10006500(v27, v7);
      v9 = sub_100066D0(v8, a3, 0);
      v28 = v9;
      v10 = 2 - (v7 < 0x62E08);
      v20 = 2 - (v7 < 0x62E08);
      if ( v9 )
      {
        if ( *a5 == -1 || *a5 > *(_DWORD *)(v9 + 8) )
          *a5 = *(_DWORD *)(v9 + 8);
        v11 = 32 * v10;
        v25 = 32 * v10;
        v21 = 0;
        v22 = v24;
        do
        {
          v12 = *(_DWORD *)(v9 + 4);
          v13 = -1;
          v14 = 0;
          if ( v12 == -1 )
            v15 = " ";
          else
            v15 = (char *)(*(_DWORD *)(a3 + 12) + 36 * v12);
          if ( v11 > 0 )
          {
            do
            {
              if ( ++v13 >= 4 )
              {
                v15 = (char *)(*(_DWORD *)(a3 + 12) + 36 * *((_DWORD *)v15 + 8));
                v13 = 0;
              }
              v16 = (int)&v15[2 * (v13 + v21)];
              v17 = (unsigned __int8)(v10 * *(_BYTE *)v16);
              memset((void *)(v14 + v22), *(_BYTE *)(v16 + 1), v17);
              v10 = v20;
              v14 += v17;
            }
            while ( v14 < v25 );
            v11 = v25;
            v9 = v28;
          }
          v22 += 4000;
          v19 = __OFSUB__(v21 + 4, 16);
          v18 = v21 - 12 < 0;
          v21 += 4;
        }
        while ( v18 ^ v19 );
        v7 = v23;
      }
      result = ++v7 % 0x1C2;
      v23 = v7;
      if ( !(v7 % 0x1C2) )
      {
        v7 -= 450;
        v23 = v7;
      }
      v24 += 32;
      --v26;
    }
    while ( v26 );
  }
  return result;
}

//----- (10006980) --------------------------------------------------------
char __usercall sub_10006980@<al>(int a1@<eax>, int a2@<esi>)
{
  _DWORD *v2; // edi@1
  char result; // al@1

  v2 = (_DWORD *)a1;
  result = sub_100065C0(a1, a2, -1);
  *v2 = 0x7FFFFFFF;
  return result;
}

//----- (100069A0) --------------------------------------------------------
char __cdecl sub_100069A0(int a1)
{
  int v1; // ecx@1
  char result; // al@1
  unsigned int v3; // edi@2
  unsigned int v4; // ebp@2
  int v5; // ebx@3

  v1 = *(_DWORD *)(a1 + 16);
  result = 0;
  if ( v1 != -1 )
  {
    v3 = 0;
    v4 = v1 - 600;
    if ( *(_DWORD *)a1 )
    {
      v5 = 0;
      do
      {
        if ( *(_DWORD *)(v5 + *(_DWORD *)(a1 + 4) + 8) < v4 )
        {
          sub_10006980(v5 + *(_DWORD *)(a1 + 4), a1);
          result = 1;
        }
        ++v3;
        v5 += 12;
      }
      while ( v3 < *(_DWORD *)a1 );
    }
  }
  return result;
}

//----- (100069F0) --------------------------------------------------------
char __cdecl sub_100069F0(int a1, int a2, int a3, int a4, int a5, void *a6, int a7, int a8, int a9, int a10, int a11)
{
  int v11; // eax@1
  char v12; // bl@1
  bool v13; // zf@1
  signed int v14; // ecx@1
  signed int v15; // ebp@1
  int v16; // edx@2
  signed int v17; // esi@4
  signed int v18; // edi@5
  int v19; // edi@7
  signed int v20; // ecx@8
  int v21; // ecx@10
  int v22; // edx@25
  int v23; // eax@37
  signed int v24; // esi@37
  int v25; // ebp@38
  signed int v26; // eax@40
  int v27; // edx@44
  _BYTE *v28; // edi@46
  __int16 v29; // dx@46
  bool v30; // sf@46
  int v31; // esi@46
  int v32; // ebx@47
  int v33; // eax@47
  int v34; // esi@53
  int v35; // edx@53
  int v36; // esi@54
  double v37; // st6@54
  signed int v38; // eax@54
  signed int v39; // ebx@54
  int v40; // eax@54
  int v41; // esi@54
  signed int v42; // eax@56
  int v43; // esi@56
  int v44; // ebp@56
  int v45; // esi@56
  signed int v46; // eax@59
  char v47; // ch@59
  int v48; // eax@59
  int v49; // esi@59
  double v50; // st6@59
  signed int v51; // eax@59
  signed int v52; // ebx@59
  int v53; // esi@59
  signed int v54; // eax@61
  int v55; // esi@61
  int v56; // eax@61
  int v57; // esi@61
  signed int v58; // eax@63
  char result; // al@63
  char v60; // [sp+Bh] [bp-21h]@1
  signed int v61; // [sp+Ch] [bp-20h]@1
  int v62; // [sp+10h] [bp-1Ch]@1
  signed int v63; // [sp+10h] [bp-1Ch]@40
  int v64; // [sp+14h] [bp-18h]@1
  int v65; // [sp+18h] [bp-14h]@1
  int v66; // [sp+1Ch] [bp-10h]@1
  int v67; // [sp+20h] [bp-Ch]@2
  int v68; // [sp+24h] [bp-8h]@2
  int v69; // [sp+28h] [bp-4h]@46
  int v70; // [sp+30h] [bp+4h]@57

  v65 = 450;
  v66 = 450;
  v11 = *(_DWORD *)a1;
  v12 = 0;
  v13 = *(_DWORD *)a1 == 0;
  v14 = -450;
  v60 = 0;
  v15 = -1350;
  v61 = 1350;
  v64 = -450;
  v62 = -450;
  if ( v13 )
  {
    result = 0;
  }
  else
  {
    v16 = *(_DWORD *)(a1 + 4);
    v67 = *(_DWORD *)(a1 + 4);
    v68 = v11;
    do
    {
      if ( *(_DWORD *)(v16 + 8) != -1 )
      {
        v17 = *(_DWORD *)v16;
        if ( *(_DWORD *)v16 < 0 )
          v18 = -1 - v17;
        else
          v18 = *(_DWORD *)v16;
        v19 = (v17 >= 0) - 1 + v18 / 450 * (2 * (v17 >= 0) - 1);
        if ( v17 < 0 )
          v20 = -1 - v17;
        else
          v20 = *(_DWORD *)v16;
        v21 = v20 % 450;
        if ( v19 > v15 )
          v15 = v19;
        if ( v19 < v61 )
          v61 = v19;
        if ( v21 > v64 )
          v64 = v21;
        if ( v21 < v65 )
          v65 = v21;
        if ( v21 < 225 )
        {
          if ( v21 > v62 )
            v62 = v21;
        }
        else if ( v21 < v66 )
        {
          v66 = v21;
        }
        if ( v19 >= 900 || v19 <= -900 )
        {
          v22 = (v21 + 1) % 450;
          if ( v22 > v64 )
            v64 = (v21 + 1) % 450;
          if ( v22 < v65 )
            v65 = (v21 + 1) % 450;
          if ( v22 < 225 )
          {
            if ( v22 > v62 )
              v62 = (v21 + 1) % 450;
          }
          else if ( v22 < v66 )
          {
            v66 = (v21 + 1) % 450;
          }
        }
        v14 = v62;
        v16 = v67;
        v60 = 1;
        v12 = 1;
      }
      v16 += 12;
      v13 = v68-- == 1;
      v67 = v16;
    }
    while ( !v13 );
    if ( !v12 )
      goto LABEL_68;
    v23 = v65;
    v24 = v15 - v61 + 1;
    v67 = v15 - v61 + 1;
    if ( v64 - v65 <= 225 )
    {
      v25 = v64 - v65 + 1;
    }
    else
    {
      v23 = v66;
      v25 = v14 - v66 + 451;
    }
    v63 = v23;
    v26 = *(_DWORD *)(a1 + 8);
    if ( v24 >= v26 )
    {
      v67 = *(_DWORD *)(a1 + 8);
      v24 = v26;
    }
    if ( v25 >= 125 )
      v25 = 125;
    *(_DWORD *)a2 = 795364 * (v24 % 2) / 2 - (signed int)((double)(v61 + v24 / 2) * -795364.3140740742);
    v27 = (v63 + v25 / 2) % 450;
    if ( v27 >= 225 )
      v27 -= 450;
    v68 = v27;
    v28 = a6;
    *(_DWORD *)a3 = 9544371 * (v25 % 2) / 2 - (signed int)((double)v27 * -9544371.768888889);
    *(_WORD *)a4 = 32 * v25;
    v29 = 4 * v24;
    v30 = v24 - 1 < 0;
    v31 = v24 - 1;
    *(_WORD *)a5 = v29;
    v64 = 0;
    v69 = -1;
    if ( !v30 )
    {
      v32 = v31 + v61;
      v33 = 450 * (v31 + v61);
      v66 = v33 + v63;
      v65 = v33 - v63 + 449;
      do
      {
        if ( v32 < 0 )
          v68 = v65;
        else
          v68 = v66;
        memset(&unk_1014E4C0, 24, 0x3E80u);
        sub_10006800(v25, v68, a1, (int)&unk_1014E4C0, &v69);
        v28 += sub_10006610((int)&unk_1014E4C0, v28, *(_WORD *)a4, (int)&unk_1014A640, &v64, v28 - (_BYTE *)a6);
        v66 -= 450;
        v65 -= 450;
        --v31;
        --v32;
      }
      while ( v31 >= 0 );
      v12 = v60;
    }
    v34 = 4 * v64;
    memcpy(v28, &unk_1014A640, 4 * v64);
    *(_DWORD *)a8 = v28 - (_BYTE *)a6;
    v35 = v69;
    *(_DWORD *)a9 = v34;
    *(_DWORD *)a11 = v35;
    if ( a10 )
    {
      v36 = (int)&v28[*(_DWORD *)a9];
      *(_BYTE *)v36 = 1;
      *(_BYTE *)(v36 + 1) = 0;
      *(_BYTE *)(v36 + 2) = 0;
      v37 = (double)v61 * 795364.3140740742;
      *(_BYTE *)(v36 + 3) = 0;
      v36 += 4;
      *(_BYTE *)v36 = 4;
      *(_BYTE *)(v36 + 1) = 0;
      *(_BYTE *)(v36 + 2) = 0;
      *(_BYTE *)(v36 + 3) = 0;
      v36 += 4;
      v38 = (signed int)v37;
      v39 = (signed int)v37;
      *(_BYTE *)(v36 + 1) = BYTE1(v38);
      v40 = v63;
      *(_BYTE *)v36 = (signed int)v37;
      *(_BYTE *)(v36 + 2) = (signed int)v37 >> 16;
      *(_BYTE *)(v36 + 3) = (unsigned int)(signed int)v37 >> 24;
      v41 = v36 + 4;
      if ( v63 >= 225 )
        v40 = v63 - 450;
      v42 = (signed int)((double)v40 * 9544371.768888889);
      *(_BYTE *)v41 = v42;
      *(_BYTE *)(v41 + 1) = BYTE1(v42);
      *(_BYTE *)(v41 + 3) = BYTE3(v42);
      *(_BYTE *)(v41 + 2) = v42 >> 16;
      v43 = v41 + 4;
      *(_BYTE *)v43 = v39;
      *(_BYTE *)(v43 + 1) = BYTE1(v39);
      *(_BYTE *)(v43 + 2) = v39 >> 16;
      *(_BYTE *)(v43 + 3) = BYTE3(v39);
      v44 = v63 + v25;
      v45 = v43 + 4;
      if ( v44 < 225 )
        v70 = v44;
      else
        v70 = v44 - 450;
      v46 = (signed int)((double)v70 * 9544371.768888889);
      v47 = BYTE1(v46);
      *(_BYTE *)v45 = v46;
      *(_BYTE *)(v45 + 3) = BYTE3(v46);
      v48 = v67;
      *(_BYTE *)(v45 + 1) = v47;
      *(_BYTE *)(v45 + 2) = (signed int)((double)v70 * 9544371.768888889) >> 16;
      v49 = v45 + 4;
      v50 = 795364.3140740742 * (double)(v61 + v48);
      v51 = (signed int)v50;
      v52 = (signed int)v50;
      *(_BYTE *)v49 = (signed int)v50;
      *(_BYTE *)(v49 + 1) = BYTE1(v51);
      *(_BYTE *)(v49 + 2) = (signed int)v50 >> 16;
      *(_BYTE *)(v49 + 3) = (unsigned int)(signed int)v50 >> 24;
      v53 = v49 + 4;
      if ( v44 >= 225 )
        v44 -= 450;
      v54 = (signed int)((double)v44 * 9544371.768888889);
      *(_BYTE *)v53 = v54;
      *(_BYTE *)(v53 + 3) = BYTE3(v54);
      *(_BYTE *)(v53 + 1) = BYTE1(v54);
      v55 = v53 + 4;
      *(_BYTE *)(v55 - 2) = v54 >> 16;
      *(_BYTE *)v55 = v52;
      *(_BYTE *)(v55 + 2) = v52 >> 16;
      v56 = v63;
      *(_BYTE *)(v55 + 1) = BYTE1(v52);
      *(_BYTE *)(v55 + 3) = BYTE3(v52);
      v57 = v55 + 4;
      if ( v63 >= 225 )
        v56 = v63 - 450;
      v58 = (signed int)(9544371.768888889 * (double)v56);
      *(_BYTE *)v57 = v58;
      *(_BYTE *)(v57 + 3) = BYTE3(v58);
      *(_BYTE *)(v57 + 1) = BYTE1(v58);
      *(_BYTE *)(v57 + 2) = v58 >> 16;
      result = v60;
      *(_DWORD *)a10 = v57 - *(_DWORD *)a9 - (_DWORD)v28 + 4;
    }
    else
    {
LABEL_68:
      result = v12;
    }
  }
  return result;
}

//----- (10006F60) --------------------------------------------------------
BOOL __cdecl sub_10006F60(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // ebp@1
  int v5; // esi@1
  int v6; // ebx@1
  int v7; // eax@4
  unsigned int v8; // eax@4
  unsigned __int8 v9; // bl@5
  unsigned int v10; // edi@6
  int v11; // esi@6
  unsigned int v12; // eax@10
  int v13; // esi@10
  _BYTE *v14; // edi@10
  int v15; // esi@10
  unsigned int v16; // esi@12
  unsigned __int8 v17; // cl@15
  int v18; // eax@17
  bool v19; // cf@17
  signed int v20; // eax@18
  unsigned int v21; // eax@23
  char v23; // [sp+Fh] [bp-15h]@5
  int v24; // [sp+10h] [bp-14h]@1
  int v25; // [sp+14h] [bp-10h]@6
  int v26; // [sp+18h] [bp-Ch]@5
  int v27; // [sp+1Ch] [bp-8h]@5

  v4 = a1;
  v5 = a2;
  v6 = sub_100066D0(a2, a1, &a1);
  v24 = v6;
  if ( v6 )
    goto LABEL_4;
  if ( a1 )
  {
    v24 = a1;
    v6 = a1;
LABEL_4:
    v7 = a3;
    *(_DWORD *)v6 = v5;
    *(_DWORD *)(v6 + 8) = v7;
    sub_100065C0(v6, v4, v7);
    v8 = sub_100067B0(*(_DWORD *)(v4 + 8), *(_BYTE **)(v4 + 12));
    *(_DWORD *)(v6 + 4) = v8;
    if ( v8 >= *(_DWORD *)(v4 + 8) )
    {
      sub_10006980(v6, v4);
      goto LABEL_23;
    }
    v9 = 0;
    v23 = 0;
    v27 = 0;
    v26 = 0;
    while ( 1 )
    {
      v10 = *(_DWORD *)(v24 + 4);
      v11 = 0;
      LOBYTE(a1) = 0;
      v25 = 0;
      while ( 1 )
      {
        if ( !v9 )
        {
          v9 = (*(_BYTE *)((unsigned __int16)v27 + a4) >> 3) + 1;
          v23 = *(_BYTE *)((unsigned __int16)v27++ + a4) & 7;
        }
        if ( v11 < 4 )
          goto LABEL_14;
        v12 = *(_DWORD *)(v4 + 8);
        v13 = 9 * v10;
        v14 = *(_BYTE **)(v4 + 12);
        v15 = 4 * v13;
        if ( *(_DWORD *)&v14[v15 + 32] >= v12 )
          *(_DWORD *)(v15 + *(_DWORD *)(v4 + 12) + 32) = sub_100067B0(v12, v14);
        v16 = *(_DWORD *)(v15 + *(_DWORD *)(v4 + 12) + 32);
        if ( v16 >= *(_DWORD *)(v4 + 8) )
          break;
        v10 = v16;
        v11 = 0;
        v25 = 0;
LABEL_14:
        if ( v9 + (unsigned __int8)a1 <= 32 )
          v17 = v9;
        else
          v17 = 32 - a1;
        v18 = 2 * (v11 + 4 * v26 + 18 * v10);
        *(_BYTE *)(v18 + *(_DWORD *)(v4 + 12)) = v17;
        *(_BYTE *)(v18 + *(_DWORD *)(v4 + 12) + 1) = v23;
        v11 = v25 + 1;
        v9 -= v17;
        v19 = (unsigned __int8)(v17 + a1) < 0x20u;
        LOBYTE(a1) = v17 + a1;
        ++v25;
        if ( !v19 )
        {
          v20 = v26;
          goto LABEL_19;
        }
      }
      sub_10006980(v24, v4);
      v24 = 0;
      v20 = 4;
LABEL_19:
      v26 = v20 + 1;
      if ( (unsigned int)(v20 + 1) >= 4 )
      {
        v6 = v24;
        break;
      }
    }
  }
LABEL_23:
  v21 = *(_DWORD *)(v4 + 16);
  if ( v21 == -1 || a3 > v21 )
    *(_DWORD *)(v4 + 16) = a3;
  return v6 != 0;
}

//----- (10007110) --------------------------------------------------------
unsigned int __cdecl sub_10007110(int a1, int a2, int a3, unsigned int a4)
{
  char v4; // bl@1
  unsigned int v5; // esi@1
  int v6; // ST34_4@2
  int v7; // ST30_4@2
  int v8; // eax@2
  unsigned int result; // eax@2
  unsigned __int8 v10; // bl@3
  unsigned int v11; // edi@3
  int v12; // ebp@3
  char v13; // al@6
  int v14; // eax@7
  int v15; // esi@7
  int v16; // eax@7
  int *v17; // eax@8
  int v18; // ecx@11
  unsigned int v19; // edx@11
  char v20; // [sp+13h] [bp-25h]@3
  char v21; // [sp+14h] [bp-24h]@1
  int v22; // [sp+18h] [bp-20h]@3
  int *v23; // [sp+1Ch] [bp-1Ch]@7
  unsigned int v24; // [sp+20h] [bp-18h]@3
  char v25; // [sp+24h] [bp-14h]@1

  sub_10020C40((int)&v25, a2, a1);
  v4 = sub_10020C80((int)&v25, 1, 0);
  v21 = sub_10020C80((int)&v25, 1, 0);
  sub_10020C60((int)&v25, 2);
  v5 = sub_10020C80((int)&v25, 20, 0);
  if ( v4 )
  {
    v6 = a2 - sub_10020C00((int *)&v25, 1);
    v7 = a1 + sub_10020C00((int *)&v25, 1);
    v8 = sub_10006500(v21, v5);
    result = sub_10006F60(a3, v8, a4, v7);
  }
  else
  {
    v10 = 2 * sub_10020C80((int)&v25, 4, 0) + 1;
    v20 = 5;
    v11 = 2 - (v5 < 0x62E08);
    v22 = 8 * (unsigned __int8)sub_10020C80((int)&v25, 4, 0) + 5;
    v24 = 2 - (v5 < 0x62E08);
    v12 = v5;
    do
    {
      if ( !v20 )
      {
        v10 = sub_10020C80((int)&v25, 8, 0);
        v20 = 8;
      }
      --v20;
      v13 = v10 & 1;
      v10 >>= 1;
      if ( v13 )
      {
        v14 = sub_10006500(v21, v12);
        v15 = v14;
        v16 = sub_100066D0(v14, a3, &v23);
        if ( v16 )
        {
          sub_100065C0(v16, a3, a4);
          v11 = v24;
        }
        else
        {
          v17 = v23;
          if ( v23 )
          {
            *v23 = v15;
            v17[2] = a4;
          }
        }
      }
      v18 = v11 + v12;
      result = (v11 + v12) / 0x1C2;
      v19 = (v11 + v12) % 0x1C2;
      v12 = v11 + v12 - 450;
      if ( v19 >= v11 )
        v12 = v18;
      --v22;
    }
    while ( v22 );
  }
  return result;
}

//----- (100072B0) --------------------------------------------------------
char __cdecl sub_100072B0(__int16 a1, int a2)
{
  unsigned int v2; // eax@2

  if ( a1 == 483 )
  {
    byte_1015534B = 1;
    dword_10428ADC = sub_10060900() + 900000;
    LOBYTE(v2) = sub_100128D0(483, a2, (char *)&unk_10428AE8 + 432 * dword_10152344, 0x1B0u);
    if ( (_BYTE)v2 )
    {
      v2 = (dword_10152344 + 1) / 0x28u;
      dword_10152344 = (dword_10152344 + 1) % 0x28u;
    }
  }
  else
  {
    LOBYTE(v2) = a1 + 18;
    if ( a1 == 494 )
    {
      if ( sub_100144B0(494, a2, &a1) && (_BYTE)a1 == 2 )
      {
        if ( dword_10428ADC < (unsigned int)sub_10060900() )
          LOBYTE(a1) = 0;
      }
      else
      {
        LOBYTE(a1) = 1;
      }
      LOBYTE(v2) = sub_10060ED0(9221, (int)&a1, 1);
    }
  }
  return v2;
}
// 10152344: using guessed type int dword_10152344;
// 1015534B: using guessed type char byte_1015534B;
// 10428ADC: using guessed type int dword_10428ADC;

//----- (10007370) --------------------------------------------------------
int __cdecl sub_10007370(__int16 a1)
{
  int result; // eax@2

  if ( a1 == 494 )
  {
    LOBYTE(a1) = 1;
    result = sub_10060ED0(9221, (int)&a1, 1);
  }
  return result;
}

//----- (100073A0) --------------------------------------------------------
int sub_100073A0()
{
  unsigned int v0; // eax@1
  char v2; // [sp+Fh] [bp-1h]@3

  dword_10152340 = 2;
  dword_10428AE0 = sub_10060900() + 10000;
  dword_103E0644 = 0;
  dword_10152344 = 0;
  byte_1015534A = 0;
  memset(&unk_103E2E48, 0, 0x45C94u);
  dword_10427F14 = -1;
  memset(dword_10427F20, 0xFFu, 0xBB8u);
  memset(&unk_101864C0, 0, 0x25A184u);
  sub_10006540((int)&unk_101F3C48, 37366, &unk_101864C0, 56049, &unk_101F3C5C);
  memset(&unk_10155378, 0, 0x31144u);
  dword_10185B4C = -1;
  v0 = 0;
  do
  {
    dword_10185B58[v0] = -1;
    dword_10186008[v0] = -1;
    ++v0;
  }
  while ( v0 < 300 );
  dword_101864BC = sub_10060900() + 30000;
  byte_1015534B = 0;
  dword_10428ADC = sub_10060900() + 900000;
  byte_10155349 = -1;
  byte_10155348 = 1;
  byte_1015534C = 0;
  v2 = 2;
  return sub_10060ED0(9221, (int)&v2, 1);
}
// 10152340: using guessed type int dword_10152340;
// 10152344: using guessed type int dword_10152344;
// 10155348: using guessed type char byte_10155348;
// 10155349: using guessed type char byte_10155349;
// 1015534A: using guessed type char byte_1015534A;
// 1015534B: using guessed type char byte_1015534B;
// 1015534C: using guessed type char byte_1015534C;
// 10185B4C: using guessed type int dword_10185B4C;
// 10185B58: using guessed type int dword_10185B58[];
// 10186008: using guessed type int dword_10186008[];
// 101864BC: using guessed type int dword_101864BC;
// 103E0644: using guessed type int dword_103E0644;
// 10427F14: using guessed type int dword_10427F14;
// 10427F20: using guessed type int dword_10427F20[];
// 10428ADC: using guessed type int dword_10428ADC;
// 10428AE0: using guessed type int dword_10428AE0;

//----- (100074B0) --------------------------------------------------------
int __cdecl sub_100074B0(_DWORD *a1)
{
  int result; // eax@1
  unsigned __int16 v2; // bx@1
  _DWORD *v3; // esi@2
  unsigned int v4; // edx@2
  char *v5; // ecx@2
  int v6; // edi@6
  int v7; // edx@7
  _BYTE *v8; // esi@7
  _BYTE *v9; // ecx@7
  int v10; // edx@9
  _BYTE *v11; // esi@9
  _BYTE *v12; // ecx@9
  _BYTE *v13; // esi@11
  _BYTE *v14; // ecx@11
  int v15; // edx@12
  signed int v16; // ecx@13
  unsigned int v17; // [sp+4h] [bp-Ch]@1
  unsigned __int16 v18; // [sp+8h] [bp-8h]@1

  result = (unsigned __int16)word_10427F18;
  v2 = 0;
  v18 = 0;
  v17 = dword_10427F20[0];
  if ( word_10427F18 )
  {
    while ( 1 )
    {
      v3 = a1;
      v4 = 4;
      v5 = (char *)&unk_10419D30 + 77 * v2;
      do
      {
        if ( *(_DWORD *)v5 != *v3 )
          goto LABEL_6;
        v4 -= 4;
        ++v3;
        v5 += 4;
      }
      while ( v4 >= 4 );
      if ( !v4 )
      {
LABEL_15:
        v16 = 0;
        goto LABEL_16;
      }
LABEL_6:
      v6 = (unsigned __int8)*v5 - *(_BYTE *)v3;
      if ( (unsigned __int8)*v5 == *(_BYTE *)v3 )
      {
        v7 = v4 - 1;
        v8 = (char *)v3 + 1;
        v9 = v5 + 1;
        if ( !v7 )
          goto LABEL_15;
        v6 = *v9 - *v8;
        if ( *v9 == *v8 )
        {
          v10 = v7 - 1;
          v11 = v8 + 1;
          v12 = v9 + 1;
          if ( !v10 )
            goto LABEL_15;
          v6 = *v12 - *v11;
          if ( *v12 == *v11 )
          {
            v13 = v11 + 1;
            v14 = v12 + 1;
            if ( v10 == 1 )
              goto LABEL_15;
            v15 = *v13;
            v6 = *v14 - v15;
            if ( *v14 == v15 )
              goto LABEL_15;
          }
        }
      }
      v16 = 1;
      if ( v6 <= 0 )
        v16 = -1;
LABEL_16:
      if ( !v16 )
        break;
      if ( dword_10427F20[v2] < v17 )
      {
        v18 = v2;
        v17 = dword_10427F20[v2];
      }
      if ( ++v2 >= (unsigned __int16)word_10427F18 )
      {
        result = (unsigned __int16)word_10427F18;
        goto LABEL_22;
      }
    }
    result = v2;
  }
LABEL_22:
  if ( (unsigned __int16)result >= 0x2EFu )
    result = v18;
  return result;
}
// 10427F18: using guessed type __int16 word_10427F18;
// 10427F20: using guessed type int dword_10427F20[];

//----- (100075C0) --------------------------------------------------------
int __cdecl sub_100075C0(_DWORD *a1)
{
  int result; // eax@1
  unsigned __int16 v2; // bp@1
  _DWORD *v3; // edx@2
  unsigned int v4; // ecx@2
  int *v5; // esi@2
  int v6; // edi@6
  int v7; // ecx@7
  _BYTE *v8; // edx@7
  _BYTE *v9; // esi@7
  int v10; // ecx@9
  _BYTE *v11; // edx@9
  _BYTE *v12; // esi@9
  _BYTE *v13; // edx@11
  _BYTE *v14; // esi@11
  signed int v15; // ecx@13
  unsigned int v16; // [sp+4h] [bp-Ch]@1
  unsigned __int16 v17; // [sp+8h] [bp-8h]@1

  result = (unsigned __int16)word_10185B50;
  v2 = 0;
  v17 = 0;
  v16 = dword_10185B58[0];
  if ( word_10185B50 )
  {
    while ( 1 )
    {
      v3 = a1;
      v4 = 4;
      v5 = &dword_10184D30[3 * v2];
      do
      {
        if ( *v5 != *v3 )
          goto LABEL_6;
        v4 -= 4;
        ++v3;
        ++v5;
      }
      while ( v4 >= 4 );
      if ( !v4 )
      {
LABEL_15:
        v15 = 0;
        goto LABEL_16;
      }
LABEL_6:
      v6 = *(_BYTE *)v5 - *(_BYTE *)v3;
      if ( *(_BYTE *)v5 == *(_BYTE *)v3 )
      {
        v7 = v4 - 1;
        v8 = (char *)v3 + 1;
        v9 = (char *)v5 + 1;
        if ( !v7 )
          goto LABEL_15;
        v6 = *v9 - *v8;
        if ( *v9 == *v8 )
        {
          v10 = v7 - 1;
          v11 = v8 + 1;
          v12 = v9 + 1;
          if ( !v10 )
            goto LABEL_15;
          v6 = *v12 - *v11;
          if ( *v12 == *v11 )
          {
            v13 = v11 + 1;
            v14 = v12 + 1;
            if ( v10 == 1 )
              goto LABEL_15;
            v6 = *v14 - *v13;
            if ( *v14 == *v13 )
              goto LABEL_15;
          }
        }
      }
      v15 = 1;
      if ( v6 <= 0 )
        v15 = -1;
LABEL_16:
      if ( !v15 )
        break;
      if ( dword_10185B58[v2] < v16 )
      {
        v17 = v2;
        v16 = dword_10185B58[v2];
      }
      if ( ++v2 >= (unsigned __int16)word_10185B50 )
      {
        result = (unsigned __int16)word_10185B50;
        goto LABEL_22;
      }
    }
    result = v2;
  }
LABEL_22:
  if ( (unsigned __int16)result >= 0x12Du )
    result = v17;
  return result;
}
// 10184D30: using guessed type int dword_10184D30[];
// 10185B50: using guessed type __int16 word_10185B50;
// 10185B58: using guessed type int dword_10185B58[];

//----- (100076D0) --------------------------------------------------------
char sub_100076D0()
{
  char v0; // bl@1
  char result; // al@5
  unsigned int v2; // edx@6
  unsigned __int16 v3; // cx@8
  int v4; // eax@8
  __int16 v5; // bx@8
  int v6; // edi@9
  int *v7; // ebp@9
  int v8; // eax@11
  int *v9; // ecx@11
  int v10; // ecx@11
  __int16 v11; // ax@17
  int v12; // ebp@17
  int v13; // edi@17
  int v14; // ebx@18
  int v15; // esi@18
  int v16; // eax@22
  char v17; // [sp+7h] [bp-1Dh]@1
  unsigned __int16 v18; // [sp+8h] [bp-1Ch]@6
  char v19[4]; // [sp+Ch] [bp-18h]@1
  int v20; // [sp+10h] [bp-14h]@8
  int v21; // [sp+14h] [bp-10h]@17
  unsigned int v22; // [sp+18h] [bp-Ch]@17
  unsigned int v23; // [sp+1Ch] [bp-8h]@18
  int v24; // [sp+20h] [bp-4h]@17

  sub_10032600(v19);
  v0 = *(_DWORD *)v19 % 0x1Cu;
  v17 = *(_DWORD *)v19 % 0x1Cu;
  if ( byte_10155349 == v0 )
    return 0;
  if ( !v0 )
  {
    if ( !sub_100069A0((int)&unk_101F3C48) )
    {
LABEL_31:
      byte_10155349 = v0;
      return 1;
    }
    byte_103E0640 = 1;
LABEL_30:
    byte_10155348 = 15;
    goto LABEL_31;
  }
  if ( v0 == 8 )
  {
    sub_1000CA60(8u, &v18);
    v22 = *(_DWORD *)v19 - v18;
    v11 = word_10427F18;
    v12 = 0;
    v13 = 0;
    v24 = dword_10427F14 - 4500;
    v21 = 0;
    v20 = 0;
    if ( word_10427F18 )
    {
      do
      {
        v14 = (unsigned __int16)v13;
        v15 = 77 * (unsigned __int16)v13;
        if ( sub_1001FDD0(*(unsigned int *)v19, byte_10419D35[v15], byte_10419D36[v15], byte_10419D37[v15], 0, &v23)
          && v23 > v22
          && dword_10427F20[(unsigned __int16)v13] > (unsigned int)v24 )
        {
          if ( (_WORD)v12 != (_WORD)v13 )
          {
            v12 = (unsigned __int16)v12;
            v16 = 77 * (unsigned __int16)v12;
            qmemcpy((char *)&unk_10419D30 + v16, (char *)&unk_10419D30 + v15, 0x4Du);
            *(int *)((char *)&dword_10419D44 + v16) += 300 * ((unsigned __int16)v12 - (unsigned __int16)v13);
            *(int *)((char *)&dword_10419D79 + v16) = 300 * (unsigned __int16)v12;
            sub_1002C120(
              (int)&unk_103E2E48 + 300 * (unsigned __int16)v12,
              (_BYTE *)&unk_103E2E48 + 300 * (unsigned __int16)v13,
              300);
            v13 = v20;
            dword_10427F20[v12] = dword_10427F20[v14];
            v12 = v21;
          }
          v21 = ++v12;
        }
        v11 = word_10427F18;
        v20 = ++v13;
      }
      while ( (unsigned __int16)v13 < (unsigned __int16)word_10427F18 );
      v0 = v17;
    }
    if ( v11 == (_WORD)v12 )
      goto LABEL_31;
    byte_10428AD8 = 1;
    word_10427F18 = v12;
    goto LABEL_30;
  }
  if ( v0 == 10 )
  {
    sub_1000CA60(0xAu, &v18);
    v2 = *(_DWORD *)v19;
    if ( dword_10185B4C < *(_DWORD *)v19 - ((unsigned int)v18 >> 1) )
    {
      dword_10185B4C = *(_DWORD *)v19;
      byte_101864B8 = 1;
    }
    v3 = word_10185B50;
    v4 = 0;
    v5 = 0;
    v20 = 0;
    if ( word_10185B50 )
    {
      do
      {
        v6 = (unsigned __int16)v4;
        v7 = &dword_10186008[(unsigned __int16)v4];
        if ( dword_10186008[(unsigned __int16)v4] > v2 )
        {
          if ( v5 != (_WORD)v4 )
          {
            v8 = 3 * (unsigned __int16)v5;
            v9 = &dword_10184D30[3 * v6];
            dword_10184D30[v8] = dword_10184D30[3 * v6];
            dword_10184D34[v8] = v9[1];
            dword_10184D38[v8] = v9[2];
            v10 = 650 * (unsigned __int16)v5;
            dword_10184D38[v8] = v10;
            sub_1002C120((int)&unk_10155378 + v10, (_BYTE *)&unk_10155378 + 650 * v6, 650);
            v4 = v20;
            dword_10185B58[(unsigned __int16)v5] = dword_10185B58[v6];
            dword_10186008[(unsigned __int16)v5] = *v7;
            v2 = *(_DWORD *)v19;
            v3 = word_10185B50;
          }
          ++v5;
        }
        v20 = ++v4;
      }
      while ( (unsigned __int16)v4 < v3 );
    }
    if ( v3 != v5 )
    {
      byte_101864B8 = 1;
      word_10185B50 = v5;
    }
    byte_10155349 = v17;
    result = 1;
  }
  else
  {
    byte_10155349 = *(_DWORD *)v19 % 0x1Cu;
    result = 0;
  }
  return result;
}
// 10155348: using guessed type char byte_10155348;
// 10155349: using guessed type char byte_10155349;
// 10184D30: using guessed type int dword_10184D30[];
// 10184D34: using guessed type int dword_10184D34[];
// 10184D38: using guessed type int dword_10184D38[];
// 10185B4C: using guessed type int dword_10185B4C;
// 10185B50: using guessed type __int16 word_10185B50;
// 10185B58: using guessed type int dword_10185B58[];
// 10186008: using guessed type int dword_10186008[];
// 101864B8: using guessed type char byte_101864B8;
// 103E0640: using guessed type char byte_103E0640;
// 10419D44: using guessed type int dword_10419D44;
// 10419D79: using guessed type int dword_10419D79;
// 10427F14: using guessed type int dword_10427F14;
// 10427F18: using guessed type __int16 word_10427F18;
// 10427F20: using guessed type int dword_10427F20[];
// 10428AD8: using guessed type char byte_10428AD8;

//----- (10007A00) --------------------------------------------------------
int __cdecl sub_10007A00(char *a1, int a2)
{
  int result; // eax@1
  unsigned __int16 v3; // bp@1
  int v4; // eax@2
  int v5; // esi@2

  sub_100225E0((int)a1, byte_10427EC6);
  result = sub_100074B0((_DWORD *)byte_10427EC6);
  v3 = result;
  if ( (unsigned __int16)result < 0x2EEu )
  {
    v4 = 77 * (unsigned __int16)result;
    qmemcpy((char *)&unk_10419D30 + v4, byte_10427EC6, 0x4Du);
    v5 = 300 * v3;
    *(int *)((char *)&dword_10419D44 + v4) += 300 * v3;
    *(int *)((char *)&dword_10419D79 + v4) = 300 * v3;
    strncpy((char *)&unk_103E2E48 + 300 * v3, a1, 0x12Cu);
    byte_103E2F70[v5] = 46;
    byte_103E2F71[v5] = 46;
    byte_103E2F72[v5] = 46;
    byte_103E2F73[v5] = 0;
    dword_10427F20[v3] = a2;
    dword_10427F14 = a2;
    result = 1;
    byte_10428AD8 = 1;
    if ( v3 == word_10427F18 )
      ++word_10427F18;
  }
  return result;
}
// 10419D44: using guessed type int dword_10419D44;
// 10419D79: using guessed type int dword_10419D79;
// 10427F14: using guessed type int dword_10427F14;
// 10427F18: using guessed type __int16 word_10427F18;
// 10427F20: using guessed type int dword_10427F20[];
// 10428AD8: using guessed type char byte_10428AD8;

//----- (10007AC0) --------------------------------------------------------
char __cdecl sub_10007AC0(char *a1, int a2)
{
  unsigned __int16 v2; // si@1
  char v3; // bl@1
  char *v4; // eax@10
  char *v5; // esi@10
  unsigned __int8 v6; // bl@13
  __int16 v7; // bp@14
  int v8; // eax@15
  unsigned int v9; // ecx@15
  int v10; // esi@17
  int v11; // ecx@17
  char v13; // [sp+8h] [bp-Ch]@13
  char v14; // [sp+Ah] [bp-Ah]@13
  int v15; // [sp+Ch] [bp-8h]@13
  int v16; // [sp+10h] [bp-4h]@13

  v2 = 0;
  v3 = 0;
  while ( v2 < 3u )
  {
    if ( !strncmp(a1 + 4, (&off_100865B8)[4 * v2], 4u) )
      v3 = 1;
    ++v2;
    if ( v3 )
    {
      dword_10185B40 = *((_DWORD *)a1 + 2);
      goto LABEL_10;
    }
  }
  if ( v3 )
    dword_10185B40 = *((_DWORD *)a1 + 2);
  else
    dword_10185B40 = *((_DWORD *)a1 + 1);
LABEL_10:
  v4 = strstr(a1 + 4, word_1007F98C);
  v5 = v4;
  if ( v4 )
  {
    v4 = (char *)isdigit((unsigned __int8)*(v4 - 1));
    if ( v4 )
    {
      v4 = (char *)isdigit((unsigned __int8)v5[1]);
      if ( v4 )
      {
        strncpy(&v13, v5 + 1, 2u);
        v14 = 0;
        LOBYTE(v16) = j__atol(&v13);
        strncpy(&v13, v5 + 3, 2u);
        v14 = 0;
        v6 = j__atol(&v13);
        LOBYTE(v4) = sub_1001FDD0(a2, v16, 0, 0, 0, &v15);
        v15 += 3600 * v6;
        if ( (_BYTE)v4 )
        {
          LOWORD(v4) = sub_100075C0(&dword_10185B40);
          v7 = (signed __int16)v4;
          if ( (unsigned __int16)v4 < 0x12Cu )
          {
            v8 = 3 * (unsigned __int16)v4;
            dword_10184D30[v8] = 0;
            dword_10184D34[v8] = 0;
            dword_10184D38[v8] = 0;
            v9 = strlen(a1);
            dword_10184D30[v8] = dword_10185B40;
            if ( v9 >= 0x28A )
              v9 = 650;
            v10 = 650 * (unsigned __int16)v7;
            dword_10184D38[v8] += 650 * (unsigned __int16)v7;
            dword_10184D34[v8] = v9;
            strncpy((char *)&unk_10155378 + 650 * (unsigned __int16)v7, a1, 0x28Au);
            v11 = v15;
            byte_101555FE[v10] = 46;
            byte_101555FF[v10] = 46;
            byte_10155600[v10] = 46;
            LOBYTE(v4) = a2;
            byte_10155601[v10] = 0;
            dword_10185B58[(unsigned __int16)v7] = a2;
            dword_10186008[(unsigned __int16)v7] = v11;
            dword_10185B4C = a2;
            byte_101864B8 = 1;
            if ( v7 == word_10185B50 )
              ++word_10185B50;
          }
        }
      }
    }
  }
  return (unsigned int)v4;
}
// 10184D30: using guessed type int dword_10184D30[];
// 10184D34: using guessed type int dword_10184D34[];
// 10184D38: using guessed type int dword_10184D38[];
// 10185B40: using guessed type int dword_10185B40;
// 10185B4C: using guessed type int dword_10185B4C;
// 10185B50: using guessed type __int16 word_10185B50;
// 10185B58: using guessed type int dword_10185B58[];
// 10186008: using guessed type int dword_10186008[];
// 101864B8: using guessed type char byte_101864B8;

//----- (10007CE0) --------------------------------------------------------
char __cdecl sub_10007CE0(int a1, int a2)
{
  char *v2; // eax@1
  int v3; // edi@9
  char v5; // [sp+0h] [bp-Ch]@5
  char v6[4]; // [sp+4h] [bp-8h]@1
  unsigned int v7; // [sp+8h] [bp-4h]@2

  LOBYTE(v2) = sub_10032600(v6);
  if ( !(_BYTE)v2 )
    return (unsigned int)v2;
  LOBYTE(v2) = sub_1001FDD0(
                 *(unsigned int *)v6,
                 *(_BYTE *)(a2 + 17),
                 *(_BYTE *)(a2 + 18),
                 *(_BYTE *)(a2 + 19),
                 *(_BYTE *)(a2 + 20),
                 &v7);
  if ( !(_BYTE)v2 )
    return (unsigned int)v2;
  v2 = (char *)*(_WORD *)(a2 + 2);
  if ( v2 == (char *)63 )
  {
    v3 = dword_101F3C58;
    sub_10007110(*(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 24), (int)&unk_101F3C48, v7);
    v2 = (char *)dword_101F3C58;
    byte_103E0640 = 1;
  }
  else
  {
    if ( v2 != (char *)413 )
      return (unsigned int)v2;
    sub_10006380(*(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 24), (int)byte_10152348, 12288, &v5);
    if ( strstr(byte_10152348, "METAR") != byte_10152348 && strstr(byte_10152348, "SPECI") != byte_10152348 )
    {
      v2 = strstr(byte_10152348, "TAF");
      if ( v2 == byte_10152348 )
        LOBYTE(v2) = sub_10007AC0(byte_10152348, *(int *)v6);
      return (unsigned int)v2;
    }
    v3 = dword_10427F14;
    sub_10007A00(byte_10152348, *(int *)v6);
    v2 = (char *)dword_10427F14;
  }
  if ( (char *)v3 != v2 )
    byte_10155348 = 15;
  return (unsigned int)v2;
}
// 10155348: using guessed type char byte_10155348;
// 101F3C58: using guessed type int dword_101F3C58;
// 103E0640: using guessed type char byte_103E0640;
// 10427F14: using guessed type int dword_10427F14;

//----- (10007E20) --------------------------------------------------------
int sub_10007E20()
{
  int v0; // eax@1
  int v1; // eax@1
  void *v2; // esi@3
  bool v3; // zf@3
  int v4; // eax@5
  char v6; // [sp+8h] [bp-8h]@1
  char v7; // [sp+Ah] [bp-6h]@3
  char v8; // [sp+Ch] [bp-4h]@1
  char v9; // [sp+Dh] [bp-3h]@3

  sub_1002C6F0((int)&v8, dword_10427F14);
  sub_1002C910((int)&v6, dword_10427F14);
  v0 = sub_10032680(8u);
  sub_10060A60(v0, 30000);
  v1 = *(_DWORD *)(dword_109FFDCC + 2712);
  if ( dword_10427F14 == -1 || (unsigned __int16)word_10427F18 <= 0u )
  {
    *(_WORD *)(v1 + 3) = word_10427F18;
    *(_DWORD *)(dword_109FFDCC + 2718) = 5;
    *(_DWORD *)(dword_109FFDCC + 2724) = 0;
    *(_DWORD *)(dword_109FFDCC + 2730) = 0;
    *(_BYTE *)(dword_109FFDCC + 2705) = 0;
    *(_BYTE *)(dword_109FFDCC + 2696) = 0;
    *(_BYTE *)(dword_109FFDCC + 2689) = 0;
    *(_BYTE *)(dword_109FFDCC + 2688) = 0;
  }
  else
  {
    *(_BYTE *)v1 = v9;
    *(_BYTE *)(v1 + 1) = v6;
    *(_BYTE *)(v1 + 2) = v7;
    *(_WORD *)(v1 + 3) = word_10427F18;
    v2 = (void *)(*(_DWORD *)(dword_109FFDCC + 2712) + 5);
    memcpy(v2, &unk_10419D30, 77 * (unsigned __int16)word_10427F18);
    memcpy((char *)v2 + 77 * (unsigned __int16)word_10427F18, &unk_103E2E48, 300 * (unsigned __int16)word_10427F18);
    *(_DWORD *)(dword_109FFDCC + 2718) = 5;
    *(_DWORD *)(dword_109FFDCC + 2724) = 77 * (unsigned __int16)word_10427F18;
    *(_DWORD *)(dword_109FFDCC + 2730) = 300 * (unsigned __int16)word_10427F18;
    *(_BYTE *)(dword_109FFDCC + 2705) = 1;
    v3 = byte_1015534B == 0;
    *(_BYTE *)(dword_109FFDCC + 2696) = 1;
    *(_BYTE *)(dword_109FFDCC + 2688) = v3;
  }
  sub_100201C0(8u);
  *(_BYTE *)(dword_109FFDCC + 14618950) = (*(_BYTE *)(dword_109FFDCC + 14618950) + (unsigned __int8)byte_10155348) % 255;
  v4 = sub_10032680(8u);
  return sub_10060A00(v4);
}
// 10155348: using guessed type char byte_10155348;
// 1015534B: using guessed type char byte_1015534B;
// 10427F14: using guessed type int dword_10427F14;
// 10427F18: using guessed type __int16 word_10427F18;
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (10008000) --------------------------------------------------------
char sub_10008000()
{
  char result; // al@1
  int v1; // eax@2
  int v2; // esi@2
  bool v3; // zf@3
  int v4; // eax@5
  int v5; // [sp+0h] [bp-28h]@2
  int v6; // [sp+4h] [bp-24h]@2
  int v7; // [sp+8h] [bp-20h]@2
  char v8; // [sp+Ch] [bp-1Ch]@3
  char v9; // [sp+Eh] [bp-1Ah]@3
  int v10; // [sp+10h] [bp-18h]@2
  int v11; // [sp+14h] [bp-14h]@2
  int v12; // [sp+18h] [bp-10h]@2
  int v13; // [sp+1Ch] [bp-Ch]@2
  int v14; // [sp+20h] [bp-8h]@2
  char v15; // [sp+24h] [bp-4h]@3
  char v16; // [sp+25h] [bp-3h]@3

  result = sub_100324A0(2);
  if ( result )
  {
    v1 = sub_10032680(0);
    sub_10060A60(v1, 30000);
    v2 = *(_DWORD *)(dword_109FFDCC + 1656);
    if ( sub_100069F0(
           (int)&unk_101F3C48,
           (int)&v10,
           (int)&v11,
           (int)&v5,
           (int)&v6,
           (void *)(v2 + 24),
           *(_DWORD *)(dword_109FFDCC + 1652),
           (int)&v12,
           (int)&v13,
           (int)&v14,
           (int)&v7) )
    {
      *(_DWORD *)v2 = v10;
      *(_DWORD *)(v2 + 4) = v11;
      *(_DWORD *)(v2 + 14) = 0;
      *(_WORD *)(v2 + 18) = v5;
      *(_WORD *)(v2 + 20) = v6;
      *(_WORD *)(v2 + 22) = 1852;
      *(_DWORD *)(dword_109FFDCC + 1662) = 24;
      *(_DWORD *)(dword_109FFDCC + 1668) = v12;
      *(_DWORD *)(dword_109FFDCC + 1674) = v13;
      *(_DWORD *)(dword_109FFDCC + 1680) = v14;
      sub_1002C6F0((int)&v15, v7);
      sub_1002C910((int)&v8, v7);
      *(_BYTE *)(v2 + 8) = v16;
      *(_BYTE *)(v2 + 9) = v8;
      *(_BYTE *)(v2 + 10) = v9;
      *(_BYTE *)(v2 + 11) = 0;
      *(_BYTE *)(v2 + 12) = 0;
      *(_BYTE *)(v2 + 13) = 0;
      *(_BYTE *)(dword_109FFDCC + 1649) = 1;
      v3 = byte_1015534B == 0;
      *(_BYTE *)(dword_109FFDCC + 1640) = 1;
      *(_BYTE *)(dword_109FFDCC + 1632) = v3;
    }
    else
    {
      *(_BYTE *)(dword_109FFDCC + 1649) = 0;
      *(_BYTE *)(dword_109FFDCC + 1640) = 0;
      *(_BYTE *)(dword_109FFDCC + 1633) = 0;
      *(_BYTE *)(dword_109FFDCC + 1632) = 0;
    }
    sub_100201C0(0);
    *(_BYTE *)(dword_109FFDCC + 14618950) = ((unsigned __int8)byte_10155348 + *(_BYTE *)(dword_109FFDCC + 14618950))
                                          % 255;
    v4 = sub_10032680(0);
    result = sub_10060A00(v4);
  }
  return result;
}
// 10155348: using guessed type char byte_10155348;
// 1015534B: using guessed type char byte_1015534B;
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (100081D0) --------------------------------------------------------
int sub_100081D0()
{
  int v0; // eax@1
  int v1; // eax@1
  void *v2; // esi@3
  bool v3; // zf@3
  int v4; // eax@5
  char v6; // [sp+4h] [bp-8h]@1
  char v7; // [sp+6h] [bp-6h]@3
  char v8; // [sp+8h] [bp-4h]@1
  char v9; // [sp+9h] [bp-3h]@3

  sub_1002C6F0((int)&v8, dword_10185B4C);
  sub_1002C910((int)&v6, dword_10185B4C);
  v0 = sub_10032680(0xAu);
  sub_10060A60(v0, 30000);
  v1 = *(_DWORD *)(dword_109FFDCC + 2976);
  if ( dword_10185B4C == -1 || (unsigned __int16)word_10185B50 <= 0u )
  {
    *(_DWORD *)(v1 + 3) = (unsigned __int16)word_10185B50;
    *(_DWORD *)(dword_109FFDCC + 2982) = 7;
    *(_DWORD *)(dword_109FFDCC + 2988) = 0;
    *(_DWORD *)(dword_109FFDCC + 2994) = 0;
    *(_BYTE *)(dword_109FFDCC + 2969) = 0;
    *(_BYTE *)(dword_109FFDCC + 2960) = 0;
    *(_BYTE *)(dword_109FFDCC + 2953) = 0;
    *(_BYTE *)(dword_109FFDCC + 2952) = 0;
  }
  else
  {
    *(_BYTE *)v1 = v9;
    *(_BYTE *)(v1 + 1) = v6;
    *(_BYTE *)(v1 + 2) = v7;
    *(_DWORD *)(v1 + 3) = (unsigned __int16)word_10185B50;
    v2 = (void *)(*(_DWORD *)(dword_109FFDCC + 2976) + 7);
    memcpy(v2, dword_10184D30, 12 * (unsigned __int16)word_10185B50);
    memcpy((char *)v2 + 12 * (unsigned __int16)word_10185B50, &unk_10155378, 650 * (unsigned __int16)word_10185B50);
    *(_DWORD *)(dword_109FFDCC + 2982) = 7;
    *(_DWORD *)(dword_109FFDCC + 2988) = 12 * (unsigned __int16)word_10185B50;
    *(_DWORD *)(dword_109FFDCC + 2994) = 650 * (unsigned __int16)word_10185B50;
    *(_BYTE *)(dword_109FFDCC + 2969) = 1;
    v3 = byte_1015534B == 0;
    *(_BYTE *)(dword_109FFDCC + 2960) = 1;
    *(_BYTE *)(dword_109FFDCC + 2952) = v3;
  }
  v4 = sub_10032680(0xAu);
  return sub_10060A00(v4);
}
// 1015534B: using guessed type char byte_1015534B;
// 10184D30: using guessed type int dword_10184D30[];
// 10185B4C: using guessed type int dword_10185B4C;
// 10185B50: using guessed type __int16 word_10185B50;
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (10008660) --------------------------------------------------------
char __cdecl sub_10008660(int a1)
{
  char result; // al@1
  int v2; // eax@5
  int v3; // eax@15
  signed int v4; // ecx@18
  int v5; // [sp+4h] [bp-1Ch]@6

  result = a1;
  if ( (signed int)(unsigned __int16)a1 > 369 )
  {
    if ( (unsigned __int16)a1 == 372 )
    {
      if ( !sub_100144B0(372, (int)&byte_10A08A80, &v5) )
        return sub_10028BC0("..\\lib\\acl\\iop\\gdl59\\iop_gdl59.c", 904, 0, 0);
      sub_10060A60(95, 300);
      v4 = 0;
      do
      {
        if ( (v5 & (1 << v4)) == 1 << v4 )
          *(_BYTE *)(dword_1042CE6C + v4 + 76) = 1;
        ++v4;
      }
      while ( v4 < 32 );
      return sub_10060A00(95);
    }
    if ( (unsigned __int16)a1 != 671 )
      return result;
LABEL_15:
    v3 = sub_10060900();
    return sub_10013610(a1, 1, (int)&byte_10A08A80, &byte_1042E4B8, v3);
  }
  if ( (unsigned __int16)a1 == 369 )
    goto LABEL_15;
  if ( (unsigned __int16)a1 == 355 )
  {
    result = sub_100144B0(355, (int)&byte_10A08A80, &v5);
    if ( !result )
      return result;
    sub_10060A60(95, 300);
    switch ( (unsigned __int8)v5 )
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
        *(_BYTE *)(dword_1042CE6C + 28) = 0;
        *(_BYTE *)(dword_1042CE6C + 29) = 0;
        *(_DWORD *)(dword_1042CE6C + 36) = sub_10060900();
        break;
      case 0xAu:
      case 0xBu:
        *(_BYTE *)(dword_1042CE6C + 4) = 0;
        *(_BYTE *)(dword_1042CE6C + 5) = 0;
        *(_DWORD *)(dword_1042CE6C + 12) = sub_10060900();
        break;
      case 0xCu:
      case 0xDu:
      case 0xEu:
        *(_BYTE *)(dword_1042CE6C + 16) = 0;
        *(_BYTE *)(dword_1042CE6C + 17) = 0;
        *(_DWORD *)(dword_1042CE6C + 24) = sub_10060900();
        break;
      case 7u:
      case 8u:
        *(_BYTE *)(dword_1042CE6C + 64) = 0;
        *(_BYTE *)(dword_1042CE6C + 65) = 1;
        *(_DWORD *)(dword_1042CE6C + 72) = sub_10060900();
        break;
      case 9u:
        *(_BYTE *)(dword_1042CE6C + 52) = 0;
        *(_BYTE *)(dword_1042CE6C + 53) = 1;
        *(_DWORD *)(dword_1042CE6C + 60) = sub_10060900();
        break;
      default:
        return sub_10060A00(95);
    }
    return sub_10060A00(95);
  }
  result = a1 - 106;
  if ( (unsigned __int16)a1 == 362 )
  {
    sub_10060A60(95, 300);
    v2 = sub_10060900();
    sub_10013610(a1, 1, (int)&byte_10A08A80, (const void *)(dword_1042CE6C + 108), v2);
    byte_1042CE6A = 0;
    result = sub_10060A00(95);
  }
  return result;
}
// 1042CE6A: using guessed type char byte_1042CE6A;
// 1042CE6C: using guessed type int dword_1042CE6C;
// 1042E4B8: using guessed type char byte_1042E4B8;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (100088E0) --------------------------------------------------------
char __thiscall sub_100088E0(void *this)
{
  unsigned int v1; // esi@1
  char result; // al@2
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = sub_1002C660(this);
  sub_100210F0(0x8000);
  v1 = 0;
  do
  {
    LOWORD(v3) = word_10087020[v1];
    sub_10015560(2, 0, &v3, 0, 8, 1);
    result = sub_10015710(2, 0, 0x8000);
    ++v1;
  }
  while ( v1 < 4 );
  return result;
}
// 10087020: using guessed type __int16 word_10087020[];

//----- (10008960) --------------------------------------------------------
char __cdecl sub_10008960(char a1)
{
  signed int v1; // ebp@1
  signed int v2; // esi@4
  void *v3; // edi@5
  char result; // al@7
  int v5; // [sp+Ch] [bp-1A4h]@1
  int v6; // [sp+10h] [bp-1A0h]@1
  char v7; // [sp+74h] [bp-13Ch]@1
  char v8; // [sp+D8h] [bp-D8h]@1
  char v9; // [sp+13Ch] [bp-74h]@1
  char v10; // [sp+13Fh] [bp-71h]@7

  qmemcpy(&v9, &a1, 0x70u);
  sub_10025090(0, &v5, (float *)&v7, (float *)&v8);
  v1 = v6;
  if ( v5 <= 0 )
    v1 = 0x3FFFF;
  if ( !byte_1042ED7C )
  {
    v2 = 0;
    if ( byte_1042E4B8 )
    {
      v3 = &unk_1042E4BC;
      do
      {
        memset(v3, 0, 0x70u);
        ++v2;
        v3 = (char *)v3 + 112;
      }
      while ( v2 < (unsigned __int8)byte_1042E4B8 );
    }
  }
  qmemcpy(&unk_1042E4BC, &v9, 0x70u);
  qmemcpy(&unk_1042E52C, &v9, 0x70u);
  result = 2;
  dword_1042ED80 = v1;
  byte_1042ED7C = 1;
  byte_1042E4B8 = 2;
  if ( v10 == 2 )
  {
    byte_1042E531 = 4;
    byte_1042E532 = 4;
  }
  return result;
}
// 1042E4B8: using guessed type char byte_1042E4B8;
// 1042E531: using guessed type char byte_1042E531;
// 1042E532: using guessed type char byte_1042E532;
// 1042ED7C: using guessed type char byte_1042ED7C;
// 1042ED80: using guessed type int dword_1042ED80;

//----- (10008A60) --------------------------------------------------------
int __cdecl sub_10008A60(unsigned __int8 a1, char a2)
{
  char v3; // [sp+8h] [bp-2Ch]@1

  qmemcpy(&v3, &a2, 0x28u);
  sub_10060A60(95, 300);
  qmemcpy((void *)(dword_1042CE6C + 40 * a1 + 116), &v3, 0x28u);
  byte_1042CE6A = 1;
  return sub_10060A00(95);
}
// 1042CE6A: using guessed type char byte_1042CE6A;
// 1042CE6C: using guessed type int dword_1042CE6C;

//----- (10008AD0) --------------------------------------------------------
void __cdecl sub_10008AD0(__int16 a1)
{
  void *v1; // ecx@0

  if ( a1 == 356 && sub_10032830(v1) )
  {
    if ( !sub_1002D390(208) && !sub_1002D390(260) && !sub_1002D390(210) )
    {
      sub_1002D550(0xD1u);
      sub_1002D440(211);
    }
    byte_1042CE68 = 1;
  }
}
// 1042CE68: using guessed type char byte_1042CE68;

//----- (10008B40) --------------------------------------------------------
int __cdecl sub_10008B40(unsigned __int8 a1, int a2)
{
  int v2; // eax@1
  int v3; // ecx@3
  char v4; // cl@7

  sub_10060A60(95, 300);
  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 != 1 )
    *(_DWORD *)(dword_1042CE6C + 12 * a1 + 8) = v2;
  v3 = *(_DWORD *)(a2 + 8);
  if ( v3 != -1 )
    *(_DWORD *)(dword_1042CE6C + 12 * (a1 + 1)) = v3;
  if ( *(_BYTE *)a2 != -1 )
    *(_BYTE *)(dword_1042CE6C + 12 * a1 + 4) = *(_BYTE *)a2;
  v4 = *(_BYTE *)(a2 + 1);
  if ( v4 != -1 )
    *(_BYTE *)(dword_1042CE6C + 12 * a1 + 5) = v4;
  return sub_10060A00(95);
}
// 1042CE6C: using guessed type int dword_1042CE6C;

//----- (10008C40) --------------------------------------------------------
char __thiscall sub_10008C40(void *this)
{
  int v1; // edi@1
  int v2; // ecx@1
  int v3; // esi@1
  char result; // al@1
  char v5; // bl@4
  unsigned __int8 v6; // cl@6
  char v7; // [sp+13h] [bp-65h]@4
  int v8; // [sp+14h] [bp-64h]@0
  char v9; // [sp+18h] [bp-60h]@1
  char v10; // [sp+1Dh] [bp-5Bh]@2
  char v11; // [sp+1Eh] [bp-5Ah]@1
  char v12; // [sp+1Fh] [bp-59h]@3
  __int16 v13; // [sp+6Ch] [bp-Ch]@14
  char v14; // [sp+70h] [bp-8h]@16

  v1 = sub_1002C660(this);
  v3 = v1 | j_HWM_pvg_hsdb_get_lrus_online(v2);
  memset(&v9, 0, 0x52u);
  result = sub_100144B0(361, (int)&byte_10A08A80, &v9);
  if ( v11 || v10 || v12 )
  {
    v7 = 1;
    v5 = 1;
  }
  else
  {
    v5 = 0;
    v7 = 0;
  }
  v6 = 0;
  while ( (v3 & dword_1008703C[v6]) != dword_1008703C[v6] )
  {
    if ( ++v6 >= 4u )
      goto LABEL_9;
  }
  if ( dword_1008703C[v6] != v1 || !result || v5 || !byte_1042CE6B )
  {
LABEL_9:
    byte_1042CE6B = v5;
    return result;
  }
  v13 = -32698;
  LOBYTE(v8) = 0;
  do
  {
    result = sub_10032CF0(v8, 0x15u);
    if ( result == 1 )
    {
      v14 = v5;
      result = sub_1002CC50((int)&v13);
    }
    LOBYTE(v8) = ++v5;
  }
  while ( (unsigned __int8)v5 < 6u );
  byte_1042CE6B = v7;
  return result;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 1008703C: using guessed type int dword_1008703C[];
// 1042CE6B: using guessed type char byte_1042CE6B;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10008D60) --------------------------------------------------------
char sub_10008D60()
{
  int v0; // eax@1
  char v2; // [sp+1h] [bp-5Bh]@1
  char v3; // [sp+2h] [bp-5Ah]@2
  char v4; // [sp+3h] [bp-59h]@1
  char v5; // [sp+4h] [bp-58h]@1
  char v6; // [sp+Ah] [bp-52h]@5

  v4 = 0;
  sub_10060E40(3004, &v2, 1, &v4);
  LOBYTE(v0) = sub_100144B0(361, (int)&byte_10A08A80, &v5);
  if ( (_BYTE)v0 )
  {
    LOBYTE(v0) = sub_10033260(105, &v3);
    if ( (_BYTE)v0 )
    {
      if ( v2 || v3 || !v6 )
      {
        LOBYTE(v0) = dword_1042CE6C;
        if ( *(_BYTE *)(dword_1042CE6C + 1) )
        {
          v0 = sub_10060A60(95, 300);
          if ( !v0 )
          {
            *(_BYTE *)(dword_1042CE6C + 1) = 0;
            sub_10032E40(0x2Fu);
            LOBYTE(v0) = sub_10060A00(95);
          }
        }
      }
      else if ( !*(_BYTE *)(dword_1042CE6C + 1) )
      {
        v0 = sub_10060A60(95, 300);
        if ( !v0 )
        {
          *(_BYTE *)(dword_1042CE6C + 1) = 1;
          sub_10032EB0(0x2Fu);
          sub_10060A90(9, 0x8000000);
          LOBYTE(v0) = sub_10060A00(95);
        }
      }
    }
  }
  return v0;
}
// 1042CE6C: using guessed type int dword_1042CE6C;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10008E80) --------------------------------------------------------
char sub_10008E80()
{
  int v0; // eax@1
  signed int v1; // ebp@1
  int v2; // edi@1
  char *v3; // esi@1
  char v4; // cl@4
  char v6[20]; // [sp+10h] [bp-18h]@1

  LOBYTE(v0) = sub_10033290((int)v6, 20);
  v1 = 0;
  v2 = dword_1042CE6C + 1412;
  v3 = &v6[-dword_1042CE6C - 1412];
  while ( 1 )
  {
    if ( !*(_BYTE *)(v2 + 20) )
    {
      v0 = v2;
      if ( v2 )
      {
        v4 = *(_BYTE *)v2;
        if ( *(_BYTE *)v2 == v6[0] )
          break;
      }
    }
LABEL_7:
    ++v1;
    v3 -= 60;
    v2 += 60;
    if ( v1 >= 20 )
      return v0;
  }
  while ( v4 )
  {
    v4 = *(_BYTE *)(v0++ + 1);
    if ( v4 != v3[v0] )
      goto LABEL_7;
  }
  LOBYTE(v0) = sub_10033300(dword_1042CE6C + 60 * v1 + 1432, 36);
  return v0;
}
// 1042CE6C: using guessed type int dword_1042CE6C;
// 10008E80: using guessed type char var_18[20];

//----- (10008F30) --------------------------------------------------------
signed int sub_10008F30()
{
  memset(&byte_1042E4B8, 0, 0x8CCu);
  byte_1042CE6B = 0;
  byte_1042CE69 = 0;
  byte_1042CE6A = 0;
  byte_1042CE68 = 0;
  dword_1042CE6C = -15;
  sub_10060A60(95, 300);
  if ( !sub_10061B70((LONG)&off_10087028) )
    sub_10028BC0("..\\lib\\acl\\iop\\gdl59\\iop_gdl59.c", 1655, 1, 0);
  sub_10060A00(95);
  return sub_10061700((int)&off_10087028);
}
// 10087028: using guessed type char *off_10087028;
// 1042CE68: using guessed type char byte_1042CE68;
// 1042CE69: using guessed type char byte_1042CE69;
// 1042CE6A: using guessed type char byte_1042CE6A;
// 1042CE6B: using guessed type char byte_1042CE6B;
// 1042CE6C: using guessed type int dword_1042CE6C;
// 1042E4B8: using guessed type char byte_1042E4B8;

//----- (10008F70) --------------------------------------------------------
char sub_10008F70()
{
  char result; // al@5
  signed int v1; // esi@6
  void *v2; // edi@7
  char *v3; // edi@10
  int v4; // eax@10
  char *v5; // ebx@10
  _BYTE *v6; // esi@10
  char *v7; // ebp@10
  bool v8; // zf@11
  void *v9; // eax@11
  int v10; // eax@14
  _BYTE *v11; // eax@15
  _BYTE *v12; // ecx@15
  bool v13; // sf@16
  unsigned __int8 v14; // of@16
  unsigned int v15; // ebx@17
  char v16; // cl@17
  unsigned __int8 v17; // al@17
  char *v18; // esi@18
  char v19; // al@20
  int v20; // ecx@23
  char v21; // al@26
  signed int v22; // ebx@28
  void *v23; // edx@29
  void *v24; // eax@29
  char v25; // [sp+2h] [bp-18Eh]@13
  int v26; // [sp+3h] [bp-18Dh]@12
  unsigned __int8 v27; // [sp+7h] [bp-189h]@17
  int v28; // [sp+8h] [bp-188h]@1
  void *v29; // [sp+Ch] [bp-184h]@10
  void *v30; // [sp+10h] [bp-180h]@10
  _BYTE *v31; // [sp+14h] [bp-17Ch]@14
  char *v32; // [sp+18h] [bp-178h]@14
  int v33; // [sp+1Ch] [bp-174h]@10
  int v34; // [sp+20h] [bp-170h]@13
  int v35; // [sp+24h] [bp-16Ch]@2
  int v36; // [sp+28h] [bp-168h]@1
  int v37; // [sp+2Ch] [bp-164h]@2
  char v38; // [sp+90h] [bp-100h]@1
  char v39; // [sp+F4h] [bp-9Ch]@1
  char v40[52]; // [sp+158h] [bp-38h]@1

  memset(&unk_1042CE70, 0, 0x1644u);
  memset(v40, 0, 0x32u);
  v28 = 0;
  sub_10025090(0, &v36, (float *)&v39, (float *)&v38);
  if ( v36 <= 0 )
  {
    result = 0;
  }
  else
  {
    v35 = v37;
    if ( byte_1042ED7C )
    {
      if ( dword_1042ED80 == v37 )
        return 1;
      byte_1042ED7C = 0;
      byte_1042E4B8 = 0;
      memset(&unk_1042E4BC, 0, 0x70u);
    }
    else
    {
      v1 = 0;
      if ( byte_1042E4B8 )
      {
        v2 = &unk_1042E4BC;
        do
        {
          memset(v2, 0, 0x70u);
          ++v1;
          v2 = (char *)v2 + 112;
        }
        while ( v1 < (unsigned __int8)byte_1042E4B8 );
      }
      byte_1042E4B8 = 0;
    }
    v3 = (char *)&unk_1042CE70;
    v4 = 0;
    v5 = (char *)&unk_1042CE70 - 114;
    v33 = 0;
    v30 = &unk_1042CE76;
    v29 = &unk_1042CE75;
    v6 = &unk_1042CEE0;
    v7 = (char *)&unk_1042CE73 - 114;
    do
    {
      v8 = *(_BYTE *)(v4 + dword_1042CE6C + 1432) == 0;
      v9 = (void *)(v4 + dword_1042CE6C + 1432);
      if ( !v8 && !sub_10022A10(v9, 33, v35, (int)&v26) )
      {
        sub_10022810(v26, v3, &v34, &v25);
        if ( v25 )
        {
          v10 = (unsigned __int8)v26;
          *v6 = *(_BYTE *)(v33 + dword_1042CE6C + 1411);
          v40[v10] = 1;
          v29 = (char *)v29 + 114;
          v30 = (char *)v30 + 114;
          ++v28;
          v6 += 114;
          v7 += 114;
          v3 += 114;
          v5 += 114;
          v8 = *v7 == 2;
          v31 = v6;
          v32 = v3;
          if ( v8 )
          {
            v11 = v29;
            ++v28;
            qmemcpy(v3, v5, 0x70u);
            v12 = v30;
            v31 += 114;
            v32 += 114;
            *((_WORD *)v3 + 56) = *((_WORD *)v5 + 56);
            v3 = v32;
            v6 = v31;
            *v11 = 4;
            *v12 = 4;
            v7 += 114;
            v5 += 114;
            v29 = v11 + 114;
            v30 = v12 + 114;
          }
        }
      }
      v4 = v33 + 60;
      v14 = __OFSUB__(v33 + 60, 1200);
      v13 = v33 - 1140 < 0;
      v33 += 60;
    }
    while ( v13 ^ v14 );
    v15 = v28;
    sub_10033540((int)&unk_1042CE70, v28, 0x72u, (int)sub_10008BD0);
    v16 = sub_10022B00();
    v17 = 0;
    v27 = v16;
    LOBYTE(v26) = 0;
    if ( v16 )
    {
      v18 = (char *)&unk_1042CEE0 + 114 * v15;
      do
      {
        if ( !v40[v17] )
        {
          v19 = sub_10022810(v26, v18 - 112, &v34, &v25);
          if ( !v25 || v19 || v34 != v35 )
          {
            v17 = v26;
          }
          else
          {
            v17 = v26;
            v20 = (unsigned __int8)v26;
            *v18 = -127;
            ++v15;
            v40[v20] = 1;
            v18 += 114;
          }
        }
        LOBYTE(v26) = ++v17;
      }
      while ( v17 < v27 );
    }
    v21 = v15;
    if ( v15 >= 0x14 )
      v21 = 20;
    v22 = 0;
    byte_1042E4B8 = v21;
    if ( v21 )
    {
      v23 = &unk_1042E4BC;
      v24 = &unk_1042CE70;
      do
      {
        qmemcpy(v23, v24, 0x70u);
        ++v22;
        v24 = (char *)v24 + 114;
        v23 = (char *)v23 + 112;
      }
      while ( v22 < (unsigned __int8)byte_1042E4B8 );
    }
    result = 1;
  }
  return result;
}
// 10008BD0: using guessed type int sub_10008BD0();
// 1042CE6C: using guessed type int dword_1042CE6C;
// 1042E4B8: using guessed type char byte_1042E4B8;
// 1042ED7C: using guessed type char byte_1042ED7C;
// 1042ED80: using guessed type int dword_1042ED80;
// 10008F70: using guessed type char var_38[52];

//----- (100092C0) --------------------------------------------------------
char sub_100092C0()
{
  signed int v0; // ebp@1
  signed int v1; // esi@9
  const char *v2; // edi@10
  char *v3; // ST00_4@16
  char result; // al@19
  char v5; // [sp+7h] [bp-15Dh]@3
  int v6; // [sp+8h] [bp-15Ch]@17
  int v7; // [sp+Ch] [bp-158h]@1
  int v8; // [sp+10h] [bp-154h]@1
  char v9; // [sp+74h] [bp-F0h]@1
  char v10; // [sp+D8h] [bp-8Ch]@1
  char v11[4]; // [sp+13Ch] [bp-28h]@1
  int v12; // [sp+140h] [bp-24h]@1
  int v13; // [sp+144h] [bp-20h]@1
  int v14; // [sp+148h] [bp-1Ch]@1
  int v15; // [sp+14Ch] [bp-18h]@1
  int v16; // [sp+150h] [bp-14h]@1
  int v17; // [sp+154h] [bp-10h]@1
  int v18; // [sp+158h] [bp-Ch]@1
  char v19; // [sp+15Ch] [bp-8h]@1

  *(_DWORD *)v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  sub_10025090(0, &v7, (float *)&v10, (float *)&v9);
  v0 = v8;
  if ( v7 <= 0 )
    v0 = 0x3FFFF;
  if ( sub_10033370(&v5) && sub_10033300((int)v11, 33) && (v5 == 3 || v5 == 6) )
  {
    if ( byte_1042ED7C )
    {
      byte_1042E4B8 = 0;
      memset(&unk_1042E4BC, 0, 0x70u);
      byte_1042ED7C = 0;
    }
    else
    {
      v1 = 0;
      if ( byte_1042E4B8 )
      {
        v2 = byte_1042E4C8;
        while ( strncmp(v2, v11, 0x21u) )
        {
          ++v1;
          v2 += 112;
          if ( v1 >= (unsigned __int8)byte_1042E4B8 )
            goto LABEL_17;
        }
        if ( v1 != (unsigned __int8)byte_1042E4B8 - 1 )
          memcpy(
            (char *)&unk_1042E4BC + 112 * v1,
            (char *)&unk_1042E52C + 112 * v1,
            112 * ((unsigned __int8)byte_1042E4B8 - v1 - 1));
        v3 = (char *)&unk_1042E4BC + 112 * (unsigned __int8)(byte_1042E4B8-- - 1);
        memset(v3, 0, 0x70u);
      }
    }
LABEL_17:
    if ( !sub_10022A10(v11, 33, v0, (int)&v6) )
      sub_10022930(v6, 0);
    result = sub_10008F70();
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1042E4B8: using guessed type char byte_1042E4B8;
// 1042ED7C: using guessed type char byte_1042ED7C;

//----- (100094A0) --------------------------------------------------------
char __cdecl sub_100094A0(unsigned __int16 a1)
{
  signed int v1; // eax@1
  int v2; // edx@34
  char *v3; // esi@34
  void *v4; // ecx@47
  void *v5; // ecx@65
  int v6; // esi@65
  int v7; // ecx@65
  char v8; // al@65
  bool v9; // cl@65
  bool v10; // al@65
  char v11; // al@76
  int v12; // ecx@76
  __int64 v14; // [sp+0h] [bp-290h]@5
  char v15; // [sp+8h] [bp-288h]@43
  int v16; // [sp+9h] [bp-287h]@76
  char v17; // [sp+Ch] [bp-284h]@34

  LOBYTE(v1) = a1;
  if ( (signed int)a1 <= 133 )
  {
    if ( a1 == 133 )
    {
      if ( sub_100144B0(133, (int)&byte_10A08A80, &v14) && (_BYTE)v14 == 2 )
      {
        LOBYTE(v1) = sub_1002D440(211);
      }
      else
      {
        LOBYTE(v1) = sub_1002D390(208);
        if ( !(_BYTE)v1 )
        {
          LOBYTE(v1) = sub_1002D390(260);
          if ( !(_BYTE)v1 )
          {
            LOBYTE(v1) = sub_1002D390(209);
            if ( !(_BYTE)v1 )
            {
              LOBYTE(v1) = sub_1002D390(210);
              if ( !(_BYTE)v1 )
                LOBYTE(v1) = sub_1002D550(0xD3u);
            }
          }
        }
      }
    }
    else if ( a1 == 99 )
    {
      LOBYTE(v1) = dword_1042CE6C;
      *(_BYTE *)(dword_1042CE6C + 17) = 1;
    }
    return v1;
  }
  if ( (signed int)a1 <= 361 )
  {
    if ( a1 == 361 )
    {
      sub_10060A60(95, 300);
      *(_BYTE *)(dword_1042CE6C + 29) = 1;
      *(_BYTE *)(dword_1042CE6C + 5) = 1;
      sub_10060A00(95);
      sub_10008D60();
      LOBYTE(v1) = sub_10008C40(v4);
      return v1;
    }
    if ( a1 != 316 )
    {
      if ( a1 == 354 )
      {
        LOBYTE(v1) = sub_100144B0(354, (int)&byte_10A08A80, &v14);
        if ( (_BYTE)v1 )
        {
          sub_10060A60(95, 300);
          if ( (unsigned __int16)v14 == 355 )
          {
            switch ( BYTE2(v14) )
            {
              case 0u:
              case 1u:
              case 2u:
              case 3u:
              case 4u:
              case 5u:
              case 6u:
                *(_DWORD *)(dword_1042CE6C + 32) = HIDWORD(v14);
                *(_BYTE *)(dword_1042CE6C + 28) = 1;
                LOBYTE(v1) = sub_10060A00(95);
                return v1;
              case 0xAu:
              case 0xBu:
                *(_DWORD *)(dword_1042CE6C + 8) = HIDWORD(v14);
                *(_BYTE *)(dword_1042CE6C + 4) = 1;
                LOBYTE(v1) = sub_10060A00(95);
                return v1;
              case 0xCu:
              case 0xDu:
              case 0xEu:
                *(_DWORD *)(dword_1042CE6C + 20) = HIDWORD(v14);
                *(_BYTE *)(dword_1042CE6C + 16) = 1;
                LOBYTE(v1) = sub_10060A00(95);
                return v1;
              case 7u:
              case 8u:
                *(_DWORD *)(dword_1042CE6C + 68) = HIDWORD(v14);
                *(_BYTE *)(dword_1042CE6C + 64) = 1;
                LOBYTE(v1) = sub_10060A00(95);
                return v1;
              case 9u:
                *(_DWORD *)(dword_1042CE6C + 56) = HIDWORD(v14);
                *(_BYTE *)(dword_1042CE6C + 52) = 1;
                break;
              default:
                break;
            }
          }
          else if ( (unsigned __int16)v14 == 376 && HIDWORD(v14) )
          {
            sub_1002D550(0xD4u);
            *(_DWORD *)(dword_1042CE6C + 44) = HIDWORD(v14);
            *(_BYTE *)(dword_1042CE6C + 40) = 1;
            LOBYTE(v1) = sub_10060A00(95);
            return v1;
          }
          LOBYTE(v1) = sub_10060A00(95);
          return v1;
        }
      }
      else
      {
        LOBYTE(v1) = a1 - 100;
        if ( a1 == 356 )
        {
          if ( byte_1042CE68 || (LOBYTE(v1) = sub_1002D390(209), (_BYTE)v1) )
          {
            byte_1042CE68 = 0;
            LOBYTE(v1) = sub_1002D440(209);
          }
        }
      }
      return v1;
    }
    LOBYTE(v1) = sub_100144B0(316, (int)&byte_10A08A80, &v14);
    if ( !(_BYTE)v1 )
      return v1;
    v2 = dword_1042CE6C;
    v1 = 0;
    v3 = &v17;
    while ( *(_BYTE *)(v2 + v1 + 76) == 1 )
    {
      if ( *v3 == 2 )
      {
        *(_BYTE *)(v2 + v1 + 76) = 2;
LABEL_41:
        v2 = dword_1042CE6C;
      }
LABEL_42:
      ++v1;
      v3 += 20;
      if ( v1 >= 32 )
      {
        if ( v15 == 4 )
        {
          LOBYTE(v1) = sub_1002D390(212);
          if ( !(_BYTE)v1 )
          {
            LOBYTE(v1) = sub_100211E0();
            if ( !(_BYTE)v1 )
              LOBYTE(v1) = sub_10028BC0(
                             "..\\lib\\acl\\iop\\gdl59\\iop_gdl59.c",
                             561,
                             0,
                             "Failed to clear GFDS registration data on auth failure.");
          }
        }
        return v1;
      }
    }
    if ( *(_BYTE *)(v2 + v1 + 76) != 2 || *v3 == 2 )
      goto LABEL_42;
    *(_BYTE *)(v2 + v1 + 76) = 0;
    goto LABEL_41;
  }
  if ( (signed int)a1 <= 366 )
  {
    if ( a1 == 366 )
    {
      if ( sub_100144B0(366, (int)&byte_10A08A80, &v14) )
      {
        LOBYTE(v1) = v14;
        if ( (_BYTE)v14 == 2 )
        {
          LOBYTE(v1) = sub_1002D440(210);
          return v1;
        }
        if ( (_BYTE)v14 != 1 )
          return v1;
      }
      LOBYTE(v1) = sub_1002D390(208);
      if ( !(_BYTE)v1 )
      {
        LOBYTE(v1) = sub_1002D390(260);
        if ( !(_BYTE)v1 )
        {
          LOBYTE(v1) = sub_1002D390(209);
          if ( !(_BYTE)v1 )
          {
            sub_1002D550(0xD2u);
            LOBYTE(v1) = sub_1002D440(211);
          }
        }
      }
    }
    else if ( a1 == 362 && !byte_1042CE6A )
    {
      sub_10060A60(95, 300);
      *(_BYTE *)dword_1042CE6C = sub_100144B0(362, (int)&byte_10A08A80, (void *)(dword_1042CE6C + 108));
      LOBYTE(v1) = sub_10060A00(95);
    }
    return v1;
  }
  if ( (signed int)a1 > 371 )
  {
    if ( a1 == 671 )
    {
      sub_100144B0(671, (int)&byte_10A08A80, &byte_1042E4B8);
      LOBYTE(v1) = sub_10013C10(369, 0x8000, (int)&byte_10A08A80);
    }
    return v1;
  }
  if ( a1 == 371 )
  {
    LOBYTE(v1) = sub_10008E80();
    if ( byte_1042CE69 )
    {
      LOBYTE(v1) = sub_10008F70();
      if ( (_BYTE)v1 )
      {
        byte_1042CE69 = 0;
        LOBYTE(v1) = sub_10013C10(369, 0x8000, (int)&byte_10A08A80);
      }
    }
    return v1;
  }
  if ( a1 == 368 )
  {
    sub_10060A60(95, 300);
    v11 = sub_100144B0(368, (int)&byte_10A08A80, &v14);
    v12 = dword_1042CE6C + 1396;
    *(_QWORD *)v12 = *(__int64 *)((char *)&v14 + 1);
    *(_DWORD *)(v12 + 8) = v16;
    *(_BYTE *)(dword_1042CE6C + 2) = v11;
    LOBYTE(v1) = sub_10060A00(95);
    return v1;
  }
  LOBYTE(v1) = a1 - 114;
  if ( a1 == 370 )
  {
    sub_10060A60(95, 300);
    sub_100144B0(370, (int)&byte_10A08A80, (void *)(dword_1042CE6C + 1408));
    v6 = sub_1002C660(v5);
    v8 = j_HWM_pvg_hsdb_get_lrus_online(v7);
    v9 = (v8 & 4) == 4;
    v10 = (v8 & 1) == 1;
    if ( v6 != 4 )
    {
      if ( v6 == 1 )
      {
        if ( v9 )
        {
          LOBYTE(v1) = sub_10060A00(95);
          return v1;
        }
      }
      else if ( v6 != 2 || v9 || v10 )
      {
        goto LABEL_75;
      }
    }
    if ( sub_10008F70() )
    {
      sub_10013C10(369, 0x8000, (int)&byte_10A08A80);
      LOBYTE(v1) = sub_10060A00(95);
      return v1;
    }
    byte_1042CE69 = 1;
LABEL_75:
    LOBYTE(v1) = sub_10060A00(95);
  }
  return v1;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 1042CE68: using guessed type char byte_1042CE68;
// 1042CE69: using guessed type char byte_1042CE69;
// 1042CE6A: using guessed type char byte_1042CE6A;
// 1042CE6C: using guessed type int dword_1042CE6C;
// 1042E4B8: using guessed type char byte_1042E4B8;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10009C10) --------------------------------------------------------
char __thiscall sub_10009C10(void *this)
{
  char result; // al@2
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( sub_10015AC0(2, 365, (char *)&v2 + 3) == 1 )
    result = BYTE3(v2);
  else
    result = 0;
  return result;
}

//----- (10009C40) --------------------------------------------------------
char __cdecl sub_10009C40(char a1)
{
  int v2; // [sp+0h] [bp-Ch]@1
  char v3; // [sp+4h] [bp-8h]@1

  v2 = 0;
  LOWORD(v2) = -32707;
  v3 = a1;
  return sub_1002CC50((int)&v2);
}

//----- (10009C90) --------------------------------------------------------
char __cdecl sub_10009C90(void *a1)
{
  int v1; // ecx@0
  void *v2; // ecx@1
  void *v3; // ecx@2
  char v5; // [sp+8h] [bp+4h]@2

  v2 = (void *)((unsigned int)a1 & j_HWM_pvg_hsdb_get_lrus_online(v1));
  if ( v2 != a1 )
    return 0;
  v5 = sub_1002C5E0(v2);
  if ( sub_10009C10(v3) != v5 )
  {
    sub_10009C40(v5);
    return 0;
  }
  return 1;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);

//----- (10009CD0) --------------------------------------------------------
char __cdecl sub_10009CD0(void *a1, int a2, int a3, __int16 a4)
{
  int v4; // ecx@0
  void *v5; // ecx@1
  char v6; // bl@5
  char result; // al@8

  v5 = (void *)((unsigned int)a1 & j_HWM_pvg_hsdb_get_lrus_online(v4));
  if ( v5 == a1 )
  {
    if ( a4 == 41 || a4 == 42 || a4 == 43 || (v6 = 16, a4 == 44) )
      v6 = 2;
    if ( sub_10009C10(v5) == v6 )
    {
      result = 1;
    }
    else
    {
      sub_10009C40(v6);
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);

//----- (10009D30) --------------------------------------------------------
char __cdecl sub_10009D30(int a1, int a2)
{
  char result; // al@1
  char v3; // [sp+0h] [bp-524h]@4
  char v4; // [sp+68h] [bp-4BCh]@3

  result = a2;
  if ( (unsigned __int16)a1 == 62 )
  {
    sub_100144B0(a1, a2, &v3);
    result = sub_100176E0(dword_109FFDCC + 436, 1, (int)&v3, 0);
  }
  else if ( (unsigned __int16)a1 == 94 )
  {
    sub_100144B0(a1, a2, &v4);
    result = sub_100176E0(dword_109FFDCC + 436, 1, (int)&v4, 1);
  }
  return result;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (10009DC0) --------------------------------------------------------
char __cdecl sub_10009DC0(__int16 a1)
{
  char result; // al@2
  __int16 v2; // [sp+0h] [bp-10h]@1
  __int16 v3; // [sp+2h] [bp-Eh]@1
  int v4; // [sp+4h] [bp-Ch]@2

  v2 = -32760;
  v3 = a1;
  if ( a1 != 5 || (result = sub_10015AC0(2, 5, &v4)) != 0 && (result = sub_1001E640(v4, 0)) != 0 )
    result = sub_10060AC0(48, (int)&v2, 2, 1);
  return result;
}

//----- (10009E30) --------------------------------------------------------
char __cdecl sub_10009E30(int a1, int a2)
{
  unsigned __int8 v2; // al@1
  char v3; // t1@1
  int v4; // ebp@1
  int v5; // ebx@1
  char *v6; // ecx@1
  int v7; // eax@1
  char v8; // dl@2
  char *v9; // eax@3
  char v10; // cl@4
  char *v11; // eax@5
  char v12; // cl@6
  char v13; // al@7
  int v14; // ecx@8
  char *v15; // eax@12
  int v16; // edx@15
  int v17; // edx@15
  char v18; // cl@16

  v2 = *(_BYTE *)(a1 + 1);
  *(_BYTE *)(a2 + 34) = v2;
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 16);
  v3 = *(_BYTE *)(a1 + 20);
  *(_BYTE *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 17) = *(_DWORD *)(a1 + 21);
  v4 = a2 + 17;
  *(_DWORD *)(v4 + 4) = *(_DWORD *)(a1 + 25);
  v5 = v2;
  *(_DWORD *)(v4 + 8) = *(_DWORD *)(a1 + 29);
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a1 + 33);
  *(_BYTE *)(v4 + 16) = *(_BYTE *)(a1 + 37);
  *(_BYTE *)(a2 + 33) = 0;
  v6 = (char *)(v2 + a2 + 16 * v2 + 10057);
  v7 = a2 + 35 - 17 * v2 - a2 - 10057;
  do
  {
    v8 = *v6;
    v6[v7] = *v6;
    ++v6;
  }
  while ( v8 );
  v9 = (char *)a2;
  do
    v10 = *v9++;
  while ( v10 );
  sub_1000CA30((char *)a2, (_BYTE)v9 - (a2 + 1));
  v11 = (char *)(a2 + 17);
  do
    v12 = *v11++;
  while ( v12 );
  sub_1000CA30((char *)(a2 + 17), (_BYTE)v11 - (a2 + 18));
  v13 = *(_BYTE *)(dword_10A08A60 + 15485);
  if ( v13
    && ((v14 = 39 * v5 + a2, *(_BYTE *)(v14 + 74) == v13)
     || *(_BYTE *)(v14 + 75) == v13
     || *(_BYTE *)(v14 + 76) == v13
     || *(_BYTE *)(v14 + 77) == v13) )
  {
    LOBYTE(v15) = *(_BYTE *)(a2 + 15485);
  }
  else
  {
    LOBYTE(v15) = *(_BYTE *)(a1 + 3);
  }
  *(_BYTE *)(a2 + 52) = (_BYTE)v15;
  *(_BYTE *)(a2 + 53) = 0;
  if ( (unsigned __int8)v15 <= 0x1Fu )
  {
    v16 = a2 + 53 - 17 * (unsigned __int8)v15 - a2;
    v15 = (char *)((unsigned __int8)v15 + a2 + 16 * (unsigned __int8)v15 + 14668);
    v17 = v16 - 14668;
    do
    {
      v18 = *v15;
      v15[v17] = *v15;
      ++v15;
    }
    while ( v18 );
  }
  return (unsigned int)v15;
}
// 10A08A60: using guessed type int dword_10A08A60;

//----- (10009F80) --------------------------------------------------------
char __cdecl sub_10009F80(int a1, int a2)
{
  unsigned __int8 v2; // cl@1
  int v3; // ebx@1
  int v4; // ebp@1
  int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // esi@2
  int v8; // eax@3
  signed int v9; // ecx@3
  char *v10; // edi@5
  void *v11; // esi@5
  signed int v12; // ebx@5
  _BYTE *v13; // ecx@7
  signed int v14; // edx@7
  unsigned __int8 v15; // bl@12
  unsigned __int8 v16; // dl@13
  char v18; // [sp+13h] [bp-19h]@13
  int v19; // [sp+14h] [bp-18h]@1
  char v20[7]; // [sp+18h] [bp-14h]@5
  char v21[9]; // [sp+1Fh] [bp-Dh]@2

  *(_WORD *)(a2 + 15525) = *(_WORD *)a1;
  v2 = *(_BYTE *)(a1 + 2);
  *(_BYTE *)(a2 + 15527) = v2;
  v3 = *(_BYTE *)(a2 + 15526);
  v4 = v2;
  v5 = 0;
  v19 = a2;
  v6 = 8;
  do
  {
    v7 = 1 << v5++;
    *((_BYTE *)&v19 + v5 + 3) = (v3 & v7) / v7;
    --v6;
    v21[v5] = (v4 & v7) / v7;
  }
  while ( v6 );
  v8 = 600;
  v9 = 28;
  do
  {
    *(_BYTE *)(v8 + dword_109FFDCC) = 0;
    v8 += 20;
    --v9;
  }
  while ( v9 );
  v10 = v20;
  v11 = &unk_100884C0;
  v12 = 9;
  do
  {
    if ( *v10 == 1 )
    {
      v13 = v11;
      v14 = 16;
      do
      {
        LOBYTE(v8) = *v13;
        if ( *v13 != -1 )
        {
          v8 = 5 * ((unsigned __int8)v8 + 30);
          *(_BYTE *)(dword_109FFDCC + 4 * v8) = 1;
        }
        ++v13;
        --v14;
      }
      while ( v14 );
    }
    ++v10;
    v11 = (char *)v11 + 16;
    --v12;
  }
  while ( v12 );
  v15 = 0;
  while ( 2 )
  {
    v16 = 0;
    v18 = 1;
    while ( v18 )
    {
      LOBYTE(v8) = v20[v16];
      if ( (_BYTE)v8 != *(&byte_10088468[8 * v15] + v15 + v16) )
        v18 = 0;
      if ( ++v16 >= 9u )
      {
        if ( v18 )
        {
          *(_BYTE *)(v19 + 15528) = v15;
          return v8;
        }
        break;
      }
    }
    if ( ++v15 < 9u )
      continue;
    break;
  }
  *(_BYTE *)(v19 + 15528) = v15;
  return v8;
}
// 109FFDCC: using guessed type int dword_109FFDCC;
// 10009F80: using guessed type char var_D[9];
// 10009F80: using guessed type char var_14[7];

//----- (1000A0D0) --------------------------------------------------------
void *__cdecl sub_1000A0D0(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // eax@2
  int v6; // ebp@2
  char *v7; // esi@2
  char *v8; // eax@2
  char v9; // di@2
  char v10; // cl@3
  char *v11; // eax@4
  char v12; // cl@5
  int v14; // [sp+Ch] [bp+8h]@1

  v2 = a2;
  *(_BYTE *)(a2 + 73) = 0;
  *(_BYTE *)(a2 + 74) = 0;
  *(_BYTE *)(a2 + 75) = 0;
  *(_BYTE *)(a2 + 76) = 0;
  *(_BYTE *)(a2 + 77) = 0;
  *(_DWORD *)(a2 + 78) = 1229209938;
  v3 = *(_DWORD *)(a2 + 15515);
  *(_DWORD *)(a2 + 82) = 1145643087;
  v4 = *(_DWORD *)(a2 + 15519);
  *(_WORD *)(a2 + 86) = 58;
  *(_DWORD *)(a2 + 95) = v3;
  *(_DWORD *)(a2 + 99) = v4;
  *(_BYTE *)(a2 + 103) = 0;
  v14 = 0;
  if ( *(_BYTE *)(a1 + 1) )
  {
    do
    {
      v5 = *(_BYTE *)(39 * (unsigned __int16)v14 + a1 + 2);
      v6 = 39 * v5 + v2;
      qmemcpy((void *)(v6 + 73), (const void *)(39 * (unsigned __int16)v14 + a1 + 2), 0x27u);
      v7 = (char *)(39 * (v5 + 2) + v2);
      v8 = (char *)(39 * (v5 + 2) + v2);
      *(_BYTE *)(v6 + 94) = 0;
      *(_BYTE *)(v6 + 111) = 0;
      v9 = (_BYTE)v8 + 1;
      do
        v10 = *v8++;
      while ( v10 );
      sub_1000CA30(v7, (_BYTE)v8 - v9);
      v11 = (char *)(v6 + 95);
      do
        v12 = *v11++;
      while ( v12 );
      sub_1000CA30((char *)(v6 + 95), (_BYTE)v11 - (v6 + 96));
      ++v14;
    }
    while ( (unsigned __int16)v14 < *(_BYTE *)(a1 + 1) );
  }
  return sub_1000C900(v2);
}

//----- (1000A1D0) --------------------------------------------------------
int __cdecl sub_1000A1D0(int a1)
{
  int result; // eax@1

  result = a1;
  qmemcpy((void *)(dword_10A08A60 + 15530), (const void *)a1, 0x48u);
  qmemcpy((void *)(dword_10A08A60 + 15602), (const void *)(a1 + 72), 0x48u);
  return result;
}
// 10A08A60: using guessed type int dword_10A08A60;

//----- (1000A210) --------------------------------------------------------
int __cdecl sub_1000A210(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(a2 + 15491) = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 15495) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 15499) = *(_DWORD *)(a1 + 8);
  *(_WORD *)(a2 + 15503) = *(_WORD *)(a1 + 12);
  *(_BYTE *)(a2 + 15505) = *(_BYTE *)(a1 + 14);
  return result;
}

//----- (1000A250) --------------------------------------------------------
char __cdecl sub_1000A250(int a1, int a2)
{
  _BYTE *v2; // ebx@1
  char result; // al@1
  int v4; // ecx@3
  int v5; // eax@4
  int v6; // edx@4
  int v7; // esi@4
  _BYTE *v8; // eax@5
  signed int v9; // ecx@5
  unsigned __int8 v10; // al@7
  signed int v11; // esi@7
  char v12; // cl@8
  signed int v13; // edx@8
  int v14; // edi@9

  v2 = (_BYTE *)a1;
  result = *(_BYTE *)(a1 + 560);
  if ( (signed int)*(_BYTE *)(a1 + 560) <= 256 && *(_BYTE *)(a1 + 32) <= 0x1Fu )
  {
    v4 = 0;
    if ( result )
    {
      do
      {
        v5 = a1 + 18 * (unsigned __int16)v4;
        v6 = a2 + 16 * *(_BYTE *)(v5 + 561) + *(_BYTE *)(v5 + 561);
        v7 = *(_DWORD *)(v5 + 562);
        v5 += 562;
        *(_DWORD *)(v6 + 10057) = v7;
        *(_DWORD *)(v6 + 10061) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(v6 + 10065) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v6 + 10069) = *(_DWORD *)(v5 + 12);
        *(_BYTE *)(v6 + 10073) = 0;
        ++v4;
      }
      while ( (unsigned __int16)v4 < *(_BYTE *)(a1 + 560) );
    }
    *(_BYTE *)(a2 + 10057) = 0;
    *(_DWORD *)(a2 + 14668) = 543976513;
    *(_DWORD *)(a2 + 14672) = 1702125891;
    *(_DWORD *)(a2 + 14676) = 1769107303;
    *(_WORD *)(a2 + 14680) = 29541;
    *(_BYTE *)(a2 + 14682) = 0;
    qmemcpy((void *)(a2 + 14685), (const void *)(a1 + 33), 0x20Fu);
    v8 = (_BYTE *)(a2 + 14684);
    v9 = 31;
    do
    {
      *v8 = 0;
      v8 += 17;
      --v9;
    }
    while ( v9 );
    sub_1000C830(a2);
    v10 = 0;
    v11 = 32;
    do
    {
      v12 = 1;
      v13 = 8;
      do
      {
        v14 = 39 * v10;
        if ( (unsigned __int8)v12 & *v2 )
          *(_BYTE *)(v14 + a2 + 73) = v10;
        else
          *(_BYTE *)(v14 + a2 + 73) = 0;
        v12 *= 2;
        ++v10;
        --v13;
      }
      while ( v13 );
      ++v2;
      --v11;
    }
    while ( v11 );
    result = (unsigned int)sub_1000C900(a2);
  }
  return result;
}

//----- (1000A3A0) --------------------------------------------------------
int __cdecl sub_1000A3A0(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(a2 + 15506) = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 15510) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 15514) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 15518) = *(_DWORD *)(a1 + 12);
  *(_WORD *)(a2 + 15522) = *(_WORD *)(a1 + 16);
  *(_BYTE *)(a2 + 15524) = *(_BYTE *)(a1 + 18);
  return result;
}

//----- (1000A3E0) --------------------------------------------------------
char sub_1000A3E0()
{
  char v1; // [sp+Bh] [bp-1h]@1

  v1 = 0;
  return sub_1001EA70(&v1, 269, 0, 1, 1);
}

//----- (1000A410) --------------------------------------------------------
char __cdecl sub_1000A410(char a1, char a2, char a3)
{
  __int16 v4; // [sp+8h] [bp-4h]@1
  char v5; // [sp+Ah] [bp-2h]@1

  LOBYTE(v4) = a1;
  HIBYTE(v4) = a2;
  v5 = a3;
  return sub_1001EA70(&v4, 249, 0, 3, 1);
}

//----- (1000A460) --------------------------------------------------------
char __cdecl sub_1000A460(char a1, char a2, char a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  LOBYTE(v5) = a1;
  BYTE1(v5) = a2;
  BYTE2(v5) = a3;
  if ( !a2 )
    BYTE1(v5) = 1;
  return sub_1001EA70(&v5, 138, 0, 3, 1);
}

//----- (1000A4B0) --------------------------------------------------------
char sub_1000A4B0()
{
  char v1; // [sp+Bh] [bp-1h]@1

  v1 = 0;
  return sub_1001EA70(&v1, 286, 0, 1, 1);
}

//----- (1000A4E0) --------------------------------------------------------
char __cdecl sub_1000A4E0(char a1)
{
  return sub_1001EA70(&a1, 276, 0, 1, 1);
}

//----- (1000A510) --------------------------------------------------------
char sub_1000A510()
{
  char v1; // [sp+Bh] [bp-1h]@1

  v1 = 0;
  return sub_1001EA70(&v1, 270, 0, 1, 1);
}

//----- (1000A540) --------------------------------------------------------
char __cdecl sub_1000A540(bool a1)
{
  a1 = a1 != 0;
  return sub_1001EA70(&a1, 265, 0, 1, 1);
}

//----- (1000A570) --------------------------------------------------------
char sub_1000A570()
{
  char v1; // [sp+Bh] [bp-1h]@1

  v1 = 0;
  return sub_1001EA70(&v1, 272, 0, 1, 1);
}

//----- (1000A5A0) --------------------------------------------------------
char __cdecl sub_1000A5A0(char a1)
{
  return sub_1001EA70(&a1, 288, 0, 1, 1);
}

//----- (1000A5D0) --------------------------------------------------------
char __cdecl sub_1000A5D0(__int16 a1, char a2)
{
  HIBYTE(a1) = a2;
  return sub_1001EA70(&a1, 274, 0, 2, 1);
}

//----- (1000A600) --------------------------------------------------------
char sub_1000A600()
{
  char v1; // [sp+Bh] [bp-1h]@1

  v1 = 0;
  return sub_1001EA70(&v1, 258, 0, 1, 1);
}

//----- (1000A630) --------------------------------------------------------
char __cdecl sub_1000A630(char a1)
{
  return sub_1001EA70(&a1, 285, 0, 1, 1);
}

//----- (1000A660) --------------------------------------------------------
char sub_1000A660()
{
  char v1; // [sp+Bh] [bp-1h]@1

  v1 = 0;
  return sub_1001EA70(&v1, 275, 0, 1, 1);
}

//----- (1000A690) --------------------------------------------------------
char sub_1000A690()
{
  char v1; // [sp+Bh] [bp-1h]@1

  v1 = 0;
  return sub_1001EA70(&v1, 260, 0, 1, 1);
}

//----- (1000A6C0) --------------------------------------------------------
char __cdecl sub_1000A6C0(char a1)
{
  return sub_1001EA70(&a1, 263, 0, 1, 1);
}

//----- (1000A6F0) --------------------------------------------------------
char __cdecl sub_1000A6F0(int a1, int a2)
{
  char result; // al@1
  bool v3; // zf@1

  result = a2;
  v3 = *(_BYTE *)(a2 + 15487) == 2;
  *(_WORD *)(a2 + 15488) = *(_BYTE *)a1;
  if ( !v3 )
  {
    if ( *(_BYTE *)(a1 + 2) )
    {
      *(_BYTE *)(a2 + 15487) = 1;
      result = sub_10033570();
      if ( result )
      {
        sub_1000A540(0);
        result = sub_1000A6C0(-1);
      }
    }
    else
    {
      *(_BYTE *)(a2 + 15487) = 0;
    }
  }
  return result;
}

//----- (1000A740) --------------------------------------------------------
char sub_1000A740()
{
  int v0; // esi@1
  int v1; // edi@3
  char v2; // dl@3
  signed __int16 v3; // ax@3
  unsigned __int8 v4; // cl@3
  signed __int16 v5; // bp@3
  char v6; // bl@4
  int v7; // esi@8
  int v8; // esi@13
  size_t v9; // esi@13
  bool v10; // cf@13
  char result; // al@14
  char v12; // [sp+13h] [bp-D1h]@1
  unsigned __int16 v13; // [sp+14h] [bp-D0h]@1
  int v14; // [sp+18h] [bp-CCh]@1
  char *v15; // [sp+1Ch] [bp-C8h]@1
  char v16; // [sp+20h] [bp-C4h]@8
  char v17; // [sp+21h] [bp-C3h]@8
  char v18[190]; // [sp+22h] [bp-C2h]@8

  v0 = dword_109FFDCC + 1813638;
  v14 = dword_109FFDCC + 1813638;
  v15 = (char *)(dword_109FFDCC + 1813638);
  v12 = 1;
  v13 = 0;
  while ( 2 )
  {
    v1 = 1200 * v13;
    v2 = *(_BYTE *)(v1 + v0);
    v3 = 1;
    v4 = 0;
    v5 = 1;
    while ( 1 )
    {
      v6 = *(_BYTE *)(v1 + (unsigned __int16)v5 + v0);
      if ( v6 != v2 || (unsigned __int16)v3 >= 0x4Bu )
        break;
      ++v3;
LABEL_9:
      if ( (unsigned __int16)++v5 >= 0x4B0u )
        goto LABEL_12;
    }
    if ( v4 < 0x40u )
    {
      v7 = 3 * v4;
      v18[v7] = v2;
      *(&v16 + v7) = v3;
      *(&v17 + v7) = HIBYTE(v3);
      v0 = v14;
      ++v4;
      v2 = v6;
      v3 = 1;
      goto LABEL_9;
    }
    v12 = 0;
LABEL_12:
    if ( v4 >= 0x40u )
    {
      result = 0;
    }
    else
    {
      v8 = 3 * v4;
      *(&v16 + v8) = v3;
      *(&v17 + v8) = HIBYTE(v3);
      v18[v8] = v2;
      v9 = 3 * (unsigned __int8)(v4 + 1);
      memcpy(v15, &v16, v9);
      v10 = (unsigned __int16)(v13 + 1) < 0x1C5u;
      v15 += v9;
      ++v13;
      if ( v10 )
      {
        v0 = v14;
        continue;
      }
      result = v12;
    }
    return result;
  }
}
// 109FFDCC: using guessed type int dword_109FFDCC;
// 1000A740: using guessed type char var_C2[190];

//----- (1000A860) --------------------------------------------------------
char __usercall sub_1000A860@<al>(unsigned __int16 a1@<ax>, int a2, int a3, unsigned __int16 a4, int a5)
{
  int v5; // ebx@1
  __int16 v6; // bp@5
  __int16 v7; // bx@8
  __int16 v8; // ax@11
  int v10; // [sp+10h] [bp-10h]@1
  int v11; // [sp+14h] [bp-Ch]@1
  int v12; // [sp+18h] [bp-8h]@2

  v5 = 11930464 * (90 - a1);
  sub_10067E30(11930464 * (90 - a1), &v10, &v11);
  if ( v11 >= 0 )
    LOWORD(v12) = a3 + ((unsigned __int64)(v11 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  else
    LOWORD(v12) = a3 - ((unsigned __int64)(-v11 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  if ( -v10 >= 0 )
  {
    v6 = HIWORD(a3);
    HIWORD(v12) = HIWORD(a3) + ((unsigned __int64)(-v10 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  }
  else
  {
    --v10;
    v6 = HIWORD(a3);
    HIWORD(v12) = HIWORD(a3) - ((unsigned __int64)(v10 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  }
  sub_10064D20(a2, v12, SHIWORD(v12), 2);
  sub_10067E30(v5 + 11930464, &v10, &v11);
  if ( v11 >= 0 )
    v7 = a3 + ((unsigned __int64)(v11 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  else
    v7 = a3 - ((unsigned __int64)(-v11 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  if ( -v10 >= 0 )
    v8 = v6 + ((unsigned __int64)(-v10 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  else
    v8 = v6 - ((unsigned __int64)(--v10 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  *(_WORD *)(a2 + 44) = v8;
  *(_WORD *)(a2 + 46) = v7;
  sub_10067E30(11930464 * (89 - a4), &v10, &v11);
  if ( v11 >= 0 )
    LOWORD(v12) = a3 + ((unsigned __int64)(v11 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  else
    LOWORD(v12) = a3 - ((unsigned __int64)(-v11 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  if ( -v10 >= 0 )
    HIWORD(v12) = v6 + ((unsigned __int64)(-v10 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  else
    HIWORD(v12) = v6 - ((unsigned __int64)(--v10 * (signed __int64)a5 + 0x3FFFFFFF) >> 31);
  return sub_10063580(a2, a3, v6, a5, 1, v12, SHIWORD(v12));
}

//----- (1000AB20) --------------------------------------------------------
char __usercall sub_1000AB20@<al>(__int16 a1@<ax>, __int16 a2@<cx>, int a3)
{
  return *(_BYTE *)(a2 + a3 + 59 * a1);
}

//----- (1000AB40) --------------------------------------------------------
int __cdecl sub_1000AB40(int a1, int a2, unsigned int a3, unsigned int a4, char a5, char a6)
{
  signed __int16 v6; // cx@0
  int v7; // ebx@1
  unsigned int v8; // edx@1
  unsigned int v9; // edi@1
  int v10; // eax@1
  __int16 *v11; // esi@1
  int result; // eax@3
  int v13; // ecx@13
  signed __int16 v14; // bp@13
  __int16 v15; // dx@13
  __int16 v16; // ax@13
  __int16 v17; // di@13
  __int16 v18; // dx@13
  int v19; // ecx@15
  int v20; // eax@19
  int v21; // ecx@25
  int v22; // eax@28
  int v23; // eax@33
  __int16 v24; // [sp+10h] [bp-14h]@13
  __int16 v25; // [sp+14h] [bp-10h]@17
  int v26; // [sp+2Ch] [bp+8h]@13

  v7 = a1;
  v8 = a3 >> 16;
  v9 = a4 >> 16;
  v10 = v6 + 1;
  v11 = &word_1042ED88;
  if ( v10 < SHIWORD(a3) || v10 > (signed __int16)v9 )
  {
    result = a2;
  }
  else
  {
    result = a2;
    word_1042ED88 = v6;
    word_1042ED8A = a2;
    word_1042ED8C = a2;
    word_1042ED8E = 1;
    v11 = (__int16 *)&unk_1042ED90;
  }
  if ( v6 >= (signed __int16)v8 && v6 <= (signed __int16)v9 )
  {
    *v11 = v6 + 1;
    v11[1] = result;
    v11[2] = result;
    v11[3] = -1;
    v11 += 4;
  }
  if ( (signed __int16)result >= (signed __int16)a3
    && (signed __int16)result <= (signed __int16)a4
    && v6 >= (signed __int16)v8
    && v6 <= (signed __int16)v9 )
  {
    while ( v11 > &word_1042ED88 )
    {
      v13 = (unsigned __int16)*(v11 - 1);
      v14 = *(v11 - 3);
      v15 = *(v11 - 2);
      v16 = *(v11 - 4);
      v11 -= 4;
      v24 = v15;
      v26 = v13;
      v17 = v13 + v16;
      v18 = v14;
      if ( v14 >= (signed __int16)a3 )
      {
        do
        {
          if ( sub_1000AB20(v17, v18, v7) != a5 )
            break;
          v19 = v18--;
          *(_BYTE *)(v19 + v7 + 59 * v17) = a6;
          v7 = a1;
        }
        while ( v18 >= (signed __int16)a3 );
        if ( v18 < v14 )
        {
          v25 = v18 + 1;
          if ( (signed __int16)(v18 + 1) < v14 && v11 < (__int16 *)&unk_104389C8 )
          {
            v20 = v17 - (signed __int16)v26;
            if ( v20 >= SHIWORD(a3) && v20 <= SHIWORD(a4) )
            {
              *v11 = v17;
              v11[1] = v25;
              v11[2] = v14 - 1;
              v11[3] = -(signed __int16)v26;
              v11 += 4;
            }
          }
          LOWORD(v13) = v26;
          v18 = v14 + 1;
          goto LABEL_23;
        }
        LOWORD(v13) = v26;
      }
      while ( 1 )
      {
        if ( ++v18 <= v24 )
        {
          do
          {
            if ( sub_1000AB20(v17, v18, v7) == a5 )
              break;
            ++v18;
          }
          while ( v18 <= v24 );
          LOWORD(v13) = v26;
        }
        result = (unsigned __int16)v18;
        v25 = v18;
        if ( v18 > v24 )
          break;
LABEL_23:
        if ( v18 <= (signed __int16)a4 )
        {
          do
          {
            if ( sub_1000AB20(v17, v18, v7) != a5 )
              break;
            v21 = v18++;
            *(_BYTE *)(v21 + v7 + 59 * v17) = a6;
          }
          while ( v18 <= (signed __int16)a4 );
          LOWORD(v13) = v26;
        }
        if ( v11 < (__int16 *)&unk_104389C8 )
        {
          v22 = v17 + (signed __int16)v13;
          if ( v22 >= SHIWORD(a3) && v22 <= SHIWORD(a4) )
          {
            v11[1] = v25;
            *v11 = v17;
            v11[2] = v18 - 1;
            v11[3] = v13;
            v11 += 4;
          }
        }
        if ( v18 > v24 + 1 && v11 < (__int16 *)&unk_104389C8 )
        {
          v23 = v17 - (signed __int16)v13;
          if ( v23 >= SHIWORD(a3) && v23 <= SHIWORD(a4) )
          {
            v11[1] = v24 + 1;
            v11[2] = v18 - 1;
            *v11 = v17;
            v11[3] = -(signed __int16)v13;
            v11 += 4;
          }
        }
      }
    }
  }
  return result;
}
// 1042ED88: using guessed type __int16 word_1042ED88;
// 1042ED8A: using guessed type __int16 word_1042ED8A;
// 1042ED8C: using guessed type __int16 word_1042ED8C;
// 1042ED8E: using guessed type __int16 word_1042ED8E;

//----- (1000ADF0) --------------------------------------------------------
int __usercall sub_1000ADF0@<eax>(int a1@<edi>, int a2, int a3, int a4, unsigned int a5, int a6, int a7)
{
  int v7; // esi@1
  unsigned __int16 v8; // bp@1
  unsigned int v9; // ebx@1
  int result; // eax@2
  int v11; // eax@7
  int v12; // esi@8
  signed int v13; // eax@12
  signed int v14; // eax@16
  unsigned __int8 v15; // [sp+Fh] [bp-21h]@6

  v7 = a7;
  v8 = 0;
  v9 = a5 / 5;
  if ( a5 )
  {
    memset(&unk_104389C8, 11, 0xD99u);
    if ( *(_WORD *)a7 )
      *(_WORD *)(a1 + 44) = 2;
    else
      *(_WORD *)(a1 + 44) = 29 - 7408 * *(_BYTE *)(a7 + 4) / 33392;
    *(_WORD *)(a1 + 46) = 29;
    v15 = 0;
    if ( v9 )
    {
      v11 = 0;
      do
      {
        v12 = v11 + v7 + 4 * v11;
        if ( v8 != *(_WORD *)v12 )
          sub_1000A860(v8, a1, 1900573, *(_WORD *)v12, 27);
        if ( *(_WORD *)(v12 + 2) == 360 )
          *(_WORD *)(v12 + 2) = 359;
        v13 = 7408 * *(_BYTE *)(v12 + 4) / 33392;
        if ( v13 < 2 )
          v13 = 2;
        sub_1000A860(*(_WORD *)v12, a1, 1900573, *(_WORD *)(v12 + 2), v13);
        v8 = *(_WORD *)(v12 + 2);
        v7 = a7;
        v11 = ++v15;
      }
      while ( v15 < v9 );
    }
    if ( *(_WORD *)v7 )
      v14 = 27;
    else
      v14 = 7408 * *(_BYTE *)(v7 + 4) / 33392;
    sub_1000A860(v8, a1, 1900573, 0, v14);
    result = sub_1000AB40(**(_DWORD **)(a1 + 52), 1, 0, 0x3A003Au, 11, 0);
  }
  else
  {
    result = sub_10065270(a1, 29, 29, 27);
  }
  return result;
}

//----- (1000AFE0) --------------------------------------------------------
char __usercall sub_1000AFE0@<al>(unsigned __int8 a1@<al>, char a2)
{
  unsigned __int8 v2; // bl@1
  unsigned __int16 v3; // ax@2
  int v4; // ebx@6
  int v5; // ecx@6
  int v6; // edi@6
  int v7; // esi@7
  int v8; // edi@9
  unsigned int v9; // eax@9
  int v10; // ebx@9
  signed __int64 v11; // rax@9
  __int64 v12; // kr00_8@9
  int v13; // ecx@9
  int v14; // edx@11
  int v15; // eax@11
  int v16; // ebx@12
  int v17; // ebx@18
  char *v18; // ebx@19
  int v19; // esi@20
  unsigned int v20; // ebp@21
  unsigned int v21; // edi@21
  int v23; // [sp+10h] [bp-88h]@19
  int v24; // [sp+14h] [bp-84h]@18
  int v25; // [sp+18h] [bp-80h]@4
  int v26; // [sp+1Ch] [bp-7Ch]@6
  int v27; // [sp+20h] [bp-78h]@19
  int v28; // [sp+24h] [bp-74h]@6
  int v29; // [sp+28h] [bp-70h]@6
  void *v30; // [sp+2Ch] [bp-6Ch]@6
  __int16 v31; // [sp+30h] [bp-68h]@6
  __int16 v32; // [sp+32h] [bp-66h]@6
  char v33; // [sp+34h] [bp-64h]@6
  char v34; // [sp+35h] [bp-63h]@6
  __int16 v35; // [sp+36h] [bp-62h]@6
  int v36; // [sp+38h] [bp-60h]@6
  int v37; // [sp+3Ch] [bp-5Ch]@6
  int v38; // [sp+40h] [bp-58h]@9
  char v39; // [sp+44h] [bp-54h]@6
  __int16 v40; // [sp+68h] [bp-30h]@6
  __int16 v41; // [sp+6Ah] [bp-2Eh]@6
  __int16 v42; // [sp+74h] [bp-24h]@6
  __int16 v43; // [sp+76h] [bp-22h]@6

  v2 = a1;
  if ( a1 == a2 || (LOBYTE(v3) = sub_1001E6F0(a1, *(_DWORD *)(dword_109FFDCC + 20 * a1 + 608), 0), (_BYTE)v3) )
  {
    v25 = v2 == 1 ? dword_109FFDCC + 1803398 : dword_109FFDCC + 5059932;
    v4 = 132 * v2;
    v5 = *(_DWORD *)(v4 + dword_109FFDCC + 1662);
    v6 = v25 + v5 + *(_DWORD *)(v4 + dword_109FFDCC + 1668);
    v26 = v4;
    v36 = v5 + v25;
    v29 = v6;
    v37 = dword_109FFDCC + 1813638;
    memset(&unk_104389C8, 0, 0xD99u);
    v31 = 59;
    v32 = 59;
    v35 = 59;
    v30 = &unk_104389C8;
    v33 = 8;
    v34 = 0;
    sub_100654D0((int)&v39, (int)&v30, 0);
    v40 = 10;
    v41 = 10;
    v42 = 10;
    v43 = 10;
    v3 = 0;
    v28 = 0;
    if ( *(_WORD *)(v25 + 3) )
    {
      do
      {
        v7 = v36 + 20 * v3;
        if ( !*(_BYTE *)(v36 + 20 * v3)
          && (unsigned int)(*(_DWORD *)(v7 + 16) + *(_DWORD *)(v7 + 12)) <= *(_DWORD *)(v4 + dword_109FFDCC + 1674) )
        {
          memset(&unk_104389C8, 0, 0xD99u);
          sub_1000ADF0(
            (int)&v39,
            *(_DWORD *)v7,
            *(_DWORD *)(v7 + 4),
            *(_DWORD *)(v7 + 8),
            *(_DWORD *)(v7 + 12),
            *(_DWORD *)(v7 + 16),
            v6 + *(_DWORD *)(v7 + 16));
          v8 = *(_DWORD *)(v7 + 4);
          v9 = (signed int)((unsigned __int64)(453i64 * (656175559 - v8) >> 8)
                          + 792257
                          + ((unsigned __int64)(-1452708011i64
                                              * (signed int)((unsigned __int64)(453i64 * (656175559 - v8) >> 8) + 792257)) >> 32)) >> 20;
          v10 = v9 + (v9 >> 31) - 27;
          v11 = 52854100028248424i64 / sub_10067ED0(v8);
          v12 = -1670265059 - *(_DWORD *)(v7 + 8);
          v38 = (signed int)((1200 * (v12 + (signed int)v11) - 0x20000000) >> 10) / -1048576;
          v13 = (signed int)((1200 * (v12 + -(signed int)v11) + 0x20000000) >> 10) / -1048576;
          if ( v13 > 1200 )
            v13 = 1200;
          v14 = 0;
          v15 = 59;
          if ( v10 < 0 )
          {
            v16 = -v10;
            v15 = 59 - v16;
            v14 = 59 * v16;
            v10 = 0;
            if ( v15 < 0 )
              v15 = 0;
          }
          if ( v15 + v10 > 453 )
          {
            if ( v10 <= 453 )
              v15 = 453 - v10;
            else
              v15 = 0;
          }
          v17 = 1200 * v10;
          v24 = v17;
          if ( v15 > 0 )
          {
            v23 = v37 + v17;
            v18 = (char *)&unk_104389C8 + v14;
            v27 = v15;
            do
            {
              v19 = v38;
              if ( v38 < v13 )
              {
                v20 = v13 - v38;
                v21 = 0;
                do
                {
                  if ( v18[v21 / v20] && (unsigned int)(v19 + v24) < 0x84B70 && (signed int)(v21 / v20) < 59 )
                    *(_BYTE *)(v23 + v19) = 11;
                  ++v19;
                  v21 += 59;
                }
                while ( v19 < v13 );
              }
              v24 += 1200;
              v23 += 1200;
              v18 += 59;
              --v27;
            }
            while ( v27 );
          }
          v4 = v26;
          v6 = v29;
        }
        v3 = v28++ + 1;
      }
      while ( (unsigned __int16)v28 < *(_WORD *)(v25 + 3) );
    }
  }
  return v3;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000B330) --------------------------------------------------------
char __cdecl sub_1000B330(char a1)
{
  memset((void *)(dword_109FFDCC + 1813638), 0, 0x84B70u);
  if ( !sub_10033580() )
  {
    sub_1000AFE0(1u, a1);
    sub_1000AFE0(0x17u, a1);
  }
  return sub_1000A740();
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000B380) --------------------------------------------------------
void *sub_1000B380()
{
  dword_10A08A60 = -15;
  dword_1093D550 = 0;
  *(_DWORD *)dword_1093D554 = 0;
  return memset(&unk_1093D5D8, 0, 0x1A0u);
}
// 1093D550: using guessed type int dword_1093D550;
// 10A08A60: using guessed type int dword_10A08A60;

//----- (1000B390) --------------------------------------------------------
int sub_1000B390()
{
  int v0; // ecx@1
  int v1; // edx@1
  int v2; // eax@1
  int v3; // esi@1
  int v4; // eax@3
  signed int v5; // eax@3
  signed int v6; // ecx@3
  int v7; // ecx@5
  int v8; // ecx@5
  int result; // eax@5

  v0 = 0;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  do
  {
    *(_DWORD *)(v3 + dword_10A08A60 + 10057) = 2960685;
    *(_DWORD *)(v2 + dword_10A08A60 + 78) = 2960685;
    *(_DWORD *)(v2 + dword_10A08A60 + 95) = 2960685;
    *(_BYTE *)(v2 + dword_10A08A60 + 73) = v0;
    *(_BYTE *)(v1 + dword_10A08A60 + 14409) = 0;
    ++v0;
    ++v1;
    v3 += 17;
    v2 += 39;
    *(_BYTE *)(dword_10A08A60 + 52) = 0;
  }
  while ( (unsigned __int16)v0 < 0x100u );
  *(_WORD *)(dword_10A08A60 + 14666) = 1;
  *(_BYTE *)(dword_10A08A60 + 15486) = 1;
  v4 = dword_10A08A60;
  *(_DWORD *)(dword_10A08A60 + 14668) = 541871169;
  v4 += 14668;
  *(_DWORD *)(v4 + 4) = 1163149635;
  *(_DWORD *)(v4 + 8) = 1230131015;
  *(_WORD *)(v4 + 12) = 21317;
  *(_BYTE *)(v4 + 14) = 0;
  v5 = 17;
  v6 = 31;
  do
  {
    *(_BYTE *)(v5 + dword_10A08A60 + 14668) = 0;
    v5 += 17;
    --v6;
  }
  while ( v6 );
  *(_WORD *)(dword_10A08A60 + 15488) = 213;
  *(_BYTE *)(dword_10A08A60 + 15487) = 1;
  *(_BYTE *)(dword_10A08A60 + 15490) = -1;
  v7 = dword_10A08A60;
  *(_DWORD *)(dword_10A08A60 + 15506) = 0;
  v7 += 15506;
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) = 0;
  *(_DWORD *)(v7 + 12) = 0;
  *(_WORD *)(v7 + 16) = 0;
  *(_BYTE *)(v7 + 18) = 0;
  v8 = dword_10A08A60 + 15525;
  *(_WORD *)v8 = 0;
  *(_BYTE *)(v8 + 2) = 0;
  result = dword_10A08A60;
  *(_BYTE *)(dword_10A08A60 + 15528) = 2;
  *(_BYTE *)(dword_10A08A60 + 15529) = 0;
  return result;
}
// 10A08A60: using guessed type int dword_10A08A60;

//----- (1000B4F0) --------------------------------------------------------
signed int sub_1000B4F0()
{
  signed int result; // eax@2

  if ( sub_10061B70((LONG)&off_10088B44) )
  {
    sub_1000B390();
    result = sub_10061700((int)&off_10088B44);
  }
  else
  {
    sub_10028BC0("..\\lib\\adl\\iop_gdl69_init.c", 140, 1, 0);
    result = sub_10061700((int)&off_10088B44);
  }
  return result;
}
// 10088B44: using guessed type char *off_10088B44;

//----- (1000B640) --------------------------------------------------------
char sub_1000B640()
{
  int v0; // esi@1
  void *v1; // ecx@1
  char result; // al@1
  char v3; // [sp+7h] [bp-41h]@8
  int v4; // [sp+8h] [bp-40h]@1
  int v5; // [sp+Ch] [bp-3Ch]@1
  int v6; // [sp+10h] [bp-38h]@1
  int v7; // [sp+14h] [bp-34h]@1
  __int16 v8; // [sp+18h] [bp-30h]@1
  char v9; // [sp+1Ah] [bp-2Eh]@1
  int v10; // [sp+1Ch] [bp-2Ch]@1
  int v11; // [sp+20h] [bp-28h]@1
  int v12; // [sp+24h] [bp-24h]@1
  int v13; // [sp+28h] [bp-20h]@1
  int v14; // [sp+2Ch] [bp-1Ch]@1
  int v15; // [sp+30h] [bp-18h]@1
  int v16; // [sp+34h] [bp-14h]@1
  int v17; // [sp+38h] [bp-10h]@1
  int v18; // [sp+3Ch] [bp-Ch]@1
  int v19; // [sp+40h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v0 = sub_10060900();
  result = sub_100336A0(v1);
  if ( result )
  {
    if ( sub_10033590(17, (int)&v4) && (result = sub_10033640(17, (int)&v10)) != 0 )
    {
      if ( *(int *)((char *)&v7 + 3) != *(int *)((char *)&v18 + 3) )
      {
        sub_1002D550(0xAAu);
        result = sub_10029A30(0x11u, 0);
      }
      byte_1043BE93 = 1;
    }
    else
    {
      result = v0 - dword_1043D3D8;
      if ( (unsigned int)(v0 - dword_1043D3D8) > 0x64 )
      {
        dword_1043D3D8 = v0;
        result = sub_100299A0(&v3);
        if ( !result || !v3 )
          result = sub_10029A00(17, 17, 0);
      }
    }
  }
  return result;
}
// 1043BE93: using guessed type char byte_1043BE93;
// 1043D3D8: using guessed type int dword_1043D3D8;

//----- (1000B750) --------------------------------------------------------
int __usercall sub_1000B750@<eax>(int result@<eax>, char a2@<bl>, char a3)
{
  int v3; // esi@3
  _BYTE *v4; // ecx@3

  if ( a2 != -1 && (unsigned __int8)result < 4u )
  {
    v3 = 109 * (unsigned __int8)result;
    *(_BYTE *)(v3 + (unsigned __int8)sub_100336C0(a2) + dword_109FFDCC) = a3;
    sub_10060ED0(dword_100899F0[(unsigned __int8)result], dword_109FFDCC + v3, 109);
    v4 = (_BYTE *)((unsigned __int8)a2 + dword_109FFDCC + 14618950);
    result = (*v4 + 1) / 255;
    *v4 = (*v4 + 1) % 255;
  }
  return result;
}
// 100899F0: using guessed type int dword_100899F0[];
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000B7C0) --------------------------------------------------------
char __usercall sub_1000B7C0@<al>(_WORD *a1@<eax>, void *a2@<ecx>)
{
  _WORD *v2; // esi@1
  int v3; // eax@1
  char v4; // bl@4
  unsigned __int8 v6; // [sp+6h] [bp-Ah]@22
  char v7; // [sp+7h] [bp-9h]@25
  int v8; // [sp+8h] [bp-8h]@11
  int v9; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  v3 = *a1;
  if ( v3 > 248 )
  {
    switch ( v3 )
    {
      case 250:
        LOBYTE(v3) = sub_10015AF0(2, 250, &unk_10439790, (int)&v8);
        if ( (_BYTE)v3 )
        {
          v3 = sub_1001C150((int)&unk_10439790);
          if ( !v3 )
          {
            LOBYTE(v3) = v8;
            if ( (unsigned __int16)v8 > 2u )
            {
              a2 = (void *)(39 * (unsigned __int8)byte_10439791);
              if ( (unsigned __int16)v8 > (unsigned int)a2 )
              {
                sub_1000A0D0((int)&unk_10439790, dword_10A08A60);
                a2 = (void *)dword_10A08A60;
                v3 = (*(_BYTE *)(dword_10A08A60 + 72) + 1) / 255;
                *(_BYTE *)(dword_10A08A60 + 72) = (*(_BYTE *)(dword_10A08A60 + 72) + 1) % 255;
              }
            }
          }
        }
        break;
      case 259:
        LOBYTE(v3) = sub_10015AF0(2, 259, &unk_1043BF90, (int)&v8);
        if ( (_BYTE)v3 )
        {
          v3 = sub_1001C1D0((int)&unk_1043BF90);
          if ( !v3 )
          {
            sub_1000A250((int)&unk_1043BF90, dword_10A08A60);
            *(_BYTE *)(dword_10A08A60 + 72) = (*(_BYTE *)(dword_10A08A60 + 72) + 1) % 255;
            a2 = (void *)dword_10A08A60;
            v3 = (*(_BYTE *)(dword_10A08A60 + 71) + 1) / 255;
            *(_BYTE *)(dword_10A08A60 + 71) = (*(_BYTE *)(dword_10A08A60 + 71) + 1) % 255;
          }
        }
        break;
      case 261:
        LOBYTE(v3) = sub_10015AC0(2, 261, &unk_1043D3DC);
        if ( (_BYTE)v3 )
        {
          v3 = sub_1001C1F0((int)&unk_1043D3DC);
          if ( !v3 )
            LOBYTE(v3) = sub_1000A3A0((int)&unk_1043D3DC, dword_10A08A60);
        }
        break;
      case 262:
        LOBYTE(v3) = sub_10015AC0(2, 262, &v6);
        if ( (_BYTE)v3 )
        {
          v3 = sub_10033B00(&v6, 0xA0u, 0xFFu, 0xA0u, 0);
          if ( !v3 )
          {
            LOBYTE(v3) = v6;
            a2 = (void *)dword_10A08A60;
            *(_WORD *)(dword_10A08A60 + 15488) = v6;
          }
        }
        break;
      case 264:
        LOBYTE(v3) = sub_10015AC0(2, 264, &v7);
        if ( (_BYTE)v3 )
        {
          v3 = sub_10033700(&v7, 0, 0);
          if ( !v3 )
          {
            LOBYTE(v3) = dword_10A08A60;
            if ( *(_BYTE *)(dword_10A08A60 + 15487) != 2 )
            {
              LOBYTE(a2) = v7 != 0;
              *(_BYTE *)(dword_10A08A60 + 15487) = v7 != 0;
            }
          }
        }
        break;
      case 268:
        LOBYTE(v3) = sub_10015AC0(2, 268, &unk_1043D3F0);
        if ( (_BYTE)v3 )
        {
          v3 = sub_1003A840((unsigned __int8 *)&unk_1043D3F0);
          if ( !v3 )
            LOBYTE(v3) = sub_10009F80((int)&unk_1043D3F0, dword_10A08A60);
        }
        break;
      case 277:
        LOBYTE(v3) = sub_10015AC0(2, 277, &unk_1043D3F0);
        if ( (_BYTE)v3 )
        {
          v3 = sub_1003A840((unsigned __int8 *)&unk_1043D3F0);
          if ( !v3 )
            LOBYTE(v3) = sub_10009F80((int)&unk_1043D3F0, dword_10A08A60);
        }
        break;
      case 271:
        LOBYTE(v3) = sub_10015AC0(2, 271, &unk_1043BF88);
        if ( (_BYTE)v3 )
        {
          v3 = sub_1001C210((int)&unk_1043BF88);
          if ( !v3 )
            LOBYTE(v3) = sub_1000A6F0((int)&unk_1043BF88, dword_10A08A60);
        }
        break;
      case 273:
        LOBYTE(v3) = sub_10015AC0(2, 273, &unk_1043D3C8);
        if ( (_BYTE)v3 )
          LOBYTE(v3) = sub_1000A210((int)&unk_1043D3C8, dword_10A08A60);
        break;
      case 287:
        LOBYTE(v3) = sub_10015AC0(2, 287, &unk_1043D3F8);
        if ( (_BYTE)v3 )
          LOBYTE(v3) = sub_1000A1D0((int)&unk_1043D3F8);
        break;
      default:
        break;
    }
  }
  else if ( v3 == 248 )
  {
    LOBYTE(v3) = sub_10015AC0(2, 248, &unk_10439768);
    if ( (_BYTE)v3 )
    {
      v3 = sub_1001C100((int)&unk_10439768);
      if ( !v3 )
      {
        sub_10009E30((int)&unk_10439768, dword_10A08A60);
        a2 = (void *)dword_10A08A60;
        v3 = (*(_BYTE *)(dword_10A08A60 + 70) + 1) / 255;
        *(_BYTE *)(dword_10A08A60 + 70) = (*(_BYTE *)(dword_10A08A60 + 70) + 1) % 255;
      }
    }
  }
  else if ( v3 == 5 )
  {
    byte_1043978F = 0;
    v4 = sub_10033580();
    LOBYTE(v3) = sub_1001E550(*((_BYTE *)v2 + 2), 0);
    LOBYTE(v9) = v3;
    if ( !v4 && (_BYTE)v3 != -1 )
      LOBYTE(v3) = sub_1001D2E0(v9, v9);
  }
  if ( !byte_1043BE93 )
  {
    LOBYTE(v3) = sub_1002EE60(a2);
    if ( (_BYTE)v3 )
      LOBYTE(v3) = sub_1000B640();
  }
  return v3;
}
// 1043978F: using guessed type char byte_1043978F;
// 10439791: using guessed type char byte_10439791;
// 1043BE93: using guessed type char byte_1043BE93;
// 10A08A5C: using guessed type int dword_10A08A5C;
// 10A08A60: using guessed type int dword_10A08A60;

//----- (1000BC40) --------------------------------------------------------
int __usercall sub_1000BC40@<eax>(int result@<eax>)
{
  if ( (_BYTE)result != *(_BYTE *)(dword_10A08A60 + 15485) )
  {
    *(_BYTE *)(dword_10A08A60 + 15485) = result;
    sub_1000C900(dword_10A08A60);
    result = (*(_BYTE *)(dword_10A08A60 + 72) + 1) / 255;
    *(_BYTE *)(dword_10A08A60 + 72) = (*(_BYTE *)(dword_10A08A60 + 72) + 1) % 255;
  }
  return result;
}
// 10A08A5C: using guessed type int dword_10A08A5C;
// 10A08A60: using guessed type int dword_10A08A60;

//----- (1000BC80) --------------------------------------------------------
char __usercall sub_1000BC80@<al>(int a1@<eax>, char a2@<dl>)
{
  int v2; // esi@2

  if ( (unsigned __int8)a1 < 4u )
  {
    v2 = 109 * (unsigned __int8)a1;
    *(_BYTE *)(v2 + dword_109FFDCC + 107) = a2;
    sub_10060ED0(dword_100899F0[(unsigned __int8)a1], v2 + dword_109FFDCC, 109);
    LOBYTE(a1) = sub_100336C0(19);
    if ( *(_BYTE *)(v2 + (unsigned __int8)a1 + dword_109FFDCC) )
    {
      a1 = (*(_BYTE *)(dword_109FFDCC + 14618969) + 1) / 255;
      *(_BYTE *)(dword_109FFDCC + 14618969) = (*(_BYTE *)(dword_109FFDCC + 14618969) + 1) % 255;
    }
  }
  return a1;
}
// 100899F0: using guessed type int dword_100899F0[];
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000BCF0) --------------------------------------------------------
char __usercall sub_1000BCF0@<al>(char a1@<al>, unsigned __int8 a2, char a3)
{
  int v3; // eax@1
  unsigned __int8 v4; // bl@1
  int v5; // esi@3
  char v7; // [sp+4h] [bp-4h]@1

  LOBYTE(v3) = sub_1001E550(a1, 0);
  v4 = v3;
  v7 = v3;
  if ( (_BYTE)v3 != -1 )
  {
    LOBYTE(v3) = a2;
    if ( a2 < 4u )
    {
      v5 = 109 * a2;
      *(_BYTE *)(v5 + (unsigned __int8)sub_100336C0(v7) + dword_109FFDCC + 52) = a3;
      sub_10060ED0(dword_100899F0[a2], dword_109FFDCC + v5, 109);
      v3 = (*(_BYTE *)(v4 + dword_109FFDCC + 14618950) + 1) / 255;
      *(_BYTE *)(v4 + dword_109FFDCC + 14618950) = (*(_BYTE *)(v4 + dword_109FFDCC + 14618950) + 1) % 255;
    }
  }
  return v3;
}
// 100899F0: using guessed type int dword_100899F0[];
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000BD80) --------------------------------------------------------
char __usercall sub_1000BD80@<al>(int a1@<eax>, char a2@<dl>)
{
  int v2; // esi@2

  if ( (unsigned __int8)a1 < 4u )
  {
    v2 = 109 * (unsigned __int8)a1;
    *(_BYTE *)(v2 + dword_109FFDCC + 104) = a2;
    sub_10060ED0(dword_100899F0[(unsigned __int8)a1], v2 + dword_109FFDCC, 109);
    LOBYTE(a1) = sub_100336C0(11);
    if ( *(_BYTE *)(v2 + (unsigned __int8)a1 + dword_109FFDCC) )
    {
      a1 = (*(_BYTE *)(dword_109FFDCC + 14618961) + 1) / 255;
      *(_BYTE *)(dword_109FFDCC + 14618961) = (*(_BYTE *)(dword_109FFDCC + 14618961) + 1) % 255;
    }
  }
  return a1;
}
// 100899F0: using guessed type int dword_100899F0[];
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000BDF0) --------------------------------------------------------
char __usercall sub_1000BDF0@<al>(int a1@<eax>, char a2@<dl>)
{
  int v2; // esi@2

  if ( (unsigned __int8)a1 < 4u )
  {
    v2 = 109 * (unsigned __int8)a1;
    *(_BYTE *)(v2 + dword_109FFDCC + 108) = a2;
    sub_10060ED0(dword_100899F0[(unsigned __int8)a1], v2 + dword_109FFDCC, 109);
    LOBYTE(a1) = sub_100336C0(18);
    if ( *(_BYTE *)(v2 + (unsigned __int8)a1 + dword_109FFDCC) )
    {
      a1 = (*(_BYTE *)(dword_109FFDCC + 14618968) + 1) / 255;
      *(_BYTE *)(dword_109FFDCC + 14618968) = (*(_BYTE *)(dword_109FFDCC + 14618968) + 1) % 255;
    }
  }
  return a1;
}
// 100899F0: using guessed type int dword_100899F0[];
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000BE60) --------------------------------------------------------
char __usercall sub_1000BE60@<al>(int a1@<eax>, char a2@<cl>, char a3@<bl>)
{
  int v3; // esi@2

  if ( (unsigned __int8)a1 < 4u )
  {
    a1 = (unsigned __int8)a1;
    v3 = 109 * (unsigned __int8)a1;
    if ( a3 )
      *(_BYTE *)(v3 + dword_109FFDCC + 106) = a2;
    else
      *(_BYTE *)(v3 + dword_109FFDCC + 105) = a2;
    LOBYTE(a1) = sub_10060ED0(dword_100899F0[a1], v3 + dword_109FFDCC, 109);
    if ( a3 )
    {
      if ( a3 == 1 )
      {
        a1 = v3 + (unsigned __int8)sub_100336C0(50);
        if ( *(_BYTE *)(a1 + dword_109FFDCC) )
        {
          a1 = (*(_BYTE *)(dword_109FFDCC + 14619000) + 1) / 255;
          *(_BYTE *)(dword_109FFDCC + 14619000) = (*(_BYTE *)(dword_109FFDCC + 14619000) + 1) % 255;
        }
      }
      else if ( a3 == 2 )
      {
        LOBYTE(a1) = sub_100336C0(34);
        if ( *(_BYTE *)(v3 + (unsigned __int8)a1 + dword_109FFDCC) )
        {
          a1 = (*(_BYTE *)(dword_109FFDCC + 14618984) + 1) / 255;
          *(_BYTE *)(dword_109FFDCC + 14618984) = (*(_BYTE *)(dword_109FFDCC + 14618984) + 1) % 255;
        }
      }
    }
    else
    {
      LOBYTE(a1) = sub_100336C0(14);
      if ( *(_BYTE *)(v3 + (unsigned __int8)a1 + dword_109FFDCC) )
      {
        a1 = (*(_BYTE *)(dword_109FFDCC + 14618964) + 1) / 255;
        *(_BYTE *)(dword_109FFDCC + 14618964) = (*(_BYTE *)(dword_109FFDCC + 14618964) + 1) % 255;
      }
    }
  }
  return a1;
}
// 100899F0: using guessed type int dword_100899F0[];
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000BFA0) --------------------------------------------------------
void sub_1000BFA0()
{
  char v0; // bl@1
  char v1; // [sp+6h] [bp-Ah]@1
  char v2; // [sp+7h] [bp-9h]@1
  float v3; // [sp+8h] [bp-8h]@1
  float v4; // [sp+Ch] [bp-4h]@1

  sub_10061C40(35, &v1);
  sub_10033E20(&v3);
  v0 = *(_BYTE *)(dword_10A08A60 + 15487);
  sub_10061C40(36, &v4);
  sub_1002ED20((bool *)&v2);
  if ( sub_1002C680(3) || v1 && !v2 && v4 > (double)v3 )
  {
    *(_BYTE *)(dword_10A08A60 + 15487) = 2;
    sub_1000A540(2);
  }
  else if ( v0 == 2 )
  {
    *(_BYTE *)(dword_10A08A60 + 15487) = 1;
    sub_1000A540(1);
  }
}
// 10A08A60: using guessed type int dword_10A08A60;

//----- (1000C050) --------------------------------------------------------
int __usercall sub_1000C050@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@5
  int result; // eax@6
  int v3; // edx@6
  unsigned int v4; // eax@1

  v4 = *(_DWORD *)(a1 + 4);
  if ( v4 <= 0xEF1 && (v4 >= 0xEF0 || v4 - 3440 <= 1) )
  {
    sub_10060D80(3824, dword_109FFDCC, 109);
    sub_10060D80(3440, dword_109FFDCC + 109, 109);
    sub_10060D80(3441, dword_109FFDCC + 218, 109);
    sub_10060D80(3825, dword_109FFDCC + 327, 109);
  }
  v1 = 0;
  do
  {
    result = (*(_BYTE *)(dword_109FFDCC + v1 + 14618950) + 1) / 255;
    v3 = (*(_BYTE *)(dword_109FFDCC + v1++ + 14618950) + 1) % 255;
    *(_BYTE *)(dword_109FFDCC + v1 + 14618949) = v3;
  }
  while ( v1 <= 27 );
  return result;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000C0D0) --------------------------------------------------------
void sub_1000C0D0()
{
  char v0; // bl@1
  void *v1; // ecx@3
  int v2; // eax@18
  int v3; // eax@22
  int v4; // eax@23
  int v5; // eax@24
  int v6; // eax@26
  void *v7; // ecx@30
  void *v8; // ecx@33
  void *v9; // ecx@37
  char v10; // [sp+2h] [bp-BAh]@1
  char v11; // [sp+3h] [bp-B9h]@1
  float v12; // [sp+4h] [bp-B8h]@9
  char v13; // [sp+8h] [bp-B4h]@8
  char String; // [sp+18h] [bp-A4h]@9
  char v15; // [sp+7Ch] [bp-40h]@1

  v11 = 0;
  sub_10034120(&v15);
  v0 = sub_10020DC0((void *)0x47, &v10);
  if ( v0 != 1 || v10 != 2 )
  {
    if ( !sub_1002D390(170) && !sub_1002D390(252) )
      sub_1002D550(0xABu);
    if ( v0 != 1 )
      goto LABEL_26;
  }
  else
  {
    sub_1002D440(171);
    if ( !byte_1043BE91 && (sub_1002C5E0(v1) != 4 || sub_100340B0(2048)) )
    {
      v11 = 1;
      byte_1043BE91 = 1;
    }
    if ( byte_1043BE6B == 2 && sub_10031310(71, &v13) == 1 )
    {
      v12 = sub_10068FB6(&String);
      if ( v12 < 3.299999952316284 )
      {
        byte_1043BE6B = 0;
      }
      else
      {
        byte_1043BE6B = 1;
        sub_1001CE30(0, 1);
      }
    }
  }
  if ( v10 != 2 )
  {
LABEL_26:
    v6 = dword_109FFDCC;
    *(_DWORD *)(dword_109FFDCC + 8496) = *(_DWORD *)"RECEIVER FAILURE";
    v6 += 8496;
    *(_DWORD *)(v6 + 4) = *(_DWORD *)"IVER FAILURE";
    *(_DWORD *)(v6 + 8) = *(_DWORD *)" FAILURE";
    *(_DWORD *)(v6 + 12) = *(_DWORD *)"LURE";
    *(_BYTE *)(v6 + 16) = aReceiverFailur[16];
    goto LABEL_27;
  }
  if ( *(_BYTE *)(dword_10A08A60 + 15526) )
  {
    if ( !memcmp((const void *)dword_10A08A60, "CHECK", 6u)
      && !memcmp((const void *)(dword_10A08A60 + 17), "ANTENNA", 8u)
      || !memcmp((const void *)(dword_10A08A60 + 17), "NO SIGNAL", 0xAu) )
    {
      v3 = dword_109FFDCC + 8496;
      *(_DWORD *)v3 = *(_DWORD *)"NO SIGNAL";
      *(_DWORD *)(v3 + 4) = *(_DWORD *)"IGNAL";
      *(_WORD *)(v3 + 8) = *(_WORD *)"L";
    }
    else
    {
      v4 = dword_109FFDCC;
      if ( byte_1043978F )
      {
        *(_DWORD *)(dword_109FFDCC + 8496) = 1414086999;
        v5 = v4 + 8496;
        *(_DWORD *)(v5 + 4) = 541544009;
        *(_DWORD *)(v5 + 8) = 542265158;
        *(_DWORD *)(v5 + 12) = 1096040772;
        *(_DWORD *)(v5 + 16) = 3026478;
      }
      else
      {
        *(_BYTE *)(dword_109FFDCC + 8496) = 0;
      }
    }
  }
  else
  {
    v2 = dword_109FFDCC;
    *(_DWORD *)(dword_109FFDCC + 8496) = 1163150660;
    v2 += 8496;
    *(_DWORD *)(v2 + 4) = 1313428547;
    *(_DWORD *)(v2 + 8) = 1128341575;
    *(_DWORD *)(v2 + 12) = 1096173908;
    *(_DWORD *)(v2 + 16) = 1313818964;
    *(_BYTE *)(v2 + 20) = 0;
  }
LABEL_27:
  if ( !sub_10033580() && v11 )
    sub_1001D2E0(0, 0x1Bu);
  if ( (unsigned int)(sub_10060900() - dword_1043BE6C) >= 0x1388 && !(sub_1002C660(v7) & 3) )
  {
    sub_1000A410(0, -1, *(_BYTE *)(dword_10A08A60 + 15485));
    dword_1043BE6C = sub_10060900();
  }
  if ( (unsigned int)(sub_10060900() - dword_1043D3C4) >= 0x1388 && !(sub_1002C660(v8) & 3) )
  {
    sub_1000A600();
    dword_1043D3C4 = sub_10060900();
  }
  if ( (unsigned int)(sub_10060900() - dword_1043BE70) >= 0x1388 )
  {
    sub_1000A690();
    if ( !(sub_1002C660(v9) & 3) )
    {
      sub_1000A510();
      sub_1000A570();
    }
    dword_1043BE70 = sub_10060900();
  }
  if ( (unsigned int)(sub_10060900() - dword_1043BE94) >= 0x2710 )
  {
    sub_1000A3E0();
    dword_1043BE94 = sub_10060900();
  }
  if ( *(_BYTE *)(dword_10A08A60 + 15529) && (unsigned int)(sub_10060900() - dword_1043BF84) >= 0x190 )
  {
    sub_1000A4B0();
    dword_1043BF84 = sub_10060900();
  }
  sub_1000BFA0();
}
// 1043978F: using guessed type char byte_1043978F;
// 1043BE6B: using guessed type char byte_1043BE6B;
// 1043BE6C: using guessed type int dword_1043BE6C;
// 1043BE70: using guessed type int dword_1043BE70;
// 1043BE91: using guessed type char byte_1043BE91;
// 1043BE94: using guessed type int dword_1043BE94;
// 1043BF84: using guessed type int dword_1043BF84;
// 1043D3C4: using guessed type int dword_1043D3C4;
// 109FFDCC: using guessed type int dword_109FFDCC;
// 10A08A60: using guessed type int dword_10A08A60;

//----- (1000C470) --------------------------------------------------------
int sub_1000C470()
{
  int result; // eax@1
  void *v1; // ecx@1
  int v2; // eax@2
  int v3; // eax@8
  char v4; // [sp+4h] [bp-14h]@1
  unsigned __int16 v5; // [sp+8h] [bp-10h]@1
  unsigned int v6; // [sp+Ah] [bp-Eh]@6
  unsigned int v7; // [sp+Eh] [bp-Ah]@8

  for ( result = sub_10060880((int)&v5, (int)&v4); result != 1; result = sub_10060880((int)&v5, (int)&v4) )
  {
    v2 = v5;
    if ( (signed int)v5 > 32769 )
    {
      switch ( v5 )
      {
        case 0x8028u:
          v3 = v7;
          LOBYTE(v3) = BYTE2(v6);
          sub_1000B750(v3, SBYTE3(v6), v7);
          break;
        case 0x8009u:
          sub_1000BDF0(v6, SBYTE1(v6));
          break;
        case 0x800Au:
          sub_1000BC80(v6, SBYTE1(v6));
          break;
        case 0x8002u:
          sub_1000BD80(v6, SBYTE1(v6));
          break;
        case 0x8003u:
          sub_1000BCF0(SBYTE1(v6), v6, SBYTE2(v6));
          break;
        case 0x8027u:
          sub_1000A460(SBYTE2(v6), SBYTE3(v6), v7);
          break;
        case 0x8025u:
          LOBYTE(v2) = BYTE2(v6);
          sub_1000BC40(v2);
          break;
        case 0x8021u:
          *(_BYTE *)(dword_10A08A60 + 15487) = BYTE2(v6);
          sub_1000A540(*(_BYTE *)(dword_10A08A60 + 15487));
          break;
        case 0x8020u:
          *(_WORD *)(dword_10A08A60 + 15488) = BYTE2(v6);
          sub_1000A6C0(*(_WORD *)(dword_10A08A60 + 15488));
          break;
        case 0x8026u:
          sub_1000A5D0(SHIWORD(v6), SBYTE3(v6));
          *(_BYTE *)(BYTE2(v6) + dword_10A08A60 + 15491) = BYTE3(v6);
          break;
        case 0x8024u:
          sub_1000A5A0(SBYTE2(v6));
          break;
        case 0x8022u:
          sub_1000A660();
          break;
        case 0x8023u:
          sub_1000A4E0(SBYTE2(v6));
          break;
        case 0x8007u:
          dword_1043BF84 = sub_10060900();
          *(_BYTE *)(dword_10A08A60 + 15529) = v6;
          sub_1000A630(v6);
          break;
        case 0x8008u:
          sub_1000B7C0(&v6, v1);
          break;
        case 0x800Bu:
          sub_100116D0(v6, v7);
          break;
        default:
          continue;
      }
    }
    else if ( v5 == 32769 )
    {
      sub_1000BE60(v6, SBYTE1(v6), SBYTE2(v6));
    }
    else if ( v5 == 1 )
    {
      sub_1000C050((int)&v5);
    }
  }
  return result;
}
// 1043BF84: using guessed type int dword_1043BF84;
// 10A08A60: using guessed type int dword_10A08A60;

//----- (1000C710) --------------------------------------------------------
void __noreturn sub_1000C710()
{
  char v0; // bl@1
  void *v1; // ecx@4
  void *v2; // ecx@4
  char v3; // [sp+6h] [bp-6h]@1
  char v4; // [sp+7h] [bp-5h]@7
  char v5; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v0 = 0;
  byte_1043978F = 1;
  sub_10060C20(&v5);
  if ( !(v5 & 0x10) )
    sub_10028BC0("..\\lib\\adl\\iop_gdl69_main.c", 437, 1, 0);
  while ( 1 )
  {
    sub_10060C20(&v5);
    if ( v5 & 1 )
    {
      sub_1000D260();
      sub_10005FC0();
      if ( sub_100336A0(v1) )
      {
        if ( v3 )
        {
          sub_1000C0D0();
        }
        else if ( sub_10020DC0((void *)0x47, &v4) && v4 == 2 )
        {
          v3 = 1;
          sub_1002D440(171);
          v0 = 0;
          sub_1000C0D0();
        }
        else if ( (unsigned __int8)++v0 > 0x80u )
        {
          sub_1002D550(0xABu);
        }
      }
      sub_1001D5E0(v2);
    }
    if ( v5 & 2 )
      sub_1000C470();
  }
}
// 1043978F: using guessed type char byte_1043978F;

//----- (1000C7F0) --------------------------------------------------------
char __cdecl sub_1000C7F0(int a1)
{
  sub_100147A0(a1);
  return 1;
}

//----- (1000C800) --------------------------------------------------------
char __cdecl sub_1000C800(int a1)
{
  int v1; // ecx@1
  bool v2; // zf@1
  char result; // al@1

  sub_100146E0(a1);
  v2 = (a1 & j_HWM_pvg_hsdb_get_lrus_online(v1)) == a1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);

//----- (1000C830) --------------------------------------------------------
_BYTE *__cdecl sub_1000C830(int a1)
{
  int v1; // ebp@1
  unsigned __int8 v2; // bl@1
  unsigned __int8 v3; // dl@1
  _BYTE *result; // eax@2
  unsigned __int16 v5; // cx@3
  const void *v6; // [sp+14h] [bp+4h]@1

  v1 = a1;
  *(_BYTE *)(a1 + 15490) = 32;
  *(_DWORD *)(a1 + 15212) = 1936028240;
  v2 = 0;
  *(_DWORD *)(a1 + 15216) = 7566437;
  v3 = 0;
  v6 = (const void *)(a1 + 14668);
  do
  {
    result = 0;
    if ( memcmp(v6, &byte_10080D49, 1u) )
    {
      v5 = 0;
      while ( v3 != 32 )
      {
        result = (_BYTE *)(v1 + 39 * v5);
        if ( result[73] )
        {
          if ( result[74] == v3 || result[75] == v3 || result[76] == v3 || result[77] == v3 )
            break;
        }
        if ( ++v5 >= 0x100u )
          goto LABEL_13;
      }
      *(_BYTE *)(v2++ + v1 + 15229) = v3;
    }
LABEL_13:
    v6 = (char *)v6 + 17;
    ++v3;
  }
  while ( v3 <= 0x20u );
  *(_BYTE *)(v1 + 15486) = v2;
  if ( v2 <= 0x20u )
    result = memset((void *)(v2 + v1 + 15229), 0, (unsigned __int8)(33 - v2));
  return result;
}

//----- (1000C900) --------------------------------------------------------
void *__cdecl sub_1000C900(int a1)
{
  char v1; // bl@1
  void *result; // eax@1
  unsigned __int16 v3; // cx@2
  _BYTE *v4; // edx@2
  char *v5; // ecx@9
  char v6; // bl@10
  int v7; // edx@10
  unsigned __int16 v8; // dx@12
  int v9; // ecx@12

  v1 = *(_BYTE *)(a1 + 15485);
  result = 0;
  if ( v1 )
  {
    if ( v1 == *(_BYTE *)(a1 + 15490) )
    {
      v5 = (char *)(a1 + 15491);
      do
      {
        v6 = *v5;
        v7 = (unsigned __int16)result;
        result = (char *)result + 1;
        ++v5;
        *(_BYTE *)(v7 + a1 + 14409) = v6;
      }
      while ( (unsigned __int16)result < 0xFu );
    }
    else
    {
      v8 = 0;
      v9 = a1 + 74;
      do
      {
        if ( *(_BYTE *)(v9 - 1)
          && (*(_BYTE *)v9 == v1 || *(_BYTE *)(v9 + 1) == v1 || *(_BYTE *)(v9 + 2) == v1 || *(_BYTE *)(v9 + 3) == v1) )
        {
          *(_BYTE *)((unsigned __int16)result + a1 + 14409) = v8;
          result = (char *)result + 1;
        }
        ++v8;
        v9 += 39;
      }
      while ( v8 < 0x100u );
    }
  }
  else
  {
    v3 = 0;
    v4 = (_BYTE *)(a1 + 73);
    do
    {
      if ( *v4 || !v3 )
      {
        *(_BYTE *)((unsigned __int16)result + a1 + 14409) = v3;
        result = (char *)result + 1;
      }
      ++v3;
      v4 += 39;
    }
    while ( v3 < 0x100u );
  }
  if ( !(_WORD)result )
  {
    *(_BYTE *)(a1 + 14409) = 0;
    result = (void *)1;
  }
  *(_WORD *)(a1 + 14666) = (_WORD)result;
  if ( (unsigned __int16)result < 0x100u )
    result = memset((void *)((unsigned __int16)result + a1 + 14409), 0, (unsigned __int16)(256 - (_WORD)result));
  return result;
}

//----- (1000C9F0) --------------------------------------------------------
void *sub_1000C9F0()
{
  void *result; // eax@1
  signed int v1; // ecx@1
  int v2; // edx@2
  char v3; // bl@2

  memset(byte_1043D488, 0, 0x100u);
  result = &unk_1008A7E0;
  v1 = 51;
  do
  {
    v2 = *(_BYTE *)result;
    v3 = *((_BYTE *)result + 1);
    result = (char *)result + 2;
    --v1;
    byte_1043D488[v2] = v3;
  }
  while ( v1 );
  return result;
}

//----- (1000CA30) --------------------------------------------------------
void __cdecl sub_1000CA30(char *a1, unsigned __int8 a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char v4; // cl@3

  if ( a2 )
  {
    v2 = a1;
    v3 = a2;
    do
    {
      v4 = byte_1043D488[(unsigned __int8)*v2];
      if ( v4 )
        *v2 = v4;
      ++v2;
      --v3;
    }
    while ( v3 );
  }
}

//----- (1000CA60) --------------------------------------------------------
char __cdecl sub_1000CA60(unsigned __int8 a1, _WORD *a2)
{
  char result; // al@1

  result = 0;
  if ( a1 < 0x1Cu )
  {
    *a2 = word_1008A628[8 * a1];
    result = 1;
  }
  return result;
}
// 1008A628: using guessed type __int16 word_1008A628[];

//----- (1000CA90) --------------------------------------------------------
char __cdecl sub_1000CA90(int a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@2
  int *v3; // ecx@2
  int *v4; // edx@2
  int v5; // esi@6
  int v6; // eax@7
  _BYTE *v7; // ecx@7
  _BYTE *v8; // edx@7
  int v9; // eax@9
  _BYTE *v10; // ecx@9
  _BYTE *v11; // edx@9
  _BYTE *v12; // ecx@11
  _BYTE *v13; // edx@11
  signed int v14; // eax@13
  int v16; // [sp+4h] [bp-18h]@1
  int v17; // [sp+8h] [bp-14h]@1
  int v18; // [sp+Ch] [bp-10h]@1
  int v19; // [sp+10h] [bp-Ch]@1
  __int16 v20; // [sp+14h] [bp-8h]@1
  char v21; // [sp+16h] [bp-6h]@1

  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v1 = sub_10033590(a1, (int)&v16);
  if ( v1 != 1 )
    goto LABEL_18;
  *(int *)((char *)&dword_1043D5AC + 3) = *(int *)((char *)&v19 + 3);
  v2 = 19;
  v3 = &dword_1043D5A0;
  v4 = &v16;
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_6;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_15:
    v14 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_15;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_15;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_15;
        v5 = *v13 - *v12;
        if ( *v13 == *v12 )
          goto LABEL_15;
      }
    }
  }
  v14 = 1;
  if ( v5 <= 0 )
    v14 = -1;
LABEL_16:
  if ( !v14 )
  {
    sub_10001600(10);
    return v1;
  }
  v1 = 0;
LABEL_18:
  sub_10001530();
  if ( (unsigned int)sub_10001510() <= 0xA )
    sub_10001600(1);
  else
    sub_10001600(8);
  return v1;
}
// 1043D5A0: using guessed type int dword_1043D5A0;
// 1043D5AC: using guessed type int dword_1043D5AC;

//----- (1000CBB0) --------------------------------------------------------
char sub_1000CBB0()
{
  if ( (unsigned int)(sub_10060900() - dword_1043D5B4) > 0x1F4 )
    sub_10001600((unsigned __int8)byte_1043D588);
  return 1;
}
// 1043D588: using guessed type char byte_1043D588;
// 1043D5B4: using guessed type int dword_1043D5B4;

//----- (1000CBE0) --------------------------------------------------------
char __cdecl sub_1000CBE0(char a1, int a2, int a3, int a4, char a5, char *a6)
{
  int v6; // eax@1
  char result; // al@3

  v6 = sub_1002CC90(&a5, 1u, (int)&unk_1008A980, 101, 10, 10);
  if ( a1 != 17 || v6 == 10 )
  {
    result = 0;
  }
  else
  {
    strncpy(a6, &byte_1008A981[101 * v6], 0x64u);
    result = 1;
  }
  return result;
}

//----- (1000CC30) --------------------------------------------------------
int sub_1000CC30()
{
  int result; // eax@1

  result = 0;
  byte_1043D588 = 0;
  dword_1043D5B4 = 0;
  dword_1043D58C = 0;
  dword_1043D590 = 0;
  dword_1043D594 = 0;
  dword_1043D598 = 0;
  dword_1043D59C = 0;
  dword_1043D5A0 = 0;
  dword_1043D5A4 = 0;
  dword_1043D5A8 = 0;
  dword_1043D5AC = 0;
  dword_1043D5B0 = 0;
  return result;
}
// 1043D588: using guessed type char byte_1043D588;
// 1043D58C: using guessed type int dword_1043D58C;
// 1043D590: using guessed type int dword_1043D590;
// 1043D594: using guessed type int dword_1043D594;
// 1043D598: using guessed type int dword_1043D598;
// 1043D59C: using guessed type int dword_1043D59C;
// 1043D5A0: using guessed type int dword_1043D5A0;
// 1043D5A4: using guessed type int dword_1043D5A4;
// 1043D5A8: using guessed type int dword_1043D5A8;
// 1043D5AC: using guessed type int dword_1043D5AC;
// 1043D5B0: using guessed type int dword_1043D5B0;
// 1043D5B4: using guessed type int dword_1043D5B4;

//----- (1000CC70) --------------------------------------------------------
char __usercall sub_1000CC70@<al>(int a1@<esi>, int a2)
{
  char result; // al@1
  char v3; // bl@3
  int v4; // eax@7
  signed int v5; // ecx@11
  float *v6; // edx@11
  unsigned __int8 v7; // al@15
  signed int v8; // ST10_4@16
  double v9; // st7@17
  char v10; // [sp+8h] [bp-2Ch]@5

  result = 0;
  if ( *(_BYTE *)a1 < 0xAu )
  {
    if ( sub_10001520() != 1 )
    {
      v3 = *(_BYTE *)a1;
      if ( *(_BYTE *)a1 )
      {
        if ( v3 == 1 )
        {
LABEL_9:
          if ( 9.8999998e24 == *(float *)(a1 + 16) )
            return 0;
LABEL_14:
          if ( v3 == 1 )
          {
            v7 = (signed int)(*(float *)(a1 + 16) * 10.0);
          }
          else
          {
            v8 = (signed int)((*(float *)(a1 + 8) - *(float *)(a1 + 12) - 14.0) * 10.0);
            *(_BYTE *)(a1 + 26) = v8;
            v7 = sub_10068130((unsigned __int8)v8, 5);
          }
          *(_BYTE *)(a1 + 26) = v7;
          v9 = (double)v7;
          if ( v9 >= 0.0 && v9 <= 100.0 )
            return 1;
          return 0;
        }
        if ( !(unsigned __int8)sub_10033640(a2, (int)&v10) || *(_BYTE *)a1 != v10 )
        {
          v3 = *(_BYTE *)a1;
          v4 = *(_BYTE *)a1;
          *(_DWORD *)(a1 + 8) = dword_1008A930[2 * v4];
          *(_DWORD *)(a1 + 12) = dword_1008A934[2 * v4];
          goto LABEL_14;
        }
      }
    }
    v3 = *(_BYTE *)a1;
    if ( *(_BYTE *)a1 != 1 )
    {
      v5 = 0;
      v6 = (float *)(a1 + 8);
      while ( 9.8999998e24 != *v6 )
      {
        ++v5;
        ++v6;
        if ( v5 >= 2 )
          goto LABEL_14;
      }
      return 0;
    }
    goto LABEL_9;
  }
  return result;
}
// 1008A930: using guessed type int dword_1008A930[];
// 1008A934: using guessed type int dword_1008A934[];

//----- (1000CDF0) --------------------------------------------------------
char __usercall sub_1000CDF0@<al>(void *a1@<ecx>, int a2@<esi>, int a3)
{
  char result; // al@1
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@1
  int v9; // [sp+Ch] [bp-10h]@1
  int v10; // [sp+10h] [bp-Ch]@1
  __int16 v11; // [sp+14h] [bp-8h]@1
  char v12; // [sp+16h] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  result = sub_100336A0(a1);
  if ( result )
  {
    v4 = *(_DWORD *)(a2 + 4);
    v5 = *(_DWORD *)(a2 + 8);
    v7 = *(_DWORD *)a2;
    v10 = *(_DWORD *)(a2 + 12);
    v8 = v4;
    v11 = *(_WORD *)(a2 + 16);
    v9 = v5;
    v12 = *(_BYTE *)(a2 + 18);
    result = sub_10015560(2, 284, &v6, 0, 23, a3);
  }
  return result;
}

//----- (1000CE80) --------------------------------------------------------
int __usercall sub_1000CE80@<eax>(int result@<eax>, char a2)
{
  if ( a2 == 17 )
    result = sub_10060F50(6169, result, 40);
  return result;
}

//----- (1000CEB0) --------------------------------------------------------
char __cdecl sub_1000CEB0(int a1, char a2)
{
  char v2; // bl@2
  int v4; // [sp+8h] [bp-2Ch]@1
  int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  if ( a2 )
  {
    if ( (unsigned __int8)sub_10033640(a1, (int)&v4) && sub_10033590(a1, (int)&v9) )
    {
      v2 = 1;
      sub_1000CE80((int)&v4, a1);
      sub_10001600(7);
    }
    else
    {
      v2 = 0;
      sub_10001600(8);
    }
  }
  else
  {
    sub_1000CE80((int)&dword_1043D58C, a1);
    v2 = 1;
    sub_10001600(7);
  }
  return v2;
}
// 1043D58C: using guessed type int dword_1043D58C;

//----- (1000CF70) --------------------------------------------------------
char __cdecl sub_1000CF70(char a1)
{
  int v1; // ecx@0
  char result; // al@1
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  result = 0;
  BYTE3(v3) = 0;
  if ( a1 == 17 )
  {
    sub_1001EA70((char *)&v3 + 3, 283, 0, 1, 1);
    result = 1;
  }
  return result;
}

//----- (1000CFA0) --------------------------------------------------------
char __usercall sub_1000CFA0@<al>(void *a1@<ecx>, int a2@<ebx>, char a3)
{
  int v3; // ecx@3
  int v4; // edx@3
  int v5; // eax@3
  int v7; // [sp+0h] [bp-1Ch]@3
  int v8; // [sp+4h] [bp-18h]@3
  int v9; // [sp+8h] [bp-14h]@3
  int v10; // [sp+Ch] [bp-10h]@3
  int v11; // [sp+10h] [bp-Ch]@3
  __int16 v12; // [sp+14h] [bp-8h]@3
  char v13; // [sp+16h] [bp-6h]@3

  if ( a3 != 17 )
    sub_10028BC0("..\\lib\\acl\\iop\\iop_gdl_cnfg.c", 927, 1, 0);
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  sub_1000CDF0(a1, (int)&v8, 0);
  qmemcpy(&dword_1043D58C, (const void *)a2, 0x28u);
  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 28);
  v8 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 32);
  v9 = v3;
  LOWORD(v3) = *(_WORD *)(a2 + 36);
  v10 = v4;
  LOBYTE(v4) = *(_BYTE *)(a2 + 38);
  v11 = v5;
  v12 = v3;
  v13 = v4;
  v7 = 71;
  return sub_1001EA70(&v7, 282, 0, 23, 1);
}
// 1043D58C: using guessed type int dword_1043D58C;

//----- (1000D060) --------------------------------------------------------
char __cdecl sub_1000D060(int a1)
{
  char v1; // bl@1
  void *v2; // ecx@4
  void *v4; // ecx@7
  char v5; // [sp+8h] [bp-2Ch]@4
  char v6; // [sp+1Ch] [bp-18h]@4

  v1 = sub_1000CF70(a1);
  if ( !v1 )
    return v1;
  if ( sub_10001520() == 2 )
  {
    if ( j_HWM_pvg_read_reg(1) == 1 )
    {
      sub_10033640(a1, (int)&v5);
      sub_1000CDF0(v2, (int)&v6, 1);
    }
    sub_10001600(7);
    return v1;
  }
  if ( j_HWM_pvg_read_reg(1) == 1 )
    sub_1000CDF0(v4, (int)&dword_1043D5A0, 1);
  v1 = sub_10033590(a1, (int)&v6);
  if ( v1 == 1 )
  {
    if ( sub_10001520() != 5 || sub_10001500() != 1 )
      sub_10001600(3);
    else
      sub_10001600(10);
    return v1;
  }
  sub_10001530();
  if ( (unsigned int)sub_10001510() > 0xA )
  {
    sub_10001600(8);
    return v1;
  }
  sub_10001600(4);
  byte_1043D588 = 2;
  dword_1043D5B4 = sub_10060900();
  return v1;
}
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 1043D588: using guessed type char byte_1043D588;
// 1043D5A0: using guessed type int dword_1043D5A0;
// 1043D5B4: using guessed type int dword_1043D5B4;

//----- (1000D160) --------------------------------------------------------
char __cdecl sub_1000D160(char a1, int a2, int a3, int a4, int a5, int a6)
{
  void *v7; // ecx@6
  int *v8; // ebx@7
  int v9; // [sp+8h] [bp-2Ch]@1
  int v10; // [sp+Ch] [bp-28h]@1
  int v11; // [sp+10h] [bp-24h]@1
  int v12; // [sp+14h] [bp-20h]@1
  int v13; // [sp+18h] [bp-1Ch]@1
  int v14; // [sp+1Ch] [bp-18h]@1
  int v15; // [sp+20h] [bp-14h]@1
  int v16; // [sp+24h] [bp-10h]@1
  int v17; // [sp+28h] [bp-Ch]@1
  int v18; // [sp+2Ch] [bp-8h]@1

  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if ( a1 != 17 )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\iop_gdl_cnfg.c", 373, 0, 0);
LABEL_3:
    sub_10001600(8);
    return 0;
  }
  if ( a6 )
  {
    if ( !sub_1000CC70(a5, 17) )
      goto LABEL_3;
    v8 = (int *)a5;
  }
  else
  {
    if ( !(unsigned __int8)sub_10033640(17, (int)&v9) || !sub_1000CC70((int)&v9, 17) )
      goto LABEL_3;
    v8 = &v9;
  }
  sub_1000CFA0(v7, (int)v8, 17);
  sub_10001600(4);
  byte_1043D588 = 2;
  dword_1043D5B4 = sub_10060900();
  return 1;
}
// 1043D588: using guessed type char byte_1043D588;
// 1043D5B4: using guessed type int dword_1043D5B4;

//----- (1000D260) --------------------------------------------------------
void sub_1000D260()
{
  if ( sub_100324A0(1) )
    sub_10011F20();
}

//----- (1000D280) --------------------------------------------------------
char __cdecl sub_1000D280(__int16 a1)
{
  char result; // al@1
  bool v2; // al@9
  char v3; // [sp+0h] [bp-254h]@11
  char v4; // [sp+1h] [bp-253h]@11
  int v5; // [sp+4h] [bp-250h]@12
  int v6; // [sp+8h] [bp-24Ch]@11
  int v7; // [sp+Ch] [bp-248h]@4
  char v8; // [sp+10h] [bp-244h]@6
  char v9; // [sp+1Ch] [bp-238h]@5
  char v10; // [sp+130h] [bp-124h]@3
  char v11; // [sp+13Ch] [bp-118h]@5

  result = a1;
  if ( a1 == 42 )
  {
    if ( !sub_100144B0(42, (int)&byte_10A08A80, &v8) || (result = sub_10021180(&v8)) == 0 )
      result = sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds.c", 207, 0, "Couldn't store copy of GFDS registration data.");
  }
  else if ( a1 == 377 )
  {
    v2 = (unsigned __int8)sub_10021070((int)&v10)
      && sub_100144B0(377, (int)&byte_10A08A80, &v7)
      && !strcmp(&v9, &v11)
      && !strcmp(&v8, &v10)
      && v11
      && v10;
    v3 = 1;
    v6 = -1;
    v4 = -1;
    if ( v2 )
    {
      sub_1002D440(212);
      v5 = 0;
    }
    else
    {
      v5 = v7 != 401 ? -1 : -34;
      memset(&v7, 0, 0x124u);
      sub_1002D550(0xD4u);
    }
    sub_10008B40(3u, (int)&v3);
    result = sub_10021180(&v8);
    if ( !result )
      result = sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds.c", 187, 0, "Couldn't store GFDS registration data.");
  }
  return result;
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (1000D450) --------------------------------------------------------
void *sub_1000D450()
{
  void *result; // eax@4

  if ( sub_100321F0(2u) && !(unsigned __int8)sub_10021090() )
    sub_1002D550(0xD4u);
  sub_10011570();
  sub_1000E7E0();
  sub_1000F3B0();
  byte_10441114 = sub_1000F310();
  sub_1000ED00();
  sub_1000F230();
  result = memset(&unk_10441118, 0, 0x500u);
  byte_10441115 = 0;
  byte_10441116 = 0;
  dword_10441670 = 0;
  dword_10441674 = 0;
  return result;
}
// 10441114: using guessed type char byte_10441114;
// 10441115: using guessed type char byte_10441115;
// 10441116: using guessed type char byte_10441116;
// 10441670: using guessed type int dword_10441670;
// 10441674: using guessed type int dword_10441674;

//----- (1000D490) --------------------------------------------------------
char *__cdecl sub_1000D490(unsigned __int8 a1)
{
  return (char *)&unk_10440868 + 84 * a1;
}

//----- (1000D4A0) --------------------------------------------------------
char __cdecl sub_1000D4A0(unsigned __int8 a1, int a2)
{
  int v2; // eax@1
  unsigned int v3; // ecx@1
  double v4; // st7@2

  v2 = 172 * a1;
  byte_1043D7F9[v2 * 4] = byte_1043D860[v2 * 4];
  v3 = dword_1043D7E4[v2];
  if ( v3 )
    v4 = (double)(unsigned int)dword_1043D7EC[v2] / (double)v3;
  else
    v4 = 0.0;
  flt_1043D7F4[v2] = v4;
  *(float *)a2 = flt_1043D7F4[v2];
  *(_DWORD *)(a2 + 4) = *(_DWORD *)&byte_1043D7F8[v2 * 4];
  return 1;
}
// 1043D7E4: using guessed type int dword_1043D7E4[];
// 1043D7EC: using guessed type int dword_1043D7EC[];
// 1043D7F4: using guessed type float flt_1043D7F4[];

//----- (1000D510) --------------------------------------------------------
char __cdecl sub_1000D510(char a1, __int16 a2)
{
  char v2; // cl@0
  int v3; // edi@1
  char v4; // bl@1
  const char *v5; // edx@1
  unsigned int v6; // ebx@3
  unsigned int v7; // eax@3
  unsigned int v8; // esi@3
  __int64 v9; // rax@5
  unsigned int v10; // ebp@5
  char result; // al@16
  char v12; // [sp+13h] [bp-19Dh]@1
  unsigned int v13; // [sp+14h] [bp-19Ch]@5
  char v14; // [sp+1Ch] [bp-194h]@1
  int v15; // [sp+9Ch] [bp-114h]@1
  __int16 v16; // [sp+A0h] [bp-110h]@1
  char v17; // [sp+A2h] [bp-10Eh]@1
  char v18; // [sp+A3h] [bp-10Dh]@1
  char v19; // [sp+A4h] [bp-10Ch]@1
  int v20; // [sp+124h] [bp-8Ch]@10
  __int16 v21; // [sp+128h] [bp-88h]@9
  char v22; // [sp+12Bh] [bp-85h]@11
  char v23; // [sp+12Ch] [bp-84h]@3

  v3 = 0;
  v4 = v2;
  memset(&v14, 0, 0x88u);
  memset(&v19, 0, 0x88u);
  v12 = 0;
  v15 = 0;
  v17 = a1;
  v16 = a2;
  v18 = v4;
  v5 = "FULL";
  if ( !v4 )
    v5 = "PART";
  v6 = 688 * (unsigned __int8)a1;
  sub_1002C2B0(
    &v14,
    0x80u,
    "%s/%d_%d_%s.cmc",
    (char *)&unk_1043D760 + v6,
    (unsigned __int8)a1,
    (unsigned __int16)a2,
    v5);
  sub_1002C2B0(&v23, 0x80u, "%s/%s_%d", (char *)&unk_1043D760 + v6, ".tx_queue", (unsigned __int8)a1);
  v7 = j_FIL_vfs_open(&v23, 14, 1911);
  v8 = v7;
  if ( v7 < 0xFFFFFFC2 && v7 )
  {
    v9 = sub_100612E0(v7);
    v10 = HIDWORD(v9);
    v13 = v9;
    if ( SHIDWORD(v9) >= 0 && (SHIDWORD(v9) > 0 || (_DWORD)v9) )
    {
      while ( !v12 )
      {
        memset(&v19, 0, 0x88u);
        sub_100613E0(v8, v3, 0);
        v3 += sub_100611A0(v8, &v19, 136);
        if ( v21 == v16 )
        {
          v12 = 1;
          if ( !v20 && !v22 )
          {
            v22 = v18;
            sub_1002C120((int)&v19, &v14, 128);
            sub_100613E0(v8, v3 - 136, 0);
            j_FIL_vfs_write(v8, &v19, 136);
          }
        }
        if ( v3 >= (signed __int64)__PAIR__(v10, v13) )
        {
          if ( v12 )
            break;
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:
      sub_100613E0(v8, 0, 2);
      j_FIL_vfs_write(v8, &v14, 136);
      ++word_1043D7F0[v6 / 2];
    }
    sub_10061070(v8);
    result = sub_10028D90(a1, a2, 1);
  }
  else
  {
    result = sub_10028BC0(
               "..\\lib\\adl\\iop_gfds_cmc.c",
               1010,
               0,
               "Failed to open or create CMC transmission queue file.");
  }
  return result;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10061330: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 1043D7F0: using guessed type __int16 word_1043D7F0[];

//----- (1000D770) --------------------------------------------------------
int __cdecl sub_1000D770(unsigned __int8 a1)
{
  unsigned int v1; // eax@1
  unsigned int v2; // edi@1
  int v3; // ebp@1
  __int64 v4; // rax@3
  unsigned int v5; // ebx@3
  int v6; // esi@3
  unsigned int v8; // [sp+8h] [bp-118h]@3
  char v9; // [sp+10h] [bp-110h]@6
  int v10; // [sp+94h] [bp-8Ch]@6
  char v11; // [sp+9Ch] [bp-84h]@1

  sub_1002C2B0(&v11, 0x80u, "%s/%s_%d", (char *)&unk_1043D760 + 688 * a1, ".tx_queue", a1);
  v1 = j_FIL_vfs_open(&v11, 4, 0);
  v2 = v1;
  v3 = 0;
  if ( v1 < 0xFFFFFFC2 )
  {
    if ( v1 )
    {
      v4 = sub_100612E0(v1);
      v5 = HIDWORD(v4);
      v6 = 0;
      v8 = v4;
      if ( SHIDWORD(v4) >= 0 && (SHIDWORD(v4) > 0 || (_DWORD)v4) )
      {
        do
        {
          memset(&v9, 0, 0x88u);
          sub_100613E0(v2, v6, 0);
          v6 += sub_100611A0(v2, &v9, 136);
          sub_10028D90(SBYTE2(v10), v10, 1);
          ++v3;
        }
        while ( v6 < (signed __int64)__PAIR__(v5, v8) );
      }
    }
  }
  sub_100610B0(v2);
  return v3;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1000D880) --------------------------------------------------------
char __usercall sub_1000D880@<al>(void *a1@<edi>, unsigned __int8 a2)
{
  char v2; // bl@1
  unsigned int v3; // eax@1
  unsigned int v4; // esi@1
  char v6; // [sp+8h] [bp-84h]@1

  v2 = 0;
  sub_1002C2B0(&v6, 0x80u, "%s/%s_%d", (char *)&unk_1043D760 + 688 * a2, ".tx_queue", a2);
  v3 = j_FIL_vfs_open(&v6, 4, 1911);
  v4 = v3;
  if ( v3 < 0xFFFFFFC2 && v3 )
  {
    sub_100613E0(v3, 0, 0);
    if ( sub_100611A0(v4, a1, 136) == 136 )
      v2 = 1;
    sub_10061070(v4);
  }
  return v2;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1000D930) --------------------------------------------------------
int sub_1000D930()
{
  unsigned __int8 v0; // bl@1
  int v1; // esi@1
  void *v2; // edi@1
  int result; // eax@8
  int v4; // [sp+Ch] [bp-1Ch]@1
  int v5; // [sp+10h] [bp-18h]@1
  int v6; // [sp+14h] [bp-14h]@1
  int v7; // [sp+18h] [bp-10h]@1
  void *v8; // [sp+1Ch] [bp-Ch]@1
  int v9; // [sp+20h] [bp-8h]@1
  int v10; // [sp+24h] [bp-4h]@1

  v0 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v1 = 0;
  v2 = &unk_10440868;
  do
  {
    HIWORD(v4) = v0;
    LOWORD(v4) = 4;
    v6 = 5500;
    v7 = 300;
    v9 = 1300;
    v8 = &unk_104400B8;
    LOWORD(v10) = 40;
    LOBYTE(v5) = v0;
    if ( v1 )
    {
      if ( v1 == 1 )
      {
        BYTE1(v5) = 47;
      }
      else if ( v1 == 2 )
      {
        BYTE1(v5) = 48;
      }
    }
    else
    {
      BYTE1(v5) = 49;
    }
    sub_10060A60(79, 5000);
    sub_100059A0(v2, (int)&v4);
    result = sub_10060A00(79);
    ++v0;
    ++v1;
    v2 = (char *)v2 + 84;
  }
  while ( v0 < 3u );
  return result;
}

//----- (1000DA00) --------------------------------------------------------
BOOL sub_1000DA00()
{
  char v0; // bl@1
  char v1; // al@1

  v0 = sub_10032340(0, 2u);
  v1 = sub_10032340(1u, 2u);
  return v0 || v1;
}

//----- (1000DA30) --------------------------------------------------------
BOOL __thiscall sub_1000DA30(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE3(v2) = 10;
  return sub_10033370((_BYTE *)&v2 + 3) && BYTE3(v2) == 3;
}

//----- (1000DAB0) --------------------------------------------------------
char __usercall sub_1000DAB0@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>)
{
  int v2; // esi@1
  char result; // al@1
  unsigned int v4; // eax@3
  unsigned int v5; // eax@3
  unsigned int v6; // esi@3
  unsigned int v7; // [sp+8h] [bp-114h]@1
  int v8; // [sp+Ch] [bp-110h]@1
  char v9; // [sp+10h] [bp-10Ch]@1
  int v10; // [sp+90h] [bp-8Ch]@3
  char v11; // [sp+98h] [bp-84h]@3

  v2 = a1;
  memset(&v9, 0, 0x88u);
  v8 = 48;
  sub_10060E40(41105, &v7, 4, &v8);
  result = sub_1000D880(&v9, a2);
  if ( result )
  {
    if ( v2 )
    {
      v4 = 688 * a2;
      byte_1043D7E0[v4] = 1;
      dword_1043D7E4[v4 / 4] = v2;
      v10 = v2;
      sub_1002C2B0(&v11, 0x80u, "%s/%s_%d", (char *)&unk_1043D760 + v4, ".tx_queue", a2);
      v5 = j_FIL_vfs_open(&v11, 6, 1911);
      v6 = v5;
      if ( v5 < 0xFFFFFFC2 )
      {
        if ( v5 )
        {
          sub_100613E0(v5, 0, 0);
          j_FIL_vfs_write(v6, &v9, 136);
          sub_10061070(v6);
        }
      }
    }
    v7 = v7 & 0xFFFFFFF7 | 0x30;
    result = sub_10060ED0(41105, (int)&v7, 4);
  }
  return result;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10061330: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 1043D7E4: using guessed type int dword_1043D7E4[];

//----- (1000DBE0) --------------------------------------------------------
signed int __cdecl sub_1000DBE0(int a1, int a2, void *a3, int a4)
{
  unsigned int v4; // eax@2
  unsigned int v5; // esi@2
  signed int v6; // edi@4
  signed int result; // eax@4
  char v8; // [sp+10h] [bp-8Ch]@1

  memset(&v8, 0, 0x88u);
  if ( sub_1000D880(&v8, *(_BYTE *)(a1 + 2)) )
  {
    v4 = j_FIL_vfs_open(&v8, 4, 0);
    v5 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      v6 = sub_100611F0(v4, a3, a4, a2, 0);
      sub_10061070(v5);
      result = v6;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1000DCB0) --------------------------------------------------------
int __usercall sub_1000DCB0@<eax>(int a1@<eax>, int a2@<ecx>, int a3@<edi>, int a4)
{
  int v4; // esi@1
  bool v5; // zf@1
  int result; // eax@1
  int v7; // esi@2

  v4 = a2;
  v5 = sub_10061120(a3, a1, a3, a1 + a2, a4 - a1 - a2) == 0;
  result = a4;
  if ( v5 )
  {
    v7 = a4 - v4;
    sub_10061310(a3, v7, (unsigned __int64)v7 >> 32);
    result = v7;
  }
  return result;
}

//----- (1000DD00) --------------------------------------------------------
bool __cdecl sub_1000DD00(unsigned __int8 a1)
{
  char v1; // cl@0
  unsigned int v2; // esi@1
  __int16 v3; // ax@1
  char v4; // al@6
  void *v5; // ecx@7
  char v6; // bl@7
  int v7; // eax@7
  int v8; // eax@8
  char v9; // al@11
  bool result; // al@20
  char v11; // [sp+7h] [bp-1h]@6
  bool v12; // [sp+Ch] [bp+4h]@4

  v2 = 688 * a1;
  v3 = word_1043D67C[v2 / 2];
  byte_1043D860[v2] = 4;
  v12 = !v3 || v3 && dword_1043D7E8[v2 / 4] + dword_1043D7E4[v2 / 4] <= (unsigned int)(unsigned __int16)v3 << 10;
  v4 = v1;
  v11 = v1;
  if ( (unsigned __int8)v1 >= 4u )
    goto LABEL_22;
  while ( 1 )
  {
    v5 = (void *)(unsigned __int8)v4;
    v6 = *(&byte_1043D672[v4] + v2);
    v7 = (unsigned __int8)*(&byte_1043D672[v4] + v2);
    if ( !v7 )
    {
      v9 = sub_1000DA30(v5);
LABEL_16:
      if ( v9 )
      {
        byte_1043D860[v2] = v6;
        byte_1043D7E1[v2] = 0;
      }
      goto LABEL_18;
    }
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( v8 == 1 && v12 )
      {
        v9 = sub_1000DA00();
        goto LABEL_16;
      }
    }
    else if ( v12 && (unsigned int)dword_1043D7E4[v2 / 4] < 0x514 )
    {
      v9 = sub_1000DA00();
      goto LABEL_16;
    }
LABEL_18:
    if ( byte_1043D860[v2] != 4 )
      break;
    v4 = v11++ + 1;
    if ( (unsigned __int8)v11 >= 4u )
    {
      result = byte_1043D860[v2] == 4;
      byte_1043D7E1[v2] = result;
      return result;
    }
  }
  byte_1043D861[v2] = v11;
LABEL_22:
  result = byte_1043D860[v2] == 4;
  byte_1043D7E1[v2] = result;
  return result;
}
// 1043D67C: using guessed type __int16 word_1043D67C[];
// 1043D7E4: using guessed type int dword_1043D7E4[];
// 1043D7E8: using guessed type int dword_1043D7E8[];

//----- (1000DE10) --------------------------------------------------------
char __fastcall sub_1000DE10(unsigned __int8 a1)
{
  unsigned __int8 v1; // bl@1
  unsigned int v2; // esi@1
  int v3; // eax@1
  char v5[9]; // [sp+Fh] [bp-A1h]@1
  int v6; // [sp+18h] [bp-98h]@1
  int v7; // [sp+1Ch] [bp-94h]@1
  char v8; // [sp+20h] [bp-90h]@1
  int v9; // [sp+A4h] [bp-Ch]@1

  v1 = a1;
  v2 = 688 * a1;
  *(_QWORD *)&v5[1] = 0i64;
  v6 = 0;
  v7 = 0;
  *(_QWORD *)v5 = (unsigned __int8)byte_1043D860[v2];
  byte_1043D7E0[v2] = 0;
  sub_1000D880(&v8, a1);
  v3 = dword_1043D7E4[v2 / 4];
  *(_DWORD *)&v5[1] = (char *)&unk_1043D5BC + v2;
  *(_WORD *)&v5[5] = v1;
  v5[7] = v5[0];
  v7 = 1;
  v6 = v3;
  sub_10028D90(SBYTE2(v9), v9, 2);
  return sub_10005740((int)&unk_10440868 + 84 * (unsigned __int8)v5[0], (int)&v5[1], 0);
}
// 1043D7E4: using guessed type int dword_1043D7E4[];

//----- (1000DEE0) --------------------------------------------------------
char __cdecl sub_1000DEE0(unsigned __int8 a1, __int16 a2, char a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // ebp@1
  int v5; // esi@3
  bool v6; // zf@3
  unsigned int v7; // esi@6
  unsigned int v8; // eax@6
  unsigned int v9; // edi@6
  __int64 v10; // rax@8
  unsigned int v11; // ebx@8
  int v12; // eax@16
  unsigned int v13; // edx@16
  char result; // al@19
  char v15; // [sp+13h] [bp-125h]@1
  int v16; // [sp+14h] [bp-124h]@8
  char v17; // [sp+1Ch] [bp-11Ch]@1
  char v18; // [sp+28h] [bp-110h]@3
  char v19; // [sp+2Ch] [bp-10Ch]@1
  int v20; // [sp+ACh] [bp-8Ch]@21
  __int16 v21; // [sp+B0h] [bp-88h]@2
  char v22; // [sp+B4h] [bp-84h]@6

  sub_100608D0(79, (int)&v17);
  v3 = a1;
  v15 = 0;
  v4 = 0;
  if ( sub_1000D880(&v19, a1) && a2 == v21 )
  {
    v5 = 172 * a1;
    v6 = (v18 & 1) == 0;
    dword_1043D7E4[v5] = 0;
    dword_1043D7EC[v5] = 0;
    byte_1043D863[v5 * 4] = 0;
    dword_1043D614[v5] = 0;
    dword_1043D618[v5] = 0;
    dword_1043D61C[v5] = 0;
    dword_1043D620[v5] = 0;
    dword_1043D624[v5] = 0;
    dword_1043D628[v5] = 0;
    dword_1043D62C[v5] = 0;
    dword_1043D630[v5] = 0;
    dword_1043D634[v5] = 0;
    dword_1043D638[v5] = 0;
    if ( v6 )
    {
      sub_10060A60(79, 5000);
      sub_10004C30((int)&unk_1043D5BC + v5 * 4);
      sub_10060A00(79);
    }
    else
    {
      sub_10004C30((int)&unk_1043D5BC + v5 * 4);
    }
  }
  v7 = 688 * a1;
  sub_1002C2B0(&v22, 0x80u, "%s/%s_%d", (char *)&unk_1043D760 + v7, ".tx_queue", a1);
  v8 = j_FIL_vfs_open(&v22, 6, 1911);
  v9 = v8;
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    v10 = sub_100612E0(v8);
    v11 = HIDWORD(v10);
    v16 = v10;
    if ( SHIDWORD(v10) >= 0 && (SHIDWORD(v10) > 0 || (_DWORD)v10) )
    {
      do
      {
        if ( v15 )
          break;
        memset(&v19, 0, 0x88u);
        sub_100613E0(v9, v4, 0);
        v4 += sub_100611A0(v9, &v19, 136);
        if ( v21 == a2 )
        {
          v15 = 1;
          if ( sub_1002C1E0(&v19, 0x80u) > 0 && sub_10061390((int)&v19) )
            j_FIL_vfs_delete(&v19);
          v4 -= 136;
          v12 = sub_1000DCB0(v4, 136, v9, v16);
          --word_1043D7F0[v7 / 2];
          v16 = v12;
          v11 = v13;
        }
      }
      while ( v4 < (signed __int64)__PAIR__(v11, v16) );
    }
    v3 = a1;
  }
  sub_10028D30(v3, a2, (a3 != 0) + 3);
  sub_100610B0(v9);
  result = sub_1000D880(&v19, v3);
  if ( result )
  {
    byte_1043D7E0[v7] = v20 != 0;
  }
  else
  {
    byte_1043D7E0[v7] = 0;
    byte_1043D865[v7] = 0;
  }
  return result;
}
// 100610D0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1043D614: using guessed type int dword_1043D614[];
// 1043D618: using guessed type int dword_1043D618[];
// 1043D61C: using guessed type int dword_1043D61C[];
// 1043D620: using guessed type int dword_1043D620[];
// 1043D624: using guessed type int dword_1043D624[];
// 1043D628: using guessed type int dword_1043D628[];
// 1043D62C: using guessed type int dword_1043D62C[];
// 1043D630: using guessed type int dword_1043D630[];
// 1043D634: using guessed type int dword_1043D634[];
// 1043D638: using guessed type int dword_1043D638[];
// 1043D7E4: using guessed type int dword_1043D7E4[];
// 1043D7EC: using guessed type int dword_1043D7EC[];
// 1043D7F0: using guessed type __int16 word_1043D7F0[];

//----- (1000E190) --------------------------------------------------------
char __cdecl sub_1000E190(int a1, char a2)
{
  unsigned int v2; // esi@1
  unsigned __int8 v3; // al@1
  char result; // al@6
  char v5; // cl@11
  bool v6; // zf@13
  unsigned int v7; // eax@19
  unsigned int v8; // edi@19
  int v9; // eax@21
  unsigned __int8 v10; // [sp+Ch] [bp-124h]@1
  int v11; // [sp+10h] [bp-120h]@1
  int v12; // [sp+14h] [bp-11Ch]@1
  int v13; // [sp+18h] [bp-118h]@1
  int v14; // [sp+1Ch] [bp-114h]@1
  char v15; // [sp+20h] [bp-110h]@1
  unsigned int v16; // [sp+A4h] [bp-8Ch]@12
  char v17; // [sp+ACh] [bp-84h]@1

  memset(&v15, 0, 0x88u);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v10 = *(_BYTE *)(a1 + 2);
  v2 = 688 * v10;
  sub_1002C2B0(&v17, 0x80u, "%s/%s_%d", (char *)&unk_1043D760 + v2, ".tx_queue", v10);
  byte_1043D7F8[v2] = 6;
  v3 = sub_1002CC90(&a2, 1u, (int)&unk_1008C228, 2, 15, 255);
  if ( v3 != -1 )
    byte_1043D7F8[v2] = byte_1008C229[2 * v3];
  if ( a2 )
  {
    if ( a2 == 4 )
    {
      sub_1002D550(0xD4u);
    }
    else if ( a2 == 13 )
    {
      result = 0;
      dword_1043D614[v2 / 4] = 0;
      dword_1043D618[v2 / 4] = 0;
      dword_1043D61C[v2 / 4] = 0;
      dword_1043D620[v2 / 4] = 0;
      dword_1043D624[v2 / 4] = 0;
      dword_1043D628[v2 / 4] = 0;
      dword_1043D62C[v2 / 4] = 0;
      dword_1043D630[v2 / 4] = 0;
      dword_1043D634[v2 / 4] = 0;
      dword_1043D638[v2 / 4] = 0;
      if ( byte_1043D864[v2] )
      {
        byte_1043D7E0[v2] = 1;
        byte_1043D864[v2] = 0;
      }
      else
      {
        byte_1043D862[v2] = 0;
      }
      return result;
    }
    ++byte_1043D863[v2];
    sub_100608D0(79, (int)&v11);
    if ( (unsigned __int8)byte_1043D863[v2] <= (unsigned __int8)byte_1043D671[v2] )
    {
      v6 = (v14 & 1) == 0;
      byte_1043D864[v2] = 1;
      byte_1043D862[v2] = 1;
      if ( v6 )
      {
        sub_10060A60(79, 5000);
        sub_10004C30((int)&unk_1043D5BC + v2);
        result = sub_10060A00(79);
      }
      else
      {
        result = (unsigned int)sub_10004C30((int)&unk_1043D5BC + v2);
      }
    }
    else
    {
      v5 = ++byte_1043D861[v2];
      byte_1043D863[v2] = 0;
      sub_1000DD00(v10);
      if ( byte_1043D7E1[v2] )
      {
        sub_1000D880(&v15, v10);
        result = sub_1000DEE0(BYTE2(v16), v16, 1);
      }
      else
      {
        v6 = (v14 & 1) == 0;
        byte_1043D864[v2] = 1;
        byte_1043D862[v2] = 1;
        if ( v6 )
        {
          sub_10060A60(79, 5000);
          sub_10004C30((int)&unk_1043D5BC + v2);
          result = sub_10060A00(79);
        }
        else
        {
          result = (unsigned int)sub_10004C30((int)&unk_1043D5BC + v2);
        }
      }
    }
  }
  else
  {
    v7 = j_FIL_vfs_open(&v17, 6, 1911);
    v8 = v7;
    if ( v7 < 0xFFFFFFC2 && v7 )
    {
      sub_100613E0(v7, 0, 0);
      sub_100611A0(v8, &v15, 136);
      j_FIL_vfs_delete(&v15);
      v9 = sub_100612E0(v8);
      sub_1000DCB0(0, 136, v8, v9);
      sub_10061070(v8);
      sub_10028D90(SBYTE2(v16), v16, 6);
    }
    result = 0;
    dword_1043D614[v2 / 4] = 0;
    dword_1043D618[v2 / 4] = 0;
    dword_1043D61C[v2 / 4] = 0;
    dword_1043D620[v2 / 4] = 0;
    dword_1043D624[v2 / 4] = 0;
    dword_1043D628[v2 / 4] = 0;
    dword_1043D62C[v2 / 4] = 0;
    dword_1043D630[v2 / 4] = 0;
    dword_1043D634[v2 / 4] = 0;
    dword_1043D638[v2 / 4] = 0;
    dword_1043D7EC[v2 / 4] = 0;
    dword_1043D7E4[v2 / 4] = 0;
    byte_1043D862[v2] = 0;
    byte_1043D863[v2] = 0;
  }
  return result;
}
// 100610D0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1043D614: using guessed type int dword_1043D614[];
// 1043D618: using guessed type int dword_1043D618[];
// 1043D61C: using guessed type int dword_1043D61C[];
// 1043D620: using guessed type int dword_1043D620[];
// 1043D624: using guessed type int dword_1043D624[];
// 1043D628: using guessed type int dword_1043D628[];
// 1043D62C: using guessed type int dword_1043D62C[];
// 1043D630: using guessed type int dword_1043D630[];
// 1043D634: using guessed type int dword_1043D634[];
// 1043D638: using guessed type int dword_1043D638[];
// 1043D7E4: using guessed type int dword_1043D7E4[];
// 1043D7EC: using guessed type int dword_1043D7EC[];

//----- (1000E560) --------------------------------------------------------
char __cdecl sub_1000E560(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  void *v3; // ecx@1
  char v4; // cl@5
  char v6; // [sp+4h] [bp-10Ch]@7
  char v7; // [sp+8Ch] [bp-84h]@9

  v2 = sub_1002C660(v1);
  if ( v2 == 4 )
  {
    LOBYTE(v2) = sub_1002C5E0(v3);
    if ( (_BYTE)v2 == 1 )
    {
      v2 = *(_BYTE *)a1;
      switch ( v2 )
      {
        case 0:
          LOBYTE(v2) = *(_BYTE *)(a1 + 1);
          if ( !byte_1043D865[688 * *(_BYTE *)(a1 + 1)] )
          {
            v4 = *(_BYTE *)(a1 + 8);
            LOBYTE(v2) = sub_1000D510(v2, *(_WORD *)(a1 + 2));
          }
          break;
        case 1:
          LOBYTE(v2) = sub_1000DEE0(*(_BYTE *)(a1 + 1), *(_WORD *)(a1 + 2), 0);
          break;
        case 2:
          LOBYTE(v2) = sub_1000D880(&v6, *(_BYTE *)(a1 + 1));
          if ( (_BYTE)v2 )
          {
            v2 = 688 * *(_BYTE *)(a1 + 1);
            byte_1043D7E0[v2] = 0;
            byte_1043D865[688 * *(_BYTE *)(a1 + 1)] = 1;
          }
          break;
        case 3:
          sub_10028C70(*(_BYTE *)(a1 + 1));
          sub_1002C2B0(
            &v7,
            0x80u,
            "%s/%s_%d",
            (char *)&unk_1043D760 + 688 * *(_BYTE *)(a1 + 1),
            ".tx_queue",
            *(_BYTE *)(a1 + 1));
          if ( sub_1000D880(&v6, *(_BYTE *)(a1 + 1)) )
            j_FIL_vfs_delete(&v6);
          LOBYTE(v2) = j_FIL_vfs_delete(&v7);
          break;
        case 4:
          sub_10028C30();
          if ( sub_10061360((int)"/mnt/sys_nand0/cmc/tx_logs") )
          {
            sub_10061420("/mnt/sys_nand0/cmc/tx_logs");
            j_FIL_vfs_mkdir("/mnt/sys_nand0/cmc/tx_logs", 1911);
          }
          LOBYTE(v2) = sub_10061360((int)"/mnt/card1/cmc/tx_logs");
          if ( (_BYTE)v2 )
          {
            sub_10061420("/mnt/card1/cmc/tx_logs");
            LOBYTE(v2) = j_FIL_vfs_mkdir("/mnt/card1/cmc/tx_logs", 1911);
          }
          break;
        case 6:
          LOBYTE(v2) = sub_1000DAB0(*(_DWORD *)(a1 + 4), *(_BYTE *)(a1 + 1));
          break;
        case 5:
          LOBYTE(v2) = sub_10028CC0(*(_BYTE *)(a1 + 1), *(_WORD *)(a1 + 2), &byte_10080D49);
          break;
        default:
          return v2;
      }
    }
  }
  return v2;
}
// 100610D0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 10061170: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);

//----- (1000E7A0) --------------------------------------------------------
int __usercall sub_1000E7A0@<eax>(unsigned __int8 a1@<al>)
{
  return sub_100056F0(
           (char *)&unk_1043D5BC + 688 * a1,
           (int)sub_1000E190,
           byte_1043D670[688 * a1],
           (int)&dword_1043D614[172 * a1],
           5,
           (int)sub_1000DA60,
           (int)sub_1000DBE0,
           0);
}
// 1000DA60: using guessed type int sub_1000DA60();
// 1043D614: using guessed type int dword_1043D614[];

//----- (1000E7E0) --------------------------------------------------------
char sub_1000E7E0()
{
  void *v0; // ecx@1
  int v1; // eax@1
  void *v2; // ecx@1
  int v3; // ebp@3
  void *v4; // esi@3
  bool v5; // zf@6
  bool v6; // cl@12
  unsigned __int8 v8; // [sp+0h] [bp-A0h]@3
  int v9; // [sp+4h] [bp-9Ch]@3
  int v10; // [sp+8h] [bp-98h]@1
  int v11; // [sp+Ch] [bp-94h]@1
  int v12; // [sp+10h] [bp-90h]@1
  char v13; // [sp+14h] [bp-8Ch]@11
  int v14; // [sp+94h] [bp-Ch]@12

  v10 = 0;
  v11 = 0;
  v12 = 0;
  memset(&unk_1043D5B8, 0, 0x2B00u);
  sub_1000D930();
  v1 = sub_1002C660(v0);
  if ( v1 == 4 )
  {
    LOBYTE(v1) = sub_1002C5E0(v2);
    if ( (_BYTE)v1 == 1 )
    {
      dword_10A08A5C = sub_10060900();
      v9 = 54;
      sub_10060ED0(41105, (int)&v9, 4);
      v8 = 0;
      v3 = 18000;
      v4 = &unk_1043D640;
      do
      {
        *(_BYTE *)v4 = 0;
        if ( !sub_10060D80(v3, (int)v4 + 4, 284) && sub_1002C1E0((char *)v4 + 4, 0x20u) > 0 )
        {
          *(_BYTE *)v4 = 1;
          j_reg_get_tag_hdr(&v10, v3, v3);
          v5 = *((_BYTE *)v4 + 46) == 0;
          *((_DWORD *)v4 - 1) = v11;
          if ( v5 )
            sub_1002C2E0((const char *)v4 + 288, "/mnt/sys_nand0/cmc/tx_logs", 128);
          else
            sub_1002C2E0((const char *)v4 + 288, "/mnt/card1/cmc/tx_logs", 128);
          if ( !sub_10061360((int)v4 + 288) )
            j_FIL_vfs_mkdir((char *)v4 + 288, 1911);
          memset(&v13, 0, 0x88u);
          if ( sub_1000D880(&v13, v8) )
          {
            *((_WORD *)v4 + 216) = sub_1000D770(v8);
            v6 = v14 != 0;
            *((_DWORD *)v4 + 105) = v14;
            *((_BYTE *)v4 + 416) = v6;
          }
          sub_1000E7A0(v8);
          *((char *)v4 - 136) = 1;
        }
        LOBYTE(v1) = v8 + 1;
        ++v3;
        v4 = (char *)v4 + 688;
        ++v8;
      }
      while ( v8 < 0x10u );
    }
  }
  return v1;
}
// 10060D50: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);
// 10061170: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);
// 10A08A5C: using guessed type int dword_10A08A5C;

//----- (1000E990) --------------------------------------------------------
char __thiscall sub_1000E990(void *this)
{
  int v1; // eax@1
  void *v2; // ecx@1
  int v3; // ebp@3
  void *v4; // esi@3
  char v5; // bl@8
  unsigned __int8 v6; // di@10
  int v7; // eax@13
  char v8; // cl@13
  unsigned __int8 v9; // al@18
  unsigned int v10; // eax@25
  char v12; // [sp+2h] [bp-AAh]@25
  char v13; // [sp+3h] [bp-A9h]@1
  int v14; // [sp+4h] [bp-A8h]@3
  unsigned int v15; // [sp+8h] [bp-A4h]@25
  int v16; // [sp+Ch] [bp-A0h]@1
  int v17; // [sp+10h] [bp-9Ch]@1
  int v18; // [sp+14h] [bp-98h]@1
  int v19; // [sp+18h] [bp-94h]@1
  char v20; // [sp+1Ch] [bp-90h]@20
  int v21; // [sp+9Ch] [bp-10h]@30
  unsigned int v22; // [sp+A0h] [bp-Ch]@22

  v17 = 0;
  v18 = 0;
  v19 = 0;
  v16 = 8;
  v13 = 5;
  v1 = sub_1002C660(this);
  if ( v1 == 4 )
  {
    LOBYTE(v1) = sub_1002C5E0(v2);
    if ( (_BYTE)v1 == 1 )
    {
      LOBYTE(v14) = 0;
      v3 = 18000;
      v4 = &unk_1043D760;
      do
      {
        if ( *((char *)v4 - 288) )
        {
          if ( !sub_10061360((int)v4) )
            j_FIL_vfs_mkdir(v4, 1911);
          j_reg_get_tag_hdr(&v17, v3, v3);
          if ( *((_DWORD *)v4 - 73) != v18 )
          {
            v5 = *((char *)v4 - 240);
            *((_DWORD *)v4 - 73) = v18;
            sub_10060D80(v3, (int)v4 - 284, 284);
            if ( *((char *)v4 - 240) != v5 )
              sub_1000E7A0(v14);
          }
          v6 = v14;
          if ( *((_BYTE **)v4 - 101) == (char *)v4 - 404 )
          {
            if ( !*((_BYTE *)v4 + 258) )
              sub_1000DD00(v14);
            v7 = 84 * *((_BYTE *)v4 + 256);
            *((_BYTE *)v4 + 157) = byte_1044089A[v7];
            v8 = *((_BYTE *)v4 + 129);
            *((_BYTE *)v4 + 152) = 0;
            if ( v8 )
              *((_BYTE *)v4 + 152) = 4;
            if ( *((_BYTE *)v4 + 128) && !v8 )
            {
              sub_10005BF0((int)&unk_10440868 + v7);
              sub_1000DE10(v14);
            }
          }
          else
          {
            *((_BYTE *)v4 + 157) = byte_1044089A[84 * *((_BYTE *)v4 + 256)];
            v9 = sub_1002CC90((char *)v4 + 157, 1u, (int)&unk_1008C20C, 2, 14, 255);
            if ( v9 != -1 )
              *((_BYTE *)v4 + 152) = byte_1008C20D[2 * v9];
          }
          if ( sub_1000D880(&v20, v6) )
          {
            if ( *((_BYTE *)v4 + 261) )
            {
              sub_1000DEE0(BYTE2(v22), v22, 0);
            }
            else if ( *((_BYTE *)v4 + 129) )
            {
              sub_10028D90(SBYTE2(v22), v22, 1);
            }
            else
            {
              sub_10060E40(41105, &v15, 4, &v16);
              sub_10060E40(41097, &v12, 1, &v13);
              v10 = v15;
              if ( !v12 && !(v15 & 8)
                || v15 & 8 && (unsigned int)(sub_10060900() - dword_10A08A5C) > 0x7D0 && (v10 = v15, !(v15 & 0x10)) )
              {
                if ( !v21 )
                {
                  v15 = v10 & 0xFFFFFFCF | 8;
                  sub_10060ED0(41105, (int)&v15, 4);
                  sub_10028EE0(SBYTE2(v22), v22, &v20, SBYTE3(v22));
                  dword_10A08A5C = sub_10060900();
                }
              }
            }
          }
        }
        LOBYTE(v1) = v14 + 1;
        ++v3;
        v4 = (char *)v4 + 688;
        LOBYTE(v14) = v14 + 1;
      }
      while ( (unsigned __int8)v14 < 0x10u );
    }
  }
  return v1;
}
// 10060D50: using guessed type int __cdecl j_reg_get_tag_hdr(_DWORD, _DWORD, _DWORD);
// 10061170: using guessed type int __cdecl j_FIL_vfs_mkdir(_DWORD, _DWORD);
// 10A08A5C: using guessed type int dword_10A08A5C;

//----- (1000EC70) --------------------------------------------------------
void *sub_1000EC70()
{
  return &unk_10441678;
}

//----- (1000EC80) --------------------------------------------------------
char sub_1000EC80()
{
  char *v0; // eax@3
  char result; // al@3

  dword_10441670 = sub_10060900();
  if ( byte_10441115 == 32 )
  {
    memcpy_0(&unk_10441118, &unk_10441140, 0x4D8u);
    --byte_10441115;
  }
  v0 = (char *)&unk_10441118 + 40 * (unsigned __int8)byte_10441115;
  *(_DWORD *)v0 = 0;
  *((_DWORD *)v0 + 1) = 0;
  *((_DWORD *)v0 + 2) = 0;
  *((_DWORD *)v0 + 3) = 0;
  *((_DWORD *)v0 + 4) = 0;
  *((_DWORD *)v0 + 5) = 0;
  *((_DWORD *)v0 + 6) = 0;
  *((_DWORD *)v0 + 7) = 0;
  *((_DWORD *)v0 + 8) = 0;
  *((_DWORD *)v0 + 9) = 0;
  result = sub_1000F3E0((int)v0);
  ++byte_10441115;
  return result;
}
// 10441115: using guessed type char byte_10441115;
// 10441670: using guessed type int dword_10441670;

//----- (1000ED00) --------------------------------------------------------
int sub_1000ED00()
{
  int v1; // [sp+0h] [bp-1Ch]@1
  int v2; // [sp+4h] [bp-18h]@1
  int v3; // [sp+8h] [bp-14h]@1
  int v4; // [sp+Ch] [bp-10h]@1
  void *v5; // [sp+10h] [bp-Ch]@1
  int v6; // [sp+14h] [bp-8h]@1
  int v7; // [sp+18h] [bp-4h]@1

  v2 = 0;
  v7 = 0;
  v3 = 5500;
  v4 = 300;
  v6 = 1300;
  v5 = &unk_10440968;
  v1 = (unsigned __int16)((byte_10441114 != 1) + 9);
  LOWORD(v7) = 40;
  LOWORD(v2) = 8193;
  sub_10060A60(79, 5000);
  sub_100059A0(&unk_10441678, (int)&v1);
  return sub_10060A00(79);
}
// 10441114: using guessed type char byte_10441114;

//----- (1000EDA0) --------------------------------------------------------
BOOL sub_1000EDA0()
{
  char v0; // bl@1
  char v1; // al@1

  v0 = sub_10032340(0, 0x10u);
  v1 = sub_10032340(1u, 0x10u);
  return v0 || v1;
}

//----- (1000EDD0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1000EDD0(int a1, char a2))(int, int)
{
  int (__cdecl *result)(int, int); // eax@7
  int v3; // [sp+0h] [bp-10h]@1
  int v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  if ( !a2 )
  {
    if ( byte_10441115 )
      --byte_10441115;
    goto LABEL_11;
  }
  if ( a2 == 4 )
  {
    sub_1002D550(0xD4u);
    goto LABEL_6;
  }
  if ( a2 == 13 )
  {
LABEL_11:
    result = 0;
    dword_104416CC = 0;
    dword_104416D0 = 0;
    dword_104416D4 = 0;
    dword_104416D8 = 0;
    dword_104416DC = 0;
    dword_104416E0 = 0;
    dword_104416E4 = 0;
    dword_104416E8 = 0;
    dword_104416EC = 0;
    dword_104416F0 = 0;
    return result;
  }
LABEL_6:
  sub_100608D0(79, (int)&v3);
  if ( v6 & 1 )
  {
    result = sub_10004C30(a1);
  }
  else
  {
    sub_10060A60(79, 5000);
    sub_10004C30(a1);
    result = (int (__cdecl *)(int, int))sub_10060A00(79);
  }
  return result;
}
// 10441115: using guessed type char byte_10441115;
// 104416CC: using guessed type int dword_104416CC;
// 104416D0: using guessed type int dword_104416D0;
// 104416D4: using guessed type int dword_104416D4;
// 104416D8: using guessed type int dword_104416D8;
// 104416DC: using guessed type int dword_104416DC;
// 104416E0: using guessed type int dword_104416E0;
// 104416E4: using guessed type int dword_104416E4;
// 104416E8: using guessed type int dword_104416E8;
// 104416EC: using guessed type int dword_104416EC;
// 104416F0: using guessed type int dword_104416F0;

//----- (1000EEA0) --------------------------------------------------------
signed int __cdecl sub_1000EEA0(int a1, int a2, int a3, unsigned int a4)
{
  char *v4; // esi@1
  char v5; // dl@5
  int v6; // eax@5
  int v7; // ecx@5
  int v8; // eax@5
  int v9; // ecx@5
  int v11; // edx@8
  __int16 v12; // cx@8
  int v13; // eax@8
  __int16 v14; // cx@8
  char v15; // [sp+8h] [bp-34h]@1
  __int16 v16; // [sp+Ah] [bp-32h]@5
  int v17; // [sp+Ch] [bp-30h]@1
  char v18; // [sp+10h] [bp-2Ch]@1
  char v19; // [sp+12h] [bp-2Ah]@8
  int v20; // [sp+14h] [bp-28h]@5
  int v21; // [sp+18h] [bp-24h]@5
  int v22; // [sp+1Ch] [bp-20h]@8
  int v23; // [sp+20h] [bp-1Ch]@8
  int v24; // [sp+24h] [bp-18h]@5
  int v25; // [sp+28h] [bp-14h]@5
  __int16 v26; // [sp+2Ch] [bp-10h]@8
  char v27; // [sp+2Eh] [bp-Eh]@8
  char v28; // [sp+2Fh] [bp-Dh]@8
  char v29; // [sp+35h] [bp-7h]@8
  char v30; // [sp+36h] [bp-6h]@8

  v4 = (char *)&unk_104410F0 + 40 * (unsigned __int8)byte_10441115;
  sub_1002C6F0((int)&v17, dword_104410F8[10 * (unsigned __int8)byte_10441115]);
  sub_1002C910((int)&v15, *((_DWORD *)v4 + 2));
  sub_1002C910((int)&v18, *((_DWORD *)v4 + 3));
  if ( byte_10441114 )
  {
    if ( byte_10441114 != 1 )
      sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds_pos_rep.c", 661, 0, "Invalid TX Mode for GFDS Position Reports");
    if ( a4 >= 0x18 )
    {
      HIWORD(v20) = BYTE2(v17) & 0x3F | (((unsigned __int16)(16 * BYTE1(v17)) | v17 & 0xF) << 7);
      LOBYTE(v21) = v15;
      LOWORD(v24) = *((_WORD *)v4 + 8);
      HIWORD(v24) = *((_WORD *)v4 + 9);
      LOWORD(v25) = *((_WORD *)v4 + 12);
      BYTE2(v25) = v4[29];
      v5 = v4[30];
      *(_WORD *)((char *)&v21 + 1) = v16;
      v6 = *(_DWORD *)v4;
      BYTE3(v25) = v5;
      v7 = *((_DWORD *)v4 + 1);
      LOBYTE(v20) = 1;
      *(_DWORD *)a3 = v20;
      *(_DWORD *)(a3 + 4) = v21;
      *(_DWORD *)(a3 + 8) = v6;
      v8 = v24;
      *(_DWORD *)(a3 + 12) = v7;
      v9 = v25;
      *(_DWORD *)(a3 + 16) = v8;
      *(_DWORD *)(a3 + 20) = v9;
      return 24;
    }
    return -26;
  }
  if ( a4 < 0x24 )
    return -26;
  BYTE1(v20) = v4[31];
  HIWORD(v20) = BYTE2(v17) & 0x3F | (((unsigned __int16)(16 * BYTE1(v17)) | v17 & 0xF) << 7);
  LOBYTE(v21) = v15;
  v11 = *(_DWORD *)v4;
  v12 = *((_WORD *)v4 + 8);
  *(_WORD *)((char *)&v21 + 1) = v16;
  v13 = *((_DWORD *)v4 + 1);
  v22 = v11;
  LOWORD(v11) = *((_WORD *)v4 + 9);
  v23 = v13;
  LOWORD(v13) = *((_WORD *)v4 + 10);
  LOWORD(v24) = v12;
  v14 = *((_WORD *)v4 + 11);
  HIWORD(v24) = v11;
  LOWORD(v11) = *((_WORD *)v4 + 13);
  LOWORD(v25) = v13;
  LOBYTE(v13) = v4[28];
  HIWORD(v25) = v14;
  LOBYTE(v20) = 0;
  v26 = v11;
  v27 = v13;
  sub_1002C120((int)&v28, v4 + 32, 6);
  v30 = v19;
  v29 = v18;
  qmemcpy((void *)a3, &v20, 0x24u);
  return 36;
}
// 104410F8: using guessed type int dword_104410F8[];
// 10441114: using guessed type char byte_10441114;
// 10441115: using guessed type char byte_10441115;

//----- (1000F0E0) --------------------------------------------------------
char sub_1000F0E0()
{
  char result; // al@1
  void *v1; // [sp+0h] [bp-10h]@1
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v2 = 0;
  dword_10441674 = sub_10060900();
  v1 = &unk_10441618;
  LOWORD(v2) = 0;
  BYTE2(v2) = 0;
  v4 = 0;
  v3 = byte_10441114 != 0 ? 24 : 36;
  result = sub_1000EDA0();
  if ( result )
  {
    if ( (int *)dword_10441628 == &dword_10441628 )
      result = sub_10005740((int)&unk_10441678, (int)&v1, 0);
  }
  return result;
}
// 10441114: using guessed type char byte_10441114;
// 10441628: using guessed type int dword_10441628;
// 10441674: using guessed type int dword_10441674;

//----- (1000F160) --------------------------------------------------------
char __thiscall sub_1000F160(void *this)
{
  int v1; // esi@5
  char result; // al@5
  int v3; // edx@11
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = this;
  BYTE3(v4) = 0;
  if ( sub_1000F390() && sub_1000F350 && byte_10441116 )
  {
    sub_1000EC80();
    sub_1000F0E0();
    sub_1000F2D0();
  }
  v1 = sub_10060900();
  result = sub_1000F350();
  if ( result )
  {
    result = sub_1000F370();
    if ( result )
    {
      result = sub_1002ED20((bool *)&v4 + 3);
      if ( result )
      {
        if ( !BYTE3(v4) || byte_10441116 )
        {
          result = sub_1000F330();
          if ( result )
          {
            v3 = (unsigned __int8)sub_1000F330();
            result = dword_10441670;
            if ( v1 - dword_10441670 >= (unsigned int)(60000 * v3) || !dword_10441670 )
            {
              sub_1000EC80();
LABEL_16:
              result = sub_1000F0E0();
              goto LABEL_17;
            }
          }
          if ( (unsigned int)(v1 - dword_10441674) >= 0x7530 && byte_10441115 )
            goto LABEL_16;
        }
      }
    }
  }
LABEL_17:
  byte_10441116 = BYTE3(v4) == 0;
  return result;
}
// 10441115: using guessed type char byte_10441115;
// 10441116: using guessed type char byte_10441116;
// 10441670: using guessed type int dword_10441670;
// 10441674: using guessed type int dword_10441674;

//----- (1000F230) --------------------------------------------------------
int sub_1000F230()
{
  return sub_100056F0(
           &unk_10441618,
           (int)sub_1000EDD0,
           32,
           (int)&dword_104416CC,
           5,
           (int)nullsub_1,
           (int)sub_1000EEA0,
           0);
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 104416CC: using guessed type int dword_104416CC;

//----- (1000F2B0) --------------------------------------------------------
int __usercall sub_1000F2B0@<eax>(int a1@<eax>)
{
  return sub_10034180(a1);
}

//----- (1000F2C0) --------------------------------------------------------
int __usercall sub_1000F2C0@<eax>(int a1@<eax>)
{
  return sub_100341A0(a1);
}

//----- (1000F2D0) --------------------------------------------------------
int sub_1000F2D0()
{
  char v1; // [sp+0h] [bp-8h]@1
  char v2; // [sp+7h] [bp-1h]@1

  sub_1000F2B0((int)&v1);
  v2 = 0;
  return sub_1000F2C0((int)&v1);
}

//----- (1000F2F0) --------------------------------------------------------
char sub_1000F2F0()
{
  char v1; // [sp+0h] [bp-8h]@1
  char v2; // [sp+6h] [bp-2h]@1

  sub_1000F2B0((int)&v1);
  return v2;
}

//----- (1000F310) --------------------------------------------------------
char sub_1000F310()
{
  char v1; // [sp+0h] [bp-8h]@1

  sub_1000F2B0((int)&v1);
  return v1;
}

//----- (1000F330) --------------------------------------------------------
char sub_1000F330()
{
  char v1; // [sp+0h] [bp-8h]@1
  char v2; // [sp+1h] [bp-7h]@1

  sub_1000F2B0((int)&v1);
  return v2;
}

//----- (1000F350) --------------------------------------------------------
char sub_1000F350()
{
  char v1; // [sp+0h] [bp-8h]@1
  char v2; // [sp+3h] [bp-5h]@1

  sub_1000F2B0((int)&v1);
  return v2;
}

//----- (1000F370) --------------------------------------------------------
char sub_1000F370()
{
  char v1; // [sp+0h] [bp-8h]@1
  char v2; // [sp+5h] [bp-3h]@1

  sub_1000F2B0((int)&v1);
  return v2;
}

//----- (1000F390) --------------------------------------------------------
char sub_1000F390()
{
  char v1; // [sp+0h] [bp-8h]@1
  char v2; // [sp+7h] [bp-1h]@1

  sub_1000F2B0((int)&v1);
  return v2;
}

//----- (1000F3B0) --------------------------------------------------------
int sub_1000F3B0()
{
  char v1; // [sp+0h] [bp-8h]@1
  char v2; // [sp+3h] [bp-5h]@1
  char v3; // [sp+4h] [bp-4h]@1
  char v4; // [sp+5h] [bp-3h]@1
  char v5; // [sp+6h] [bp-2h]@1
  char v6; // [sp+7h] [bp-1h]@1

  sub_1000F2B0((int)&v1);
  v4 = v2;
  v5 = v3;
  v6 = 0;
  return sub_1000F2C0((int)&v1);
}

//----- (1000F3E0) --------------------------------------------------------
char __cdecl sub_1000F3E0(int a1)
{
  char result; // al@34
  float v2; // [sp+10h] [bp-F0h]@5
  int v3; // [sp+18h] [bp-E8h]@6
  char v4; // [sp+1Fh] [bp-E1h]@27
  __int16 v5; // [sp+20h] [bp-E0h]@30
  int v6; // [sp+24h] [bp-DCh]@9
  double v7; // [sp+28h] [bp-D8h]@1
  double v8; // [sp+30h] [bp-D0h]@2
  char v9; // [sp+38h] [bp-C8h]@29
  int v10; // [sp+44h] [bp-BCh]@30
  int v11; // [sp+48h] [bp-B8h]@19
  char v12; // [sp+58h] [bp-A8h]@19
  char v13; // [sp+60h] [bp-A0h]@21
  __int16 v14; // [sp+80h] [bp-80h]@22
  float v15; // [sp+C8h] [bp-38h]@26

  if ( sub_1002BC40(0, (int)&v7) )
    sub_1002EEB0(a1, v7, v8);
  if ( !sub_10032600((char *)(a1 + 8)) )
    *(_DWORD *)(a1 + 8) = 0;
  if ( sub_1002BFC0(&v2) )
  {
    v2 = v2 * 1.943844437599182 * 100.0;
    v2 = sub_10068180(v2, 1.0);
    v3 = (signed int)v2;
    *(_WORD *)(a1 + 16) = v3;
  }
  if ( sub_1002BF10(&v2) )
    *(_WORD *)(a1 + 18) = (signed int)(v2 * 10430.37835047043);
  if ( sub_10034AB0(1, &v6) )
    *(_WORD *)(a1 + 20) = HIWORD(v6);
  if ( sub_10033FE0(&v2) )
  {
    v2 = v2 * 3.280839920043945;
    v2 = sub_10068180(v2, 1.0);
    *(_WORD *)(a1 + 22) = (signed int)v2 - 30000;
  }
  if ( sub_1002BE60(&v2) )
  {
    v2 = v2 * 3.280839920043945;
    v2 = sub_10068180(v2, 1.0);
    *(_WORD *)(a1 + 24) = (signed int)v2 - 30000;
  }
  if ( sub_10033F80(&v2) )
  {
    v2 = v2 * 1.943844437599182 * 100.0;
    v2 = sub_10068180(v2, 1.0);
    v3 = (signed int)v2;
    *(_WORD *)(a1 + 26) = v3;
  }
  if ( sub_10033F20(&v2) )
  {
    v2 = sub_10068180(v2, 1.0);
    *(_BYTE *)(a1 + 28) = (signed int)v2;
  }
  sub_10025380((int)&v11);
  if ( v12 )
    sub_1002C120(a1 + 32, &v12, 7);
  *(_DWORD *)(a1 + 12) = v11;
  if ( sub_100252B0(0, &v13) )
  {
    switch ( v14 )
    {
      case 3:
      case 5:
        *(_BYTE *)(a1 + 29) = 0;
        break;
      case 2:
      case 4:
        *(_BYTE *)(a1 + 29) = 1;
        break;
      default:
        *(_BYTE *)(a1 + 29) = 2;
        break;
    }
    v3 = (signed int)v15;
    *(_BYTE *)(a1 + 30) = v3;
  }
  *(_BYTE *)(a1 + 31) = 0;
  if ( sub_1002ED20((bool *)&v4) )
    *(_BYTE *)(a1 + 31) |= v4;
  if ( sub_10034740(&v9) )
  {
    sub_10034240(v10, &v5);
    if ( v5 == 7700 || v5 == 7600 || v5 == 7500 )
      *(_BYTE *)(a1 + 31) |= 2u;
  }
  result = sub_1000F2F0();
  *(_BYTE *)(a1 + 31) |= result;
  return result;
}

//----- (1000F760) --------------------------------------------------------
void *__cdecl sub_1000F760(char a1)
{
  if ( a1 )
  {
    sub_10060A60(79, 5000);
    sub_100059A0(&unk_107FC380, (int)&unk_1008CDFC);
    sub_10060A00(79);
  }
  return &unk_107FC380;
}

//----- (1000F7F0) --------------------------------------------------------
int __usercall sub_1000F7F0@<eax>(unsigned int *a1@<ebx>, int a2, int a3, unsigned __int8 a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@1
  signed int v7; // eax@1
  _DWORD *v8; // ecx@2
  int v9; // ecx@4
  int v10; // edx@4
  signed int v11; // eax@4
  unsigned int v12; // eax@10
  int v13; // ST14_4@11
  char v14; // al@11
  int result; // eax@14
  unsigned int *v16; // [sp+Ch] [bp-20h]@4
  int v17; // [sp+10h] [bp-1Ch]@4
  int v18; // [sp+18h] [bp-14h]@4
  int v19; // [sp+1Ch] [bp-10h]@4
  int v20; // [sp+20h] [bp-Ch]@9

  v5 = 0;
  v6 = 0;
  memset((void *)(a2 + 12), 0, 0x60u);
  v7 = 0;
  if ( *(_BYTE *)(a3 + 2) )
  {
    v8 = (_DWORD *)(a2 + 14);
    do
    {
      *v8 = a1[v6];
      v5 += a1[v6];
      ++v7;
      ++v6;
      v8 = (_DWORD *)((char *)v8 + 6);
    }
    while ( v7 < *(_BYTE *)(a3 + 2) );
  }
  v16 = &a1[v6];
  v9 = *(_DWORD *)(a2 + 8);
  v10 = *(_DWORD *)(a2 + 4);
  v17 = a5 - v6 * 4;
  v18 = v9;
  v19 = v10;
  v11 = sub_10035710((int)&v16, 15, (int)&unk_105026E0, 46920);
  if ( !v11 )
    v11 = (char)sub_10036C40((int)&v16, 4);
  if ( v11 == 1 )
    v11 = sub_10034BE0((int)&v16);
  *(_BYTE *)(a2 + 1) = 0;
  if ( !v11 && v5 == v20 )
  {
    v12 = sub_10068380(a1, 4 * *(_BYTE *)(a3 + 2), 0xFFFFFFFF);
    if ( *(_DWORD *)(a3 + 8) == sub_10068380(*(unsigned int **)(a2 + 8), v20, v12) )
    {
      v13 = *(_DWORD *)(a2 + 8);
      v14 = sub_1001E5D0(a4);
      if ( sub_1001E500(v14, 0, a2 + 12, v13) )
        *(_BYTE *)(a2 + 1) = 1;
    }
  }
  if ( *(_BYTE *)(a2 + 1) )
    result = v20;
  else
    result = 0;
  return result;
}

//----- (1000F980) --------------------------------------------------------
char __usercall sub_1000F980@<al>(int a1@<edi>, unsigned int a2@<esi>, int a3)
{
  char v3; // bl@1
  double v4; // st7@1
  char result; // al@6
  double v6; // [sp+4h] [bp-1Ch]@1
  double v7; // [sp+Ch] [bp-14h]@1
  char v8; // [sp+14h] [bp-Ch]@4

  v3 = 0;
  v6 = 6.2831853071796;
  v4 = 6.2831853071796;
  v7 = 6.2831853071796;
  if ( a2 != 0x3FFFF )
  {
    sub_10026170(0, a2, &v6);
    if ( v6 == 6.2831853071796 || v7 == 6.2831853071796 )
    {
      v4 = v6;
    }
    else
    {
      v3 = 1;
      sub_1002EEB0(a1, v6, v7);
      sub_10025B10(a2, (int)&v8);
      v4 = v6;
    }
  }
  result = v3;
  if ( a3 )
  {
    *(double *)a3 = v4;
    *(double *)(a3 + 8) = v7;
  }
  return result;
}

//----- (1000FB50) --------------------------------------------------------
void __cdecl sub_1000FB50(char a1)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // ebp@1
  int v4; // eax@2
  int v5; // eax@2
  unsigned __int8 v6; // [sp+10h] [bp-4h]@1

  *(_BYTE *)(dword_109FFDCC + 444) = -1;
  v1 = 0;
  v2 = 0;
  *(_BYTE *)(dword_109FFDCC + 446) = 0;
  v6 = 0;
  v3 = 0;
  do
  {
    v4 = sub_10032680(v6);
    sub_10060A60(v4, 30000);
    *(_BYTE *)(dword_109FFDCC + v3 + 593) = 0;
    *(_BYTE *)(dword_109FFDCC + 444) = -1;
    *(_BYTE *)(v2 + dword_109FFDCC + 1640) = 0;
    *(_BYTE *)(v2 + dword_109FFDCC + 1632) = 0;
    *(_BYTE *)(v2 + dword_109FFDCC + 1649) = 0;
    *(_BYTE *)(v2 + dword_109FFDCC + 1633) = 0;
    *(_BYTE *)(v1 + dword_109FFDCC + 14618950) = (*(_BYTE *)(v1 + dword_109FFDCC + 14618950) + 1) % 255;
    v5 = sub_10032680(v6);
    sub_10060A00(v5);
    ++v1;
    v3 += 20;
    v2 += 132;
    ++v6;
  }
  while ( v6 <= 0x1Bu );
  if ( !a1 )
    sub_1001D2E0(0, 0x1Bu);
  JUMPOUT(&loc_1001EBE0);
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1000FC60) --------------------------------------------------------
void __cdecl sub_1000FC60(int a1, float a2, float a3)
{
  bool v3; // zf@2
  char v4; // bl@2
  int v5; // edi@8
  signed int v6; // eax@8
  int v7; // ecx@8
  char v8; // al@12
  double v9; // st7@12
  unsigned int v10; // esi@16
  double v11; // st6@17
  int v12; // edx@19
  int v13; // edx@20
  int v14; // eax@20
  char v15; // [sp+1Ch] [bp-1F0h]@1
  unsigned __int8 v16; // [sp+1Ch] [bp-1F0h]@10
  float v17; // [sp+20h] [bp-1ECh]@2
  float v18; // [sp+24h] [bp-1E8h]@4
  float v19; // [sp+28h] [bp-1E4h]@2
  float v20; // [sp+2Ch] [bp-1E0h]@2
  int v21; // [sp+30h] [bp-1DCh]@2
  float v22; // [sp+38h] [bp-1D4h]@16
  float v23; // [sp+3Ch] [bp-1D0h]@28
  char v24; // [sp+40h] [bp-1CCh]@2
  unsigned __int8 v25; // [sp+50h] [bp-1BCh]@2
  int v26[100]; // [sp+54h] [bp-1B8h]@8
  char v27; // [sp+1E4h] [bp-28h]@2
  char v28; // [sp+1EDh] [bp-1Fh]@9

  v15 = sub_100603F0();
  if ( v15 == -1 )
    return;
  sub_10062A20((int)&v27);
  sub_10024640(0, (char *)&v25);
  v21 = 262141;
  sub_10026170(0, -3, (double *)&v24);
  v19 = 0.0;
  v3 = *(_BYTE *)(a1 + 2) == 0;
  v17 = 9.9999996e24;
  v4 = 1;
  v20 = a2;
  if ( v3 )
    *(_BYTE *)(a1 + 2) += sub_1000F980(a1 + 8 * *(_BYTE *)(a1 + 1) + 20, 0x3FFFDu, 0);
  sub_100628D0(1, &v18);
  if ( a2 == 0.0 || v18 < (double)a2 )
  {
    v5 = a1 + 8 * (*(_BYTE *)(a1 + 2) + *(_BYTE *)(a1 + 1)) + 20;
    v6 = sub_10062700();
    *(_BYTE *)(a1 + 2) += sub_1000F980(v5, v6, (int)&v24);
    v7 = v26[(unsigned __int8)v15];
    v19 = v18 + 0.0;
    v21 = v7;
    v4 = 0;
  }
  else if ( !sub_10062790(0, 1, &v17) )
  {
    v17 = 9.9999996e24;
  }
  if ( v28 == 3 )
    goto LABEL_25;
  v16 = v15 + 1;
  if ( !v4 )
  {
    while ( v16 < v25 )
    {
      sub_10024C30(0, v16, &v18, &v17);
      v8 = sub_10024830(0, v16);
      v9 = v18;
      if ( v8 || a3 >= v9 )
      {
        if ( !v4 )
        {
          v10 = v26[v16];
          LODWORD(v22) = &v26[v16];
          if ( v10 != v21 )
          {
            v11 = a2;
            if ( a2 == 0.0 || v9 + v19 <= v11 )
            {
              *(_BYTE *)(a1 + 2) += sub_1000F980(
                                      a1 + 8 * (*(_BYTE *)(a1 + 2) + *(_BYTE *)(a1 + 1)) + 20,
                                      v10,
                                      (int)&v24);
              v13 = *(_BYTE *)(a1 + 1);
              v14 = *(_BYTE *)(a1 + 2);
              v19 = v18 + v19;
              if ( (unsigned int)(v14 + v13) >= 0x69 )
              {
                v4 = 1;
                v17 = 9.9999996e24;
              }
              v21 = *(_DWORD *)LODWORD(v22);
            }
            else
            {
              v12 = *(_DWORD *)LODWORD(v22);
              v4 = 1;
              v20 = v11 - v19;
              v21 = v12;
            }
          }
        }
      }
      else
      {
        v4 = 1;
        v17 = 9.9999996e24;
      }
      ++v16;
      if ( v4 )
        goto LABEL_26;
    }
LABEL_25:
    if ( !v4 )
      return;
  }
LABEL_26:
  if ( v20 > 0.0 && 9.9999996e24 != v17 )
  {
    sub_10068110((int)&v24, (int)&v21);
    sub_1005FD90((int)&v21, v20, v17, (int)&v22);
    sub_1002EF90(a1 + 8 * (*(_BYTE *)(a1 + 2) + *(_BYTE *)(a1 + 1)) + 20, v22, v23);
    ++*(_BYTE *)(a1 + 2);
  }
}
// 1000FC60: using guessed type int var_1B8[100];

//----- (1000FF70) --------------------------------------------------------
bool __cdecl sub_1000FF70(void *a1, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // edi@1
  signed int v7; // eax@2
  float v8; // ST28_4@8
  float v9; // ST14_4@8
  float v10; // ST28_4@8
  unsigned int v12; // [sp+1Ch] [bp-1Ch]@4
  int v13; // [sp+20h] [bp-18h]@1
  int v14; // [sp+24h] [bp-14h]@1
  int v15; // [sp+28h] [bp-10h]@1
  int v16; // [sp+2Ch] [bp-Ch]@1
  int v17; // [sp+30h] [bp-8h]@1

  v6 = (char *)a3;
  v13 = a2;
  v14 = a3;
  v15 = a4;
  v16 = a5;
  v17 = a6;
  memset(a1, 0, 0x35Cu);
  *(_BYTE *)a1 = 1;
  *((_BYTE *)a1 + 1) = 0;
  *((_BYTE *)a1 + 2) = 0;
  *((_BYTE *)a1 + 3) = 0;
  *((_DWORD *)a1 + 1) = a6;
  *((_BYTE *)a1 + 8) = BYTE1(a2);
  *((_BYTE *)a1 + 9) = (unsigned int)a2 >> 16;
  *((_WORD *)a1 + 5) = a3;
  sub_1002C120((int)a1 + 12, "14.01", 8);
  if ( v13 & 2 )
  {
    v6 = (char *)a1 + 8 * *((_BYTE *)a1 + 1) + 20;
    v7 = sub_100246D0(0);
    *((_BYTE *)a1 + 1) += sub_1000F980((int)v6, v7, 0);
  }
  if ( v13 & 8 )
  {
    sub_100264D0((int)v6, (int)&v15, (int *)&v12);
    *((_BYTE *)a1 + 1) += sub_1000F980((int)a1 + 8 * *((_BYTE *)a1 + 1) + 20, v12, 0);
  }
  if ( v13 & 1 )
    *((_BYTE *)a1 + 2) += sub_1000F980((int)a1 + 8 * (*((_BYTE *)a1 + 1) + *((_BYTE *)a1 + 2)) + 20, 0x3FFFDu, 0);
  if ( v13 & 4 )
  {
    v8 = (double)(unsigned __int16)v14 * 1000.0;
    v9 = v8;
    v10 = 1000.0 * (double)HIWORD(v14);
    sub_1000FC60((int)a1, v10, v9);
  }
  return *((_BYTE *)a1 + 1) + *((_BYTE *)a1 + 3) + *((_BYTE *)a1 + 2) != 0;
}

//----- (100100F0) --------------------------------------------------------
char __cdecl sub_100100F0(int a1, int a2, void *a3, size_t a4)
{
  void *v4; // ecx@0
  unsigned __int16 v5; // ax@5
  int v6; // esi@7
  char result; // al@11
  int v8; // [sp+10h] [bp-51Ch]@10
  char v9; // [sp+14h] [bp-518h]@10

  if ( !a2 )
    sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds_wx.c", 2993, 1, 0);
  if ( a4 <= 0x514
    && (sub_1002C660(v4) != 4 ? (v6 = 4) : (v5 = *(_WORD *)(a2 + 2), v5 <= 1u) || v5 > 8u ? (v6 = 0) : (v6 = dword_1008CDD8[v5]),
        memset(&v8, 0, 0x518u),
        LOWORD(v8) = a4,
        HIWORD(v8) = 1,
        memcpy(&v9, a3, a4),
        sub_10014160(418, v8 + 4, v6, &v8, 1, (int)&byte_10A08A80)) )
  {
    result = 0;
    ++dword_10441A5C;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds_wx.c", 3037, 0, 0);
    result = 1;
  }
  return result;
}
// 1008CDD8: using guessed type int dword_1008CDD8[];
// 10441A5C: using guessed type int dword_10441A5C;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10010210) --------------------------------------------------------
int __cdecl sub_10010210(char a1)
{
  void *v1; // ecx@0
  int result; // eax@1

  result = sub_1002C660(v1);
  if ( result == 4 )
    result = sub_10060ED0(9196, (int)&a1, 1);
  return result;
}

//----- (10010230) --------------------------------------------------------
size_t __usercall sub_10010230@<eax>(int a1@<eax>, _DWORD *a2@<edi>, int a3@<esi>, int a4, int a5)
{
  size_t result; // eax@2

  *(_DWORD *)a1 = *(_DWORD *)a3;
  if ( *(_DWORD *)a3 )
  {
    *(_DWORD *)(a1 + 4) = *a2;
    memcpy((void *)(a5 + *a2), (const void *)(a4 + *(_DWORD *)(a3 + 4)), *(_DWORD *)a3);
    *a2 += *(_DWORD *)a3;
    result = *(_DWORD *)a3;
  }
  else
  {
    *(_DWORD *)(a1 + 4) = 0;
    result = 0;
  }
  return result;
}

//----- (10010270) --------------------------------------------------------
void *__cdecl sub_10010270(char a1)
{
  if ( a1 )
  {
    sub_10060A60(79, 5000);
    sub_10004490(
      &unk_107FC3D4,
      1500,
      2400,
      1300,
      (int)&unk_107FCC90,
      (int)sub_1000F920,
      (int)sub_100100F0,
      (int)sub_1000F7C0);
    sub_10060A00(79);
  }
  return &unk_107FC3D4;
}
// 1000F7C0: using guessed type int sub_1000F7C0();
// 1000F920: using guessed type int sub_1000F920();

//----- (100102C0) --------------------------------------------------------
int __cdecl sub_100102C0(int a1)
{
  void *v1; // eax@1

  sub_10060A60(79, 5000);
  sub_10004C30((int)&unk_1050DE28);
  sub_10004C30((int)&unk_107FC480);
  v1 = sub_10010270(0);
  sub_10004C50((int)v1, a1);
  return sub_10060A00(79);
}

//----- (10010310) --------------------------------------------------------
char __thiscall sub_10010310(void *this)
{
  char v1; // bl@1
  unsigned int v2; // esi@2
  int *v3; // edi@2
  int v4; // eax@3
  int v5; // ST14_4@6
  char v6; // ST10_1@6
  void *v7; // eax@6

  v1 = 0;
  if ( !dword_104416F8 )
    goto LABEL_14;
  v2 = 0;
  v3 = &dword_107FC160;
  do
  {
    v4 = j_HWM_pvg_hsdb_get_lrus_online(this);
    if ( v4 & dword_1008CDE0[v2] )
    {
      if ( (int *)*v3 != v3 )
        sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds_wx.c", 1176, 1, 0);
      sub_10060A60(79, 5000);
      v5 = dword_104416F8;
      v6 = byte_104416FC;
      v7 = sub_10010270(0);
      v1 = sub_10004D50((int)v7, (int)(v3 - 4), v2 + 2, v6, v5, 0);
      LOBYTE(v4) = sub_10060A00(79);
    }
    ++v2;
    v3 += 20;
  }
  while ( v2 < 7 );
  if ( !v1 )
  {
LABEL_14:
    LOBYTE(v4) = sub_10032470(this);
    if ( (_BYTE)v4 == 1 )
      LOBYTE(v4) = sub_10010210(byte_1008CDD0[(unsigned __int8)byte_104416FF]);
  }
  return v4;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 1008CDE0: using guessed type int dword_1008CDE0[];
// 104416F8: using guessed type int dword_104416F8;
// 104416FC: using guessed type char byte_104416FC;
// 104416FF: using guessed type char byte_104416FF;
// 107FC160: using guessed type int dword_107FC160;

//----- (100103D0) --------------------------------------------------------
int __cdecl sub_100103D0(char *a1, char a2)
{
  char *v2; // esi@1
  char v3; // bl@3
  int result; // eax@4

  v2 = a1;
  if ( !a1 )
    sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds_wx.c", 1485, 1, a1);
  v3 = a2;
  if ( a2 )
  {
    dword_104416F8 = 0;
    sub_10032600((char *)&a1);
    dword_107FC4D8 = (int)(a1 + 30000);
    sub_10060ED0(9197, (int)&dword_107FC4D8, 4);
    result = sub_10010210(byte_1008CDD0[(unsigned __int8)v3]);
    byte_104416FF = v3;
  }
  else
  {
    result = *((_DWORD *)v2 + 1);
    dword_104416F8 = *((_DWORD *)v2 + 1);
    byte_104416FD = 1;
    dword_107FC4DC = 0;
  }
  return result;
}
// 104416F8: using guessed type int dword_104416F8;
// 104416FD: using guessed type char byte_104416FD;
// 104416FF: using guessed type char byte_104416FF;
// 107FC4D8: using guessed type int dword_107FC4D8;
// 107FC4DC: using guessed type int dword_107FC4DC;

//----- (10010570) --------------------------------------------------------
int __cdecl sub_10010570(int a1)
{
  int v1; // ecx@0
  int v2; // ebp@1
  int v3; // edx@1
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // ecx@1
  int result; // eax@1
  unsigned int v9; // ecx@1
  unsigned int v10; // esi@3
  int v11; // edx@4
  signed int v12; // esi@8
  int v13; // eax@8
  int v14; // esi@14
  const void *v15; // ST04_4@14
  int v16; // ecx@15
  void *v17; // eax@15
  size_t v18; // eax@15
  signed int v19; // [sp+10h] [bp-1Ch]@1
  unsigned int v20; // [sp+14h] [bp-18h]@1
  int v21; // [sp+14h] [bp-18h]@14
  int v22; // [sp+18h] [bp-14h]@1
  void *v23; // [sp+20h] [bp-Ch]@1
  char *v24; // [sp+20h] [bp-Ch]@14
  int v25; // [sp+24h] [bp-8h]@1
  int v26; // [sp+28h] [bp-4h]@1
  int v27; // [sp+30h] [bp+4h]@2
  signed int v28; // [sp+30h] [bp+4h]@14

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 20);
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 14);
  v6 = *(_DWORD *)(v1 + 8);
  v22 = v6 + 5;
  v23 = (void *)(v4 + v5 + v3);
  v25 = v6 + *(_DWORD *)(v1 + 14) + *(_DWORD *)(v1 + 20);
  v7 = *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 26) - v5;
  v26 = *(_DWORD *)(a1 + 26);
  result = 0;
  v9 = v7 - v3;
  v19 = 0;
  v20 = 0;
  if ( *(_WORD *)(v6 + 3) )
  {
    v27 = v6 + 5;
    do
    {
      v10 = 0;
      if ( *(_WORD *)(v4 + 3) )
      {
        v11 = v4 + 5;
        while ( *(_DWORD *)v27 != *(_DWORD *)v11 || *(_DWORD *)(v27 + 4) != *(_DWORD *)(v11 + 4) )
        {
          ++v10;
          v11 += 25;
          if ( v10 >= *(_WORD *)(v4 + 3) )
            goto LABEL_8;
        }
      }
      else
      {
LABEL_8:
        v12 = v19;
        v13 = *(_DWORD *)(v27 + 17);
        if ( v19 >= 499 || v9 < v13 + 25 )
          goto LABEL_13;
        dword_1050DE80[v19++] = v20;
        v9 += -25 - v13;
      }
      v27 += 25;
      ++v20;
    }
    while ( v20 < *(_WORD *)(v6 + 3) );
    v12 = v19;
LABEL_13:
    if ( v12 <= 0 )
    {
      result = 0;
    }
    else
    {
      v14 = 25 * v12;
      v15 = v23;
      v24 = (char *)v23 + v14;
      memcpy_0(v24, v15, *(_DWORD *)(v2 + 26));
      *(_DWORD *)(v2 + 20) += v14;
      v21 = v14;
      v28 = 0;
      if ( v19 <= 0 )
      {
        result = v14;
      }
      else
      {
        do
        {
          v16 = 25 * dword_1050DE80[v28];
          v17 = (void *)(25 * *(_WORD *)(v4 + 3) + v4 + 5);
          qmemcpy(v17, (const void *)(v16 + v22), 0x19u);
          v18 = sub_10010230((int)v17 + 17, &v26, v16 + v22 + 17, v25, (int)v24);
          *(_DWORD *)(v2 + 26) += v18;
          v21 += v18;
          ++*(_WORD *)(v4 + 3);
          ++v28;
        }
        while ( v28 < v19 );
        result = v21;
      }
    }
  }
  return result;
}
// 1050DE80: using guessed type int dword_1050DE80[];

//----- (10010730) --------------------------------------------------------
int __cdecl sub_10010730(int a1)
{
  int v1; // ecx@0
  int v2; // ebp@1
  int v3; // esi@1
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // ebp@1
  int result; // eax@1
  signed int v8; // ecx@1
  unsigned int v9; // ebp@1
  _DWORD *v10; // esi@2
  unsigned int v11; // eax@3
  int v12; // ecx@4
  int v13; // edx@11
  int v14; // esi@17
  const void *v15; // ST08_4@17
  const void *v16; // ebp@18
  void *v17; // eax@18
  size_t v18; // eax@18
  int v19; // ecx@18
  signed int v20; // [sp+10h] [bp-24h]@1
  unsigned int v21; // [sp+14h] [bp-20h]@1
  signed int v22; // [sp+14h] [bp-20h]@17
  int v23; // [sp+18h] [bp-1Ch]@1
  int v24; // [sp+1Ch] [bp-18h]@17
  void *v25; // [sp+20h] [bp-14h]@1
  char *v26; // [sp+20h] [bp-14h]@17
  int v27; // [sp+24h] [bp-10h]@1
  int v28; // [sp+28h] [bp-Ch]@1
  int v29; // [sp+2Ch] [bp-8h]@18
  size_t v30; // [sp+30h] [bp-4h]@18

  v2 = *(_DWORD *)(v1 + 8);
  v3 = *(_DWORD *)(a1 + 14);
  v4 = *(_DWORD *)(a1 + 20);
  v5 = *(_DWORD *)(a1 + 8);
  v25 = (void *)(v5 + v3 + v4);
  v23 = v2;
  v27 = v2 + *(_DWORD *)(v1 + 14) + *(_DWORD *)(v1 + 20);
  v6 = *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 26) - v3;
  v28 = *(_DWORD *)(a1 + 26);
  result = 0;
  v8 = 0;
  v9 = v6 - v4;
  v20 = 0;
  v21 = 0;
  if ( !*(_WORD *)(v23 + 3) )
    return result;
  v10 = (_DWORD *)(v23 + 74);
  do
  {
    v11 = 0;
    if ( *(_WORD *)(v5 + 3) )
    {
      v12 = v5 + 7;
      while ( *((_BYTE *)v10 - 66) != *(_BYTE *)(v12 + 1)
           || *((_BYTE *)v10 - 67) != *(_BYTE *)v12
           || *((_BYTE *)v10 - 68) != *(_BYTE *)(v12 - 1)
           || *((_BYTE *)v10 - 69) != *(_BYTE *)(v12 - 2) )
      {
        ++v11;
        v12 += 77;
        if ( v11 >= *(_WORD *)(v5 + 3) )
        {
          v8 = v20;
          goto LABEL_11;
        }
      }
      v8 = v20;
      goto LABEL_15;
    }
LABEL_11:
    v13 = *v10 + *(_DWORD *)((char *)v10 - 53);
    if ( v8 >= 499 || v9 < v13 + 77 )
      break;
    dword_1050DE80[v8++] = v21;
    v20 = v8;
    v9 += -77 - v13;
LABEL_15:
    v10 = (_DWORD *)((char *)v10 + 77);
    ++v21;
  }
  while ( v21 < *(_WORD *)(v23 + 3) );
  if ( v8 <= 0 )
  {
    result = 0;
  }
  else
  {
    v14 = 77 * v8;
    v15 = v25;
    v26 = (char *)v25 + 77 * v8;
    memcpy_0(v26, v15, *(_DWORD *)(a1 + 26));
    *(_DWORD *)(a1 + 20) += v14;
    v24 = v14;
    v22 = 0;
    if ( v20 <= 0 )
    {
      result = v14;
    }
    else
    {
      do
      {
        v16 = (const void *)(77 * dword_1050DE80[v22] + v23 + 5);
        v17 = (void *)(77 * *(_WORD *)(v5 + 3) + v5 + 5);
        qmemcpy(v17, v16, 0x4Du);
        v29 = (int)v17;
        v30 = sub_10010230((int)v17 + 16, &v28, (int)v16 + 16, v27, (int)v26);
        v18 = sub_10010230(v29 + 69, &v28, (int)v16 + 69, v27, (int)v26);
        v19 = v18 + v30;
        *(_DWORD *)(a1 + 26) += v18 + v30;
        ++*(_WORD *)(v5 + 3);
        v24 += v19;
        ++v22;
      }
      while ( v22 < v20 );
      result = v24;
    }
  }
  return result;
}
// 1050DE80: using guessed type int dword_1050DE80[];

//----- (10010920) --------------------------------------------------------
int __usercall sub_10010920@<eax>(int a1@<eax>, int a2)
{
  int v2; // ebx@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // esi@1
  int v6; // ebp@1
  unsigned int v7; // edi@1
  int v8; // ecx@1
  int result; // eax@1
  int v10; // esi@1
  bool v11; // zf@1
  int v12; // edx@2
  int v13; // eax@3
  unsigned int v14; // esi@4
  _DWORD *v15; // edi@4
  char *v16; // ecx@7
  _DWORD *v17; // edx@7
  int v18; // ebx@11
  int v19; // esi@12
  _BYTE *v20; // ecx@12
  _BYTE *v21; // edx@12
  int v22; // esi@14
  _BYTE *v23; // ecx@14
  _BYTE *v24; // edx@14
  _BYTE *v25; // ecx@16
  _BYTE *v26; // edx@16
  signed int v27; // ecx@18
  signed int v28; // eax@25
  int v29; // ecx@25
  bool v30; // cf@29
  int v31; // esi@32
  int v32; // edi@32
  char *v33; // ST08_4@32
  int v34; // ebp@35
  int v35; // ebx@35
  size_t v36; // eax@35
  int v37; // ecx@35
  int v38; // [sp+10h] [bp-30h]@1
  signed int v39; // [sp+14h] [bp-2Ch]@1
  unsigned int v40; // [sp+18h] [bp-28h]@3
  unsigned int v41; // [sp+1Ch] [bp-24h]@1
  int v42; // [sp+20h] [bp-20h]@1
  int v43; // [sp+24h] [bp-1Ch]@2
  int v44; // [sp+24h] [bp-1Ch]@32
  int v45; // [sp+28h] [bp-18h]@1
  int v46; // [sp+28h] [bp-18h]@32
  char *v47; // [sp+2Ch] [bp-14h]@1
  char *v48; // [sp+2Ch] [bp-14h]@32
  int v49; // [sp+30h] [bp-10h]@1
  int v50; // [sp+34h] [bp-Ch]@1
  size_t v51; // [sp+38h] [bp-8h]@4
  int v52; // [sp+3Ch] [bp-4h]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 20);
  v4 = *(_DWORD *)(a2 + 14);
  v5 = *(_DWORD *)(a1 + 8);
  v38 = *(_DWORD *)(a2 + 8);
  v47 = (char *)(*(_DWORD *)(a2 + 8) + v4 + v3);
  v45 = v5;
  v6 = v5 + *(_DWORD *)(a1 + 14) + *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 26) - v4 - v3;
  v8 = *(_DWORD *)(a1 + 8);
  v50 = *(_DWORD *)(a2 + 26);
  result = 0;
  v10 = v5 + 4;
  v11 = *(_BYTE *)(v8 + 3) == 0;
  v52 = v10;
  v49 = v6;
  v39 = 0;
  v41 = v7;
  v42 = 0;
  if ( v11 )
    return result;
  v12 = v10 + 9;
  v43 = v10 + 9;
LABEL_3:
  v13 = v38;
  v40 = 0;
  if ( *(_BYTE *)(v38 + 3) )
  {
    v14 = *(_DWORD *)v12;
    v51 = *(_DWORD *)v12;
    v15 = (_DWORD *)(v38 + 17);
    while ( 1 )
    {
      if ( !v14 || v14 != *(v15 - 1) )
        goto LABEL_23;
      v16 = &v47[*v15];
      v17 = (_DWORD *)(v6 + *(_DWORD *)(v12 + 4));
      if ( v14 < 4 )
      {
LABEL_10:
        if ( !v14 )
          goto LABEL_20;
      }
      else
      {
        while ( *v17 == *(_DWORD *)v16 )
        {
          v14 -= 4;
          v16 += 4;
          ++v17;
          if ( v14 < 4 )
            goto LABEL_10;
        }
      }
      v18 = *(_BYTE *)v17 - (unsigned __int8)*v16;
      if ( *(_BYTE *)v17 != (unsigned __int8)*v16
        || (v19 = v14 - 1, v20 = v16 + 1, v21 = (char *)v17 + 1, v19)
        && ((v18 = *v21 - *v20, *v21 != *v20)
         || (v22 = v19 - 1, v23 = v20 + 1, v24 = v21 + 1, v22)
         && ((v18 = *v24 - *v23, *v24 != *v23)
          || (v25 = v23 + 1, v26 = v24 + 1, v22 != 1) && (v18 = *v26 - *v25, *v26 != *v25))) )
      {
        v27 = 1;
        if ( v18 <= 0 )
          v27 = -1;
        goto LABEL_21;
      }
LABEL_20:
      v27 = 0;
LABEL_21:
      v12 = v43;
      v2 = a2;
      if ( !v27 )
      {
        v7 = v41;
LABEL_29:
        v12 += 17;
        v30 = v42++ + 1 < (unsigned int)*(_BYTE *)(v45 + 3);
        v43 = v12;
        if ( !v30 )
        {
          v28 = v39;
          goto LABEL_31;
        }
        goto LABEL_3;
      }
      v14 = v51;
      v13 = v38;
LABEL_23:
      ++v40;
      v15 = (_DWORD *)((char *)v15 + 17);
      if ( v40 >= *(_BYTE *)(v13 + 3) )
      {
        v7 = v41;
        break;
      }
    }
  }
  v28 = v39;
  v29 = *(_DWORD *)v12 + *(_DWORD *)(v12 - 8);
  if ( v39 < 499 && v7 >= v29 + 17 )
  {
    dword_1050DE80[v39++] = v42;
    v7 += -17 - v29;
    v41 = v7;
    goto LABEL_29;
  }
LABEL_31:
  if ( v28 <= 0 )
  {
    result = 0;
  }
  else
  {
    v31 = 17 * v28;
    v32 = (int)&v47[17 * v28];
    v33 = v47;
    v48 = &v47[17 * v28];
    memcpy_0(v48, v33, *(_DWORD *)(v2 + 26));
    *(_DWORD *)(v2 + 20) += v31;
    v44 = v31;
    v46 = 0;
    if ( v39 > 0 )
    {
      while ( 1 )
      {
        v34 = v52 + 16 * dword_1050DE80[v46] + dword_1050DE80[v46];
        v35 = v38 + 4 + 16 * *(_BYTE *)(v38 + 3) + *(_BYTE *)(v38 + 3);
        *(_DWORD *)v35 = *(_DWORD *)v34;
        *(_DWORD *)(v35 + 4) = *(_DWORD *)(v34 + 4);
        *(_DWORD *)(v35 + 8) = *(_DWORD *)(v34 + 8);
        *(_DWORD *)(v35 + 12) = *(_DWORD *)(v34 + 12);
        *(_BYTE *)(v35 + 16) = *(_BYTE *)(v34 + 16);
        v51 = sub_10010230(v35 + 1, &v50, v34 + 1, v49, v32);
        v36 = sub_10010230(v35 + 9, &v50, v34 + 9, v49, (int)v48);
        v37 = v36 + v51;
        *(_DWORD *)(a2 + 26) += v36 + v51;
        ++*(_BYTE *)(v38 + 3);
        v44 += v37;
        if ( ++v46 >= v39 )
          break;
        v32 = (int)v48;
      }
      result = v44;
    }
    else
    {
      result = v31;
    }
  }
  return result;
}
// 1050DE80: using guessed type int dword_1050DE80[];

//----- (10010BF0) --------------------------------------------------------
int __cdecl sub_10010BF0(int a1)
{
  int v1; // ecx@0
  int v2; // ebp@1
  int v3; // edx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // ecx@1
  int result; // eax@1
  unsigned int v8; // ecx@1
  int v9; // eax@2
  unsigned int v10; // edi@3
  int v11; // edx@4
  signed int v12; // edi@9
  int v13; // edx@9
  int v14; // edi@15
  int v15; // ebp@16
  void *v16; // eax@16
  int v17; // edi@16
  int v18; // esi@16
  size_t v19; // eax@16
  int v20; // ecx@16
  signed int v21; // [sp+10h] [bp-24h]@1
  int v22; // [sp+14h] [bp-20h]@2
  int v23; // [sp+14h] [bp-20h]@15
  unsigned int v24; // [sp+18h] [bp-1Ch]@1
  signed int v25; // [sp+18h] [bp-1Ch]@15
  int v26; // [sp+1Ch] [bp-18h]@1
  char *v27; // [sp+20h] [bp-14h]@15
  int v28; // [sp+24h] [bp-10h]@1
  int v29; // [sp+28h] [bp-Ch]@1
  void *v30; // [sp+2Ch] [bp-8h]@1
  size_t v31; // [sp+30h] [bp-4h]@16

  v2 = *(_DWORD *)(v1 + 8);
  v3 = *(_DWORD *)(a1 + 20);
  v4 = *(_DWORD *)(a1 + 8);
  v26 = v2 + 5;
  v5 = *(_DWORD *)(a1 + 14);
  v30 = (void *)(v4 + v5 + v3);
  v28 = v2 + *(_DWORD *)(v1 + 14) + *(_DWORD *)(v1 + 20);
  v6 = *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 26) - v5;
  v29 = *(_DWORD *)(a1 + 26);
  result = 0;
  v8 = v6 - v3;
  v21 = 0;
  v24 = 0;
  if ( *(_WORD *)(v2 + 3) )
  {
    v9 = v2 + 5;
    v22 = v2 + 5;
    do
    {
      v10 = 0;
      if ( *(_WORD *)(v4 + 3) )
      {
        v11 = v4 + 5;
        while ( *(_DWORD *)v9 != *(_DWORD *)v11 || *(_DWORD *)(v22 + 4) != *(_DWORD *)(v11 + 4) )
        {
          ++v10;
          v11 += 75;
          if ( v10 >= *(_WORD *)(v4 + 3) )
          {
            v9 = v22;
            goto LABEL_9;
          }
        }
      }
      else
      {
LABEL_9:
        v12 = v21;
        v13 = *(_DWORD *)(v9 + 59) + *(_DWORD *)(v9 + 67);
        if ( v21 >= 499 || v8 < v13 + 75 )
          goto LABEL_14;
        dword_1050DE80[v21++] = v24;
        v8 += -75 - v13;
      }
      ++v24;
      v9 = v22 + 75;
      v22 += 75;
    }
    while ( v24 < *(_WORD *)(v2 + 3) );
    v12 = v21;
LABEL_14:
    if ( v12 <= 0 )
    {
      result = 0;
    }
    else
    {
      v14 = 75 * v12;
      v27 = (char *)v30 + v14;
      memcpy_0((char *)v30 + v14, v30, *(_DWORD *)(a1 + 26));
      *(_DWORD *)(a1 + 20) += v14;
      v23 = v14;
      v25 = 0;
      if ( v21 <= 0 )
      {
        result = v14;
      }
      else
      {
        do
        {
          v15 = 75 * dword_1050DE80[v25] + v26;
          v16 = (void *)(75 * *(_WORD *)(v4 + 3) + v4 + 5);
          v17 = 75 * *(_WORD *)(v4 + 3) + v4 + 5;
          v18 = 75 * dword_1050DE80[v25] + v26;
          qmemcpy((void *)v17, (const void *)v18, 0x48u);
          v18 += 72;
          v17 += 72;
          *(_WORD *)v17 = *(_WORD *)v18;
          *(_BYTE *)(v17 + 2) = *(_BYTE *)(v18 + 2);
          v30 = v16;
          v31 = sub_10010230((int)v16 + 59, &v29, v15 + 59, v28, (int)v27);
          v19 = sub_10010230((int)v30 + 67, &v29, v15 + 67, v28, (int)v27);
          v20 = v19 + v31;
          *(_DWORD *)(a1 + 26) += v19 + v31;
          ++*(_WORD *)(v4 + 3);
          v23 += v20;
          ++v25;
        }
        while ( v25 < v21 );
        result = v23;
      }
    }
  }
  return result;
}
// 1050DE80: using guessed type int dword_1050DE80[];

//----- (10010DE0) --------------------------------------------------------
int __usercall sub_10010DE0@<eax>(int a1@<eax>, int a2)
{
  int v2; // ebp@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // edi@1
  unsigned int v7; // edx@1
  int result; // eax@1
  int v9; // ecx@2
  unsigned int v10; // esi@3
  int v11; // ecx@4
  signed int v12; // esi@10
  int v13; // eax@10
  bool v14; // cf@13
  int v15; // esi@16
  const void *v16; // ST04_4@16
  int v17; // ecx@19
  int v18; // eax@19
  size_t v19; // eax@19
  _DWORD *v20; // [sp+10h] [bp-1Ch]@2
  signed int v21; // [sp+14h] [bp-18h]@1
  int v22; // [sp+18h] [bp-14h]@1
  int v23; // [sp+18h] [bp-14h]@16
  int v24; // [sp+1Ch] [bp-10h]@1
  void *v25; // [sp+20h] [bp-Ch]@1
  char *v26; // [sp+20h] [bp-Ch]@16
  int v27; // [sp+24h] [bp-8h]@1
  int v28; // [sp+28h] [bp-4h]@1
  char v29; // [sp+30h] [bp+4h]@4
  int v30; // [sp+30h] [bp+4h]@16

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 20);
  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(_DWORD *)(a2 + 14);
  v25 = (void *)(v4 + v5 + v3);
  v6 = *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 14) + *(_DWORD *)(a1 + 20);
  v24 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 26) - v5 - v3;
  v28 = *(_DWORD *)(a2 + 26);
  result = 0;
  v27 = v6;
  v21 = 0;
  v22 = 0;
  if ( *(_DWORD *)(v24 + 3) )
  {
    v9 = v24 + 11;
    v20 = (_DWORD *)(v24 + 11);
    do
    {
      v10 = 0;
      if ( *(_DWORD *)(v4 + 3) )
      {
        v29 = *(_BYTE *)(v9 - 1);
        v11 = v4 + 9;
        while ( v29 != *(_BYTE *)(v11 + 1)
             || *((_BYTE *)v20 - 2) != *(_BYTE *)v11
             || *((_BYTE *)v20 - 3) != *(_BYTE *)(v11 - 1)
             || *((_BYTE *)v20 - 4) != *(_BYTE *)(v11 - 2) )
        {
          ++v10;
          v11 += 12;
          if ( v10 >= *(_DWORD *)(v4 + 3) )
            goto LABEL_10;
        }
      }
      else
      {
LABEL_10:
        v12 = v21;
        v13 = *v20;
        if ( v21 >= 499 || v7 < v13 + 12 )
          goto LABEL_15;
        dword_1050DE80[v21++] = v22;
        v7 += -12 - v13;
      }
      v9 = (int)(v20 + 3);
      v14 = (unsigned int)(v22++ + 1) < *(_DWORD *)(v24 + 3);
      v20 += 3;
    }
    while ( v14 );
    v12 = v21;
LABEL_15:
    if ( v12 <= 0 )
    {
      result = 0;
    }
    else
    {
      v15 = 12 * v12;
      v16 = v25;
      v26 = (char *)v25 + v15;
      memcpy_0(v26, v16, *(_DWORD *)(v2 + 26));
      *(_DWORD *)(v2 + 20) += v15;
      v23 = v15;
      v30 = 0;
      if ( v21 > 0 )
      {
        while ( 1 )
        {
          v17 = v24 + 12 * dword_1050DE80[v30] + 7;
          v18 = v4 + 12 * *(_DWORD *)(v4 + 3) + 7;
          *(_DWORD *)v18 = *(_DWORD *)v17;
          *(_DWORD *)(v18 + 4) = *(_DWORD *)(v17 + 4);
          *(_DWORD *)(v18 + 8) = *(_DWORD *)(v17 + 8);
          v19 = sub_10010230(v18 + 4, &v28, v17 + 4, v6, (int)v26);
          *(_DWORD *)(v2 + 26) += v19;
          v23 += v19;
          ++*(_DWORD *)(v4 + 3);
          if ( ++v30 >= v21 )
            break;
          v6 = v27;
        }
        result = v23;
      }
      else
      {
        result = v15;
      }
    }
  }
  return result;
}
// 1050DE80: using guessed type int dword_1050DE80[];

//----- (10010FB0) --------------------------------------------------------
int __usercall sub_10010FB0@<eax>(int a1@<eax>, int a2)
{
  int v2; // ebx@1
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // ebp@1
  int v6; // edi@1
  int v7; // esi@1
  int result; // eax@1
  int v9; // edi@1
  unsigned int v10; // esi@1
  bool v11; // zf@1
  int v12; // ebx@2
  int v13; // ecx@4
  unsigned int v14; // esi@5
  char *v15; // ecx@7
  _DWORD *v16; // edx@7
  int v17; // edi@11
  int v18; // esi@12
  _BYTE *v19; // ecx@12
  _BYTE *v20; // edx@12
  int v21; // esi@14
  _BYTE *v22; // ecx@14
  _BYTE *v23; // edx@14
  _BYTE *v24; // ecx@16
  _BYTE *v25; // edx@16
  signed int v26; // ecx@18
  bool v27; // cf@23
  int v28; // eax@25
  int v29; // ecx@25
  int v30; // esi@32
  void *v31; // ebp@35
  const void *v32; // ebx@35
  size_t v33; // ST50_4@35
  size_t v34; // ST50_4@35
  size_t v35; // ST50_4@35
  size_t v36; // ST50_4@35
  size_t v37; // ST50_4@35
  size_t v38; // ST50_4@35
  size_t v39; // ST50_4@35
  size_t v40; // ST50_4@35
  size_t v41; // eax@35
  int v42; // [sp+10h] [bp-28h]@1
  int v43; // [sp+14h] [bp-24h]@1
  unsigned int v44; // [sp+18h] [bp-20h]@1
  char *v45; // [sp+18h] [bp-20h]@32
  int v46; // [sp+1Ch] [bp-1Ch]@1
  int v47; // [sp+20h] [bp-18h]@1
  int v48; // [sp+24h] [bp-14h]@4
  int v49; // [sp+28h] [bp-10h]@3
  void *v50; // [sp+2Ch] [bp-Ch]@1
  int v51; // [sp+30h] [bp-8h]@1
  int v52; // [sp+34h] [bp-4h]@1

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 20);
  v4 = *(_DWORD *)(a2 + 14);
  v5 = *(_DWORD *)(a2 + 8);
  v50 = (void *)(v5 + v4 + v3);
  v6 = *(_DWORD *)(a1 + 14) + *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a2 + 26) - v4;
  v46 = *(_DWORD *)(a2 + 26);
  result = 0;
  v9 = v2 + v6;
  v10 = v7 - v3;
  v11 = *(_WORD *)(v2 + 3) == 0;
  v52 = v5;
  v51 = v2;
  v43 = v9;
  v47 = 0;
  v44 = v10;
  v42 = 0;
  if ( v11 )
    return result;
  v12 = v2 + 61;
LABEL_3:
  v11 = *(_WORD *)(v5 + 3) == 0;
  v49 = 0;
  if ( !v11 )
  {
    v13 = v5 + 5;
    v48 = v5 + 5;
    while ( 1 )
    {
      v14 = *(_DWORD *)(v12 - 56);
      if ( !v14 || v14 != *(_DWORD *)v13 )
        goto LABEL_23;
      v15 = (char *)v50 + *(_DWORD *)(v13 + 4);
      v16 = (_DWORD *)(v9 + *(_DWORD *)(v12 - 52));
      if ( v14 < 4 )
      {
LABEL_10:
        if ( !v14 )
          goto LABEL_20;
      }
      else
      {
        while ( *v16 == *(_DWORD *)v15 )
        {
          v14 -= 4;
          v15 += 4;
          ++v16;
          if ( v14 < 4 )
            goto LABEL_10;
        }
      }
      v17 = *(_BYTE *)v16 - (unsigned __int8)*v15;
      if ( *(_BYTE *)v16 != (unsigned __int8)*v15
        || (v18 = v14 - 1, v19 = v15 + 1, v20 = (char *)v16 + 1, v18)
        && ((v17 = *v20 - *v19, *v20 != *v19)
         || (v21 = v18 - 1, v22 = v19 + 1, v23 = v20 + 1, v21)
         && ((v17 = *v23 - *v22, *v23 != *v22)
          || (v24 = v22 + 1, v25 = v23 + 1, v21 != 1) && (v17 = *v25 - *v24, *v25 != *v24))) )
      {
        v26 = 1;
        if ( v17 <= 0 )
          v26 = -1;
        goto LABEL_21;
      }
LABEL_20:
      v26 = 0;
LABEL_21:
      v9 = v43;
      if ( !v26 )
      {
        v10 = v44;
LABEL_29:
        v12 += 88;
        if ( ++v42 >= (unsigned int)*(_WORD *)(v51 + 3) )
        {
          v28 = v47;
          goto LABEL_31;
        }
        goto LABEL_3;
      }
      v13 = v48;
LABEL_23:
      v13 += 88;
      v27 = v49++ + 1 < (unsigned int)*(_WORD *)(v5 + 3);
      v48 = v13;
      if ( !v27 )
      {
        v10 = v44;
        break;
      }
    }
  }
  v28 = v47;
  v29 = *(_DWORD *)v12
      + *(_DWORD *)(v12 - 8)
      + *(_DWORD *)(v12 - 16)
      + *(_DWORD *)(v12 + 24)
      + *(_DWORD *)(v12 - 24)
      + *(_DWORD *)(v12 - 32)
      + *(_DWORD *)(v12 - 40)
      + *(_DWORD *)(v12 - 48)
      + *(_DWORD *)(v12 - 56);
  if ( v47 < 499 && v10 >= v29 + 88 )
  {
    dword_1050DE80[v47] = v42;
    v47 = v28 + 1;
    v10 += -88 - v29;
    v44 = v10;
    goto LABEL_29;
  }
LABEL_31:
  if ( v28 <= 0 )
  {
    result = 0;
  }
  else
  {
    v30 = 88 * v28;
    v45 = (char *)v50 + 88 * v28;
    memcpy_0(v45, v50, *(_DWORD *)(a2 + 26));
    *(_DWORD *)(a2 + 20) += v30;
    result = v30;
    v49 = v30;
    v48 = 0;
    if ( v47 > 0 )
    {
      while ( 1 )
      {
        v31 = (void *)(88 * *(_WORD *)(v5 + 3) + v5 + 5);
        v32 = (const void *)(88 * dword_1050DE80[v48] + v51 + 5);
        qmemcpy(v31, v32, 0x58u);
        v33 = sub_10010230((int)v31, &v46, (int)v32, v43, (int)v45);
        v34 = sub_10010230((int)v31 + 8, &v46, (int)v32 + 8, v43, (int)v45) + v33;
        v35 = sub_10010230((int)v31 + 16, &v46, (int)v32 + 16, v43, (int)v45) + v34;
        v36 = sub_10010230((int)v31 + 24, &v46, (int)v32 + 24, v43, (int)v45) + v35;
        v37 = sub_10010230((int)v31 + 32, &v46, (int)v32 + 32, v43, (int)v45) + v36;
        v38 = sub_10010230((int)v31 + 40, &v46, (int)v32 + 40, v43, (int)v45) + v37;
        v39 = sub_10010230((int)v31 + 48, &v46, (int)v32 + 48, v43, (int)v45) + v38;
        v40 = sub_10010230((int)v31 + 56, &v46, (int)v32 + 56, v43, (int)v45) + v39;
        v41 = sub_10010230((int)v31 + 80, &v46, (int)v32 + 80, v43, (int)v45);
        *(_DWORD *)(a2 + 26) += v41 + v40;
        ++*(_WORD *)(v52 + 3);
        v49 += v41 + v40;
        if ( ++v48 >= v47 )
          break;
        v5 = v52;
      }
      result = v49;
    }
  }
  return result;
}
// 1050DE80: using guessed type int dword_1050DE80[];

//----- (10011320) --------------------------------------------------------
char sub_10011320()
{
  char v0; // bl@1
  signed int v1; // edi@3
  int v2; // ecx@3
  void *v3; // ecx@3
  void *v4; // eax@11
  char v5; // al@11
  void *v6; // eax@12
  void *v8; // [sp+8h] [bp-34h]@11
  int v9; // [sp+Ch] [bp-30h]@11
  int v10; // [sp+10h] [bp-2Ch]@11
  int v11; // [sp+14h] [bp-28h]@11
  char v12[4]; // [sp+18h] [bp-24h]@14
  int v13; // [sp+1Ch] [bp-20h]@14
  int v14; // [sp+20h] [bp-1Ch]@14
  int v15; // [sp+24h] [bp-18h]@1
  int v16; // [sp+28h] [bp-14h]@6
  int v17; // [sp+2Ch] [bp-10h]@6
  int v18; // [sp+30h] [bp-Ch]@6
  int v19; // [sp+34h] [bp-8h]@6

  v0 = 0;
  sub_10060E00(2122, (int)&v15, 20);
  if ( !dword_107FC4DC )
    dword_107FC4DC = sub_10060900() + 120000;
  v1 = sub_100321F0(2u);
  if ( !(v1 & j_HWM_pvg_hsdb_get_lrus_online(v2)) && sub_1002C5E0(v3) != 4 )
  {
    sub_10010210(5);
    return 0;
  }
  if ( !sub_1000FF70(&unk_10441700, v15, v16, v17, v18, v19) )
  {
    sub_10010210(3);
    return 0;
  }
  byte_104416FC = ((unsigned int)(unsigned __int8)byte_104416FC + 1) % 0xFF;
  if ( (int *)dword_1050DE38 != &dword_1050DE38 )
    sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds_wx.c", 3100, 1, 0);
  if ( (int *)dword_107FC490 != &dword_107FC490 )
    sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds_wx.c", 3101, 1, 0);
  v9 = 0;
  v11 = 0;
  BYTE2(v9) = byte_104416FC;
  LOWORD(v9) = 1;
  v8 = &unk_1050DE28;
  v10 = 8 * ((unsigned __int8)byte_10441701 + (unsigned __int8)byte_10441702 + (unsigned __int8)byte_10441703) + 20;
  sub_10060A60(79, 5000);
  v4 = sub_1000F760(0);
  v5 = sub_10005740((int)v4, (int)&v8, (int)&unk_107FC480);
  if ( v5 )
  {
    sub_10010210(byte_1008CDD0[(unsigned __int8)v5]);
  }
  else
  {
    v0 = 1;
    v6 = sub_10010270(0);
    sub_10004C50((int)v6, 0);
    dword_104416F8 = 0;
    byte_104416FF = 0;
    sub_10010210(1);
  }
  sub_10060A00(79);
  v13 = 0;
  v14 = 0;
  sub_10032600(v12);
  dword_107FC4D8 = *(_DWORD *)v12 + dword_105026DC;
  sub_10060ED0(9197, (int)&dword_107FC4D8, 4);
  sub_10060ED0(9219, (int)&v13, 8);
  return v0;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 104416F8: using guessed type int dword_104416F8;
// 104416FC: using guessed type char byte_104416FC;
// 104416FF: using guessed type char byte_104416FF;
// 10441701: using guessed type char byte_10441701;
// 10441702: using guessed type char byte_10441702;
// 10441703: using guessed type char byte_10441703;
// 105026DC: using guessed type int dword_105026DC;
// 1050DE38: using guessed type int dword_1050DE38;
// 107FC490: using guessed type int dword_107FC490;
// 107FC4D8: using guessed type int dword_107FC4D8;
// 107FC4DC: using guessed type int dword_107FC4DC;

//----- (10011570) --------------------------------------------------------
int sub_10011570()
{
  void *v0; // ecx@1
  void *v1; // edi@2
  void *v2; // esi@2
  signed int v3; // ebp@2
  void *v4; // esi@5
  signed int v5; // edi@5
  int result; // eax@7
  char v7; // [sp+Ch] [bp-8h]@1
  char v8; // [sp+Dh] [bp-7h]@1
  unsigned __int8 v9; // [sp+Eh] [bp-6h]@7
  char v10; // [sp+Fh] [bp-5h]@7
  int v11; // [sp+10h] [bp-4h]@1

  v7 = 0;
  v8 = 0;
  v11 = 0;
  byte_105026DA = sub_10033580();
  byte_104416FD = 0;
  dword_104416F8 = 0;
  byte_104416FE = 0;
  dword_107FC4DC = 0;
  byte_104416FC = 0;
  byte_105026DB = 1;
  dword_10441A5C = 0;
  byte_104416FF = 0;
  sub_100056F0(&unk_1050DE28, (int)sub_10010470, 0, (int)&unk_107FC470, 2, 0, (int)sub_1000FAC0, 0);
  sub_10005540(&unk_107FC480, (int)sub_100103D0, (int)&unk_1050E650, 3070714);
  if ( sub_1002C660(v0) == 4 )
  {
    v1 = &unk_107FC150;
    v2 = &unk_107FC400;
    v3 = 7;
    do
    {
      sub_10004CE0(v1, (int)sub_10010470, 0, (int)v2, 2, 0, (int)sub_1000FA50, 0);
      v2 = (char *)v2 + 16;
      v1 = (char *)v1 + 80;
      --v3;
    }
    while ( v3 );
  }
  else
  {
    v4 = &unk_107FC150;
    v5 = 7;
    do
    {
      sub_10004CA0(v4, (int)sub_100103D0, (int)&unk_1050E650, 3070714);
      v4 = (char *)v4 + 80;
      --v5;
    }
    while ( v5 );
  }
  sub_10061000(9195, &v9, 1, &v7);
  sub_10061000(9196, &v10, 1, &v8);
  result = sub_10061000(9197, &dword_107FC4D8, 4, &v11);
  dword_105026DC = 60000 * v9;
  return result;
}
// 1000FA50: using guessed type int sub_1000FA50();
// 1000FAC0: using guessed type int sub_1000FAC0();
// 10010470: using guessed type int sub_10010470();
// 104416F8: using guessed type int dword_104416F8;
// 104416FC: using guessed type char byte_104416FC;
// 104416FD: using guessed type char byte_104416FD;
// 104416FE: using guessed type char byte_104416FE;
// 104416FF: using guessed type char byte_104416FF;
// 10441A5C: using guessed type int dword_10441A5C;
// 105026DA: using guessed type char byte_105026DA;
// 105026DB: using guessed type char byte_105026DB;
// 105026DC: using guessed type int dword_105026DC;
// 107FC4D8: using guessed type int dword_107FC4D8;
// 107FC4DC: using guessed type int dword_107FC4DC;

//----- (100116D0) --------------------------------------------------------
void __cdecl sub_100116D0(unsigned int a1, unsigned __int8 a2)
{
  void *v2; // ecx@0
  void *v3; // eax@6
  char v4; // al@7
  char v5; // bl@7
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@3
  char v7[4]; // [sp+8h] [bp-1Ch]@3
  int v8; // [sp+Ch] [bp-18h]@9
  int v9; // [sp+10h] [bp-14h]@9
  int v10; // [sp+14h] [bp-10h]@9
  int v11; // [sp+18h] [bp-Ch]@9
  int v12; // [sp+1Ch] [bp-8h]@9

  switch ( (unsigned __int8)(a1 >> 16) )
  {
    case 0u:
      sub_10060ED0(dword_1008CDC0[a2], (int)&a1 + 3, 1);
      break;
    case 2u:
      sub_10060E00(9195, (int)&v6, 1);
      dword_105026DC = 60 * v6;
      sub_10032600(v7);
      dword_107FC4D8 = *(_DWORD *)v7 + dword_105026DC;
      sub_10060ED0(9197, (int)&dword_107FC4D8, 4);
      break;
    case 1u:
      sub_100102C0(13);
      dword_107FC4DC = 0;
      break;
    case 3u:
      if ( sub_10032470(v2) != 1 )
      {
        sub_10060A60(79, 5000);
        v3 = sub_1000F760(0);
        sub_10005BF0((int)v3);
        sub_10060A00(79);
        dword_107FC4DC = 0;
        sub_10011320();
      }
      break;
    case 4u:
      v4 = sub_10032470(v2);
      v5 = v4;
      if ( !v4 || v4 == 3 )
      {
        sub_10060E00(2122, (int)&v8, 20);
        if ( sub_1000FF70(&unk_10441700, v8, v9, v10, v11, v12) )
        {
          if ( v5 )
            sub_10010210(0);
        }
        else if ( v5 != 3 )
        {
          sub_10010210(3);
        }
      }
      break;
    case 5u:
      sub_1000FB50(SBYTE3(a1));
      break;
    default:
      return;
  }
}
// 1008CDC0: using guessed type int dword_1008CDC0[];
// 105026DC: using guessed type int dword_105026DC;
// 107FC4D8: using guessed type int dword_107FC4D8;
// 107FC4DC: using guessed type int dword_107FC4DC;

//----- (100118D0) --------------------------------------------------------
unsigned __int8 __fastcall sub_100118D0(void *a1)
{
  unsigned __int8 result; // al@1
  char v2; // al@5
  void *v3; // [sp+0h] [bp-4h]@1

  v3 = a1;
  result = sub_10032600((char *)&v3);
  if ( dword_105026DC )
  {
    result = sub_1002C680(1);
    if ( !result )
    {
      result = sub_100324A0(1);
      if ( result )
      {
        if ( (unsigned int)v3 > dword_107FC4D8 )
        {
          v2 = sub_10032470(v3);
          if ( !v2 || (result = v2 - 2, result <= 3u) )
          {
            if ( dword_107FC4DC && (unsigned int)v3 >= dword_107FC4DC )
            {
              result = sub_10010210(7);
            }
            else
            {
              result = sub_10011320();
              if ( !result )
              {
                dword_107FC4D8 = (int)v3 + 30000;
                result = sub_10060ED0(9197, (int)&dword_107FC4D8, 4);
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 105026DC: using guessed type int dword_105026DC;
// 107FC4D8: using guessed type int dword_107FC4D8;
// 107FC4DC: using guessed type int dword_107FC4DC;

//----- (10011970) --------------------------------------------------------
int __usercall sub_10011970@<eax>(int result@<eax>, int a2, int a3, size_t a4, char a5)
{
  int v5; // ebx@1
  int v6; // eax@2
  int v7; // ebp@2
  size_t v8; // edx@2
  void *v9; // ecx@2
  int v10; // eax@8
  int v11; // ST1C_4@23
  char v12; // al@23
  int v13; // eax@24
  int v14; // eax@27
  char v15; // [sp+6h] [bp-1Ah]@16
  char v16; // [sp+7h] [bp-19h]@16
  char v17; // [sp+8h] [bp-18h]@16
  char v18; // [sp+9h] [bp-17h]@16
  char v19; // [sp+Ah] [bp-16h]@16
  char v20; // [sp+Bh] [bp-15h]@16
  char v21[4]; // [sp+Ch] [bp-14h]@16
  char v22; // [sp+10h] [bp-10h]@16
  char v23; // [sp+12h] [bp-Eh]@16
  char v24; // [sp+14h] [bp-Ch]@16
  char v25; // [sp+15h] [bp-Bh]@16
  void *v26; // [sp+18h] [bp-8h]@2
  int v27; // [sp+1Ch] [bp-4h]@2

  v5 = result;
  if ( *(_BYTE *)(result + 1) )
  {
    v6 = sub_10032680(a3);
    sub_10060A60(v6, 30000);
    v7 = 132 * (unsigned __int8)a3;
    v8 = *(_DWORD *)(dword_109FFDCC + v7 + 1652);
    v9 = *(void **)(dword_109FFDCC + v7 + 1656);
    v27 = (unsigned __int8)a3;
    v26 = v9;
    if ( v8 >= a4 )
    {
      if ( *(_BYTE *)(156 * (unsigned __int8)a3 + dword_109FFDCC + 446)
        && *(_BYTE *)(dword_109FFDCC + v7 + 1640)
        && !*(_BYTE *)(dword_109FFDCC + v7 + 1632)
        && *(_BYTE *)(dword_109FFDCC + v7 + 1633) == 2 )
      {
        switch ( *(_BYTE *)a2 )
        {
          case 5:
            v10 = sub_10010730(v5);
            goto LABEL_14;
          case 0x1B:
          case 0x1C:
            v10 = sub_10010920(dword_109FFDCC + v7 + 1648, v5);
            goto LABEL_14;
          case 0x23:
            v10 = sub_10010FB0(dword_109FFDCC + v7 + 1648, v5);
            goto LABEL_14;
          case 0x2A:
            v10 = sub_10010DE0(dword_109FFDCC + v7 + 1648, v5);
            goto LABEL_14;
          case 0x46:
            v10 = sub_10010BF0(v5);
            goto LABEL_14;
          case 0x47:
            v10 = sub_10010570(v5);
LABEL_14:
            a4 += v10;
            break;
          default:
            break;
        }
      }
      if ( a5 )
      {
        sub_10032600(v21);
        sub_1002C6F0((int)&v24, *(unsigned int *)v21);
        sub_1002C910((int)&v22, *(unsigned int *)v21);
        v18 = v22;
        v20 = v23;
        v16 = v25;
        if ( sub_1001FF50(a3, &v15, &v17, &v19) )
        {
          if ( v15 >= 0 )
            *(_BYTE *)(v15 + *(_DWORD *)(v5 + 8)) = v16;
          if ( v17 > 0 )
            *(_BYTE *)(v17 + *(_DWORD *)(v5 + 8)) = v18;
          if ( v19 > 0 )
            *(_BYTE *)(v19 + *(_DWORD *)(v5 + 8)) = v20;
        }
      }
      v11 = *(_DWORD *)(v5 + 8);
      v12 = sub_1001E5D0(a3);
      if ( sub_1001E500(v12, 0, v5 + 12, v11) )
      {
        v13 = 132
            * (*(_DWORD *)(dword_109FFDCC + 20 * (unsigned __int8)a3 + 604)
             + *(_BYTE *)(dword_109FFDCC + 20 * (unsigned __int8)a3 + 592));
        *(_BYTE *)(v13 + dword_109FFDCC + 1649) = 1;
        *(_WORD *)(v13 + dword_109FFDCC + 1758) = *(_BYTE *)a2;
        qmemcpy((void *)(v13 + dword_109FFDCC + 1660), (const void *)(v5 + 12), 0x60u);
        memcpy(v26, *(const void **)(v5 + 8), a4);
        *(_BYTE *)(*(_DWORD *)(dword_109FFDCC + 608) + v7 + 8) = 1;
        *(_BYTE *)(*(_DWORD *)(dword_109FFDCC + 608) + v7) = a5;
        *(_BYTE *)(*(_DWORD *)(dword_109FFDCC + 608) + v7 + 1) = 2;
        if ( !(_BYTE)a3 )
        {
          sub_1000B330(1);
          *(_BYTE *)(dword_109FFDCC + 1765) = 2;
          *(_BYTE *)(dword_109FFDCC + 1772) = 1;
          *(_BYTE *)(*(_DWORD *)(dword_109FFDCC + 608) + 1) = 2;
          *(_BYTE *)(dword_109FFDCC + 14618951) = (*(_BYTE *)(dword_109FFDCC + 14618951) + 1) % 255;
        }
        sub_100201C0(a3);
        *(_BYTE *)(v27 + dword_109FFDCC + 14618950) = (*(_BYTE *)(v27 + dword_109FFDCC + 14618950) + 1) % 255;
      }
    }
    v14 = sub_10032680(a3);
    result = sub_10060A00(v14);
  }
  return result;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (10011D00) --------------------------------------------------------
void __cdecl sub_10011D00(int a1, unsigned int a2)
{
  unsigned int v2; // ebx@1
  int v3; // ebp@4
  unsigned __int8 v4; // al@5
  unsigned int v5; // edi@5
  unsigned int v6; // eax@6
  int v7; // esi@16
  char v8; // al@16
  int v9; // edi@16
  unsigned __int8 v10; // al@18
  unsigned int v11; // ebx@20
  int v12; // eax@21
  int v13; // [sp+4h] [bp-80h]@0
  int v14; // [sp+8h] [bp-7Ch]@14
  bool v15; // [sp+Ch] [bp-78h]@4
  char v16; // [sp+10h] [bp-74h]@21
  int v17; // [sp+14h] [bp-70h]@21
  void *v18; // [sp+18h] [bp-6Ch]@21

  v2 = a2;
  if ( a2 >= 0x14 )
  {
    if ( sub_100324A0(1) )
    {
      if ( sub_10033580() == 1 )
      {
        v3 = a1;
        v15 = strncmp((const char *)(a1 + 8), "SimData", 8u) == 0;
        if ( *(_BYTE *)a1 == 1 )
        {
          v4 = *(_BYTE *)(a1 + 17);
          v5 = 4 * (((unsigned int)v4 + 21) >> 2);
          if ( v4 )
          {
            sub_1002C120(dword_109FFDCC + 8624, (_BYTE *)(a1 + 18), 180);
            v6 = *(_BYTE *)(a1 + 17);
            if ( v6 >= 0xB3 )
              v6 = 179;
            *(_BYTE *)(dword_109FFDCC + v6 + 8624) = 0;
          }
          else
          {
            *(_BYTE *)(dword_109FFDCC + 8624) = 0;
          }
          if ( !*(_BYTE *)(a1 + 16) )
            sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds_wx.c", 3321, 0, 0);
          if ( v5 > a2 - 12 )
            sub_10028BC0("..\\lib\\acl\\iop\\iop_gfds_wx.c", 3322, 0, 0);
          v14 = 0;
          if ( *(_BYTE *)(a1 + 16) )
          {
            while ( 1 )
            {
              if ( v5 > v2 - 12 )
                return;
              v7 = v5 + v3;
              v8 = sub_1001E550(*(_BYTE *)(v5 + v3), 0);
              v9 = v5 + 12;
              LOBYTE(v13) = v8;
              if ( (unsigned __int8)v8 >= 0x34u )
                goto LABEL_23;
              if ( *(_BYTE *)(v7 + 1) != 1 )
                goto LABEL_23;
              v10 = *(_BYTE *)(v7 + 2);
              if ( !v10 || v10 > 0x10u )
                goto LABEL_23;
              v11 = *(_DWORD *)(v7 + 4);
              if ( v11 > a2 - v9 )
                break;
              memset(&v16, 0, 0x74u);
              v18 = &unk_10441A60;
              v17 = 789626;
              v12 = sub_1000F7F0((unsigned int *)(v9 + v3), (int)&v16, v7, v13, v11);
              sub_10011970((int)&v16, v7, v13, v12, v15);
              v3 = a1;
              v2 = a2;
              *(_BYTE *)((unsigned __int8)v13 + dword_109FFDCC + 14618950) = (*(_BYTE *)((unsigned __int8)v13
                                                                                       + dword_109FFDCC
                                                                                       + 14618950)
                                                                            + 1)
                                                                           % 255;
LABEL_24:
              v5 = 4 * ((unsigned int)(*(_DWORD *)(v7 + 4) + v9 + 3) >> 2);
              if ( ++v14 >= *(_BYTE *)(v3 + 16) )
                return;
            }
            v2 = a2;
LABEL_23:
            if ( *(_DWORD *)(v7 + 4) > v2 - v9 )
              return;
            goto LABEL_24;
          }
        }
      }
    }
  }
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (10011F20) --------------------------------------------------------
void sub_10011F20()
{
  void *v0; // ecx@1
  char v1; // bl@1
  void *v2; // ecx@5
  unsigned int v3; // eax@7
  void *v4; // ecx@10
  void *v5; // ecx@12
  void *v6; // eax@18
  int v7; // [sp+8h] [bp-70h]@7
  unsigned int v8; // [sp+Ch] [bp-6Ch]@7
  char v9; // [sp+10h] [bp-68h]@15
  unsigned __int16 v10; // [sp+14h] [bp-64h]@15
  char v11; // [sp+24h] [bp-54h]@15

  dword_10441A5C = 0;
  v1 = sub_10033580();
  if ( v1 != byte_105026DA )
  {
    byte_105026DA = v1;
    sub_1000FB50(v1);
    if ( v1 == 1 && sub_10032470(v0) != 1 )
      byte_104416FD = 1;
  }
  if ( sub_1002C660(v0) == 4 && sub_10032470(v2) == 1 )
  {
    v3 = (unsigned int)(dword_107FC484 - dword_107FC498) / *((_DWORD *)sub_1000F760(0) + 20);
    v7 = dword_107FC484 - dword_107FC498;
    v8 = v3;
    sub_10060F90(9219, (int)&v7, 8);
  }
  if ( byte_104416FD )
  {
    byte_104416FD = 0;
    sub_10011D00((int)&unk_1050E650, dword_104416F8);
    byte_104416FE = 1;
  }
  else if ( sub_1002C660(v2) == 4 )
  {
    if ( byte_104416FE )
    {
      if ( sub_10032470(v4) != 1 )
        sub_10010210(1);
      byte_104416FE = 0;
      sub_10010310(v5);
      if ( dword_104416F8 )
      {
        sub_10060E00(2122, (int)&v9, 20);
        sub_1002C2B0(&v11, 0x50u, "WWWx_%d.data", v10);
        sub_1001FAA0((int)"WWWx", (int)&v11, (int)&unk_1050E650, dword_104416F8, 0, 0, 0);
      }
    }
    sub_100118D0(v4);
  }
  else if ( byte_105026DB )
  {
    v6 = sub_10010270(0);
    sub_10005DC0((int)v6);
    byte_105026DB = 0;
  }
}
// 104416F8: using guessed type int dword_104416F8;
// 104416FD: using guessed type char byte_104416FD;
// 104416FE: using guessed type char byte_104416FE;
// 10441A5C: using guessed type int dword_10441A5C;
// 105026DA: using guessed type char byte_105026DA;
// 105026DB: using guessed type char byte_105026DB;
// 107FC484: using guessed type int dword_107FC484;
// 107FC498: using guessed type int dword_107FC498;

//----- (100120D0) --------------------------------------------------------
char sub_100120D0()
{
  unsigned __int8 v0; // bl@1
  int v1; // esi@4
  char v2; // bl@4
  unsigned __int8 v3; // al@7
  int v4; // eax@14
  char v6; // [sp+8h] [bp-78h]@1
  unsigned __int8 v7; // [sp+Ch] [bp-74h]@1
  int v8; // [sp+10h] [bp-70h]@1
  int v9; // [sp+14h] [bp-6Ch]@1
  int v10; // [sp+18h] [bp-68h]@1
  int v11; // [sp+1Ch] [bp-64h]@1
  int v12; // [sp+20h] [bp-60h]@1
  int v13; // [sp+24h] [bp-5Ch]@1
  char v14; // [sp+28h] [bp-58h]@1
  char v15; // [sp+29h] [bp-57h]@9
  char v16[2]; // [sp+2Ah] [bp-56h]@12
  char v17; // [sp+2Ch] [bp-54h]@2
  char v18; // [sp+2Dh] [bp-53h]@9
  char v19; // [sp+2Eh] [bp-52h]@10
  char v20[4]; // [sp+78h] [bp-8h]@7

  memset(&v14, 0, 0x52u);
  v0 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v6 = 1;
  v7 = 0;
  do
  {
    if ( v17 == 8 )
      break;
    if ( sub_10032340(v7, 1u) )
    {
      v1 = v0;
      v2 = byte_1008D862[4 * v0];
      if ( !v6 || (v6 = 1, !sub_100144B0((unsigned __int16)word_1008D860[2 * v1], (int)&byte_10A08A80, &v8)) )
        v6 = 0;
      v3 = v8;
      v20[v1] = BYTE1(v8);
      *(&v14 + 4 * (unsigned __int8)v2) = byte_1008D868[v3];
      if ( !v17 )
      {
        switch ( v3 )
        {
          case 5u:
            v17 = 5;
            v18 = 1 << v2;
            *(&v15 + 4 * (unsigned __int8)v2) = 2;
            break;
          case 4u:
            v17 = 1;
            v19 = 1 << v2;
            break;
          case 2u:
            v17 = 8;
            break;
          case 1u:
          case 7u:
            v17 = 4;
            v16[4 * (unsigned __int8)v2] = 2;
            break;
          default:
            break;
        }
      }
    }
    v0 = v7++ + 1;
  }
  while ( v7 < 2u );
  v4 = sub_10060900();
  sub_10013610(361, v6, (int)&byte_10A08A80, &v14, v4);
  return sub_100094A0(0x169u);
}
// 1008D860: using guessed type __int16 word_1008D860[];
// 10A08A80: using guessed type char byte_10A08A80;
// 100120D0: using guessed type char var_8[4];
// 100120D0: using guessed type char var_56[2];

//----- (10012260) --------------------------------------------------------
char __cdecl sub_10012260(int a1)
{
  int v1; // eax@1
  __int16 v2; // si@1
  char v3; // bl@1
  char v5; // [sp+8h] [bp-5Ch]@1
  char v6; // [sp+9h] [bp-5Bh]@2
  char v7; // [sp+Ah] [bp-5Ah]@1
  unsigned __int8 v8; // [sp+Bh] [bp-59h]@1
  char v9[84]; // [sp+Ch] [bp-58h]@1

  v1 = 3 * (unsigned __int8)sub_1002CE20(&a1, 2u, (int)&unk_1008D874, 6, 2);
  v2 = word_1008D876[v1];
  v8 = byte_1008D878[2 * v1];
  v5 = sub_100144B0(a1, (int)&byte_10A08A80, &v7);
  v3 = sub_100144B0(361, (int)&byte_10A08A80, v9);
  if ( sub_100321F0(0x1Fu) & 0x8000 )
  {
    if ( !sub_100144B0(133, (int)&byte_10A08A80, &v6) )
      return sub_1002D440(v2);
  }
  else
  {
    v6 = 2;
  }
  if ( (!v3 || v9[4 * v8] != 9) && (!v5 || v7 != 2) )
    return sub_1002D550(v2);
  return sub_1002D440(v2);
}
// 1008D876: using guessed type __int16 word_1008D876[];
// 10A08A80: using guessed type char byte_10A08A80;
// 10012260: using guessed type char var_58[84];

//----- (10012360) --------------------------------------------------------
char __cdecl sub_10012360(int a1)
{
  bool v1; // al@2
  char result; // al@4
  int v3; // eax@5
  int v4; // eax@5
  char v5; // [sp+3h] [bp-25h]@1
  char v6; // [sp+4h] [bp-24h]@5
  char v7; // [sp+5h] [bp-23h]@5
  int v8; // [sp+8h] [bp-20h]@2
  char v9; // [sp+Ch] [bp-1Ch]@1
  char v10; // [sp+Eh] [bp-1Ah]@4

  v5 = 0;
  if ( !sub_100144B0(a1, (int)&byte_10A08A80, &v9) || (v1 = sub_10032320((int)&v5), LOBYTE(v8) = 1, !v1) )
    LOBYTE(v8) = 0;
  result = v10;
  if ( v10 != v5 )
  {
    v6 = byte_1008D862[4 * (unsigned __int8)sub_1002CE20(&a1, 2u, (int)word_1008D860, 4, 2)];
    v7 = v5;
    v3 = sub_10060900();
    sub_10013610(29, v8, (int)&byte_10A08A80, &v6, v3);
    v4 = sub_100321F0(1u);
    result = sub_10013C10(29, v4, (int)&byte_10A08A80);
  }
  return result;
}
// 1008D860: using guessed type __int16 word_1008D860[];
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10012430) --------------------------------------------------------
char __cdecl sub_10012430(int a1)
{
  char result; // al@1

  result = a1;
  switch ( (unsigned __int16)a1 )
  {
    case 0x1Bu:
    case 0x1Cu:
      sub_100120D0();
      result = sub_10012360(a1);
      break;
    case 0x98u:
    case 0x99u:
      result = sub_10012260(a1);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10012500) --------------------------------------------------------
signed __int16 __usercall sub_10012500@<ax>(int a1@<eax>, int a2@<ecx>)
{
  signed __int16 result; // ax@2

  a1 = (unsigned __int16)a1;
  if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a2 + 4) )
    result = -1;
  else
    result = *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * a1);
  return result;
}

//----- (10012520) --------------------------------------------------------
int __usercall sub_10012520@<eax>(int a1@<esi>, signed int a2)
{
  int v2; // edx@1
  char v3; // cl@1
  int v4; // ebp@1
  signed int v5; // edx@1
  int v6; // eax@1
  int v7; // edi@2
  int v8; // ecx@3
  bool v9; // zf@3
  int v10; // edi@5
  signed int v11; // ebx@5
  int v12; // ebp@8
  int v13; // edx@9
  int v14; // eax@11
  __int16 v15; // cx@11
  char v16; // dl@11
  int v17; // edx@11
  int v18; // eax@11
  int v19; // ecx@11
  unsigned int v20; // eax@15
  int v21; // ecx@15
  char v23; // [sp+7h] [bp-29h]@5
  int v24; // [sp+8h] [bp-28h]@1
  int v25; // [sp+Ch] [bp-24h]@1
  int v26; // [sp+10h] [bp-20h]@8
  int v27; // [sp+14h] [bp-1Ch]@3
  int v28; // [sp+18h] [bp-18h]@3
  int v29; // [sp+1Ch] [bp-14h]@1
  char v30; // [sp+20h] [bp-10h]@1
  char v31; // [sp+21h] [bp-Fh]@1
  __int16 v32; // [sp+22h] [bp-Eh]@16
  int v33; // [sp+24h] [bp-Ch]@11
  int v34; // [sp+28h] [bp-8h]@11

  v2 = *(_DWORD *)(a1 + 60);
  v3 = *(_BYTE *)(a1 + 1);
  v4 = ~*(_DWORD *)(a1 + 72);
  v29 = *(_DWORD *)(a1 + 16);
  v30 = v3;
  v31 = 1;
  v25 = v4;
  sub_10060A60(v2, -1);
  v5 = a2;
  v6 = 0;
  v24 = 0;
  if ( a2 > 0 )
  {
    do
    {
      v7 = *(_DWORD *)(a1 + 48);
      if ( *(_BYTE *)(v7 + 20 * v6) != 1 )
      {
        v8 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v9 = *(_BYTE *)(a1 + 1) == 6;
        v27 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        v28 = v4 & (*(_DWORD *)(v7 + 20 * v6 + 12) | 0xC00000);
        if ( v9 || !(v8 & *(_DWORD *)(a1 + 84)) )
        {
          v23 = 1;
          v10 = *(_DWORD *)(a1 + 16) + 12;
          v11 = 12;
        }
        else
        {
          v10 = *(_DWORD *)(a1 + 16);
          v23 = 0;
          v11 = 0;
        }
        if ( v6 < v5 )
        {
          v12 = 20 * v6;
          v26 = v5 - v6;
          do
          {
            v13 = *(_DWORD *)(a1 + 48);
            if ( !*(_BYTE *)(v13 + v12) && v8 == (v25 & (*(_DWORD *)(v13 + v12 + 12) | 0xC00000)) )
            {
              v14 = v13 + v12;
              v15 = *(_WORD *)(v13 + v12 + 6);
              LOWORD(v33) = *(_WORD *)(v13 + v12 + 4);
              v16 = *(_BYTE *)(v13 + v12 + 1);
              BYTE1(v34) = *(_BYTE *)(v14 + 2);
              HIWORD(v33) = v15;
              LOBYTE(v34) = v16;
              v17 = v34;
              *(_DWORD *)v10 = v33;
              *(_DWORD *)(v10 + 4) = v17;
              memcpy(
                (void *)(v10 + 8),
                *(const void **)(*(_DWORD *)(a1 + 48) + v12 + 8),
                *(_WORD *)(*(_DWORD *)(a1 + 48) + v12 + 6));
              v18 = *(_DWORD *)(a1 + 48) + v12;
              v19 = *(_WORD *)(v18 + 6);
              v10 += v19 + 8;
              v11 += v19 + 8;
              v8 = v27;
              *(_BYTE *)v18 = 1;
            }
            v12 += 20;
            --v26;
          }
          while ( v26 );
          v4 = v25;
        }
        if ( v23 )
        {
          v20 = sub_10068380((unsigned int *)(*(_DWORD *)(a1 + 16) + 12), v11 - 12, 0xFFFFFFFF);
          v21 = *(_DWORD *)(a1 + 16);
          v33 = 327678;
          LOWORD(v34) = 1;
          *(_DWORD *)v21 = 327678;
          *(_DWORD *)(v21 + 4) = v34;
          *(_DWORD *)(v21 + 8) = v20;
        }
        v32 = v11;
        if ( j_HWM_pvg_hsdb_put(&v28) == -100 )
          sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 4355, 0, 0);
        v5 = a2;
      }
      v6 = v24 + 1;
      v24 = v6;
      v6 = (unsigned __int16)v6;
    }
    while ( (unsigned __int16)v6 < v5 );
  }
  return sub_10060A00(*(_DWORD *)(a1 + 60));
}
// 10061640: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (10012720) --------------------------------------------------------
int __usercall sub_10012720@<eax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@2
  signed __int16 v5; // ax@3
  int v6; // ebx@3
  int v7; // ebp@3
  int v8; // eax@3
  int v9; // ecx@3
  int v11; // [sp+4h] [bp-8h]@2
  int v12; // [sp+8h] [bp-4h]@3

  v3 = a1;
  sub_10060A60(*(_DWORD *)(a2 + 60), -1);
  if ( v3 )
  {
    v4 = 0;
    v11 = v3;
    do
    {
      v12 = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 4);
      v5 = sub_10012500(v12, a2);
      v6 = (unsigned __int16)v5;
      v7 = 52 * (unsigned __int16)v5;
      memcpy(
        (void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v7 + 4)),
        *(const void **)(v4 + *(_DWORD *)(a2 + 48) + 8),
        *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6));
      v8 = 24 * v6;
      *(_WORD *)(v8 + *(_DWORD *)(a2 + 64) + 4) = *(_WORD *)(v4 + *(_DWORD *)(a2 + 48) + 6);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 1) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 1);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 20) = *(_DWORD *)(v4 + *(_DWORD *)(a2 + 48) + 16);
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 2) = *(_BYTE *)(v4 + *(_DWORD *)(a2 + 48) + 2);
      *(_DWORD *)(v8 + *(_DWORD *)(a2 + 64) + 16) = a3;
      *(_BYTE *)(v8 + *(_DWORD *)(a2 + 64)) = 0;
      v9 = v7 + *(_DWORD *)(a2 + 32);
      if ( *(_DWORD *)(v9 + 36) && !*(_DWORD *)(v9 + 12) && !(*(_BYTE *)(v8 + *(_DWORD *)(a2 + 64) + 6) & 1) )
      {
        sub_10060A00(*(_DWORD *)(a2 + 60));
        (*(void (__cdecl **)(int, int))(*(_DWORD *)(a2 + 32) + v7 + 36))(v12, a2);
        sub_10060A60(*(_DWORD *)(a2 + 60), -1);
      }
      v4 += 20;
      --v11;
    }
    while ( v11 );
  }
  return sub_10060A00(*(_DWORD *)(a2 + 60));
}

//----- (10012840) --------------------------------------------------------
char __cdecl sub_10012840(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@2
  char result; // al@2

  LOWORD(v2) = sub_10012500(a1, a2);
  if ( (_WORD)v2 == -1 )
  {
    result = sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 670, 0, 0);
  }
  else
  {
    sub_10060A60(*(_DWORD *)(a2 + 60), -1);
    v2 = (unsigned __int16)v2;
    v3 = 52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32);
    memset((void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(v3 + 4)), 0, *(_WORD *)v3);
    result = sub_10060A00(*(_DWORD *)(a2 + 60));
    *(_BYTE *)(*(_DWORD *)(a2 + 64) + 24 * v2 + 1) = 0;
  }
  return result;
}

//----- (100128C0) --------------------------------------------------------
signed __int16 __cdecl sub_100128C0(int a1, int a2)
{
  return sub_10012500(a2, a1);
}

//----- (100128D0) --------------------------------------------------------
char __cdecl sub_100128D0(int a1, int a2, void *a3, unsigned __int16 a4)
{
  signed __int16 v4; // di@1
  int v5; // ebp@2
  int v6; // eax@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // edx@4
  int v11; // ecx@4
  unsigned __int16 v12; // di@4
  int v13; // ecx@6
  int v14; // ST2C_4@16
  int v15; // ST28_4@16
  const char *v16; // eax@16
  char v17; // [sp+13h] [bp-75h]@4
  unsigned __int16 v18; // [sp+18h] [bp-70h]@1
  unsigned int v19; // [sp+1Ch] [bp-6Ch]@1
  char v20; // [sp+20h] [bp-68h]@3

  v4 = sub_10012500(a1, a2);
  v18 = v4;
  v19 = sub_10060900();
  if ( v4 == -1 )
  {
    v17 = 0;
    sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 943, 0, 0);
  }
  else
  {
    v5 = 52 * (unsigned __int16)v4;
    v6 = *(_DWORD *)(a2 + 32) + v5;
    if ( *(_BYTE *)(v6 + 8) )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_10015B20(a2, v4);
      _snprintf(&v20, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 874, 0, &v20);
      return 0;
    }
    v10 = *(_DWORD *)(a2 + 64);
    v11 = 24 * (unsigned __int16)v4;
    v12 = *(_WORD *)(v10 + v11 + 4);
    v17 = *(_BYTE *)(v10 + v11 + 1);
    if ( *(_BYTE *)(v11 + v10)
      || *(_DWORD *)(v6 + 12)
      && ((v13 = *(_DWORD *)(v11 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v19 > v13 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v6 + 16)) )
    {
      v17 = 0;
    }
    if ( v12 && v12 <= a4 && v12 == *(_WORD *)v6 )
    {
      sub_10060A60(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v5 + 4)), v12);
      sub_10060A00(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v17 = 0;
    }
    if ( v12 > a4 || v12 != *(_WORD *)(*(_DWORD *)(a2 + 32) + v5) )
    {
      v14 = *(_BYTE *)(a2 + 1);
      v15 = *(_WORD *)(*(_DWORD *)(a2 + 32) + v5);
      v16 = sub_10015B20(a2, v18);
      _snprintf(&v20, 0x64u, "%d-%s by=%d sz=%d pi=%d bsz=%d", (unsigned __int16)a1, v16, v12, v15, v14, a4);
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 936, 0, &v20);
    }
  }
  return v17;
}

//----- (10012AC0) --------------------------------------------------------
int __cdecl sub_10012AC0(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int result; // eax@2

  v2 = sub_10012500(a1, a2);
  if ( v2 == -1 )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 992, 0, 0);
    result = 0;
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(v3 + 64) + 24 * (unsigned __int16)v2 + 20);
  }
  return result;
}

//----- (10012B10) --------------------------------------------------------
char __cdecl sub_10012B10(int a1, int a2, void *a3, unsigned __int16 *a4, unsigned __int16 a5)
{
  signed __int16 v5; // bp@1
  int v6; // edi@2
  int v7; // ST30_4@3
  const char *v8; // eax@3
  int v10; // ecx@4
  unsigned __int16 v11; // bp@4
  int v12; // eax@4
  int v13; // eax@5
  int v14; // ecx@6
  unsigned __int16 v15; // ax@14
  unsigned __int16 v16; // cx@14
  int v17; // ST2C_4@16
  int v18; // ST28_4@16
  int v19; // ST24_4@16
  const char *v20; // eax@16
  char v21; // [sp+13h] [bp-75h]@4
  unsigned __int16 v22; // [sp+18h] [bp-70h]@1
  unsigned int v23; // [sp+1Ch] [bp-6Ch]@1
  char v24; // [sp+20h] [bp-68h]@3

  v5 = sub_10012500(a1, a2);
  v22 = v5;
  v23 = sub_10060900();
  if ( v5 == -1 )
  {
    v21 = 0;
    *a4 = 0;
    sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1267, 0, 0);
  }
  else
  {
    v6 = 52 * (unsigned __int16)v5;
    if ( *(_BYTE *)(*(_DWORD *)(a2 + 32) + v6 + 8) != 1 )
    {
      v7 = *(_BYTE *)(a2 + 1);
      v8 = sub_10015B20(a2, v5);
      _snprintf(&v24, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v8, v7);
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1189, 0, &v24);
      return 0;
    }
    v10 = 24 * (unsigned __int16)v5;
    v11 = *(_WORD *)(v10 + *(_DWORD *)(a2 + 64) + 4);
    *a4 = v11;
    v12 = *(_DWORD *)(a2 + 64);
    v21 = *(_BYTE *)(v10 + v12 + 1);
    if ( *(_BYTE *)(v10 + v12)
      || (v13 = *(_DWORD *)(a2 + 32) + v6, *(_DWORD *)(v13 + 12))
      && ((v14 = *(_DWORD *)(v10 + *(_DWORD *)(a2 + 64) + 16)) == 0
       || v23 > v14 + *(_DWORD *)(a2 + 36) + *(_DWORD *)(v13 + 16)) )
    {
      v21 = 0;
    }
    if ( v11 && v11 <= *(_WORD *)(v6 + *(_DWORD *)(a2 + 32)) && v11 <= a5 )
    {
      sub_10060A60(*(_DWORD *)(a2 + 60), -1);
      memcpy(a3, (const void *)(*(_DWORD *)(a2 + 28) + *(_DWORD *)(*(_DWORD *)(a2 + 32) + v6 + 4)), *a4);
      sub_10060A00(*(_DWORD *)(a2 + 60));
    }
    else
    {
      v21 = 0;
    }
    v15 = *a4;
    v16 = *(_WORD *)(v6 + *(_DWORD *)(a2 + 32));
    if ( *a4 > v16 || v15 > a5 )
    {
      v17 = *(_BYTE *)(a2 + 1);
      v18 = v16;
      v19 = v15;
      v20 = sub_10015B20(a2, v22);
      _snprintf(&v24, 0x64u, "%d-%s by=%d sz=%d pipe=%d bsz=%d", (unsigned __int16)a1, v20, v19, v18, v17, a5);
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1260, 0, &v24);
    }
  }
  return v21;
}

//----- (10012D20) --------------------------------------------------------
int __cdecl sub_10012D20(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // ecx@3
  signed int v5; // ebx@7
  unsigned __int16 v6; // cx@7
  int v7; // eax@8
  int v8; // ecx@14

  v1 = *(_DWORD *)(a1 + 8);
  sub_10060A60(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      LOWORD(v3) = sub_10012500(v2, a1);
      if ( (_WORD)v3 != -1 )
      {
        v3 = (unsigned __int16)v3;
        v4 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v3;
        if ( *(_BYTE *)(v4 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v3 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v4 + 12)
            && *(_DWORD *)(v4 + 24) & *(_DWORD *)(a1 + 72) )
          {
            v5 = *(_DWORD *)(a1 + 8);
            v6 = 0;
            if ( v5 > 0 )
            {
              v7 = 0;
              do
              {
                if ( *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v7) == (_WORD)v2 )
                  break;
                v7 = ++v6;
              }
              while ( v6 < v5 );
            }
            if ( v6 == v5 )
              *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v8 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 8) = v1;
  return sub_10060A00(v8);
}

//----- (10012DD0) --------------------------------------------------------
int __cdecl sub_10012DD0(int a1)
{
  int v1; // ebp@1
  int v2; // edi@1
  signed __int16 v3; // ax@2
  int v4; // ecx@3
  int v5; // eax@3
  int v6; // edx@12

  v1 = 0;
  sub_10060A60(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  if ( *(_DWORD *)(a1 + 4) > 0 )
  {
    do
    {
      v3 = sub_10012500(v2, a1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3 + *(_DWORD *)(a1 + 32);
        if ( *(_BYTE *)(v5 + 28) & *(_BYTE *)a1 )
        {
          if ( *(_BYTE *)(v4 + *(_DWORD *)(a1 + 24)) == 1
            && *(_DWORD *)(v5 + 12)
            && *(_DWORD *)(v5 + 20) & *(_DWORD *)(a1 + 72)
            && *(_DWORD *)(v5 + 24) )
          {
            if ( (unsigned int)*(_WORD *)v5 + 20 > *(_DWORD *)(a1 + 20) )
              sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1622, 0, 0);
            else
              *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v1++) = v2;
          }
        }
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int16)v2 < *(_DWORD *)(a1 + 4) );
  }
  v6 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 12) = v1;
  return sub_10060A00(v6);
}

//----- (10012E80) --------------------------------------------------------
char __cdecl sub_10012E80(int a1)
{
  char v1; // cl@1
  int v2; // eax@2
  int v3; // ebx@3
  signed int v4; // ebp@3
  unsigned int v5; // eax@3
  unsigned int v6; // edi@3
  bool v7; // zf@3
  unsigned int v8; // eax@4
  unsigned int v9; // eax@6
  int v10; // edx@15
  int v11; // eax@15
  int v12; // edi@15
  int v13; // edx@15
  int v14; // ebp@15
  int v15; // ebx@15
  int v16; // eax@15
  int v17; // eax@19
  char v18; // cl@19
  int v19; // ecx@24
  int v20; // edi@25
  int v21; // ecx@30
  int v22; // edx@30
  unsigned int v23; // edi@38
  int v24; // ebp@44
  int v25; // eax@45
  int v26; // edx@45
  int v27; // ecx@45
  void (__cdecl *v28)(int, int); // edi@45
  unsigned int v30; // [sp+10h] [bp-90h]@3
  int v31; // [sp+14h] [bp-8Ch]@3
  int v32; // [sp+18h] [bp-88h]@20
  unsigned int v33; // [sp+18h] [bp-88h]@44
  int v34; // [sp+1Ch] [bp-84h]@1
  int v35; // [sp+20h] [bp-80h]@2
  int v36; // [sp+24h] [bp-7Ch]@1
  char v37; // [sp+28h] [bp-78h]@1
  unsigned __int16 v38; // [sp+2Ah] [bp-76h]@3
  unsigned int v39; // [sp+2Ch] [bp-74h]@1
  int v40; // [sp+30h] [bp-70h]@15
  int v41; // [sp+34h] [bp-6Ch]@3
  char v42; // [sp+38h] [bp-68h]@9

  v1 = *(_BYTE *)(a1 + 1);
  v36 = *(_DWORD *)(a1 + 16);
  v37 = v1;
  v39 = sub_10060900();
  v34 = 0;
LABEL_2:
  while ( 1 )
  {
    v2 = j_HWM_pvg_hsdb_get(&v35, *(_DWORD *)(a1 + 20));
    if ( v2 <= 0 )
      break;
    v3 = *(_DWORD *)(a1 + 16);
    v4 = v38;
    v5 = *(_DWORD *)v3;
    v6 = 0;
    v7 = (unsigned __int16)*(_DWORD *)v3 == -2;
    v31 = v38;
    v30 = 0;
    v41 = *(_DWORD *)(v3 + 4);
    if ( v7 )
    {
      v8 = v5 >> 16;
      v4 = -8 - (unsigned __int16)v8 + v38;
      v31 = -8 - (unsigned __int16)v8 + v38;
      v3 += (unsigned __int16)v8 + 8;
      if ( (unsigned __int16)v8 < 4u || v4 <= 0 )
      {
        v31 = 0;
        v4 = 0;
        v9 = ~v34;
      }
      else
      {
        v34 = *(_DWORD *)(v3 - 4);
        v9 = sub_10068380((unsigned int *)v3, v4, 0xFFFFFFFF);
      }
      if ( v34 != v9 )
      {
        _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
        sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1796, 0, &v42);
        continue;
      }
    }
    else if ( *(_BYTE *)(a1 + 1) == 6 )
    {
      _snprintf(&v42, 0x64u, "crc error rxsz=%d pipe=%d addr=0x%lx", v38, v37, v35);
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1817, 0, &v42);
      continue;
    }
    if ( v4 > 0 )
    {
      while ( 1 )
      {
        v10 = *(_DWORD *)v3;
        v11 = *(_DWORD *)(v3 + 4);
        v12 = 20 * v6;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 4) = *(_DWORD *)v3;
        *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6) = HIWORD(v10);
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 1) = v11;
        *(_BYTE *)(v12 + *(_DWORD *)(a1 + 48) + 2) = BYTE1(v11);
        v40 = v10;
        LOWORD(v14) = sub_10012500(v10, a1);
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16) = v35;
        v15 = v3 + 8;
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 8) = v15;
        v16 = *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6);
        v3 = v16 + v15;
        v31 += -8 - v16;
        if ( v31 < 0 )
        {
          _snprintf(
            &v42,
            0x64u,
            "error with pkt id %d rxsz=%d pipe=%d",
            (unsigned __int16)v13,
            HIWORD(v40),
            *(_BYTE *)(a1 + 1));
          sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1877, 0, &v42);
          goto LABEL_2;
        }
        if ( *(_DWORD *)(a1 + 80) )
          (*(void (__cdecl **)(int, int, _DWORD, _DWORD))(a1 + 80))(
            a1,
            v13,
            *(_WORD *)(v12 + *(_DWORD *)(a1 + 48) + 6),
            *(_DWORD *)(*(_DWORD *)(a1 + 48) + v12 + 8));
        if ( (_WORD)v14 == -1 )
        {
LABEL_39:
          v23 = v30;
          goto LABEL_40;
        }
        v14 = (unsigned __int16)v14;
        v17 = 52 * (unsigned __int16)v14 + *(_DWORD *)(a1 + 32);
        v18 = *(_BYTE *)(v17 + 8);
        if ( v18 )
        {
          v32 = v12 + *(_DWORD *)(a1 + 48);
          if ( *(_WORD *)(v32 + 6) <= *(_WORD *)v17 )
            goto LABEL_23;
          if ( v18 )
            goto LABEL_39;
        }
        v32 = v12 + *(_DWORD *)(a1 + 48);
        if ( *(_WORD *)(v32 + 6) != *(_WORD *)v17 )
          goto LABEL_39;
LABEL_23:
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 24) + v14) != 1 )
          goto LABEL_39;
        v19 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
        if ( (v19 & *(_DWORD *)(v17 + 20)) != v19 )
        {
          v20 = *(_DWORD *)(v12 + *(_DWORD *)(a1 + 48) + 16);
          if ( (v20 & 0xC00000) != v20 && !(*(_BYTE *)a1 & 4) )
            goto LABEL_39;
        }
        if ( !(*(_DWORD *)(v17 + 24) & *(_DWORD *)(a1 + 72)) || !(*(_BYTE *)(v17 + 28) & *(_BYTE *)a1) )
          goto LABEL_39;
        if ( *(_DWORD *)(v17 + 12) )
        {
          v21 = *(_DWORD *)(a1 + 64) + 24 * v14;
          v22 = *(_DWORD *)(v21 + 16);
          if ( v22 )
          {
            if ( v39 <= v22 + *(_DWORD *)(a1 + 36) + (*(_DWORD *)(v17 + 16) >> 1)
              && (*(_BYTE *)(v32 + 1) != 1 || *(_BYTE *)(v21 + 1) == 1 && *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && (*(_BYTE *)(v21 + 1) == 1 || *(_BYTE *)(v32 + 2) > *(_BYTE *)(v21 + 2))
              && *(_BYTE *)(v32 + 2) != *(_BYTE *)(v21 + 2) )
            {
              goto LABEL_39;
            }
          }
        }
        v23 = v30++ + 1;
LABEL_40:
        if ( !v31 || v23 >= *(_DWORD *)(a1 + 52) )
        {
          if ( v23 )
          {
            sub_10012720(v23, a1, v39);
            if ( v23 )
            {
              v24 = 0;
              v33 = v23;
              do
              {
                v25 = (unsigned __int16)sub_10012500(*(_WORD *)(*(_DWORD *)(a1 + 48) + v24 + 4), a1);
                v27 = *(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v25;
                v28 = *(void (__cdecl **)(int, int))(v27 + 36);
                if ( v28 && *(_DWORD *)(v27 + 12) && !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + 24 * v25 + 6) & 1) )
                  v28(v26, a1);
                v24 += 20;
                --v33;
              }
              while ( v33 );
            }
          }
          v30 = 0;
        }
        if ( v31 <= 0 )
          goto LABEL_2;
        v6 = v30;
      }
    }
  }
  if ( v2 == -95 )
    LOBYTE(v2) = sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2094, 0, 0);
  return v2;
}
// 10061610: using guessed type int __cdecl j_HWM_pvg_hsdb_get(_DWORD, _DWORD);

//----- (10013280) --------------------------------------------------------
int __cdecl sub_10013280(int a1)
{
  int v1; // ecx@0
  int result; // eax@1
  signed __int16 v3; // ax@2
  int v4; // ebx@2
  int v5; // edi@2
  unsigned int *v6; // edx@2
  int v7; // ebp@3
  unsigned int v8; // ecx@3
  unsigned int v9; // ebx@4
  unsigned int v10; // eax@4
  int v11; // ecx@5
  int v12; // eax@5
  int v13; // edx@8
  int v14; // ecx@8
  int v15; // edx@8
  unsigned int v16; // eax@12
  int v17; // edx@16
  int v18; // ST24_4@19
  const char *v19; // eax@19
  int v20; // eax@20
  int v21; // ecx@21
  int v22; // ebx@24
  int v23; // edx@26
  int v24; // eax@27
  int v25; // eax@29
  int v26; // eax@31
  int v27; // edx@31
  int v28; // eax@32
  int v29; // ecx@32
  int v30; // ebp@32
  void (__cdecl *v31)(int, int); // ebp@33
  unsigned int v32; // [sp+8h] [bp-8Ch]@1
  signed int v33; // [sp+Ch] [bp-88h]@1
  unsigned int v34; // [sp+10h] [bp-84h]@1
  int v35; // [sp+14h] [bp-80h]@1
  int v36; // [sp+18h] [bp-7Ch]@2
  int v37; // [sp+1Ch] [bp-78h]@1
  unsigned __int16 v38; // [sp+24h] [bp-70h]@2
  int v39; // [sp+28h] [bp-6Ch]@2
  char v40; // [sp+2Ch] [bp-68h]@19

  v34 = 12;
  v37 = j_HWM_pvg_hsdb_get_lrus_online(v1);
  v33 = 0;
  result = sub_10060900();
  v32 = result;
  v35 = 0;
  if ( *(_DWORD *)(a1 + 12) > 0 )
  {
    do
    {
      v36 = *(_WORD *)(*(_DWORD *)(a1 + 76) + 2 * v35);
      v3 = sub_10012500(v36, a1);
      v4 = (unsigned __int16)v3;
      v5 = 24 * (unsigned __int16)v3;
      v6 = (unsigned int *)(v5 + *(_DWORD *)(a1 + 64) + 8);
      v38 = v3;
      v39 = (unsigned __int16)v3;
      if ( v32 >= *v6 - *(_DWORD *)(a1 + 36) )
      {
        v7 = 52 * (unsigned __int16)v3;
        v8 = *v6 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + 52 * (unsigned __int16)v3 + 12);
        if ( v32 >= v8 )
        {
          v9 = *(_DWORD *)(*(_DWORD *)(a1 + 32) + v7 + 12);
          v6 = (unsigned int *)(v5 + *(_DWORD *)(a1 + 64) + 8);
          v10 = v9 * ((*(_DWORD *)(*(_DWORD *)(a1 + 32) + v7 + 12) - v8 + v32 - 1) / v9);
          v4 = v39;
          v8 += v10;
        }
        *v6 = v8;
        v11 = v37;
        v12 = v7 + *(_DWORD *)(a1 + 32);
        if ( v37 & *(_DWORD *)(v12 + 24) || v11 & 0xC00000 || (*(_DWORD *)(v12 + 32) >> 3) & 1 )
        {
          v16 = *(_WORD *)v12 + v34 + 8;
          if ( v33 > 0 && (v16 > *(_DWORD *)(a1 + 20) || v16 > 0x5B0) )
          {
            sub_10012520(a1, v33);
            v33 = 0;
            v34 = 12;
          }
          v17 = *(_DWORD *)(a1 + 32);
          if ( !*(_DWORD *)(v17 + v7 + 44) || *(_BYTE *)(v5 + *(_DWORD *)(a1 + 64) + 6) & 4 )
            goto LABEL_42;
          if ( (*(_DWORD *)(v17 + v7 + 32) >> 1) & 1 )
          {
            v18 = *(_BYTE *)(a1 + 1);
            v19 = sub_10015B20(a1, v38);
            _snprintf(&v40, 0x64u, "%d-%s is TX_ON_PUT, pipe=%d", (unsigned __int16)v36, v19, v18);
            sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2279, 0, &v40);
          }
          v20 = v5 + *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(*(_BYTE *)(a1 + 3) + v4 * *(_BYTE *)(a1 + 2) + *(_DWORD *)(a1 + 56)) > *(_BYTE *)(v20 + 2)
            && (v21 = *(_DWORD *)(v20 + 16)) != 0
            && v32 <= *(_DWORD *)(a1 + 36) + v21 + (*(_DWORD *)(*(_DWORD *)(a1 + 32) + v7 + 16) >> 1)
            && *(_BYTE *)(v20 + 1) == 1 )
          {
LABEL_42:
            v22 = v36;
          }
          else
          {
            v22 = v36;
            (*(void (__cdecl **)(int, int))(*(_DWORD *)(a1 + 32) + v7 + 44))(v36, a1);
          }
          v23 = *(_DWORD *)(a1 + 64);
          if ( *(_BYTE *)(v5 + v23 + 3) == 1 )
          {
            v24 = *(_DWORD *)(v5 + v23 + 16);
            if ( v24 )
            {
              if ( v32 <= *(_DWORD *)(a1 + 36) + v24 + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v7 + 12) )
              {
                *(_DWORD *)(v5 + *(_DWORD *)(a1 + 64) + 12) = v32;
                *(_BYTE *)(v5 + *(_DWORD *)(a1 + 64) + 3) = 0;
                v25 = *(_DWORD *)(a1 + 64);
                if ( *(_DWORD *)(v5 + v25 + 20) & *(_DWORD *)(a1 + 72) )
                {
                  if ( *(_WORD *)(v5 + v25 + 4) )
                  {
                    v26 = 20 * v33;
                    *(_DWORD *)(v26 + *(_DWORD *)(a1 + 48) + 8) = *(_DWORD *)(a1 + 28)
                                                                + *(_DWORD *)(*(_DWORD *)(a1 + 32) + v7 + 4);
                    *(_DWORD *)(v26 + *(_DWORD *)(a1 + 48) + 12) = v37 & *(_DWORD *)(*(_DWORD *)(a1 + 32) + v7 + 24);
                    *(_WORD *)(v26 + *(_DWORD *)(a1 + 48) + 4) = v22;
                    *(_WORD *)(v26 + *(_DWORD *)(a1 + 48) + 6) = *(_WORD *)(v5 + *(_DWORD *)(a1 + 64) + 4);
                    *(_BYTE *)(v26 + *(_DWORD *)(a1 + 48)) = 0;
                    ++v33;
                    *(_BYTE *)(v26 + *(_DWORD *)(a1 + 48) + 1) = *(_BYTE *)(v5 + *(_DWORD *)(a1 + 64) + 1);
                    *(_BYTE *)(v26 + *(_DWORD *)(a1 + 48) + 2) = *(_BYTE *)(v5 + *(_DWORD *)(a1 + 64) + 2);
                    v27 = *(_DWORD *)(a1 + 32);
                    v34 += *(_WORD *)(v27 + v7) + 8;
                    if ( (*(_DWORD *)(v27 + v7 + 32) >> 2) & 1 )
                    {
                      v28 = *(_DWORD *)(a1 + 32);
                      v29 = *(_DWORD *)(v7 + v28 + 24);
                      v30 = v28 + v7;
                      if ( v29 & *(_DWORD *)(a1 + 72) )
                      {
                        v31 = *(void (__cdecl **)(int, int))(v30 + 36);
                        if ( v31 )
                        {
                          if ( !(*(_BYTE *)(v5 + *(_DWORD *)(a1 + 64) + 6) & 1) )
                            v31(v22, a1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          v13 = *(_DWORD *)(a1 + 64);
          v14 = *(_DWORD *)(v13 + v5 + 16);
          v15 = v5 + v13;
          if ( (!v14 || v32 > *(_DWORD *)(a1 + 36) + v14 + *(_DWORD *)(v12 + 16)) && *(_BYTE *)(v15 + 1) == 1 )
          {
            *(_BYTE *)(v5 + *(_DWORD *)(a1 + 64) + 1) = 0;
            *(_BYTE *)(v5 + *(_DWORD *)(a1 + 64) + 3) = 0;
          }
        }
      }
      ++v35;
    }
    while ( v35 < *(_DWORD *)(a1 + 12) );
    result = v33;
    if ( v33 > 0 && v34 <= *(_DWORD *)(a1 + 20) )
      result = sub_10012520(a1, v33);
  }
  return result;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);

//----- (10013610) --------------------------------------------------------
char __cdecl sub_10013610(int a1, char a2, int a3, const void *a4, int a5)
{
  signed __int16 v5; // ax@1
  int v6; // ebx@2
  int v7; // ebp@2
  int v8; // edi@2
  int v9; // ecx@2
  int v10; // ST2C_4@4
  const char *v11; // eax@4
  int v12; // eax@5
  int v13; // edx@5
  int v14; // ecx@7
  int v15; // edx@7
  int v16; // ecx@7
  int v17; // eax@15
  unsigned int v18; // ecx@15
  int v19; // eax@15
  int v20; // edx@16
  int (__cdecl *v21)(int, int); // ebp@18
  int v22; // ST2C_4@23
  int v23; // ST28_4@23
  int v24; // ST24_4@23
  const char *v25; // eax@23
  unsigned int v26; // eax@4
  unsigned int v28; // [sp+10h] [bp-70h]@5
  char v29; // [sp+18h] [bp-68h]@4

  v5 = sub_10012500(a1, a3);
  if ( v5 == -1
    || (v6 = (unsigned __int16)v5,
        v7 = 52 * (unsigned __int16)v5,
        v8 = 24 * (unsigned __int16)v5,
        v9 = v7 + *(_DWORD *)(a3 + 32),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4) != *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a3 + 4) || v5 == -1 )
    {
      _snprintf(&v29, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v5, *(_BYTE *)(a3 + 1));
      LOBYTE(v26) = sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2645, 0, &v29);
    }
    else
    {
      v22 = *(_BYTE *)(a3 + 1);
      v23 = *(_WORD *)(52 * (unsigned __int16)v5 + *(_DWORD *)(a3 + 32));
      v24 = *(_WORD *)(*(_DWORD *)(a3 + 64) + 24 * (unsigned __int16)v5 + 4);
      v25 = sub_10015B20(a3, v5);
      _snprintf(&v29, 0x64u, "%d-%s stssz=%d infsz=%d pipe=%d", (unsigned __int16)a1, v25, v24, v23, v22);
      LOBYTE(v26) = sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2660, 0, &v29);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) )
  {
    v10 = *(_BYTE *)(a3 + 1);
    v11 = sub_10015B20(a3, v5);
    _snprintf(&v29, 0x64u, "%d-%s is var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v26) = sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2511, 0, &v29);
  }
  else
  {
    v12 = sub_10060900();
    v13 = *(_DWORD *)(a3 + 32);
    v28 = v12;
    if ( !*(_DWORD *)(v13 + v7 + 12)
      || (v26 = *(_DWORD *)(v13 + v7 + 16), v28 <= a5 + v26 + *(_DWORD *)(a3 + 36))
      && ((v14 = *(_DWORD *)(a3 + 64), v15 = *(_DWORD *)(v14 + v8 + 16), v16 = v8 + v14, !v15)
       || v28 > *(_DWORD *)(a3 + 36) + v15 + (v26 >> 1)
       || a2
       && (*(_BYTE *)(v16 + 1) != 1
        || *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2))
       || *(_BYTE *)(v16 + 1) != 1
       && *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + *(_DWORD *)(a3 + 56)) <= *(_BYTE *)(v16 + 2)
       || (v26 = *(_DWORD *)(a3 + 56),
           *(_BYTE *)(*(_BYTE *)(a3 + 3) + v6 * *(_BYTE *)(a3 + 2) + v26) == *(_BYTE *)(v16 + 2))) )
    {
      sub_10060A60(*(_DWORD *)(a3 + 60), -1);
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 1) = a2;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 16) = a5;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 2) = *(_BYTE *)(*(_BYTE *)(a3 + 3)
                                                           + v6 * *(_BYTE *)(a3 + 2)
                                                           + *(_DWORD *)(a3 + 56));
      *(_BYTE *)(v8 + *(_DWORD *)(a3 + 64)) = 0;
      *(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 3) = 1;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v8 + 20) = *(_DWORD *)(a3 + 72);
      v17 = *(_DWORD *)(a3 + 32);
      v18 = *(_DWORD *)(v17 + v7 + 32);
      v19 = v7 + v17;
      if ( (v18 >> 1) & 1 )
      {
        v20 = *(_DWORD *)(a3 + 64);
        if ( v28 < *(_DWORD *)(v20 + v8 + 8) )
          *(_DWORD *)(v20 + v8 + 8) -= *(_DWORD *)(v19 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v7 + 4)),
        a4,
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v8 + 4));
      LOBYTE(v26) = sub_10060A00(*(_DWORD *)(a3 + 60));
      v21 = *(int (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v7 + 48);
      if ( v21 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v8 + 6) & 8) )
        LOBYTE(v26) = v21(a1, a3);
    }
  }
  return v26;
}

//----- (10013920) --------------------------------------------------------
char __cdecl sub_10013920(int a1, unsigned __int16 a2, char a3, int a4, const void *a5, int a6)
{
  signed __int16 v6; // ax@1
  int v7; // ebp@2
  int v8; // ebx@2
  int v9; // ecx@2
  int v10; // ST28_4@4
  const char *v11; // eax@4
  unsigned int v12; // edx@5
  int v13; // ecx@5
  unsigned int v14; // ecx@6
  int v15; // edx@7
  int v16; // edi@7
  int v17; // edi@14
  int v18; // eax@14
  int v19; // ecx@15
  int (__cdecl *v20)(int, int); // ebx@17
  int v21; // ST28_4@22
  const char *v22; // eax@22
  int v23; // eax@4
  unsigned int v25; // [sp+10h] [bp-70h]@5
  char v26; // [sp+18h] [bp-68h]@4

  v6 = sub_10012500(a1, a4);
  if ( v6 == -1
    || (v7 = (unsigned __int16)v6, v8 = 52 * (unsigned __int16)v6, v9 = v8 + *(_DWORD *)(a4 + 32), a2 > *(_WORD *)v9) )
  {
    if ( (signed int)(unsigned __int16)a1 >= *(_DWORD *)(a4 + 4) || v6 == -1 )
    {
      _snprintf(&v26, 0x64u, "pkt:%d lut_id:%d pipe:%d", (unsigned __int16)a1, (unsigned __int16)v6, *(_BYTE *)(a4 + 1));
      LOBYTE(v23) = sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2939, 0, &v26);
    }
    else
    {
      v21 = *(_BYTE *)(a4 + 1);
      v22 = sub_10015B20(a4, v6);
      _snprintf(&v26, 0x64u, "%d-%s >max sz sz=%d pipe=%d", (unsigned __int16)a1, v22, a2, v21);
      LOBYTE(v23) = sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2953, 0, &v26);
    }
  }
  else if ( *(_BYTE *)(v9 + 8) == 1 )
  {
    v12 = sub_10060900();
    v13 = *(_DWORD *)(a4 + 32) + v8;
    v25 = v12;
    if ( !*(_DWORD *)(v13 + 12)
      || (v14 = *(_DWORD *)(v13 + 16), v23 = *(_DWORD *)(a4 + 36), v12 <= a6 + v23 + v14)
      && ((v15 = *(_DWORD *)(a4 + 64) + 24 * v7, (v16 = *(_DWORD *)(v15 + 16)) == 0)
       || v25 > v23 + v16 + (v14 >> 1)
       || a3
       && (*(_BYTE *)(v15 + 1) != 1
        || (LOBYTE(v23) = *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + *(_DWORD *)(a4 + 56)),
            (unsigned __int8)v23 <= *(_BYTE *)(v15 + 2)))
       || *(_BYTE *)(v15 + 1) != 1
       && (v23 = *(_DWORD *)(a4 + 56),
           *(_BYTE *)(*(_BYTE *)(a4 + 3) + v7 * *(_BYTE *)(a4 + 2) + v23) <= *(_BYTE *)(v15 + 2))) )
    {
      sub_10060A60(*(_DWORD *)(a4 + 60), -1);
      v17 = 24 * v7;
      *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4) = a2;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 1) = a3;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 16) = a6;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 2) = *(_BYTE *)(*(_BYTE *)(a4 + 3)
                                                            + v7 * *(_BYTE *)(a4 + 2)
                                                            + *(_DWORD *)(a4 + 56));
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64)) = 0;
      *(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 3) = 1;
      *(_DWORD *)(v17 + *(_DWORD *)(a4 + 64) + 20) = *(_DWORD *)(a4 + 72);
      v18 = *(_DWORD *)(a4 + 32) + v8;
      if ( (*(_DWORD *)(v18 + 32) >> 1) & 1 )
      {
        v19 = *(_DWORD *)(a4 + 64);
        if ( v25 < *(_DWORD *)(v17 + v19 + 8) )
          *(_DWORD *)(v17 + v19 + 8) -= *(_DWORD *)(v18 + 12);
      }
      memcpy(
        (void *)(*(_DWORD *)(a4 + 28) + *(_DWORD *)(*(_DWORD *)(a4 + 32) + v8 + 4)),
        a5,
        *(_WORD *)(v17 + *(_DWORD *)(a4 + 64) + 4));
      sub_10060A00(*(_DWORD *)(a4 + 60));
      v23 = *(_DWORD *)(a4 + 32);
      v20 = *(int (__cdecl **)(int, int))(v23 + v8 + 48);
      if ( v20 && !(*(_BYTE *)(v17 + *(_DWORD *)(a4 + 64) + 6) & 8) )
        LOBYTE(v23) = v20(a1, a4);
    }
  }
  else
  {
    v10 = *(_BYTE *)(a4 + 1);
    v11 = sub_10015B20(a4, v6);
    _snprintf(&v26, 0x64u, "%d-%s !var pipe=%d", (unsigned __int16)a1, v11, v10);
    LOBYTE(v23) = sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 2802, 0, &v26);
  }
  return v23;
}

//----- (10013C10) --------------------------------------------------------
char __cdecl sub_10013C10(int a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  char result; // al@2
  int v5; // ecx@3
  int v6; // ebp@3
  int v7; // eax@3
  int v8; // edi@3
  int v9; // ebx@3
  int v10; // ST24_4@5
  const char *v11; // eax@5
  int v12; // eax@7
  int v13; // ebp@10
  void (__cdecl *v14)(int, int); // eax@10
  char v15; // cl@13
  int v16; // edx@13
  __int16 v17; // ax@13
  bool v18; // cf@13
  bool v19; // zf@13
  int v20; // ebx@17
  int v21; // eax@19
  char v22; // dl@19
  __int16 v23; // cx@19
  unsigned int v24; // eax@20
  int v25; // ecx@20
  int v26; // edi@21
  char v27; // [sp+6h] [bp-7Eh]@3
  char v28; // [sp+7h] [bp-7Dh]@17
  int v29; // [sp+8h] [bp-7Ch]@13
  int v30; // [sp+Ch] [bp-78h]@13
  char v31; // [sp+10h] [bp-74h]@13
  char v32; // [sp+11h] [bp-73h]@15
  __int16 v33; // [sp+12h] [bp-72h]@13
  int v34; // [sp+14h] [bp-70h]@1
  int v35; // [sp+18h] [bp-6Ch]@19
  char v36; // [sp+1Ch] [bp-68h]@5

  v3 = sub_10012500(a1, a3);
  v34 = (unsigned __int16)v3;
  if ( v3 == -1 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(a3 + 72);
    v6 = (unsigned __int16)v3;
    v7 = *(_DWORD *)(a3 + 32);
    v8 = 52 * v6;
    v9 = a2 & ~v5 & (*(_DWORD *)(v7 + 52 * v6 + 24) | 0xC00000);
    v27 = 1;
    if ( !*(_DWORD *)(52 * v6 + v7 + 12) || (*(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 32) >> 6) & 1 )
    {
      if ( *(_BYTE *)(*(_DWORD *)(a3 + 24) + v6) != 1 )
        goto LABEL_26;
      v12 = v8 + *(_DWORD *)(a3 + 32);
      if ( !(v5 & *(_DWORD *)(v12 + 20)) || !(*(_BYTE *)(v12 + 28) & *(_BYTE *)a3) || !v9 )
        goto LABEL_26;
      v13 = 24 * v6;
      *(_DWORD *)(*(_DWORD *)(a3 + 64) + v13 + 12) = sub_10060900();
      v14 = *(void (__cdecl **)(int, int))(*(_DWORD *)(a3 + 32) + v8 + 44);
      if ( v14 && !(*(_BYTE *)(*(_DWORD *)(a3 + 64) + v13 + 6) & 4) )
        v14(a1, a3);
      v15 = *(_BYTE *)(a3 + 1);
      v16 = *(_DWORD *)(a3 + 64);
      v30 = *(_DWORD *)(a3 + 16);
      v31 = v15;
      v29 = v9;
      v17 = *(_WORD *)(v16 + v13 + 4) + 20;
      v18 = (unsigned int)(unsigned __int16)v17 < *(_DWORD *)(a3 + 20);
      v19 = (unsigned __int16)v17 == *(_DWORD *)(a3 + 20);
      v33 = *(_WORD *)(v16 + v13 + 4) + 20;
      if ( !v18 && !v19 )
      {
        sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3198, 1, 0);
        v17 = v33;
      }
      v19 = *(_BYTE *)(a3 + 1) == 6;
      v32 = *(_BYTE *)(*(_DWORD *)(a3 + 32) + v8 + 32) & 1;
      if ( v19 || !(a2 & *(_DWORD *)(a3 + 84)) )
      {
        v28 = 1;
        v20 = *(_DWORD *)(a3 + 16) + 12;
      }
      else
      {
        v20 = *(_DWORD *)(a3 + 16);
        v28 = 0;
        v33 = v17 - 12;
      }
      sub_10060A60(*(_DWORD *)(a3 + 60), -1);
      v21 = *(_DWORD *)(a3 + 64) + v13;
      v22 = *(_BYTE *)(v21 + 1);
      LOWORD(v34) = a1;
      v23 = *(_WORD *)(v21 + 4);
      BYTE1(v35) = *(_BYTE *)(v21 + 2);
      HIWORD(v34) = v23;
      *(_DWORD *)v20 = v34;
      LOBYTE(v35) = v22;
      *(_DWORD *)(v20 + 4) = v35;
      memcpy(
        (void *)(v20 + 8),
        (const void *)(*(_DWORD *)(a3 + 28) + *(_DWORD *)(*(_DWORD *)(a3 + 32) + v8 + 4)),
        *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4));
      if ( v28 )
      {
        v24 = sub_10068380(
                (unsigned int *)(*(_DWORD *)(a3 + 16) + 12),
                *(_WORD *)(*(_DWORD *)(a3 + 64) + v13 + 4) + 8,
                0xFFFFFFFF);
        v25 = *(_DWORD *)(a3 + 16);
        v34 = 327678;
        LOWORD(v35) = 1;
        *(_DWORD *)v25 = 327678;
        *(_DWORD *)(v25 + 4) = v35;
        *(_DWORD *)(v25 + 8) = v24;
      }
      v26 = j_HWM_pvg_hsdb_put(&v29);
      sub_10060A00(*(_DWORD *)(a3 + 60));
      if ( v26 < 0 )
LABEL_26:
        v27 = 0;
      result = v27;
    }
    else
    {
      v10 = *(_BYTE *)(a3 + 1);
      v11 = sub_10015B20(a3, v34);
      _snprintf(&v36, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v11, v10);
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3123, 0, &v36);
      result = 0;
    }
  }
  return result;
}
// 10061640: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (10013ED0) --------------------------------------------------------
char __cdecl sub_10013ED0(int a1, int a2, void *a3, char a4, int a5)
{
  signed __int16 v5; // ax@1
  char result; // al@2
  int v7; // ebp@3
  int v8; // ebx@3
  int v9; // eax@3
  int v10; // ecx@3
  int v11; // edi@3
  int v12; // ST24_4@4
  const char *v13; // eax@4
  int v14; // eax@6
  int v15; // ebp@9
  char v16; // cl@9
  int v17; // edx@9
  __int16 v18; // ax@9
  bool v19; // cf@9
  bool v20; // zf@9
  int v21; // edi@13
  char v22; // bl@13
  int v23; // eax@15
  __int16 v24; // cx@15
  int v25; // ecx@15
  void *v26; // edx@15
  unsigned int v27; // eax@16
  int v28; // ecx@16
  int v29; // edi@17
  char v30; // [sp+7h] [bp-81h]@3
  int v31; // [sp+8h] [bp-80h]@9
  int v32; // [sp+Ch] [bp-7Ch]@9
  char v33; // [sp+10h] [bp-78h]@9
  char v34; // [sp+11h] [bp-77h]@11
  __int16 v35; // [sp+12h] [bp-76h]@9
  void *v36; // [sp+14h] [bp-74h]@1
  int v37; // [sp+18h] [bp-70h]@1
  int v38; // [sp+1Ch] [bp-6Ch]@15
  char v39; // [sp+20h] [bp-68h]@4

  v36 = a3;
  v5 = sub_10012500(a1, a5);
  v37 = (unsigned __int16)v5;
  if ( v5 == -1 )
  {
    result = 0;
  }
  else
  {
    v7 = (unsigned __int16)v5;
    v8 = 52 * (unsigned __int16)v5;
    v9 = *(_DWORD *)(a5 + 32) + v8;
    v10 = *(_DWORD *)(a5 + 72);
    v11 = a2 & ~v10 & (*(_DWORD *)(v9 + 24) | 0xC00000);
    v30 = 0;
    if ( *(_DWORD *)(v9 + 12) )
    {
      v12 = *(_BYTE *)(a5 + 1);
      v13 = sub_10015B20(a5, v37);
      _snprintf(&v39, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v13, v12);
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3486, 0, &v39);
      result = 0;
    }
    else
    {
      if ( *(_BYTE *)(*(_DWORD *)(a5 + 24) + v7) == 1
        && (v14 = v8 + *(_DWORD *)(a5 + 32), v10 & *(_DWORD *)(v14 + 20))
        && *(_BYTE *)(v14 + 28) & *(_BYTE *)a5
        && v11 )
      {
        v15 = 24 * v7;
        *(_DWORD *)(*(_DWORD *)(a5 + 64) + v15 + 12) = sub_10060900();
        v16 = *(_BYTE *)(a5 + 1);
        v17 = *(_DWORD *)(a5 + 64);
        v32 = *(_DWORD *)(a5 + 16);
        v33 = v16;
        v31 = v11;
        v18 = *(_WORD *)(v17 + v15 + 4) + 20;
        v19 = (unsigned int)(unsigned __int16)v18 < *(_DWORD *)(a5 + 20);
        v20 = (unsigned __int16)v18 == *(_DWORD *)(a5 + 20);
        v35 = *(_WORD *)(v17 + v15 + 4) + 20;
        if ( !v19 && !v20 )
        {
          sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3535, 1, 0);
          v18 = v35;
        }
        v20 = *(_BYTE *)(a5 + 1) == 6;
        v34 = *(_BYTE *)(*(_DWORD *)(a5 + 32) + v8 + 32) & 1;
        if ( v20 || !(a2 & *(_DWORD *)(a5 + 84)) )
        {
          v22 = 1;
          v21 = *(_DWORD *)(a5 + 16) + 12;
        }
        else
        {
          v21 = *(_DWORD *)(a5 + 16);
          v22 = 0;
          v35 = v18 - 12;
        }
        sub_10060A60(*(_DWORD *)(a5 + 60), -1);
        v23 = *(_DWORD *)(a5 + 64) + v15;
        LOWORD(v37) = a1;
        v24 = *(_WORD *)(v23 + 4);
        LOBYTE(v23) = *(_BYTE *)(v23 + 2);
        HIWORD(v37) = v24;
        v25 = v37;
        LOBYTE(v38) = a4;
        BYTE1(v38) = v23;
        *(_DWORD *)(v21 + 4) = v38;
        v26 = v36;
        *(_DWORD *)v21 = v25;
        memcpy((void *)(v21 + 8), v26, *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4));
        if ( v22 )
        {
          v27 = sub_10068380(
                  (unsigned int *)(*(_DWORD *)(a5 + 16) + 12),
                  *(_WORD *)(*(_DWORD *)(a5 + 64) + v15 + 4) + 8,
                  0xFFFFFFFF);
          v28 = *(_DWORD *)(a5 + 16);
          v37 = 327678;
          LOWORD(v38) = 1;
          *(_DWORD *)v28 = 327678;
          *(_DWORD *)(v28 + 4) = v38;
          *(_DWORD *)(v28 + 8) = v27;
        }
        v29 = j_HWM_pvg_hsdb_put(&v31);
        sub_10060A00(*(_DWORD *)(a5 + 60));
        if ( v29 >= 0 )
          v30 = 1;
      }
      else
      {
        v30 = 0;
      }
      result = v30;
    }
  }
  return result;
}
// 10061640: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (10014160) --------------------------------------------------------
char __cdecl sub_10014160(int a1, unsigned __int16 a2, int a3, void *a4, char a5, int a6)
{
  signed __int16 v6; // ax@1
  char result; // al@2
  int v8; // ebx@3
  int v9; // ebp@3
  int v10; // eax@3
  int v11; // ecx@3
  int v12; // edi@3
  int v13; // ST24_4@4
  const char *v14; // eax@4
  int v15; // eax@6
  int v16; // ebx@9
  char v17; // cl@9
  unsigned int v18; // edx@9
  bool v19; // cf@9
  bool v20; // zf@9
  int v21; // edi@13
  int v22; // ecx@15
  char v23; // dl@15
  void *v24; // eax@15
  int v25; // edx@15
  unsigned int v26; // eax@16
  int v27; // ecx@16
  int v28; // edi@17
  char v29; // [sp+6h] [bp-82h]@3
  char v30; // [sp+7h] [bp-81h]@13
  int v31; // [sp+8h] [bp-80h]@9
  int v32; // [sp+Ch] [bp-7Ch]@9
  char v33; // [sp+10h] [bp-78h]@9
  char v34; // [sp+11h] [bp-77h]@11
  __int16 v35; // [sp+12h] [bp-76h]@9
  void *v36; // [sp+14h] [bp-74h]@1
  int v37; // [sp+18h] [bp-70h]@1
  int v38; // [sp+1Ch] [bp-6Ch]@15
  char v39; // [sp+20h] [bp-68h]@4

  v36 = a4;
  v6 = sub_10012500(a1, a6);
  v37 = (unsigned __int16)v6;
  if ( v6 == -1 )
  {
    result = 0;
  }
  else
  {
    v8 = (unsigned __int16)v6;
    v9 = 52 * (unsigned __int16)v6;
    v10 = *(_DWORD *)(a6 + 32) + v9;
    v11 = *(_DWORD *)(a6 + 72);
    v12 = a3 & ~v11 & (*(_DWORD *)(v10 + 24) | 0xC00000);
    v29 = 0;
    if ( *(_DWORD *)(v10 + 12) )
    {
      v13 = *(_BYTE *)(a6 + 1);
      v14 = sub_10015B20(a6, v37);
      _snprintf(&v39, 0x64u, "%d-%s is prdc pipe=%d", (unsigned __int16)a1, v14, v13);
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3771, 0, &v39);
      result = 0;
    }
    else
    {
      if ( *(_BYTE *)(v8 + *(_DWORD *)(a6 + 24)) == 1
        && (v15 = v9 + *(_DWORD *)(a6 + 32), v11 & *(_DWORD *)(v15 + 20))
        && *(_BYTE *)(v15 + 28) & *(_BYTE *)a6
        && v12 )
      {
        v16 = 24 * v8;
        *(_DWORD *)(*(_DWORD *)(a6 + 64) + v16 + 12) = sub_10060900();
        v17 = *(_BYTE *)(a6 + 1);
        v32 = *(_DWORD *)(a6 + 16);
        v18 = (unsigned __int16)(a2 + 20);
        v19 = v18 < *(_DWORD *)(a6 + 20);
        v20 = v18 == *(_DWORD *)(a6 + 20);
        v31 = v12;
        v33 = v17;
        v35 = a2 + 20;
        if ( !v19 && !v20 )
          sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3832, 1, 0);
        v20 = *(_BYTE *)(a6 + 1) == 6;
        v34 = *(_BYTE *)(*(_DWORD *)(a6 + 32) + v9 + 32) & 1;
        if ( v20 || !(a3 & *(_DWORD *)(a6 + 84)) )
        {
          v30 = 1;
          v21 = *(_DWORD *)(a6 + 16) + 12;
        }
        else
        {
          v21 = *(_DWORD *)(a6 + 16);
          v35 -= 12;
          v30 = 0;
        }
        sub_10060A60(*(_DWORD *)(a6 + 60), -1);
        LOWORD(v37) = a1;
        v22 = *(_DWORD *)(a6 + 64);
        LOBYTE(v38) = a5;
        v23 = *(_BYTE *)(v22 + v16 + 2);
        HIWORD(v37) = a2;
        v24 = v36;
        BYTE1(v38) = v23;
        v25 = v38;
        *(_DWORD *)v21 = v37;
        *(_DWORD *)(v21 + 4) = v25;
        memcpy((void *)(v21 + 8), v24, a2);
        if ( v30 )
        {
          v26 = sub_10068380((unsigned int *)(*(_DWORD *)(a6 + 16) + 12), a2 + 8, 0xFFFFFFFF);
          v27 = *(_DWORD *)(a6 + 16);
          v37 = 327678;
          LOWORD(v38) = 1;
          *(_DWORD *)v27 = 327678;
          *(_DWORD *)(v27 + 4) = v38;
          *(_DWORD *)(v27 + 8) = v26;
        }
        v28 = j_HWM_pvg_hsdb_put(&v31);
        sub_10060A00(*(_DWORD *)(a6 + 60));
        if ( v28 >= 0 )
          v29 = 1;
      }
      else
      {
        v29 = 0;
      }
      result = v29;
    }
  }
  return result;
}
// 10061640: using guessed type int __cdecl j_HWM_pvg_hsdb_put(_DWORD);

//----- (100143F0) --------------------------------------------------------
int __cdecl sub_100143F0(int a1)
{
  int result; // eax@1
  int v2; // edi@2
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // edx@3
  void (__cdecl *v7)(int, int); // eax@5
  int i; // [sp+4h] [bp-8h]@1
  unsigned int v9; // [sp+8h] [bp-4h]@1

  v9 = sub_10060900();
  result = 0;
  for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
  {
    v2 = *(_WORD *)(*(_DWORD *)(a1 + 68) + 2 * result);
    v3 = (unsigned __int16)sub_10012500(v2, a1);
    v4 = 24 * (unsigned __int16)v3;
    v5 = v4 + *(_DWORD *)(a1 + 64);
    if ( !*(_BYTE *)v5 )
    {
      v6 = *(_DWORD *)(v5 + 16);
      if ( !v6 || v9 > v6 + *(_DWORD *)(a1 + 36) + *(_DWORD *)(52 * v3 + *(_DWORD *)(a1 + 32) + 16) )
      {
        *(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 1) = 0;
        *(_BYTE *)(v4 + *(_DWORD *)(a1 + 64)) = 1;
        v7 = *(void (__cdecl **)(int, int))(52 * v3 + *(_DWORD *)(a1 + 32) + 40);
        if ( v7 )
        {
          if ( !(*(_BYTE *)(*(_DWORD *)(a1 + 64) + v4 + 6) & 2) )
            v7(v2, a1);
        }
      }
    }
    result = i + 1;
  }
  return result;
}

//----- (100144B0) --------------------------------------------------------
char __cdecl sub_100144B0(int a1, int a2, void *a3)
{
  return sub_100128D0(a1, a2, a3, 0xFFFFu);
}

//----- (100144D0) --------------------------------------------------------
char __cdecl sub_100144D0(int a1, int a2, void *a3, unsigned __int16 *a4)
{
  return sub_10012B10(a1, a2, a3, a4, 0xFFFFu);
}

//----- (10014500) --------------------------------------------------------
int __cdecl sub_10014500(int a1)
{
  int v1; // esi@1
  int v2; // ecx@3
  signed __int16 v3; // ax@5
  int v4; // ebp@6
  int v5; // edi@6
  int v6; // ecx@6
  unsigned int v7; // edi@6
  int v8; // ST10_4@10
  int v10; // [sp+8h] [bp-8h]@1
  unsigned int v11; // [sp+Ch] [bp-4h]@4
  int v12; // [sp+14h] [bp+4h]@3

  v1 = a1;
  v10 = sub_10060900();
  if ( *(_BYTE *)(a1 + 3) >= 4u )
    sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 1321, 1, 0);
  sub_10060A60(*(_DWORD *)(a1 + 60), -1);
  v2 = 0;
  v12 = 0;
  if ( *(_DWORD *)(v1 + 4) > 0 )
  {
    v11 = 0;
    do
    {
      v3 = sub_10012500(v2, v1);
      if ( v3 != -1 )
      {
        v4 = (unsigned __int16)v3;
        v5 = 52 * (unsigned __int16)v3;
        memset(
          (void *)(*(_DWORD *)(v1 + 28) + *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 4)),
          0,
          *(_WORD *)(*(_DWORD *)(v1 + 32) + v5));
        v6 = 24 * v4;
        *(_BYTE *)(v6 + *(_DWORD *)(v1 + 64)) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 1) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 2) = -1;
        *(_WORD *)(*(_DWORD *)(v1 + 64) + v6 + 4) = *(_WORD *)(v5 + *(_DWORD *)(v1 + 32));
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 16) = 0;
        *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 12) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 3) = 0;
        *(_BYTE *)(*(_DWORD *)(v1 + 64) + v6 + 6) = 0;
        v7 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + v5 + 12);
        if ( v7 )
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10 + 25 * (v11 % (v7 / 0x19));
        else
          *(_DWORD *)(*(_DWORD *)(v1 + 64) + v6 + 8) = v10;
      }
      v2 = v12++ + 1;
      v11 = (unsigned __int16)v12;
    }
    while ( (signed int)(unsigned __int16)v12 < *(_DWORD *)(v1 + 4) );
  }
  v8 = *(_DWORD *)(v1 + 60);
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
  sub_10060A00(v8);
  sub_10012D20(v1);
  return sub_10012DD0(v1);
}

//----- (10014650) --------------------------------------------------------
char __cdecl sub_10014650(int a1, int a2)
{
  signed __int16 v2; // ax@1
  int v3; // edx@1
  int v4; // esi@2
  int v5; // edi@2
  int v6; // eax@2
  int v7; // edx@2

  v2 = sub_10012500(a1, a2);
  if ( v2 == -1 )
  {
    LOBYTE(v6) = sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb.c", 3035, 0, 0);
  }
  else
  {
    v4 = *(_DWORD *)(v3 + 28) + *(_DWORD *)(52 * (unsigned __int16)v2 + *(_DWORD *)(v3 + 32) + 4);
    v5 = *(_WORD *)v4;
    LOWORD(v6) = sub_10012500(v5, v3);
    if ( (_WORD)v6 != -1 )
    {
      v6 = 3 * (unsigned __int16)v6;
      if ( *(_BYTE *)(*(_DWORD *)(v7 + 64) + 8 * v6 + 1) == 1 )
        LOBYTE(v6) = sub_10013C10(v5, *(_DWORD *)(v4 + 4), v7);
    }
  }
  return v6;
}

//----- (100146D0) --------------------------------------------------------
char sub_100146D0()
{
  return sub_10016230(0);
}

//----- (100146E0) --------------------------------------------------------
int __cdecl sub_100146E0(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10A08AD4 |= a1;
  return result;
}
// 10A08AD4: using guessed type int dword_10A08AD4;

//----- (100146F0) --------------------------------------------------------
int __cdecl sub_100146F0(int a1, int a2, unsigned __int16 a3, char a4, char a5)
{
  unsigned __int16 v5; // di@1
  _WORD *v6; // edx@2
  int v7; // esi@2
  unsigned __int16 v8; // ax@3
  int v9; // eax@4

  v5 = 0;
  if ( a3 )
  {
    v6 = dword_107FD440;
    v7 = a1;
    do
    {
      v8 = *(_WORD *)(a2 + 2 * v5);
      if ( v8 >= 0x388u )
        break;
      LOWORD(v9) = v6[v8 + 178008];
      if ( (unsigned __int16)v9 < 0x23Du )
      {
        v9 = (unsigned __int16)v9;
        if ( (a1 & (*(_DWORD *)&v6[26 * (unsigned __int16)v9 + 163122] | *(_DWORD *)&v6[26 * (unsigned __int16)v9
                                                                                      + 163120])) == a1
          || v7 & 0xC00000 )
        {
          sub_10036C60(a4, (_BYTE *)v6 + v9, &byte_107FD448[v9], a5);
          v6 = dword_107FD440;
        }
      }
      ++v5;
    }
    while ( v5 < a3 );
  }
  sub_10012D20((int)&byte_10A08A80);
  return sub_10012DD0((int)&byte_10A08A80);
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (100147A0) --------------------------------------------------------
int __cdecl sub_100147A0(int a1)
{
  int result; // eax@1

  result = ~a1;
  dword_10A08AD4 &= ~a1;
  return result;
}
// 10A08AD4: using guessed type int dword_10A08AD4;

//----- (100147B0) --------------------------------------------------------
char __cdecl sub_100147B0(int a1, int a2)
{
  int v2; // eax@1
  int v3; // esi@2
  int v4; // ebp@2
  unsigned __int16 v5; // di@2
  unsigned __int16 v6; // cx@3
  int v7; // edi@8
  unsigned __int16 v8; // di@9
  int v9; // eax@10
  int v11; // [sp+4h] [bp-530h]@2
  __int16 v12; // [sp+8h] [bp-52Ch]@9
  int v13; // [sp+Ch] [bp-528h]@10
  int v14; // [sp+10h] [bp-524h]@12

  LOWORD(v2) = sub_100128C0(a2, a1);
  if ( (_WORD)v2 != -1 )
  {
    v3 = *(_DWORD *)(a2 + 28) + *(_DWORD *)(52 * (unsigned __int16)v2 + *(_DWORD *)(a2 + 32) + 4);
    v4 = 24 * (unsigned __int16)v2;
    v5 = *(_WORD *)(*(_DWORD *)(a2 + 64) + v4 + 4);
    v2 = sub_10061C90(*(_BYTE *)v3);
    v11 = v2;
    if ( v5 > 4u )
    {
      v6 = *(_WORD *)(v3 + 2);
      if ( v6 <= 0x1F4u && 2 * (unsigned int)v6 <= (unsigned int)v5 - 4 && v2 != -1 )
      {
        if ( *(_BYTE *)v3 == 2 )
        {
          LOBYTE(v2) = sub_100146F0(*(_DWORD *)(*(_DWORD *)(a2 + 64) + v4 + 20), v3 + 4, v6, 1, 1);
        }
        else
        {
          v7 = sub_1002CC90((_DWORD *)(a2 + 1), 1u, (int)&unk_10098C64, 1, 4, -1);
          v2 = sub_1002CC90((_DWORD *)v3, 1u, (int)&unk_10098C64, 1, 4, 4);
          if ( v2 >= v7 )
          {
            LOBYTE(v2) = sub_10028BC0("..\\lib\\adl\\iop_hsdb_pkt.c", 787, 0, 0);
          }
          else
          {
            v8 = 0;
            v12 = -32705;
            if ( *(_WORD *)(v3 + 2) )
            {
              do
              {
                v13 = *(_DWORD *)(*(_DWORD *)(a2 + 64) + v4 + 20);
                v9 = *(_WORD *)(v3 + 2) - v8;
                if ( v9 >= 100 )
                  LOWORD(v9) = 100;
                LOWORD(v14) = v9;
                memcpy((char *)&v14 + 2, (const void *)(v3 + 2 * v8 + 4), 2 * (unsigned __int16)v9);
                LOBYTE(v2) = sub_10060AC0(v11, (int)&v12, 50000, 0);
                v8 += v14;
              }
              while ( v8 < *(_WORD *)(v3 + 2) );
            }
          }
        }
      }
    }
  }
  return v2;
}

//----- (10014950) --------------------------------------------------------
char sub_10014950()
{
  memset(byte_107FD448, 0, 0x388u);
  memset(dword_107FD440, 0, 0x23Du);
  sub_10036E40(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  sub_10038020(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  sub_100374F0(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  sub_10037E10(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  sub_100373C0(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  sub_10037420(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  sub_10038240(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  sub_100382A0(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  sub_10037CA0(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  sub_10037470(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
  return sub_10037D80(2, 0x388u, (int)dword_107FD440, (int)byte_107FD448, (int)dword_107FD440 + 356016);
}

//----- (10014AD0) --------------------------------------------------------
signed int sub_10014AD0()
{
  void *v0; // ecx@4
  char *v1; // ecx@6
  unsigned int v2; // eax@6
  int v3; // edx@9
  int v4; // edx@11
  signed int result; // eax@15
  int v6; // edi@16
  void **v7; // esi@16
  size_t v8; // eax@17

  if ( sub_10061B70((LONG)&off_10099C6C) )
  {
    memcpy((char *)dword_107FD440 + 326220, &unk_10091800, 0x7464u);
    qmemcpy((char *)dword_107FD440 + 356016, &unk_10098C68, 0x710u);
  }
  else
  {
    sub_10028BC0("..\\lib\\adl\\iop_hsdb_pkt.c", 1037, 1, 0);
  }
  if ( sub_10034150() == 1 && sub_1002C5E0(v0) == 4 )
  {
    v1 = (char *)dword_107FD440;
    v2 = 0;
    do
    {
      if ( *(_DWORD *)&v1[v2 + 326236] )
      {
        *(_DWORD *)&v1[v2 + 326236] += 1500;
        v1 = (char *)dword_107FD440;
      }
      v3 = *(_DWORD *)&v1[v2 + 326288];
      if ( v3 )
      {
        *(_DWORD *)&v1[v2 + 326288] = v3 + 1500;
        v1 = (char *)dword_107FD440;
      }
      v4 = *(_DWORD *)&v1[v2 + 326340];
      if ( v4 )
      {
        *(_DWORD *)&v1[v2 + 326340] = v4 + 1500;
        v1 = (char *)dword_107FD440;
      }
      v2 += 156;
    }
    while ( v2 < 0x7464 );
  }
  sub_10061700((int)&off_10099C6C);
  if ( sub_10061B70((LONG)&off_1009A338) )
  {
    v6 = 0;
    v7 = (void **)off_10099378;
    do
    {
      v8 = sub_1002C1E0(*v7, 0x24u);
      memcpy((void *)(v6 + dword_107FD444), *v7, v8);
      ++v7;
      v6 += 36;
    }
    while ( (signed int)v7 < (signed int)&off_10099C6C );
    result = sub_10061700((int)&off_1009A338);
  }
  else
  {
    sub_10028BC0("..\\lib\\adl\\iop_hsdb_pkt.c", 1087, 1, 0);
    result = sub_10061700((int)&off_1009A338);
  }
  return result;
}
// 10099378: using guessed type char *off_10099378[574];
// 10099C6C: using guessed type char *off_10099C6C;
// 1009A338: using guessed type char *off_1009A338;
// 107FD444: using guessed type int dword_107FD444;

//----- (10014C30) --------------------------------------------------------
int sub_10014C30()
{
  sub_10014950();
  sub_10016D00();
  sub_10012D20((int)&byte_10A08A80);
  return sub_10012DD0((int)&byte_10A08A80);
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10014C60) --------------------------------------------------------
int sub_10014C60()
{
  void *v0; // ecx@1
  void *v1; // ecx@1
  char v2; // al@4
  void *v3; // ecx@4
  int result; // eax@8

  dword_107FD440 = (void *)-15;
  dword_107FD444 = -15;
  sub_10014AD0();
  dword_10A08A98 = (int)dword_107FD440;
  dword_10A08A90 = (int)&unk_10A000C0;
  dword_10A08A94 = 22568;
  dword_10A08A9C = (int)dword_107FD440 + 14328;
  dword_10A08AA0 = (int)&unk_10091800;
  dword_10A08AA4 = 12;
  dword_10A08AA8 = (int)&unk_10098C68;
  byte_10A08A81 = 2;
  dword_10A08A84 = 904;
  dword_10A08AAC = (int)off_10099378;
  dword_10A08AB0 = (int)&unk_10A05900;
  dword_10A08AB4 = 573;
  dword_10A08AB8 = (int)&unk_10099C80;
  byte_10A08A82 = 3;
  byte_10A08A83 = sub_10036CA0(v0);
  dword_10A08AD0 = 0;
  dword_10A08ABC = 91;
  dword_10A08AC0 = (int)dword_107FD440 + 576;
  dword_10A08AC4 = (int)&unk_10A085E0;
  dword_10A08AD4 = 0;
  if ( sub_10034150() == 1 && sub_1002C5E0(v1) == 4 )
    dword_10A08AA0 = (int)dword_107FD440 + 326220;
  v2 = sub_1002C5E0(v1);
  byte_10A08A80 = v2;
  if ( v2 == 8 )
  {
    byte_10A08A80 = 11;
  }
  else if ( v2 == 4 )
  {
    byte_10A08A80 = 5;
  }
  dword_10A08AC8 = sub_1002C660(v3);
  dword_10A08ACC = (int)dword_107FD440 + 357824;
  sub_10014950();
  result = sub_10014500((int)&byte_10A08A80);
  *((_DWORD *)dword_107FD440 + 89743) = dword_10A08A8C;
  return result;
}
// 10099378: using guessed type char *off_10099378[574];
// 107FD444: using guessed type int dword_107FD444;
// 10A08A80: using guessed type char byte_10A08A80;
// 10A08A81: using guessed type char byte_10A08A81;
// 10A08A82: using guessed type char byte_10A08A82;
// 10A08A83: using guessed type char byte_10A08A83;
// 10A08A84: using guessed type int dword_10A08A84;
// 10A08A8C: using guessed type int dword_10A08A8C;
// 10A08A90: using guessed type int dword_10A08A90;
// 10A08A94: using guessed type int dword_10A08A94;
// 10A08A98: using guessed type int dword_10A08A98;
// 10A08A9C: using guessed type int dword_10A08A9C;
// 10A08AA0: using guessed type int dword_10A08AA0;
// 10A08AA4: using guessed type int dword_10A08AA4;
// 10A08AA8: using guessed type int dword_10A08AA8;
// 10A08AAC: using guessed type int dword_10A08AAC;
// 10A08AB0: using guessed type int dword_10A08AB0;
// 10A08AB4: using guessed type int dword_10A08AB4;
// 10A08AB8: using guessed type int dword_10A08AB8;
// 10A08ABC: using guessed type int dword_10A08ABC;
// 10A08AC0: using guessed type int dword_10A08AC0;
// 10A08AC4: using guessed type int dword_10A08AC4;
// 10A08AC8: using guessed type int dword_10A08AC8;
// 10A08ACC: using guessed type int dword_10A08ACC;
// 10A08AD0: using guessed type int dword_10A08AD0;
// 10A08AD4: using guessed type int dword_10A08AD4;

//----- (10014DC0) --------------------------------------------------------
int __cdecl sub_10014DC0(char a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 7 )
    result = (unsigned __int16)word_1009B19C[a1];
  return result;
}
// 1009B19C: using guessed type __int16 word_1009B19C[];

//----- (10014DE0) --------------------------------------------------------
signed int sub_10014DE0()
{
  signed int result; // eax@1

  result = -15;
  dword_107FD7EC = -15;
  dword_107FD7F8 = -15;
  dword_107FD7D4 = -15;
  dword_107FD7FC = -15;
  dword_107FD7E8 = -15;
  dword_107FD7D8 = -15;
  dword_107FD7D0 = -15;
  dword_107FD7E4 = -15;
  dword_107FD7F4 = -15;
  dword_107FD7F0 = -15;
  dword_107FD7E0 = -15;
  dword_107FD7DC = -15;
  return result;
}
// 107FD7D0: using guessed type int dword_107FD7D0;
// 107FD7D4: using guessed type int dword_107FD7D4;
// 107FD7D8: using guessed type int dword_107FD7D8;
// 107FD7DC: using guessed type int dword_107FD7DC;
// 107FD7E0: using guessed type int dword_107FD7E0;
// 107FD7E4: using guessed type int dword_107FD7E4;
// 107FD7E8: using guessed type int dword_107FD7E8;
// 107FD7EC: using guessed type int dword_107FD7EC;
// 107FD7F0: using guessed type int dword_107FD7F0;
// 107FD7F4: using guessed type int dword_107FD7F4;
// 107FD7F8: using guessed type int dword_107FD7F8;
// 107FD7FC: using guessed type int dword_107FD7FC;

//----- (10014E30) --------------------------------------------------------
signed int __usercall sub_10014E30@<eax>(char a1@<al>, int a2@<ecx>)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = sub_10061AA0((int)&off_1009B1BC);
      break;
    case 0:
      result = sub_10061AA0((int)&off_1009B1D0);
      break;
    case 1:
      result = sub_10061AA0((int)&off_1009B1E4);
      break;
    case 2:
      result = sub_10061AA0((int)&off_1009B20C);
      break;
    case 3:
      result = sub_10061AA0((int)&off_1009B1F8);
      break;
    case 5:
      result = sub_10061AA0((int)&off_1009B220);
      break;
    default:
      result = sub_10061AA0(a2);
      break;
  }
  return result;
}
// 1009B1BC: using guessed type char *off_1009B1BC;
// 1009B1D0: using guessed type char *off_1009B1D0;
// 1009B1E4: using guessed type char *off_1009B1E4;
// 1009B1F8: using guessed type char *off_1009B1F8;
// 1009B20C: using guessed type char *off_1009B20C;
// 1009B220: using guessed type char *off_1009B220;

//----- (10014ED0) --------------------------------------------------------
int __usercall sub_10014ED0@<eax>(char a1@<al>)
{
  return sub_10060A00(dword_1009ACEC[a1]);
}
// 1009ACEC: using guessed type int dword_1009ACEC[];

//----- (10014EF0) --------------------------------------------------------
int __usercall sub_10014EF0@<eax>(char a1@<al>)
{
  return sub_10060A60(dword_1009ACEC[a1], 10);
}
// 1009ACEC: using guessed type int dword_1009ACEC[];

//----- (10014F10) --------------------------------------------------------
signed __int16 __usercall sub_10014F10@<ax>(char a1@<al>, unsigned __int16 a2@<si>)
{
  signed __int16 result; // ax@3
  bool v3; // cf@8

  switch ( a1 )
  {
    case 6:
      if ( a2 < 0x2E5u )
      {
        if ( !(unsigned __int8)sub_10014E30(a1, a1) )
        {
          sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3201, 0, 0);
          goto LABEL_6;
        }
        result = *(_WORD *)(dword_107FD7EC + 2 * a2 + 241212);
        v3 = (unsigned __int16)result < 0x256u;
        goto LABEL_31;
      }
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3186, 0, 0);
      return -1;
    default:
      goto LABEL_6;
    case 0:
      if ( a2 >= 0x344u )
      {
        sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3224, 0, 0);
        return -1;
      }
      if ( (unsigned __int8)sub_10014E30(a1, a1) )
      {
        result = *(_WORD *)(dword_107FD7F8 + 2 * a2 + 284664);
        v3 = (unsigned __int16)result < 0x211u;
        goto LABEL_31;
      }
      if ( sub_1002C4D0(15000) )
        goto LABEL_6;
      sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3242, 0, 0);
      return 0;
    case 1:
      if ( a2 >= 0xBCCu )
      {
        sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3265, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10014E30(a1, a1) )
        goto LABEL_6;
      result = *(_WORD *)(dword_107FD7D4 + 2 * a2 + 447808);
      v3 = (unsigned __int16)result < 0x979u;
      goto LABEL_31;
    case 2:
      if ( a2 >= 0x388u )
      {
        sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3302, 0, 0);
        return -1;
      }
      result = *(_WORD *)(dword_10A08AA8 + 2 * a2);
      v3 = (unsigned __int16)result < 0x23Du;
      goto LABEL_31;
    case 3:
      if ( a2 >= 0xBEu )
      {
        sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3339, 0, 0);
        return -1;
      }
      if ( !(unsigned __int8)sub_10014E30(a1, a1) )
      {
        sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3354, 0, 0);
        return 0;
      }
      result = *(_WORD *)(dword_107FD7E8 + 2 * a2 + 23096);
      v3 = (unsigned __int16)result < 0x52u;
      goto LABEL_31;
    case 5:
      if ( a2 < 4u )
      {
        if ( (unsigned __int8)sub_10014E30(a1, a1) )
        {
          result = *(_WORD *)(dword_107FD7D8 + 2 * a2 + 1804);
          v3 = (unsigned __int16)result < 4u;
LABEL_31:
          if ( !v3 )
            result = -1;
        }
        else
        {
LABEL_6:
          result = 0;
        }
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\hsdb\\iop_hsdb_pkt_intf.c", 3377, 0, 0);
        result = -1;
      }
      return result;
  }
}
// 107FD7D4: using guessed type int dword_107FD7D4;
// 107FD7D8: using guessed type int dword_107FD7D8;
// 107FD7E8: using guessed type int dword_107FD7E8;
// 107FD7EC: using guessed type int dword_107FD7EC;
// 107FD7F8: using guessed type int dword_107FD7F8;
// 10A08AA8: using guessed type int dword_10A08AA8;

//----- (10015140) --------------------------------------------------------
char __cdecl sub_10015140(char a1, unsigned __int16 a2, _BYTE *a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v6; // eax@9

  v3 = sub_10014F10(a1, a2);
  if ( v3 != -1 && !sub_10014EF0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_107FD7EC);
        sub_10014ED0(a1);
        return 1;
      case 0:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_107FD7F8);
        sub_10014ED0(a1);
        return 1;
      case 1:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        v6 = dword_107FD7D4;
        goto LABEL_15;
      case 2:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_10A08A98);
        sub_10014ED0(a1);
        return 1;
      case 3:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        *a3 = *(_BYTE *)((unsigned __int16)v3 + dword_107FD7E8);
        sub_10014ED0(a1);
        return 1;
      case 5:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        v6 = dword_107FD7D8;
LABEL_15:
        *a3 = *(_BYTE *)((unsigned __int16)v3 + v6);
        sub_10014ED0(a1);
        return 1;
      default:
LABEL_16:
        sub_10014ED0(a1);
        break;
    }
  }
  return 0;
}
// 107FD7D4: using guessed type int dword_107FD7D4;
// 107FD7D8: using guessed type int dword_107FD7D8;
// 107FD7E8: using guessed type int dword_107FD7E8;
// 107FD7EC: using guessed type int dword_107FD7EC;
// 107FD7F8: using guessed type int dword_107FD7F8;
// 10A08A98: using guessed type int dword_10A08A98;

//----- (10015290) --------------------------------------------------------
char __cdecl sub_10015290(char a1, unsigned __int16 a2, void *a3)
{
  int v3; // ecx@1
  signed __int16 v4; // si@1
  char result; // al@2

  v4 = sub_10014F10(a1, a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10014E30(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_107FD7EC + 210116), 0x34u);
        result = 1;
        break;
      case 0:
        if ( (unsigned __int8)sub_10014E30(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_107FD7F8 + 257156), 0x34u);
        result = 1;
        break;
      case 1:
        result = sub_10014E30(a1, v3);
        if ( result != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_107FD7D4 + 321708), 0x34u);
        break;
      case 2:
        qmemcpy(a3, (const void *)(dword_10A08AA0 + 52 * (unsigned __int16)v4), 0x34u);
        result = 1;
        break;
      case 3:
        if ( (unsigned __int8)sub_10014E30(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_107FD7E8 + 18832), 0x34u);
        result = 1;
        break;
      case 5:
        if ( (unsigned __int8)sub_10014E30(a1, v3) != 1 )
          goto LABEL_15;
        qmemcpy(a3, (const void *)(52 * (unsigned __int16)v4 + dword_107FD7D8 + 1596), 0x34u);
        result = 1;
        break;
      default:
LABEL_15:
        result = 0;
        break;
    }
  }
  return result;
}
// 107FD7D4: using guessed type int dword_107FD7D4;
// 107FD7D8: using guessed type int dword_107FD7D8;
// 107FD7E8: using guessed type int dword_107FD7E8;
// 107FD7EC: using guessed type int dword_107FD7EC;
// 107FD7F8: using guessed type int dword_107FD7F8;
// 10A08AA0: using guessed type int dword_10A08AA0;

//----- (10015400) --------------------------------------------------------
char __cdecl sub_10015400(char a1, unsigned __int16 a2, int a3)
{
  signed __int16 v3; // si@1
  int v4; // ecx@2
  int v5; // eax@5

  v3 = sub_10014F10(a1, a2);
  if ( v3 != -1 && !sub_10014EF0(a1) )
  {
    switch ( a1 )
    {
      case 6:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_107FD7EC + 24 * ((unsigned __int16)v3 + 25);
        goto LABEL_15;
      case 0:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_107FD7F8 + 24 * (unsigned __int16)v3 + 532;
        goto LABEL_15;
      case 1:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_107FD7D4 + 24 * (unsigned __int16)v3 + 2428;
        goto LABEL_15;
      case 2:
        v5 = dword_10A08AC0 + 24 * (unsigned __int16)v3;
        goto LABEL_15;
      case 3:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_107FD7E8 + 24 * (unsigned __int16)v3 + 84;
        goto LABEL_15;
      case 5:
        if ( (unsigned __int8)sub_10014E30(a1, v4) != 1 )
          goto LABEL_16;
        v5 = dword_107FD7D8 + 24 * (unsigned __int16)v3 + 4;
LABEL_15:
        *(_DWORD *)a3 = *(_DWORD *)v5;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(a3 + 12) = *(_DWORD *)(v5 + 12);
        *(_DWORD *)(a3 + 16) = *(_DWORD *)(v5 + 16);
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v5 + 20);
        sub_10014ED0(a1);
        return 1;
      default:
LABEL_16:
        sub_10014ED0(a1);
        break;
    }
  }
  return 0;
}
// 107FD7D4: using guessed type int dword_107FD7D4;
// 107FD7D8: using guessed type int dword_107FD7D8;
// 107FD7E8: using guessed type int dword_107FD7E8;
// 107FD7EC: using guessed type int dword_107FD7EC;
// 107FD7F8: using guessed type int dword_107FD7F8;
// 10A08AC0: using guessed type int dword_10A08AC0;

//----- (10015560) --------------------------------------------------------
char __cdecl sub_10015560(int a1, int a2, void *a3, char a4, int a5, int a6)
{
  int v6; // ecx@0
  signed __int16 v7; // ax@1
  int v8; // ebp@2
  __int16 v9; // si@10
  int v11; // [sp-8h] [bp-570h]@16
  __int16 v12; // [sp+8h] [bp-560h]@12
  __int16 v13; // [sp+3Ch] [bp-52Ch]@9
  char v14; // [sp+40h] [bp-528h]@15
  char v15; // [sp+41h] [bp-527h]@9
  __int16 v16; // [sp+42h] [bp-526h]@9
  char v17; // [sp+44h] [bp-524h]@9
  __int16 v18; // [sp+46h] [bp-522h]@14
  int v19; // [sp+48h] [bp-520h]@15
  char v20; // [sp+4Ch] [bp-51Ch]@14

  LOBYTE(v7) = a1;
  switch ( (char)a1 )
  {
    case 6:
      v8 = 28;
      goto LABEL_7;
    case 0:
      v8 = 29;
      goto LABEL_7;
    case 1:
      v8 = 30;
      goto LABEL_7;
    case 3:
      v8 = 32;
      goto LABEL_7;
    case 5:
      v8 = 33;
LABEL_7:
      LOBYTE(v7) = sub_10014E30(a1, v6);
      if ( !(_BYTE)v7 )
        return v7;
      v7 = sub_10014F10(a1, a2);
      if ( v7 == -1 )
        return v7;
      v15 = a6;
      LOBYTE(v7) = a4;
      v13 = -32768;
      v16 = a2;
      v17 = a4;
      if ( a4 == 1 )
      {
        v9 = a5;
        if ( (unsigned __int16)a5 > 0x514u )
          return v7;
      }
      else
      {
        if ( sub_10015290(a1, a2, &v12) != 1 )
          goto LABEL_15;
        v9 = v12;
      }
      memcpy(&v20, a3, (unsigned __int16)v9);
      v18 = v9;
LABEL_15:
      v19 = sub_10060900();
      v14 = 0;
      LOBYTE(v7) = sub_1002CB10(v8, (int)&v13);
      return v7;
    default:
      return v7;
    case 2:
      v11 = sub_10060900();
      if ( a4 == 1 )
        LOBYTE(v7) = sub_10013920(a2, a5, a6, (int)&byte_10A08A80, a3, v11);
      else
        LOBYTE(v7) = sub_10013610(a2, a6, (int)&byte_10A08A80, a3, v11);
      return v7;
  }
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10015710) --------------------------------------------------------
char __cdecl sub_10015710(char a1, int a2, int a3)
{
  signed __int16 v3; // ax@1
  int v4; // edi@2
  __int16 v6; // [sp+4h] [bp-52Ch]@8
  __int16 v7; // [sp+8h] [bp-528h]@9
  int v8; // [sp+Ch] [bp-524h]@9

  LOBYTE(v3) = a1;
  switch ( a1 )
  {
    case 6:
      v4 = 28;
      goto LABEL_8;
    case 0:
      v4 = 29;
      goto LABEL_8;
    case 1:
      v4 = 30;
      goto LABEL_8;
    case 2:
      LOBYTE(v3) = sub_10013C10(a2, a3, (int)&byte_10A08A80);
      return v3;
    case 3:
      v4 = 32;
      goto LABEL_8;
    case 5:
      v4 = 33;
LABEL_8:
      memset(&v6, 0, 0x528u);
      v3 = sub_10014F10(a1, a2);
      if ( v3 != -1 )
      {
        v6 = -32766;
        v7 = a2;
        v8 = a3;
        LOBYTE(v3) = sub_1002CB10(v4, (int)&v6);
      }
      break;
    default:
      return v3;
  }
  return v3;
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10015820) --------------------------------------------------------
char __cdecl sub_10015820(char a1, int a2, __int16 a3, __int16 a4, void *a5, int a6)
{
  char result; // al@2
  int v7; // ecx@3
  signed __int16 v8; // si@3
  int v9; // eax@7
  int v10; // ebp@7
  int v11; // esi@7
  int v12; // edi@7
  unsigned int v13; // ebx@7
  int v14; // eax@9
  int v15; // eax@11
  int v16; // eax@12
  int v17; // eax@14
  int v18; // eax@16
  int v19; // eax@24
  char v20; // [sp+7h] [bp-9h]@18
  __int16 v21; // [sp+8h] [bp-8h]@1
  unsigned int v22; // [sp+Ch] [bp-4h]@1

  v22 = sub_10060900();
  v21 = 0;
  if ( a1 < 7 )
  {
    v8 = sub_10014F10(a1, a2);
    if ( v8 == -1 )
    {
      result = 0;
    }
    else
    {
      switch ( a1 )
      {
        case 6:
          if ( !(unsigned __int8)sub_10014E30(a1, v7) )
            goto LABEL_29;
          v9 = 3 * (unsigned __int16)v8 + 75;
          v10 = dword_107FD7EC + 14952;
          v11 = 52 * (unsigned __int16)v8 + dword_107FD7EC + 210116;
          v12 = dword_107FD7EC + 8 * v9;
          v13 = 195164;
          goto LABEL_17;
        case 0:
          if ( !(unsigned __int8)sub_10014E30(a1, v7) )
            goto LABEL_29;
          v14 = 3 * (unsigned __int16)v8;
          v10 = dword_107FD7F8 + 13228;
          v11 = 52 * (unsigned __int16)v8 + dword_107FD7F8 + 257156;
          v12 = dword_107FD7F8 + 8 * v14 + 532;
          v13 = 243928;
          goto LABEL_17;
        case 1:
          if ( !(unsigned __int8)sub_10014E30(a1, v7) )
            goto LABEL_29;
          v15 = 3 * (unsigned __int16)v8;
          v10 = dword_107FD7D4 + 60628;
          v11 = 52 * (unsigned __int16)v8 + dword_107FD7D4 + 321708;
          v12 = dword_107FD7D4 + 8 * v15 + 2428;
          v13 = 261080;
          goto LABEL_17;
        case 2:
          v10 = dword_10A08A9C;
          v16 = (unsigned __int16)v8;
          v11 = dword_10A08AA0 + 52 * (unsigned __int16)v8;
          v12 = dword_10A08AC0 + 24 * v16;
          v13 = 311892;
          goto LABEL_17;
        case 3:
          if ( !(unsigned __int8)sub_10014E30(a1, v7) )
            goto LABEL_29;
          v17 = 3 * (unsigned __int16)v8;
          v10 = dword_107FD7E8 + 2052;
          v11 = 52 * (unsigned __int16)v8 + dword_107FD7E8 + 18832;
          v12 = dword_107FD7E8 + 8 * v17 + 84;
          v13 = 16780;
          goto LABEL_17;
        case 5:
          if ( !(unsigned __int8)sub_10014E30(a1, v7) )
            goto LABEL_29;
          v18 = 3 * (unsigned __int16)v8;
          v10 = dword_107FD7D8 + 100;
          v11 = 52 * (unsigned __int16)v8 + dword_107FD7D8 + 1596;
          v12 = dword_107FD7D8 + 8 * v18 + 4;
          v13 = 1496;
LABEL_17:
          if ( sub_10014EF0(a1) )
            goto LABEL_29;
          v20 = *(_BYTE *)(v12 + 1);
          if ( *(_BYTE *)(v12 + 1) == 1 && v10 )
          {
            if ( *(_DWORD *)(v11 + 12) && v22 > *(_DWORD *)(v11 + 16) + *(_DWORD *)(v12 + 16) )
              goto LABEL_32;
            v21 = a4;
            if ( !a4 )
              v21 = *(_WORD *)(v12 + 4) - a3;
            v19 = *(_DWORD *)(v11 + 4) + (unsigned __int16)a3;
            if ( !v21 || (unsigned int)(unsigned __int16)v21 + v19 > v13 )
LABEL_32:
              v20 = 0;
            else
              memcpy(a5, (const void *)(v10 + v19), (unsigned __int16)v21);
          }
          *(_WORD *)a6 = v21;
          sub_10014ED0(a1);
          result = v20;
          break;
        default:
LABEL_29:
          result = 0;
          break;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 107FD7D0: using guessed type int dword_107FD7D0;
// 107FD7D4: using guessed type int dword_107FD7D4;
// 107FD7D8: using guessed type int dword_107FD7D8;
// 107FD7E4: using guessed type int dword_107FD7E4;
// 107FD7E8: using guessed type int dword_107FD7E8;
// 107FD7EC: using guessed type int dword_107FD7EC;
// 107FD7F4: using guessed type int dword_107FD7F4;
// 107FD7F8: using guessed type int dword_107FD7F8;
// 10A08A9C: using guessed type int dword_10A08A9C;
// 10A08AA0: using guessed type int dword_10A08AA0;
// 10A08AC0: using guessed type int dword_10A08AC0;

//----- (10015A90) --------------------------------------------------------
char __cdecl sub_10015A90(char a1, int a2, __int16 a3, __int16 a4, void *a5)
{
  int v5; // ecx@0
  int v7; // [sp+0h] [bp-4h]@1

  v7 = v5;
  return sub_10015820(a1, a2, a3, a4, a5, (int)&v7);
}

//----- (10015AC0) --------------------------------------------------------
char __cdecl sub_10015AC0(char a1, int a2, void *a3)
{
  int v3; // ecx@0
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v3;
  return sub_10015820(a1, a2, 0, 0, a3, (int)&v5);
}

//----- (10015AF0) --------------------------------------------------------
char __cdecl sub_10015AF0(char a1, int a2, void *a3, int a4)
{
  return sub_10015820(a1, a2, 0, 0, a3, a4);
}

//----- (10015B20) --------------------------------------------------------
const char *__cdecl sub_10015B20(int a1, unsigned __int16 a2)
{
  int v2; // ecx@1
  const char *result; // eax@1

  v2 = *(_DWORD *)(a1 + 44);
  result = "UNKNOWN";
  if ( v2 )
  {
    if ( a2 <= *(_WORD *)(*(_DWORD *)(a1 + 40) + 2 * *(_DWORD *)(a1 + 4)) )
      result = *(const char **)(v2 + 4 * a2);
  }
  return result;
}

//----- (10015B50) --------------------------------------------------------
int __cdecl sub_10015B50(char a1, int a2)
{
  void *v2; // ecx@1
  void *v3; // ecx@1
  void *v4; // ecx@2
  int v5; // eax@3
  int v6; // ecx@16

  sub_10060A60(*(_DWORD *)(a2 + 60), -1);
  *(_BYTE *)a2 = sub_1002C5E0(v2) | 1;
  if ( a1 == 1 )
  {
    if ( sub_100340B0(2048) )
      v5 = sub_1002C660(v4) | 0x300;
    else
      v5 = sub_1002C660(v4) | 0x83B00;
    *(_DWORD *)(a2 + 72) = v5;
    if ( !sub_100340B0(0x10000) )
      *(_DWORD *)(a2 + 72) |= 0x110000u;
    if ( !sub_100340B0(0x20000) )
      *(_DWORD *)(a2 + 72) |= 0x220000u;
    if ( !sub_100340B0(1024) )
      *(_DWORD *)(a2 + 72) |= 0x400u;
    if ( !sub_100340B0(0x1000000) )
      *(_DWORD *)(a2 + 72) |= 0x3000000u;
    if ( !sub_100340B0(0x4000000) )
      *(_DWORD *)(a2 + 72) |= 0x4000000u;
    if ( !sub_100340B0(0x8000000) )
    {
      v6 = *(_DWORD *)(a2 + 60);
      *(_DWORD *)(a2 + 72) |= 0x8000000u;
      sub_10060A00(v6);
      return sub_10014500(a2);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 72) = sub_1002C660(v3);
  }
  sub_10060A00(*(_DWORD *)(a2 + 60));
  return sub_10014500(a2);
}

//----- (10015C70) --------------------------------------------------------
char __cdecl sub_10015C70(int a1, int a2)
{
  void *v2; // ecx@0
  char result; // al@1
  char v4; // [sp+4h] [bp-30h]@4

  result = sub_1002C560(v2);
  if ( byte_107FD802 == 1 || result == 1 )
  {
    result = a1;
    if ( (_WORD)a1 == word_107FD800 )
    {
      sub_100144B0(a1, a2, &v4);
      result = sub_100383A0((int)&dword_10A000A0, &v4);
    }
  }
  return result;
}
// 107FD800: using guessed type __int16 word_107FD800;
// 107FD802: using guessed type char byte_107FD802;
// 10A000A0: using guessed type int dword_10A000A0;

//----- (10015E00) --------------------------------------------------------
int __usercall sub_10015E00@<eax>(char *a1@<edi>, size_t a2@<esi>, int a3)
{
  __int16 v3; // ax@1
  int result; // eax@2

  v3 = a3 & 0x3FFF;
  a3 &= 0x3FFFu;
  if ( v3 & 0x2000 )
  {
    result = sub_1002C2B0(a1, a2, "'%c'", v3 & 0xDFFF);
  }
  else
  {
    result = sub_1002CC90(&a3, 2u, (int)&unk_1009BD80, 14, 103, 103);
    if ( (_BYTE)result != 103 )
      result = sub_1002C120((int)a1, &aStop_accel[14 * (unsigned __int8)result], a2);
  }
  return result;
}

//----- (10015E70) --------------------------------------------------------
int __cdecl sub_10015E70(char a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_1002CC90(&a1, 1u, (int)&unk_1009C328, 13, 96, 96);
  if ( (_BYTE)result != 96 )
    result = sub_1002C120(a2, &aSkey1[13 * (unsigned __int8)result], a3);
  return result;
}

//----- (10015EB0) --------------------------------------------------------
int __cdecl sub_10015EB0(char a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_1002CC90(&a1, 1u, (int)&unk_1009C808, 13, 19, 19);
  if ( (_BYTE)result != 19 )
    result = sub_1002C120(a2, &aCrs_k[13 * (unsigned __int8)result], a3);
  return result;
}

//----- (10015EF0) --------------------------------------------------------
int __cdecl sub_10015EF0(char a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_1002CC90(&a1, 1u, (int)&unk_1009C900, 12, 6, 6);
  if ( (_BYTE)result != 6 )
    result = sub_1002C120(a2, &aGdu_key[12 * (unsigned __int8)result], a3);
  return result;
}

//----- (10015F30) --------------------------------------------------------
char __thiscall sub_10015F30(void *this)
{
  const void *v1; // esi@1
  char result; // al@3
  __int16 v3; // [sp+8h] [bp-52Ch]@1
  char v4; // [sp+Ch] [bp-528h]@1
  int v5; // [sp+2Ch] [bp-508h]@3
  char v6; // [sp+30h] [bp-504h]@1
  char v7; // [sp+31h] [bp-503h]@3
  char v8; // [sp+32h] [bp-502h]@3
  char v9; // [sp+34h] [bp-500h]@3

  v1 = this;
  memset(&v3, 0, 0x528u);
  v3 = -32724;
  qmemcpy(&v4, v1, 0x2Cu);
  if ( v6 == 2 || v6 == 3 )
  {
    sub_1002CC40((int)&v3);
    result = 1;
  }
  else
  {
    sub_10038430(v5, v7, v9 != 0, v8);
    result = 1;
  }
  return result;
}

//----- (10015FE0) --------------------------------------------------------
char __cdecl sub_10015FE0(int a1, int a2)
{
  char v2; // al@1
  char v3; // al@8
  char v4; // al@15
  const char *v5; // esi@15
  float v6; // ST30_4@17
  const char *v8; // [sp-8h] [bp-3Ch]@12
  char v9[4]; // [sp+10h] [bp-24h]@1
  int v10; // [sp+14h] [bp-20h]@1
  int v11; // [sp+18h] [bp-1Ch]@1
  int v12; // [sp+1Ch] [bp-18h]@1
  int v13; // [sp+20h] [bp-14h]@1
  int v14; // [sp+24h] [bp-10h]@1
  int v15; // [sp+28h] [bp-Ch]@1
  int v16; // [sp+2Ch] [bp-8h]@1

  *(_DWORD *)v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  sub_10015EF0(*(_BYTE *)(a1 + 36), a1, 32);
  v2 = *(_BYTE *)(a1 + 36);
  if ( v2 && v2 != 4 )
  {
    if ( v2 == 1 || v2 == 5 )
      sub_10015EB0(*(_BYTE *)(a1 + 37), (int)v9, 32);
    else
      sub_10015E00(v9, 0x20u, *(_WORD *)(a1 + 34));
  }
  else
  {
    sub_10015E70(*(_BYTE *)(a1 + 37), (int)v9, 32);
  }
  sub_1002C2E0((const char *)a1, ",", 32);
  sub_1002C2E0((const char *)a1, v9, 32);
  sub_1002C2E0((const char *)a1, ",", 32);
  v3 = *(_BYTE *)(a1 + 36);
  if ( v3 && v3 != 2 )
  {
    if ( v3 == 4 )
    {
      switch ( *(_BYTE *)(a1 + 40) )
      {
        case 0:
          v8 = "NONE";
          goto LABEL_21;
        case 1:
          v8 = "HOLD";
          goto LABEL_21;
        case 2:
          goto LABEL_14;
        case 3:
          goto LABEL_19;
        default:
          break;
      }
    }
    else
    {
      v4 = *(_BYTE *)(a1 + 38);
      v5 = "LEFT";
      if ( v4 >= 0 )
        v5 = "RIGHT";
      v6 = (double)v4;
      sub_1002C2B0(v9, 0x20u, "%s,%d", v5, (signed int)COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF));
      sub_1002C2E0((const char *)a1, v9, 32);
    }
  }
  else
  {
    switch ( *(_BYTE *)(a1 + 40) )
    {
      case 1:
LABEL_14:
        v8 = "DOWN";
        goto LABEL_21;
      case 0:
LABEL_19:
        v8 = "UP";
        goto LABEL_21;
      case 2:
      case 3:
        v8 = "STUCK";
LABEL_21:
        sub_1002C2E0((const char *)a1, v8, 32);
        break;
      default:
        break;
    }
  }
  sub_1002C0D0((const char *)a1, 0x1Fu, 32);
  return sub_10014160((unsigned __int16)word_107FD800, 0x2Cu, 0xFFFFFFF, (void *)a1, 1, a2);
}
// 107FD800: using guessed type __int16 word_107FD800;

//----- (100161D0) --------------------------------------------------------
char sub_100161D0()
{
  char result; // al@2
  char v1; // [sp+0h] [bp-30h]@3

  if ( sub_10038370((int)&dword_10A000A0) )
  {
    sub_10038300((int)&dword_10A000A0, &v1);
    sub_10015F30(&v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10A000A0: using guessed type int dword_10A000A0;

//----- (10016230) --------------------------------------------------------
char __cdecl sub_10016230(char a1)
{
  char result; // al@2
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 == 1 )
      result = sub_100010F0();
  }
  else
  {
    LOWORD(v2) = -32757;
    sub_1002CC40((int)&v2);
    sub_1002CC50((int)&v2);
    sub_1002CC60((int)&v2);
    sub_1002CC80((int)&v2);
    sub_1002CC70((int)&v2);
    result = sub_1002CC30((int)&v2);
  }
  return result;
}

//----- (100162A0) --------------------------------------------------------
char __cdecl sub_100162A0(unsigned __int8 a1)
{
  char result; // al@4
  int v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+8h] [bp-Ch]@1
  int v4; // [sp+Ch] [bp-8h]@1

  v2 = 0;
  v3 = 0;
  v4 = 0;
  if ( a1 >= 2u || sub_10060E40(9132, &v2, 12, &unk_1009CAC4) )
  {
    result = 4;
  }
  else if ( (unsigned int)(sub_10060900() - *(&v3 + a1)) >= 0x4E20 )
  {
    result = 4;
  }
  else
  {
    result = *((_BYTE *)&v2 + a1);
  }
  return result;
}

//----- (10016340) --------------------------------------------------------
char __cdecl sub_10016340(unsigned __int8 a1)
{
  char result; // al@1
  int v2; // eax@2
  int v3; // [sp+4h] [bp-14h]@1
  int v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+Ch] [bp-Ch]@1
  __int16 v6; // [sp+10h] [bp-8h]@1
  char v7; // [sp+12h] [bp-6h]@1

  result = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( a1 < 0xB0u )
  {
    LOWORD(v2) = sub_1002DBA0(a1);
    result = sub_10012840(v2, (int)&byte_10A08A80);
    if ( byte_107FE2D8[a1] )
    {
      LOWORD(v3) = -32711;
      LOBYTE(v4) = 1;
      BYTE1(v4) = a1;
      result = sub_1002CC40((int)&v3);
    }
    byte_107FE2D8[a1] = 0;
    byte_107FE388[a1] = 0;
  }
  return result;
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (100163D0) --------------------------------------------------------
char __cdecl sub_100163D0(__int16 a1)
{
  int v2; // [sp+0h] [bp-Ch]@1
  __int16 v3; // [sp+4h] [bp-8h]@1

  v2 = 0;
  LOWORD(v2) = -32743;
  v3 = a1;
  return sub_1002CC40((int)&v2);
}

//----- (10016420) --------------------------------------------------------
char __cdecl sub_10016420(int a1, int a2)
{
  char result; // al@1
  int v3; // eax@2
  unsigned __int8 v4; // al@2
  int v5; // ecx@3
  char v6; // al@3
  char v7; // [sp+Ch] [bp-80h]@1
  char v8; // [sp+1Bh] [bp-71h]@2
  char v9; // [sp+23h] [bp-69h]@2
  char v10; // [sp+2Fh] [bp-5Dh]@2
  char v11; // [sp+4Bh] [bp-41h]@2
  char v12; // [sp+6Bh] [bp-21h]@2
  char v13; // [sp+77h] [bp-15h]@2
  int v14; // [sp+80h] [bp-Ch]@1
  __int16 v15; // [sp+84h] [bp-8h]@1

  v14 = 0;
  v15 = 0;
  result = sub_100144B0(a1, a2, &v7);
  if ( result == 1 )
  {
    v12 = 0;
    v11 = 0;
    v8 = 0;
    v13 = 0;
    v10 = 0;
    v9 = 0;
    v3 = sub_10060900();
    sub_10013610(a1, 1, a2, &v7, v3);
    v4 = sub_1002DB40(a1);
    if ( v4 < 0xB0u )
    {
      v5 = v4;
      v6 = byte_107FE388[v4];
      if ( (unsigned __int8)v6 < 4u )
        byte_107FE388[v5] = v6 + 1;
    }
    LOWORD(v14) = -32743;
    v15 = a1;
    result = sub_1002CC40((int)&v14);
  }
  return result;
}

//----- (100164F0) --------------------------------------------------------
char __cdecl sub_100164F0(int a1, int a2)
{
  void *v2; // ecx@1
  char v3; // si@1
  char v4; // bl@1
  __int16 v5; // ax@2
  int v6; // eax@6
  char v8; // [sp+18h] [bp-78h]@1

  memset(&v8, 0, 0x74u);
  v3 = sub_1002DB00(v2);
  v4 = 0;
  while ( 1 )
  {
    LOBYTE(v5) = off_1009D6D8[(unsigned __int8)v4](v3);
    if ( (unsigned __int8)v5 < 0xB0u )
    {
      v5 = sub_1002DBA0(v5);
      if ( (_WORD)a1 == v5 )
        break;
    }
    if ( (unsigned __int8)++v4 >= 3u )
      return v5;
  }
  sub_100312A0(&v8, v4);
  v6 = sub_10060900();
  LOBYTE(v5) = sub_10013610(a1, 1, a2, &v8, v6);
  return v5;
}
// 1009D6D8: using guessed type int (__cdecl *off_1009D6D8[3])(char);

//----- (100165C0) --------------------------------------------------------
char __cdecl sub_100165C0(int a1, int a2)
{
  int v2; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = 1400;
  v2 = sub_10060900();
  return sub_10013610(a1, 1, a2, &v4, v2);
}

//----- (100165F0) --------------------------------------------------------
bool __thiscall sub_100165F0(void *this)
{
  int v1; // esi@1
  void *v2; // ecx@1
  int v3; // edi@1
  void *v4; // ecx@1
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // esi@1

  v1 = sub_10030640(this);
  v3 = sub_1002C5C0(v2);
  v5 = sub_1002C660(v4);
  v6 = 0;
  v7 = v5 | ~v1;
  while ( !(v7 & dword_1009D728[v6] & v3) )
  {
    if ( ++v6 >= 7 )
      return 1;
  }
  return v5 == dword_1009D728[v6];
}
// 1009D728: using guessed type int dword_1009D728[];

//----- (10016640) --------------------------------------------------------
bool __usercall sub_10016640@<al>(unsigned __int8 a1@<al>)
{
  char v1; // bl@1
  int v2; // esi@2
  bool result; // al@3
  unsigned __int8 v4; // al@4
  char v5; // al@5
  char v6; // al@5
  int v7; // esi@6
  bool v8; // zf@6
  int *v9; // eax@6
  _BYTE *v10; // edx@9
  char v11; // al@13
  char v12; // al@13
  int v13; // esi@14
  int *v14; // edi@14
  int v15; // [sp+4h] [bp-8h]@3
  _BYTE *v16; // [sp+8h] [bp-4h]@6

  v1 = 0;
  if ( a1 < 0xEu )
  {
    v2 = 3 * a1;
    if ( dword_1009D634[v2] )
    {
      sub_10038790((int)&v15);
      return (v15 & dword_1009D634[v2]) != 0;
    }
    v4 = byte_1009D630[v2 * 4];
    switch ( byte_1009D630[v2 * 4] )
    {
      case 0x73:
      case 0x77:
        v5 = sub_1002DB80(v4);
        v6 = sub_100341C0(v5);
        if ( (unsigned __int8)v6 >= 2u )
          return v1;
        v7 = (unsigned __int8)v6;
        v8 = LOBYTE(dword_107FD818[(unsigned __int8)v6]) == 0;
        v9 = &dword_107FD818[(unsigned __int8)v6];
        v16 = v9;
        if ( v8 )
        {
          if ( sub_100309D0(
                 byte_1009D748[2 * v7],
                 (char *)&dword_107FD818[v7] + 3,
                 (unsigned __int8 *)&dword_107FD818[v7] + 2) )
          {
            v10 = v16;
            BYTE1(dword_107FD818[v7]) = 0;
            *v10 = 1;
            result = 1;
          }
          else
          {
            if ( sub_10030A60(
                   byte_1009D749[2 * v7],
                   (char *)&dword_107FD818[v7] + 3,
                   (unsigned __int8 *)&dword_107FD818[v7] + 2) )
            {
              v1 = 1;
              BYTE1(dword_107FD818[v7]) = 1;
            }
            *v16 = v1;
            result = v1;
          }
        }
        else
        {
          *(_BYTE *)v9 = 1;
          result = 1;
        }
        return result;
      case 0x98:
      case 0x99:
      case 0x9A:
      case 0x9B:
        v11 = sub_1002DB80(v4);
        v12 = sub_10038470(v11);
        if ( (unsigned __int8)v12 >= 4u )
          return v1;
        v13 = (unsigned __int8)v12;
        v14 = &dword_107FD808[(unsigned __int8)v12];
        if ( LOBYTE(dword_107FD808[(unsigned __int8)v12]) )
        {
          *(_BYTE *)v14 = 1;
          return 1;
        }
        if ( sub_10030A60(
               byte_1009D744[(unsigned __int8)v12],
               (char *)&dword_107FD808[(unsigned __int8)v12] + 3,
               (unsigned __int8 *)&dword_107FD808[(unsigned __int8)v12] + 2) )
        {
          v1 = 1;
          BYTE1(dword_107FD808[v13]) = 1;
        }
        *(_BYTE *)v14 = v1;
        break;
      default:
        return v1;
    }
  }
  return v1;
}
// 1009D634: using guessed type int dword_1009D634[];
// 107FD808: using guessed type int dword_107FD808[];
// 107FD818: using guessed type int dword_107FD818[];

//----- (10016800) --------------------------------------------------------
int __cdecl sub_10016800(char a1)
{
  return sub_1002CC90(&a1, 1u, (int)byte_1009D630, 12, 14, 14);
}

//----- (10016820) --------------------------------------------------------
int __usercall sub_10016820@<eax>(unsigned __int8 a1@<al>)
{
  signed int v1; // edi@1
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  unsigned __int8 v6; // al@4
  int v7; // ecx@4
  char v8; // al@5
  char v9; // al@5
  int v10; // esi@6
  char v11; // al@7
  char v12; // ST04_1@7
  char v13; // al@7
  char v14; // cl@9
  char v15; // al@10
  char v16; // al@10
  int v17; // esi@11
  char v18; // al@12
  char v19; // ST04_1@12
  char v20; // al@12
  char v21; // [sp+7h] [bp-5h]@7
  char v22; // [sp+8h] [bp-4h]@7

  v1 = 0;
  if ( a1 < 0xEu )
  {
    v2 = 6 * a1;
    v3 = dword_1009D634[2 * v2 / 4u];
    v4 = 2 * v2;
    if ( v3 )
      return j_HWM_pvg_hsdb_get_lrus_online(v3) & v3;
    v6 = byte_1009D630[v4];
    v7 = v6;
    switch ( v6 )
    {
      case 0x73u:
      case 0x77u:
        v8 = sub_1002DB80(v6);
        v9 = sub_100341C0(v8);
        if ( (unsigned __int8)v9 < 2u )
        {
          v10 = (unsigned __int8)v9;
          if ( LOBYTE(dword_107FD818[v10]) )
          {
            v11 = BYTE3(dword_107FD818[v10]);
            v22 = BYTE2(dword_107FD818[v10]);
            v12 = BYTE1(dword_107FD818[v10]);
            v13 = sub_10031B40(v11);
            if ( sub_10031D70(v13, v12, &v22, &v21) )
            {
              if ( v21 == 2 )
              {
                v14 = BYTE3(dword_107FD818[v10]);
                goto LABEL_15;
              }
            }
          }
        }
        break;
      case 0x98u:
      case 0x99u:
      case 0x9Au:
      case 0x9Bu:
        v15 = sub_1002DB80(v6);
        v16 = sub_10038470(v15);
        if ( (unsigned __int8)v16 < 4u )
        {
          v17 = (unsigned __int8)v16;
          if ( LOBYTE(dword_107FD808[v17]) )
          {
            v18 = BYTE3(dword_107FD808[v17]);
            v22 = BYTE2(dword_107FD808[v17]);
            v19 = BYTE1(dword_107FD808[v17]);
            v20 = sub_10031B40(v18);
            if ( sub_10031D70(v20, v19, &v22, &v21) )
            {
              if ( v21 == 2 )
              {
                v14 = BYTE3(dword_107FD808[v17]);
LABEL_15:
                v1 = sub_10031B80(v14);
              }
            }
          }
        }
        break;
      default:
        break;
    }
    v1 &= j_HWM_pvg_hsdb_get_lrus_online(v7);
  }
  return v1;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 1009D634: using guessed type int dword_1009D634[];
// 107FD808: using guessed type int dword_107FD808[];
// 107FD818: using guessed type int dword_107FD818[];

//----- (100169B0) --------------------------------------------------------
char __fastcall sub_100169B0(unsigned __int8 a1)
{
  char result; // al@1

  result = 0;
  if ( a1 < 0xB0u )
    result = *((_BYTE *)dword_107FD820 + a1);
  return result;
}

//----- (100169D0) --------------------------------------------------------
signed int sub_100169D0()
{
  if ( !sub_10061B70((LONG)&off_1009D74C) )
    sub_10028BC0("..\\lib\\adl\\iop_prod_data.c", 2111, 1, 0);
  return sub_10061700((int)&off_1009D74C);
}
// 1009D74C: using guessed type char *off_1009D74C;

//----- (10016A10) --------------------------------------------------------
int __usercall sub_10016A10@<eax>(int result@<eax>, char a2@<dl>)
{
  if ( (unsigned __int8)result < 0xB0u )
  {
    result = (unsigned __int8)result;
    *((_BYTE *)dword_107FD820 + (unsigned __int8)result) = a2;
  }
  return result;
}

//----- (10016A30) --------------------------------------------------------
void *sub_10016A30()
{
  dword_107FD820 = (void *)-15;
  sub_100169D0();
  dword_107FD824 = 0;
  dword_107FE2C8 = 0;
  dword_107FE2CC = 0;
  dword_107FE2D0 = 0;
  word_107FE2D4 = 0;
  memset(byte_107FE388, 0, 0xB0u);
  return memset(byte_107FE2D8, 0, 0xB0u);
}
// 107FD824: using guessed type int dword_107FD824;
// 107FE2C8: using guessed type int dword_107FE2C8;
// 107FE2CC: using guessed type int dword_107FE2CC;
// 107FE2D0: using guessed type int dword_107FE2D0;
// 107FE2D4: using guessed type __int16 word_107FE2D4;

//----- (10016A90) --------------------------------------------------------
char __thiscall sub_10016A90(void *this)
{
  int v1; // eax@1
  int v2; // eax@2
  unsigned int v3; // ebp@4
  int v4; // edx@5
  char *v5; // esi@6
  int v6; // edi@7
  __int16 v7; // cx@8
  int v9; // [sp+0h] [bp-88h]@4
  __int64 v10; // [sp+8h] [bp-80h]@16
  char v11; // [sp+10h] [bp-78h]@12

  LOBYTE(v1) = sub_100165F0(this);
  if ( (_BYTE)v1 )
  {
    v2 = sub_10060900();
    if ( (unsigned int)(v2 - dword_107FD824) > 0x2EE0 )
    {
      dword_107FD824 = v2;
      dword_107FE2C8 = 0;
      dword_107FE2CC = 0;
      dword_107FE2D0 = 0;
      word_107FE2D4 = 0;
    }
    v9 = 0;
    v3 = 0;
    while ( 1 )
    {
      LOBYTE(v1) = sub_100169B0(byte_1009D630[v3]);
      if ( !(_BYTE)v1 )
        goto LABEL_19;
      v1 = *((_BYTE *)&dword_107FE2C8 + v4);
      v5 = *(char **)((char *)&off_1009D638 + v3) + 4 * v1;
      if ( *(_WORD *)v5 >= 0x388u )
        goto LABEL_19;
      v6 = sub_10016820(v4);
      LOBYTE(v1) = sub_1002DB40(*(_WORD *)v5);
      if ( !v6 )
      {
        LOBYTE(v1) = sub_10016340(v1);
        goto LABEL_18;
      }
      v7 = *((_WORD *)v5 + 1);
      if ( (unsigned __int16)v7 >= 0x4Cu )
      {
        if ( (unsigned __int8)v1 < 0xB0u && (unsigned __int8)byte_107FE388[(unsigned __int8)v1] < 4u )
        {
          v10 = 1095216660480i64;
          LODWORD(v10) = *(_WORD *)v5;
          sub_10015560(2, 0, &v10, 0, 8, 1);
          LOBYTE(v1) = sub_10015710(2, 0, v6);
        }
        goto LABEL_18;
      }
      if ( (unsigned __int8)v1 < 0xB0u )
        break;
      LOBYTE(v1) = sub_10030E90(byte_1009D630[v3], v7, &v11);
      if ( !(_BYTE)v1 )
        goto LABEL_13;
LABEL_18:
      v4 = v9;
      ++*((_BYTE *)&dword_107FE2C8 + v4);
LABEL_19:
      v3 += 12;
      v9 = v4 + 1;
      if ( v3 >= 0xA8 )
        return v1;
    }
    if ( (unsigned __int8)byte_107FE388[(unsigned __int8)v1] >= 4u )
      goto LABEL_18;
LABEL_13:
    LOBYTE(v1) = sub_10030C70(byte_1009D630[v3], 1u, (int)(v5 + 2), v6);
    goto LABEL_18;
  }
  return v1;
}
// 1009D638: using guessed type void *off_1009D638;
// 107FD824: using guessed type int dword_107FD824;
// 107FE2C8: using guessed type int dword_107FE2C8;
// 107FE2CC: using guessed type int dword_107FE2CC;
// 107FE2D0: using guessed type int dword_107FE2D0;
// 107FE2D4: using guessed type __int16 word_107FE2D4;

//----- (10016C30) --------------------------------------------------------
char __cdecl sub_10016C30(int a1, int a2)
{
  char result; // al@1
  unsigned __int16 v3; // si@2
  char v4; // al@3
  char v5; // ST18_1@4
  __int16 v6; // [sp+4h] [bp-4E8h]@1
  unsigned __int8 v7; // [sp+8h] [bp-4E4h]@1
  char v8[1239]; // [sp+Dh] [bp-4DFh]@3
  char v9; // [sp+4E4h] [bp-8h]@1
  char v10; // [sp+4E6h] [bp-6h]@2

  memset(&v6, 0, 0x4E4u);
  v6 = -32709;
  result = sub_100144D0(a1, a2, &v7, (unsigned __int16 *)&v9);
  if ( result )
  {
    v3 = 0;
    v10 = 1;
    if ( v7 )
    {
      do
      {
        v4 = v8[124 * v3];
        if ( (unsigned __int8)v4 < 0xB0u )
        {
          v5 = v8[124 * v3];
          byte_107FE2D8[(unsigned __int8)v4] = 1;
          if ( (unsigned __int8)sub_10016800(v5) < 0xEu )
            v10 = 0;
        }
        ++v3;
      }
      while ( v3 < v7 );
    }
    result = sub_1002CC40((int)&v6);
  }
  return result;
}
// 10016C30: using guessed type char var_4DF[1239];

//----- (10016D00) --------------------------------------------------------
char sub_10016D00()
{
  char v0; // si@2
  signed int v1; // eax@2
  void *v2; // ecx@2
  int v3; // eax@4
  int v4; // eax@4
  char *v5; // esi@4
  int v6; // eax@5
  int v7; // eax@5
  char *v8; // ebx@6
  _DWORD *v9; // edi@8
  char v10; // al@9
  signed int v11; // ebp@12
  signed int v12; // esi@14
  int v13; // eax@18
  int v14; // esi@20
  int v15; // eax@20
  signed int v16; // esi@26
  int v17; // edi@26
  int v18; // eax@28
  int v19; // eax@29
  char v20; // dl@29
  int v21; // eax@29
  char v22; // dl@29
  int v23; // eax@29
  char v24; // dl@29
  int v25; // eax@29
  int v26; // eax@30
  char v27; // dl@30
  int v28; // eax@31
  int v29; // eax@32
  char v30; // dl@32
  int v31; // eax@32
  char v32; // dl@32
  int v33; // eax@32
  char v34; // dl@32
  int v35; // eax@32
  int v36; // eax@33
  char v37; // dl@33
  int v38; // eax@34
  int v39; // eax@35
  int v40; // eax@36
  char v41; // dl@36
  int v42; // eax@37
  int v43; // eax@38
  int v44; // eax@39
  char v45; // dl@39
  unsigned __int8 v46; // bl@41
  char v47; // di@42
  int v48; // eax@42
  int v49; // eax@43
  int v50; // eax@43
  signed int v51; // esi@43
  int v52; // eax@44
  int v53; // eax@47
  char v54; // dl@47
  int v55; // eax@47
  char v56; // dl@47
  char *v57; // esi@47
  int v58; // eax@48
  int v59; // eax@50
  char v60; // dl@50
  int v61; // eax@50
  char v62; // dl@50
  char *v63; // esi@50
  int v64; // eax@51
  int v65; // eax@53
  char v66; // dl@53
  int v67; // eax@53
  char v68; // dl@53
  char *v69; // esi@53
  int v70; // eax@54
  int v71; // eax@56
  char v72; // dl@56
  int v73; // eax@56
  char v74; // dl@56
  int v75; // eax@63
  char v76; // dl@63
  int v77; // eax@63
  char v78; // dl@63
  int v79; // eax@65
  char v80; // dl@65
  int v81; // eax@65
  char v82; // dl@65
  int v83; // eax@65
  char v84; // dl@65
  int v85; // eax@65
  char v86; // dl@65
  int v87; // eax@67
  char v88; // dl@67
  int v89; // eax@67
  char v90; // dl@67
  int v91; // eax@69
  char v92; // dl@69
  int v93; // eax@69
  char v94; // dl@69
  int v95; // eax@71
  char v96; // dl@71
  int v97; // eax@71
  char v98; // dl@71
  int v99; // eax@73
  char v100; // dl@73
  int v101; // eax@73
  char v102; // dl@73
  unsigned __int8 v103; // bl@74
  void **v104; // esi@74
  signed int v105; // ebp@74
  int v106; // eax@75
  int v107; // edi@76
  __int16 v108; // ax@78
  int v109; // eax@79
  int v111; // [sp+10h] [bp-290h]@1
  int v112; // [sp+14h] [bp-28Ch]@1
  _WORD *v113; // [sp+18h] [bp-288h]@1
  int v114; // [sp+1Ch] [bp-284h]@1
  int v115; // [sp+20h] [bp-280h]@44
  char v116; // [sp+24h] [bp-27Ch]@1
  char v117; // [sp+94h] [bp-20Ch]@21
  char v118; // [sp+98h] [bp-208h]@56
  char v119; // [sp+F2h] [bp-1AEh]@56
  char v120; // [sp+FEh] [bp-1A2h]@58

  memset(byte_107FD828, 0, 0xAA0u);
  memset(&unk_107FE438, 0, 0x890u);
  v111 = 0;
  memset(&v116, 0, 0x74u);
  memset(dword_107FD820, 0, 0xB0u);
  dword_107FD808[0] = 0;
  dword_107FD80C = 0;
  dword_107FD810 = 0;
  dword_107FD814 = 0;
  dword_107FD818[0] = 0;
  dword_107FD81C = 0;
  sub_10038790((int)&v111);
  LOBYTE(v114) = 0;
  v112 = 0;
  v113 = &unk_1009D6EC;
  do
  {
    v0 = v114;
    v1 = sub_10031B80(v114);
    if ( v1 & v111 || sub_1002C5E0(v2) == 4 )
    {
      LOBYTE(v3) = sub_10031BC0(v0);
      sub_10016A10(v3, 1);
      LOBYTE(v4) = sub_10031B00(v0);
      sub_10016A10(v4, 1);
      sub_100386E0(v0, (int)byte_107FD828);
      v5 = (char *)&unk_107FDB00;
      do
      {
        LOBYTE(v6) = sub_10031C90(*v5);
        v7 = sub_10016A10(v6, 1);
        v5 += 4;
      }
      while ( (signed int)v5 < (signed int)&unk_107FDB20 );
      v8 = (char *)&unk_107FDB20;
      do
      {
        if ( *v8 == 4 )
        {
          LOBYTE(v7) = *((_BYTE *)v113 - 8);
          v7 = sub_10016A10(v7, 1);
          v9 = &unk_1009D6F8;
          do
          {
            v10 = byte_107FD828[*v9];
            if ( v10 && v10 != 4 && v10 != 6 )
            {
              v11 = 1;
              if ( v10 == 3 )
                v11 = 2;
              v12 = 0;
              do
              {
                LOBYTE(v7) = *((_BYTE *)v9 + v12 + 4);
                v7 = sub_10016A10(v7, 1);
                v12 += v11;
              }
              while ( v12 < 4 );
            }
            v9 += 2;
          }
          while ( (signed int)v9 < (signed int)dword_1009D728 );
        }
        else
        {
          LOBYTE(v13) = sub_10031CB0(*v8);
          v7 = sub_10016A10(v13, 1);
        }
        v8 += 8;
      }
      while ( (signed int)v8 < (signed int)&unk_107FDB48 );
      v14 = (int)v113;
      if ( sub_100144B0(*v113, (int)&byte_10A08A80, &v116) == 1 )
      {
        if ( v117 & 1 )
        {
          LOBYTE(v15) = *(_BYTE *)(v14 - 7);
          v15 = sub_10016A10(v15, 1);
        }
        if ( v117 & 2 )
        {
          LOBYTE(v15) = *(_BYTE *)(v14 - 6);
          v15 = sub_10016A10(v15, 1);
        }
        if ( v117 & 8 )
        {
          v16 = 0;
          v17 = 5 * v112;
          do
          {
            LOBYTE(v15) = *(&byte_1009D6E7[2 * v17] + v16);
            v15 = sub_10016A10(v15, 1);
            ++v16;
          }
          while ( v16 < 4 );
        }
      }
      if ( sub_100169B0(0x11u) )
      {
        LOBYTE(v18) = 21;
        v19 = sub_10016A10(v18, 1);
        LOBYTE(v19) = 32;
        v21 = sub_10016A10(v19, v20);
        LOBYTE(v21) = 31;
        v23 = sub_10016A10(v21, v22);
        LOBYTE(v23) = 33;
        sub_10016A10(v23, v24);
        if ( sub_10030B40(39) )
        {
          LOBYTE(v25) = -121;
          v26 = sub_10016A10(v25, 1);
          LOBYTE(v26) = -119;
          sub_10016A10(v26, v27);
        }
      }
      if ( sub_100169B0(0x12u) )
      {
        LOBYTE(v28) = 22;
        v29 = sub_10016A10(v28, 1);
        LOBYTE(v29) = 36;
        v31 = sub_10016A10(v29, v30);
        LOBYTE(v31) = 35;
        v33 = sub_10016A10(v31, v32);
        LOBYTE(v33) = 37;
        sub_10016A10(v33, v34);
        if ( sub_10030B40(40) )
        {
          LOBYTE(v35) = -120;
          v36 = sub_10016A10(v35, 1);
          LOBYTE(v36) = -118;
          sub_10016A10(v36, v37);
        }
      }
      if ( sub_100169B0(0x13u) )
      {
        LOBYTE(v38) = 30;
        sub_10016A10(v38, 1);
        if ( sub_10030B40(36) )
        {
          LOBYTE(v39) = 123;
          v40 = sub_10016A10(v39, 1);
          LOBYTE(v40) = 124;
          sub_10016A10(v40, v41);
        }
      }
      if ( sub_100169B0(0x14u) )
      {
        LOBYTE(v42) = 34;
        sub_10016A10(v42, 1);
        if ( sub_10030B40(37) )
        {
          LOBYTE(v43) = 125;
          v44 = sub_10016A10(v43, 1);
          LOBYTE(v44) = 126;
          sub_10016A10(v44, v45);
        }
      }
    }
    ++v112;
    v113 += 5;
    LOBYTE(v114) = v114 + 1;
  }
  while ( (unsigned __int8)v114 < 2u );
  v46 = 0;
  LOBYTE(v112) = 0;
  do
  {
    v47 = v112;
    v48 = sub_1002D710(v112);
    if ( v48 & v111 )
    {
      LOBYTE(v49) = sub_1002D790(v47);
      sub_10016A10(v49, 1);
      LOBYTE(v50) = sub_1002D6A0(v47);
      sub_10016A10(v50, 1);
      v51 = 0;
      do
      {
        sub_10030120(v47, v51, (int)&v115);
        LOBYTE(v52) = sub_1002DAE0(v115);
        v48 = sub_10016A10(v52, 1);
        ++v51;
      }
      while ( v51 < 2 );
    }
    LOBYTE(v112) = ++v46;
  }
  while ( v46 < 3u );
  if ( v111 & 0x1000 )
  {
    LOBYTE(v48) = 79;
    v53 = sub_10016A10(v48, 1);
    LOBYTE(v53) = -86;
    v55 = sub_10016A10(v53, v54);
    LOBYTE(v55) = -83;
    sub_10016A10(v55, v56);
    sub_10038760(0, (int)&unk_107FE438);
    v57 = (char *)&unk_107FE7A8;
    do
    {
      LOBYTE(v58) = sub_10031AA0(*v57);
      v48 = sub_10016A10(v58, 1);
      v57 += 8;
    }
    while ( (signed int)v57 < (signed int)&unk_107FE828 );
  }
  if ( v111 & 0x2000 )
  {
    LOBYTE(v48) = 80;
    v59 = sub_10016A10(v48, 1);
    LOBYTE(v59) = -85;
    v61 = sub_10016A10(v59, v60);
    LOBYTE(v61) = -82;
    sub_10016A10(v61, v62);
    sub_10038760(1, (int)&unk_107FE438);
    v63 = (char *)&unk_107FE7A8;
    do
    {
      LOBYTE(v64) = sub_10031AA0(*v63);
      v48 = sub_10016A10(v64, 1);
      v63 += 8;
    }
    while ( (signed int)v63 < (signed int)&unk_107FE828 );
  }
  if ( v111 & 0x80000 )
  {
    LOBYTE(v48) = -117;
    v65 = sub_10016A10(v48, 1);
    LOBYTE(v65) = -84;
    v67 = sub_10016A10(v65, v66);
    LOBYTE(v67) = -81;
    sub_10016A10(v67, v68);
    sub_10038760(2, (int)&unk_107FE438);
    v69 = (char *)&unk_107FE7A8;
    do
    {
      LOBYTE(v70) = sub_10031AA0(*v69);
      v48 = sub_10016A10(v70, 1);
      v69 += 8;
    }
    while ( (signed int)v69 < (signed int)&unk_107FE828 );
  }
  if ( v111 & 0x8000 )
  {
    LOBYTE(v48) = 82;
    v71 = sub_10016A10(v48, 1);
    LOBYTE(v71) = 85;
    v73 = sub_10016A10(v71, v72);
    LOBYTE(v73) = 86;
    sub_10016A10(v73, v74);
    sub_10060E00(6444, (int)&v118, 514);
    if ( v119 == 1 )
    {
      LOBYTE(v48) = 83;
      v48 = sub_10016A10(v48, 1);
    }
    if ( v120 == 1 )
    {
      LOBYTE(v48) = 84;
      v48 = sub_10016A10(v48, 1);
    }
  }
  if ( v111 & 0x800 )
  {
    LOBYTE(v48) = 71;
    v48 = sub_10016A10(v48, 1);
  }
  if ( v111 & 0x400 )
  {
    LOBYTE(v48) = 69;
    v75 = sub_10016A10(v48, 1);
    LOBYTE(v75) = 70;
    v77 = sub_10016A10(v75, v76);
    LOBYTE(v77) = 92;
    v48 = sub_10016A10(v77, v78);
  }
  if ( v111 & 0x4000 )
  {
    LOBYTE(v48) = 87;
    v79 = sub_10016A10(v48, 1);
    LOBYTE(v79) = 88;
    v81 = sub_10016A10(v79, v80);
    LOBYTE(v81) = 89;
    v83 = sub_10016A10(v81, v82);
    LOBYTE(v83) = 90;
    v85 = sub_10016A10(v83, v84);
    LOBYTE(v85) = 91;
    v48 = sub_10016A10(v85, v86);
  }
  if ( v111 & 0x40 )
  {
    LOBYTE(v48) = -128;
    v87 = sub_10016A10(v48, 1);
    LOBYTE(v87) = -127;
    v89 = sub_10016A10(v87, v88);
    LOBYTE(v89) = -126;
    v48 = sub_10016A10(v89, v90);
  }
  if ( v111 & 0x80 )
  {
    LOBYTE(v48) = -125;
    v91 = sub_10016A10(v48, 1);
    LOBYTE(v91) = -124;
    v93 = sub_10016A10(v91, v92);
    LOBYTE(v93) = -123;
    v48 = sub_10016A10(v93, v94);
  }
  if ( v111 & 0x10 )
  {
    LOBYTE(v48) = -110;
    v95 = sub_10016A10(v48, 1);
    LOBYTE(v95) = -109;
    v97 = sub_10016A10(v95, v96);
    LOBYTE(v97) = -108;
    v48 = sub_10016A10(v97, v98);
  }
  if ( v111 & 0x20 )
  {
    LOBYTE(v48) = -107;
    v99 = sub_10016A10(v48, 1);
    LOBYTE(v99) = -106;
    v101 = sub_10016A10(v99, v100);
    LOBYTE(v101) = -105;
    sub_10016A10(v101, v102);
  }
  v103 = 0;
  v104 = &off_1009D638;
  v105 = 14;
  do
  {
    LOBYTE(v106) = sub_10016640(v103);
    if ( (_BYTE)v106 )
    {
      v107 = 0;
      if ( *(_WORD *)*v104 < 0x388u )
      {
        v106 = 0;
        do
        {
          v108 = *(_WORD *)((char *)*v104 + v106);
          if ( v108 != 348 )
          {
            v109 = sub_1002DB40(v108);
            sub_10016A10(v109, 1);
          }
          v106 = 4 * ++v107;
        }
        while ( *((_WORD *)*v104 + 2 * v107) < 0x388u );
      }
    }
    ++v103;
    v104 += 3;
    --v105;
  }
  while ( v105 );
  return v106;
}
// 1009D638: using guessed type void *off_1009D638;
// 1009D728: using guessed type int dword_1009D728[];
// 107FD808: using guessed type int dword_107FD808[];
// 107FD80C: using guessed type int dword_107FD80C;
// 107FD810: using guessed type int dword_107FD810;
// 107FD814: using guessed type int dword_107FD814;
// 107FD818: using guessed type int dword_107FD818[];
// 107FD81C: using guessed type int dword_107FD81C;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10017350) --------------------------------------------------------
char __usercall sub_10017350@<al>(int a1@<edx>, _DWORD *a2@<ecx>, int a3@<esi>)
{
  char result; // al@1
  unsigned int v4; // eax@2
  _DWORD *v5; // edx@3

  result = 1;
  if ( *(_BYTE *)(a3 + 5) < 0x10u )
  {
    v4 = 0;
    *a2 = 0;
    if ( *(_BYTE *)(a3 + 5) )
    {
      v5 = (_DWORD *)(a1 + 14);
      do
      {
        *a2 += *v5;
        ++v4;
        v5 = (_DWORD *)((char *)v5 + 6);
      }
      while ( v4 < *(_BYTE *)(a3 + 5) );
    }
    *a2 += 1200 * *(_WORD *)(a3 + 2);
    result = 0;
  }
  return result;
}

//----- (100173A0) --------------------------------------------------------
int __usercall sub_100173A0@<eax>(int result@<eax>, unsigned int a2@<edx>, __int16 a3@<si>)
{
  unsigned int v3; // ecx@2

  if ( result && (a2 = (unsigned __int8)a2, v3 = 0, (_BYTE)a2) )
  {
    while ( *(_BYTE *)(result + 8) != a3 )
    {
      ++v3;
      result += 156;
      if ( v3 >= a2 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (100173D0) --------------------------------------------------------
char __fastcall sub_100173D0(int a1, int a2)
{
  char result; // al@1
  unsigned __int8 v3; // cl@1

  result = 1;
  v3 = 0;
  while ( !*(_WORD *)(a2 + 2 * v3 + 114) )
  {
    if ( ++v3 >= 0x10u )
      goto LABEL_6;
  }
  result = 0;
LABEL_6:
  if ( *(_BYTE *)(a2 + 11) )
    result = 0;
  return result;
}

//----- (10017400) --------------------------------------------------------
char __usercall sub_10017400@<al>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  int v3; // ebp@1
  unsigned __int16 v4; // ax@1
  unsigned __int16 v5; // bx@4
  __int16 v6; // ax@8
  int v7; // ecx@12
  int v9; // eax@16
  size_t v10; // eax@22
  int v11; // ecx@24
  char v12; // [sp+Fh] [bp-9h]@1
  unsigned __int16 v13; // [sp+10h] [bp-8h]@1
  int v14; // [sp+14h] [bp-4h]@1

  v2 = a1;
  v3 = *(_BYTE *)(a1 + 5);
  v4 = *(_WORD *)(a2 + 2 * (3 * v3 + 6));
  v13 = *(_WORD *)(a2 + 2 * (3 * v3 + 6));
  v14 = 0;
  v12 = 0;
  if ( !a2 )
    return 1;
  if ( *(_WORD *)(a2 + 108) != *(_WORD *)v2 )
    return 1;
  if ( *(_BYTE *)(a2 + 113) != *(_BYTE *)(v2 + 4) )
    return 1;
  v5 = *(_WORD *)(v2 + 2);
  if ( v5 >= v4
    || sub_10017350(a2, &v14, v2)
    || (unsigned int)(v14 + 1200) > *(_DWORD *)(a2 + 4)
    || *(_BYTE *)(v2 + 5) >= 0x10u )
  {
    return 1;
  }
  v6 = *(_WORD *)(a2 + 146);
  if ( v6 < 0 )
  {
    v9 = v13 - *(_WORD *)(a2 + 2 * v3 + 114);
    if ( v5 == v9 )
      goto LABEL_21;
    if ( v5 < v9 )
      return 0;
    if ( v5 - 1 == v9 )
    {
      *(_WORD *)(a2 + 146) = v5 - 1;
      *(_BYTE *)(a2 + 148) = *(_BYTE *)(v2 + 5);
      *(_BYTE *)(a2 + 149) = 1;
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if ( *(_BYTE *)(a2 + 148) == v3 )
  {
    if ( v6 == v5 )
    {
      *(_WORD *)(a2 + 2 * *(_BYTE *)(v2 + 5) + 114) -= *(_BYTE *)(a2 + 149);
      *(_WORD *)(a2 + 146) = -1;
      *(_BYTE *)(a2 + 148) = -1;
      *(_BYTE *)(a2 + 149) = 0;
      goto LABEL_21;
    }
    v7 = *(_BYTE *)(a2 + 149) - *(_WORD *)(a2 + 2 * v3 + 114) + v13 + 1;
    if ( v5 == v7 )
    {
      ++*(_BYTE *)(a2 + 149);
      goto LABEL_21;
    }
    if ( v5 < v7 )
      return 0;
LABEL_20:
    *(_BYTE *)(a2 + 11) = 1;
  }
LABEL_21:
  if ( *(_WORD *)(v2 + 2) == v13 - 1 )
    v10 = *(_DWORD *)(a2 + 6 * *(_BYTE *)(v2 + 5) + 14) - 1200 * (v13 - 1);
  else
    v10 = 1200;
  memcpy((void *)(v14 + *(_DWORD *)a2), (const void *)(v2 + 6), v10);
  if ( *(_WORD *)(a2 + 146) < 0 || *(_BYTE *)(a2 + 148) != *(_BYTE *)(v2 + 5) )
  {
    v11 = *(_BYTE *)(v2 + 5);
    --*(_WORD *)(a2 + 2 * v11 + 114);
  }
  if ( sub_100173D0(v11, a2) )
    *(_BYTE *)(a2 + 10) = 1;
  else
    *(_BYTE *)(a2 + 10) = 0;
  *(_BYTE *)(a2 + 9) = 1;
  if ( *(_WORD *)(a2 + 2 * *(_BYTE *)(v2 + 5) + 114) != -1 )
    return v12;
  *(_BYTE *)(a2 + 10) = 0;
  sub_10028BC0("..\\lib\\acl\\iop\\wx\\iop_ptp_client.c", 684, 0, 0);
  return 1;
}

//----- (10017600) --------------------------------------------------------
char __usercall sub_10017600@<al>(int a1@<edx>, char *a2)
{
  unsigned int v2; // esi@1
  char result; // al@1
  int v4; // ecx@4
  unsigned __int64 v5; // kr18_8@5
  char *v6; // ecx@8
  _WORD *v7; // eax@8
  signed int v8; // esi@8
  signed int v9; // [sp+4h] [bp-Ch]@4
  unsigned int v10; // [sp+8h] [bp-8h]@1

  v2 = 0;
  result = 1;
  v10 = 0;
  if ( a1 && a2 && *(_DWORD *)a1 )
  {
    v4 = (int)(a2 + 14);
    v9 = 4;
    do
    {
      v5 = *(_DWORD *)v4
         + *(_DWORD *)(v4 - 6)
         + (unsigned __int64)*(_DWORD *)(v4 - 12)
         + *(_DWORD *)(v4 + 6)
         + __PAIR__(v2, v10);
      v2 = v5 >> 32;
      v10 = v5;
      v4 += 24;
      --v9;
    }
    while ( v9 );
    if ( v2 || (unsigned int)v5 >= *(_DWORD *)(a1 + 4) )
    {
      result = 1;
    }
    else
    {
      qmemcpy((void *)(a1 + 12), a2, 0x66u);
      v6 = a2;
      v7 = (_WORD *)(a1 + 114);
      v8 = 16;
      do
      {
        *v7 = *(_WORD *)v6;
        ++v7;
        v6 += 6;
        --v8;
      }
      while ( v8 );
      result = 0;
      *(_BYTE *)(a1 + 10) = 0;
      *(_BYTE *)(a1 + 11) = 0;
      *(_BYTE *)(a1 + 149) = 0;
      *(_WORD *)(a1 + 146) = -1;
      *(_BYTE *)(a1 + 148) = -1;
      *(_BYTE *)(a1 + 9) = 1;
    }
  }
  return result;
}

//----- (100176E0) --------------------------------------------------------
char __cdecl sub_100176E0(int a1, char a2, int a3, char a4)
{
  int v4; // eax@5
  char result; // al@6
  int v6; // edi@8

  if ( a1 && a3 )
  {
    if ( a4 )
    {
      if ( a4 == 1 )
      {
        v6 = sub_100173A0(a1, a2, *(_BYTE *)(a3 + 4));
        if ( v6 )
          result = sub_10017400(a3, v6);
        else
          result = 1;
      }
      else
      {
        result = 1;
      }
    }
    else if ( *(_BYTE *)(a3 + 100) || (v4 = sub_100173A0(a1, a2, *(_BYTE *)(a3 + 101))) == 0 )
    {
      result = 1;
    }
    else
    {
      result = sub_10017600(v4, (char *)a3);
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10017770) --------------------------------------------------------
int __thiscall sub_10017770(void *this)
{
  int v1; // edi@1
  int v2; // ecx@1
  char v3; // al@1
  int v4; // esi@2
  int result; // eax@16

  v1 = sub_1002C660(this);
  v3 = v1 | j_HWM_pvg_hsdb_get_lrus_online(v2);
  if ( v3 & 0x40 )
  {
    v4 = 64;
  }
  else if ( v3 >= 0 )
  {
    if ( v3 & 0x10 )
    {
      v4 = 16;
    }
    else if ( v3 & 0x20 )
    {
      v4 = 32;
    }
    else if ( v3 & 4 )
    {
      v4 = 4;
    }
    else
    {
      v4 = ((v3 & 1) != 1) + 1;
    }
  }
  else
  {
    v4 = 128;
  }
  if ( dword_107FECC8 != v4 && v1 == dword_107FECC8 && sub_10026B50() )
    sub_10028BC0("..\\lib\\adl\\iop_sms.c", 316, 0, 0);
  result = v4;
  dword_107FECC8 = v4;
  return result;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 107FECC8: using guessed type int dword_107FECC8;

//----- (10017840) --------------------------------------------------------
char sub_10017840()
{
  char result; // al@1
  char v1; // bl@2
  int v2; // esi@2
  int v3; // esi@4
  char v4; // [sp+0h] [bp-Ch]@1
  int v5; // [sp+4h] [bp-8h]@2

  result = sub_100144B0(415, (int)&byte_10A08A80, &v4);
  if ( result )
  {
    v1 = v4;
    v2 = v5;
    if ( sub_10060A60(36, 300) )
      sub_10028BC0("..\\lib\\adl\\iop_sms.c", 425, 0, 0);
    v3 = 12 * (v2 + (unsigned __int8)v1);
    *(_BYTE *)(v3 + dword_107FECCC + 8) = 0;
    *(_DWORD *)(v3 + dword_107FECCC + 4) = sub_10060900();
    result = sub_10060A00(36);
  }
  return result;
}
// 107FECCC: using guessed type int dword_107FECCC;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (100178E0) --------------------------------------------------------
char sub_100178E0()
{
  int v0; // eax@1
  int v1; // eax@3
  __int16 v3; // [sp+0h] [bp-10h]@1
  unsigned __int8 v4; // [sp+4h] [bp-Ch]@3
  int v5; // [sp+8h] [bp-8h]@3

  LOBYTE(v0) = sub_100144B0(416, (int)&byte_10A08A80, &v3);
  if ( (_BYTE)v0 )
  {
    v0 = sub_10060A60(36, 300);
    if ( !v0 )
    {
      v1 = v5 + v4;
      *(_BYTE *)(dword_107FECCC + 12 * (v4 + v5) + 8) = 1;
      *(_WORD *)(dword_107FECCC + 12 * v1) = v3;
      LOBYTE(v0) = sub_10060A00(36);
    }
  }
  return v0;
}
// 107FECCC: using guessed type int dword_107FECCC;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10017970) --------------------------------------------------------
char sub_10017970()
{
  void *v0; // ecx@1
  int v1; // esi@1
  void *v2; // ecx@1
  int v3; // eax@1
  unsigned __int8 v4; // bl@2
  bool v5; // dl@3
  int v6; // eax@4
  char v7; // cl@4
  int v8; // edx@13
  __int16 *v9; // eax@13
  int v11; // [sp-4h] [bp-1C4h]@2
  char v12; // [sp+8h] [bp-1B8h]@27
  char v13; // [sp+9h] [bp-1B7h]@19
  char v14; // [sp+Ah] [bp-1B6h]@1
  char v15; // [sp+Bh] [bp-1B5h]@1
  __int16 v16; // [sp+Ch] [bp-1B4h]@2
  char v17; // [sp+Eh] [bp-1B2h]@2
  char v18; // [sp+13h] [bp-1ADh]@23
  char v19; // [sp+14h] [bp-1ACh]@2
  char v20; // [sp+18h] [bp-1A8h]@3
  unsigned __int8 v21; // [sp+19h] [bp-1A7h]@13
  char v22; // [sp+1Ah] [bp-1A6h]@3
  __int16 v23; // [sp+1Bh] [bp-1A5h]@13
  char v24; // [sp+1Dh] [bp-1A3h]@16
  char v25; // [sp+2Fh] [bp-191h]@19
  unsigned __int8 v26; // [sp+30h] [bp-190h]@22
  unsigned int v27; // [sp+31h] [bp-18Fh]@21
  __int16 v28; // [sp+35h] [bp-18Bh]@21
  char v29; // [sp+37h] [bp-189h]@8
  char v30[168]; // [sp+38h] [bp-188h]@4
  char v31; // [sp+E0h] [bp-E0h]@2
  char v32; // [sp+E2h] [bp-DEh]@2
  char v33; // [sp+E3h] [bp-DDh]@2
  char v34; // [sp+E4h] [bp-DCh]@21
  char v35[51]; // [sp+E8h] [bp-D8h]@5
  char v36; // [sp+11Bh] [bp-A5h]@22

  v15 = 0;
  sub_10060E40(3043, &v14, 1, &v15);
  v1 = sub_1002C660(v0);
  v3 = sub_10017770(v2);
  if ( v1 != v3 )
    return v3;
  v16 = 0;
  v17 = 0;
  memset(&v31, 0, 0xDCu);
  v32 = 2;
  v33 = -1;
  v4 = 0;
  LOBYTE(v3) = sub_100144B0(414, (int)&byte_10A08A80, &v19);
  if ( !(_BYTE)v3 )
    return v3;
  v5 = v20 == 0;
  if ( v22 == -128 )
  {
    do
    {
      v6 = v4;
      v7 = v30[v4++];
      if ( v7 == 32 )
        break;
      v35[v6] = v7;
    }
    while ( v4 < 0x33u );
    if ( !v5 || !v4 || *(&v29 + v4) != 32 )
      goto LABEL_20;
    v32 = 1;
  }
  else
  {
    if ( (v22 & 0xF0 | 1) == 129 )
    {
      v16 = v23;
      v17 = 0;
      if ( v20 || sub_1002C170("00", &v16, 3) )
        goto LABEL_20;
      v8 = v21 - 1;
      v9 = (__int16 *)&v24;
    }
    else
    {
      if ( (v22 & 0xF0 | 1) != 145 || v20 )
        goto LABEL_20;
      v8 = v21 + 1;
      v9 = &v23;
    }
    if ( sub_1002C120((int)v35, v9, v8) == -1 )
    {
LABEL_20:
      v13 = 0;
      goto LABEL_21;
    }
    v32 = 0;
  }
  v13 = 1;
  if ( v25 != 3 )
    goto LABEL_20;
LABEL_21:
  LOWORD(v11) = v28;
  BYTE2(v11) = v29;
  sub_10022BC0((int *)&v34, v27, v11);
  if ( !v13
    || sub_1002C120((int)&v36, &v30[v4], v26 - v4 + 1) == -1
    || (v31 = 0, LOBYTE(v3) = sub_10026530((int)&v31, (int)&v18), (_BYTE)v3) && (_BYTE)v3 != 17 )
  {
    LOBYTE(v3) = sub_10028BC0("..\\lib\\adl\\iop_sms.c", 694, 0, 0);
  }
  else if ( !v14 )
  {
    v3 = sub_10060A60(36, 300);
    if ( !v3 )
    {
      sub_10060EB0(41000, (int)&v12, 1);
      ++v12;
      sub_10060ED0(41000, (int)&v12, 1);
      LOBYTE(v3) = sub_10060A00(36);
    }
  }
  return v3;
}
// 10A08A80: using guessed type char byte_10A08A80;
// 10017970: using guessed type char var_188[168];
// 10017970: using guessed type char var_D8[51];

//----- (10017C00) --------------------------------------------------------
char sub_10017C00()
{
  char v0; // bl@1
  char result; // al@1
  char v2; // [sp+7h] [bp-1C5h]@2
  int v3; // [sp+8h] [bp-1C4h]@1
  char v4[4]; // [sp+Ch] [bp-1C0h]@15
  char v5; // [sp+10h] [bp-1BCh]@2
  char v6[5]; // [sp+13h] [bp-1B9h]@16
  char v7; // [sp+ECh] [bp-E0h]@20

  v0 = 9;
  result = sub_100144B0(417, (int)&byte_10A08A80, &v3);
  if ( result )
  {
    result = sub_10026830(v3, (int)&v2, (int)&v5);
    if ( !result )
    {
      if ( SHIWORD(v3) == -996 )
      {
        if ( v5 != 4 )
          sub_10028BC0("..\\lib\\adl\\iop_sms.c", 786, 0, 0);
      }
      else if ( SHIWORD(v3) == -994 )
      {
        if ( v5 != 4 )
          sub_10028BC0("..\\lib\\adl\\iop_sms.c", 765, 0, 0);
        v5 = 5;
      }
      else if ( HIWORD(v3) )
      {
        v5 = 6;
        v0 = 2;
      }
      else
      {
        if ( v5 != 5 )
          sub_10028BC0("..\\lib\\adl\\iop_sms.c", 775, 0, 0);
        v5 = 7;
        v0 = 11;
      }
      if ( sub_10032600(v4) )
        *(_DWORD *)&v6[1] = *(_DWORD *)v4;
      result = sub_100269B0(&v2, 12, (int)&v5);
      if ( v6[0] != -1 && v0 != 9 && v0 != 11 )
      {
        sub_100266B0(v6[0], 12, (int)&v7);
        v7 = v0;
        result = sub_100269B0(v6, 12, (int)&v7);
      }
    }
  }
  return result;
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10017D70) --------------------------------------------------------
signed int sub_10017D70()
{
  dword_107FECC8 = 4;
  dword_107FECCC = -15;
  if ( !sub_10061B70((LONG)&off_1009E1B0) )
    sub_10028BC0("..\\lib\\adl\\iop_sms.c", 359, 1, 0);
  return sub_10061700((int)&off_1009E1B0);
}
// 1009E1B0: using guessed type char *off_1009E1B0;
// 107FECC8: using guessed type int dword_107FECC8;
// 107FECCC: using guessed type int dword_107FECCC;

//----- (10017D90) --------------------------------------------------------
char __cdecl sub_10017D90(__int16 a1)
{
  char result; // al@3

  if ( a1 == 414 )
  {
    result = sub_10017970();
  }
  else if ( a1 == 416 )
  {
    result = sub_100178E0();
  }
  else
  {
    result = a1 + 95;
    if ( a1 == 417 )
      result = sub_10017C00();
  }
  return result;
}

//----- (10017DC0) --------------------------------------------------------
char __cdecl sub_10017DC0(__int16 a1)
{
  char result; // al@2

  if ( a1 == 415 )
    result = sub_10017840();
  return result;
}

//----- (10017DD0) --------------------------------------------------------
void *__fastcall sub_10017DD0(int a1, int a2)
{
  signed int v2; // eax@1
  void *result; // eax@3

  v2 = 0;
  do
  {
    *((_BYTE *)dword_107FECDC + v2 + 44) = 0;
    *(_DWORD *)((char *)dword_107FECDC + v2 + 64) = a2;
    *((_BYTE *)dword_107FECDC + v2 + 45) = 0;
    v2 += 1032;
  }
  while ( v2 < 92880 );
  result = dword_107FECDC;
  *((_BYTE *)dword_107FECDC + 9) = 0;
  *((_DWORD *)dword_107FECDC + 8) = 0;
  return result;
}

//----- (10017E20) --------------------------------------------------------
bool __usercall sub_10017E20@<al>(float a1@<ecx>, int *a2@<esi>)
{
  char v2; // al@4
  int v3; // eax@4
  void *v5; // ecx@9
  float v6; // [sp+0h] [bp-4h]@1

  v6 = a1;
  if ( *((_BYTE *)dword_107FECDC + 24) != 1
    || *((_BYTE *)dword_107FECDC + 19)
    || !(*((_DWORD *)dword_107FECDC + 10) & 0x180000) )
  {
    if ( sub_10034AB0(1, a2) )
      return 1;
    if ( sub_1002BF10(&v6) )
    {
      *a2 = (signed int)(v6 * 57.29578018188477);
      return sub_1002C5E0(v5) == 4;
    }
  }
  else
  {
    *a2 = *((_DWORD *)dword_107FECDC + 5);
    v2 = sub_10062C70();
    *a2 += (signed int)(sub_10062650(v2) * 683565248.0);
    v3 = (*((_DWORD *)dword_107FECDC + 10) >> 19) & 3;
    if ( v3 == 2 || v3 == 3 && sub_10034AB0(1, a2) )
      return 1;
  }
  return 0;
}

//----- (10017ED0) --------------------------------------------------------
void *__thiscall sub_10017ED0(void *this)
{
  void *result; // eax@1

  result = dword_107FECDC;
  if ( *((_DWORD *)dword_107FECDC + 10) & 0x4000000 )
  {
    *((_DWORD *)dword_107FECDC + 5) = *(_DWORD *)this;
    result = dword_107FECDC;
    *((_BYTE *)dword_107FECDC + 24) = 1;
  }
  else
  {
    *((_BYTE *)dword_107FECDC + 24) = 0;
  }
  return result;
}

//----- (10017F00) --------------------------------------------------------
char __usercall sub_10017F00@<al>(int a1@<edi>)
{
  char result; // al@1
  char v2; // dl@2
  _BYTE *v3; // eax@8
  float v4; // ecx@11
  unsigned __int8 v5; // al@13
  int v6; // ebp@15
  int v7; // esi@15
  float v8; // ST00_4@15
  signed int v9; // ST14_4@15
  double v10; // st6@15
  int v11; // eax@15
  int v12; // ecx@15
  signed int *v13; // ebx@15
  double v14; // st7@15
  float v15; // ST00_4@17
  signed int v16; // eax@17
  signed int v17; // edx@17
  double v18; // st6@17
  int v19; // edx@19
  bool v20; // [sp+12h] [bp-2Ah]@1
  unsigned __int8 v21; // [sp+13h] [bp-29h]@13
  int v22; // [sp+18h] [bp-24h]@11
  __int64 v23; // [sp+1Ch] [bp-20h]@15
  __int64 v24; // [sp+24h] [bp-18h]@15
  double v25; // [sp+2Ch] [bp-10h]@11
  double v26; // [sp+34h] [bp-8h]@11

  result = *((_BYTE *)dword_107FECDC + 18);
  v20 = 0;
  if ( result == 1 || (v2 = *((_BYTE *)dword_107FECDC + 41), v2 == 65) || v2 == 68 || v2 == 66 || v2 == 67 )
  {
    if ( !result )
      v20 = *((_BYTE *)dword_107FECDC + 41) == 67;
    sub_10060A60(102, 200);
    v3 = dword_107FECDC;
    if ( !v20 )
    {
      ++*((_BYTE *)dword_107FECDC + 9);
      v3 = dword_107FECDC;
      if ( *((_BYTE *)dword_107FECDC + 9) >= 0x5Au )
      {
        *((_BYTE *)dword_107FECDC + 9) = 0;
        v3 = dword_107FECDC;
      }
    }
    v3[1032 * v3[9] + 44] = 0;
    *((_DWORD *)dword_107FECDC + 258 * *((_BYTE *)dword_107FECDC + 9) + 16) = sub_10060900();
    sub_1002BC40(0, (int)&v25);
    *((double *)dword_107FECDC + 129 * *((_BYTE *)dword_107FECDC + 9) + 6) = v25;
    *((double *)dword_107FECDC + 129 * *((_BYTE *)dword_107FECDC + 9) + 7) = v26;
    LODWORD(v4) = 1032 * *((_BYTE *)dword_107FECDC + 9);
    *((_BYTE *)dword_107FECDC + LODWORD(v4) + 45) = *(_BYTE *)(a1 + 1);
    if ( sub_10017E20(v4, &v22) != 1 )
      v22 = 0;
    v5 = 0;
    v21 = 0;
    if ( *(_BYTE *)a1 )
    {
      do
      {
        if ( v5 < 0x3Fu )
        {
          v6 = v5;
          v7 = 16 * v5;
          *((_DWORD *)dword_107FECDC + 258 * *((_BYTE *)dword_107FECDC + 9) + 4 * v5 + 18) = v22
                                                                                           + *(_DWORD *)(16 * v5 + a1 + 28);
          v8 = (double)*(unsigned int *)(16 * v5 + a1 + 36);
          v9 = sub_100681F0(v8);
          v10 = (double)*(unsigned int *)(v7 + a1 + 36);
          LODWORD(v23) = (unsigned __int16)v9 | 0xC00;
          v11 = 16 * (v6 + 2);
          v12 = *(_DWORD *)(v11 + a1);
          v13 = (signed int *)(v11 + a1);
          v24 = (signed __int64)((double)v9 * 0.5 + v10 * 1852.0);
          v14 = (double)*(signed int *)(v11 + a1);
          if ( v12 < 0 )
            v14 = v14 + 4294967300.0;
          v15 = v14;
          v16 = sub_100681F0(v15);
          v17 = *v13;
          LODWORD(v23) = v16;
          v18 = (double)*v13;
          if ( v17 < 0 )
            v18 = v18 + 4294967300.0;
          *((_DWORD *)dword_107FECDC + 258 * *((_BYTE *)dword_107FECDC + 9) + 4 * (v6 + 5)) = v24;
          v19 = v7 + 1032 * *((_BYTE *)dword_107FECDC + 9);
          v23 = (signed __int64)((double)v16 * 0.5 + v18 * 1852.0);
          *(_DWORD *)((char *)dword_107FECDC + v19 + 76) = v23;
          *((_BYTE *)dword_107FECDC + 1032 * *((_BYTE *)dword_107FECDC + 9) + v7 + 68) = *(_BYTE *)(v7 + a1 + 24);
          ++*((_BYTE *)dword_107FECDC + 1032 * *((_BYTE *)dword_107FECDC + 9) + 44);
          v5 = v21;
        }
        v21 = ++v5;
      }
      while ( v5 < *(_BYTE *)a1 );
    }
    if ( v20 )
      dword_107FECD0 = sub_10060900() + 1000;
    result = sub_10060A00(102);
  }
  return result;
}
// 107FECD0: using guessed type int dword_107FECD0;
// 107FECD8: using guessed type char byte_107FECD8;

//----- (100181B0) --------------------------------------------------------
const void *__usercall sub_100181B0@<eax>(const void *result@<eax>)
{
  qmemcpy((char *)dword_107FECDC + 92924, result, 0x160u);
  return result;
}

//----- (100181D0) --------------------------------------------------------
char __usercall sub_100181D0@<al>(void *a1@<ecx>, char a2@<bl>)
{
  int v2; // eax@8
  int v4; // [sp+0h] [bp-Ch]@1
  int v5; // [sp+4h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  if ( a2 )
  {
    if ( a2 == 4 )
    {
      LOBYTE(v5) = *(_BYTE *)a1;
    }
    else if ( a2 == 6 )
    {
      memcpy_0(&v5, a1, 2u);
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\iop\\strm\\iop_strm_frmt.c", 1548, 1, 0);
    }
  }
  else
  {
    v5 = *(_DWORD *)a1;
  }
  LOBYTE(v4) = a2;
  v2 = sub_10060900();
  sub_10013610(9, 1, (int)&byte_10A08A80, &v4, v2);
  sub_10013C10(9, 0xFFFFFFF, (int)&byte_10A08A80);
  return 1;
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10018280) --------------------------------------------------------
int sub_10018280()
{
  char v0; // al@2
  int v1; // eax@6
  _BYTE *v2; // ecx@6
  unsigned __int8 v3; // dl@6
  int v4; // edx@7
  int v5; // edx@8
  signed int v6; // esi@11
  int v7; // edx@12
  float v9; // [sp+Ch] [bp-10h]@1
  int v10; // [sp+10h] [bp-Ch]@1
  double v11; // [sp+14h] [bp-8h]@4

  v9 = 0.0;
  v10 = 0;
  if ( (*((_DWORD *)dword_107FECDC + 10) & 0x180000) == 1572864 )
  {
    v0 = sub_10062C70();
    if ( !sub_10034AB0(v0, &v10) && sub_1002BF10(&v9) == 1 )
    {
      v11 = v9;
      v9 = v11 - sub_10062650(0);
      sub_100387F0((int)&v10, v9);
    }
    sub_100181D0(&v10, 0);
  }
  sub_10060A60(102, 200);
  v1 = sub_10060900();
  v2 = dword_107FECDC;
  v3 = *((_BYTE *)dword_107FECDC + 9);
  if ( v3 >= 0x59u )
  {
    v4 = 0;
  }
  else
  {
    v4 = v3 + 1;
    if ( v4 >= 90 )
    {
LABEL_11:
      v6 = 0;
      v2[9];
      v7 = 0;
      do
      {
        if ( v1 - *(_DWORD *)&v2[v7 + 64] > 180000 )
        {
          v2[v7 + 44] = 0;
          v2 = dword_107FECDC;
        }
        ++v6;
        v7 += 1032;
      }
      while ( v6 <= v2[9] );
      return sub_10060A00(102);
    }
  }
  v5 = 1032 * v4;
  while ( v1 - *(_DWORD *)&v2[v5 + 64] > 180000 )
  {
    v2[v5 + 44] = 0;
    v2 = dword_107FECDC;
    v5 += 1032;
    if ( v5 >= 92880 )
      goto LABEL_11;
  }
  return sub_10060A00(102);
}

//----- (100183B0) --------------------------------------------------------
int __cdecl sub_100183B0(int a1)
{
  int v1; // ecx@1

  sub_10060A60(102, 200);
  sub_10017DD0(v1, a1);
  return sub_10060A00(102);
}

//----- (100183E0) --------------------------------------------------------
void *sub_100183E0()
{
  int v0; // eax@1
  int v1; // ecx@1

  v0 = sub_10060900();
  return sub_10017DD0(v1, v0);
}

//----- (10018400) --------------------------------------------------------
void *__usercall sub_10018400@<eax>(const void *a1@<esi>)
{
  void *result; // eax@2
  unsigned __int8 v2; // bl@3
  char v3; // al@4

  if ( *((_BYTE *)dword_107FECDC + 18) )
  {
    memcpy_0(dword_107FECDC, a1, 8u);
    v2 = 0;
    while ( 1 )
    {
      v3 = *((_BYTE *)a1 + 8 * v2);
      if ( v3 == 51 || v3 == 52 )
        break;
      if ( ++v2 >= 8u )
        goto LABEL_11;
    }
    if ( !sub_1002D390(165) )
      sub_100183E0();
    *((_BYTE *)dword_107FECDC + 19) = 1;
    sub_1002D550(0xA5u);
LABEL_11:
    if ( v2 == 8 )
    {
      *((_BYTE *)dword_107FECDC + 19) = 0;
      sub_1002D440(165);
    }
    result = (void *)(sub_10060900() + 5000);
    dword_107FECD4 = (int)result;
  }
  else
  {
    result = memcpy_0((char *)dword_107FECDC + 10, a1, 8u);
  }
  return result;
}
// 107FECD4: using guessed type int dword_107FECD4;

//----- (100184B0) --------------------------------------------------------
int sub_100184B0()
{
  char v1; // [sp+1h] [bp-1h]@1

  sub_100183F0();
  sub_10060A00(102);
  sub_100181D0(&unk_1009E73C, 6);
  v1 = 0;
  sub_100181D0(&v1, 4);
  return sub_10060A60(102, 200);
}
// 100183F0: using guessed type int sub_100183F0(void);

//----- (100184F0) --------------------------------------------------------
signed int __usercall sub_100184F0@<eax>(void *a1@<ecx>, int a2@<esi>)
{
  int v2; // eax@1
  signed int result; // eax@7
  char *v4; // ecx@7

  v2 = *(_DWORD *)a2 & 0xFF;
  if ( v2 == 70 || v2 == 82 || *(_BYTE *)(a2 + 1) == 68 && sub_1002C5E0(a1) == 1 )
  {
    *((_BYTE *)dword_107FECDC + 19) = 1;
    sub_100183F0();
    sub_1002D550(0xA5u);
  }
  else
  {
    *((_BYTE *)dword_107FECDC + 19) = 0;
    sub_1002D440(165);
  }
  *((_DWORD *)dword_107FECDC + 10) = *(_DWORD *)a2;
  memcpy_0(dword_107FECDC, (char *)dword_107FECDC + 10, 8u);
  result = -1;
  v4 = (char *)dword_107FECDC + 10;
  *(_DWORD *)v4 = -1;
  *((_DWORD *)v4 + 1) = -1;
  return result;
}
// 100183F0: using guessed type int sub_100183F0(void);

//----- (10018580) --------------------------------------------------------
signed int __cdecl sub_10018580(int a1)
{
  char v1; // bl@1
  void *v2; // ecx@7
  signed int result; // eax@30
  char v4; // [sp+3h] [bp-585h]@1
  __int16 v5; // [sp+4h] [bp-584h]@22
  int v6; // [sp+8h] [bp-580h]@1
  int v7; // [sp+Ch] [bp-57Ch]@1
  int v8; // [sp+10h] [bp-578h]@1
  char v9; // [sp+14h] [bp-574h]@1
  char v10; // [sp+174h] [bp-414h]@1
  int v11; // [sp+57Ch] [bp-Ch]@1
  int v12; // [sp+580h] [bp-8h]@1

  v11 = 0;
  v12 = 0;
  v4 = 0;
  v1 = 0;
  v8 = 0;
  v6 = 0;
  memset(&v10, 0, 0x408u);
  memset(&v9, 0, 0x160u);
  v7 = 0;
  if ( (signed int)(unsigned __int16)a1 > 701 )
  {
LABEL_24:
    sub_10028BC0("..\\lib\\acl\\iop\\strm\\iop_strm_frmt.c", 575, 1, 0);
  }
  else if ( (unsigned __int16)a1 == 701 )
  {
    v1 = sub_100144B0(a1, (int)&byte_10A08A80, &v5);
    if ( v1 == 1 )
    {
      sub_10060A60(102, 200);
      *((_WORD *)dword_107FECDC + 18) = v5;
      sub_10060A00(102);
    }
  }
  else
  {
    switch ( (unsigned __int16)a1 )
    {
      case 0xBu:
        v1 = sub_100144B0(a1, (int)&byte_10A08A80, &v8);
        if ( v1 == 1 )
        {
          sub_10060A60(102, 200);
          sub_10017ED0(&v8);
          sub_10060A00(102);
        }
        break;
      case 0xCu:
        v1 = sub_100144B0(a1, (int)&byte_10A08A80, &v6);
        if ( v1 == 1 )
        {
          sub_10060A60(102, 200);
          sub_100184F0(v2, (int)&v6);
          sub_10060A00(102);
        }
        break;
      case 0xAu:
        v1 = sub_100144B0(a1, (int)&byte_10A08A80, &v10);
        if ( v1 == 1 )
          sub_10017F00((int)&v10);
        break;
      case 0xDu:
        v1 = sub_100144B0(a1, (int)&byte_10A08A80, &v11);
        if ( v1 == 1 )
        {
          sub_10060A60(102, 200);
          sub_10018400(&v11);
          sub_10060A00(102);
        }
        break;
      case 0xEu:
        v1 = sub_100144B0(a1, (int)&byte_10A08A80, &v4);
        if ( v1 == 1 )
        {
          sub_10060A60(102, 200);
          if ( v4 )
          {
            if ( v4 == 1 )
            {
              sub_100184B0();
              sub_10060A00(102);
            }
            else
            {
              sub_10028BC0("..\\lib\\acl\\iop\\strm\\iop_strm_frmt.c", 514, 1, 0);
              sub_10060A00(102);
            }
          }
          else
          {
            sub_100183F0();
            sub_10060A00(102);
          }
        }
        break;
      case 0xFu:
        v1 = sub_100144B0(a1, (int)&byte_10A08A80, &v9);
        if ( v1 == 1 )
        {
          sub_10060A60(102, 200);
          sub_100181B0(&v9);
          sub_10060A00(102);
        }
        break;
      case 0x10u:
        v1 = sub_100144B0(a1, (int)&byte_10A08A80, &v7);
        if ( v1 == 1 )
        {
          sub_10060A60(102, 200);
          *((_DWORD *)dword_107FECDC + 8) = v7;
          sub_10060A00(102);
        }
        break;
      default:
        goto LABEL_24;
    }
  }
  sub_10060A60(102, 200);
  if ( v1 == 1 )
    *((_DWORD *)dword_107FECDC + 7) = sub_10060900() + 5000;
  if ( *((_BYTE *)dword_107FECDC + 8) <= 1u && (unsigned __int8)sub_1002BC10() > 1u )
    sub_100183F0();
  sub_10060A00(102);
  sub_10018280();
  result = sub_1002BC10();
  *((_BYTE *)dword_107FECDC + 8) = result;
  return result;
}
// 100183F0: using guessed type int sub_100183F0(void);
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10018900) --------------------------------------------------------
void sub_10018900()
{
  unsigned int v0; // esi@2
  _BYTE *v1; // eax@2
  void *v2; // ecx@8

  if ( byte_107FECD8 )
  {
    v0 = sub_10060900();
    v1 = dword_107FECDC;
    if ( !*((_BYTE *)dword_107FECDC + 18)
      && *((_BYTE *)dword_107FECDC + 41) == 67
      && dword_107FECD0
      && v0 > dword_107FECD0 )
    {
      sub_10060A60(102, 200);
      sub_100183E0();
      sub_10060A00(102);
      v1 = dword_107FECDC;
      dword_107FECD0 = 0;
    }
    if ( v0 <= *((_DWORD *)v1 + 7) )
    {
      if ( v1[18] == 1 && v0 > dword_107FECD4 )
      {
        *(_DWORD *)v1 = -1;
        *((_DWORD *)dword_107FECDC + 1) = -1;
        *((_BYTE *)dword_107FECDC + 19) = 0;
        sub_1002D440(165);
      }
    }
    else
    {
      sub_10060A60(102, 200);
      sub_100183E0();
      if ( *((_BYTE *)dword_107FECDC + 18) )
      {
        *((_BYTE *)dword_107FECDC + 19) = 1;
        sub_1002D550(0xA5u);
        sub_10060A00(102);
      }
      else
      {
        *((_DWORD *)dword_107FECDC + 10) &= 0xF7FFFFFF;
        *((_DWORD *)dword_107FECDC + 10) &= 0xEFFFFFFF;
        *((_DWORD *)dword_107FECDC + 10) &= 0xFBFFFFFF;
        *((_DWORD *)dword_107FECDC + 10) &= 0xFEFFFFFF;
        *((_DWORD *)dword_107FECDC + 10) &= 0xFDFFFFFF;
        *((_BYTE *)dword_107FECDC + 40) = 70;
        sub_100184F0(v2, (int)dword_107FECDC + 40);
        sub_10060A00(102);
      }
    }
  }
}
// 107FECD0: using guessed type int dword_107FECD0;
// 107FECD4: using guessed type int dword_107FECD4;
// 107FECD8: using guessed type char byte_107FECD8;

//----- (10018A40) --------------------------------------------------------
signed int sub_10018A40()
{
  const char *v1; // [sp+0h] [bp-14h]@1
  char v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+8h] [bp-Ch]@1
  int v4; // [sp+Ch] [bp-8h]@1
  void **v5; // [sp+10h] [bp-4h]@1

  v1 = "/shr_mem/iop_strm_intf.shr";
  v2 = 5;
  v3 = 93276;
  v4 = 0;
  v5 = &dword_107FECDC;
  dword_107FECDC = (void *)-15;
  if ( !sub_10061B70((LONG)&v1) )
    sub_10028BC0("..\\lib\\acl\\iop\\strm\\iop_strm_frmt.c", 959, 1, 0);
  *((_BYTE *)dword_107FECDC + 19) = 1;
  *((_DWORD *)dword_107FECDC + 5) = 2147483648;
  *((_BYTE *)dword_107FECDC + 24) = 0;
  *((_DWORD *)dword_107FECDC + 7) = sub_10060900() + 60000;
  *((_BYTE *)dword_107FECDC + 18) = sub_10030B10(50) != 0;
  *((_BYTE *)dword_107FECDC + 8) = 2;
  sub_100183F0();
  return sub_10061700((int)&v1);
}
// 100183F0: using guessed type int sub_100183F0(void);

//----- (10018B00) --------------------------------------------------------
char sub_10018B00()
{
  char result; // al@1

  sub_10018A40();
  dword_107FECD0 = 0;
  dword_107FECD4 = 0;
  result = sub_10038820();
  byte_107FECD8 = result;
  return result;
}
// 107FECD0: using guessed type int dword_107FECD0;
// 107FECD4: using guessed type int dword_107FECD4;
// 107FECD8: using guessed type char byte_107FECD8;

//----- (10018B20) --------------------------------------------------------
char *__cdecl sub_10018B20(char a1)
{
  char *result; // eax@1

  result = dword_107FECE0;
  if ( dword_107FECE0[12] != a1 )
  {
    sub_10060A60(38, 300);
    dword_107FECE0[12] = a1;
    sub_10060A00(38);
    result = (char *)sub_10060ED0(3145, (int)&a1, 1);
  }
  return result;
}

//----- (10018B70) --------------------------------------------------------
char sub_10018B70()
{
  if ( dword_107FECE0[21] )
  {
    sub_10060A60(38, 300);
    if ( dword_107FECE0[22] )
    {
      dword_107FECE0[21] = 0;
      dword_107FECE0[22] = 0;
    }
    else
    {
      dword_107FECE0[22] = 1;
    }
    sub_10060A00(38);
  }
  return sub_100330B0(0x29u, dword_107FECE0[22]);
}

//----- (10018BD0) --------------------------------------------------------
char sub_10018BD0()
{
  if ( dword_107FECE0[28] )
  {
    sub_10060A60(38, 300);
    if ( dword_107FECE0[29] )
    {
      dword_107FECE0[28] = 0;
      dword_107FECE0[29] = 0;
    }
    else
    {
      dword_107FECE0[29] = 1;
      if ( dword_107FECE0[35] == 2 )
        dword_107FECE0[22] = 0;
    }
    sub_10060A00(38);
  }
  return sub_100330B0(0x2Au, dword_107FECE0[29]);
}

//----- (10018C40) --------------------------------------------------------
char *__cdecl sub_10018C40(unsigned __int16 a1)
{
  char *result; // eax@1
  double v2; // st7@6

  result = (char *)a1;
  if ( a1 == 195 )
  {
    result = dword_107FECE0;
    v2 = flt_107FECE8;
    dword_107FECE0[13] = 0;
    *((float *)dword_107FECE0 + 1) = v2;
  }
  else if ( a1 == 403 )
  {
    result = dword_107FECE0;
    if ( !dword_107FECE0[13] )
      *((float *)dword_107FECE0 + 1) = 9.9999996e24;
    flt_107FECE8 = 9.9999996e24;
  }
  return result;
}
// 107FECE8: using guessed type float flt_107FECE8;

//----- (10018C90) --------------------------------------------------------
char sub_10018C90()
{
  char v0; // bl@1
  signed int v1; // eax@1
  char v3; // [sp+6h] [bp-2h]@1
  char v4; // [sp+7h] [bp-1h]@1

  v4 = 3;
  v0 = 0;
  sub_10060E40(3145, &v3, 1, &v4);
  LOBYTE(v1) = dword_107FECE0[12];
  if ( (_BYTE)v1 != v3 )
  {
    v1 = sub_10060B40(38, -2);
    if ( !v1 )
    {
      v0 = 1;
      LOBYTE(v1) = sub_10060A60(38, 300);
    }
    dword_107FECE0[12] = v3;
    if ( v0 )
      LOBYTE(v1) = sub_10060A00(38);
  }
  return v1;
}

//----- (10018E50) --------------------------------------------------------
char *__usercall sub_10018E50@<eax>(char *result@<eax>, float *a2@<ecx>)
{
  bool v2; // zf@3

  result = (char *)(unsigned __int16)result;
  if ( (unsigned __int16)result == 195 )
  {
    result = dword_107FECE0;
    *((float *)dword_107FECE0 + 1) = *a2 * 3.280839895013123;
    dword_107FECE0[13] = 1;
  }
  else if ( result == (char *)403 )
  {
    result = dword_107FECE0;
    v2 = dword_107FECE0[13] == 0;
    flt_107FECE8 = *a2 * 3.280839895013123;
    if ( v2 )
      *((float *)dword_107FECE0 + 1) = flt_107FECE8;
  }
  return result;
}
// 107FECE8: using guessed type float flt_107FECE8;

//----- (10018EA0) --------------------------------------------------------
_BYTE *__usercall sub_10018EA0@<eax>(_BYTE *result@<eax>)
{
  *((_WORD *)dword_107FECE0 + 4) = *result;
  return result;
}

//----- (10018EB0) --------------------------------------------------------
_BYTE *__usercall sub_10018EB0@<eax>(_BYTE *result@<eax>)
{
  *((_WORD *)dword_107FECE0 + 5) = *result;
  return result;
}

//----- (10018EC0) --------------------------------------------------------
char __usercall sub_10018EC0@<al>(int a1@<eax>)
{
  char result; // al@1

  dword_107FECE0[13] = *(_BYTE *)a1;
  result = *(_BYTE *)(a1 + 1);
  dword_107FECE0[14] = result;
  return result;
}

//----- (10018EE0) --------------------------------------------------------
_DWORD *__usercall sub_10018EE0@<eax>(_DWORD *result@<eax>)
{
  *((_DWORD *)dword_107FECE0 + 4) = *result;
  return result;
}

//----- (10018EF0) --------------------------------------------------------
int __usercall sub_10018EF0@<eax>(int result@<eax>)
{
  dword_107FECE0[15] = *(_BYTE *)(result + 1);
  return result;
}

//----- (10018F00) --------------------------------------------------------
unsigned __int8 __usercall sub_10018F00@<al>(unsigned __int8 result@<al>)
{
  if ( !result || result > (unsigned __int8)byte_107FECE6 )
    byte_107FECE6 = result;
  return result;
}
// 107FECE6: using guessed type char byte_107FECE6;

//----- (10018F20) --------------------------------------------------------
char *__usercall sub_10018F20@<eax>(char a1@<bl>)
{
  char *result; // eax@1

  result = dword_107FECE0;
  if ( !dword_107FECE0 )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\tcas\\iop_tcas_frmt.c", 1712, 1, dword_107FECE0);
    result = dword_107FECE0;
  }
  result[35] = a1;
  return result;
}

//----- (10018F50) --------------------------------------------------------
char sub_10018F50()
{
  unsigned int v0; // eax@1

  dword_107FECE0[30] = byte_107FECE6;
  v0 = sub_10060900();
  if ( v0 > 0xEA60 )
  {
    if ( (byte_107FECE6 == 4 || byte_107FECE6 == 6 || byte_107FECE6 == 8) && (unsigned __int8)sub_10030C20() )
      LOBYTE(v0) = sub_1002D550(0xA6u);
    else
      LOBYTE(v0) = sub_1002D440(166);
  }
  return v0;
}
// 107FECE6: using guessed type char byte_107FECE6;

//----- (10018FA0) --------------------------------------------------------
signed int __thiscall sub_10018FA0(void *this)
{
  int v1; // ecx@1
  char v2; // al@3
  int v4; // [sp-2h] [bp-4h]@1

  byte_107FECE6 = 7;
  byte_107FECEC = sub_100342A0((int)this);
  flt_107FECE8 = 9.9999996e24;
  dword_107FECF0 = 0;
  byte_107FECE4 = 0;
  byte_107FECE7 = 0;
  byte_107FECE5 = sub_10030BA0();
  v4 = v1;
  HIWORD(v4) = 780;
  dword_107FECE0 = (char *)-15;
  if ( !sub_10061B70((LONG)&off_1009F650) )
    sub_10028BC0("..\\lib\\acl\\iop\\tcas\\iop_tcas_frmt.c", 1223, 1, 0);
  *dword_107FECE0 = 0;
  *((float *)dword_107FECE0 + 1) = 9.9999996e24;
  *((_WORD *)dword_107FECE0 + 4) = 27;
  *((_WORD *)dword_107FECE0 + 5) = 90;
  dword_107FECE0[13] = 0;
  dword_107FECE0[14] = 0;
  dword_107FECE0[15] = 30;
  *((_DWORD *)dword_107FECE0 + 4) = 2147483648;
  dword_107FECE0[20] = 0;
  dword_107FECE0[28] = 0;
  v2 = byte_107FECE6;
  dword_107FECE0[29] = 0;
  dword_107FECE0[30] = v2;
  dword_107FECE0[33] = 0;
  *((_DWORD *)dword_107FECE0 + 6) = sub_10060900();
  dword_107FECE0[21] = 0;
  dword_107FECE0[22] = 0;
  sub_10060E40(10017, dword_107FECE0 + 35, 1, (char *)&v4 + 2);
  if ( byte_107FECE5 && dword_107FECE0[35] != 9 )
    dword_107FECE0[35] = 9;
  sub_10061000(3145, dword_107FECE0 + 12, 1, (char *)&v4 + 3);
  return sub_10061700((int)&off_1009F650);
}
// 1009F650: using guessed type char *off_1009F650;
// 107FECE4: using guessed type char byte_107FECE4;
// 107FECE5: using guessed type char byte_107FECE5;
// 107FECE6: using guessed type char byte_107FECE6;
// 107FECE7: using guessed type char byte_107FECE7;
// 107FECE8: using guessed type float flt_107FECE8;
// 107FECEC: using guessed type char byte_107FECEC;
// 107FECF0: using guessed type int dword_107FECF0;

//----- (10018FE0) --------------------------------------------------------
char sub_10018FE0()
{
  int v0; // esi@1
  int v1; // ecx@1
  char v2; // bl@1
  char result; // al@2
  int v4; // [sp+8h] [bp-38h]@9
  char v5; // [sp+11h] [bp-2Fh]@10

  v0 = sub_10060900();
  v2 = sub_100342A0(v1);
  if ( sub_10060A60(38, 300) )
  {
    result = sub_10028BC0("..\\lib\\acl\\iop\\tcas\\iop_tcas_frmt.c", 504, 0, 0);
  }
  else
  {
    if ( byte_107FECEC == v2 || sub_10019980() != 1 )
    {
      if ( (unsigned int)(v0 - *((_DWORD *)dword_107FECE0 + 6)) > 0x7D0 )
      {
        sub_10018F00(8u);
        sub_10018F50();
        dword_107FECF0 = 0;
      }
    }
    else
    {
      byte_107FECEC = v2;
      *((_DWORD *)dword_107FECE0 + 6) = v0;
    }
    result = sub_10060A00(38);
    if ( byte_107FECE5 )
    {
      result = sub_10029420(&v4);
      if ( result )
      {
        dword_107FECE0[20] = v5;
        result = v4;
        if ( dword_107FECE0[12] != (_BYTE)v4 )
          result = (unsigned int)sub_10018B20(v4);
      }
    }
  }
  return result;
}
// 107FECE5: using guessed type char byte_107FECE5;
// 107FECEC: using guessed type char byte_107FECEC;
// 107FECF0: using guessed type int dword_107FECF0;

//----- (100190E0) --------------------------------------------------------
char sub_100190E0()
{
  char result; // al@1
  char v1; // al@5

  result = dword_107FECE0[30];
  if ( result == 3 || result == 4 || !result && dword_107FECE0[35] == 2 )
  {
    v1 = dword_107FECE0[35];
    if ( v1 == 4 || v1 == 5 || v1 == 6 )
      sub_10026C30(5);
    sub_10018F00(5u);
    sub_10060A60(38, 300);
    dword_107FECE0[28] = 1;
    result = sub_10060A00(38);
  }
  return result;
}

//----- (10019140) --------------------------------------------------------
char sub_10019140()
{
  char result; // al@1
  char v1; // bl@1

  result = dword_107FECE0[30];
  v1 = 0;
  if ( !result )
  {
    sub_10018F00(3u);
    if ( !sub_10060B40(38, -2) )
    {
      v1 = 1;
      sub_10060A60(38, 300);
    }
    if ( dword_107FECE0[35] == 2 )
      dword_107FECE0[22] = 1;
    else
      dword_107FECE0[21] = 1;
    if ( v1 )
      sub_10060A00(38);
    result = dword_107FECE0[35];
    if ( result == 4 || result == 5 || result == 6 )
      result = sub_10026C30(3);
    return result;
  }
  if ( result != 3 )
    return result;
  if ( !sub_10060B40(38, -2) )
  {
    v1 = 1;
    sub_10060A60(38, 300);
  }
  if ( dword_107FECE0[35] != 2 )
  {
    dword_107FECE0[21] = 1;
    goto LABEL_21;
  }
  if ( dword_107FECE0[22] )
  {
    dword_107FECE0[22] = 0;
LABEL_21:
    sub_10018F00(0);
    goto LABEL_22;
  }
  dword_107FECE0[22] = 1;
LABEL_22:
  if ( v1 )
    sub_10060A00(38);
  result = dword_107FECE0[35];
  if ( result == 4 || result == 5 || result == 6 )
    result = sub_10026C30(0);
  return result;
}

//----- (10019240) --------------------------------------------------------
char __usercall sub_10019240@<al>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // bl@1
  signed __int16 v3; // dx@5
  signed __int16 v4; // cx@5
  char *v5; // ecx@14
  signed int v6; // eax@20
  int v7; // edx@21
  char v8; // al@22
  float v9; // ST24_4@28
  double v10; // st5@28
  char v11; // bl@31
  bool v12; // bl@35
  char *v13; // ecx@39
  unsigned __int8 v15; // [sp+12h] [bp-1Ah]@1
  char v16; // [sp+13h] [bp-19h]@1
  signed __int16 v17; // [sp+14h] [bp-18h]@4
  signed __int16 v18; // [sp+18h] [bp-14h]@4
  int v19; // [sp+20h] [bp-Ch]@1
  int v20; // [sp+24h] [bp-8h]@21

  v1 = a1;
  v15 = 0;
  v19 = 0;
  v16 = 0;
  v2 = sub_10019980();
  if ( dword_107FECE0[12] )
  {
    if ( dword_107FECE0[12] == 1 )
    {
      v3 = -4 * *((_WORD *)dword_107FECE0 + 4);
      v4 = 4 * *((_WORD *)dword_107FECE0 + 5);
    }
    else
    {
      if ( dword_107FECE0[12] != 2 )
      {
        v17 = -3000;
        v18 = 3000;
        goto LABEL_9;
      }
      v3 = -4 * *((_WORD *)dword_107FECE0 + 5);
      v4 = 4 * *((_WORD *)dword_107FECE0 + 4);
    }
  }
  else
  {
    v3 = -4 * *((_WORD *)dword_107FECE0 + 4);
    v4 = 4 * *((_WORD *)dword_107FECE0 + 4);
  }
  v17 = v3;
  v18 = v4;
LABEL_9:
  dword_107FECE0[32] = *(_BYTE *)v1;
  dword_107FECE0[33] = 0;
  *((_DWORD *)dword_107FECE0 + 12) = *(_DWORD *)(v1 + 16);
  *((_DWORD *)dword_107FECE0 + 13) = *(_DWORD *)(v1 + 20);
  dword_107FECE0[35] = *(_BYTE *)(v1 + 3);
  if ( *(_BYTE *)(v1 + 1) > 0x1Eu )
  {
    sub_10018F00(6u);
    sub_10018F50();
    dword_107FECF0 = 0;
  }
  else
  {
    v15 = *(_BYTE *)(v1 + 1);
  }
  *((_DWORD *)dword_107FECE0 + 11) = *(_DWORD *)(v1 + 12);
  dword_107FECE0[38] = *(_BYTE *)(v1 + 6);
  if ( *(_BYTE *)(v1 + 6) || v2 != 2 )
  {
    v5 = dword_107FECE0;
  }
  else
  {
    dword_107FECE0[38] = sub_10034AB0(1, (int *)dword_107FECE0 + 11);
    v5 = dword_107FECE0;
    v16 = dword_107FECE0[38];
  }
  if ( *(_BYTE *)(v1 + 6) && v2 != 2 && v2 != 1 )
  {
    *((_DWORD *)v5 + 11) += (signed int)(sub_10062650(0) * 683565248.0);
    v5 = dword_107FECE0;
  }
  LOBYTE(v6) = v15;
  if ( v15 )
  {
    v7 = v1 + 46;
    v20 = v15;
    do
    {
      v8 = *(_BYTE *)(v7 - 13);
      if ( v8 == 2
        || v8 == 1
        || !*(_BYTE *)(v7 - 12)
        || v5[35] == 7
        || (LOWORD(v6) = *(_WORD *)v7, *(_WORD *)v7 >= v17) && (signed __int16)v6 <= v18 )
      {
        v9 = *(float *)(v7 + 10);
        v10 = v9;
        if ( (LODWORD(v9) & 0x7F800000) == 2139095040 || v10 > 33712.0 || v10 < 0.0 )
        {
          v11 = 0;
          v10 = (float)0.0;
        }
        else
        {
          v11 = 1;
        }
        qmemcpy(&v5[40 * (unsigned __int8)v5[33] + 60], (const void *)(v7 - 18), 0x28u);
        *(float *)&dword_107FECE0[40 * (unsigned __int8)dword_107FECE0[33] + 88] = v10;
        v12 = v11 && *(_BYTE *)(v7 - 9);
        dword_107FECE0[40 * (unsigned __int8)dword_107FECE0[33] + 69] = v12;
        if ( v16 && *(_BYTE *)(v7 - 11) )
        {
          v13 = &dword_107FECE0[40 * (unsigned __int8)dword_107FECE0[33] + 72];
          *(_WORD *)v13 -= *((_WORD *)dword_107FECE0 + 23);
        }
        ++dword_107FECE0[33];
        LOBYTE(v6) = *(_BYTE *)(v7 - 13);
        if ( (_BYTE)v6 == 2 || (_BYTE)v6 == 1 )
        {
          v6 = 1 << *(_BYTE *)(v7 - 18);
          v19 |= v6;
        }
        v5 = dword_107FECE0;
      }
      v7 += 40;
      --v20;
    }
    while ( v20 );
    dword_107FECF0 = v19;
  }
  else
  {
    dword_107FECF0 = 0;
  }
  return v6;
}
// 107FECF0: using guessed type int dword_107FECF0;

//----- (10019510) --------------------------------------------------------
char __usercall sub_10019510@<al>(int a1@<esi>)
{
  char v1; // al@9
  char result; // al@13
  char v3; // [sp+5h] [bp-13h]@6
  char v4; // [sp+6h] [bp-12h]@21
  char v5; // [sp+7h] [bp-11h]@21
  double v6; // [sp+8h] [bp-10h]@1
  double v7; // [sp+10h] [bp-8h]@1

  sub_1002BC40(0, (int)&v6);
  sub_1002EEB0(a1 + 16, v6, v7);
  sub_10018F20(*(_BYTE *)(a1 + 3));
  sub_10018C90();
  if ( !byte_107FECE7 )
  {
    if ( sub_10019980() == 1 )
    {
LABEL_12:
      byte_107FECE7 = 1;
      goto LABEL_13;
    }
    if ( sub_10019990() == 1 )
      sub_100199A0(0);
    if ( *(_BYTE *)(a1 + 3) <= 7u )
    {
      sub_1002ED20((bool *)&v3);
      if ( v3 == 1 && (!byte_107FECE6 || byte_107FECE6 == 5) )
      {
        v1 = *(_BYTE *)(a1 + 3);
        if ( v1 != 3 && v1 != 2 )
          sub_10019140();
      }
      goto LABEL_12;
    }
  }
LABEL_13:
  result = byte_107FECE6;
  if ( !byte_107FECE6 || byte_107FECE6 == 1 || byte_107FECE6 == 5 )
    result = sub_10019240(a1);
  if ( *(_BYTE *)(a1 + 3) == 7 )
  {
    result = *(_BYTE *)(a1 + 4) & ~byte_107FECE4;
    if ( result & 2 )
    {
      result = sub_10032EB0(2u);
    }
    else if ( result & 1 )
    {
      v4 = 0;
      result = sub_10060E40(9134, &v5, 1, &v4);
      if ( !v5 )
        result = sub_10032EB0(3u);
    }
    byte_107FECE4 = *(_BYTE *)(a1 + 4);
  }
  return result;
}
// 107FECE4: using guessed type char byte_107FECE4;
// 107FECE6: using guessed type char byte_107FECE6;
// 107FECE7: using guessed type char byte_107FECE7;

//----- (10019630) --------------------------------------------------------
char __cdecl sub_10019630(unsigned __int8 *a1, char a2)
{
  char result; // al@2

  if ( a2 )
  {
    sub_10018F00(*a1);
    result = sub_10018F50();
  }
  else
  {
    sub_10018F00(4u);
    result = sub_10018F50();
  }
  return result;
}

//----- (10019660) --------------------------------------------------------
char *__usercall sub_10019660@<eax>(char *a1@<eax>)
{
  return sub_10018F20(*a1);
}

//----- (10019670) --------------------------------------------------------
int __cdecl sub_10019670(char *a1, int a2)
{
  char v2; // bl@12
  char v4; // [sp+9h] [bp-4E7h]@8
  char v5; // [sp+Ah] [bp-4E6h]@6
  char v6; // [sp+Bh] [bp-4E5h]@19
  char v7; // [sp+Ch] [bp-4E4h]@10
  char v8; // [sp+10h] [bp-4E0h]@21
  char v9; // [sp+14h] [bp-4DCh]@4
  char v10; // [sp+18h] [bp-4D8h]@23
  int v11; // [sp+1Ch] [bp-4D4h]@12
  char v12; // [sp+20h] [bp-4D0h]@12
  unsigned __int8 v13; // [sp+22h] [bp-4CEh]@14
  char v14; // [sp+27h] [bp-4C9h]@15

  sub_10060A60(38, 300);
  *((_DWORD *)dword_107FECE0 + 6) = sub_10060900();
  if ( dword_107FECE0[30] == 8 )
  {
    sub_10018F00(7u);
    sub_10018F50();
    sub_10018F00(0);
  }
  switch ( (unsigned __int16)a1 )
  {
    case 0xC3u:
    case 0x193u:
      if ( sub_100144B0((int)a1, a2, &v9) )
        sub_10018E50(a1, (float *)&v9);
      break;
    case 0xC4u:
      if ( sub_100144B0((int)a1, a2, &v5) )
        sub_10018EA0(&v5);
      break;
    case 0xC5u:
      if ( sub_100144B0((int)a1, a2, &v4) )
        sub_10018EB0(&v4);
      break;
    case 0xC6u:
      if ( sub_100144B0((int)a1, a2, &v7) )
        sub_10018EC0((int)&v7);
      break;
    case 0xC8u:
      v2 = sub_100144B0((int)a1, a2, &v12);
      LOBYTE(v11) = v2;
      if ( sub_10019980() == 2 && v2 && v13 < 4u && !v14 )
        v13 = 4;
      sub_10018F00(0);
      sub_10019630(&v13, v11);
      if ( v2 )
        sub_10019510((int)&v12);
      break;
    case 0xCBu:
      if ( sub_100144B0((int)a1, a2, &v6) )
        sub_10019660(&v6);
      break;
    case 0xCCu:
      if ( sub_100144B0((int)a1, a2, &v8) )
        sub_10018EE0(&v8);
      break;
    case 0xCDu:
      if ( sub_100144B0((int)a1, a2, &v10) )
        sub_10018EF0((int)&v10);
      break;
    default:
      sub_10028BC0("..\\lib\\acl\\iop\\tcas\\iop_tcas_frmt.c", 462, 1, 0);
      break;
    case 0xC7u:
    case 0xC9u:
    case 0xCAu:
    case 0xCEu:
      return sub_10060A00(38);
  }
  return sub_10060A00(38);
}

//----- (10019980) --------------------------------------------------------
char sub_10019980()
{
  return *(_BYTE *)(dword_107FECF4 + 3);
}
// 107FECF4: using guessed type int dword_107FECF4;

//----- (10019990) --------------------------------------------------------
char sub_10019990()
{
  return *(_BYTE *)(dword_107FECF4 + 2);
}
// 107FECF4: using guessed type int dword_107FECF4;

//----- (100199A0) --------------------------------------------------------
char __cdecl sub_100199A0(char a1)
{
  char v1; // bl@1
  char result; // al@3

  v1 = 0;
  if ( !sub_10060B40(38, -2) )
  {
    v1 = 1;
    sub_10060A60(38, 300);
  }
  result = a1;
  *(_BYTE *)(dword_107FECF4 + 1) = a1;
  if ( v1 )
    result = sub_10060A00(38);
  return result;
}
// 107FECF4: using guessed type int dword_107FECF4;

//----- (100199F0) --------------------------------------------------------
int __cdecl sub_100199F0(unsigned __int8 a1)
{
  int result; // eax@2

  if ( a1 < 4u )
  {
    sub_10060A60(38, 300);
    *(_BYTE *)(dword_107FECF4 + 3) = a1;
    result = sub_10060A00(38);
  }
  return result;
}
// 107FECF4: using guessed type int dword_107FECF4;

//----- (10019A30) --------------------------------------------------------
char __thiscall sub_10019A30(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE3(v2) = *(_BYTE *)(dword_107FECF4 + 3);
  return sub_10015560(2, 289, (char *)&v2 + 3, 0, 1, 1);
}
// 107FECF4: using guessed type int dword_107FECF4;

//----- (10019B30) --------------------------------------------------------
signed int sub_10019B30()
{
  char v0; // bl@4
  void *v1; // ecx@5
  bool v2; // al@14

  dword_107FECF4 = -15;
  if ( !sub_10061B70((LONG)&off_1009F704) )
    sub_10028BC0("..\\lib\\acl\\iop\\iop_trfc.c", 396, 1, 0);
  if ( sub_10030BA0() )
  {
    v0 = 3;
  }
  else if ( sub_10030B10(10) || sub_10038840(v1) )
  {
    v0 = 0;
  }
  else
  {
    v0 = (sub_10030B40(17) != 0) + 1;
  }
  if ( sub_100309A0() )
  {
    *(_BYTE *)(dword_107FECF4 + 2) = 1;
    *(_BYTE *)(dword_107FECF4 + 1) = 1;
  }
  else
  {
    *(_BYTE *)(dword_107FECF4 + 2) = 0;
    *(_BYTE *)(dword_107FECF4 + 1) = 0;
  }
  v2 = v0 != 1 && *(_BYTE *)(dword_107FECF4 + 2);
  *(_BYTE *)dword_107FECF4 = v2;
  *(_BYTE *)(dword_107FECF4 + 3) = v0;
  return sub_10061700((int)&off_1009F704);
}
// 1009F704: using guessed type char *off_1009F704;
// 107FECF4: using guessed type int dword_107FECF4;

//----- (10019B40) --------------------------------------------------------
_BYTE *__usercall sub_10019B40@<eax>(char a1@<bl>, int a2@<esi>)
{
  signed int v2; // ecx@4
  int v3; // eax@5
  _BYTE *result; // eax@9
  unsigned int v5; // eax@11
  unsigned int v6; // eax@14

  if ( !*(_WORD *)(a2 + 10) && a1 == 3 )
    *(_DWORD *)(a2 + 16) = sub_10060900();
  v2 = 0;
  if ( *(_BYTE *)(a2 + 184) )
  {
    v3 = a2 + 29;
    do
    {
      *(_BYTE *)(v3 + 7) = a1;
      if ( **(_BYTE **)(a2 + 12) != 3 )
        *(_BYTE *)v3 = 0;
      ++v2;
      v3 += 32;
    }
    while ( v2 < *(_BYTE *)(a2 + 184) );
  }
  result = *(_BYTE **)(a2 + 12);
  if ( *result != a1 )
  {
    if ( !a1 )
    {
      v5 = *(_DWORD *)(a2 + 188);
      if ( v5 < 0xFFFFFFC2 && v5 )
      {
        sub_10061070(*(_DWORD *)(a2 + 188));
        *(_DWORD *)(a2 + 188) = -15;
      }
      v6 = *(_DWORD *)(a2 + 49276);
      if ( v6 < 0xFFFFFFC2 )
      {
        if ( v6 )
        {
          sub_10039560((void *)(a2 + 49160));
          *(_DWORD *)(a2 + 49276) = -15;
        }
      }
    }
    result = *(_BYTE **)(a2 + 12);
    *(_BYTE *)(a2 + 8) = *result;
    *result = a1;
  }
  return result;
}

//----- (10019BE0) --------------------------------------------------------
_DWORD *__usercall sub_10019BE0@<eax>(int a1@<ecx>, int a2@<esi>)
{
  int v2; // edx@1
  _DWORD *result; // eax@1
  _DWORD *v4; // ecx@2

  v2 = *(_BYTE *)(a1 + 184);
  result = 0;
  if ( v2 > 0 )
  {
    v4 = (_DWORD *)(a1 + 24);
    do
    {
      if ( *v4 == a2 )
        result = v4;
      v4 += 8;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (10019C00) --------------------------------------------------------
signed int __usercall sub_10019C00@<eax>(int a1@<eax>, int a2@<edx>, void *a3@<ecx>)
{
  return sub_100611A0(*(_DWORD *)(a2 + 188), a3, a1);
}

//----- (10019C20) --------------------------------------------------------
signed int sub_10019C20()
{
  if ( !sub_10061B70((LONG)&off_100A04C8) )
    sub_10028BC0("..\\lib\\adl\\iop_upld_mngr.c", 1938, 1, 0);
  *(_BYTE *)dword_10810978 = 0;
  byte_107FECF8 = 0;
  return sub_10061700((int)&off_100A04C8);
}
// 100A04C8: using guessed type char *off_100A04C8;
// 107FECF8: using guessed type char byte_107FECF8;
// 10810978: using guessed type int dword_10810978;

//----- (10019CA0) --------------------------------------------------------
char __usercall sub_10019CA0@<al>(int a1@<esi>, char a2, int a3, char a4, int a5, int a6, int a7, int a8, __int16 a9, int a10)
{
  int v10; // edi@1
  unsigned int v11; // eax@1
  _DWORD *v12; // edx@5
  unsigned int v13; // eax@5
  const char *v14; // ecx@5
  int v15; // edi@9
  int v16; // eax@10
  _BYTE *v17; // ecx@10
  _BYTE *v18; // edx@10
  int v19; // eax@12
  _BYTE *v20; // ecx@12
  _BYTE *v21; // edx@12
  _BYTE *v22; // ecx@14
  _BYTE *v23; // edx@14
  signed int v24; // eax@17
  unsigned int v25; // eax@20
  char *v26; // ecx@22
  _BYTE *v27; // eax@22
  char v28; // dl@23
  signed int v29; // edx@24
  bool v30; // zf@35
  bool v31; // sf@35

  v10 = a3;
  *(_DWORD *)(a1 + 188) = -15;
  *(_DWORD *)(a1 + 49276) = -15;
  memset((void *)(a1 + 50024), 0, 0x34u);
  v11 = j_FIL_vfs_open(a6, 4, 1792);
  *(_DWORD *)(a1 + 188) = v11;
  if ( (v11 >= 0xFFFFFFC2 || !v11)
    && sub_10061390((int)"/mnt/card0/avtn_rgn.gca")
    && !sub_100395C0(
          (int)"/mnt/card0/avtn_rgn.gca",
          4,
          (void *)(a1 + 49160),
          (int)"Garmin Dont Give Out sYsTem lOader 1543krats&$*%(dh)#2654/*-") )
  {
    v12 = (_DWORD *)a6;
    v13 = 10;
    v14 = "/mnt/card0";
    do
    {
      if ( *v12 != *(_DWORD *)v14 )
        goto LABEL_9;
      v13 -= 4;
      v14 += 4;
      ++v12;
    }
    while ( v13 >= 4 );
    if ( !v13 )
    {
LABEL_17:
      v24 = 0;
      goto LABEL_18;
    }
LABEL_9:
    v15 = *(_BYTE *)v12 - *v14;
    if ( *(_BYTE *)v12 == *v14 )
    {
      v16 = v13 - 1;
      v17 = v14 + 1;
      v18 = (char *)v12 + 1;
      if ( !v16
        || (v15 = *v18 - *v17, *v18 == *v17)
        && ((v19 = v16 - 1, v20 = v17 + 1, v21 = v18 + 1, !v19)
         || (v15 = *v21 - *v20, *v21 == *v20)
         && ((v22 = v20 + 1, v23 = v21 + 1, v19 == 1) || (v15 = *v23 - *v22, *v23 == *v22))) )
      {
        v10 = a3;
        goto LABEL_17;
      }
    }
    v30 = v15 == 0;
    v31 = v15 < 0;
    v10 = a3;
    v24 = 1;
    if ( v31 || v30 )
      v24 = -1;
LABEL_18:
    if ( !v24 )
    {
      *(_DWORD *)(a1 + 50048) = a1 + 192;
      *(_DWORD *)(a1 + 50056) = a1 + 2240;
      *(_DWORD *)(a1 + 50024) = 0;
      *(_DWORD *)(a1 + 50028) = 0;
      *(_WORD *)(a1 + 50032) = 0;
      *(_DWORD *)(a1 + 50040) = 0;
      *(_WORD *)(a1 + 50044) = 0;
      *(_DWORD *)(a1 + 50052) = 2048;
      *(_DWORD *)(a1 + 50060) = 46920;
      *(_DWORD *)(a1 + 50064) = 15;
      *(_BYTE *)(a1 + 50068) = -2;
      *(_DWORD *)(a1 + 50072) = 0xFFFF;
      *(_DWORD *)(a1 + 188) = sub_1003A560(a1 + 49160, (char *)(a6 + 11), 4, (void *)(a1 + 49288), a1 + 50024);
    }
  }
  v25 = *(_DWORD *)(a1 + 188);
  if ( v25 < 0xFFFFFFC2 && v25 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 12) + 4) = a2;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 144) = v10;
    *(_BYTE *)(*(_DWORD *)(a1 + 12) + 5) = a4;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 140) = a5;
    *(_WORD *)(*(_DWORD *)(a1 + 12) + 136) = a9;
    *(_WORD *)(*(_DWORD *)(a1 + 12) + 138) = -1;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 168) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 152) = a7;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 148) = a8;
    v26 = (char *)a6;
    v27 = (_BYTE *)(*(_DWORD *)(a1 + 12) + 7);
    do
    {
      v28 = *v26;
      *v27++ = *v26++;
    }
    while ( v28 );
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 156) = a10;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 160) = 0;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 164) = 1000;
    sub_100613E0(
      *(_DWORD *)(a1 + 188),
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(a1 + 12) + 168),
      0);
    *(_WORD *)(a1 + 10) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    dword_1080B09C = sub_10060900();
    **(_BYTE **)(a1 + 12) = 1;
    memset((void *)(a1 + 24), 0, 0xA0u);
    *(_BYTE *)(a1 + 184) = 0;
    v29 = 2;
    do
    {
      v25 = 1 << (v29 - 2);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v25 = 1 << (v29 - 1);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      if ( (1 << v29) & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = 1 << v29;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v25 = 1 << (v29 + 1);
      if ( v25 & v10 )
      {
        *(_DWORD *)(32 * *(_BYTE *)(a1 + 184) + a1 + 24) = v25;
        LOBYTE(v25) = **(_BYTE **)(a1 + 12);
        *(_BYTE *)(32 * *(_BYTE *)(a1 + 184) + a1 + 36) = v25;
        *(_DWORD *)(32 * ((*(_BYTE *)(a1 + 184))++ + 1) + a1) = 0;
        if ( *(_BYTE *)(a1 + 184) >= 5u )
          break;
      }
      v29 += 4;
      LOBYTE(v25) = v29 - 2;
    }
    while ( (unsigned int)(v29 - 2) < 0x20 );
  }
  return v25;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1080B09C: using guessed type int dword_1080B09C;

//----- (1001A0E0) --------------------------------------------------------
char __usercall sub_1001A0E0@<al>(const void *a1@<eax>, int a2@<ebx>, char a3, unsigned __int16 a4)
{
  const void *v4; // edi@1
  int v5; // esi@3
  int v6; // eax@4
  int v7; // ecx@5
  int v8; // edi@5
  char result; // al@6
  int v10; // eax@8

  v4 = a1;
  *(_DWORD *)(a2 + 20) = sub_10060900();
  if ( a3 == 1 )
  {
    v5 = 39;
  }
  else
  {
    if ( a3 == 2 )
    {
      v5 = 0xFFFF;
      v10 = sub_10060900();
      sub_10013920(0xFFFF, a4, 1, (int)&byte_10A08A80, v4, v10);
      goto LABEL_5;
    }
    v5 = 38;
  }
  v6 = sub_10060900();
  sub_10013610(v5, 1, (int)&byte_10A08A80, v4, v6);
LABEL_5:
  v7 = *(_DWORD *)(a2 + 12);
  v8 = *(_DWORD *)(v7 + 144);
  if ( v8 == sub_1002C660((void *)v7) || (result = sub_10013C10(v5, v8, (int)&byte_10A08A80)) != 0 )
    result = 1;
  return result;
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (1001A170) --------------------------------------------------------
int sub_1001A170()
{
  unsigned int v0; // esi@1
  void (__cdecl *v1)(int); // eax@2
  int result; // eax@5

  dword_10810978 = -15;
  sub_10019C20();
  memset(&dword_107FED00, 0, 0xC39Cu);
  dword_10810970 = 0;
  dword_10810974 = 0;
  v0 = 0;
  do
  {
    v1 = (void (__cdecl *)(int))dword_100A04AC[v0];
    if ( v1 )
      v1(dword_100A04A8[v0]);
    v0 += 4;
  }
  while ( v0 < 8 );
  result = sub_10060900();
  dword_10810970 = result;
  LOBYTE(dword_10810974) = 0;
  dword_107FED0C = dword_10810978;
  dword_107FEDBC = -15;
  dword_1080AD7C = -15;
  byte_107FECFA = 0;
  byte_107FECF9 = 0;
  return result;
}
// 100A04A8: using guessed type int dword_100A04A8[];
// 100A04AC: using guessed type int dword_100A04AC[];
// 107FECF9: using guessed type char byte_107FECF9;
// 107FECFA: using guessed type char byte_107FECFA;
// 107FED00: using guessed type int dword_107FED00;
// 107FED0C: using guessed type int dword_107FED0C;
// 107FEDBC: using guessed type int dword_107FEDBC;
// 1080AD7C: using guessed type int dword_1080AD7C;
// 10810970: using guessed type int dword_10810970;
// 10810974: using guessed type int dword_10810974;
// 10810978: using guessed type int dword_10810978;

//----- (1001A210) --------------------------------------------------------
char __cdecl sub_1001A210(char a1, int a2, char a3, int a4, const char *a5, int a6, int a7, __int16 a8, int a9)
{
  if ( strlen(a5) >= 0x80 )
    sub_10028BC0("..\\lib\\adl\\iop_upld_mngr.c", 1375, 1, 0);
  return sub_10019CA0((int)&dword_107FED00, a1, a2, a3, a4, (int)a5, a6, a7, a8, a9);
}
// 107FED00: using guessed type int dword_107FED00;

//----- (1001A280) --------------------------------------------------------
_BYTE *__cdecl sub_1001A280(char a1)
{
  void *v1; // ecx@4
  char v2; // bl@5
  int v4; // [sp+8h] [bp-18h]@1
  int v5; // [sp+Ch] [bp-14h]@1
  int v6; // [sp+10h] [bp-10h]@1
  int v7; // [sp+14h] [bp-Ch]@1
  int v8; // [sp+18h] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  if ( (unsigned __int8)byte_107FED08 >= 2u && *(_BYTE *)dword_107FED0C == 5 || *(_BYTE *)dword_107FED0C >= 2u )
  {
    LOBYTE(v4) = 2;
    v1 = *(void **)(dword_107FED0C + 140);
    v6 = *(_DWORD *)(dword_107FED0C + 140);
    v7 = *(_DWORD *)(dword_107FED0C + 148);
    LOWORD(v5) = *(_WORD *)(dword_107FED0C + 136);
    LOWORD(v1) = v5;
    BYTE1(v4) = *(_BYTE *)(dword_107FED0C + 5);
    v8 = sub_1002C660(v1);
    sub_1001A0E0(&v4, (int)&dword_107FED00, 0, 0x14u);
  }
  dword_107FED00 = sub_10060900();
  v2 = 5;
  if ( !a1 )
    v2 = 7;
  return sub_10019B40(v2, (int)&dword_107FED00);
}
// 107FED00: using guessed type int dword_107FED00;
// 107FED08: using guessed type char byte_107FED08;
// 107FED0C: using guessed type int dword_107FED0C;

//----- (1001A340) --------------------------------------------------------
_BYTE *__usercall sub_1001A340@<eax>(_BYTE *result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // esi@1
  char v4; // bl@1
  int v5; // ecx@3
  signed int v6; // eax@3
  int v7; // edi@4
  _BYTE *v8; // ecx@9

  v3 = a3;
  v4 = (char)result;
  if ( *(_BYTE *)(a2 + 12) != (_BYTE)result )
  {
    *(_BYTE *)(a2 + 12) = (_BYTE)result;
    if ( (_BYTE)result == 7 )
    {
      *(_DWORD *)(*(_DWORD *)(a3 + 12) + 144) &= ~*(_DWORD *)a2;
      v5 = *(_BYTE *)(a3 + 184);
      v6 = 0;
      if ( v5 > 0 )
      {
        v7 = v3 + 24;
        do
        {
          ++v6;
          if ( v7 == a2 )
            break;
          v7 += 32;
        }
        while ( v6 < *(_BYTE *)(v3 + 184) );
      }
      memcpy_0((void *)a2, (const void *)(a2 + 32), 32 * (v5 - v6));
      v4 = *(_BYTE *)(v3 + 36);
      --*(_BYTE *)(v3 + 184);
    }
    result = 0;
    if ( *(_BYTE *)(v3 + 184) )
    {
      v8 = (_BYTE *)(v3 + 36);
      while ( *v8 == v4 )
      {
        ++result;
        v8 += 32;
        if ( (signed int)result >= *(_BYTE *)(v3 + 184) )
          goto LABEL_12;
      }
    }
    else
    {
LABEL_12:
      if ( v4 == 7 )
        result = sub_1001A280(0);
      else
        result = sub_10019B40(v4, v3);
    }
  }
  return result;
}

//----- (1001A660) --------------------------------------------------------
__int16 __usercall sub_1001A660@<ax>(unsigned __int64 a1@<edx:eax>)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@2
  int v4; // edx@12
  unsigned int v5; // ecx@18
  unsigned int v6; // ebp@18
  unsigned int v7; // edi@27
  int v8; // ecx@27

  v1 = dword_107FED0C;
  v2 = a1;
  LOWORD(a1) = *(_WORD *)(a1 + 2);
  if ( (_WORD)a1 == *(_WORD *)(dword_107FED0C + 136) )
  {
    LODWORD(a1) = sub_10019BE0((int)&dword_107FED00, *(_DWORD *)(v2 + 28));
    v3 = a1;
    if ( (_DWORD)a1 )
    {
      if ( *(_BYTE *)v2 != 1 )
      {
        HIDWORD(a1) = a1;
        LOBYTE(a1) = 7;
        LOWORD(a1) = (unsigned int)sub_1001A340((_BYTE *)a1, SHIDWORD(a1), (int)&dword_107FED00);
        return a1;
      }
      if ( *(_BYTE *)v1 != 3
        || (LODWORD(a1) = *(_DWORD *)(v1 + 168), *(_DWORD *)(v2 + 4) != (_DWORD)a1)
        || (LODWORD(a1) = *(_DWORD *)(v2 + 8), (_DWORD)a1) )
      {
        if ( *(_BYTE *)(v2 + 1) < 2u )
          return a1;
        LODWORD(a1) = *(_DWORD *)(v2 + 8);
        v5 = *(_DWORD *)(v3 + 20);
        HIDWORD(a1) = *(_DWORD *)(v2 + 4);
        v6 = *(_DWORD *)(v3 + 16);
        if ( (unsigned int)a1 <= v5 && ((unsigned int)a1 < v5 || HIDWORD(a1) <= v6) )
        {
          if ( (unsigned int)a1 < v5 || (unsigned int)a1 <= v5 && HIDWORD(a1) < v6 )
            return a1;
          *(_DWORD *)(v1 + 168) = HIDWORD(a1);
          sub_100613E0(dword_107FEDBC, *(_DWORD *)(dword_107FED0C + 152) + *(_DWORD *)(dword_107FED0C + 168), 0);
          if ( (unsigned __int8)++byte_107FEDBA > 5u )
            byte_107FEDBA = 5;
        }
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v3 + 28) = sub_10060900();
        LOWORD(a1) = *(_WORD *)(v2 + 24);
        *(_WORD *)(v3 + 24) = a1;
        if ( *(_BYTE *)dword_107FED0C == 3 )
        {
          v7 = *(_DWORD *)(dword_107FED0C + 168);
          v8 = *(_DWORD *)(dword_107FED0C + 148);
          if ( v7 != v8 || *(_DWORD *)(v3 + 16) == v8 && !*(_DWORD *)(v3 + 20) )
          {
            a1 = *(_QWORD *)(v3 + 16) + (unsigned __int16)a1;
            if ( v7 < a1 )
            {
              LOBYTE(a1) = byte_107FED08;
              LOWORD(a1) = (unsigned int)sub_1001A340((_BYTE *)a1, v3, (int)&dword_107FED00);
            }
          }
        }
      }
      else
      {
        *(_BYTE *)(v3 + 5) = 1;
        word_107FED0A = 0;
        dword_107FED14 = 0;
        if ( *(_BYTE *)(v2 + 1) >= 1u && byte_107FED08 == 4 )
        {
          *(_WORD *)(dword_107FED0C + 138) = *(_WORD *)(v2 + 16);
          LODWORD(a1) = *(_DWORD *)(v2 + 12);
          *(_DWORD *)(dword_107FED0C + 160) = a1;
        }
        if ( *(_BYTE *)(v2 + 1) < 2u )
        {
          byte_107FEDBB = 1;
          byte_107FEDB9 = 1;
          byte_107FEDBA = 0;
          *(_WORD *)(v3 + 24) = 1000;
        }
        else
        {
          v4 = *(_DWORD *)(v2 + 8) | *(_DWORD *)(v2 + 4);
          if ( !*(_QWORD *)(v2 + 4) )
          {
            byte_107FEDBB = *(_BYTE *)(v2 + 8) | *(_BYTE *)(v2 + 4);
            byte_107FEDB9 = 25;
            byte_107FEDBA = v4;
          }
          LODWORD(a1) = sub_10060900();
          *(_DWORD *)(v3 + 28) = a1;
          LOWORD(a1) = *(_WORD *)(v2 + 24);
          *(_WORD *)(v3 + 24) = a1;
        }
        *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v2 + 8);
        LOBYTE(a1) = byte_107FED08;
        LOWORD(a1) = (unsigned int)sub_1001A340((_BYTE *)a1, v3, (int)&dword_107FED00);
      }
    }
  }
  return a1;
}
// 107FED00: using guessed type int dword_107FED00;
// 107FED08: using guessed type char byte_107FED08;
// 107FED0A: using guessed type __int16 word_107FED0A;
// 107FED0C: using guessed type int dword_107FED0C;
// 107FED14: using guessed type int dword_107FED14;
// 107FEDB9: using guessed type char byte_107FEDB9;
// 107FEDBA: using guessed type char byte_107FEDBA;
// 107FEDBB: using guessed type char byte_107FEDBB;
// 107FEDBC: using guessed type int dword_107FEDBC;

//----- (1001A870) --------------------------------------------------------
char __thiscall sub_1001A870(void *this)
{
  int v1; // esi@1
  signed int v2; // eax@1
  int v3; // edi@1
  int v4; // ecx@2
  int v5; // eax@8
  int v6; // ecx@10
  char result; // al@11
  int v8; // eax@13
  unsigned int v9; // ebp@13
  int v10; // eax@13
  unsigned int v11; // ebx@14
  int v12; // eax@16
  int v13; // ecx@18
  int v14; // [sp+10h] [bp-7FCh]@2
  int v15; // [sp+14h] [bp-7F8h]@1
  __int16 v16; // [sp+18h] [bp-7F4h]@1
  char v17; // [sp+1Ah] [bp-7F2h]@25
  int v18; // [sp+1Ch] [bp-7F0h]@18
  char v19; // [sp+20h] [bp-7ECh]@16
  size_t v20; // [sp+408h] [bp-404h]@16
  int v21; // [sp+40Ch] [bp-400h]@12
  __int16 v22; // [sp+410h] [bp-3FCh]@1
  char v23; // [sp+412h] [bp-3FAh]@25
  int v24; // [sp+414h] [bp-3F8h]@25
  size_t v25; // [sp+418h] [bp-3F4h]@25
  int v26; // [sp+41Ch] [bp-3F0h]@25
  char v27; // [sp+420h] [bp-3ECh]@25

  v1 = (int)this;
  memset(&v16, 0, 0x3F8u);
  memset(&v22, 0, 0x3F8u);
  v15 = sub_10060900();
  v2 = *(_BYTE *)(v1 + 184);
  byte_107FECF8 = 0;
  v3 = v1 + 24;
  if ( v2 > 1 )
  {
    v4 = v1 + 72;
    v14 = v2 - 1;
    do
    {
      if ( *(_QWORD *)v4 + (unsigned __int64)*(_WORD *)(v4 + 8) < *(_QWORD *)(v3 + 16)
                                                                + (unsigned __int64)*(_WORD *)(v3 + 24) )
        v3 = v4 - 16;
      v4 += 32;
      --v14;
    }
    while ( v14 );
  }
  if ( *(_WORD *)(v1 + 10) )
  {
    *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) = *(_DWORD *)(v3 + 16);
    sub_100613E0(
      *(_DWORD *)(v1 + 188),
      *(_DWORD *)(*(_DWORD *)(v1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168),
      0);
    if ( *(_WORD *)(v1 + 10) > 1u )
    {
      v5 = *(_DWORD *)(v1 + 12);
      if ( *(_DWORD *)(v5 + 164) < 0x3E8u )
        *(_DWORD *)(v5 + 164) = 1000;
    }
  }
  v6 = *(_DWORD *)(v1 + 12);
  if ( *(_DWORD *)(v6 + 168) >= *(_QWORD *)(v3 + 16) + (unsigned __int64)*(_WORD *)(v3 + 24) )
    return (unsigned int)sub_10019B40(3, v1);
  v16 = *(_WORD *)(v6 + 136);
  v21 = sub_1002C660((void *)v6);
  while ( 1 )
  {
    v8 = sub_10060900();
    dword_107FECFC = v8;
    v9 = v8 - v15;
    v10 = *(_DWORD *)(v1 + 12);
    if ( *(_DWORD *)(v10 + 168) < *(_DWORD *)(v10 + 148) )
      break;
    result = (unsigned int)sub_10019B40(4, v1);
LABEL_31:
    if ( **(_BYTE **)(v1 + 12) != 2 || v9 >= 0x23 )
      return result;
  }
  v11 = *(_DWORD *)(v10 + 148) - *(_DWORD *)(v10 + 168);
  if ( v11 > *(_DWORD *)(v10 + 164) )
    v11 = *(_DWORD *)(v10 + 164);
  v12 = sub_10019C00(v11, v1, &v19);
  v20 = v12;
  if ( v12 != v11 )
  {
    v20 = 0;
    sub_1001A280(1);
    v12 = v20;
  }
  v13 = *(_DWORD *)(v1 + 12);
  v18 = *(_DWORD *)(v13 + 168);
  if ( (unsigned int)(v18 + v12) > *(_DWORD *)(v13 + 148) )
  {
    v12 = *(_DWORD *)(v13 + 148) - v18;
    v20 = *(_DWORD *)(v13 + 148) - v18;
  }
  *(_DWORD *)(v13 + 168) += v12;
  if ( *(_BYTE *)(v1 + 187)
    || *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) >= *(_DWORD *)(*(_DWORD *)(v1 + 12) + 148)
    || *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) >= *(_QWORD *)(v3 + 16) + (unsigned __int64)*(_WORD *)(v3 + 24) )
  {
    sub_10019B40(3, v1);
  }
  if ( *(_DWORD *)(*(_DWORD *)(v1 + 12) + 164) >= 0x3E8u )
  {
    result = sub_1001A0E0(&v16, v1, 1, 0x3F8u);
  }
  else
  {
    v22 = v16;
    v24 = v18;
    v25 = v20;
    v23 = v17;
    v26 = v21;
    memcpy(&v27, &v19, v20);
    result = sub_1001A0E0(&v22, v1, 2, v25 + 16);
  }
  if ( result )
    goto LABEL_31;
  *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168) -= v20;
  return sub_100613E0(
           *(_DWORD *)(v1 + 188),
           *(_DWORD *)(*(_DWORD *)(v1 + 12) + 152) + *(_DWORD *)(*(_DWORD *)(v1 + 12) + 168),
           0);
}
// 107FECF8: using guessed type char byte_107FECF8;
// 107FECFC: using guessed type int dword_107FECFC;

//----- (1001AB90) --------------------------------------------------------
_BYTE *__usercall sub_1001AB90@<eax>(int a1@<esi>)
{
  _BYTE *result; // eax@1
  bool v2; // zf@1
  int v3; // edi@4
  int v4; // eax@8
  int v5; // eax@8
  void *v6; // ecx@8
  _BYTE *v7; // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int (__cdecl *v10)(int, _DWORD, _DWORD, _DWORD); // edx@10
  signed int v11; // [sp+0h] [bp-20h]@3
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+14h] [bp-Ch]@1
  _BYTE *v16; // [sp+18h] [bp-8h]@1

  result = 0;
  v2 = *(_BYTE *)(a1 + 184) == 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( v2 )
    result = sub_1001A280(0);
  v11 = 0;
  if ( *(_BYTE *)(a1 + 184) )
  {
    v3 = a1 + 24;
    do
    {
      if ( *(_BYTE *)(v3 + 4) == 1 )
      {
        if ( *(_BYTE *)(v3 + 5) == 1 )
        {
          LOBYTE(result) = 2;
          sub_1001A340(result, v3, a1);
        }
        else
        {
          byte_107FECF8 = 1;
          v4 = sub_10060900();
          LOBYTE(v12) = 0;
          dword_107FECFC = v4;
          v5 = *(_DWORD *)(a1 + 12);
          v6 = *(void **)(v5 + 140);
          v14 = *(_DWORD *)(v5 + 140);
          v15 = *(_DWORD *)(v5 + 148);
          LOWORD(v13) = *(_WORD *)(v5 + 136);
          LOWORD(v6) = v13;
          BYTE1(v12) = *(_BYTE *)(v5 + 5);
          v7 = (_BYTE *)sub_1002C660(v6);
          v16 = v7;
          LOBYTE(v7) = 3;
          sub_1001A340(v7, v3, a1);
          sub_1001A0E0(&v12, a1, 0, 0x14u);
        }
      }
      else
      {
        v8 = sub_1002CC90((_DWORD *)v3, 4u, (int)dword_100A04A8, 16, 2, 3);
        if ( v8 < 3 )
        {
          v9 = 4 * v8;
          v10 = *(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD))((char *)&off_100A04B0 + v9 * 4);
          if ( v10 )
            *(_BYTE *)(v3 + 4) = v10(
                                   dword_100A04A8[v9],
                                   *(_BYTE *)(*(_DWORD *)(a1 + 12) + 5),
                                   *(_DWORD *)(*(_DWORD *)(a1 + 12) + 140),
                                   *(_WORD *)(*(_DWORD *)(a1 + 12) + 136));
        }
      }
      if ( (double)(unsigned int)(sub_10060900() - dword_1080B09C) > 600000.0 )
        sub_1001A280(0);
      result = (_BYTE *)(v11 + 1);
      v3 += 32;
      ++v11;
    }
    while ( v11 < *(_BYTE *)(a1 + 184) );
  }
  return result;
}
// 100A04A8: using guessed type int dword_100A04A8[];
// 100A04B0: using guessed type int (__cdecl *off_100A04B0)(int, int, int, __int16);
// 107FECF8: using guessed type char byte_107FECF8;
// 107FECFC: using guessed type int dword_107FECFC;
// 1080B09C: using guessed type int dword_1080B09C;

//----- (1001AE10) --------------------------------------------------------
char __thiscall sub_1001AE10(int this)
{
  int v1; // esi@1
  unsigned __int8 v2; // cl@1
  char v3; // dl@1
  _BYTE *v4; // eax@2
  int v5; // edi@2
  int v6; // eax@6
  void *v7; // ecx@7
  __int16 v9; // cx@9
  signed int v10; // eax@11
  _DWORD *v11; // ecx@12
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+14h] [bp-Ch]@1
  int v16; // [sp+18h] [bp-8h]@1

  v1 = this;
  v2 = *(_BYTE *)(this + 184);
  v3 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( v2 )
  {
    v4 = (_BYTE *)(v1 + 29);
    v5 = v2;
    do
    {
      if ( *v4 == 1 )
        ++v3;
      v4 += 32;
      --v5;
    }
    while ( v5 );
  }
  v6 = *(_DWORD *)(v1 + 12);
  if ( v2 != v3 )
  {
    LOBYTE(v12) = 1;
    v7 = *(void **)(v6 + 140);
    v14 = *(_DWORD *)(v6 + 140);
    v15 = *(_DWORD *)(v6 + 148);
    LOWORD(v13) = *(_WORD *)(v6 + 136);
    LOWORD(v7) = v13;
    BYTE1(v12) = *(_BYTE *)(v6 + 5);
    v16 = sub_1002C660(v7);
    sub_10019B40(3, v1);
    return sub_1001A0E0(&v12, v1, 0, 0x14u);
  }
  if ( *(_WORD *)(v6 + 136) == 74 )
  {
    v9 = *(_WORD *)(v6 + 138);
    if ( v9 == -1 )
    {
      sub_1001A280(0);
      return sub_10028BC0("..\\lib\\adl\\iop_upld_mngr.c", 2939, 0, 0);
    }
    sub_10030D40(*(_BYTE *)(v6 + 4), v9, *(_DWORD *)(v6 + 160));
  }
  v10 = 0;
  if ( *(_BYTE *)(v1 + 184) )
  {
    v11 = (_DWORD *)(v1 + 32);
    do
    {
      *v11 = 0;
      ++v10;
      v11 += 8;
    }
    while ( v10 < *(_BYTE *)(v1 + 184) );
  }
  *(_DWORD *)(v1 + 4) = sub_10060900();
  return (unsigned int)sub_10019B40(6, v1);
}

//----- (1001AF80) --------------------------------------------------------
char __cdecl sub_1001AF80(int a1, int a2)
{
  char result; // al@2
  unsigned __int64 v3; // rax@6
  void *v4; // ecx@6
  void *v5; // ecx@8
  int v6; // [sp+8h] [bp-28h]@1
  int v7; // [sp+Ch] [bp-24h]@1
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  int v12; // [sp+20h] [bp-10h]@1
  int v13; // [sp+24h] [bp-Ch]@1
  int v14; // [sp+28h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v6 = 0;
  if ( (_WORD)a1 == 40 )
  {
    result = sub_100144B0(40, a2, &v7);
    if ( !result )
      return result;
    BYTE2(v11) = BYTE1(v7);
    BYTE1(v7) = 0;
  }
  else
  {
    result = sub_100144D0(a1, a2, &v7, (unsigned __int16 *)&v6);
  }
  if ( result )
  {
    LODWORD(v3) = sub_10012AC0(a1, a2);
    LOBYTE(v4) = BYTE1(v7);
    if ( BYTE1(v7) <= 1u )
      goto LABEL_10;
    if ( BYTE1(v7) == 2 )
    {
      v14 = v3;
      LODWORD(v3) = sub_1002C660(v4);
      if ( !((unsigned int)v3 & v14) )
      {
LABEL_11:
        LODWORD(v3) = &v7;
        return sub_1001A660(v3);
      }
      LODWORD(v3) = sub_1002C660(v5);
LABEL_10:
      v14 = v3;
      goto LABEL_11;
    }
    result = sub_10028BC0("..\\lib\\adl\\iop_upld_mngr.c", 1177, 0, 0);
  }
  return result;
}

//----- (1001B080) --------------------------------------------------------
void __thiscall sub_1001B080(int *this)
{
  char v1; // bl@9
  signed int v2; // ebp@9
  int *v3; // edi@10
  unsigned int v4; // eax@11
  bool v5; // zf@19
  int v6; // eax@35
  int v7; // eax@36
  int (__cdecl *v8)(int, _DWORD, _DWORD, _DWORD); // edx@36
  int v9; // eax@47
  int v10; // edi@47
  int *v11; // [sp+0h] [bp-4h]@9

  switch ( *(_BYTE *)dword_107FED0C )
  {
    case 1:
      sub_1001AB90((int)&dword_107FED00);
      return;
    case 2:
      sub_1001A870(&dword_107FED00);
      return;
    case 3:
      v9 = sub_10060900();
      v10 = v9;
      if ( byte_107FECF8 == 1 )
      {
        if ( (double)(unsigned int)(v9 - dword_107FECFC) <= 12000.0 )
        {
          if ( (double)(unsigned int)(v9 - *(&dword_107FED00 + 4)) > 360000.0 )
            sub_1001A280(0);
        }
        else
        {
          sub_10019B40(1, (int)&dword_107FED00);
        }
      }
      if ( (double)(unsigned int)(v10 - dword_107FECFC) <= 360000.0 )
      {
        if ( *((_BYTE *)&dword_107FED00 + 8) == 2
          && *(_DWORD *)(*(&dword_107FED00 + 3) + 164) < 0x3E8u
          && (unsigned int)(v10 - *(&dword_107FED00 + 5)) >= 0x3E8 )
        {
          sub_10019B40(2, (int)&dword_107FED00);
          ++*((_WORD *)&dword_107FED00 + 5);
        }
      }
      else
      {
        sub_1001A280(0);
      }
      return;
    case 4:
      sub_1001AE10((int)&dword_107FED00);
      return;
    case 6:
      v11 = this;
      v1 = 0;
      v2 = 0;
      if ( *((_BYTE *)&dword_107FED00 + 184) )
      {
        v3 = &dword_107FED00 + 6;
        while ( 1 )
        {
          v4 = *v3;
          v11 = v3;
          if ( (unsigned int)*v3 > 0x4000 )
            break;
          if ( *v3 == 0x4000 )
            goto LABEL_35;
          if ( v4 > 0x200 )
          {
            if ( v4 > 0x1000 )
            {
              v5 = v4 == 0x2000;
            }
            else
            {
              if ( v4 == 4096 || v4 == 1024 )
                goto LABEL_35;
              v5 = v4 == 2048;
            }
LABEL_34:
            if ( !v5 )
              goto LABEL_39;
            goto LABEL_35;
          }
          if ( v4 != 512 )
          {
            switch ( v4 )
            {
              case 0x10u:
              case 0x20u:
              case 0x40u:
              case 0x80u:
              case 0x100u:
                goto LABEL_35;
              default:
                break;
            }
LABEL_39:
            v1 = 1;
            goto LABEL_40;
          }
LABEL_35:
          v6 = sub_1002CC90(v3, 4u, (int)dword_100A04A8, 16, 2, 3);
          if ( v6 < 3 )
          {
            v7 = 4 * v6;
            v8 = *(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD))((char *)&off_100A04B4 + v7 * 4);
            if ( v8 )
            {
              v1 = v8(
                     dword_100A04A8[v7],
                     *(_BYTE *)(*(&dword_107FED00 + 3) + 5),
                     *(_DWORD *)(*(&dword_107FED00 + 3) + 140),
                     *(_WORD *)(*(&dword_107FED00 + 3) + 136));
              if ( v1 != 1 )
                ++v3[2];
              goto LABEL_40;
            }
            goto LABEL_39;
          }
LABEL_40:
          ++v2;
          v3 += 8;
          if ( v2 >= *((_BYTE *)&dword_107FED00 + 184) )
            goto LABEL_41;
        }
        if ( v4 > 0x200000 )
        {
          if ( v4 > 0x4000000 )
          {
            v5 = v4 == 0x8000000;
          }
          else
          {
            if ( v4 == 0x4000000 || v4 == 0x1000000 )
              goto LABEL_35;
            v5 = v4 == 0x2000000;
          }
        }
        else
        {
          if ( v4 == 0x200000 )
            goto LABEL_35;
          if ( v4 > 0x20000 )
          {
            if ( v4 == 0x80000 )
              goto LABEL_35;
            v5 = v4 == 0x100000;
          }
          else
          {
            if ( v4 == 0x20000 || v4 == 0x8000 )
              goto LABEL_35;
            v5 = v4 == 0x10000;
          }
        }
        goto LABEL_34;
      }
LABEL_41:
      if ( v11[2] > 500 )
        sub_1001A280(0);
      if ( v1 == 1
        && (unsigned int)(sub_10060900() - *(&dword_107FED00 + 1)) >= *(_DWORD *)(*(&dword_107FED00 + 3) + 156) )
      {
        sub_10019B40(0, (int)&dword_107FED00);
      }
      return;
    case 5:
    case 7:
      if ( (unsigned int)(sub_10060900() - dword_107FED00) >= 0x1388 )
      {
        byte_107FECF8 = 0;
        dword_1080B09C = 0;
        sub_10019B40(0, (int)&dword_107FED00);
      }
      return;
    case 0:
      return;
    default:
      sub_10028BC0("..\\lib\\adl\\iop_upld_mngr.c", 1268, 1, 0);
      return;
  }
}
// 100A04A8: using guessed type int dword_100A04A8[];
// 100A04B4: using guessed type int (__cdecl *off_100A04B4)(int);
// 107FECF8: using guessed type char byte_107FECF8;
// 107FECFC: using guessed type int dword_107FECFC;
// 107FED00: using guessed type int dword_107FED00;
// 107FED0C: using guessed type int dword_107FED0C;
// 1080B09C: using guessed type int dword_1080B09C;

//----- (1001B110) --------------------------------------------------------
char __cdecl sub_1001B110(void *a1, int a2)
{
  sub_10032630((int)a1 + 12);
  return sub_10014160(402, 0x44u, 0xFFFFFFF, a1, 1, a2);
}

//----- (1001B140) --------------------------------------------------------
int __cdecl sub_1001B140(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_10033B00((unsigned __int8 *)(v1 + a1), 0, 4u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 4 );
  return result;
}

//----- (1001B170) --------------------------------------------------------
unsigned int __cdecl sub_1001B170(char *a1)
{
  return sub_10033990(a1, -100, 100, 0, 0);
}

//----- (1001B190) --------------------------------------------------------
int __cdecl sub_1001B190(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 2u, 0, 0);
}

//----- (1001B1B0) --------------------------------------------------------
int __cdecl sub_1001B1B0(_BYTE *a1)
{
  return sub_10033BF0(a1, 0x1CCF0u, 0x2171Eu, 0x2171Eu, 0);
}

//----- (1001B1D0) --------------------------------------------------------
int __cdecl sub_1001B1D0(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 1u, 1u, 0);
}

//----- (1001B1F0) --------------------------------------------------------
int __cdecl sub_1001B1F0(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_10033B00((unsigned __int8 *)(v1 + a1), 0, 4u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 23 );
  return result;
}

//----- (1001B220) --------------------------------------------------------
unsigned int __cdecl sub_1001B220(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10033700((_BYTE *)(a1 + 6), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  if ( sub_10033B00((unsigned __int8 *)(a1 + 12), 0, 0xFFu, 0, a2) == 1 )
    v2 = 1;
  result = sub_10033700((_BYTE *)a1, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 2), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 9), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 3), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 14), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033B00((unsigned __int8 *)(a1 + 7), 0, 0x40u, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 10), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 5), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 11), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033B00((unsigned __int8 *)(a1 + 4), 0, 0x40u, 0x30u, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 13), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 1), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 17), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 24), 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1001B550) --------------------------------------------------------
unsigned int __cdecl sub_1001B550(int a1, int a2)
{
  signed int v2; // ebx@1
  unsigned int result; // eax@1

  v2 = 0;
  result = sub_10033700((_BYTE *)(a1 + 21), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 24), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 26), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 10), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 30), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 31), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 27), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 29), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 28), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 18), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 17), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 8), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 23), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 22), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 13), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 5), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)a1, -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 1), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 2), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 3), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 4), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 15), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 16), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 12), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 14), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 11), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 7), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 20), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 19), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 9), -31, 31, 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700((_BYTE *)(a1 + 25), 0, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033990((char *)(a1 + 6), -31, 31, 0, a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1001B9A0) --------------------------------------------------------
int __cdecl sub_1001B9A0(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_10033B00((unsigned __int8 *)(v1 + a1), 0, 4u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 56 );
  return result;
}

//----- (1001B9D0) --------------------------------------------------------
unsigned int __cdecl sub_1001B9D0(_BYTE *a1)
{
  return sub_100339E0(a1, -1, 5, -1, 0);
}

//----- (1001B9F0) --------------------------------------------------------
int __cdecl sub_1001B9F0(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 5u, 0, 0);
}

//----- (1001BA10) --------------------------------------------------------
int __cdecl sub_1001BA10(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 4u, 2u, 0);
}

//----- (1001BA30) --------------------------------------------------------
int __cdecl sub_1001BA30(_BYTE *a1)
{
  return sub_10033BF0(a1, 0, 2u, 0, 0);
}

//----- (1001BA50) --------------------------------------------------------
int __cdecl sub_1001BA50(int a1)
{
  return sub_100338A0(a1, 0.1, 4.0, COERCE_INT(1.5), 0);
}

//----- (1001BAA0) --------------------------------------------------------
int __cdecl sub_1001BAA0(unsigned __int8 *a1)
{
  int result; // eax@1

  result = sub_1001BA50((int)(a1 + 4));
  if ( !result )
    result = sub_1001BA10(a1);
  return result;
}

//----- (1001BAC0) --------------------------------------------------------
int __cdecl sub_1001BAC0(int a1)
{
  int result; // eax@1

  result = sub_1001B9F0((unsigned __int8 *)(a1 + 1));
  if ( !result )
  {
    result = sub_1001B9F0((unsigned __int8 *)(a1 + 2));
    if ( !result )
    {
      result = sub_1001B9F0((unsigned __int8 *)(a1 + 3));
      if ( !result )
      {
        result = sub_10030FB0((unsigned __int8 *)(a1 + 7));
        if ( !result )
        {
          result = sub_10033700((_BYTE *)(a1 + 5), 0, 0);
          if ( !result )
          {
            result = sub_10033700((_BYTE *)a1, 0, 0);
            if ( !result )
            {
              result = sub_10033700((_BYTE *)(a1 + 4), 0, 0);
              if ( !result )
                result = sub_10033700((_BYTE *)(a1 + 6), 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (1001BB50) --------------------------------------------------------
unsigned int __cdecl sub_1001BB50(int a1)
{
  unsigned int result; // eax@1

  result = sub_1001B9D0((_BYTE *)a1);
  if ( !result )
    result = sub_1001B9D0((_BYTE *)(a1 + 4));
  return result;
}

//----- (1001BB70) --------------------------------------------------------
signed int __cdecl sub_1001BB70(int a1)
{
  int v1; // esi@1
  signed int result; // eax@2
  signed int v3; // esi@4

  v1 = 0;
  while ( 1 )
  {
    result = sub_10033700((_BYTE *)(v1 + a1), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      v3 = 0;
      do
      {
        result = sub_10033700((_BYTE *)(a1 + v3 + 6), 0, 0);
        if ( result )
          break;
        ++v3;
      }
      while ( v3 < 6 );
      return result;
    }
  }
  return result;
}

//----- (1001BBC0) --------------------------------------------------------
unsigned int __cdecl sub_1001BBC0(int a1)
{
  unsigned int result; // eax@1

  result = sub_1001B9D0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1001B9D0((_BYTE *)(a1 + 4));
    if ( !result )
    {
      result = sub_1001B9D0((_BYTE *)(a1 + 8));
      if ( !result )
      {
        result = sub_1001B9D0((_BYTE *)(a1 + 12));
        if ( !result )
          result = sub_10033700((_BYTE *)(a1 + 16), 1, 0);
      }
    }
  }
  return result;
}

//----- (1001BC20) --------------------------------------------------------
int __cdecl sub_1001BC20(_BYTE *a1)
{
  return sub_10033BF0(a1, 0, 0x20u, 2u, 0);
}

//----- (1001BC40) --------------------------------------------------------
unsigned int __cdecl sub_1001BC40(_BYTE *a1)
{
  return sub_100339E0(a1, -1, 4, -1, 0);
}

//----- (1001BC60) --------------------------------------------------------
int __cdecl sub_1001BC60(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 9u, 0, 0);
}

//----- (1001BC80) --------------------------------------------------------
int __cdecl sub_1001BC80(_BYTE *a1)
{
  return sub_10033BF0(a1, 0x81u, 0xFFu, 0xC0u, 0);
}

//----- (1001BCA0) --------------------------------------------------------
signed int __cdecl sub_1001BCA0(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10033BF0(a1, 0, 0xFFFFFFFF, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1001BCD0) --------------------------------------------------------
int __cdecl sub_1001BCD0(_BYTE *a1)
{
  return sub_10033B50(a1, 0, 0xFFFu, 640, 0);
}

//----- (1001BCF0) --------------------------------------------------------
int __cdecl sub_1001BCF0(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10033B50(a1, 0, 0xFFFu, 640, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1001BD30) --------------------------------------------------------
signed int __cdecl sub_1001BD30(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10033B50(a1, 0, 0xFFFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1001BD60) --------------------------------------------------------
int __cdecl sub_1001BD60(int a1, int a2)
{
  signed int v2; // ebx@1
  int result; // eax@3

  v2 = 0;
  if ( sub_1001BCA0((_BYTE *)(a1 + 8), a2) == 1 )
    v2 = 1;
  result = sub_1001BCF0((_BYTE *)(a1 + 2), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001BCF0((_BYTE *)(a1 + 4), a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1003A770((unsigned __int8 *)a1, a2);
  if ( result == 1 )
  {
    v2 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001BCF0((_BYTE *)(a1 + 6), a2);
  if ( result != 1 && !result )
    result = v2;
  return result;
}

//----- (1001BDF0) --------------------------------------------------------
int __cdecl sub_1001BDF0(int a1)
{
  int result; // eax@1

  result = sub_10033B00((unsigned __int8 *)a1, 0, 0x78u, 0, 0);
  if ( !result )
    result = sub_10033B00((unsigned __int8 *)(a1 + 1), 0, 0x78u, 0, 0);
  return result;
}

//----- (1001BE20) --------------------------------------------------------
int __cdecl sub_1001BE20(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 3u, 1u, 0);
}

//----- (1001BE40) --------------------------------------------------------
unsigned int __cdecl sub_1001BE40(int a1)
{
  unsigned int result; // eax@1

  result = sub_100339E0((_BYTE *)a1, -1, 5, -1, 0);
  if ( !result )
    result = sub_100339E0((_BYTE *)(a1 + 4), -1, 5, -1, 0);
  return result;
}

//----- (1001BE70) --------------------------------------------------------
int __cdecl sub_1001BE70(int a1)
{
  int result; // eax@1

  result = sub_100338A0(a1, 0.0, 5.0, COERCE_INT(0.23), 0);
  if ( !result )
  {
    result = sub_100338A0(a1 + 4, -10.0, 10.0, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_100338A0(a1 + 8, 0.0, 12.9, COERCE_INT(0.86000001), 0);
      if ( !result )
      {
        result = sub_100338A0(a1 + 12, 0.0, 5.0, COERCE_INT(0.23), 0);
        if ( !result )
          result = sub_100338A0(a1 + 16, -10.0, 10.0, COERCE_INT(0.0), 0);
      }
    }
  }
  return result;
}

//----- (1001BF60) --------------------------------------------------------
int __cdecl sub_1001BF60(int a1)
{
  int v1; // edi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10033700((_BYTE *)(a1 + v1 + 44), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 6 )
    {
      result = sub_10033B00((unsigned __int8 *)(a1 + 1), 0, 3u, 1u, 0);
      if ( !result )
      {
        result = sub_1001BE40(a1 + 36);
        if ( !result )
        {
          result = sub_100338A0(a1 + 52, -9.9999996e24, 9.9999996e24, COERCE_INT(77.166664), 0);
          if ( !result )
          {
            result = sub_1001BE70(a1 + 8);
            if ( !result )
            {
              result = sub_1001BE40(a1 + 28);
              if ( !result )
              {
                result = sub_10033B50((_BYTE *)(a1 + 2), 0x1F4u, 0x800u, 600, 0);
                if ( !result )
                {
                  result = sub_1001B190((unsigned __int8 *)(a1 + 50));
                  if ( !result )
                  {
                    result = sub_1001BDF0(a1 + 57);
                    if ( !result )
                    {
                      result = sub_10033700((_BYTE *)(a1 + 56), 0, 0);
                      if ( !result )
                        result = sub_1001BE20((unsigned __int8 *)(a1 + 51));
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}

//----- (1001C070) --------------------------------------------------------
signed int __cdecl sub_1001C070(unsigned __int8 *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10033B00(a1, 0, 0xFFu, 0, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1001C0A0) --------------------------------------------------------
int __cdecl sub_1001C0A0(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_1003A8B0(v1);
    if ( result )
      break;
    ++v2;
    v1 += 232;
  }
  while ( v2 < 14 );
  return result;
}

//----- (1001C0D0) --------------------------------------------------------
int __cdecl sub_1001C0D0(int a1)
{
  signed int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  do
  {
    result = sub_10033B00((unsigned __int8 *)(a1 + v1 + 1), 0, 0x20u, 0, 0);
    if ( result )
      break;
    ++v1;
  }
  while ( v1 < 4 );
  return result;
}

//----- (1001C100) --------------------------------------------------------
int __cdecl sub_1001C100(int a1)
{
  int result; // eax@1

  result = sub_10033B00((unsigned __int8 *)(a1 + 3), 0, 0x20u, 0, 0);
  if ( !result )
    result = sub_10033B00((unsigned __int8 *)a1, 0, 0x20u, 0, 0);
  return result;
}

//----- (1001C130) --------------------------------------------------------
int __cdecl sub_1001C130(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 0x64u, 0x64u, 0);
}

//----- (1001C150) --------------------------------------------------------
int __cdecl sub_1001C150(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  int result; // eax@2

  v1 = 0;
  v2 = a1 + 2;
  do
  {
    result = sub_1001C0D0(v2);
    if ( result )
      break;
    ++v1;
    v2 += 39;
  }
  while ( v1 < 255 );
  return result;
}

//----- (1001C1C0) --------------------------------------------------------
int __cdecl sub_1001C1C0(int a1)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = 0;
  while ( 1 )
  {
    result = sub_10033700((_BYTE *)(v1 + a1 + 4), 0, 0);
    if ( result )
      break;
    if ( ++v1 >= 3 )
      return sub_1001C130((unsigned __int8 *)(a1 + 10));
  }
  return result;
}

//----- (1001C1D0) --------------------------------------------------------
int __cdecl sub_1001C1D0(int a1)
{
  return sub_10033B00((unsigned __int8 *)(a1 + 32), 0, 0x20u, 0, 0);
}

//----- (1001C1F0) --------------------------------------------------------
int __cdecl sub_1001C1F0(int a1)
{
  return sub_10033B00((unsigned __int8 *)(a1 + 18), 0, 1u, 0, 0);
}

//----- (1001C210) --------------------------------------------------------
int __cdecl sub_1001C210(int a1)
{
  int result; // eax@1

  result = sub_10033B00((unsigned __int8 *)(a1 + 1), 0xA0u, 0xFFu, 0xA0u, 0);
  if ( !result )
  {
    result = sub_10033B00((unsigned __int8 *)(a1 + 2), 0, 1u, 0, 0);
    if ( !result )
      result = sub_10033B00((unsigned __int8 *)a1, 0xA0u, 0xFFu, 0xA0u, 0);
  }
  return result;
}

//----- (1001C270) --------------------------------------------------------
int __cdecl sub_1001C270(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10033B00(a1, 0, 3u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1001C2A0) --------------------------------------------------------
int __cdecl sub_1001C2A0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10033B00(a1, 0, 6u, 2u, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1001C2D0) --------------------------------------------------------
int __cdecl sub_1001C2D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10033B00(a1, 0, 5u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1001C300) --------------------------------------------------------
signed int __cdecl sub_1001C300(_BYTE *a1, int a2)
{
  bool v2; // zf@1
  signed int result; // eax@1

  v2 = sub_10033BF0(a1, 0, 0xFFFFFFFF, 0xFFFFFFFF, a2) == 1;
  result = 1;
  if ( !v2 )
    result = 0;
  return result;
}

//----- (1001C330) --------------------------------------------------------
int __cdecl sub_1001C330(int a1, int a2)
{
  signed int v2; // ebp@1
  unsigned __int8 v3; // bl@1
  int result; // eax@3

  v2 = 0;
  v3 = 0;
  do
  {
    switch ( v3 )
    {
      case 4u:
      case 5u:
      case 6u:
      case 9u:
      case 0xAu:
        result = sub_10033B00((unsigned __int8 *)(a1 + v3), 0, 0x3Fu, 0, a2);
        break;
      default:
        result = sub_10033B00((unsigned __int8 *)(a1 + v3), 0, 0xFFu, 0xFFu, a2);
        break;
    }
    if ( result == 1 )
    {
      v2 = 1;
    }
    else if ( result )
    {
      return result;
    }
    ++v3;
  }
  while ( v3 < 0xDu );
  return v2;
}

//----- (1001C3E0) --------------------------------------------------------
int __cdecl sub_1001C3E0(int a1)
{
  int result; // eax@1

  result = sub_1003A7C0((_BYTE *)(a1 + 3272));
  if ( !result )
  {
    result = sub_1003A7C0((_BYTE *)(a1 + 3274));
    if ( !result )
    {
      result = sub_1003A7A0((unsigned __int8 *)(a1 + 14));
      if ( !result )
      {
        result = sub_1001C3D0(a1 + 24);
        if ( !result )
        {
          result = sub_1003A7A0((unsigned __int8 *)(a1 + 15));
          if ( !result )
          {
            result = sub_1003A750((unsigned __int8 *)(a1 + 12));
            if ( !result )
              result = sub_1003A7A0((unsigned __int8 *)(a1 + 13));
          }
        }
      }
    }
  }
  return result;
}
// 1001C3D0: using guessed type _DWORD __cdecl sub_1001C3D0(_DWORD);

//----- (1001C460) --------------------------------------------------------
unsigned int __cdecl sub_1001C460(int a1)
{
  unsigned int result; // eax@1

  result = sub_1001B170((char *)(a1 + 3));
  if ( !result )
  {
    result = sub_1001B170((char *)(a1 + 2));
    if ( !result )
    {
      result = sub_1001B170((char *)a1);
      if ( !result )
        result = sub_1001B170((char *)(a1 + 1));
    }
  }
  return result;
}

//----- (1001C4A0) --------------------------------------------------------
unsigned int __cdecl sub_1001C4A0(int a1)
{
  signed int v1; // esi@1
  int v2; // edi@1
  unsigned int result; // eax@2

  v1 = 0;
  v2 = a1;
  while ( 1 )
  {
    result = sub_1001C460(v2);
    if ( result )
      break;
    ++v1;
    v2 += 4;
    if ( v1 >= 3 )
    {
      result = sub_1001B190((unsigned __int8 *)(a1 + 12));
      if ( !result )
        result = sub_1001B1D0((unsigned __int8 *)(a1 + 13));
      return result;
    }
  }
  return result;
}

//----- (1001C4F0) --------------------------------------------------------
int __cdecl sub_1001C4F0(int a1)
{
  int result; // eax@1

  result = sub_1001B1B0((_BYTE *)(a1 + 4));
  if ( !result )
    result = sub_10033B50((_BYTE *)a1, 0, 0x3FFFu, 0x3FFF, 0);
  return result;
}

//----- (1001C520) --------------------------------------------------------
signed int __cdecl sub_1001C520(int a1)
{
  signed int result; // eax@1
  int v2; // edi@23
  int v3; // [sp+10h] [bp-10h]@5
  int v4; // [sp+10h] [bp-10h]@21

  result = sub_100338A0(a1 + 36, -1500.0, 60000.0, COERCE_INT(0.0), 0);
  if ( !result )
  {
    result = sub_100338A0(a1 + 40, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
    if ( !result )
    {
      result = sub_10033700((_BYTE *)a1, 0, 0);
      if ( !result )
      {
        result = sub_10033700((_BYTE *)(a1 + 1), 0, 0);
        if ( !result )
        {
          result = sub_100338A0(a1 + 44, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
          if ( !result )
          {
            result = sub_10033750(a1 + 48, -1.0e25, 1.0e25, v3, COERCE_UNSIGNED_INT64(0.0) >> 32, 0);
            if ( !result )
            {
              result = sub_100338A0(a1 + 56, 0.0, 2000.0, COERCE_INT(0.0), 0);
              if ( !result )
              {
                result = sub_100338A0(a1 + 60, -6.2831855, 6.2831855, COERCE_INT(0.0), 0);
                if ( !result )
                {
                  result = sub_1001B990(a1 + 64);
                  if ( !result )
                  {
                    result = sub_100338A0(a1 + 84, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                    if ( !result )
                    {
                      result = sub_100338A0(a1 + 88, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                      if ( !result )
                      {
                        result = sub_100338A0(a1 + 92, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                        if ( !result )
                        {
                          result = sub_10033B50((_BYTE *)(a1 + 32), 0, 8u, 0, 0);
                          if ( !result )
                          {
                            result = sub_100338A0(a1 + 96, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                            if ( !result )
                            {
                              result = sub_100338A0(a1 + 100, -1500.0, 60000.0, COERCE_INT(0.0), 0);
                              if ( !result )
                              {
                                result = sub_100338A0(a1 + 104, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
                                if ( !result )
                                {
                                  result = sub_100310C0(a1 + 108);
                                  if ( !result )
                                  {
                                    result = sub_10033700((_BYTE *)(a1 + 2), 0, 0);
                                    if ( !result )
                                    {
                                      result = sub_10033700((_BYTE *)(a1 + 3), 0, 0);
                                      if ( !result )
                                      {
                                        result = sub_10033700((_BYTE *)(a1 + 4), 0, 0);
                                        if ( !result )
                                        {
                                          result = sub_10033B50((_BYTE *)(a1 + 34), 0, 7u, 0, 0);
                                          if ( !result )
                                          {
                                            result = sub_10033750(
                                                       a1 + 76,
                                                       0.0,
                                                       604800.0,
                                                       v4,
                                                       COERCE_UNSIGNED_INT64(0.0) >> 32,
                                                       0);
                                            if ( !result )
                                            {
                                              v2 = 0;
                                              while ( 1 )
                                              {
                                                result = sub_10033700((_BYTE *)(a1 + v2 + 20), 0, 0);
                                                if ( result )
                                                  break;
                                                if ( ++v2 >= 12 )
                                                {
                                                  result = sub_100310C0(a1 + 124);
                                                  if ( !result )
                                                  {
                                                    result = sub_100338A0(
                                                               a1 + 152,
                                                               -9.9999996e24,
                                                               9.9999996e24,
                                                               COERCE_INT(0.0),
                                                               0);
                                                    if ( !result )
                                                    {
                                                      result = sub_1001B990(a1 + 140);
                                                      if ( !result )
                                                        result = sub_10033700((_BYTE *)(a1 + 5), 0, 0);
                                                    }
                                                  }
                                                  return result;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 1001B990: using guessed type _DWORD __cdecl sub_1001B990(_DWORD);

//----- (1001C8F0) --------------------------------------------------------
int __cdecl sub_1001C8F0(int a1)
{
  int result; // eax@1

  result = sub_1001BA30((_BYTE *)a1);
  if ( !result )
    result = sub_1001BC80((_BYTE *)(a1 + 4));
  return result;
}

//----- (1001C920) --------------------------------------------------------
unsigned int __cdecl sub_1001C920(int a1)
{
  unsigned int result; // eax@1

  result = sub_1001B9D0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_1001B9D0((_BYTE *)(a1 + 4));
    if ( !result )
      result = sub_1001BC40((_BYTE *)(a1 + 8));
  }
  return result;
}

//----- (1001C950) --------------------------------------------------------
unsigned int __cdecl sub_1001C950(int a1)
{
  unsigned int result; // eax@1

  result = sub_1001B9D0((_BYTE *)a1);
  if ( !result )
    result = sub_1001BC60((unsigned __int8 *)(a1 + 4));
  return result;
}

//----- (1001C970) --------------------------------------------------------
unsigned int __cdecl sub_1001C970(int a1)
{
  unsigned int result; // eax@1

  result = sub_1001B9D0((_BYTE *)a1);
  if ( !result )
  {
    result = sub_10033B00((unsigned __int8 *)(a1 + 8), 0, 0x1Eu, 0x1Eu, 0);
    if ( !result )
      result = sub_1001BC40((_BYTE *)(a1 + 4));
  }
  return result;
}

//----- (1001C9B0) --------------------------------------------------------
void __cdecl __noreturn sub_1001C9B0(int a1)
{
  exit(a1 + 4);
}

//----- (1001CB20) --------------------------------------------------------
signed int __cdecl sub_1001CB20(int a1, int a2)
{
  signed int v2; // ebx@1
  bool v3; // zf@5
  signed int result; // eax@5

  v2 = 0;
  if ( sub_1001C070((unsigned __int8 *)a1, a2) == 1 )
    v2 = 1;
  if ( sub_1001BD30((_BYTE *)(a1 + 2), a2) == 1 )
    v2 = 1;
  v3 = sub_1001C070((unsigned __int8 *)(a1 + 1), a2) == 1;
  result = 1;
  if ( !v3 )
    result = v2;
  return result;
}

//----- (1001CB70) --------------------------------------------------------
int __cdecl sub_1001CB70(_BYTE *a1, int a2)
{
  return sub_10033BF0(a1, 0, 0x1FEu, 0, a2);
}

//----- (1001CB90) --------------------------------------------------------
signed int __usercall sub_1001CB90@<eax>(int a1@<eax>, int a2@<edi>)
{
  int v2; // esi@1
  signed int v3; // ebx@1
  char v4; // al@5
  signed int result; // eax@8
  int v6; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  if ( sub_1001CB20(a1, v6) == 1 )
    v3 = 1;
  if ( a2 == 2 )
  {
    *(_BYTE *)(v2 + 1) = 40;
    v3 = 1;
  }
  v4 = *(_BYTE *)(v2 + 1);
  if ( v4 == 26 || v4 == 12 )
  {
    result = sub_10033B00((unsigned __int8 *)(v2 + 4), 0x20u, 0x20u, 0x20u, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    result = sub_10033700((_BYTE *)(v2 + 37), 0, a2);
    if ( result == 1 )
    {
      v3 = 1;
    }
    else if ( result )
    {
      return result;
    }
    if ( *(_BYTE *)(v2 + 1) == 26 )
      result = sub_1001B550(v2 + 5, a2);
    else
      result = sub_1001B220(v2 + 5, a2);
    if ( result != 1 )
    {
      if ( result )
        return result;
      goto LABEL_25;
    }
    return 1;
  }
  if ( v4 != 40 )
  {
    if ( a2 != 1 )
      return -4;
    *(_BYTE *)(v2 + 1) = 40;
    return 1;
  }
  result = sub_1001C300((_BYTE *)(v2 + 4), a2);
  if ( result != 1 )
LABEL_25:
    result = v3;
  return result;
}

//----- (1001CC60) --------------------------------------------------------
int __usercall sub_1001CC60@<eax>(unsigned __int8 *a1@<eax>, int a2@<esi>)
{
  unsigned __int8 *v2; // edi@1
  signed int v3; // ebx@1
  int result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0

  v2 = a1;
  v3 = 0;
  result = sub_1001C270(a1, v5);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001C2A0(v2 + 1, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033700(v2 + 2, 0, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001C2D0(v2 + 3, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033BF0(v2 + 8, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_10033BF0(v2 + 12, 0, 0x1E61u, 0x4B0u, a2);
  if ( result == 1 )
  {
    v3 = 1;
  }
  else if ( result )
  {
    return result;
  }
  result = sub_1001CB70(v2 + 4, a2);
  if ( result != 1 && !result )
    result = v3;
  return result;
}

//----- (1001CD50) --------------------------------------------------------
int __cdecl sub_1001CD50(unsigned __int8 *a1)
{
  return sub_1001CC60(a1, 0);
}

//----- (1001CD60) --------------------------------------------------------
signed int __cdecl sub_1001CD60(int a1)
{
  return sub_1001CB90(a1, 0);
}

//----- (1001CD70) --------------------------------------------------------
char __cdecl sub_1001CD70(unsigned __int8 a1)
{
  int v1; // eax@1
  _BYTE *v2; // ecx@2
  signed int v3; // eax@2
  signed __int64 v4; // rtt@2

  LOBYTE(v1) = a1;
  if ( a1 < 0x34u )
  {
    v2 = (_BYTE *)(a1 + dword_109FFDCC + 14618950);
    v3 = *v2 + 1;
    v4 = v3;
    v1 = v3 / 255;
    *v2 = v4 % 255;
  }
  return v1;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001CDA0) --------------------------------------------------------
int __thiscall sub_1001CDA0(void *this)
{
  unsigned __int8 v1; // bl@1
  char *v2; // eax@2
  unsigned __int8 v3; // bl@3
  char *v4; // eax@4
  int result; // eax@4
  unsigned __int8 v6; // [sp+4h] [bp-4h]@1
  unsigned __int8 v7; // [sp+4h] [bp-4h]@3

  byte_1093D408 = 0;
  v1 = 0;
  dword_1093D440 = (sub_1002C5E0(this) & 0xC) != 12 ? 5000 : 250;
  v6 = 0;
  do
  {
    v2 = sub_1001E4E0(v6);
    sub_10060A60(*((_DWORD *)v2 + 3), 3000);
    v6 = ++v1;
  }
  while ( v1 < 0x12u );
  sub_1001E970();
  v3 = 0;
  v7 = 0;
  do
  {
    v4 = sub_1001E4E0(v7);
    result = sub_10060A00(*((_DWORD *)v4 + 3));
    v7 = ++v3;
  }
  while ( v3 < 0x12u );
  return result;
}
// 1093D408: using guessed type char byte_1093D408;
// 1093D440: using guessed type int dword_1093D440;

//----- (1001CE30) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001CE30(unsigned __int8 a1, char a2)
{
  unsigned __int8 result; // al@1

  result = a1;
  if ( a1 < 4u )
  {
    result = a1;
    byte_1093D444[a1] = a2;
  }
  return result;
}

//----- (1001CE50) --------------------------------------------------------
char __cdecl sub_1001CE50(int a1)
{
  int v1; // edi@1
  int v2; // ebp@1
  char v3; // bl@1
  size_t v4; // eax@1
  _DWORD *v5; // ecx@1
  signed int v6; // edx@1
  char result; // al@4
  int v8; // esi@5
  int v9; // esi@5
  char v10; // cl@5
  int *v11; // eax@7
  int v12; // edi@7
  bool v13; // zf@7
  char v14; // [sp+Fh] [bp-15h]@5
  int v15; // [sp+10h] [bp-14h]@1
  int v16; // [sp+14h] [bp-10h]@8
  int v17; // [sp+18h] [bp-Ch]@5
  int v18; // [sp+1Ch] [bp-8h]@5
  int *v19; // [sp+20h] [bp-4h]@7

  v1 = a1;
  v15 = *(_DWORD *)a1;
  v2 = 0;
  sub_10060950();
  v3 = -2;
  v4 = 0;
  v5 = (_DWORD *)(a1 + 20);
  v6 = 15;
  do
  {
    v4 += *v5;
    v5 = (_DWORD *)((char *)v5 + 6);
    --v6;
  }
  while ( v6 );
  if ( !v4 )
    return 1;
  v8 = *(_DWORD *)(a1 + 4);
  v17 = *(_DWORD *)(a1 + 14);
  v9 = v8 - v4;
  v18 = v15 + v17;
  memcpy_0((void *)(v9 + v15), (const void *)(v15 + v17), v4);
  v10 = 1;
  v14 = 1;
  while ( 1 )
  {
    v11 = (int *)(v1 + 6 * (unsigned __int8)v10 + 14);
    v12 = *v11;
    v13 = *v11 == 0;
    v19 = v11;
    if ( v13 )
      goto LABEL_12;
    v16 = v9 - v17 - v2 < 0 ? 0 : v9 - v17 - v2;
    if ( !v16 )
      sub_10028BC0("..\\lib\\acl\\iop\\wx\\iop_wx.c", 653, 0, 0);
    v3 = sub_10036BC0(v2 + v18, &v16, v9 + v15, v12, (int)&unk_10931CC0, 46920, 15);
    if ( v3 != 1 )
      break;
    v10 = v14;
    v2 += v16;
    *v19 = v16;
    v9 += v12;
LABEL_12:
    v14 = ++v10;
    if ( (unsigned __int8)v10 >= 0x10u )
      goto LABEL_15;
    v1 = a1;
  }
  sub_10028BC0("..\\lib\\acl\\iop\\wx\\iop_wx.c", 668, 0, 0);
LABEL_15:
  if ( v3 == 1 )
    return 1;
  result = 0;
  *(_BYTE *)(a1 + 10) = 0;
  return result;
}

//----- (1001CF90) --------------------------------------------------------
char __usercall sub_1001CF90@<al>(unsigned __int8 a1@<al>)
{
  unsigned __int8 v1; // bl@1
  unsigned __int8 v3; // [sp+7h] [bp-1h]@1

  v3 = sub_1001E610(a1);
  v1 = 0;
  while ( sub_1001E610(*(_BYTE *)(156 * v1 + dword_109FFDCC + 444)) != v3 )
  {
    if ( ++v1 >= 1u )
      return 1;
  }
  return 0;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001CFE0) --------------------------------------------------------
char __cdecl sub_1001CFE0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  signed int v3; // edi@1
  _DWORD *v4; // esi@3
  char *i; // eax@3
  int v6; // ebp@5
  unsigned int v7; // edi@5
  int v8; // ecx@6
  char result; // al@11
  unsigned __int8 v10; // [sp+Ch] [bp-8h]@3
  unsigned __int8 v11; // [sp+Ch] [bp-8h]@10
  signed int v12; // [sp+10h] [bp-4h]@3

  v1 = a1;
  memset((void *)(a1 + 436), 0, 0x9Cu);
  memset((void *)(a1 + 592), 0, 0x410u);
  memset((void *)(a1 + 1632), 0, 0x1AD0u);
  v2 = a1 + 8496;
  v3 = 4;
  do
  {
    sub_1002C120(v2, "RECEIVER FAILURE", 128);
    v2 += 32;
    --v3;
  }
  while ( v3 );
  v12 = 0;
  v10 = 0;
  v4 = (_DWORD *)(a1 + 608);
  for ( i = sub_1001E4E0(0); ; i = sub_1001E4E0(v10) )
  {
    *(v4 - 1) = v3;
    *v4 = 132 * v3 + v1 + 1632;
    v6 = v1 + *((_DWORD *)i + 5);
    v7 = 0;
    if ( i[1] )
    {
      v8 = 0;
      do
      {
        v8 += 132;
        *(_DWORD *)(v8 + *v4 - 120) = *((_DWORD *)i + 5) + v7 * *((_DWORD *)i + 2);
        *(_DWORD *)(v8 + *v4 - 108) = v6 + v7 * *((_DWORD *)i + 2);
        *(_BYTE *)(v8 + *v4 - 116) = v10;
        *(_DWORD *)(v8 + *v4 - 112) = *((_DWORD *)i + 2);
        ++v7;
      }
      while ( v7 < (unsigned __int8)i[1] );
      v1 = a1;
    }
    v12 += (unsigned __int8)i[1];
    v4 += 5;
    if ( ++v10 >= 0x34u )
      break;
    v3 = v12;
  }
  *(_DWORD *)(v1 + 436) = &unk_10810A08;
  *(_BYTE *)(v1 + 444) = -1;
  *(_DWORD *)(v1 + 440) = 1184440;
  v11 = 0;
  do
  {
    sub_1001EAF0(v1, v11);
    result = v11++ + 1;
  }
  while ( v11 < 4u );
  return result;
}

//----- (1001D140) --------------------------------------------------------
char sub_1001D140()
{
  int v0; // esi@1
  char v1; // bl@2
  unsigned int v2; // edi@2
  __int16 v3; // ax@3
  unsigned __int8 v4; // bl@3
  int v5; // edi@7
  unsigned __int8 v6; // al@7
  unsigned int v7; // edx@11
  char v9; // [sp+Bh] [bp-9h]@7
  unsigned __int8 v10; // [sp+Ch] [bp-8h]@7
  char *v11; // [sp+10h] [bp-4h]@7

  v0 = dword_109FFDCC + 436;
  if ( *(_BYTE *)(dword_109FFDCC + 444) < 0xFFu )
  {
    v7 = sub_10060900() + 300000;
    LOBYTE(v3) = 5 * *(_BYTE *)(v0 + 8);
    if ( *(_DWORD *)(dword_109FFDCC + 20 * *(_BYTE *)(v0 + 8) + 596) > v7 )
      *(_BYTE *)(v0 + 8) = -1;
  }
  else
  {
    v1 = byte_1093D408 + 1;
    v2 = 0;
    while ( 1 )
    {
      v3 = (unsigned __int8)v1 / 52;
      v4 = (unsigned __int8)v1 % 52;
      if ( byte_1093D409[v4] )
      {
        LOBYTE(v3) = sub_1001CF90(v4);
        if ( (_BYTE)v3 )
          break;
      }
      ++v2;
      v1 = v4 + 1;
      if ( v2 >= 0x34 )
        return v3;
    }
    v5 = dword_109FFDCC + 20 * v4 + 592;
    v11 = sub_1001E4E0(v4);
    v6 = sub_1001E610(v4);
    *(_BYTE *)(v0 + 11) = 0;
    v10 = v6;
    *(_BYTE *)(v0 + 8) = *(_BYTE *)(132 * *(_BYTE *)v5 + *(_DWORD *)(v5 + 16) + 16);
    *(_BYTE *)(v0 + 9) = 1;
    memset((void *)(v0 + 12), 0, 0x66u);
    *(_DWORD *)(v0 + 114) = 0;
    *(_DWORD *)(v0 + 118) = 0;
    *(_DWORD *)(v0 + 122) = 0;
    *(_DWORD *)(v0 + 126) = 0;
    *(_DWORD *)(v0 + 130) = 0;
    *(_DWORD *)(v0 + 134) = 0;
    *(_DWORD *)(v0 + 138) = 0;
    *(_DWORD *)(v0 + 142) = 0;
    v9 = byte_1093D444[v10];
    if ( v9 != byte_109FFDC8[sub_1001E610(v4)] && v9 != 2 )
      byte_109FFDC8[v10] = v9;
    LOBYTE(v3) = sub_1001EB50(v10, v11[16], v5);
    byte_1093D408 = v4;
  }
  return v3;
}
// 1093D408: using guessed type char byte_1093D408;
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001D2B0) --------------------------------------------------------
char __usercall sub_1001D2B0@<al>(unsigned __int8 a1@<al>, char a2@<cl>)
{
  int v2; // eax@1
  bool v3; // zf@2

  LOBYTE(v2) = sub_1001E550(a2, a1);
  if ( (_BYTE)v2 != -1 )
  {
    v2 = (unsigned __int8)v2;
    v3 = byte_1093D409[(unsigned __int8)v2] == -1;
    ++byte_1093D409[v2];
    if ( v3 )
      byte_1093D409[v2] = -1;
    LOBYTE(v2) = sub_1001D140();
  }
  return v2;
}

//----- (1001D2E0) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001D2E0(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 result; // al@1
  int v3; // ebp@2
  int v4; // esi@3
  char *v5; // ebx@3
  unsigned __int8 v6; // [sp+0h] [bp-8h]@1
  unsigned __int8 v7; // [sp+4h] [bp-4h]@3

  result = a1;
  v6 = a1;
  if ( a1 <= a2 )
  {
    v3 = 20 * a1;
    do
    {
      v4 = dword_109FFDCC + v3 + 592;
      v5 = sub_1001E4E0(v6);
      v7 = sub_1001E610(v6);
      if ( !*(_BYTE *)(v4 + 1) && sub_1001E640(v5[16], v7) )
      {
        if ( v6 != a1 )
          sub_10060B90(25);
        sub_1001D2B0(v7, v5[16]);
        *(_BYTE *)(v4 + 2) = 15;
      }
      result = v6 + 1;
      v3 += 20;
      ++v6;
    }
    while ( v6 <= a2 );
  }
  return result;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001D390) --------------------------------------------------------
char __cdecl sub_1001D390(int a1, int a2)
{
  int v2; // edi@1
  unsigned int v3; // eax@1
  int v4; // ebp@1
  int v5; // ebx@1
  int v6; // ecx@12
  const void *v7; // ST24_4@16
  unsigned __int8 v8; // al@16
  void *v9; // ecx@18
  int v10; // edx@23
  unsigned __int8 v11; // al@24
  char v13; // [sp+13h] [bp-9h]@1
  size_t v14; // [sp+14h] [bp-8h]@9
  signed int v15; // [sp+18h] [bp-4h]@11

  v2 = a2;
  v3 = 0;
  v4 = *(_DWORD *)(a2 + 16) + 132 * (unsigned __int8)((*(_BYTE *)a2 + 1) % *(_BYTE *)(a1 + 1));
  v13 = (*(_BYTE *)a2 + 1) % *(_BYTE *)(a1 + 1);
  v5 = dword_109FFDCC + 436;
  while ( *(_BYTE *)(v4 + 16) != *(_BYTE *)(v5 + 8) )
  {
    ++v3;
    v5 += 156;
    if ( v3 >= 1 )
      return v3;
  }
  if ( v3 < 1 )
  {
    if ( *(_BYTE *)(v5 + 9) )
    {
      *(_DWORD *)(v5 + 152) = sub_10060900();
      *(_BYTE *)(v5 + 9) = 0;
    }
    if ( *(_BYTE *)(v5 + 10) )
    {
      *(_BYTE *)(a2 + 2) = 0;
      v14 = 0;
      if ( byte_109FFDC8[sub_1001E610(*(_BYTE *)a1)] )
        *(_BYTE *)(v5 + 10) = sub_1001CE50(v5);
      v3 = v5 + 26;
      v15 = 4;
      do
      {
        v6 = *(_DWORD *)(v3 - 6) + *(_DWORD *)(v3 - 12);
        v3 += 24;
        v14 += *(_DWORD *)(v3 - 24) + *(_DWORD *)(v3 - 18) + v6;
        --v15;
      }
      while ( v15 );
      if ( *(_BYTE *)(v5 + 10) )
      {
        if ( v14 > *(_DWORD *)(a1 + 8) )
        {
          LOBYTE(v3) = sub_10028BC0("..\\lib\\acl\\iop\\wx\\iop_wx.c", 814, 0, 0);
          *(_BYTE *)(a2 + 1) = 0;
          *(_BYTE *)(v5 + 10) = 0;
          *(_BYTE *)(v5 + 8) = -1;
          return v3;
        }
        v7 = *(const void **)v5;
        v8 = sub_1001E610(*(_BYTE *)a1);
        if ( !sub_1001E500(*(_BYTE *)(a1 + 16), v8, v5 + 12, (int)v7) )
        {
          LOBYTE(v3) = sub_10028BC0("..\\lib\\acl\\iop\\wx\\iop_wx.c", 819, 0, 0);
          *(_BYTE *)(a2 + 1) = 0;
          *(_BYTE *)(v5 + 10) = 0;
          *(_BYTE *)(v5 + 8) = -1;
          return v3;
        }
        sub_10060A60(*(_DWORD *)(a1 + 12), 30000);
        *(_BYTE *)(v4 + 17) = 1;
        qmemcpy((void *)(v4 + 28), (const void *)(v5 + 12), 0x64u);
        v9 = *(void **)(v4 + 24);
        *(_WORD *)(v4 + 128) = *(_WORD *)(v5 + 112);
        memcpy(v9, *(const void **)v5, v14);
        v2 = a2;
        *(_BYTE *)(v4 + 8) = sub_1001E8E0(*(_BYTE *)a1);
        *(_BYTE *)a2 = v13;
        sub_10060A00(*(_DWORD *)(a1 + 12));
        sub_1001FBF0(a1, *(_BYTE *)a2);
        LOBYTE(v3) = sub_1001CD70(*(_BYTE *)a1);
        byte_1093D409[*(_BYTE *)a1] = 0;
      }
      *(_BYTE *)(v2 + 1) = 0;
      *(_BYTE *)(v5 + 10) = 0;
      *(_BYTE *)(v5 + 8) = -1;
      return v3;
    }
    v3 = sub_10060900() - *(_DWORD *)(v5 + 152);
    if ( v3 >= 0x2710 || *(_BYTE *)(v5 + 11) == 1 )
    {
      ++*(_BYTE *)(a2 + 2);
      LOBYTE(v3) = -1;
      *(_BYTE *)(a2 + 1) = 0;
      *(_BYTE *)(v5 + 8) = -1;
      if ( *(_BYTE *)(a2 + 2) <= 0x14u )
      {
        v11 = sub_1001E610(*(_BYTE *)a1);
        LOBYTE(v3) = sub_1001D2B0(v11, *(_BYTE *)(a1 + 16));
      }
      else
      {
        v10 = *(_BYTE *)a1;
        *(_BYTE *)(v5 + 8) = -1;
        byte_1093D409[v10] = 0;
      }
    }
  }
  return v3;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001D5E0) --------------------------------------------------------
char __thiscall sub_1001D5E0(void *this)
{
  void *v1; // ecx@2
  int v2; // esi@4
  int v3; // esi@5
  char *v4; // eax@5
  char *v5; // edi@5
  int v6; // ebp@7
  bool v7; // zf@7
  int v8; // esi@10
  char v9; // bl@10
  char v10; // al@10
  unsigned int v11; // edx@17
  bool v12; // cf@18
  char v14; // [sp+3h] [bp-15h]@1
  unsigned __int8 v15; // [sp+4h] [bp-14h]@4
  int v16; // [sp+8h] [bp-10h]@10
  int v17; // [sp+Ch] [bp-Ch]@7
  int v18; // [sp+10h] [bp-8h]@4
  int v19; // [sp+14h] [bp-4h]@5

  v14 = 0;
  if ( sub_1002C5E0(this) == 4 && sub_10060900() - dword_1093D448 > (unsigned int)dword_1093D440 )
  {
    sub_1001E900(v1);
    dword_1093D448 = sub_10060900();
  }
  v2 = 0;
  v15 = 0;
  v18 = 0;
  do
  {
    v3 = v2 + dword_109FFDCC + 592;
    v19 = v3;
    v4 = sub_1001E4E0(v15);
    v5 = v4;
    if ( *(_BYTE *)(v3 + 1) )
      sub_1001D390((int)v4, v3);
    v6 = 0;
    v7 = v5[1] == 0;
    v17 = 0;
    if ( !v7 )
    {
      while ( 1 )
      {
        v8 = v6 + *(_DWORD *)(v3 + 16);
        v9 = sub_1001E6F0(v15, v8, (unsigned int *)&v16);
        v10 = *(_BYTE *)(v8 + 1);
        if ( (v10 == 0) != (v9 == 0) )
          v14 = 1;
        if ( v10 != v9 || *(_DWORD *)(v8 + 4) != v16 )
        {
          sub_10060A60(*((_DWORD *)v5 + 3), 10);
          *(_BYTE *)(v8 + 1) = v9;
          *(_DWORD *)(v8 + 4) = v16;
          sub_10060A00(*((_DWORD *)v5 + 3));
        }
        if ( v14 )
          sub_1001CD70(*v5);
        v11 = (unsigned __int8)v5[1];
        v6 += 132;
        if ( ++v17 >= v11 )
          break;
        v3 = v19;
      }
    }
    v2 = v18 + 20;
    v12 = (unsigned __int8)(v15++ + 1) < 0x34u;
    v18 += 20;
  }
  while ( v12 );
  return sub_1001D140();
}
// 1093D440: using guessed type int dword_1093D440;
// 1093D448: using guessed type int dword_1093D448;
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001D740) --------------------------------------------------------
char __cdecl sub_1001D740(char a1, unsigned int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // esi@1
  unsigned int v5; // edx@1
  int v6; // eax@1
  unsigned int v8; // edi@7
  _BYTE *v9; // ecx@8
  unsigned int v10; // ecx@18
  int v11; // eax@19
  unsigned int v12; // [sp+8h] [bp-8h]@6
  char v13[4]; // [sp+Ch] [bp-4h]@6

  v3 = a3;
  v4 = a2;
  v5 = *(_DWORD *)(a2 + 8);
  v6 = a3 + v5 + *(_DWORD *)(a2 + 2);
  if ( *(_WORD *)(a3 + 18) > 0xDACu )
    return 0;
  if ( a1 == 1 )
  {
    if ( !*(_BYTE *)(a3 + 11) )
    {
      if ( *(_BYTE *)(a3 + 8) != 1 )
        return 0;
      sub_10032600(v13);
      sub_1002C6F0((int)&a3, *(unsigned int *)v13);
      HIWORD(a2) = HIWORD(a3);
      LOBYTE(a2) = a3;
      BYTE1(a2) = 1;
      sub_1002C820((int *)&v12, a2);
      v12 -= 86400;
      sub_1002C6F0((int)&a2, v12);
      *(_BYTE *)(v3 + 11) = BYTE1(a2);
    }
    v8 = 0;
    if ( *(_DWORD *)(v4 + 8) / 3u )
    {
      v9 = (_BYTE *)(v3 + *(_DWORD *)(v4 + 2) + 2);
      do
      {
        if ( *(_WORD *)(v4 + 98) == 1 )
        {
          if ( *v9 )
          {
            if ( *v9 == 1 )
            {
              *v9 = 0;
            }
            else if ( *v9 > 0x18u )
            {
              return 0;
            }
          }
          else
          {
            *v9 = 24;
          }
        }
        ++v8;
        v9 += 3;
      }
      while ( v8 < *(_DWORD *)(v4 + 8) / 3u );
    }
    v5 = *(_DWORD *)(v4 + 8);
    v6 = v3 + v5 + *(_DWORD *)(v4 + 2);
  }
  if ( 4 * *(_WORD *)(v3 + 20) == *(_DWORD *)(v4 + 14) )
  {
    v10 = 0;
    if ( !*(_WORD *)(v3 + 20) )
      return 1;
    v11 = v6 + 2;
    while ( *(_BYTE *)(v11 - 2)
          + ((*(_BYTE *)(v11 - 1) + ((*(_BYTE *)v11 + ((unsigned int)*(_BYTE *)(v11 + 1) << 8)) << 8)) << 8) <= v5 )
    {
      ++v10;
      v11 += 4;
      if ( v10 >= *(_WORD *)(v3 + 20) )
        return 1;
    }
  }
  return 0;
}

//----- (1001D8B0) --------------------------------------------------------
bool __cdecl sub_1001D8B0(int a1, int a2, int a3)
{
  return 26 * *(_WORD *)(a3 + 3) == *(_DWORD *)(a2 + 8);
}

//----- (1001D8D0) --------------------------------------------------------
char __cdecl sub_1001D8D0(int a1, int a2, int a3)
{
  unsigned int v3; // edx@1
  unsigned int v4; // ebx@1
  char result; // al@2
  unsigned int v6; // esi@3
  unsigned int *v7; // eax@4
  unsigned int v8; // ecx@5

  v3 = *(_WORD *)(a3 + 3);
  v4 = 0;
  if ( 20 * v3 == *(_DWORD *)(a2 + 8) )
  {
    v6 = 0;
    if ( *(_WORD *)(a3 + 3) )
    {
      v7 = (unsigned int *)(a3 + *(_DWORD *)(a2 + 2) + 16);
      while ( 1 )
      {
        v8 = *v7 + *(v7 - 1);
        if ( v8 > *(_DWORD *)(a2 + 14) || *v7 < v4 )
          break;
        ++v6;
        v7 += 5;
        v4 = v8;
        if ( v6 >= v3 )
          goto LABEL_8;
      }
      result = 0;
    }
    else
    {
LABEL_8:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001D930) --------------------------------------------------------
char __cdecl sub_1001D930(int a1, int a2, int a3)
{
  unsigned int v3; // ebx@1
  char result; // al@2
  unsigned int v5; // edx@3
  unsigned int *v6; // eax@4
  unsigned int v7; // ecx@5

  v3 = 0;
  if ( 77 * *(_WORD *)(a3 + 3) == *(_DWORD *)(a2 + 8) )
  {
    v5 = 0;
    if ( *(_WORD *)(a3 + 3) )
    {
      v6 = (unsigned int *)(a3 + *(_DWORD *)(a2 + 2) + 73);
      while ( 1 )
      {
        v7 = *v6 + *(v6 - 1);
        if ( v7 > *(_DWORD *)(a2 + 14) || *v6 < v3 )
          break;
        ++v5;
        v6 = (unsigned int *)((char *)v6 + 77);
        v3 = v7;
        if ( v5 >= *(_WORD *)(a3 + 3) )
          goto LABEL_8;
      }
      result = 0;
    }
    else
    {
LABEL_8:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001D990) --------------------------------------------------------
char __cdecl sub_1001D990(int a1, int a2, int a3)
{
  unsigned int v3; // esi@1
  char result; // al@2
  unsigned int v5; // edx@3
  unsigned int v6; // ecx@5
  int v7; // eax@6

  v3 = *(_DWORD *)(a2 + 8);
  if ( *(_WORD *)(a3 + 15) <= 0x7D0u )
  {
    v5 = *(_WORD *)(a3 + 17);
    if ( 4 * v5 == *(_DWORD *)(a2 + 14) )
    {
      v6 = 0;
      if ( *(_WORD *)(a3 + 17) )
      {
        v7 = a3 + v3 + *(_DWORD *)(a2 + 2) + 2;
        while ( *(_BYTE *)(v7 - 2)
              + ((*(_BYTE *)(v7 - 1) + ((*(_BYTE *)v7 + ((unsigned int)*(_BYTE *)(v7 + 1) << 8)) << 8)) << 8) <= v3 )
        {
          ++v6;
          v7 += 4;
          if ( v6 >= v5 )
            goto LABEL_9;
        }
        result = 0;
      }
      else
      {
LABEL_9:
        result = 1;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001DA10) --------------------------------------------------------
char __cdecl sub_1001DA10(int a1, int a2, int a3)
{
  unsigned __int16 v3; // dx@1
  unsigned __int16 v4; // si@2
  int v5; // ecx@3
  char result; // al@5
  unsigned __int16 v7; // si@6
  unsigned __int16 v8; // di@7
  unsigned int v9; // ecx@8
  _DWORD *v10; // edx@8

  v3 = *(_WORD *)(a3 + 17);
  if ( v3 && (v4 = *(_WORD *)(a3 + 15)) != 0 && (v5 = *(_DWORD *)(a2 + 8)) != 0 && 2 * v3 * v4 != v5 )
  {
    result = 0;
  }
  else
  {
    v7 = *(_WORD *)(a3 + 33);
    if ( v7 && (v8 = *(_WORD *)(a3 + 31)) != 0 )
    {
      v9 = 2;
      v10 = (_DWORD *)(a2 + 14);
      while ( !*v10 || 2 * v7 * v8 == *v10 )
      {
        ++v9;
        v10 = (_DWORD *)((char *)v10 + 6);
        if ( v9 > 0xF )
          goto LABEL_12;
      }
      result = 0;
    }
    else
    {
LABEL_12:
      result = 1;
    }
  }
  return result;
}

//----- (1001DAA0) --------------------------------------------------------
bool __cdecl sub_1001DAA0(int a1, int a2, int a3)
{
  return 41 * *(_BYTE *)(a3 + 3) == *(_DWORD *)(a2 + 8);
}

//----- (1001DAC0) --------------------------------------------------------
bool __cdecl sub_1001DAC0(int a1, int a2, int a3)
{
  return 5 * *(_WORD *)(a3 + 3) == *(_DWORD *)(a2 + 8);
}

//----- (1001DAE0) --------------------------------------------------------
char __cdecl sub_1001DAE0(char a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ecx@1
  int v5; // edx@1
  int v6; // ebp@1
  int v8; // edi@4
  unsigned int v9; // edx@6
  unsigned int v10; // ecx@6
  int v11; // eax@8
  _DWORD *v12; // ecx@12
  int v13; // edx@12
  unsigned int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@3

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(_DWORD *)(a2 + 2);
  v6 = a3 + v4 + v5;
  v14 = 0;
  if ( 17 * *(_BYTE *)(a3 + 3) != v4 )
    return 0;
  v15 = 0;
  if ( *(_BYTE *)(a3 + 3) )
  {
    v8 = v5 + a3 + 1;
    while ( 1 )
    {
      v9 = *(_DWORD *)(v8 + 4);
      v10 = *(_DWORD *)(v3 + 14);
      if ( v9 + *(_DWORD *)v8 > v10 )
        break;
      if ( v9 < v14 )
        break;
      v14 = v9 + *(_DWORD *)v8;
      v11 = *(_DWORD *)(v8 + 8);
      if ( v11 + *(_DWORD *)(v8 + 12) > v10 )
      {
        if ( v11 )
          break;
      }
      if ( !a1 && *(_DWORD *)v8 >> 3 )
      {
        v12 = (_DWORD *)(v9 + v6 + 4);
        v13 = *(_DWORD *)v8 >> 3;
        do
        {
          if ( *v12 > 0 )
            *v12 = -*v12;
          v12 += 2;
          --v13;
        }
        while ( v13 );
      }
      v8 += 17;
      if ( ++v15 >= (unsigned int)*(_BYTE *)(a3 + 3) )
        return 1;
      v3 = a2;
    }
    return 0;
  }
  return 1;
}

//----- (1001DBB0) --------------------------------------------------------
char __cdecl sub_1001DBB0(int a1, int a2, int a3)
{
  unsigned int v3; // edx@1
  unsigned int v4; // ebx@1
  char result; // al@2
  unsigned int v6; // esi@3
  unsigned int *v7; // eax@4
  unsigned int v8; // ecx@5

  v3 = *(_BYTE *)(a3 + 3);
  v4 = 0;
  if ( 20 * v3 == *(_DWORD *)(a2 + 8) )
  {
    v6 = 0;
    if ( *(_BYTE *)(a3 + 3) )
    {
      v7 = (unsigned int *)(a3 + *(_DWORD *)(a2 + 2) + 12);
      while ( 1 )
      {
        v8 = *v7 + *(v7 - 1);
        if ( v8 > *(_DWORD *)(a2 + 14) || *v7 < v4 )
          break;
        ++v6;
        v7 += 5;
        v4 = v8;
        if ( v6 >= v3 )
          goto LABEL_8;
      }
      result = 0;
    }
    else
    {
LABEL_8:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001DC10) --------------------------------------------------------
bool __cdecl sub_1001DC10(int a1, int a2, int a3)
{
  return 46 * *(_WORD *)(a3 + 3) == *(_DWORD *)(a2 + 8);
}

//----- (1001DC30) --------------------------------------------------------
char __cdecl sub_1001DC30(int a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  _WORD *v4; // ecx@1

  v3 = 0;
  v4 = (_WORD *)(a3 + 16387);
  while ( *v4 <= 0x400u )
  {
    ++v3;
    v4 += 8193;
    if ( v3 >= 0xA )
      return 1;
  }
  return 0;
}

//----- (1001DC60) --------------------------------------------------------
char __cdecl sub_1001DC60(char a1, int a2, int a3)
{
  int v3; // edx@1
  int v4; // eax@1
  unsigned int v5; // esi@1
  int v6; // ebx@1
  int v8; // ecx@4
  int v9; // eax@5
  int v10; // eax@9
  int v11; // eax@13
  int v12; // eax@17
  int v13; // eax@21
  int v14; // eax@25
  int v15; // eax@29
  int v16; // eax@33
  unsigned int v17; // eax@37
  unsigned int v18; // edi@38
  int v19; // ebp@40
  unsigned int v20; // edi@42
  int v21; // eax@43
  int v22; // edx@49
  unsigned int v23; // [sp+10h] [bp-8h]@1
  unsigned int v24; // [sp+14h] [bp-4h]@3

  v3 = *(_DWORD *)(a2 + 2);
  v4 = *(_DWORD *)(a2 + 8);
  v5 = 0;
  v6 = a3 + v4 + v3;
  v23 = 0;
  if ( 88 * *(_WORD *)(a3 + 3) != v4 )
    return 0;
  v24 = 0;
  if ( *(_WORD *)(a3 + 3) )
  {
    v8 = v3 + a3 + 12;
    do
    {
      v9 = *(_DWORD *)(v8 - 12);
      if ( v9 )
      {
        if ( *(_DWORD *)(v8 - 8) < v5 )
          return 0;
        if ( v9 )
          v5 = v9 + *(_DWORD *)(v8 - 8);
      }
      v10 = *(_DWORD *)(v8 - 4);
      if ( v10 )
      {
        if ( *(_DWORD *)v8 < v5 )
          return 0;
        if ( v10 )
          v5 = v10 + *(_DWORD *)v8;
      }
      v11 = *(_DWORD *)(v8 + 4);
      if ( v11 )
      {
        if ( *(_DWORD *)(v8 + 8) < v5 )
          return 0;
        if ( v11 )
          v5 = v11 + *(_DWORD *)(v8 + 8);
      }
      v12 = *(_DWORD *)(v8 + 12);
      if ( v12 )
      {
        if ( *(_DWORD *)(v8 + 16) < v5 )
          return 0;
        if ( v12 )
          v5 = v12 + *(_DWORD *)(v8 + 16);
      }
      v13 = *(_DWORD *)(v8 + 20);
      if ( v13 )
      {
        if ( *(_DWORD *)(v8 + 24) < v5 )
          return 0;
        if ( v13 )
          v5 = v13 + *(_DWORD *)(v8 + 24);
      }
      v14 = *(_DWORD *)(v8 + 28);
      if ( v14 )
      {
        if ( *(_DWORD *)(v8 + 32) < v5 )
          return 0;
        if ( v14 )
          v5 = v14 + *(_DWORD *)(v8 + 32);
      }
      v15 = *(_DWORD *)(v8 + 36);
      if ( v15 )
      {
        if ( *(_DWORD *)(v8 + 40) < v5 )
          return 0;
        if ( v15 )
          v5 = v15 + *(_DWORD *)(v8 + 40);
      }
      v16 = *(_DWORD *)(v8 + 44);
      if ( v16 )
      {
        if ( *(_DWORD *)(v8 + 48) < v5 )
          return 0;
        if ( v16 )
          v5 = v16 + *(_DWORD *)(v8 + 48);
      }
      v17 = *(_DWORD *)(a2 + 14);
      if ( v5 > v17 )
        return 0;
      v18 = *(_DWORD *)(v8 + 68);
      if ( v18 )
      {
        if ( *(_DWORD *)(v8 + 72) < v23 )
          return 0;
      }
      v19 = *(_DWORD *)(v8 + 72);
      v23 = v18 + v19;
      if ( v18 + v19 > v17 )
        return 0;
      if ( !a1 )
      {
        v20 = v18 / 0x13;
        if ( v20 )
        {
          v21 = v6 + v19 + 6;
          do
          {
            if ( !*(_BYTE *)(v21 - 6) )
              goto LABEL_55;
            if ( *(_BYTE *)(v21 - 6) == 1 )
            {
              *(_DWORD *)v21 = -*(_DWORD *)v21;
              *(_DWORD *)(v21 + 8) = -*(_DWORD *)(v21 + 8);
              goto LABEL_48;
            }
            if ( *(_BYTE *)(v21 - 6) == 2 )
LABEL_55:
              *(_DWORD *)v21 = -*(_DWORD *)v21;
LABEL_48:
            v21 += 19;
            --v20;
          }
          while ( v20 );
        }
        v22 = -*(_DWORD *)(v8 + 64);
        *(_DWORD *)(v8 + 56) = -*(_DWORD *)(v8 + 56);
        *(_DWORD *)(v8 + 64) = v22;
      }
      v8 += 88;
      ++v24;
    }
    while ( v24 < *(_WORD *)(a3 + 3) );
  }
  return 1;
}

//----- (1001DE20) --------------------------------------------------------
bool __cdecl sub_1001DE20(int a1, int a2, int a3)
{
  return 28 * *(_WORD *)(a3 + 2) == *(_DWORD *)(a2 + 8);
}

//----- (1001DE40) --------------------------------------------------------
char __cdecl sub_1001DE40(int a1, int a2, int a3)
{
  unsigned int v3; // ebp@1
  int v4; // eax@1
  unsigned int v5; // ebx@3
  int v6; // edi@3
  unsigned int v7; // edx@4
  int v8; // ecx@4
  unsigned int v9; // ebp@5
  unsigned int v11; // [sp+10h] [bp-Ch]@1
  int v12; // [sp+14h] [bp-8h]@1

  v11 = 0;
  v12 = 0;
  v3 = *(_DWORD *)(a2 + 8);
  v4 = a3 + 5;
  while ( 1 )
  {
    v5 = *(_DWORD *)(v4 + 12);
    v6 = *(_DWORD *)(v4 + 8);
    if ( v6 + v5 > v3 )
      return 0;
    v7 = *(_DWORD *)(v4 + 4);
    v8 = *(_DWORD *)v4;
    if ( v7 + *(_DWORD *)v4 > v3 )
      return 0;
    v9 = v11;
    if ( v7 >= v11 )
    {
      if ( v8 )
      {
        v9 = v7 + *(_DWORD *)v4;
        v11 = v7 + *(_DWORD *)v4;
      }
    }
    else if ( v8 )
    {
      return 0;
    }
    if ( v5 < v9 && v6 )
      return 0;
    if ( v6 )
      v11 = v6 + v5;
    v4 += 17;
    if ( (unsigned int)++v12 > 4 )
      break;
    v3 = *(_DWORD *)(a2 + 8);
  }
  return 1;
}

//----- (1001DEE0) --------------------------------------------------------
char __cdecl sub_1001DEE0(int a1, int a2, int a3)
{
  unsigned int v3; // edx@1
  unsigned int v4; // eax@1
  char result; // al@2
  unsigned int v6; // edi@3
  unsigned int *v7; // ecx@4

  v3 = *(_DWORD *)(a3 + 3);
  v4 = 0;
  if ( 12 * v3 == *(_DWORD *)(a2 + 8) )
  {
    v6 = 0;
    if ( v3 )
    {
      v7 = (unsigned int *)(a3 + *(_DWORD *)(a2 + 2) + 8);
      while ( *v7 >= v4 )
      {
        v4 = *v7 + *(v7 - 1);
        if ( v4 > *(_DWORD *)(a2 + 14) )
          break;
        ++v6;
        v7 += 3;
        if ( v6 >= v3 )
          goto LABEL_8;
      }
      result = 0;
    }
    else
    {
LABEL_8:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001DF40) --------------------------------------------------------
char __cdecl sub_1001DF40(int a1, int a2, int a3)
{
  unsigned int v3; // eax@1
  int v5; // eax@3
  unsigned int *v6; // ecx@3
  unsigned int v7; // ebx@4
  unsigned int v8; // esi@5
  unsigned int v9; // edx@5
  int v10; // ecx@6
  unsigned int v11; // eax@7
  bool v12; // cf@11
  signed int v13; // [sp+0h] [bp-8h]@3
  unsigned int *v14; // [sp+4h] [bp-4h]@3
  int v15; // [sp+10h] [bp+8h]@3

  v3 = *(_DWORD *)(a2 + 2);
  if ( v3 < 0x13 )
    return 0;
  v5 = a3 + v3;
  v6 = (unsigned int *)(a2 + 8);
  v15 = v5;
  v13 = 1;
  v14 = v6;
  while ( 1 )
  {
    v7 = *v6;
    if ( *v6 )
      break;
LABEL_11:
    v6 = (unsigned int *)((char *)v14 + 6);
    v12 = (unsigned int)(v13++ + 1) < 0x10;
    v14 = (unsigned int *)((char *)v14 + 6);
    if ( !v12 )
      return 1;
  }
  v8 = *(_WORD *)(a3 + 13);
  v9 = 0;
  if ( !*(_WORD *)(a3 + 13) )
  {
LABEL_10:
    v5 = v7 + v15;
    v15 += v7;
    goto LABEL_11;
  }
  v10 = v5 + 2;
  while ( 1 )
  {
    v11 = *(_BYTE *)(v10 - 2) + ((*(_BYTE *)(v10 - 1) + ((*(_BYTE *)v10 + (*(_BYTE *)(v10 + 1) << 8)) << 8)) << 8);
    if ( v11 < 4 * v8 || v11 > v7 )
      return 0;
    ++v9;
    v10 += 4;
    if ( v9 >= v8 )
      goto LABEL_10;
  }
}

//----- (1001E000) --------------------------------------------------------
char __cdecl sub_1001E000(char a1, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // esi@1
  int v5; // eax@1
  unsigned int v6; // edi@5
  unsigned int v7; // ebx@6
  _DWORD *v8; // eax@6
  int v9; // ecx@8
  unsigned int v10; // edx@8
  unsigned int v12; // edi@15
  unsigned int v13; // ebx@16
  _DWORD *v14; // eax@16
  int v15; // ecx@18
  unsigned int v16; // edx@18
  int v17; // [sp+18h] [bp+8h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 2) + a3;
  v5 = *(_DWORD *)(a2 + 8);
  v17 = v5 + v4;
  if ( !a1 || a1 == 2 || a1 == 3 )
  {
    if ( v5 == 75 * *(_WORD *)(a3 + 3) )
    {
      v12 = 0;
      if ( *(_WORD *)(a3 + 3) )
      {
        v13 = *(_DWORD *)(v3 + 14);
        v14 = (_DWORD *)(v4 + 71);
        while ( *(v14 - 3) + *(v14 - 2) <= v13 )
        {
          v15 = *(v14 - 1);
          v16 = v15 + *v14;
          if ( v16 > v13 || v15 && *(_BYTE *)(v16 + v17 - 1) )
            break;
          ++v12;
          v14 = (_DWORD *)((char *)v14 + 75);
          if ( v12 >= *(_WORD *)(a3 + 3) )
            return 1;
        }
        return 0;
      }
      return 1;
    }
    return 0;
  }
  if ( v5 != 92 * *(_WORD *)(a3 + 3) )
    return 0;
  v6 = 0;
  if ( *(_WORD *)(a3 + 3) )
  {
    v7 = *(_DWORD *)(v3 + 14);
    v8 = (_DWORD *)(v4 + 88);
    while ( *(v8 - 3) + *(v8 - 2) <= v7 )
    {
      v9 = *(v8 - 1);
      v10 = v9 + *v8;
      if ( v10 > v7 || v9 && *(_BYTE *)(v10 + v17 - 1) )
        break;
      ++v6;
      v8 += 23;
      if ( v6 >= *(_WORD *)(a3 + 3) )
        return 1;
    }
    return 0;
  }
  return 1;
}

//----- (1001E0E0) --------------------------------------------------------
char __cdecl sub_1001E0E0(int a1, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  unsigned int v5; // ebx@1
  int v6; // eax@1
  char result; // al@2
  int v8; // esi@4
  int v9; // edx@5
  unsigned int v10; // [sp+Ch] [bp-8h]@4
  int v11; // [sp+1Ch] [bp+8h]@3

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(_WORD *)(a3 + 3);
  v6 = a3 + *(_DWORD *)(a2 + 2);
  if ( v4 == 25 * v5 )
  {
    v11 = 0;
    if ( v5 )
    {
      v10 = *(_DWORD *)(v3 + 14);
      v8 = v6 + 17;
      while ( 1 )
      {
        v9 = *(_DWORD *)v8;
        if ( *(_DWORD *)v8 + (unsigned __int64)*(_DWORD *)(v8 + 4) > v10
          || !v9
          || *(_BYTE *)(v9 + *(_DWORD *)(v8 + 4) + v4 + v6 - 1) )
        {
          break;
        }
        v8 += 25;
        if ( ++v11 >= v5 )
          goto LABEL_9;
      }
      result = 0;
    }
    else
    {
LABEL_9:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001E190) --------------------------------------------------------
char __cdecl sub_1001E190(int a1, int a2, int a3)
{
  unsigned int v3; // edx@1
  char result; // al@2
  unsigned int v5; // ebx@3
  unsigned int v6; // ebp@4
  int v7; // eax@4
  int v8; // ecx@7
  unsigned int v9; // esi@8

  v3 = 0;
  if ( *(_DWORD *)(a2 + 8) == 26 * *(_BYTE *)(a3 + 3) )
  {
    v5 = 0;
    if ( *(_BYTE *)(a3 + 3) )
    {
      v6 = *(_DWORD *)(a2 + 14);
      v7 = a3 + *(_DWORD *)(a2 + 2) + 14;
      while ( *(_DWORD *)v7 + *(_DWORD *)(v7 - 4) <= v6 && *(_DWORD *)v7 >= v3 )
      {
        v3 = *(_DWORD *)v7 + *(_DWORD *)(v7 - 4);
        v8 = *(_DWORD *)(v7 + 4);
        if ( v8 )
        {
          v9 = *(_DWORD *)(v7 + 8);
          if ( v9 < v3 )
            break;
          v3 = v8 + v9;
        }
        if ( v3 > v6 )
          break;
        ++v5;
        v7 += 26;
        if ( v5 >= *(_BYTE *)(a3 + 3) )
          goto LABEL_12;
      }
      result = 0;
    }
    else
    {
LABEL_12:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001E200) --------------------------------------------------------
char __cdecl sub_1001E200(int a1, int a2, int a3)
{
  unsigned int v3; // edx@1
  char result; // al@2
  unsigned int v5; // ebx@3
  unsigned int v6; // ebp@4
  int v7; // eax@4
  int v8; // ecx@7
  unsigned int v9; // esi@8

  v3 = 0;
  if ( 26 * *(_BYTE *)(a3 + 3) == *(_DWORD *)(a2 + 8) )
  {
    v5 = 0;
    if ( *(_BYTE *)(a3 + 3) )
    {
      v6 = *(_DWORD *)(a2 + 14);
      v7 = a3 + *(_DWORD *)(a2 + 2) + 14;
      while ( *(_DWORD *)v7 + *(_DWORD *)(v7 - 4) <= v6 && *(_DWORD *)v7 >= v3 )
      {
        v3 = *(_DWORD *)v7 + *(_DWORD *)(v7 - 4);
        v8 = *(_DWORD *)(v7 + 4);
        if ( v8 )
        {
          v9 = *(_DWORD *)(v7 + 8);
          if ( v9 < v3 )
            break;
          v3 = v8 + v9;
        }
        if ( v3 > v6 )
          break;
        ++v5;
        v7 += 26;
        if ( v5 >= *(_BYTE *)(a3 + 3) )
          goto LABEL_12;
      }
      result = 0;
    }
    else
    {
LABEL_12:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001E270) --------------------------------------------------------
char __cdecl sub_1001E270(int a1, int a2, int a3)
{
  char result; // al@2
  unsigned int v4; // edi@3
  unsigned int v5; // ecx@4
  int v6; // eax@4
  int v7; // edx@15

  if ( 62 * *(_WORD *)(a3 + 3) == *(_DWORD *)(a2 + 8) )
  {
    v4 = 0;
    if ( *(_WORD *)(a3 + 3) )
    {
      v5 = *(_DWORD *)(a2 + 14);
      v6 = a3 + *(_DWORD *)(a2 + 2) + 17;
      while ( *(_DWORD *)(v6 - 4) + (unsigned int)*(_BYTE *)v6 <= v5 || !*(_BYTE *)v6 )
      {
        if ( *(_DWORD *)(v6 + 17) + (unsigned int)*(_BYTE *)(v6 + 21) > v5 && *(_BYTE *)(v6 + 21) )
          break;
        if ( *(_DWORD *)(v6 + 22) + (unsigned int)*(_BYTE *)(v6 + 26) > v5 && *(_BYTE *)(v6 + 26) )
          break;
        if ( *(_DWORD *)(v6 + 27) + (unsigned int)*(_BYTE *)(v6 + 31) > v5 && *(_BYTE *)(v6 + 31) )
          break;
        if ( *(_DWORD *)(v6 + 32) + (unsigned int)*(_BYTE *)(v6 + 36) > v5 && *(_BYTE *)(v6 + 36) )
          break;
        v7 = *(_DWORD *)(v6 + 37);
        if ( v7 + *(_DWORD *)(v6 + 41) > v5 )
        {
          if ( v7 )
            break;
        }
        ++v4;
        v6 += 62;
        if ( v4 >= *(_WORD *)(a3 + 3) )
          goto LABEL_18;
      }
      result = 0;
    }
    else
    {
LABEL_18:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001E320) --------------------------------------------------------
char __cdecl sub_1001E320(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ecx@1
  unsigned int v5; // ebp@1
  int v6; // eax@1
  char result; // al@2
  int v8; // edi@4
  unsigned __int8 v9; // dl@7
  int v10; // eax@8
  unsigned int v11; // ecx@10
  unsigned int v12; // ebx@11
  int v13; // eax@11
  unsigned int v14; // [sp+Ch] [bp-Ch]@1
  int v15; // [sp+10h] [bp-8h]@1
  unsigned int v16; // [sp+14h] [bp-4h]@1
  int v17; // [sp+24h] [bp+Ch]@3

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(_WORD *)(a3 + 3);
  v6 = a3 + *(_DWORD *)(a2 + 2);
  v14 = *(_DWORD *)(a2 + 14);
  v15 = v6 + v4 + v14;
  v16 = *(_WORD *)(a3 + 3);
  if ( 37 * v5 == v4 )
  {
    v17 = 0;
    if ( v5 )
    {
      v8 = v6 + 20;
      while ( *(_DWORD *)v8 + *(_DWORD *)(v8 + 4) <= v14 || !*(_DWORD *)v8 )
      {
        v9 = *(_BYTE *)(v8 + 8);
        if ( v9 )
        {
          v10 = *(_DWORD *)(v8 + 9);
          if ( (unsigned int)(v10 + *(_DWORD *)(v8 + 13)) > *(_DWORD *)(v3 + 20) && v10 )
            break;
          v11 = 0;
          if ( v9 )
          {
            v12 = *(_DWORD *)(v3 + 26);
            v13 = v15 + 18;
            while ( *(_DWORD *)v13 + *(_DWORD *)(v13 + 4) <= v12 || !*(_DWORD *)v13 )
            {
              ++v11;
              v13 += 26;
              if ( v11 >= v9 )
              {
                v3 = a2;
                v5 = v16;
                goto LABEL_16;
              }
            }
            break;
          }
        }
LABEL_16:
        v8 += 37;
        if ( ++v17 >= v5 )
          goto LABEL_17;
      }
      result = 0;
    }
    else
    {
LABEL_17:
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001E400) --------------------------------------------------------
char __cdecl sub_1001E400(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // ebx@1
  int v4; // esi@1
  int v5; // edi@1
  char v6; // al@2
  unsigned int v7; // edx@5
  unsigned int v8; // ebx@6
  int v9; // eax@6
  unsigned int v11; // [sp+Ch] [bp-8h]@11
  char v12[4]; // [sp+10h] [bp-4h]@11

  v3 = a2;
  v4 = a3;
  v5 = a3 + *(_DWORD *)(a2 + 2);
  if ( !*(_BYTE *)(a3 + 3) )
  {
    v6 = *(_BYTE *)a3;
    if ( *(_BYTE *)a3 < 0x1Cu )
    {
      if ( v6 != 1 )
        return 0;
      sub_10032600(v12);
      sub_1002C6F0((int)&a3, *(unsigned int *)v12);
      HIWORD(a2) = HIWORD(a3);
      LOBYTE(a2) = a3;
      BYTE1(a2) = 1;
      sub_1002C820((int *)&v11, a2);
      v11 -= 86400;
      sub_1002C6F0((int)&a2, v11);
      *(_BYTE *)(v4 + 3) = BYTE1(a2);
    }
    else
    {
      *(_BYTE *)(a3 + 3) = v6;
    }
  }
  if ( 20 * *(_WORD *)(v4 + 6) == *(_DWORD *)(v3 + 8) )
  {
    v7 = 0;
    if ( !*(_WORD *)(v4 + 6) )
      return 1;
    v8 = *(_DWORD *)(v3 + 14);
    v9 = v5 + 7;
    while ( *(_DWORD *)v9 + 5 * (unsigned int)*(_BYTE *)(v9 + 4) <= v8 )
    {
      ++v7;
      v9 += 20;
      if ( v7 >= *(_WORD *)(v4 + 6) )
        return 1;
    }
  }
  return 0;
}

//----- (1001E4E0) --------------------------------------------------------
char *__cdecl sub_1001E4E0(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( a1 >= 0x34u )
    result = 0;
  else
    result = &byte_100A15F8[28 * a1];
  return result;
}

//----- (1001E500) --------------------------------------------------------
char __cdecl sub_1001E500(char a1, char a2, unsigned int a3, int a4)
{
  char (__cdecl *v4)(char, unsigned int, int); // eax@1
  char result; // al@2

  v4 = (char (__cdecl *)(char, unsigned int, int))*(&off_100A261C
                                                  + 2
                                                  * (unsigned __int16)sub_1002CC90(
                                                                        &a1,
                                                                        1u,
                                                                        (int)&unk_100A2618,
                                                                        8,
                                                                        37,
                                                                        37));
  if ( v4 )
    result = v4(a2, a3, a4);
  else
    result = 0;
  return result;
}
// 100A261C: using guessed type int (__cdecl *off_100A261C)(char, int, int);

//----- (1001E550) --------------------------------------------------------
char __cdecl sub_1001E550(char a1, unsigned __int8 a2)
{
  char result; // al@1
  char v3; // cl@1
  char v4; // dl@1

  result = -1;
  v3 = 0;
  v4 = 0;
  if ( a2 >= 4u
    || (v3 = byte_100A2740[12 * a2], v4 = byte_100A2741[12 * a2], (unsigned __int8)v3 < 0x34u)
    && (unsigned __int8)v3 <= (unsigned __int8)v4 )
  {
    while ( a1 != byte_100A1608[28 * (unsigned __int8)v3] )
    {
      if ( (unsigned __int8)++v3 > (unsigned __int8)v4 )
        return result;
    }
    result = byte_100A15F8[28 * (unsigned __int8)v3];
  }
  return result;
}

//----- (1001E5D0) --------------------------------------------------------
char __cdecl sub_1001E5D0(unsigned __int8 a1)
{
  char result; // al@1

  result = -1;
  if ( a1 < 0x34u )
    result = byte_100A1608[28 * a1];
  return result;
}

//----- (1001E5F0) --------------------------------------------------------
char *__cdecl sub_1001E5F0(unsigned __int8 a1)
{
  char *result; // eax@2

  if ( a1 >= 4u )
    result = 0;
  else
    result = &byte_100A2740[12 * a1];
  return result;
}

//----- (1001E610) --------------------------------------------------------
unsigned __int8 __cdecl sub_1001E610(unsigned __int8 a1)
{
  unsigned __int8 result; // al@1
  int v2; // ecx@2

  result = 0;
  do
  {
    v2 = 12 * result;
    if ( a1 >= (unsigned __int8)byte_100A2740[v2] && a1 <= (unsigned __int8)byte_100A2741[v2] )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}

//----- (1001E640) --------------------------------------------------------
char __cdecl sub_1001E640(char a1, unsigned __int8 a2)
{
  void *v2; // ecx@2

  if ( sub_1001E550(a1, a2) != -1 && sub_10033580() == a2 )
  {
    if ( !(sub_1002C660(v2) & 0xF0) )
      return 1;
    switch ( a1 )
    {
      case 5:
      case 0xA:
      case 0xE:
      case 0x1B:
      case 0x1C:
      case 0x2A:
      case 0x46:
      case 0x47:
      case 0x5A:
        return 1;
      default:
        return 0;
    }
  }
  return 0;
}

//----- (1001E6F0) --------------------------------------------------------
char __cdecl sub_1001E6F0(unsigned __int8 a1, int a2, unsigned int *a3)
{
  bool v3; // zf@1
  int v4; // ebx@1
  unsigned __int16 v5; // bp@12
  signed __int64 v6; // rdi@13
  char v8; // [sp+5h] [bp-27h]@1
  char v9; // [sp+6h] [bp-26h]@5
  char v10; // [sp+7h] [bp-25h]@5
  char v11[4]; // [sp+8h] [bp-24h]@2
  unsigned int v12; // [sp+Ch] [bp-20h]@1
  int v13; // [sp+10h] [bp-1Ch]@6
  int v14; // [sp+14h] [bp-18h]@6
  int v15; // [sp+18h] [bp-14h]@6
  char v16; // [sp+1Ch] [bp-10h]@15
  char v17; // [sp+1Eh] [bp-Eh]@20
  char v18; // [sp+20h] [bp-Ch]@15
  char v19; // [sp+21h] [bp-Bh]@16
  char v20; // [sp+24h] [bp-8h]@13
  char v21; // [sp+28h] [bp-4h]@13

  v3 = *(_BYTE *)(a2 + 8) == 0;
  v4 = *(_DWORD *)(a2 + 24);
  v8 = 0;
  v12 = -1;
  if ( !v3 && sub_10032600(v11) && v4 && a1 < 0x34u && sub_1001FF50(a1, &a2, &v9, &v10) )
  {
    LOBYTE(v15) = 0;
    LOBYTE(v14) = 0;
    LOBYTE(v13) = 0;
    if ( (char)a2 >= 0 )
      LOBYTE(v15) = *(_BYTE *)((char)a2 + v4);
    if ( v9 > 0 )
      LOBYTE(v14) = *(_BYTE *)(v9 + v4);
    if ( v10 > 0 )
      LOBYTE(v13) = *(_BYTE *)(v10 + v4);
    v5 = word_100A160A[14 * a1];
    if ( sub_1001FDD0(*(unsigned int *)v11, v15, v14, v13, 0, &v12) )
    {
      v6 = *(unsigned int *)v11 - (unsigned __int64)v12;
      sub_1002C6F0((int)&v20, v12);
      sub_1002C910((int)&v21, v12);
      if ( v6 < 0 )
      {
        if ( -v6 >= v5 )
          goto LABEL_26;
        sub_1002C6F0((int)&v18, *(unsigned int *)v11);
        sub_1002C910((int)&v16, *(unsigned int *)v11);
        if ( (char)a2 >= 0 )
          *(_BYTE *)((char)a2 + v4) = v19;
        if ( v9 > 0 )
          *(_BYTE *)(v9 + v4) = v16;
        if ( v10 > 0 )
          *(_BYTE *)(v10 + v4) = v17;
        v6 = 0i64;
      }
      if ( v6 < v5 )
      {
        if ( v6 <= v5 >> 1 )
          v8 = 2;
        else
          v8 = 1;
      }
    }
  }
LABEL_26:
  if ( a3 )
    *a3 = v12;
  return v8;
}
// 100A160A: using guessed type __int16 word_100A160A[];

//----- (1001E8E0) --------------------------------------------------------
char __cdecl sub_1001E8E0(char a1)
{
  char result; // al@3

  if ( a1 == 1 || a1 == 23 )
    result = sub_1000B330(a1);
  else
    result = 1;
  return result;
}

//----- (1001E900) --------------------------------------------------------
char __thiscall sub_1001E900(void *this)
{
  char result; // al@5
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( sub_100336A0(this) && !sub_100340B0(2048) && !sub_10033580() )
    sub_1001FC60(0, 0x1Bu);
  result = sub_10021090();
  if ( result )
  {
    result = sub_10020DC0((void *)0x53, (char *)&v2 + 3);
    if ( !result || BYTE3(v2) != 2 )
    {
      result = sub_10033580();
      if ( result == 1 )
        result = sub_1001FC60(0x28u, 0x33u);
    }
  }
  return result;
}

//----- (1001E970) --------------------------------------------------------
signed int sub_1001E970()
{
  signed int result; // eax@2

  dword_109FFDCC = -15;
  if ( sub_10061B70((LONG)&off_100A2770) )
  {
    sub_1001CFE0(dword_109FFDCC);
    result = sub_10061700((int)&off_100A2770);
  }
  else
  {
    sub_10028BC0("..\\lib\\adl\\iop_wx_prj.c", 1082, 1, 0);
    result = sub_10061700((int)&off_100A2770);
  }
  return result;
}
// 100A2770: using guessed type char *off_100A2770;
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001E9D0) --------------------------------------------------------
int sub_1001E9D0()
{
  signed int v0; // eax@1
  signed int v1; // ecx@1
  char v3; // [sp+0h] [bp-74h]@1
  char v4; // [sp+34h] [bp-40h]@1

  memset(&v3, 0, 0x6Du);
  memset(&v4, 28, 0x34u);
  v0 = 600;
  v1 = 28;
  do
  {
    *(_BYTE *)(v0 + dword_109FFDCC) = 1;
    v0 += 20;
    --v1;
  }
  while ( v1 );
  sub_10061000(3440, (void *)(dword_109FFDCC + 109), 109, &v3);
  return sub_10061000(3441, (void *)(dword_109FFDCC + 218), 109, &v3);
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001EA70) --------------------------------------------------------
char __usercall sub_1001EA70@<al>(void *a1@<edi>, int a2@<esi>, char a3, int a4, int a5)
{
  __int16 v6; // [sp+0h] [bp-52Ch]@1
  __int16 v7; // [sp+4h] [bp-528h]@1
  int v8; // [sp+8h] [bp-524h]@1

  memset(&v6, 0, 0x528u);
  sub_10015560(2, a2, a1, a3, a4, a5);
  v6 = -32766;
  v7 = a2;
  v8 = 2048;
  return sub_1002CC80((int)&v6);
}

//----- (1001EAF0) --------------------------------------------------------
_BYTE *__cdecl sub_1001EAF0(int a1, unsigned __int8 a2)
{
  _BYTE *result; // eax@3
  signed int v3; // ecx@4
  signed int v4; // ecx@8

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      result = (_BYTE *)(a1 + 1160);
      v4 = 12;
      do
      {
        *result = 1;
        result += 20;
        --v4;
      }
      while ( v4 );
      *(_BYTE *)(a1 + 8528) = 0;
    }
    else
    {
      result = (_BYTE *)(a2 - 2);
      if ( a2 == 2 )
      {
        result = (_BYTE *)(a1 + 1400);
        v3 = 12;
        do
        {
          *result = 1;
          result += 20;
          --v3;
        }
        while ( v3 );
        *(_BYTE *)(a1 + 8624) = 0;
      }
    }
  }
  else
  {
    result = (_BYTE *)sub_1001E9D0();
  }
  return result;
}

//----- (1001EB50) --------------------------------------------------------
char __cdecl sub_1001EB50(unsigned __int8 a1, char a2, int a3)
{
  int v3; // eax@1
  bool v4; // zf@2
  int v6; // [sp+0h] [bp-8h]@1
  __int16 v7; // [sp+4h] [bp-4h]@1

  v6 = 0;
  v7 = 0;
  LOBYTE(v3) = sub_10033580();
  if ( (_BYTE)v3 == a1 )
  {
    v4 = byte_109FFDC8[a1] == 0;
    LOBYTE(v6) = a2;
    if ( !v4 )
      LOBYTE(v6) = a2 | 0x80;
    v3 = sub_10060900();
    *(_DWORD *)(a3 + 4) = v3;
    if ( a1 )
    {
      if ( a1 == 2 )
        *(_BYTE *)(a3 + 1) = 1;
    }
    else
    {
      *(_BYTE *)(a3 + 1) = 1;
      BYTE1(v6) = sub_1001E550(a2, 0);
      LOBYTE(v3) = sub_1001EA70(&v6, 4, 0, 3, 1);
    }
  }
  return v3;
}

//----- (1001EC00) --------------------------------------------------------
HANDLE __cdecl sub_1001EC00(_BYTE *a1, DWORD a2)
{
  unsigned __int8 v2; // dl@1
  int v3; // eax@1
  DWORD v4; // edi@1
  char *v5; // ecx@1
  signed int v6; // esi@1
  int v7; // ebx@2
  _BYTE *v8; // esi@3
  int v9; // eax@3
  unsigned __int8 v10; // cl@3
  unsigned __int8 v11; // al@3
  char *v12; // ebx@3
  char v13; // al@3
  unsigned int v14; // eax@6
  int v15; // esi@13
  HANDLE v16; // edi@14
  HANDLE result; // eax@14
  HANDLE v18; // esi@15
  void *v19; // esi@16
  int v20; // eax@20
  int v21; // eax@22
  int v22; // eax@24
  int v23; // ST44_4@25
  int v24; // ST40_4@25
  int v25; // ST3C_4@25
  int v26; // ST38_4@25
  int v27; // ST34_4@25
  int v28; // ST30_4@25
  int v29; // eax@25
  int v30; // ebx@25
  unsigned __int8 v31; // [sp+43h] [bp-379h]@4
  DWORD NumberOfBytesWritten; // [sp+44h] [bp-378h]@13
  unsigned __int8 v33; // [sp+4Ah] [bp-372h]@3
  unsigned __int8 v34; // [sp+4Bh] [bp-371h]@3
  DWORD nNumberOfBytesToWrite; // [sp+4Ch] [bp-370h]@1
  float v36; // [sp+50h] [bp-36Ch]@7
  struct _SYSTEMTIME SystemTime; // [sp+54h] [bp-368h]@14
  LPCVOID lpBuffer; // [sp+64h] [bp-358h]@3
  char Buffer; // [sp+68h] [bp-354h]@1
  int v40; // [sp+6Ch] [bp-350h]@1
  char v41; // [sp+70h] [bp-34Ch]@1
  char v42; // [sp+71h] [bp-34Bh]@1
  char v43; // [sp+7Fh] [bp-33Dh]@1
  char v44; // [sp+F7h] [bp-2C5h]@1
  int v45; // [sp+F8h] [bp-2C4h]@1
  char v46; // [sp+FCh] [bp-2C0h]@22
  char v47; // [sp+10Ch] [bp-2B0h]@22
  CHAR FileName; // [sp+170h] [bp-24Ch]@9
  char v49; // [sp+1F0h] [bp-1CCh]@14
  char v50; // [sp+270h] [bp-14Ch]@20
  CHAR NewFileName; // [sp+338h] [bp-84h]@13

  nNumberOfBytesToWrite = a2;
  memset(&Buffer, 0, 0x94u);
  v2 = *a1;
  v3 = 132 * (*(_BYTE *)(dword_109FFDCC + 20 * v2 + 592) + *(_DWORD *)(dword_109FFDCC + 20 * v2 + 604))
     + dword_109FFDCC
     + 1632;
  v40 = *(_DWORD *)(132 * (*(_BYTE *)(dword_109FFDCC + 20 * v2 + 592) + *(_DWORD *)(dword_109FFDCC + 20 * v2 + 604))
                  + dword_109FFDCC
                  + 1652);
  v41 = *(_BYTE *)(v3 + 16);
  qmemcpy(&v42, (const void *)(v3 + 28), 0x66u);
  v4 = 0;
  v44 = *(_BYTE *)(v3 + 17);
  v45 = 0;
  v5 = &v43;
  v6 = 4;
  do
  {
    v7 = *(_DWORD *)(v5 - 6) + *((_DWORD *)v5 - 3);
    v5 += 24;
    v4 += *((_DWORD *)v5 - 6) + *(_DWORD *)(v5 - 18) + v7;
    --v6;
  }
  while ( v6 );
  v8 = *(_BYTE **)(v3 + 24);
  v9 = a1[3];
  v34 = v8[a1[2]];
  v10 = v8[v9];
  lpBuffer = v8;
  v33 = v10;
  v11 = sub_1001E610(v2);
  v12 = sub_1001E5F0(v11);
  v13 = a1[4];
  if ( v13 <= 0 )
    v31 = 0;
  else
    v31 = v8[v13];
  v14 = *((_DWORD *)a1 + 2);
  if ( v4 > v14 )
  {
    nNumberOfBytesToWrite = 0;
    v4 = 0;
    v36 = 200.0;
  }
  else
  {
    v36 = (double)(100 * v4) / (double)v14;
    if ( v36 <= 85.0 || *a1 == 13 )
    {
      nNumberOfBytesToWrite = v4;
    }
    else
    {
      sub_1002C2B0(&FileName, 0x80u, "%i%% %s\n", (signed int)v36, nNumberOfBytesToWrite);
      sub_10028BC0("..\\lib\\acl\\iop\\wx\\iop_wx_sim.c", 433, 0, &FileName);
      nNumberOfBytesToWrite = v4;
    }
  }
  sub_1002C2B0(&FileName, 0x80u, "%s\\enbl_log.txt", *((_DWORD *)v12 + 2), *((_DWORD *)a1 + 6));
  if ( sub_10061390((int)&FileName) )
  {
    sub_1002C2B0(&FileName, 0x80u, "%s\\%s.datatmp", *((_DWORD *)v12 + 2), *((_DWORD *)a1 + 6));
    sub_1002C2B0(&NewFileName, 0x80u, "%s\\%s.data", *((_DWORD *)v12 + 2), *((_DWORD *)a1 + 6));
    v15 = j_FIL_vfs_open(&FileName, 142, 0);
    j_FIL_vfs_write(v15, &Buffer, 148);
    NumberOfBytesWritten = j_FIL_vfs_write(v15, lpBuffer, v4);
    sub_10061310(v15, v4 + 148, 0);
    sub_10061070(v15);
    j_FIL_vfs_rename(&FileName, &NewFileName);
  }
  GetSystemTime(&SystemTime);
  sub_10020A60((char *)4, &v49, 0x80u);
  sub_1002C2B0(&v49, 0x80u, "%s..\\%s", &v49, *((_DWORD *)v12 + 1));
  sub_1002C2B0(&FileName, 0x80u, "%s\\enbl_log.txt", &v49, *((_DWORD *)a1 + 6));
  sub_10060A60(85, -1);
  v16 = CreateFileA(&FileName, 0x40000000u, 7u, 0, 3u, 0, 0);
  result = (HANDLE)sub_10060A00(85);
  if ( v16 != (HANDLE)-1 )
  {
    sub_1002C2B0(&FileName, 0x80u, "%s\\%s.datatmp", &v49, *((_DWORD *)a1 + 6));
    sub_1002C2B0(&NewFileName, 0x80u, "%s\\%s.data", &v49, *((_DWORD *)a1 + 6));
    sub_10060A60(85, -1);
    v18 = CreateFileA(&FileName, 0x40000000u, 7u, 0, 4u, 0, 0);
    if ( v18 == (HANDLE)-1 )
    {
      result = (HANDLE)sub_10060A00(85);
    }
    else
    {
      NumberOfBytesWritten = 0;
      WriteFile(v18, &Buffer, 0x94u, &NumberOfBytesWritten, 0);
      WriteFile(v18, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
      SetEndOfFile(v18);
      FlushFileBuffers(v18);
      CloseHandle(v18);
      sub_10060A00(85);
      MoveFileExA(&FileName, &NewFileName, 1u);
      sub_1002C2B0(&FileName, 0x80u, "%s\\%s_log.csv", &v49, *((_DWORD *)v12 + 1), *((_DWORD *)a1 + 6));
      sub_10060A60(85, -1);
      result = CreateFileA(&FileName, 0x40000000u, 7u, 0, 4u, 0, 0);
      v19 = result;
      if ( result == (HANDLE)-1 )
      {
        ++*(_DWORD *)dword_1093D554;
      }
      else
      {
        if ( GetFileSize(result, 0) > 0x20000000 )
          SetEndOfFile(v19);
        sub_10060A00(85);
        if ( !GetFileSize(v19, 0) )
        {
          v20 = sub_1002C2B0(
                  &v50,
                  0xC8u,
                  "weather product, prod id, sz, percent mem used, prod day month, prod utc HH:MM, gdu ms tstamp, gdu utc"
                  " date, gdu utc time\r\n");
          WriteFile(v19, &v50, v20, &NumberOfBytesWritten, 0);
        }
        SetFilePointer(v19, 0, 0, 2u);
        if ( !(dword_1093D550 & 2) )
        {
          sub_10031310(71, &v46);
          v21 = sub_1002C2B0(
                  &v50,
                  0xC8u,
                  "\r\n\r\nlog started current UTC time %2i/%2i/%04i %02i:%02i:%02i gdl ver %s\r\n",
                  SystemTime.wMonth,
                  SystemTime.wDay,
                  SystemTime.wYear,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  &v47);
          WriteFile(v19, &v50, v21, &NumberOfBytesWritten, 0);
        }
        if ( *(_DWORD *)dword_1093D554 )
        {
          v22 = sub_1002C2B0(
                  &v50,
                  0xC8u,
                  "%i errors writing log current time %2i/%2i/%04i %02i:%02i:%02i\r\n",
                  *(_DWORD *)dword_1093D554,
                  SystemTime.wMonth,
                  SystemTime.wDay,
                  SystemTime.wYear,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond);
          WriteFile(v19, &v50, v22, &NumberOfBytesWritten, 0);
        }
        v23 = SystemTime.wSecond;
        v24 = SystemTime.wMinute;
        v25 = SystemTime.wHour;
        v26 = SystemTime.wYear;
        v27 = SystemTime.wDay;
        v28 = SystemTime.wMonth;
        v29 = sub_10060900();
        v30 = sub_1002C2B0(
                &v50,
                0xC8u,
                "%s,%i,%i,%.2f,%i,%02i:%02i,%i,%2i/%2i/%04i,%02i:%02i:%02i\r\n",
                *((_DWORD *)a1 + 6),
                *a1,
                nNumberOfBytesToWrite,
                v36,
                v34,
                v33,
                v31,
                v29,
                v28,
                v27,
                v26,
                v25,
                v24,
                v23);
        WriteFile(v19, &v50, v30, &NumberOfBytesWritten, 0);
        if ( NumberOfBytesWritten == v30 )
        {
          dword_1093D550 |= 2u;
          *(_DWORD *)dword_1093D554 = 0;
          result = (HANDLE)CloseHandle(v19);
        }
        else
        {
          ++*(_DWORD *)dword_1093D554;
          result = (HANDLE)CloseHandle(v19);
        }
      }
    }
  }
  return result;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10061270: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);
// 10061330: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);
// 1093D550: using guessed type int dword_1093D550;
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001F2A0) --------------------------------------------------------
int __usercall sub_1001F2A0@<eax>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // ebp@1
  int v9; // edi@1
  int v10; // ebx@1
  unsigned __int8 v11; // al@1
  char *v12; // eax@1
  HANDLE v13; // eax@1
  void *v14; // edi@1
  DWORD v15; // eax@5
  unsigned int v16; // eax@9
  unsigned int v17; // edi@9
  unsigned __int8 v18; // al@13
  char *v19; // eax@13
  unsigned int v20; // eax@13
  int v21; // edx@17
  void *v22; // eax@17
  int v23; // edi@20
  int v24; // ST38_4@22
  unsigned __int8 v25; // al@22
  int v26; // ST38_4@32
  unsigned __int8 v27; // al@32
  int v28; // edi@38
  int v29; // eax@40
  int v30; // ebx@44
  int result; // eax@41
  char v32; // [sp+12h] [bp-1EAh]@1
  char v33; // [sp+13h] [bp-1E9h]@1
  HANDLE hFile; // [sp+18h] [bp-1E4h]@1
  HANDLE hFilea; // [sp+18h] [bp-1E4h]@13
  DWORD NumberOfBytesRead; // [sp+24h] [bp-1D8h]@5
  int v37; // [sp+28h] [bp-1D4h]@1
  struct _BY_HANDLE_FILE_INFORMATION FileInformation; // [sp+2Ch] [bp-1D0h]@4
  char v39; // [sp+60h] [bp-19Ch]@16
  int v40; // [sp+78h] [bp-184h]@4
  char Buffer; // [sp+9Ch] [bp-160h]@5
  char v42; // [sp+A5h] [bp-157h]@5
  __int16 v43; // [sp+109h] [bp-F3h]@5
  char v44; // [sp+12Bh] [bp-D1h]@5
  char v45; // [sp+130h] [bp-CCh]@1

  v6 = a2;
  v7 = *(_DWORD *)(a2 + 12);
  v8 = *(_DWORD *)(a5 + 16) + 132 * a6;
  v9 = a1;
  v37 = a1;
  v32 = 0;
  v33 = 0;
  v10 = v8 + 16;
  sub_10060A60(v7, 30000);
  sub_10020A60((char *)4, &v45, 0xC8u);
  v11 = sub_1001E610(*(_BYTE *)v6);
  v12 = sub_1001E5F0(v11);
  sub_1002C2B0(byte_1093D450, 0x80u, "%s\\%s\\%s.data", &v45, *((_DWORD *)v12 + 1), v9);
  sub_10060A60(85, -1);
  v13 = CreateFileA(byte_1093D450, 0x80000000, 7u, 0, 3u, 0, 0);
  v14 = v13;
  hFile = v13;
  if ( (unsigned int)v13 < 0xFFFFFFC2 && v13 )
  {
    if ( GetFileSize(v13, 0) <= *(_DWORD *)(v8 + 20) + 148 )
    {
      GetFileInformationByHandle(v14, &FileInformation);
      v40 = sub_1002C990((signed __int64)FileInformation.ftLastWriteTime);
      sub_10060A00(85);
      v32 = 1;
      if ( *(_DWORD *)a4 == v40 )
      {
        sub_10060A60(85, -1);
      }
      else
      {
        *(_DWORD *)a4 = v40;
        sub_10060A60(85, -1);
        ReadFile(v14, &Buffer, 0x94u, &NumberOfBytesRead, 0);
        v15 = *(_DWORD *)(v8 + 20);
        qmemcpy((void *)(v8 + 28), &v42, 0x64u);
        *(_WORD *)(v8 + 128) = v43;
        *(_BYTE *)(v8 + 17) = v44;
        ReadFile(hFile, *(LPVOID *)(v8 + 24), v15, &NumberOfBytesRead, 0);
        v14 = hFile;
        v33 = 1;
      }
    }
    CloseHandle(v14);
  }
  sub_10060A00(85);
  if ( !v32 )
  {
    v16 = j_FIL_vfs_open("/mnt/card0/wx/wx_intf.shr", 4, 1911);
    v17 = v16;
    if ( v16 < 0xFFFFFFC2 && v16 )
    {
      if ( sub_100612E0(v16) == 14619016 )
      {
        v32 = 1;
        sub_100611F0(v17, (void *)(v8 + 16), 156, v10 - dword_109FFDCC + 12, 0);
        if ( *(_BYTE *)(v8 + 17) )
        {
          sub_100611F0(v17, *(void **)(v8 + 24), *(_DWORD *)(v8 + 20), *(_DWORD *)(v8 + 24) - dword_109FFDCC + 12, 0);
          sub_10061070(v17);
          goto LABEL_20;
        }
        goto LABEL_18;
      }
      sub_10061070(v17);
    }
    v18 = sub_1001E610(*(_BYTE *)v6);
    v19 = sub_1001E5F0(v18);
    sub_1002C2B0(byte_1093D450, 0x80u, "%s/%s.data", *((_DWORD *)v19 + 2), v37);
    v20 = j_FIL_vfs_open(byte_1093D450, 4, 1911);
    v17 = v20;
    hFilea = (HANDLE)v20;
    if ( v20 < 0xFFFFFFC2 && v20 )
    {
      if ( (unsigned int)sub_100612E0(v20) <= *(_DWORD *)(v8 + 20) + 148 )
      {
        v32 = 1;
        sub_100610F0(v17, &v39);
        if ( *(_DWORD *)a4 != v40 )
        {
          *(_DWORD *)a4 = v40;
          sub_100611A0(v17, &Buffer, 148);
          v21 = *(_DWORD *)(v8 + 20);
          v22 = *(void **)(v8 + 24);
          qmemcpy((void *)(v8 + 28), &v42, 0x64u);
          *(_WORD *)(v8 + 128) = v43;
          *(_BYTE *)(v8 + 17) = v44;
          sub_100611A0((unsigned int)hFilea, v22, v21);
          v17 = (unsigned int)hFilea;
          v33 = 1;
        }
      }
LABEL_18:
      sub_10061070(v17);
      goto LABEL_19;
    }
  }
LABEL_19:
  if ( v33 != 1 )
  {
    v23 = a4;
    goto LABEL_28;
  }
LABEL_20:
  v23 = a4;
  ++*(_DWORD *)(v23 + 4);
  if ( *(_DWORD *)(a4 + 4) > 2u )
    dword_1093D550 |= 1u;
  *(_BYTE *)v8 = 1;
  *(_BYTE *)(a5 + 8) = 1;
  *(_BYTE *)a5 = a6;
  sub_1001CD70(*(_BYTE *)v6);
  v24 = *(_DWORD *)(v8 + 24);
  v25 = sub_1001E610(*(_BYTE *)v6);
  if ( sub_1001E500(*(_BYTE *)(v6 + 16), v25, v8 + 28, v24) )
  {
    *(_BYTE *)(v8 + 1) = 2;
    *(_BYTE *)(v8 + 8) = sub_1001E8E0(*(_BYTE *)v6);
  }
  else
  {
    *(_BYTE *)(v8 + 8) = 0;
    *(_BYTE *)(v8 + 1) = 0;
  }
LABEL_28:
  if ( !v32 )
  {
    *(_BYTE *)v8 = 0;
    *(_BYTE *)(v8 + 8) = 0;
    *(_BYTE *)(v8 + 1) = 0;
    *(_DWORD *)v23 = 0;
  }
  if ( !*(_BYTE *)(v8 + 8) )
  {
    if ( !*(_BYTE *)v8 )
      return sub_10060A00(*(_DWORD *)(v6 + 12));
    v26 = *(_DWORD *)(v8 + 24);
    v27 = sub_1001E610(*(_BYTE *)v6);
    if ( !sub_1001E500(*(_BYTE *)(v6 + 16), v27, v8 + 28, v26) )
      return sub_10060A00(*(_DWORD *)(v6 + 12));
    *(_BYTE *)(v8 + 17) = 1;
  }
  if ( sub_1001E6F0(*(_BYTE *)v6, v8, 0) || dword_1093D550 & 1 )
  {
    result = sub_10060A00(*(_DWORD *)(v6 + 12));
  }
  else if ( *(_BYTE *)v6 == 12 )
  {
    v30 = *(_DWORD *)(v8 + 24);
    *(_BYTE *)v30 = *(_BYTE *)a3;
    *(_BYTE *)(v30 + 1) = (*(_BYTE *)(a3 + 1) + 1) % 24;
    result = sub_10060A00(*(_DWORD *)(v6 + 12));
  }
  else
  {
    if ( *(_BYTE *)v6 == 31 && (v28 = *(_DWORD *)(dword_109FFDCC + 1248), *(_BYTE *)v28) && *(_BYTE *)(v28 + 8) )
    {
      v29 = a3;
      *(_BYTE *)(*(_BYTE *)(v6 + 2) + *(_DWORD *)(v28 + 24)) = *(_BYTE *)a3;
      *(_BYTE *)(*(_BYTE *)(v6 + 3) + *(_DWORD *)(v28 + 24)) = *(_BYTE *)(a3 + 1);
      *(_BYTE *)(*(_BYTE *)(v6 + 4) + *(_DWORD *)(v28 + 24)) = *(_BYTE *)(a3 + 2);
      v10 = v8 + 16;
    }
    else
    {
      v29 = a3;
    }
    *(_BYTE *)(*(_BYTE *)(v6 + 2) + *(_DWORD *)(v10 + 8)) = *(_BYTE *)v29;
    *(_BYTE *)(*(_BYTE *)(v6 + 3) + *(_DWORD *)(v10 + 8)) = *(_BYTE *)(v29 + 1);
    *(_BYTE *)(*(_BYTE *)(v6 + 4) + *(_DWORD *)(v10 + 8)) = *(_BYTE *)(v29 + 2);
    result = sub_10060A00(*(_DWORD *)(v6 + 12));
  }
  return result;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 1093D550: using guessed type int dword_1093D550;
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001F800) --------------------------------------------------------
bool __cdecl sub_1001F800(int a1, int a2, int a3, size_t Count, int a5, int a6, int a7, int a8)
{
  bool v8; // bl@1
  FILE *v9; // edi@1
  void *v10; // ebx@4
  int v11; // eax@8
  unsigned int v12; // eax@15
  unsigned int v13; // edi@15
  signed int v14; // eax@18
  void *v15; // ebx@19
  bool result; // al@22
  unsigned int v17; // eax@23
  signed int v18; // eax@26
  signed int v19; // eax@27
  size_t v20; // [sp+10h] [bp-274h]@6
  size_t v21; // [sp+14h] [bp-270h]@7
  void *v22; // [sp+18h] [bp-26Ch]@1
  void *v23; // [sp+1Ch] [bp-268h]@1
  void *DstBuf; // [sp+20h] [bp-264h]@1
  int v25; // [sp+24h] [bp-260h]@1
  char v26; // [sp+28h] [bp-25Ch]@1
  char v27; // [sp+F0h] [bp-194h]@1

  v23 = (void *)a3;
  v25 = a2;
  v22 = (void *)a5;
  DstBuf = (void *)a8;
  v8 = 0;
  *(_DWORD *)a7 = 0;
  sub_10020A60((char *)4, &v26, 0xC8u);
  sub_1002C2B0(&v27, 0x190u, "%s\\%s\\%s", &v26, a1, a2);
  sub_10060A60(85, -1);
  v9 = sub_10069D0E(&v27, "rb");
  if ( v9 )
  {
    if ( DstBuf )
      *(_DWORD *)a7 = sub_10069C2F(DstBuf, 4u, 1u, v9);
    v10 = v22;
    if ( v22 && a6 )
    {
      if ( sub_10069C2F(&v20, 4u, 2u, v9) != 2 )
      {
        v20 = 0;
        v21 = 0;
LABEL_13:
        fclose(v9);
        v8 = *(_DWORD *)a7 > 4u;
        goto LABEL_14;
      }
      v11 = v20;
    }
    else
    {
      v11 = Count;
      v20 = Count;
      v21 = 0;
    }
    if ( v11 )
    {
      *(_DWORD *)a7 += sub_10069C2F(v23, 1u, v11, v9);
      if ( v21 )
        *(_DWORD *)a7 += sub_10069C2F(v10, 1u, v21, v9);
    }
    goto LABEL_13;
  }
LABEL_14:
  sub_10060A00(85);
  if ( v8
    || (sub_1002C2B0(&v27, 0x190u, "/mnt/card0/%s/%s", a1, v25),
        v12 = j_FIL_vfs_open(&v27, 4, 1911),
        v13 = v12,
        v12 >= 0xFFFFFFC2)
    || !v12 )
  {
    result = v8;
  }
  else
  {
    if ( DstBuf )
    {
      v14 = sub_100611A0(v12, DstBuf, 4);
      *(_DWORD *)a7 = v14 < 0 ? 0 : v14;
    }
    v15 = v22;
    if ( v22 && a6 )
    {
      if ( sub_100611A0(v13, &v20, 8) != 8 )
      {
        v20 = 0;
        v21 = 0;
        sub_10061070(v13);
        return *(_DWORD *)a7 > 4u;
      }
      v17 = v20;
    }
    else
    {
      v17 = Count;
      v20 = Count;
      v21 = 0;
    }
    if ( v17 > 0 )
    {
      v18 = sub_100611A0(v13, v23, v17);
      *(_DWORD *)a7 += v18 < 0 ? 0 : v18;
      if ( v21 > 0 )
      {
        v19 = sub_100611A0(v13, v15, v21);
        *(_DWORD *)a7 += v19 < 0 ? 0 : v19;
      }
    }
    sub_10061070(v13);
    result = *(_DWORD *)a7 > 4u;
  }
  return result;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1001FAA0) --------------------------------------------------------
char __cdecl sub_1001FAA0(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  unsigned int v7; // eax@1
  unsigned int v8; // esi@2
  int v9; // edi@6
  int v10; // eax@8
  int v12; // [sp+10h] [bp-110h]@8
  int v13; // [sp+14h] [bp-10Ch]@8
  int v14; // [sp+18h] [bp-108h]@1
  char v15; // [sp+1Ch] [bp-104h]@1

  v14 = a5;
  sub_1002C2B0(&v15, 0x100u, "/mnt/card0/%s/enbl_log.txt", a1);
  LOBYTE(v7) = sub_10061390((int)&v15);
  if ( (_BYTE)v7 )
  {
    sub_1002C2B0(&v15, 0x100u, "/mnt/card0/%s/%s", a1, a2);
    v7 = j_FIL_vfs_open(&v15, 142, 0);
    v8 = v7;
    if ( v7 < 0xFFFFFFC2 )
    {
      if ( v7 )
      {
        if ( a7 )
          j_FIL_vfs_write(v7, a7, 4);
        v9 = v14;
        if ( v14 && a6 )
        {
          v13 = a6;
          v12 = a4;
          j_FIL_vfs_write(v8, &v12, 8);
          v10 = v12;
        }
        else
        {
          v10 = a4;
          v12 = a4;
          v13 = 0;
        }
        if ( v10 )
        {
          j_FIL_vfs_write(v8, a3, v10);
          if ( v13 )
            j_FIL_vfs_write(v8, v9, v13);
        }
        LOBYTE(v7) = sub_10061070(v8);
      }
    }
  }
  return v7;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10061330: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1001FBF0) --------------------------------------------------------
HANDLE __cdecl sub_1001FBF0(int a1, unsigned __int8 a2)
{
  HANDLE result; // eax@3

  if ( *(_BYTE *)(a1 + 1) > 1u && a2 )
  {
    sub_1002C2B0(byte_1093D558, 0x80u, "%s_%i", *(_DWORD *)(a1 + 24), a2);
    result = sub_1001EC00((_BYTE *)a1, (DWORD)byte_1093D558);
  }
  else
  {
    sub_1002C120((int)byte_1093D558, *(_BYTE **)(a1 + 24), 128);
    result = sub_1001EC00((_BYTE *)a1, (DWORD)byte_1093D558);
  }
  return result;
}

//----- (1001FC60) --------------------------------------------------------
char __cdecl sub_1001FC60(unsigned __int8 a1, unsigned __int8 a2)
{
  void *v2; // ecx@0
  int v3; // eax@1
  unsigned int v4; // ebp@2
  char *v5; // eax@4
  int v6; // esi@4
  char v7; // al@4
  unsigned int v8; // edi@4
  char *v9; // ebx@5
  unsigned __int8 v10; // al@10
  char v12; // [sp+0h] [bp-1Ch]@2
  char v13; // [sp+1h] [bp-1Bh]@2
  char v14; // [sp+2h] [bp-1Ah]@2
  int v15; // [sp+4h] [bp-18h]@2
  int v16; // [sp+8h] [bp-14h]@3
  char v17[4]; // [sp+Ch] [bp-10h]@2
  char v18; // [sp+10h] [bp-Ch]@2
  char v19; // [sp+12h] [bp-Ah]@2
  char v20; // [sp+14h] [bp-8h]@2
  char v21; // [sp+15h] [bp-7h]@2
  int v22; // [sp+18h] [bp-4h]@4

  LOBYTE(v3) = sub_1002C5E0(v2);
  if ( v3 & 4 )
  {
    sub_10032600(v17);
    sub_1002C6F0((int)&v20, *(unsigned int *)v17);
    sub_1002C910((int)&v18, *(unsigned int *)v17);
    v4 = a1;
    v13 = v18;
    v12 = v21;
    v3 = 20 * a1;
    v14 = v19;
    v15 = *(_DWORD *)(v3 + dword_109FFDCC + 604);
    if ( a1 <= (unsigned int)a2 )
    {
      v16 = 20 * a1;
      do
      {
        v22 = v16 + dword_109FFDCC + 592;
        v5 = sub_1001E4E0(v4);
        v6 = (int)v5;
        v7 = v5[1];
        v8 = 0;
        if ( v7 )
        {
          v9 = (char *)&unk_1093D5D8 + 8 * v15;
          do
          {
            if ( (unsigned __int8)v7 > 1u && v8 )
              sub_1002C2B0(byte_1093D4D0, 0x80u, "%s_%i", *(_DWORD *)(v6 + 24), v8);
            else
              sub_1002C120((int)byte_1093D4D0, *(_BYTE **)(v6 + 24), 128);
            v10 = sub_1001E610(*(_BYTE *)v6);
            if ( sub_1001E640(*(_BYTE *)(v6 + 16), v10) )
              sub_1001F2A0((int)byte_1093D4D0, v6, (int)&v12, (int)v9, v22, v8);
            v7 = *(_BYTE *)(v6 + 1);
            ++v15;
            ++v8;
            v9 += 8;
          }
          while ( v8 < (unsigned __int8)v7 );
        }
        LOBYTE(v3) = a2;
        v16 += 20;
        ++v4;
      }
      while ( v4 <= a2 );
    }
  }
  return v3;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001FDD0) --------------------------------------------------------
char __cdecl sub_1001FDD0(unsigned int a1, char a2, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, _DWORD *a6)
{
  char v6; // bl@1
  int v7; // eax@6
  char result; // al@21
  char v9; // [sp+4h] [bp-10h]@7
  char v10; // [sp+5h] [bp-Fh]@7
  unsigned int v11; // [sp+8h] [bp-Ch]@5
  __int16 v12; // [sp+Ch] [bp-8h]@5
  int v13; // [sp+10h] [bp-4h]@21
  unsigned int v14; // [sp+1Ch] [bp+8h]@5

  v6 = a2;
  if ( (unsigned __int8)a2 > 0x1Fu || a3 >= 0x18u || a4 >= 0x3Cu || a5 >= 0x3Cu )
  {
    *a6 = -1;
    result = 0;
  }
  else
  {
    sub_1002C6F0((int)&v11, a1);
    sub_1002C910((int)&v12, a1);
    v14 = v11;
    if ( !v6 )
    {
      v7 = v12 - a3;
      if ( v7 > -2 )
      {
        if ( v7 <= 22 )
        {
          v6 = BYTE1(v11);
        }
        else
        {
          sub_1002C6F0((int)&v9, a1 + 86400);
          v6 = v10;
        }
      }
      else
      {
        sub_1002C6F0((int)&v9, a1 - 86400);
        v6 = v10;
      }
    }
    if ( (unsigned __int8)v6 < 0x1Cu || BYTE1(v14) != 1 )
    {
      if ( BYTE1(v14) >= 0x1Cu && v6 == 1 )
      {
        if ( (_BYTE)v14 == 12 )
        {
          ++HIWORD(v14);
          LOBYTE(v14) = 1;
        }
        else
        {
          LOBYTE(v14) = v14 + 1;
        }
      }
    }
    else if ( (_BYTE)v14 == 1 )
    {
      --HIWORD(v14);
      LOBYTE(v14) = 12;
    }
    else
    {
      LOBYTE(v14) = v14 - 1;
    }
    BYTE1(v14) = v6;
    sub_1002C820(&v13, v14);
    *a6 = v13 + a5 + 60 * (a4 + 60 * a3);
    result = 1;
  }
  return result;
}

//----- (1001FF20) --------------------------------------------------------
int __cdecl sub_1001FF20(unsigned __int8 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 0x34u )
    result = *(_DWORD *)(dword_109FFDCC + 20 * a1 + 604) + *(_BYTE *)(dword_109FFDCC + 20 * a1 + 592);
  return result;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (1001FF50) --------------------------------------------------------
char __cdecl sub_1001FF50(unsigned __int8 a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  char *v4; // eax@1
  char result; // al@2

  v4 = sub_1001E4E0(a1);
  if ( v4 )
  {
    *a2 = v4[2];
    *a3 = v4[3];
    *a4 = v4[4];
    result = 1;
  }
  else
  {
    *a2 = -1;
    *a3 = -1;
    result = 0;
    *a4 = -1;
  }
  return result;
}

//----- (1001FFA0) --------------------------------------------------------
char __fastcall sub_1001FFA0(unsigned __int8 a1)
{
  int v1; // esi@1
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // ebp@1
  char result; // al@1
  int v7; // ebx@2
  unsigned int v8; // edx@2
  unsigned __int8 v9; // cl@4
  signed __int16 v10; // ax@7
  unsigned __int8 v11; // ST08_1@27
  char *v12; // eax@27
  int v13; // [sp+10h] [bp-Ch]@1
  int v14; // [sp+14h] [bp-8h]@2
  unsigned __int8 v15; // [sp+18h] [bp-4h]@1

  v1 = 20 * a1;
  v2 = *(_DWORD *)(v1 + dword_109FFDCC + 608);
  v3 = *(_DWORD *)(v2 + 24);
  v15 = a1 + 1;
  v4 = 20 * (unsigned __int8)(a1 + 1);
  v5 = *(_DWORD *)(*(_DWORD *)(v4 + dword_109FFDCC + 608) + 24);
  v13 = *(_DWORD *)(v2 + 24);
  result = sub_1001E6F0(a1, v2, 0);
  if ( result )
  {
    v14 = v5 + 5;
    v7 = v3 + 5;
    memset((void *)v5, 0, *(_DWORD *)(*(_DWORD *)(v4 + dword_109FFDCC + 608) + 20));
    *(_DWORD *)v5 = *(_DWORD *)v13;
    *(_WORD *)(v5 + 3) = 0;
    *(_BYTE *)(*(_DWORD *)(v4 + dword_109FFDCC + 608) + 8) = *(_BYTE *)(*(_DWORD *)(v1 + dword_109FFDCC + 608) + 8);
    *(_BYTE *)(*(_DWORD *)(v4 + dword_109FFDCC + 608) + 1) = *(_BYTE *)(*(_DWORD *)(v1 + dword_109FFDCC + 608) + 1);
    **(_BYTE **)(v4 + dword_109FFDCC + 608) = **(_BYTE **)(v1 + dword_109FFDCC + 608);
    *(_BYTE *)(*(_DWORD *)(v4 + dword_109FFDCC + 608) + 17) = *(_BYTE *)(*(_DWORD *)(v1 + dword_109FFDCC + 608) + 17);
    *(_DWORD *)(*(_DWORD *)(v4 + dword_109FFDCC + 608) + 30) = 5;
    *(_DWORD *)(*(_DWORD *)(v4 + dword_109FFDCC + 608) + 36) = 0;
    v8 = 0;
    if ( *(_WORD *)(v13 + 3) )
    {
      do
      {
        if ( *(_BYTE *)(v7 + 4) == 1 )
        {
          *(_DWORD *)v14 = *(_DWORD *)v7;
          v9 = *(_BYTE *)(v7 + 15);
          if ( v9 )
          {
            if ( *(_BYTE *)(v7 + 47) < 5u )
            {
              if ( *(_BYTE *)(v7 + 51) < 5u )
              {
                if ( *(_BYTE *)(v7 + 55) < 5u )
                {
                  if ( *(_BYTE *)(v7 + 59) < 5u )
                    v10 = 999;
                  else
                    v10 = *(_WORD *)(v7 + 57);
                }
                else
                {
                  v10 = *(_WORD *)(v7 + 53);
                }
              }
              else
              {
                v10 = *(_WORD *)(v7 + 49);
              }
            }
            else
            {
              v10 = *(_WORD *)(v7 + 45);
            }
            if ( v9 != 4 || (unsigned __int16)v10 < 0x1Eu )
            {
              if ( v9 <= 2u || (unsigned __int16)v10 < 0xAu )
              {
                if ( v9 <= 1u || (unsigned __int16)v10 < 5u )
                  *(_BYTE *)(v14 + 4) = 4;
                else
                  *(_BYTE *)(v14 + 4) = 3;
              }
              else
              {
                *(_BYTE *)(v14 + 4) = 2;
              }
            }
            else
            {
              *(_BYTE *)(v14 + 4) = 1;
            }
          }
          else
          {
            *(_BYTE *)(v14 + 4) = 0;
          }
          ++*(_WORD *)(v5 + 3);
          *(_DWORD *)(*(_DWORD *)(v4 + dword_109FFDCC + 608) + 36) += 5;
          v14 += 5;
        }
        ++v8;
        v7 += 77;
      }
      while ( v8 < *(_WORD *)(v13 + 3) );
    }
    sub_1001CD70(v15);
    v11 = *(_BYTE *)(v4 + dword_109FFDCC + 592);
    v12 = sub_1001E4E0(v15);
    result = (unsigned int)sub_1001FBF0((int)v12, v11);
  }
  return result;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (100201C0) --------------------------------------------------------
char __cdecl sub_100201C0(unsigned __int8 a1)
{
  int v1; // eax@1
  int v2; // eax@2
  int v3; // esi@4
  int v4; // eax@4
  int v5; // esi@4
  int v6; // edi@4
  int v7; // esi@6
  int v8; // edi@6
  int v9; // eax@6
  char v10; // dl@6
  char v12; // [sp+6h] [bp-Ah]@4
  char v13; // [sp+7h] [bp-9h]@5
  char v14; // [sp+8h] [bp-8h]@4
  char v15; // [sp+9h] [bp-7h]@5
  char v16; // [sp+Ah] [bp-6h]@4
  char v17; // [sp+Bh] [bp-5h]@5
  int v18; // [sp+Ch] [bp-4h]@4

  v1 = (unsigned __int8)sub_1001E5D0(a1) - 1;
  if ( v1 )
  {
    v2 = v1 - 4;
    if ( !v2 )
      LOBYTE(v2) = sub_1001FFA0(a1);
  }
  else
  {
    LOBYTE(v18) = a1 + 1;
    v3 = sub_1001FF20(a1);
    v4 = sub_1001FF20(a1 + 1);
    v5 = 132 * v3;
    v6 = 132 * v4;
    *(_BYTE *)(v5 + dword_109FFDCC + 1640) = 1;
    *(_BYTE *)(132 * v4 + dword_109FFDCC + 1632) = 0;
    LOBYTE(v2) = sub_1001FF50(a1, &v12, &v14, &v16);
    if ( (_BYTE)v2 )
    {
      LOBYTE(v2) = sub_1001FF50(a1 + 1, &v13, &v15, &v17);
      if ( (_BYTE)v2 )
      {
        v7 = *(_DWORD *)(v5 + dword_109FFDCC + 1656);
        v8 = *(_DWORD *)(v6 + dword_109FFDCC + 1656);
        v9 = v14;
        *(_BYTE *)(v13 + v8) = *(_BYTE *)(v12 + v7);
        v10 = *(_BYTE *)(v9 + v7);
        v2 = v16;
        *(_BYTE *)(v15 + v8) = v10;
        *(_BYTE *)(v17 + v8) = *(_BYTE *)(v2 + v7);
      }
    }
  }
  return v2;
}
// 109FFDCC: using guessed type int dword_109FFDCC;

//----- (100202C0) --------------------------------------------------------
char sub_100202C0()
{
  char *v0; // eax@1
  char *v1; // ecx@1
  signed int v2; // edx@1
  void *v3; // ecx@3
  char result; // al@3
  char v5; // [sp+4h] [bp-28h]@1
  char v6; // [sp+Ch] [bp-20h]@1

  v0 = &v5;
  v1 = &v6;
  v2 = 7;
  do
  {
    *v0 = 0;
    *(_DWORD *)v1 = 42066;
    ++v0;
    v1 += 4;
    --v2;
  }
  while ( v2 );
  sub_10060ED0(41104, (int)&v5, 36);
  dword_10942F98 = 0;
  dword_10942FA0 = 0;
  dword_10942F9C = 0;
  byte_1093D779 = 0;
  dword_1093D77C = 0;
  dword_10942F94 = 0;
  result = sub_1002C5E0(v3);
  byte_1093D778 = result;
  return result;
}
// 1093D778: using guessed type char byte_1093D778;
// 1093D779: using guessed type char byte_1093D779;
// 1093D77C: using guessed type int dword_1093D77C;
// 10942F94: using guessed type int dword_10942F94;
// 10942F98: using guessed type int dword_10942F98;
// 10942F9C: using guessed type int dword_10942F9C;
// 10942FA0: using guessed type int dword_10942FA0;

//----- (10020350) --------------------------------------------------------
char __cdecl sub_10020350(int a1, int a2)
{
  int v2; // ecx@0
  int v3; // eax@1
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  LOBYTE(v3) = sub_100144D0(a1, a2, &dword_1093D780, (unsigned __int16 *)&v5);
  if ( (_BYTE)v3 == 1 )
  {
    v3 = j_REG_pvg_xfil_write_data(&dword_1093D780, (unsigned __int16)v5);
    if ( v3 != (unsigned __int16)v5 )
      LOBYTE(v3) = sub_10028BC0("..\\lib\\adl\\iop_xfil_reg_frmt.c", 345, 0, 0);
  }
  return v3;
}
// 10060FF0: using guessed type int __cdecl j_REG_pvg_xfil_write_data(_DWORD, _DWORD);
// 1093D780: using guessed type int dword_1093D780;

//----- (100203B0) --------------------------------------------------------
char __cdecl sub_100203B0(int a1, int a2, __int16 a3)
{
  int v4; // [sp+0h] [bp-Ch]@1
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v6 = 0;
  v4 = a2;
  LOWORD(v6) = a3;
  v5 = sub_1002C660((void *)a3);
  return sub_10013ED0(254, a1, &v4, 1, (int)&byte_10A08A80);
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10020400) --------------------------------------------------------
int __cdecl sub_10020400(int a1, int a2)
{
  int v2; // ebx@1
  void *v3; // ecx@1
  int result; // eax@1

  v2 = sub_10012AC0(a1, a2);
  result = sub_1002C5C0(v3);
  if ( v2 & result )
  {
    sub_1002D550(0x3Fu);
    result = *(_DWORD *)(a2 + 32);
    dword_10942F98 |= *(_DWORD *)(52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)a1) + result + 20);
  }
  return result;
}
// 10942F94: using guessed type int dword_10942F94;
// 10942F98: using guessed type int dword_10942F98;

//----- (10020450) --------------------------------------------------------
char __cdecl sub_10020450(int a1)
{
  unsigned int v1; // eax@2
  char v2; // dl@3
  int v3; // ecx@5
  int v4; // eax@5
  __int16 v5; // si@8
  int v6; // eax@8
  char v8; // [sp+0h] [bp-2B8h]@8

  if ( !dword_1093D77C || (v1 = sub_10060900(), dword_1093D77C <= v1) )
  {
    v2 = byte_1093D779;
    if ( (unsigned __int8)byte_1093D779 >= 0x32u )
    {
      v2 = 0;
      byte_1093D779 = 0;
    }
    v3 = 58 * (unsigned __int8)v2;
    v4 = 58;
    if ( v3 + 58 > 2880 )
    {
      v4 = 2880 - v3;
      if ( 2880 - v3 <= 0 )
      {
        v2 = 0;
        v4 = 58;
        byte_1093D779 = 0;
      }
    }
    v5 = j_reg_get_xfil_tag_data(&v8, 58 * (unsigned __int8)v2, v4);
    v6 = sub_10060900();
    LOBYTE(v1) = sub_10013920(a1, 12 * v5, 1, (int)&byte_10A08A80, &v8, v6);
    ++byte_1093D779;
  }
  return v1;
}
// 10060D60: using guessed type int __cdecl j_reg_get_xfil_tag_data(_DWORD, _DWORD, _DWORD);
// 1093D779: using guessed type char byte_1093D779;
// 1093D77C: using guessed type int dword_1093D77C;
// 10A08A80: using guessed type char byte_10A08A80;

//----- (10020500) --------------------------------------------------------
__int16 __thiscall sub_10020500(void *this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = sub_1002C660(this);
  return word_100A33DC[4 * sub_1002CC90(&v2, 4u, (int)&unk_100A33D8, 8, 7, 0)];
}
// 100A33DC: using guessed type __int16 word_100A33DC[];

//----- (10020530) --------------------------------------------------------
char __cdecl sub_10020530(int a1, int a2, unsigned __int16 a3)
{
  signed int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@1
  int v6; // esi@8
  unsigned int v7; // ebp@8
  unsigned int v8; // edi@9
  int v9; // edi@15
  int v10; // ecx@20
  char v12; // [sp+13h] [bp-29h]@1
  char v13[8]; // [sp+14h] [bp-28h]@2
  int v14[7]; // [sp+1Ch] [bp-20h]@15

  v3 = a3 / 0xCu;
  LOBYTE(v4) = sub_1002D8B0(a1);
  v5 = v4;
  v12 = 0;
  if ( byte_1093D778 == 2 )
    LOBYTE(v4) = sub_10060D80(41104, (int)v13, 36);
  if ( (unsigned int)(v3 - 1) <= 0x4D && !(a3 % 0xCu) )
  {
    if ( !dword_1093D77C || (v4 = sub_10060900(), dword_1093D77C <= v4) )
    {
      if ( v3 > 0 )
      {
        v6 = a2 + 2;
        v7 = a3 / 0xCu;
        while ( 1 )
        {
          v4 = j_REG_pvg_xfil_shld_rqst_tag(v6 - 2);
          v8 = v4;
          if ( v4 == 2 )
            LOBYTE(v4) = sub_100203B0(a1, *(_WORD *)v6, *(_WORD *)(v6 + 8));
          if ( byte_1093D778 != 2 )
            goto LABEL_22;
          if ( v5 == 7 )
            goto LABEL_22;
          LOBYTE(v4) = sub_100297B0(*(_WORD *)v6);
          if ( !(_BYTE)v4 )
            goto LABEL_22;
          if ( v8 != 1 )
          {
            v10 = *(_WORD *)v6;
            v4 = v5;
            v13[v4] = 0;
            v14[v4] = v10;
            goto LABEL_21;
          }
          v4 = *(_WORD *)v6;
          v9 = v14[v5];
          if ( v4 == v9 )
          {
            v4 = (unsigned int)&v13[v5];
            if ( v13[v5] != 1 )
            {
              *(_BYTE *)v4 = 1;
LABEL_21:
              v12 = 1;
              goto LABEL_22;
            }
          }
          else if ( v9 == 42066 )
          {
            v14[v5] = v4;
            goto LABEL_21;
          }
LABEL_22:
          v6 += 12;
          if ( !--v7 )
          {
            if ( v12 )
              LOBYTE(v4) = sub_10060ED0(41104, (int)v13, 36);
            return v4;
          }
        }
      }
    }
  }
  return v4;
}
// 10060FE0: using guessed type int __cdecl j_REG_pvg_xfil_shld_rqst_tag(_DWORD);
// 1093D778: using guessed type char byte_1093D778;
// 1093D77C: using guessed type int dword_1093D77C;
// 10020530: using guessed type char var_28[8];
// 10020530: using guessed type int var_20[7];

//----- (10020690) --------------------------------------------------------
char __cdecl sub_10020690(const void *a1, unsigned __int16 a2, int a3)
{
  void *v3; // ecx@0
  int v4; // esi@1
  int v5; // eax@1

  v4 = (unsigned __int16)sub_10020500(v3);
  v5 = sub_10060900();
  sub_10013920(v4, a2, 1, (int)&byte_10A08A80, a1, v5);
  return sub_10013C10(v4, a3, (int)&byte_10A08A80);
}
// 10A08A80: using guessed type char byte_10A08A80;

//----- (100206D0) --------------------------------------------------------
char __cdecl sub_100206D0(int a1, int a2)
{
  int v2; // eax@2
  int v3; // eax@4
  int v5; // [sp+8h] [bp-4h]@1

  memset(&unk_10942FA8, 0, 0x3A8u);
  if ( sub_100144D0(a1, a2, &unk_10942FA8, (unsigned __int16 *)&v5) == 1 )
  {
    v2 = sub_100208B0(a1);
    sub_10020530(v2, (int)&unk_10942FA8, v5);
  }
  if ( dword_10942F98 || (LOBYTE(v3) = sub_1002D390(63), (_BYTE)v3) )
  {
    v3 = ~*(_DWORD *)(52 * *(_WORD *)(*(_DWORD *)(a2 + 40) + 2 * (unsigned __int16)a1) + *(_DWORD *)(a2 + 32) + 20);
    dword_10942F98 &= v3;
    if ( !dword_10942F98 )
      LOBYTE(v3) = sub_1002D440(63);
  }
  return v3;
}
// 10942F98: using guessed type int dword_10942F98;

//----- (10020760) --------------------------------------------------------
int __cdecl sub_10020760(int a1, __int16 a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@5
  bool v6; // zf@6

  dword_1093D780 = 0;
  dword_1093D784 = 0;
  dword_1093D788 = 0;
  dword_1093D78C = 0;
  byte_1093D790 = 0;
  result = j_REG_pvg_xfil_read_data(a1, &dword_1093D780, 22545, 1436);
  v4 = result;
  if ( result >= 0 && result )
  {
    if ( a1 == -1 || a2 == (_WORD)dword_1093D784 )
    {
      sub_10020690(&dword_1093D780, result, a3);
      v5 = 0;
      while ( 1 )
      {
        v6 = *(int *)((char *)&dword_1093D788 + v5) == 3134;
        v5 += *(_WORD *)((char *)&dword_1093D784 + v5) + 17;
        if ( v6 )
          break;
        if ( v5 >= v4 )
          return v4;
      }
      dword_1093D77C = sub_10060900() + 7000;
    }
    result = v4;
  }
  return result;
}
// 10060FD0: using guessed type int __cdecl j_REG_pvg_xfil_read_data(_DWORD, _DWORD, _DWORD, _DWORD);
// 1093D77C: using guessed type int dword_1093D77C;
// 1093D780: using guessed type int dword_1093D780;
// 1093D784: using guessed type int dword_1093D784;
// 1093D788: using guessed type int dword_1093D788;
// 1093D78C: using guessed type int dword_1093D78C;
// 1093D790: using guessed type char byte_1093D790;

//----- (10020810) --------------------------------------------------------
char __cdecl sub_10020810(int a1, int a2)
{
  char result; // al@1
  int v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@1
  int v5; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v5 = 0;
  result = sub_100144B0(a1, a2, &v3);
  if ( result == 1 )
    result = sub_10020760(v3, v5, v4);
  return result;
}

//----- (10020860) --------------------------------------------------------
int sub_10020860()
{
  signed int v0; // esi@1
  int result; // eax@2

  v0 = 0;
  do
  {
    result = sub_10020760(-1, 0, 0xFFFFFFF);
    if ( result <= 0 )
      break;
    ++v0;
  }
  while ( v0 < 10 );
  if ( v0 <= 0 || dword_10942F94 > 50 )
  {
    result = j_REG_pvg_flush_que(3, 1, 12);
    dword_10942F94 = 0;
  }
  else
  {
    ++dword_10942F94;
  }
  return result;
}
// 10060D10: using guessed type int __cdecl j_REG_pvg_flush_que(_DWORD, _DWORD, _DWORD);
// 10942F94: using guessed type int dword_10942F94;

//----- (100208B0) --------------------------------------------------------
int __cdecl sub_100208B0(char a1)
{
  return dword_100A3994[2 * sub_1002CC90(&a1, 2u, (int)&unk_100A3990, 8, 7, 0)];
}
// 100A3994: using guessed type int dword_100A3994[];

//----- (100208E0) --------------------------------------------------------
int __cdecl sub_100208E0(int a1, int a2)
{
  if ( a1 == 2 )
  {
    sub_10020990();
    return 4;
  }
  if ( a1 != 8 )
    return 4;
  if ( *(_DWORD *)a2 != 4 )
    sub_10028BC0(".\\test\\nav_test_suite_2.c", 160, 1, 0);
  if ( *(_DWORD *)(a2 + 84) != 6 )
    sub_10028BC0(".\\test\\nav_test_suite_2.c", 161, 1, 0);
  if ( *(_DWORD *)(a2 + 168) != 6 )
    sub_10028BC0(".\\test\\nav_test_suite_2.c", 162, 1, 0);
  return sub_100209D0(*(_DWORD *)(a2 + 4), *(float *)(a2 + 88), *(float *)(a2 + 172));
}

//----- (10020980) --------------------------------------------------------
char **sub_10020980()
{
  return off_100A3A90;
}
// 100A3A90: using guessed type char *off_100A3A90[3];

//----- (10020990) --------------------------------------------------------
void *sub_10020990()
{
  memset(flt_10943350, 0, 0xC8u);
  byte_10943418 = 0;
  memset(flt_10943420, 0, 0xC8u);
  return memset(byte_109434E8, 0, 0x32u);
}
// 10943350: using guessed type float flt_10943350[];
// 10943418: using guessed type char byte_10943418;
// 10943420: using guessed type float flt_10943420[];

//----- (100209D0) --------------------------------------------------------
int __cdecl sub_100209D0(int a1, float a2, float a3)
{
  int result; // eax@2

  if ( (unsigned int)a1 >= 0x32 )
  {
    if ( a1 == 98 )
    {
      sub_10020990();
      result = 0;
    }
    else if ( a1 == 99 )
    {
      memset32(flt_10943350, SLODWORD(a3), 0x32u);
      byte_10943418 = 1;
      memset32(flt_10943420, SLODWORD(a2), 0x32u);
      memset(byte_109434E8, 1, 0x32u);
      result = 0;
    }
    else
    {
      result = 9;
    }
  }
  else
  {
    byte_109434E8[a1] = 1;
    flt_10943420[a1] = a2;
    byte_10943418 = 0;
    flt_10943350[a1] = a3;
    result = 0;
  }
  return result;
}
// 10943350: using guessed type float flt_10943350[];
// 10943418: using guessed type char byte_10943418;
// 10943420: using guessed type float flt_10943420[];

//----- (10020A60) --------------------------------------------------------
char *__cdecl sub_10020A60(char *a1, char *a2, size_t a3)
{
  char *result; // eax@2
  const char *v4; // eax@3

  if ( a1 == (char *)4 )
  {
    v4 = (const char *)SIM_proc_rqst(13);
    result = strncpy(a2, v4, a3);
  }
  else
  {
    *a2 = 0;
    result = strncpy(a2, a1, a3);
  }
  return result;
}
// 10068506: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10020AA0) --------------------------------------------------------
int (**sub_10020AA0())()
{
  return off_100A3AA4;
}
// 100A3AA4: using guessed type int (*off_100A3AA4[4])();

//----- (10020AC0) --------------------------------------------------------
int __usercall sub_10020AC0@<eax>(int a1@<edi>, int a2@<esi>)
{
  char v3; // [sp+0h] [bp-18h]@1

  sub_10060E00(2122, (int)&v3, 20);
  switch ( a1 )
  {
    case 0:
      v3 = 0;
      if ( a2 )
        v3 = 15;
      break;
    case 1:
      v3 &= 0xFEu;
      if ( a2 )
        v3 |= 1u;
      break;
    case 2:
      v3 &= 0xFDu;
      if ( a2 )
        v3 |= 2u;
      break;
    case 3:
      v3 &= 0xFBu;
      if ( a2 )
        v3 |= 4u;
      break;
    case 4:
      v3 &= 0xF7u;
      if ( a2 )
        v3 |= 8u;
      break;
    default:
      break;
  }
  sub_10060ED0(2122, (int)&v3, 20);
  return 0;
}

//----- (10020B70) --------------------------------------------------------
int __cdecl sub_10020B70(int a1, int a2)
{
  int result; // eax@1

  result = 4;
  if ( a1 == 8 )
  {
    if ( *(_DWORD *)a2 != 4 )
      sub_10028BC0(".\\test\\wwwx_test_suite.c", 175, 1, 0);
    if ( *(_DWORD *)(a2 + 84) != 4 )
      sub_10028BC0(".\\test\\wwwx_test_suite.c", 176, 1, 0);
    result = sub_10020AC0(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 88));
  }
  return result;
}

//----- (10020BD0) --------------------------------------------------------
char **sub_10020BD0()
{
  return off_100A3B48;
}
// 100A3B48: using guessed type char *off_100A3B48[3];

//----- (10020BE0) --------------------------------------------------------
int __cdecl sub_10020BE0(int a1)
{
  int result; // eax@1

  result = a1;
  if ( *(_DWORD *)(a1 + 4) )
  {
    ++*(_DWORD *)a1;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return result;
}

//----- (10020C00) --------------------------------------------------------
int __cdecl sub_10020C00(int *a1, char a2)
{
  int *v2; // ecx@2
  int result; // eax@2

  if ( a2 )
  {
    sub_10020BE0((int)a1);
    result = *v2;
  }
  else
  {
    result = *a1;
  }
  return result;
}

//----- (10020C20) --------------------------------------------------------
int __cdecl sub_10020C20(int a1)
{
  return 8 * (*(_DWORD *)(a1 + 8) - *(_DWORD *)a1) - *(_DWORD *)(a1 + 4);
}

//----- (10020C40) --------------------------------------------------------
int __cdecl sub_10020C40(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (10020C60) --------------------------------------------------------
int __cdecl sub_10020C60(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@1

  v2 = a2 + *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 += (unsigned int)(a2 + *(_DWORD *)(a1 + 4)) >> 3;
  result = v2 & 7;
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (10020C80) --------------------------------------------------------
unsigned int __cdecl sub_10020C80(int a1, char a2, char a3)
{
  char v3; // bl@1
  int v4; // edi@3
  int v5; // ecx@6
  char v6; // bl@10
  int v7; // ST04_4@10
  unsigned int v9; // ebp@13

  v3 = a2;
  if ( a3 && *(_BYTE *)(*(_DWORD *)(a1 + 12) + *(_DWORD *)a1) & (unsigned __int8)byte_100A3B5C[*(_DWORD *)(a1 + 4)] )
    v4 = -1;
  else
    v4 = 0;
  if ( a2 )
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(a1 + 4);
      if ( v5 || (unsigned __int8)v3 < 8u )
      {
        if ( v5 + (unsigned int)(unsigned __int8)v3 <= 8 )
        {
          v9 = (v4 << v3) | (255 >> (8 - v3)) & ((unsigned int)*(_BYTE *)(*(_DWORD *)(a1 + 12) + *(_DWORD *)a1) >> (8 - *(_BYTE *)(a1 + 4) - v3));
          sub_10020C60(a1, (unsigned __int8)v3);
          return v9;
        }
        v6 = 8 - v5;
        v7 = (unsigned __int8)(8 - v5);
        v4 = (255 >> v5) & *(_BYTE *)(*(_DWORD *)(a1 + 12) + *(_DWORD *)a1) | (v4 << v7);
        sub_10020C60(a1, v7);
        a2 -= v6;
        v3 = a2;
      }
      else
      {
        v4 = *(_BYTE *)(*(_DWORD *)(a1 + 12) + *(_DWORD *)a1) | (v4 << 8);
        sub_10020C60(a1, 8);
        v3 -= 8;
        a2 = v3;
      }
      if ( !v3 )
        return v4;
    }
  }
  return v4;
}

//----- (10020D80) --------------------------------------------------------
void sub_10020D80()
{
  dword_1094351C = -15;
}
// 1094351C: using guessed type int dword_1094351C;

//----- (10020D90) --------------------------------------------------------
void sub_10020D90()
{
  dword_10A09200 = -15;
}
// 10A09200: using guessed type int dword_10A09200;

//----- (10020DA0) --------------------------------------------------------
char __thiscall sub_10020DA0(void *this)
{
  int v1; // eax@1
  bool v2; // zf@1
  char result; // al@1

  v1 = sub_1002C660(this);
  v2 = sub_1002D420(28, v1) == 1;
  result = 1;
  if ( !v2 )
    result = 2;
  return result;
}

//----- (10020DC0) --------------------------------------------------------
char __cdecl sub_10020DC0(void *a1, char *a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  char result; // al@2
  int v5; // eax@3
  char v6; // [sp+7h] [bp-1h]@1

  v6 = 3;
  v3 = sub_1002DB00(v2);
  if ( (_BYTE)a1 == sub_1002D790(v3) )
  {
    *a2 = sub_10020DA0(a1);
    result = 1;
  }
  else
  {
    v5 = (unsigned __int16)sub_1002DBC0((unsigned __int8)a1);
    if ( (_WORD)v5 == 904 || sub_10015AC0(2, v5, &v6) != 1 || sub_1003A7A0((unsigned __int8 *)&v6) )
    {
      result = 0;
    }
    else
    {
      *a2 = v6;
      result = 1;
    }
  }
  return result;
}

//----- (10020E40) --------------------------------------------------------
char sub_10020E40()
{
  char v1; // [sp+3h] [bp-5h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 356), 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (10020E80) --------------------------------------------------------
char sub_10020E80()
{
  char v1; // [sp+3h] [bp-5h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 384), 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (10020EC0) --------------------------------------------------------
char sub_10020EC0()
{
  char v1; // [sp+3h] [bp-5h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 396), 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (10020F00) --------------------------------------------------------
char sub_10020F00()
{
  char v1; // [sp+3h] [bp-5h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 1012), 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (10020F40) --------------------------------------------------------
char sub_10020F40()
{
  char v1; // [sp+3h] [bp-5h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 1260), 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (10020F80) --------------------------------------------------------
char sub_10020F80()
{
  char v1; // [sp+3h] [bp-5h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 1276), 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (10020FC0) --------------------------------------------------------
char sub_10020FC0()
{
  char v1; // [sp+3h] [bp-5h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 1324), 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (10021000) --------------------------------------------------------
char sub_10021000()
{
  char v1; // [sp+3h] [bp-5h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 1336), 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (10021040) --------------------------------------------------------
signed int sub_10021040()
{
  signed int result; // eax@1

  byte_10943521 = j_HWM_pvg_read_reg(1);
  result = -15;
  byte_10943520 = 0;
  dword_10943528 = -15;
  dword_10943524 = -15;
  return result;
}
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10943520: using guessed type char byte_10943520;
// 10943521: using guessed type char byte_10943521;
// 10943524: using guessed type int dword_10943524;
// 10943528: using guessed type int dword_10943528;

//----- (10021070) --------------------------------------------------------
BOOL __cdecl sub_10021070(int a1)
{
  return sub_10060D80(6468, a1, 288) == 0;
}

//----- (10021090) --------------------------------------------------------
BOOL sub_10021090()
{
  char v1; // [sp+0h] [bp-124h]@1
  char v2; // [sp+60h] [bp-C4h]@2

  return (unsigned __int8)sub_10021070((int)&v1) && v2;
}

//----- (100210F0) --------------------------------------------------------
char __cdecl sub_100210F0(int a1)
{
  char v1; // bl@1
  char v3; // [sp+4h] [bp-144h]@2
  char v4; // [sp+10h] [bp-138h]@2
  char v5; // [sp+24h] [bp-124h]@1
  char v6; // [sp+30h] [bp-118h]@2

  v1 = sub_10021070((int)&v5);
  if ( v1 )
  {
    sub_1002C120((int)&v3, &v5, 12);
    sub_1002C120((int)&v4, &v6, 20);
    sub_10015560(2, 378, &v3, 0, 32, 1);
    sub_10015710(2, 378, a1);
  }
  return v1;
}

//----- (10021180) --------------------------------------------------------
bool __cdecl sub_10021180(void *a1)
{
  bool v1; // bl@1
  void *v2; // ecx@1
  int v3; // eax@1

  v1 = sub_10060EF0(6468, (int)a1, 288) == 0;
  v3 = sub_1002C660(v2);
  if ( v1 && v3 != 1 )
  {
    sub_10015560(2, 42, a1, 0, 288, 1);
    sub_10015710(2, 42, 1);
  }
  return v1;
}

//----- (100211E0) --------------------------------------------------------
bool sub_100211E0()
{
  bool v0; // bl@1
  char v2; // [sp+4h] [bp-124h]@1

  memset(&v2, 0, 0x120u);
  v0 = sub_10021180(&v2);
  sub_1002D550(0xD4u);
  return v0;
}

//----- (10021240) --------------------------------------------------------
_BYTE *__usercall sub_10021240@<eax>(_BYTE *result@<eax>)
{
  if ( *result )
    ++result;
  return result;
}

//----- (10021250) --------------------------------------------------------
char *__usercall sub_10021250@<eax>(const char *a1@<eax>)
{
  return strstr(a1, "RMK");
}

//----- (10021260) --------------------------------------------------------
char *__usercall sub_10021260@<eax>(const char *a1@<esi>)
{
  char *result; // eax@1

  result = strstr(a1, "PROB");
  if ( !result )
  {
    result = strstr(a1, "BECMG");
    if ( !result )
    {
      result = strstr(a1, "TEMPO");
      if ( !result )
        result = strstr(a1, "NOSIG");
    }
  }
  return result;
}

//----- (100212B0) --------------------------------------------------------
char __usercall sub_100212B0@<al>(int a1@<esi>, unsigned __int8 a2)
{
  unsigned __int8 v2; // bl@1
  char result; // al@4

  v2 = 0;
  if ( a2 )
  {
    while ( isalpha(*(_BYTE *)(v2 + a1)) )
    {
      if ( ++v2 >= a2 )
        goto LABEL_4;
    }
    result = 0;
  }
  else
  {
LABEL_4:
    result = 1;
  }
  return result;
}

//----- (100212F0) --------------------------------------------------------
char __usercall sub_100212F0@<al>(int a1@<esi>, unsigned __int8 a2)
{
  unsigned __int8 v2; // bl@1
  char result; // al@4

  v2 = 0;
  if ( a2 )
  {
    while ( isdigit(*(_BYTE *)(v2 + a1)) )
    {
      if ( ++v2 >= a2 )
        goto LABEL_4;
    }
    result = 0;
  }
  else
  {
LABEL_4:
    result = 1;
  }
  return result;
}

//----- (10021330) --------------------------------------------------------
signed int __usercall sub_10021330@<eax>(int a1@<esi>)
{
  signed int result; // eax@1

  memset((void *)a1, 0, 0x4Du);
  result = 255;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 14) = -1;
  *(_BYTE *)(a1 + 13) = -1;
  *(_BYTE *)(a1 + 11) = -1;
  *(_BYTE *)(a1 + 12) = -1;
  *(_WORD *)(a1 + 24) = 255;
  *(_WORD *)(a1 + 41) = 0x7FFF;
  *(_WORD *)(a1 + 43) = 0x7FFF;
  *(_BYTE *)(a1 + 39) = -1;
  *(_BYTE *)(a1 + 38) = -1;
  return result;
}

//----- (10021370) --------------------------------------------------------
char __usercall sub_10021370@<al>(const char *a1@<eax>, int a2@<edi>)
{
  const char *v2; // esi@1

  v2 = a1;
  if ( !strncmp(a1, "AUTO", 4u) )
  {
    *(_BYTE *)(a2 + 8) = 1;
    v2 += 5;
  }
  if ( !strncmp(v2, "COR", 3u) )
  {
    *(_BYTE *)(a2 + 9) = 1;
    v2 += 4;
  }
  strstr(v2, "CAVOK");
  return 1;
}

//----- (100213C0) --------------------------------------------------------
char __usercall sub_100213C0@<al>(const char *a1@<eax>, int a2)
{
  const char *v2; // esi@1
  char *v3; // eax@1
  char *i; // edi@8
  int v5; // edi@10
  unsigned __int16 v6; // ax@21
  unsigned int v7; // ebx@30
  int v8; // edi@35
  unsigned int v9; // esi@38
  unsigned int v10; // edi@38
  int v11; // ecx@41
  char v13; // al@49
  unsigned int v14; // eax@52
  char v15; // al@61
  char v16; // [sp+Dh] [bp-17h]@4
  char v17; // [sp+Eh] [bp-16h]@2
  char v18[4]; // [sp+10h] [bp-14h]@10
  char v19[4]; // [sp+14h] [bp-10h]@10
  unsigned int v20; // [sp+18h] [bp-Ch]@1
  __int64 v21; // [sp+1Ch] [bp-8h]@1

  v2 = a1;
  LODWORD(v21) = 255;
  v20 = 255;
  v3 = strstr(a1, "KMH");
  if ( v3 )
  {
    v17 = 0;
  }
  else
  {
    v3 = strstr(v2, "KT");
    if ( v3 )
    {
      v17 = 1;
      v16 = 2;
      goto LABEL_8;
    }
    v3 = strstr(v2, "MPS");
    if ( !v3 )
      return 1;
    v17 = 2;
  }
  v16 = 3;
LABEL_8:
  for ( i = v3; *i != 32; --i )
    ;
  v5 = (int)(i + 1);
  *(_DWORD *)v18 = 0;
  *(_DWORD *)v19 = 0;
  if ( strncmp((const char *)v5, "VRB", 3u) )
  {
    if ( sub_100212F0(v5, 6u) == 1 )
    {
      strncpy(v18, (const char *)v5, 3u);
      strncpy(v19, (const char *)(v5 + 3), 3u);
      LODWORD(v21) = (unsigned __int16)j__atol(v18);
      v20 = (unsigned __int16)j__atol(v19);
      v5 += 6;
      goto LABEL_28;
    }
    if ( sub_100212F0(v5, 5u) == 1 )
    {
      strncpy(v18, (const char *)v5, 3u);
      strncpy(v19, (const char *)(v5 + 3), 2u);
      LODWORD(v21) = (unsigned __int16)j__atol(v18);
      v20 = (unsigned __int16)j__atol(v19);
      v5 += 5;
      goto LABEL_28;
    }
    if ( sub_100212F0(v5, 3u) != 1 )
      return 1;
    if ( !strncmp((const char *)(v5 + 3), "P99KT", 5u) )
    {
      strncpy(v18, (const char *)v5, 3u);
      v6 = j__atol(v18);
      v20 = 99;
      v5 += 3;
    }
    else if ( !strncmp((const char *)(v5 + 3), "P49MPS", 6u) )
    {
      strncpy(v18, (const char *)v5, 3u);
      v6 = j__atol(v18);
      v20 = 49;
      v5 += 3;
    }
    else
    {
      if ( strncmp((const char *)(v5 + 3), "P199KMH", 7u) )
      {
LABEL_27:
        v5 += 3;
        goto LABEL_28;
      }
      strncpy(v18, (const char *)v5, 3u);
      v6 = j__atol(v18);
      v20 = 199;
      v5 += 4;
    }
    LODWORD(v21) = v6;
    goto LABEL_27;
  }
  if ( sub_100212F0(v5 + 3, 3u) == 1 )
  {
    strncpy(v19, (const char *)(v5 + 3), 3u);
    v20 = (unsigned __int16)j__atol(v19);
    LODWORD(v21) = 255;
    v5 += 6;
  }
  else if ( sub_100212F0(v5 + 3, 2u) == 1 )
  {
    strncpy(v19, (const char *)(v5 + 3), 2u);
    v20 = (unsigned __int16)j__atol(v19);
    LODWORD(v21) = 255;
    v5 += 5;
  }
LABEL_28:
  *(_DWORD *)v19 = 0;
  if ( *(_BYTE *)v5 != 71 )
    goto LABEL_34;
  if ( sub_100212F0(v5 + 1, 3u) != 1 )
  {
    if ( *(_BYTE *)v5 == 71 && sub_100212F0(v5 + 1, 2u) == 1 )
    {
      strncpy(v19, (const char *)(v5 + 1), 2u);
      v7 = (unsigned __int16)j__atol(v19);
      v5 += 3;
      goto LABEL_35;
    }
LABEL_34:
    v7 = 0;
    goto LABEL_35;
  }
  strncpy(v19, (const char *)(v5 + 1), 3u);
  v7 = (unsigned __int16)j__atol(v19);
  v5 += 4;
LABEL_35:
  v8 = (unsigned __int8)v16 + v5;
  *(_DWORD *)v18 = 0;
  if ( *(_BYTE *)(v8 + 4) != 86 || sub_100212F0(v8 + 1, 3u) != 1 || sub_100212F0(v8 + 5, 3u) != 1 )
  {
    v9 = -1;
    v10 = -1;
  }
  else
  {
    strncpy(v18, (const char *)(v8 + 1), 3u);
    v9 = (unsigned __int16)j__atol(v18);
    strncpy(v18, (const char *)(v8 + 5), 3u);
    v10 = (unsigned __int16)j__atol(v18);
  }
  if ( (_DWORD)v21 == 255 )
  {
    v11 = a2;
  }
  else
  {
    v11 = a2;
    *(_BYTE *)(a2 + 10) = (unsigned int)v21 / 0xA;
  }
  if ( v9 != -1 )
  {
    *(_BYTE *)(v11 + 11) = v9 / 0xA;
    *(_BYTE *)(v11 + 12) = v10 / 0xA;
  }
  if ( !v17 )
  {
    v21 = (signed __int64)((double)v20 * 0.2777777777777778 * 1.943844492440605);
    v15 = v21;
    if ( (unsigned int)v21 > 0xFE )
      v15 = -1;
    *(_BYTE *)(v11 + 13) = v15;
    if ( v7 )
    {
      v21 = (signed __int64)(1.943844492440605 * (0.2777777777777778 * (double)v7));
      v14 = v21;
      goto LABEL_53;
    }
    return 1;
  }
  if ( v17 == 1 )
  {
    if ( v20 > 0xFE )
      v20 = 255;
    *(_BYTE *)(v11 + 13) = v20;
    if ( v7 && v7 < 0xFE )
    {
      *(_BYTE *)(v11 + 14) = v7;
      return 1;
    }
    return 1;
  }
  if ( v17 != 2 )
  {
    *(_BYTE *)(v11 + 4) = 0;
    return 1;
  }
  v21 = (signed __int64)((double)v20 * 1.943844492440605);
  v13 = v21;
  if ( (unsigned int)v21 > 0xFE )
    v13 = -1;
  *(_BYTE *)(v11 + 13) = v13;
  if ( !v7 )
    return 1;
  v21 = (signed __int64)(1.943844492440605 * (double)v7);
  v14 = v21;
LABEL_53:
  if ( v14 > 0xFE )
    LOBYTE(v14) = -1;
  *(_BYTE *)(v11 + 14) = v14;
  return 1;
}

//----- (10021950) --------------------------------------------------------
char __usercall sub_10021950@<al>(_BYTE *a1@<eax>)
{
  _BYTE *v1; // esi@1
  char v2; // bl@1
  int v3; // ecx@2

  v1 = a1;
  v2 = 0;
  if ( isalpha(*a1) )
  {
    do
    {
      v3 = (v1++)[1];
      ++v2;
    }
    while ( isalpha(v3) );
  }
  return v2;
}

//----- (10021990) --------------------------------------------------------
char *__usercall sub_10021990@<eax>(char *result@<eax>)
{
  char v1; // cl@1

  v1 = *result;
  if ( *result != 32 )
  {
    while ( v1 )
    {
      v1 = (result++)[1];
      if ( v1 == 32 )
      {
        ++result;
        return result;
      }
    }
  }
  if ( *result == 32 )
    ++result;
  return result;
}

//----- (100219C0) --------------------------------------------------------
char __cdecl sub_100219C0(int a1, char a2)
{
  char *v2; // ecx@0
  char *v3; // esi@1
  unsigned __int8 v5; // bl@8
  int v6; // eax@12
  char *v7; // eax@13
  int v8; // esi@15
  int v9; // esi@27
  char *v10; // eax@29
  char v11; // al@31
  char v12; // dl@32
  __int16 v13; // cx@32
  char v14; // cl@34
  __int16 v15; // dx@34
  char v16; // dl@36
  __int16 v17; // cx@36
  char v18; // cl@38
  __int16 v19; // dx@38
  char v20; // [sp+13h] [bp-19h]@1
  int v21; // [sp+14h] [bp-18h]@1
  int v22; // [sp+18h] [bp-14h]@1
  char v23[4]; // [sp+1Ch] [bp-10h]@8
  int v24; // [sp+20h] [bp-Ch]@1
  int v25; // [sp+24h] [bp-8h]@1

  v24 = 0;
  v25 = 0;
  v20 = 0;
  v3 = v2;
  v22 = 0;
  v21 = 0;
  if ( (signed int)(unsigned __int8)a2 > 0 )
  {
    do
    {
      if ( !*v3 )
        return 1;
      while ( sub_100212B0((int)v3, 3u) != 1 && strncmp(v3, "VV", 2u) )
      {
        v3 = sub_10021990(v3);
        if ( !*v3 )
          return 1;
      }
      if ( !*v3 )
        return 1;
      *(_DWORD *)v23 = 0;
      v5 = 0;
      while ( strncmp(v3, &byte_100A5DE1[5 * v5], 3u) )
      {
        if ( ++v5 >= 4u )
          goto LABEL_11;
      }
      if ( v5 >= 4u )
      {
LABEL_11:
        if ( !strncmp(v3, "SKC", 3u) )
          goto LABEL_12;
        if ( !strncmp(v3, "CLR", 3u) )
        {
          v6 = v20;
          *((_BYTE *)&v22 + v20) = 1;
          goto LABEL_13;
        }
        if ( !strncmp(v3, "NSC", 3u) )
        {
LABEL_12:
          v6 = v20;
          *((_BYTE *)&v22 + v20) = 2;
LABEL_13:
          *((_WORD *)&v24 + v6) = 0;
          *((_BYTE *)&v21 + v6) = 0;
          v7 = sub_10021240(v3 + 3);
          goto LABEL_31;
        }
        if ( !strncmp(v3, "VV", 2u) )
        {
          v9 = (int)(v3 + 2);
          if ( sub_100212F0(v9, 3u) == 1 )
          {
            strncpy(v23, (const char *)v9, 3u);
            --v20;
            *(_WORD *)(a1 + 24) = j__atol(v23);
            v7 = sub_10021240((_BYTE *)(v9 + 3));
          }
          else
          {
            v10 = sub_10021990((char *)v9);
            --v20;
            v7 = sub_10021240(v10 - 1);
          }
        }
        else
        {
          v7 = sub_10021990(v3);
          --v20;
        }
      }
      else
      {
        v8 = (int)(v3 + 3);
        *((_BYTE *)&v22 + v20) = byte_100A5DE0[5 * v5];
        if ( sub_100212F0(v8, 3u) == 1 )
        {
          strncpy(v23, (const char *)v8, 3u);
          *((_WORD *)&v24 + v20) = j__atol(v23);
          v8 += 3;
        }
        else
        {
          *((_WORD *)&v24 + v20) = 0;
        }
        if ( !strncmp((const char *)v8, "CB", 2u) )
        {
          *((_BYTE *)&v21 + v20) = 1;
          v7 = sub_10021240((_BYTE *)(v8 + 2));
        }
        else if ( !strncmp((const char *)v8, "TCU", 3u) )
        {
          *((_BYTE *)&v21 + v20) = 2;
          v7 = sub_10021240((_BYTE *)(v8 + 3));
        }
        else
        {
          *((_BYTE *)&v21 + v20) = 0;
          v7 = sub_10021240((_BYTE *)v8);
        }
      }
LABEL_31:
      v3 = v7;
      v11 = v20;
      if ( v20 )
      {
        switch ( v20 )
        {
          case 1:
            v14 = BYTE1(v21);
            *(_BYTE *)(a1 + 51) = BYTE1(v22);
            v15 = HIWORD(v24);
            *(_BYTE *)(a1 + 52) = v14;
            *(_WORD *)(a1 + 49) = v15;
            break;
          case 2:
            v16 = BYTE2(v21);
            *(_BYTE *)(a1 + 55) = BYTE2(v22);
            v17 = v25;
            *(_BYTE *)(a1 + 56) = v16;
            *(_WORD *)(a1 + 53) = v17;
            break;
          case 3:
            v18 = BYTE3(v21);
            *(_BYTE *)(a1 + 59) = BYTE3(v22);
            v19 = HIWORD(v25);
            *(_BYTE *)(a1 + 60) = v18;
            *(_WORD *)(a1 + 57) = v19;
            break;
        }
      }
      else
      {
        v12 = v21;
        *(_BYTE *)(a1 + 47) = v22;
        v13 = v24;
        *(_BYTE *)(a1 + 48) = v12;
        *(_WORD *)(a1 + 45) = v13;
      }
      ++v20;
    }
    while ( (char)(v11 + 1) < (signed int)(unsigned __int8)a2 );
  }
  return 1;
}

//----- (10021CD0) --------------------------------------------------------
char __usercall sub_10021CD0@<al>(char *a1@<ecx>, int a2@<ebx>)
{
  char *v2; // edi@1
  signed __int16 v4; // ax@9
  char v5[4]; // [sp+Ch] [bp-Ch]@8
  char v6; // [sp+10h] [bp-8h]@8

  v2 = a1;
  if ( *a1 )
  {
    while ( *v2 != 81 && *v2 != 65 || sub_100212F0((int)(v2 + 1), 4u) != 1 )
    {
      v2 = sub_10021990(v2);
      if ( !*v2 )
        return 1;
    }
    if ( *v2 )
    {
      *(_DWORD *)v5 = 0;
      v6 = 0;
      strncpy(v5, v2 + 1, 4u);
      if ( *v2 == 81 )
      {
        *(_DWORD *)v5 = (signed int)(100.0 * ((double)j__atol(v5) * 100.0 * 0.0002953) + 0.5);
        v4 = *(_WORD *)v5;
      }
      else
      {
        v4 = j__atol(v5);
      }
      *(_BYTE *)(a2 + 38) = (unsigned __int16)v4 / 100;
      *(_BYTE *)(a2 + 39) = (unsigned __int16)v4 % 100;
    }
  }
  return 1;
}

//----- (10021DE0) --------------------------------------------------------
char __usercall sub_10021DE0@<al>(char *a1@<eax>, int a2)
{
  char *v2; // edi@1
  char v4; // cl@9
  __int32 v5; // eax@14
  int v6; // edi@14
  char v7; // [sp+13h] [bp-5h]@0
  char v8[2]; // [sp+14h] [bp-4h]@13
  char v9; // [sp+16h] [bp-2h]@13

  v2 = a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      if ( *v2 == 77 && sub_100212F0((int)(v2 + 1), 2u) == 1 && v2[3] == 47 )
      {
        v4 = 1;
        goto LABEL_12;
      }
      if ( sub_100212F0((int)v2, 2u) == 1 && v2[2] == 47 )
        break;
      v2 = sub_10021990(v2);
      if ( !*v2 )
        return 1;
    }
    v4 = 0;
  }
  else
  {
    v4 = v7;
  }
LABEL_12:
  if ( *v2 )
  {
    *(_WORD *)v8 = 0;
    v9 = 0;
    if ( v4 )
    {
      strncpy(v8, v2 + 1, 2u);
      v5 = -j__atol(v8);
      v6 = (int)(v2 + 4);
    }
    else
    {
      strncpy(v8, v2, 2u);
      LOWORD(v5) = j__atol(v8);
      v6 = (int)(v2 + 3);
    }
    *(_WORD *)(a2 + 41) = v5;
    *(_WORD *)v8 = 0;
    v9 = 0;
    if ( *(_BYTE *)v6 == 77 )
    {
      if ( sub_100212F0(v6 + 1, 2u) == 1 )
      {
        strncpy(v8, (const char *)(v6 + 1), 2u);
        *(_WORD *)(a2 + 43) = -(signed __int16)j__atol(v8);
        return 1;
      }
      if ( *(_BYTE *)v6 == 77 && sub_100212F0(v6 + 1, 1u) == 1 )
      {
        strncpy(v8, (const char *)(v6 + 1), 1u);
        *(_WORD *)(a2 + 43) = -(signed __int16)j__atol(v8);
        return 1;
      }
    }
    if ( sub_100212F0(v6, 2u) == 1 )
    {
      strncpy(v8, (const char *)v6, 2u);
      *(_WORD *)(a2 + 43) = j__atol(v8);
    }
  }
  return 1;
}

//----- (10021F70) --------------------------------------------------------
char __usercall sub_10021F70@<al>(int a1@<ebx>, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // esi@3
  char *v6; // eax@20
  _BYTE *v7; // edi@23
  unsigned __int16 v8; // ax@23
  char v9; // [sp+Ch] [bp-14h]@1
  char v10[4]; // [sp+14h] [bp-Ch]@22
  char v11; // [sp+18h] [bp-8h]@22

  v9 = 0;
  v3 = a2;
  if ( *a2 )
  {
    while ( 1 )
    {
      if ( sub_100212F0((int)v3, 4u) )
      {
        v4 = (int)(v3 + 4);
        if ( v3[4] == 32 || sub_100212B0(v4, 1u) == 1 && v3[5] == 32 )
          break;
        if ( sub_100212B0(v4, 2u) == 1 && v3[6] == 32 && v3[5] != 84 || sub_100212B0(v4, 3u) == 1 && v3[7] == 32 )
          break;
      }
      if ( sub_100212F0((int)v3, 2u) == 1 && v3[2] == 75 && v3[3] == 77 )
      {
        v9 = 1;
        break;
      }
      v3 = sub_10021990(v3);
      if ( !*v3 )
        goto LABEL_18;
    }
  }
  if ( *v3 )
  {
    *(_DWORD *)(a1 + 20) = a3 + v3 - a2;
    v6 = (char *)(strchr(v3, 32) - v3);
    if ( v9 )
      v6 += 2;
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)v10 = 0;
    v11 = 0;
    if ( sub_100212F0((int)v3, 4u) == 1 )
    {
      strncpy(v10, v3, 4u);
      v7 = v3 + 4;
      v8 = (signed int)((double)j__atol(v10) * 0.0006213711922373339);
    }
    else
    {
      strncpy(v10, v3, 4u);
      v7 = v3 + 2;
      v8 = (signed int)((double)j__atol(v10) * 1000.0 * 0.0006213711922373339);
    }
    for ( ; *v7 != 32; ++v7 )
      ;
    if ( v8 >= 5u )
      goto LABEL_19;
    if ( v8 >= 3u )
    {
      *(_BYTE *)(a1 + 15) = 3;
      return 1;
    }
    *(_BYTE *)(a1 + 15) = 2 - (v8 < 1u);
  }
  else
  {
LABEL_18:
    if ( strstr(a2, "CAVOK") )
    {
LABEL_19:
      *(_BYTE *)(a1 + 15) = 4;
      return 1;
    }
  }
  return 1;
}

//----- (10022190) --------------------------------------------------------
char __cdecl sub_10022190(int a1, char *a2, int a3)
{
  char *v3; // eax@1
  int v4; // esi@2
  char v5; // bl@2
  unsigned __int8 v6; // al@8
  int v8; // edi@29
  char *v9; // eax@32
  char *v10; // eax@33
  char *v11; // eax@45
  signed int v12; // ecx@45
  char v13; // [sp+Fh] [bp-15h]@1
  char v14; // [sp+10h] [bp-14h]@1
  char v15; // [sp+11h] [bp-13h]@1
  char v16; // [sp+12h] [bp-12h]@1
  char v17[2]; // [sp+14h] [bp-10h]@1
  char v18; // [sp+16h] [bp-Eh]@1
  int v19; // [sp+18h] [bp-Ch]@1
  int v20; // [sp+1Ch] [bp-8h]@1
  int v21; // [sp+20h] [bp-4h]@1

  v19 = 0;
  v21 = 0;
  v20 = 1;
  v13 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  *(_WORD *)v17 = 0;
  v18 = 0;
  v3 = strstr(a2, "SM");
  if ( v3 )
  {
    v4 = (int)(v3 - 1);
    v5 = 2;
    if ( v3 - 1 <= a2 )
    {
LABEL_26:
      *(_DWORD *)(a1 + 16) = 0;
      return 1;
    }
    while ( v5 )
    {
      v14 = 1;
      if ( sub_100212B0(v4, 1u) )
      {
        if ( *(_BYTE *)v4 == 77 && isdigit(*(_BYTE *)(v4 + 1)) )
        {
          v15 = 1;
        }
        else
        {
          for ( ; *(_BYTE *)v4 != 32; ++v4 )
            ;
        }
        goto LABEL_12;
      }
      if ( *(_BYTE *)v4 == 32 )
      {
        --v5;
      }
      else if ( *(_BYTE *)v4 == 47 )
      {
        v6 = *(_BYTE *)(v4 - 2);
        ++v5;
        v13 = 1;
        if ( v6 != 32 )
        {
          if ( isdigit(v6) )
            v16 = 1;
        }
      }
      if ( --v4 <= (unsigned int)a2 )
        goto LABEL_12;
    }
    if ( !v14 )
      goto LABEL_26;
LABEL_12:
    if ( (char *)v4 == a2 && !v13 )
    {
      if ( v5 == 1 )
        v4 = (int)sub_10021990((char *)v4);
      --v4;
    }
    if ( v5 )
    {
      if ( !v15 )
        ++v4;
    }
    else
    {
      v4 += 2;
    }
    v8 = v4;
    *(_DWORD *)(a1 + 20) = a3 + v4 - (_DWORD)a2;
    if ( v13 )
    {
      if ( v16 )
      {
        v9 = &strchr((const char *)v4, 47)[-v4 - 1];
        if ( (signed int)v9 >= 3 )
        {
          v19 = (unsigned __int16)j__atol((const char *)v4++);
        }
        else
        {
          strncpy(v17, (const char *)v4, (unsigned __int16)v9);
          v19 = (unsigned __int16)j__atol(v17);
          v10 = strchr((const char *)v4, 47) - 2;
          *v10 = 32;
          v4 = (int)v10;
        }
      }
      else if ( *(_BYTE *)(v4 + 1) == 32 )
      {
        v19 = (unsigned __int16)j__atol((const char *)v4);
        v4 += 2;
      }
      if ( strncmp((const char *)v4, "SM", 2u) )
      {
        do
        {
          if ( isdigit(*(_BYTE *)v4) )
          {
            v21 = (unsigned __int16)j__atol((const char *)v4);
          }
          else if ( *(_BYTE *)v4 == 47 )
          {
            v20 = (unsigned __int16)j__atol((const char *)++v4);
          }
          ++v4;
        }
        while ( strncmp((const char *)v4, "SM", 2u) );
        if ( !(_WORD)v20 )
        {
          v21 = 0;
          v20 = 1;
        }
      }
    }
    else
    {
      v19 = (unsigned __int16)j__atol((const char *)v4);
    }
    v11 = strstr(a2, "SM");
    v12 = (unsigned __int16)v20;
    *(_DWORD *)(a1 + 16) = &v11[2 - v8];
    v21 = (signed int)((double)(unsigned __int16)v21 / (double)v12 + (double)(unsigned __int16)v19);
    if ( (unsigned __int16)v21 >= 5u )
    {
      *(_BYTE *)(a1 + 15) = 4;
      return 1;
    }
    if ( (unsigned __int16)v21 >= 3u )
    {
      *(_BYTE *)(a1 + 15) = 3;
      return 1;
    }
    *(_BYTE *)(a1 + 15) = 2 - ((unsigned __int16)v21 < 1u);
  }
  return 1;
}

//----- (10022490) --------------------------------------------------------
char __usercall sub_10022490@<al>(char *a1@<eax>, int a2@<edi>, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  char *v4; // esi@1
  char v5; // al@3
  char v6; // al@8
  char v8; // al@13
  unsigned __int8 v9; // bl@20
  unsigned __int8 v10; // [sp+Ah] [bp-2h]@1
  char v11; // [sp+Bh] [bp-1h]@1

  v3 = 0;
  v4 = a1;
  v10 = 0;
  v11 = 0;
  if ( a3 )
  {
    while ( 1 )
    {
      if ( !*v4 )
        return 1;
      while ( 1 )
      {
        v5 = sub_10021950(v4);
        if ( v5 )
        {
          if ( !(v5 & 1) && strncmp(v4, "AUTO", 4u) )
            break;
        }
        if ( *v4 == 43 || *v4 == 45 )
        {
          v6 = sub_10021950(v4 + 1);
          if ( v6 )
          {
            if ( !(v6 & 1) )
              break;
          }
        }
        if ( v11 )
          return 1;
        v4 = sub_10021990(v4);
        if ( !*v4 )
          return 1;
      }
      v8 = *v4;
      if ( !*v4 )
        return 1;
      if ( v8 == 43 )
        break;
      if ( v8 == 45 )
      {
        *(_BYTE *)(v3 + a2 + 26) = 1;
        goto LABEL_18;
      }
LABEL_19:
      if ( sub_100212B0((int)v4, 2u) )
      {
        do
        {
          v9 = 0;
          while ( strncmp(v4, &aVc[4 * v9], 2u) )
          {
            if ( ++v9 >= 0x1Du )
              goto LABEL_23;
          }
          if ( v9 >= 0x1Du )
          {
LABEL_23:
            v4 = sub_10021990(v4);
            break;
          }
          v4 += 2;
          *(_BYTE *)(v10++ + a2 + 26) = byte_100A5DF8[4 * v9];
          v11 = 1;
        }
        while ( sub_100212B0((int)v4, 2u) );
        v3 = v10;
      }
      ++v4;
      if ( v3 >= a3 )
        return 1;
    }
    *(_BYTE *)(v3 + a2 + 26) = 2;
LABEL_18:
    ++v3;
    ++v4;
    v10 = v3;
    goto LABEL_19;
  }
  return 1;
}

//----- (100225E0) --------------------------------------------------------
char __cdecl sub_100225E0(int a1, char *a2)
{
  char *v2; // ebp@1
  unsigned int v3; // eax@1
  unsigned int v4; // esi@1
  char *v5; // eax@2
  size_t v6; // eax@4
  int v7; // ecx@6
  char *v8; // eax@6
  int v9; // ebp@15
  const char *v10; // ebp@16
  char v12[2]; // [sp+10h] [bp-138h]@16
  char v13; // [sp+12h] [bp-136h]@16
  int v14; // [sp+14h] [bp-134h]@1
  char v15[2]; // [sp+18h] [bp-130h]@1
  unsigned __int8 v16; // [sp+1Ah] [bp-12Eh]@10
  char v17; // [sp+1Bh] [bp-12Dh]@11

  sub_10021330((int)a2);
  a2[4] = 1;
  v2 = v15;
  v3 = strlen((const char *)a1);
  v4 = v3;
  v14 = v3;
  if ( v3 < 5 )
    goto LABEL_21;
  v5 = sub_10021250((const char *)a1);
  if ( v5 )
    v4 = (unsigned int)&v5[-a1 + 1];
  v6 = v4;
  if ( v4 >= 0x12C )
    v6 = 300;
  memcpy(v15, (const void *)a1, v6);
  v7 = v14;
  v15[v4] = 0;
  *(_DWORD *)(a2 + 69) = v7;
  v8 = sub_10021260(v15);
  if ( v8 )
    *(v8 - 1) = 0;
  if ( !strncmp(v15, "SA", 2u) || !strncmp(v15, "SP", 2u) && !isalnum(v16) )
    v2 = &v17;
  if ( !strncmp(v2, "METAR", 5u) || !strncmp(v2, "SPECI", 5u) )
    v2 += 6;
  *(_DWORD *)(a2 + 73) = 0;
  LOBYTE(v3) = (unsigned int)strncpy(a2, v2, 4u);
  v9 = (int)(v2 + 5);
  if ( *(_BYTE *)(v9 + 6) != 90 )
  {
LABEL_21:
    a2[4] = 0;
  }
  else
  {
    *(_WORD *)v12 = 0;
    v13 = 0;
    strncpy(v12, (const char *)v9, 2u);
    a2[5] = j__atol(v12);
    strncpy(v12, (const char *)(v9 + 2), 2u);
    a2[6] = j__atol(v12);
    strncpy(v12, (const char *)(v9 + 4), 2u);
    a2[7] = j__atol(v12);
    v10 = (const char *)(v9 + 8);
    a2[4] &= sub_10021370(v10, (int)a2);
    a2[4] &= sub_100213C0(v10, (int)a2);
    a2[4] &= sub_10021F70((int)a2, (char *)v10, v10 - v15);
    a2[4] &= sub_10022190((int)a2, (char *)v10, v10 - v15);
    a2[4] &= sub_10022490((char *)v10, (int)a2, 0xCu);
    a2[4] &= sub_100219C0((int)a2, 4);
    a2[4] &= sub_10021DE0((char *)v10, (int)a2);
    LOBYTE(v3) = sub_10021CD0((char *)v10, (int)a2);
    a2[4] &= v3;
  }
  return v3;
}
// 100225E0: using guessed type char var_130[2];

//----- (10022810) --------------------------------------------------------
char __cdecl sub_10022810(char a1, char *a2, int *a3, char *a4)
{
  char result; // al@4
  int v5; // edx@5
  char v6; // cl@5
  char *v7; // [sp+10h] [bp-11Ch]@1
  int v8; // [sp+14h] [bp-118h]@1
  int v9; // [sp+18h] [bp-114h]@1
  __int16 *v10; // [sp+1Ch] [bp-110h]@1
  int v11; // [sp+20h] [bp-10Ch]@1
  int *v12; // [sp+24h] [bp-108h]@1
  int v13; // [sp+28h] [bp-104h]@1
  int v14; // [sp+2Ch] [bp-100h]@1
  char v15; // [sp+30h] [bp-FCh]@1
  int v16; // [sp+A0h] [bp-8Ch]@5
  char v17; // [sp+A4h] [bp-88h]@5
  __int16 v18; // [sp+A8h] [bp-84h]@1
  char v19; // [sp+ACh] [bp-80h]@1

  v9 = 0;
  v10 = &v18;
  v19 = a1;
  v18 = -32737;
  v14 = 4;
  v11 = 128;
  v12 = (int *)&v7;
  v13 = 400;
  v7 = &v15;
  v8 = 120;
  if ( sub_10060AF0(21, (int)&v10) || v8 != 120 )
    sub_10028BC0("..\\lib\\adl\\udb_intf_wifi.c", 329, 0, 0);
  result = v9;
  if ( !(_BYTE)v9 )
  {
    v5 = v16;
    qmemcpy(a2, &v15, 0x70u);
    v6 = v17;
    *a3 = v5;
    *a4 = v6;
  }
  return result;
}

//----- (10022930) --------------------------------------------------------
char __cdecl sub_10022930(char a1, char a2)
{
  int v3; // [sp+0h] [bp-A4h]@1
  int v4; // [sp+4h] [bp-A0h]@1
  int v5; // [sp+8h] [bp-9Ch]@1
  __int16 *v6; // [sp+Ch] [bp-98h]@1
  int v7; // [sp+10h] [bp-94h]@1
  int *v8; // [sp+14h] [bp-90h]@1
  int v9; // [sp+18h] [bp-8Ch]@1
  int v10; // [sp+1Ch] [bp-88h]@1
  __int16 v11; // [sp+20h] [bp-84h]@1
  char v12; // [sp+24h] [bp-80h]@1
  char v13; // [sp+9Ch] [bp-8h]@1

  v5 = 0;
  v12 = a1;
  v13 = a2;
  v11 = -32717;
  v10 = 4;
  v6 = &v11;
  v7 = 128;
  v8 = &v3;
  v9 = 400;
  v3 = 0;
  v4 = 0;
  if ( sub_10060AF0(21, (int)&v6) || v4 )
    sub_10028BC0("..\\lib\\adl\\udb_intf_wifi.c", 500, 0, 0);
  return v5;
}

//----- (10022A10) --------------------------------------------------------
char __cdecl sub_10022A10(void *a1, char a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-A4h]@1
  int v6; // [sp+4h] [bp-A0h]@1
  int v7; // [sp+8h] [bp-9Ch]@1
  __int16 *v8; // [sp+Ch] [bp-98h]@1
  int v9; // [sp+10h] [bp-94h]@1
  int *v10; // [sp+14h] [bp-90h]@1
  int v11; // [sp+18h] [bp-8Ch]@1
  int v12; // [sp+1Ch] [bp-88h]@1
  __int16 v13; // [sp+20h] [bp-84h]@1
  char v14; // [sp+32h] [bp-72h]@1
  int v15; // [sp+98h] [bp-Ch]@1

  v7 = 0;
  v15 = a3;
  v13 = -32712;
  memcpy(&v14, a1, (unsigned __int8)a2);
  v8 = &v13;
  v12 = 4;
  v9 = 128;
  v10 = &v5;
  v11 = 400;
  v5 = a4;
  v6 = 1;
  if ( sub_10060AF0(21, (int)&v8) || v6 != 1 )
    sub_10028BC0("..\\lib\\adl\\udb_intf_wifi.c", 639, 0, 0);
  return v7;
}

//----- (10022B00) --------------------------------------------------------
char sub_10022B00()
{
  char v1; // [sp+3h] [bp-A5h]@1
  char *v2; // [sp+4h] [bp-A4h]@1
  int v3; // [sp+8h] [bp-A0h]@1
  int v4; // [sp+Ch] [bp-9Ch]@1
  __int16 *v5; // [sp+10h] [bp-98h]@1
  int v6; // [sp+14h] [bp-94h]@1
  int *v7; // [sp+18h] [bp-90h]@1
  int v8; // [sp+1Ch] [bp-8Ch]@1
  int v9; // [sp+20h] [bp-88h]@1
  __int16 v10; // [sp+24h] [bp-84h]@1

  v4 = 0;
  v5 = &v10;
  v10 = -32704;
  v9 = 4;
  v6 = 128;
  v7 = (int *)&v2;
  v8 = 400;
  v2 = &v1;
  v3 = 1;
  if ( sub_10060AF0(21, (int)&v5) || v3 != 1 )
    sub_10028BC0("..\\lib\\adl\\udb_intf_wifi.c", 777, 0, 0);
  return v1;
}

//----- (10022BC0) --------------------------------------------------------
int __cdecl sub_10022BC0(int *a1, unsigned int a2, int a3)
{
  unsigned int v3; // ST14_4@1
  int *v4; // esi@1
  unsigned int v5; // ST18_4@1
  int result; // eax@1

  HIWORD(v3) = (unsigned __int8)a2 + 2000;
  v4 = a1;
  LOBYTE(v3) = BYTE1(a2);
  BYTE1(v3) = a2 >> 16;
  LOWORD(v5) = a2 >> 24;
  HIWORD(v5) = a3;
  sub_1002C820(a1, v3);
  sub_1002C960((int *)&a1, v5);
  result = (int)&a1[-900 * SBYTE2(a3)];
  *v4 += result;
  return result;
}

//----- (10022C40) --------------------------------------------------------
void sub_10022C40()
{
  dword_10A09220 = -15;
}
// 10A09220: using guessed type int dword_10A09220;

//----- (10022C50) --------------------------------------------------------
signed int sub_10022C50()
{
  return sub_10061AA0((int)&off_100A6A7C);
}
// 100A6A7C: using guessed type char *off_100A6A7C;

//----- (10022C60) --------------------------------------------------------
char __cdecl sub_10022C60(unsigned __int8 a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
  char result; // al@1

  result = 0;
  if ( a2 != 0x3FFFF && a1 != -1 && a1 >= a3 && a1 <= a4 )
    result = 1;
  return result;
}

//----- (10022C90) --------------------------------------------------------
char __usercall sub_10022C90@<al>(signed int a1@<eax>, unsigned __int8 a2@<cl>, int a3@<edi>, unsigned __int8 a4, signed int *a5, _BYTE *a6)
{
  signed int v6; // esi@3
  int v7; // ebx@6
  int v8; // edi@6
  signed int v9; // esi@7
  __int64 v11; // [sp-Ch] [bp-14h]@6
  __int64 v12; // [sp-4h] [bp-Ch]@0

  *a5 = 0x3FFFF;
  *a6 = -1;
  if ( (_BYTE)a1 == -1 || a2 )
  {
    HIDWORD(v11) = a3;
    v7 = a2;
    v8 = (unsigned __int8)a1;
    if ( a2 >= (signed int)(unsigned __int8)a1 )
    {
      while ( 1 )
      {
        a1 = sub_10026F30(a4, v7);
        v9 = a1;
        if ( a1 != 0x3FFFF )
        {
          LODWORD(v11) = a1;
          LOBYTE(a1) = sub_10026DA0(v11);
          if ( !(_BYTE)a1 )
            break;
        }
        if ( --v7 < v8 )
          return a1;
      }
      LOBYTE(a1) = (_BYTE)a5;
      *a6 = v7;
      *a5 = v9;
    }
  }
  else
  {
    a1 = sub_10026F30(a4, 0);
    v6 = a1;
    if ( a1 != 0x3FFFF )
    {
      LODWORD(v12) = a1;
      LOBYTE(a1) = sub_10026DA0(v12);
      if ( !(_BYTE)a1 )
      {
        LOBYTE(a1) = (_BYTE)a6;
        *a6 = 0;
        *a5 = v6;
      }
    }
  }
  return a1;
}
// 10022C90: could not find valid save-restore pair for edi

//----- (10022D30) --------------------------------------------------------
char __usercall sub_10022D30@<al>(int a1@<ebx>, _BYTE *a2, int *a3)
{
  int v3; // ebp@1
  signed int v4; // esi@1
  int *v5; // esi@4
  _BYTE *v6; // edi@4
  signed int v7; // eax@4
  char v8; // bl@5
  unsigned __int8 v9; // dl@15
  char v10; // cl@20
  unsigned __int8 v11; // cl@26
  unsigned __int8 v13; // [sp-10h] [bp-38h]@23
  signed int *v14; // [sp-Ch] [bp-34h]@23
  __int64 v15; // [sp-8h] [bp-30h]@5
  _BYTE *v16; // [sp-8h] [bp-30h]@23
  char v17; // [sp+Ch] [bp-1Ch]@1
  char v18; // [sp+Dh] [bp-1Bh]@1
  char v19; // [sp+Eh] [bp-1Ah]@2
  char v20; // [sp+Fh] [bp-19h]@15
  int v21; // [sp+10h] [bp-18h]@1
  unsigned __int8 v22; // [sp+14h] [bp-14h]@1
  int v23; // [sp+18h] [bp-10h]@5
  unsigned __int8 v24; // [sp+1Ch] [bp-Ch]@1
  unsigned __int8 v25; // [sp+20h] [bp-8h]@1
  unsigned __int8 v26; // [sp+24h] [bp-4h]@1
  char v27; // [sp+2Ch] [bp+4h]@5
  unsigned __int8 v28; // [sp+30h] [bp+8h]@5
  char v29; // [sp+30h] [bp+8h]@15

  v18 = sub_10026EF0(0);
  v25 = sub_10027110(0);
  v26 = sub_10027190(0);
  v3 = sub_10026EB0(0);
  v24 = sub_10027150(0);
  v22 = sub_100271D0(0);
  v4 = sub_10026F90(0);
  v21 = v4;
  v17 = sub_10027210(0);
  if ( v3 != 0x3FFFF || (v19 = 0, v4 != 0x3FFFF) )
    v19 = 1;
  v5 = a3;
  v6 = a2;
  *a3 = 0x3FFFF;
  *a2 = -1;
  LOBYTE(v7) = sub_1002BA70();
  if ( (_BYTE)v7 )
  {
    HIDWORD(v15) = a1;
    sub_100422A0();
    v8 = *(_BYTE *)(dword_10A09ABC + 812);
    v27 = *(_BYTE *)(dword_10A09ABC + 816);
    v23 = *(_DWORD *)(dword_10A09ABC + 840);
    v28 = v8;
    if ( (unsigned __int8)v8 >= 0x66u && v8 != -1 )
    {
      v8 = -1;
      v28 = -1;
    }
    if ( ((unsigned __int8)v8 > (unsigned __int8)v18
       || *(_BYTE *)(dword_10A09AB0 + 4) != v18
       || *(_DWORD *)(dword_10A09AB0 + 264) != v3
       || *(_DWORD *)(dword_10A09AB0 + 604) != v21)
      && *(_BYTE *)(dword_10A09ABC + 816) != 3 )
    {
      v8 = -1;
      v28 = -1;
    }
    LOBYTE(v7) = sub_10042290();
    if ( v8 != -1 )
    {
      v29 = sub_10022C60(v28, v3, v25, v26);
      LOBYTE(v7) = sub_10022C60(v9, v21, v24, v22);
      v20 = v7;
      if ( v27 == 3 )
      {
        LODWORD(v15) = v23;
        if ( !sub_10026DA0(v15) )
        {
          LOBYTE(v7) = v23;
          *v5 = v23;
          *v6 = v8;
          return v7;
        }
        LOBYTE(v7) = v20;
LABEL_29:
        if ( v29 == 1 )
        {
          LOBYTE(v7) = v17;
          if ( (unsigned __int8)v8 > (unsigned __int8)v17 )
          {
            v11 = v26;
LABEL_37:
            v16 = v6;
            v14 = v5;
            LOBYTE(v7) = v8;
            v13 = 0;
            goto LABEL_38;
          }
          *v5 = v3;
          *v6 = v17;
          goto LABEL_39;
        }
LABEL_33:
        if ( (_BYTE)v7 == 1 )
        {
          if ( v3 == 0x3FFFF )
          {
            v11 = v22;
            goto LABEL_37;
          }
          *v5 = v3;
          *v6 = v17;
        }
LABEL_39:
        if ( v27 != 3 && *v5 == 0x3FFFF && *v6 == -1 )
        {
          if ( v3 == 0x3FFFF )
          {
            LOBYTE(v7) = v21;
            if ( v21 != 0x3FFFF )
            {
              *v5 = v21;
              LOBYTE(v7) = v22;
              *v6 = v22;
            }
          }
          else
          {
            *v5 = v3;
            *v6 = v17;
          }
        }
        return v7;
      }
      if ( v27 != 2 && v27 != 1 )
        goto LABEL_29;
      v10 = v18;
      if ( !v18 || v29 )
        goto LABEL_29;
      if ( (_BYTE)v7 )
        goto LABEL_33;
      v16 = v6;
      v14 = v5;
      LOBYTE(v7) = v8;
      v13 = 0;
      if ( v19 == 1 )
      {
        if ( v21 == 0x3FFFF )
        {
          v11 = v25 - 1;
          goto LABEL_38;
        }
        v10 = v24;
      }
      v11 = v10 - 1;
LABEL_38:
      LOBYTE(v7) = sub_10022C90(v7, v11, (int)v6, v13, v14, v16);
      goto LABEL_39;
    }
  }
  return v7;
}
// 10022D30: could not find valid save-restore pair for ebx
// 10A09AB0: using guessed type int dword_10A09AB0;
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (10022F80) --------------------------------------------------------
int __cdecl sub_10022F80(int a1, int a2, int a3, void *a4, int a5)
{
  signed int v5; // ebx@1
  int v6; // eax@2
  int result; // eax@6

  *(_DWORD *)a5 = 0;
  sub_10025F60((const char *)a1, (int)a4, (signed int *)a5);
  v5 = sub_10027490(a1);
  if ( v5 != 0x3FFFF )
  {
    memcpy_0((char *)a4 + 4, a4, 0x78u);
    *(_DWORD *)a4 = v5;
    v6 = *(_DWORD *)a5 + 1;
    if ( v6 >= 31 )
      v6 = 31;
    *(_DWORD *)a5 = v6;
  }
  if ( *(_DWORD *)a5 <= 0 )
  {
    result = a3;
    *(_DWORD *)a2 = 0x3FFFF;
    *(_BYTE *)a3 = 29;
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)a4;
    result = *(_DWORD *)a5 <= 1 ? 0 : 8;
    *(_BYTE *)a3 = result;
  }
  return result;
}

//----- (10023010) --------------------------------------------------------
char __cdecl sub_10023010(__int64 a1)
{
  char result; // al@5

  if ( (unsigned int)a1 < 0x3E8 || (_DWORD)a1 == 262141 )
  {
    result = 4;
  }
  else if ( (_DWORD)a1 == 0x3FFFF || (_DWORD)a1 == 262142 )
  {
    result = 9;
  }
  else
  {
    result = sub_10026DA0(a1);
  }
  return result;
}

//----- (10023040) --------------------------------------------------------
double __cdecl sub_10023040(float a1)
{
  unsigned int v1; // esi@1
  char v2; // al@1
  char v3; // al@2
  double result; // st7@2
  __int64 v5; // [sp-4h] [bp-20h]@0
  char v6; // [sp+4h] [bp-18h]@9
  char v7; // [sp+Ch] [bp-10h]@9

  v1 = LODWORD(a1);
  *(float *)&v5 = a1;
  v2 = sub_10023010(v5);
  if ( v1 == 262141 )
  {
    v3 = sub_10062C70();
    a1 = sub_10062650(v3);
    result = a1;
  }
  else
  {
    switch ( v2 )
    {
      case 9:
        a1 = 6.2831855;
        result = (float)6.2831855;
        break;
      case 8:
        a1 = sub_100242C0(v1);
        result = a1;
        break;
      case 3:
        a1 = sub_10027870(v1);
        result = a1;
        break;
      default:
        sub_10026170(0, v1, (double *)&v7);
        sub_10068110((int)&v7, (int)&v6);
        sub_10027850((int)&v6, &a1);
        result = a1;
        break;
    }
  }
  return result;
}

//----- (10023100) --------------------------------------------------------
int __usercall sub_10023100@<eax>(int a1@<edi>, int a2, int a3, char a4)
{
  int v4; // esi@1
  int result; // eax@6
  __int64 v6; // [sp-Ch] [bp-B0h]@2
  int v7; // [sp+Bh] [bp-99h]@1
  int v8; // [sp+10h] [bp-94h]@1
  int v9; // [sp+14h] [bp-90h]@1
  int v10[31]; // [sp+18h] [bp-8Ch]@1
  char v11; // [sp+94h] [bp-10h]@3

  sub_10022F80(a2, (int)&v9, (int)&v7, v10, (int)&v8);
  v4 = 0;
  if ( v8 <= 0 )
  {
    result = 0x3FFFF;
  }
  else
  {
    HIDWORD(v6) = a1;
    while ( 1 )
    {
      sub_10025610(v10[v4], (char *)&v7 + 1, &v11);
      if ( __PAIR__(*(_BYTE *)(a3 + 1), *(_BYTE *)a3) == *(_WORD *)((char *)&v7 + 1) )
      {
        LODWORD(v6) = v10[v4];
        if ( a4 == sub_10023010(v6) )
          break;
      }
      if ( ++v4 >= v8 )
        return 0x3FFFF;
    }
    result = v10[v4];
  }
  return result;
}
// 10023100: could not find valid save-restore pair for edi
// 10023100: using guessed type int var_8C[31];

//----- (100231E0) --------------------------------------------------------
int __cdecl sub_100231E0(int a1)
{
  unsigned __int16 v1; // ax@2
  bool v2; // cf@3
  bool v3; // zf@3
  int result; // eax@3
  __int64 v5; // [sp-4h] [bp-Ch]@0

  LODWORD(v5) = a1 & 0x3FFFF;
  if ( sub_10026DA0(v5)
    || (v1 = HIWORD(a1) >> 10, (unsigned __int16)(HIWORD(a1) >> 10) < 5u)
    || (v2 = v1 < 8u, v3 = v1 == 8, result = a1 & 0x3FFFF, !v2 && !v3) )
  {
    result = 0x3FFFF;
  }
  return result;
}

//----- (10023220) --------------------------------------------------------
char __cdecl sub_10023220(unsigned int a1, unsigned int *a2, _BYTE *a3, _BYTE *a4)
{
  char result; // al@1

  *a2 = a1 & 0x3FFFF;
  *a3 = (a1 >> 18) & 0x7F;
  result = (a1 >> 25) & 1;
  *a4 = result;
  return result;
}

//----- (10023250) --------------------------------------------------------
int __cdecl sub_10023250(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  unsigned __int16 v3; // [sp+Ch] [bp+4h]@1

  result = 0;
  v3 = *(_WORD *)(a1 + 4);
  v2 = 0;
  do
  {
    if ( v3 & (unsigned __int16)(1 << v2) )
      result += (unsigned __int16)word_10A09962;
    ++v2;
  }
  while ( v2 < 16 );
  return result;
}
// 10A09962: using guessed type __int16 word_10A09962;

//----- (10023290) --------------------------------------------------------
signed int __usercall sub_10023290@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v4; // eax@4

  if ( !a3 )
    return 1000;
  if ( a1 != 1000 )
  {
    v4 = 5 * a1;
    goto LABEL_7;
  }
  if ( a2 != 1000 )
  {
    v4 = 5 * a2 - 90;
LABEL_7:
    if ( abs(2 * v4 - a3) > 90 )
      a3 += 180;
  }
  return a3;
}

//----- (100232D0) --------------------------------------------------------
signed int __thiscall sub_100232D0(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 0x10 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_10023250(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_10A09214)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_10A09962;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10A09962;
    }
    if ( v5 & 4 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10A09962;
    }
    if ( v5 & 8 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09962: using guessed type __int16 word_10A09962;

//----- (10023380) --------------------------------------------------------
signed int __usercall sub_10023380@<eax>(int a1@<edi>)
{
  signed int result; // eax@1
  int v2; // ebx@2
  int v3; // esi@2
  __int16 v4; // ax@2
  char *v5; // ecx@2
  unsigned __int16 v6; // [sp+0h] [bp-A4h]@2

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    v2 = *(_DWORD *)a1;
    v3 = v2 + sub_10023250(a1);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_10A09214)(v2, 160, &v6);
    v4 = *(_WORD *)(a1 + 4);
    v5 = (char *)&v6;
    if ( v4 & 1 )
    {
      v3 += v6;
      v5 = (char *)&v6 + (unsigned __int16)word_10A09962;
    }
    if ( v4 & 2 )
      v3 += *(_WORD *)v5;
    result = v3;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09962: using guessed type __int16 word_10A09962;

//----- (10023410) --------------------------------------------------------
signed int __thiscall sub_10023410(int this)
{
  int v1; // edi@1
  signed int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  __int16 v5; // cx@2
  char *v6; // eax@2
  unsigned __int16 v7; // [sp+4h] [bp-A4h]@2

  v1 = this;
  result = 0xFFFFFF;
  if ( *(_BYTE *)(this + 4) & 8 )
  {
    v3 = *(_DWORD *)this;
    v4 = v3 + sub_10023250(this);
    (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_10A09214)(v3, 160, &v7);
    v5 = *(_WORD *)(v1 + 4);
    v6 = (char *)&v7;
    if ( v5 & 1 )
    {
      v4 += v7;
      v6 = (char *)&v7 + (unsigned __int16)word_10A09962;
    }
    if ( v5 & 2 )
    {
      v4 += *(_WORD *)v6;
      v6 += (unsigned __int16)word_10A09962;
    }
    if ( v5 & 4 )
      v4 += *(_WORD *)v6;
    result = v4;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09962: using guessed type __int16 word_10A09962;

//----- (100234B0) --------------------------------------------------------
char __usercall sub_100234B0@<al>(int a1@<eax>, char a2)
{
  int v2; // ecx@2
  char v3; // cl@2
  int v4; // eax@2
  unsigned int v5; // eax@3
  unsigned int v6; // ecx@3
  int v7; // eax@5

  if ( a2 == 2 )
  {
    v2 = *(_DWORD *)(a1 + 12) >> 22;
    v4 = *(_DWORD *)(a1 + 4) >> 30;
    v3 = v2 & 3;
    LOBYTE(v4) = v4 & 3;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 12);
    v6 = v5 >> 23;
    v4 = v5 >> 22;
    v3 = v6 & 1;
    LOBYTE(v4) = v4 & 1;
  }
  if ( v3 == 1 )
  {
    LOBYTE(v4) = (_BYTE)v4 == 1;
    v7 = 2 * v4 + 1;
  }
  else if ( (_BYTE)v4 == 1 )
  {
    LOBYTE(v7) = 2;
  }
  else if ( v3 == 2 || (_BYTE)v4 == 2 )
  {
    LOBYTE(v7) = 5;
  }
  else
  {
    LOBYTE(v7) = 0;
  }
  return v7;
}

//----- (10023500) --------------------------------------------------------
int __usercall sub_10023500@<eax>(int a1@<esi>)
{
  int result; // eax@1

  result = 0xFFFFFF;
  if ( *(_BYTE *)(a1 + 4) & 1 )
    result = *(_DWORD *)a1 + sub_10023250(a1);
  return result;
}

//----- (10023520) --------------------------------------------------------
char __usercall sub_10023520@<al>(unsigned int a1@<eax>, unsigned int *a2@<ebx>, _BYTE *a3@<edi>, int a4@<esi>, _DWORD *a5, int *a6)
{
  int *v6; // ebp@1

  v6 = a6;
  *a6 = 1000;
  *(_BYTE *)a1 = 95;
  *a2 = 1000;
  *a3 = 95;
  if ( *(_BYTE *)(a4 + 3) & 0x1F )
  {
    *v6 = *(_BYTE *)(a4 + 3) & 0x1F;
    *(_BYTE *)a1 = byte_100A6A98[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    *a2 = (*(_BYTE *)(a4 + 3) & 0x1F) + 18;
    a1 = ((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7;
    *a3 = byte_100A6A90[a1];
  }
  if ( *(_BYTE *)(a4 + 5) & 4 )
  {
    (*(void (__cdecl **)(_DWORD, signed int, int **))dword_10A09214)(*a5, 1, &a6);
    *a5 += (unsigned __int16)word_10A09966;
    LOBYTE(a1) = (_BYTE)a6;
    if ( (unsigned __int8)a6 & 0x1F )
    {
      a1 = ((unsigned __int8)a6 & 0x1F) + 18;
      *a2 = a1;
      *a3 = byte_100A6A90[((unsigned int)*(_BYTE *)(a4 + 3) >> 5) & 7];
    }
    else
    {
      *a2 = 1000;
      *a3 = 95;
    }
  }
  return a1;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09966: using guessed type __int16 word_10A09966;

//----- (100235E0) --------------------------------------------------------
void *__usercall sub_100235E0@<eax>(int a1@<eax>, char *a2@<esi>)
{
  int v2; // ST0C_4@2
  int v3; // eax@2
  void *result; // eax@2

  if ( *(_WORD *)(a1 + 10) & 0x8000 )
  {
    LOWORD(v2) = *(_WORD *)(a1 + 22);
    HIWORD(v2) = (*(_DWORD *)(a1 + 16) >> 25) & 0x7F;
    v3 = v2 + dword_10A092C4;
    *(_DWORD *)a2 = v2 + dword_10A092C4;
    result = (void *)(*(int (__cdecl **)(int, signed int, char *, int))dword_10A09214)(v3, 2, a2 + 4, v2);
    *(_DWORD *)a2 += (unsigned __int16)word_10A092C8;
  }
  else
  {
    result = memcpy_0(a2, &unk_100A6AA0, 6u);
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A092C4: using guessed type int dword_10A092C4;
// 10A092C8: using guessed type __int16 word_10A092C8;

//----- (10023640) --------------------------------------------------------
__int16 __usercall sub_10023640@<ax>(int a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // edi@2
  int v6; // ecx@6
  int v7; // edx@10
  char v8; // cl@10
  unsigned int v9; // eax@10
  int v10; // edx@16
  int v12; // [sp+0h] [bp-20h]@0
  __int16 v13; // [sp+Ch] [bp-14h]@2
  __int16 v14; // [sp+Eh] [bp-12h]@6
  int v15; // [sp+10h] [bp-10h]@2

  v3 = a1;
  sub_10025C50(a3 & 0x3FFFF, v12);
  *(_DWORD *)a2 >>= 7;
  *(_DWORD *)(a2 + 4) >>= 7;
  LOWORD(v4) = HIWORD(a3) >> 10;
  if ( HIWORD(a3) >> 10 != 5 )
  {
    if ( (_WORD)v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_10A09214)(v3, 9, &v13);
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned int)(unsigned __int8)v15 >> 4;
    }
    else
    {
      if ( (_WORD)v4 == 7 )
      {
        (*(void (__cdecl **)(int, signed int, __int16 *))dword_10A09214)(v3, 11, &v13);
      }
      else
      {
        if ( (_WORD)v4 != 8 )
          return v4;
        (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_10A09214)(v3, 15, &v13);
      }
      v7 = *(_DWORD *)a2 - 16 * v14;
      v8 = v15;
      v9 = (unsigned __int8)v15 >> 4;
    }
    *(_DWORD *)a2 = (v7 - (v8 & 0xF)) << 7;
    v10 = *(_DWORD *)(a2 + 4) - v9;
    v4 = 16 * v13;
    *(_DWORD *)(a2 + 4) = (v10 - v4) << 7;
    return v4;
  }
  (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_10A09214)(v3, 7, &v13);
  LOWORD(v4) = v15;
  v5 = (unsigned __int16)word_10A09964 + v3;
  if ( BYTE1(v15) & 8 )
  {
    if ( BYTE1(v15) & 4 )
      v5 += (unsigned __int16)word_10A09966;
    (*(void (__cdecl **)(int, signed int, __int16 *))dword_10A09214)(v5, 19, &v13);
    if ( (HIWORD(a3) & 0x3FCu) > 0x1FC )
    {
      v4 = (signed __int16)v15;
      *(_DWORD *)a2 -= SHIWORD(v15);
      *(_DWORD *)(a2 + 4) -= v4;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
    else
    {
      LOWORD(v4) = v14;
      v6 = v13;
      *(_DWORD *)a2 -= v14;
      *(_DWORD *)(a2 + 4) -= v6;
      *(_DWORD *)a2 <<= 7;
      *(_DWORD *)(a2 + 4) <<= 7;
    }
  }
  else
  {
    *(_DWORD *)a2 = 0x7FFFFFFF;
    *(_DWORD *)(a2 + 4) = 0x7FFFFFFF;
  }
  return v4;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09964: using guessed type __int16 word_10A09964;
// 10A09966: using guessed type __int16 word_10A09966;

//----- (100237B0) --------------------------------------------------------
char __cdecl sub_100237B0(unsigned int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebp@1
  __int64 v4; // ST00_8@1
  char result; // al@1
  int v6; // eax@2
  unsigned int v7; // edi@2
  unsigned int v8; // ecx@2
  unsigned __int8 v9; // al@2
  char v10; // dl@2
  unsigned __int8 v11; // cl@3
  char v12; // dl@3
  char v13; // cl@3
  unsigned int v14; // ebp@4
  unsigned __int8 v15; // cl@4
  unsigned int v16; // eax@5
  char v17; // [sp+14h] [bp-20h]@2
  unsigned int v18; // [sp+18h] [bp-1Ch]@2
  int v19; // [sp+1Eh] [bp-16h]@2
  unsigned int v20; // [sp+24h] [bp-10h]@2
  unsigned int v21; // [sp+28h] [bp-Ch]@2
  __int16 v22; // [sp+2Dh] [bp-7h]@8
  unsigned __int8 v23; // [sp+2Fh] [bp-5h]@3
  unsigned __int8 v24; // [sp+30h] [bp-4h]@3
  unsigned __int8 v25; // [sp+3Ch] [bp+8h]@1
  int v26; // [sp+3Ch] [bp+8h]@8

  v2 = a2;
  v3 = a2 + 32;
  memcpy_0((void *)(a2 + 32), "______", 7u);
  *(double *)a2 = 6.2831853071796;
  *(double *)(a2 + 8) = 6.2831853071796;
  *(float *)(a2 + 16) = 9.9999996e24;
  *(_BYTE *)(a2 + 62) = byte_10A0922D;
  *(_BYTE *)(a2 + 58) = 0;
  *(_BYTE *)(a2 + 63) = 0;
  *(_BYTE *)(a2 + 64) = 0;
  *(_BYTE *)(a2 + 65) = 0;
  *(_BYTE *)(a2 + 66) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 28) = 0x3FFFF;
  *(_DWORD *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 67) = 2;
  *(_BYTE *)(a2 + 59) = 0;
  *(_BYTE *)(a2 + 60) = 0;
  *(_BYTE *)(a2 + 61) = 0;
  sub_1002C120(a2 + 39, " ", 9);
  sub_1002C120(a2 + 52, " ", 6);
  sub_1002C120(a2 + 48, " ", 4);
  LODWORD(v4) = a1;
  v25 = sub_10042630();
  result = sub_10026DA0(v4);
  if ( !result )
  {
    sub_10025B10(a1, v3);
    sub_10026050(a1, v2);
    v6 = sub_10026D70(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v6, 29, &v17);
    v7 = v18;
    v8 = v21 >> 13;
    v9 = (v18 >> 26) & 7;
    v10 = (v20 >> 23) & 1;
    *(float *)(v2 + 16) = (double)((v19 & 0x7FFF) - 5000) * 0.3048000037670135;
    *(_BYTE *)(v2 + 62) = v9;
    *(_BYTE *)(v2 + 58) = v10;
    *(_BYTE *)(v2 + 63) = v8 & 7;
    if ( v25 == 2 )
    {
      v11 = v24;
      *(_BYTE *)(v2 + 65) = v24 & 7;
      *(_BYTE *)(v2 + 66) = (v23 >> 4) & 7;
      *(_BYTE *)(v2 + 67) = (*(unsigned int *)((char *)&v19 + 2) >> 29) & 3;
      *(_BYTE *)(v2 + 59) = (v11 >> 3) & 1;
      v12 = v11 >> 4;
      v13 = v11 >> 5;
    }
    else
    {
      v14 = *(int *)((char *)&v19 + 2);
      *(_BYTE *)(v2 + 65) = (*(unsigned int *)((char *)&v19 + 2) >> 30) & 3;
      *(_BYTE *)(v2 + 66) = (v7 >> 30) & 3;
      *(_BYTE *)(v2 + 67) = (v14 >> 29) & 1;
      v15 = v23;
      *(_BYTE *)(v2 + 59) = (v23 >> 2) & 1;
      v12 = v15 >> 3;
      v13 = v15 >> 4;
    }
    *(_BYTE *)(v2 + 61) = v13 & 1;
    *(_BYTE *)(v2 + 60) = v12 & 1;
    sub_1002C120(v2 + 39, (_BYTE *)(dword_10A09A90 + 25 * (v9 + 64)), 9);
    sub_1002C120(v2 + 52, (_BYTE *)(dword_10A09A90 + 25 * (*(_BYTE *)(v2 + 66) + 128)), 6);
    sub_1002C120(v2 + 48, (_BYTE *)(dword_10A09A90 + 25 * (*(_BYTE *)(v2 + 65) + 192)), 4);
    v16 = (*(unsigned int *)((char *)&v19 + 2) >> 24) & 0x1F;
    *(_DWORD *)(v2 + 20) = v16;
    if ( v16 != 31 )
      *(_DWORD *)(v2 + 20) = 12 - v16;
    *(_DWORD *)(v2 + 24) = v21 & 0x1FFF;
    result = sub_100234B0((int)&v17, v25);
    *(_BYTE *)(v2 + 64) = result;
    if ( (unsigned __int16)word_10A092A4 >= 0x1Cu )
    {
      result = v22;
      HIWORD(v26) = v23 & 3;
      LOWORD(v26) = v22;
      *(_DWORD *)(v2 + 28) = v26;
    }
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A0922D: using guessed type char byte_10A0922D;
// 10A092A4: using guessed type __int16 word_10A092A4;
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10023A30) --------------------------------------------------------
void *__cdecl sub_10023A30(unsigned int a1, char *a2)
{
  int v2; // eax@2
  __int64 v4; // [sp-4h] [bp-24h]@0
  char v5; // [sp+4h] [bp-1Ch]@2
  __int16 v6; // [sp+Eh] [bp-12h]@1

  v6 &= 0x7FFFu;
  LODWORD(v4) = a1;
  if ( !sub_10026DA0(v4) )
  {
    v2 = sub_10026D70(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v2, 28, &v5);
  }
  return sub_100235E0((int)&v5, a2);
}
// 10A09214: using guessed type int dword_10A09214;

//----- (10023A80) --------------------------------------------------------
signed int __cdecl sub_10023A80(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-10h]@3
  int v6; // [sp+Eh] [bp-6h]@3

  result = sub_100232D0(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_10A09214)(v3, 15, &v5);
        if ( !(v6 & 0x400) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_10A0996C;
        if ( v6 & 0x200 )
          v3 += (unsigned __int16)word_10A0996E;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A0996C: using guessed type __int16 word_10A0996C;
// 10A0996E: using guessed type __int16 word_10A0996E;

//----- (10023B00) --------------------------------------------------------
signed int __usercall sub_10023B00@<eax>(int a1@<edi>, unsigned __int8 a2)
{
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  char v6; // [sp+9h] [bp-7h]@3

  result = sub_10023380(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_10A09214)(v3, 9, &v5);
        if ( !(v6 & 1) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_10A09984;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09984: using guessed type __int16 word_10A09984;

//----- (10023B70) --------------------------------------------------------
signed int __cdecl sub_10023B70(unsigned __int8 a1)
{
  int v1; // ecx@0
  signed int result; // eax@1
  signed int v3; // esi@1
  unsigned __int8 v4; // bl@2
  char v5; // [sp+4h] [bp-Ch]@3
  int v6; // [sp+Ch] [bp-4h]@3

  result = sub_10023410(v1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a1 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(signed int, signed int, char *))dword_10A09214)(v3, 11, &v5);
        if ( !(v6 & 0x8000) )
          break;
        ++v4;
        v3 += (unsigned __int16)word_10A09986;
        if ( v4 >= a1 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09986: using guessed type __int16 word_10A09986;

//----- (10023BE0) --------------------------------------------------------
int __usercall sub_10023BE0@<eax>(int a1@<eax>, char a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // [sp+4h] [bp-8h]@3
  char v6; // [sp+6h] [bp-6h]@3
  char v7; // [sp+9h] [bp-3h]@4

  result = sub_10023500(a1);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = 0;
    if ( a2 > 0 )
    {
      while ( 1 )
      {
        (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v3, 7, &v5);
        if ( !(v6 & 0x80) )
          break;
        v3 += (unsigned __int16)word_10A09964;
        ++v4;
        if ( v7 & 4 )
          v3 += (unsigned __int16)word_10A09966;
        if ( v7 & 8 )
          v3 += (unsigned __int16)word_10A09968;
        if ( v7 & 0x10 )
          v3 += (unsigned __int16)word_10A0996A;
        if ( v4 >= a2 )
          return v3;
      }
      result = 0xFFFFFF;
    }
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09964: using guessed type __int16 word_10A09964;
// 10A09966: using guessed type __int16 word_10A09966;
// 10A09968: using guessed type __int16 word_10A09968;
// 10A0996A: using guessed type __int16 word_10A0996A;

//----- (10023C70) --------------------------------------------------------
void __usercall sub_10023C70(int a1@<edi>, int a2, int a3)
{
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@1

  sub_10023640(a3, (int)&v3, a2);
  *(double *)a1 = sub_10042B90(v3, 24);
  *(double *)(a1 + 8) = sub_10042B90(v4, 24);
}

//----- (10023CB0) --------------------------------------------------------
__int16 __cdecl sub_10023CB0(unsigned int a1, char a2, int a3)
{
  int v3; // ebp@1
  __int16 v4; // bx@1
  unsigned int v5; // eax@1
  double v6; // st7@1
  unsigned int v7; // esi@1
  signed int v8; // eax@3
  unsigned __int16 v9; // dx@3
  int v10; // edx@3
  int v11; // eax@3
  int v12; // edx@3
  int v13; // ecx@3
  int v14; // edi@3
  int v15; // ecx@3
  double v16; // st7@3
  unsigned __int16 v17; // cx@3
  __int16 v18; // ax@3
  __int16 v19; // dx@3
  __int16 v20; // ax@3
  unsigned int v21; // edx@6
  __int16 v22; // cx@7
  double v23; // st5@8
  char v24; // al@12
  char v25; // cl@12
  unsigned int v26; // ecx@25
  unsigned int v27; // ecx@25
  unsigned __int16 v28; // dx@25
  float v30; // [sp+Ch] [bp-3Ch]@3
  char v31; // [sp+10h] [bp-38h]@1
  int v32; // [sp+18h] [bp-30h]@3
  int v33; // [sp+1Ch] [bp-2Ch]@3
  unsigned int v34; // [sp+20h] [bp-28h]@25
  unsigned int v35; // [sp+24h] [bp-24h]@25
  unsigned __int16 v36; // [sp+28h] [bp-20h]@2
  char v37; // [sp+2Ah] [bp-1Eh]@3
  unsigned __int16 v38; // [sp+2Bh] [bp-1Dh]@3
  unsigned __int16 v39; // [sp+2Dh] [bp-1Bh]@2
  __int16 v40; // [sp+34h] [bp-14h]@3
  __int16 v41; // [sp+36h] [bp-12h]@3
  __int16 v42; // [sp+38h] [bp-10h]@3
  __int16 v43; // [sp+3Ah] [bp-Eh]@3
  unsigned __int16 v44; // [sp+3Ch] [bp-Ch]@3
  unsigned __int8 v45; // [sp+3Eh] [bp-Ah]@3
  __int16 v46; // [sp+3Fh] [bp-9h]@7
  unsigned int v47; // [sp+41h] [bp-7h]@6
  unsigned __int16 v48; // [sp+45h] [bp-3h]@24

  v3 = a3;
  v4 = 0;
  *(_BYTE *)(a3 + 2) = 0;
  sub_10023A30(a1, &v31);
  v5 = sub_10023BE0((int)&v31, a2);
  v6 = 9.9999996e24;
  v7 = v5;
  if ( v5 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(unsigned int, signed int, unsigned __int16 *))dword_10A09214)(v5, 12, &v36);
    LOWORD(v5) = word_10A09964;
    a3 = (unsigned __int16)word_10A09964 + v7;
    if ( v39 & 8 )
    {
      *(_BYTE *)(v3 + 2) = 1;
      sub_10023520(v3 + 7, (unsigned int *)(v3 + 16), (_BYTE *)(v3 + 8), (int)&v36, &a3, (int *)(v3 + 12));
      v8 = sub_10023290(*(_DWORD *)(v3 + 12), *(_DWORD *)(v3 + 16), (unsigned int)v38 >> 8);
      v9 = v39;
      *(_DWORD *)(v3 + 20) = v8;
      LOBYTE(v8) = v37 & 0xF;
      *(_WORD *)(v3 + 10) = v9 >> 5;
      v10 = a3;
      *(_BYTE *)(v3 + 9) = v8;
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_10A09214)(v10, 19, &v40);
      sub_10025C50(a1, (int)&v32);
      v11 = v32 >> 7;
      v12 = v40;
      v13 = v33 >> 7;
      *(_DWORD *)(v3 + 24) = ((v32 >> 7) - v41) << 7;
      v14 = v13 - v12;
      v32 = v11;
      *(_DWORD *)(v3 + 32) = (v11 - v43) << 7;
      v33 = v13;
      v15 = (v13 - v42) << 7;
      *(_DWORD *)(v3 + 28) = v14 << 7;
      *(_DWORD *)(v3 + 36) = v15;
      v16 = sub_10026E40(a1);
      v17 = v44;
      v30 = v16;
      a3 = (signed __int16)((signed __int16)(16 * v44) >> 4);
      v18 = 16 * v45;
      v19 = ((signed __int16)(16 * v44) >> 4) & 0xF00F;
      *(float *)(v3 + 40) = (double)a3 * 0.3048000037670135 + v30;
      v20 = (v17 >> 12) | (v19 | v18) & 0xFFF0;
      LOWORD(a3) = v20;
      if ( v20 & 0x800 )
        LOWORD(v5) = v5 | 0xF000;
      else
        LOWORD(v5) = v5 & 0xFFF;
      a3 = (signed __int16)v5;
      v21 = v47;
      *(_BYTE *)(v3 + 3) = 0;
      *(_BYTE *)(v3 + 4) = 0;
      *(_BYTE *)(v3 + 5) = 0;
      *(_BYTE *)(v3 + 6) = 0;
      *(float *)(v3 + 56) = v30 + 0.3048000037670135 * (double)(signed __int16)v5;
      v6 = 9.9999996e24;
      *(float *)(v3 + 44) = 9.9999996e24;
      *(float *)(v3 + 60) = 9.9999996e24;
      *(float *)(v3 + 52) = 9.9999996e24;
      *(float *)(v3 + 68) = 9.9999996e24;
      *(float *)(v3 + 76) = 9.9999996e24;
      *(float *)(v3 + 72) = 9.9999996e24;
      if ( (unsigned __int16)word_10A09968 >= 0xBu )
      {
        v22 = v46;
        LOWORD(v5) = v46 & 0x3FFF;
        if ( (v46 & 0x3FFF) != 0x3FFF )
        {
          a3 = (unsigned __int16)v5;
          LOWORD(v5) = (unsigned __int8)v21;
          *(float *)&a3 = (double)a3 / 10.0 - 350.0;
          v23 = *(float *)&a3;
          a3 = (unsigned __int8)v21;
          *(float *)(v3 + 44) = v23;
          *(float *)&a3 = (double)a3 / 10.0;
          if ( v22 & 0x8000 )
            *(float *)&a3 = -*(float *)&a3;
          *(float *)(v3 + 60) = v23 + *(float *)&a3;
        }
      }
      if ( (unsigned __int16)word_10A09968 < 0x13u )
      {
        *(float *)(v3 + 48) = 9.9999996e24;
        *(_BYTE *)v3 = 0;
        *(float *)(v3 + 64) = 9.9999996e24;
        *(_BYTE *)(v3 + 1) = 0;
        goto LABEL_33;
      }
      v24 = (v21 >> 18) & 1;
      v25 = (v21 >> 20) & 1;
      *(_BYTE *)v3 = v24;
      *(_BYTE *)(v3 + 1) = v25;
      if ( v24 )
      {
        a3 = (v21 >> 8) & 0x3FF;
        *(float *)(v3 + 48) = (double)(unsigned int)a3 / 100.0;
      }
      else
      {
        *(float *)(v3 + 48) = 9.9999996e24;
      }
      if ( v25 )
      {
        a3 = v21 >> 22;
        *(float *)(v3 + 64) = (double)(v21 >> 22) / 100.0;
      }
      else
      {
        *(float *)(v3 + 64) = 9.9999996e24;
      }
      if ( v24 && !(v21 & 0x80000) )
        *(float *)(v3 + 48) = *(float *)(v3 + 48) * -1.0;
      if ( v25 && !(v21 & 0x200000) )
        *(float *)(v3 + 64) = -1.0 * *(float *)(v3 + 64);
      LOWORD(v5) = v48;
      if ( v48 == -1 )
        goto LABEL_33;
      (*(void (__cdecl **)(int, signed int, unsigned int *))dword_10A09214)(
        dword_10A09684 + (unsigned __int16)word_10A09688 * v48,
        8,
        &v34);
      v5 = v34;
      v26 = v34 >> 31;
      *(_BYTE *)(v3 + 3) = (v34 >> 15) & 1;
      *(_BYTE *)(v3 + 4) = v26 & 1;
      v27 = v35;
      *(_BYTE *)(v3 + 5) = (v35 >> 15) & 1;
      *(_BYTE *)(v3 + 6) = (v27 >> 31) & 1;
      v28 = v36;
      if ( v5 & 0x4000 )
      {
        a3 = v36 - (v5 & 0x3FFF);
        *(float *)(v3 + 52) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v5 & 0x40000000 )
      {
        v5 = (v5 >> 16) & 0x3FFF;
        a3 = v28 - v5;
        *(float *)(v3 + 68) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v27 & 0x4000 )
      {
        v5 = v27 & 0x3FFF;
        a3 = v28 - v5;
        *(float *)(v3 + 76) = (double)(unsigned int)a3 * 0.3048;
      }
      if ( v27 & 0x40000000 )
      {
        a3 = v28 - ((v27 >> 16) & 0x3FFF);
        *(float *)(v3 + 72) = 0.3048 * (double)(unsigned int)a3;
        v6 = 9.9999996e24;
LABEL_33:
        v4 = 0;
        goto LABEL_34;
      }
      v4 = 0;
    }
    v6 = 9.9999996e24;
  }
LABEL_34:
  if ( *(_BYTE *)(v3 + 2) == (_BYTE)v4 )
  {
    *(_BYTE *)v3 = v4;
    *(_BYTE *)(v3 + 1) = v4;
    *(_DWORD *)(v3 + 12) = 1000;
    *(_DWORD *)(v3 + 16) = 1000;
    *(_DWORD *)(v3 + 20) = 1000;
    *(_WORD *)(v3 + 10) = v4;
    *(_BYTE *)(v3 + 7) = 95;
    *(_BYTE *)(v3 + 8) = 95;
    LOBYTE(v5) = byte_10A09A8C;
    *(float *)(v3 + 40) = v6;
    *(float *)(v3 + 44) = v6;
    *(_BYTE *)(v3 + 9) = v5;
    *(float *)(v3 + 56) = v6;
    LOWORD(v5) = -1;
    *(float *)(v3 + 60) = v6;
    *(float *)(v3 + 48) = v6;
    *(_BYTE *)(v3 + 3) = v4;
    *(float *)(v3 + 64) = v6;
    *(_BYTE *)(v3 + 4) = v4;
    *(float *)(v3 + 52) = v6;
    *(_BYTE *)(v3 + 5) = v4;
    *(float *)(v3 + 68) = v6;
    *(_BYTE *)(v3 + 6) = v4;
    *(float *)(v3 + 76) = v6;
    *(_DWORD *)(v3 + 24) = 0x7FFFFFFF;
    *(float *)(v3 + 72) = v6;
    *(_DWORD *)(v3 + 28) = 0x7FFFFFFF;
    *(_DWORD *)(v3 + 32) = 0x7FFFFFFF;
    *(_DWORD *)(v3 + 36) = 0x7FFFFFFF;
  }
  return v5;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09684: using guessed type int dword_10A09684;
// 10A09688: using guessed type __int16 word_10A09688;
// 10A09964: using guessed type __int16 word_10A09964;
// 10A09968: using guessed type __int16 word_10A09968;
// 10A09A8C: using guessed type char byte_10A09A8C;

//----- (10024190) --------------------------------------------------------
int __cdecl sub_10024190(__int64 a1)
{
  int result; // eax@2
  char v2; // [sp+0h] [bp-8h]@1

  sub_10023A30(a1 & 0x3FFFF, &v2);
  switch ( (unsigned int)WORD1(a1) >> 10 )
  {
    case 5u:
      result = sub_10023BE0((int)&v2, (*(_DWORD *)((char *)&a1 + 2) >> 2) & 0x7F);
      break;
    case 6u:
      result = sub_10023B00((int)&v2, *(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 7u:
      result = sub_10023B70(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    case 8u:
      result = sub_10023A80(*(_DWORD *)((char *)&a1 + 2) >> 2);
      break;
    default:
      result = 0xFFFFFF;
      break;
  }
  return result;
}

//----- (10024240) --------------------------------------------------------
double __cdecl sub_10024240(unsigned int a1)
{
  __int64 v2; // [sp-4h] [bp-64h]@0
  char v3; // [sp+7h] [bp-59h]@2
  float v4; // [sp+8h] [bp-58h]@1
  unsigned int v5; // [sp+Ch] [bp-54h]@2
  char v6; // [sp+10h] [bp-50h]@2
  float v7; // [sp+38h] [bp-28h]@4
  float v8; // [sp+48h] [bp-18h]@3

  v4 = 9.9999996e24;
  LODWORD(v2) = a1;
  if ( sub_10026DA0(v2) == 5 )
  {
    sub_10023220(a1, &v5, &v4, &v3);
    sub_10023CB0(v5, SLOBYTE(v4), (int)&v6);
    if ( v3 )
    {
      v4 = v8;
      return v8;
    }
    v4 = v7;
  }
  return v4;
}

//----- (100242C0) --------------------------------------------------------
double __cdecl sub_100242C0(int a1)
{
  __int64 v1; // ST08_8@1
  int v2; // eax@1
  float v4; // [sp+0h] [bp-14h]@1
  char v5; // [sp+4h] [bp-10h]@2
  __int16 v6; // [sp+Eh] [bp-6h]@2

  LODWORD(v1) = a1;
  *((float *)&v1 + 1) = 6.2831855;
  v2 = sub_10024190(v1);
  if ( v2 != 0xFFFFFF )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v2, 15, &v5);
    v4 = (double)(signed __int16)((signed __int16)(v6 << 7) >> 7) * 0.01745329238474369 * 0.5;
  }
  return v4;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (10024330) --------------------------------------------------------
int __cdecl sub_10024330(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  __int16 v4; // ax@2
  signed int v5; // eax@4
  char v6; // bl@4
  __int64 v7; // [sp-4h] [bp-58h]@0
  char v8; // [sp+Eh] [bp-46h]@3
  char v9; // [sp+Fh] [bp-45h]@3
  int v10; // [sp+10h] [bp-44h]@3
  int v11; // [sp+14h] [bp-40h]@3
  int v12; // [sp+18h] [bp-3Ch]@3
  char v13; // [sp+1Ch] [bp-38h]@3
  char v14; // [sp+23h] [bp-31h]@12
  char v15; // [sp+24h] [bp-30h]@10

  *(_DWORD *)a2 = 1600085855;
  *(_WORD *)(a2 + 4) = 24415;
  LODWORD(v7) = a1;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_10024190(v7);
  v3 = result;
  if ( result != 0xFFFFFF )
  {
    v4 = HIWORD(a1) >> 10;
    if ( HIWORD(a1) >> 10 == 5 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v3, 12, &v13);
      v10 = (unsigned __int16)word_10A09964 + v3;
      sub_10023520((unsigned int)&v9, (unsigned int *)&v12, &v8, (int)&v13, &v10, &v11);
      if ( (HIWORD(a1) & 0x3FCu) <= 0x1FC )
      {
        v6 = v9;
        v5 = v11;
      }
      else
      {
        v5 = v12;
        v6 = v8;
      }
      *(_BYTE *)a2 = 82;
      *(_BYTE *)(a2 + 1) = 87;
      if ( sub_1002C060(v5, 2, (_BYTE *)(a2 + 2)) )
      {
        *(_BYTE *)(a2 + 4) = v6;
        *(_BYTE *)(a2 + 6) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 2) = 1600085855;
        *(_BYTE *)(a2 + 6) = 0;
      }
    }
    else if ( v4 == 6 )
    {
      (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v3, 9, &v13);
      sub_10042BD0(&v15, 5, a2);
      *(_BYTE *)(a2 + 5) = 0;
    }
    else if ( v4 == 7 )
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_10A09214)(v3, 11, &v13);
      sub_10042BD0(&v14, 3, a2);
      *(_BYTE *)(a2 + 3) = 0;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, signed int, _DWORD))dword_10A09214)(v3, 15, &v13);
      sub_10042BD0(&v14, 4, a2);
      *(_BYTE *)(a2 + 4) = 0;
    }
    result = sub_1002C320(a2, 0);
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09964: using guessed type __int16 word_10A09964;

//----- (100244C0) --------------------------------------------------------
char __cdecl sub_100244C0(int a1, int a2)
{
  char v2; // bl@1
  int v3; // ebp@1
  int v4; // eax@2
  __int64 v6; // [sp-4h] [bp-30h]@0
  char v7; // [sp+10h] [bp-1Ch]@2
  unsigned int v8; // [sp+14h] [bp-18h]@2

  *(double *)a2 = 6.2831853071796;
  LODWORD(v6) = a1;
  *(double *)(a2 + 8) = 6.2831853071796;
  v2 = 0;
  v3 = sub_10024190(v6);
  if ( v3 != 0xFFFFFF )
  {
    v4 = sub_10026D70(a1 & 0x3FFFF);
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v4, 28, &v7);
    v2 = (v8 >> 29) & 1;
    sub_10023C70(a2, a1, v3);
  }
  return v2;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (10024530) --------------------------------------------------------
__int16 __cdecl sub_10024530(int a1, int a2)
{
  int v2; // eax@1
  __int64 v4; // [sp-4h] [bp-Ch]@0

  LODWORD(v4) = a1;
  *(_DWORD *)a2 = 2147483648;
  *(_DWORD *)(a2 + 4) = 2147483648;
  v2 = sub_10024190(v4);
  if ( v2 != 0xFFFFFF )
    LOWORD(v2) = sub_10023640(v2, a2, a1);
  return v2;
}

//----- (10024570) --------------------------------------------------------
signed int __cdecl sub_10024570(unsigned __int8 a1)
{
  signed int v1; // esi@2
  int v2; // eax@3
  signed int result; // eax@5

  if ( (unsigned __int8)sub_10030C50() )
  {
    v1 = 0x3FFFF;
    sub_10060A60(100, 60000);
    if ( a1 != 9 )
    {
      v2 = dword_10A09AA0 + (a1 << 7);
      if ( *(_WORD *)(v2 + 248) )
        v1 = *(_DWORD *)(v2 + 252);
    }
    sub_10060A00(100);
    result = v1;
  }
  else
  {
    result = 0x3FFFF;
  }
  return result;
}
// 10A09AA0: using guessed type int dword_10A09AA0;

//----- (100245D0) --------------------------------------------------------
int __cdecl sub_100245D0(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  *(float *)a2 = 6.2831855;
  *(float *)(a2 + 4) = 6.2831855;
  switch ( *(_BYTE *)a1 )
  {
    case 1:
    case 4:
    case 0x12:
    case 0x14:
    case 0x15:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 48);
      break;
    case 2:
    case 5:
    case 0x13:
    case 0x16:
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 56);
      break;
    default:
      return result;
  }
  return result;
}

//----- (10024640) --------------------------------------------------------
char __cdecl sub_10024640(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  int v3; // esi@1
  unsigned __int8 v4; // bl@2
  int v5; // edi@3
  signed int v6; // eax@3
  char result; // al@6
  char *v8; // edi@7
  unsigned int v9; // ecx@7

  sub_10060A60(54, 60000);
  v2 = sub_10026C80(a1);
  v3 = v2;
  if ( v2 )
  {
    v4 = 0;
    *a2 = *(_BYTE *)(v2 + 1);
    if ( *(_BYTE *)(v2 + 1) )
    {
      do
      {
        v5 = v4;
        v6 = sub_10042A30(84 * v4++ + v3 + 148);
        *(_DWORD *)&a2[4 * v5 + 4] = v6;
      }
      while ( v4 < *(_BYTE *)(v3 + 1) );
    }
  }
  else
  {
    *a2 = 0;
  }
  sub_10060A00(54);
  result = *a2;
  if ( (unsigned __int8)*a2 < 0x64u )
  {
    v8 = &a2[4 * (unsigned __int8)result + 4];
    v9 = (unsigned __int8)(100 - result);
    result = -1;
    memset32(v8, 0x3FFFF, v9);
  }
  return result;
}

//----- (100246D0) --------------------------------------------------------
signed int __cdecl sub_100246D0(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1
  char v3; // cl@2

  v1 = 0x3FFFF;
  sub_10060A60(54, 60000);
  v2 = sub_10026C80(a1);
  if ( v2 )
  {
    v3 = *(_BYTE *)(v2 + 1);
    if ( v3 )
    {
      if ( *(_BYTE *)(v2 + 90) == -1 || (v1 = *(_DWORD *)(v2 + 104), v1 == 0x3FFFF) )
      {
        if ( *(_BYTE *)(v2 + 60) == 3 || *(_BYTE *)(v2 + 61) == 3 || (v1 = *(_DWORD *)(v2 + 64), v1 == 0x3FFFF) )
          v1 = sub_10042A30(84 * (unsigned __int8)(v3 - 1) + v2 + 148);
      }
    }
  }
  sub_10060A00(54);
  return v1;
}

//----- (10024750) --------------------------------------------------------
int __cdecl sub_10024750(int a1, char a2, void *a3)
{
  int v3; // eax@1
  int result; // eax@3

  sub_10060A60(54, 60000);
  v3 = sub_10026C80(a1);
  if ( v3 && (unsigned __int8)a2 < *(_BYTE *)(v3 + 1) )
  {
    qmemcpy(a3, (const void *)(84 * (unsigned __int8)a2 + v3 + 148), 0x3Cu);
    result = sub_10060A00(54);
  }
  else
  {
    memset(a3, 0, 0x3Cu);
    *(_BYTE *)a3 = 24;
    *((_BYTE *)a3 + 1) = 0;
    *((_BYTE *)a3 + 4) = 0;
    *((_BYTE *)a3 + 6) = 0;
    *((_BYTE *)a3 + 7) = 4;
    result = sub_10060A00(54);
  }
  return result;
}

//----- (100247D0) --------------------------------------------------------
signed int __cdecl sub_100247D0(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  v1 = 0x3FFFF;
  sub_10060A60(54, 60000);
  v2 = sub_10026C80(a1);
  if ( v2 )
  {
    if ( *(_BYTE *)(v2 + 1) > 1u )
    {
      if ( *(_BYTE *)(v2 + 20) == 3 || *(_BYTE *)(v2 + 21) == 3 || (v1 = *(_DWORD *)(v2 + 24), v1 == 0x3FFFF) )
        v1 = sub_10042A30(v2 + 148);
    }
  }
  sub_10060A00(54);
  return v1;
}

//----- (10024830) --------------------------------------------------------
char __cdecl sub_10024830(unsigned __int8 a1, unsigned __int8 a2)
{
  char v2; // bl@1
  int v3; // eax@1
  int v4; // ecx@3
  char v5; // al@3
  char v6; // al@7

  v2 = 1;
  sub_10060A60(54, 60000);
  v3 = sub_10026C80(a1);
  if ( !v3 || a2 >= *(_BYTE *)(v3 + 1) )
    goto LABEL_21;
  v4 = v3 + 84 * a2;
  v5 = *(_BYTE *)(v4 + 148);
  if ( v5 == 14 || v5 == 17 )
  {
    if ( a2 && !(*(_BYTE *)(v4 + 65) & 8) )
      goto LABEL_22;
    goto LABEL_21;
  }
  if ( v5 != 6 )
    goto LABEL_22;
  if ( !a2
    || (v6 = *(_BYTE *)(v4 + 64), v6 == 1)
    || v6 == 2
    || v6 == 4
    || v6 == 5
    || v6 == 7
    || v6 == 10
    || v6 == 18
    || v6 == 19
    || v6 == 20
    || v6 == 21 )
  {
LABEL_21:
    v2 = 0;
    goto LABEL_22;
  }
  if ( v6 == 22 )
  {
    sub_10060A00(54);
    return 0;
  }
LABEL_22:
  sub_10060A00(54);
  return v2;
}

//----- (100248D0) --------------------------------------------------------
char __cdecl sub_100248D0(int a1)
{
  unsigned __int8 v1; // dl@1
  char result; // al@1
  char v3; // cl@1

  v1 = *(_BYTE *)(a1 + 1);
  result = -1;
  v3 = 0;
  if ( v1 )
  {
    while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 2) )
    {
      if ( (unsigned __int8)++v3 >= v1 )
        return result;
    }
    result = v3;
  }
  return result;
}

//----- (10024900) --------------------------------------------------------
int __cdecl sub_10024900(int a1, int a2, _BYTE *a3, _BYTE *a4, int a5, int a6, float *a7)
{
  char v7; // cl@2
  int v8; // edx@3
  int v9; // edx@3
  char v11; // [sp+13h] [bp-21h]@3
  int v12; // [sp+14h] [bp-20h]@3
  int v13; // [sp+18h] [bp-1Ch]@1
  int v14; // [sp+1Ch] [bp-18h]@3
  float *v15; // [sp+20h] [bp-14h]@1
  char v16; // [sp+24h] [bp-10h]@3
  int v17; // [sp+28h] [bp-Ch]@3
  int v18; // [sp+2Ch] [bp-8h]@3

  v13 = a5;
  v15 = a7;
  if ( a1 && (v7 = *(_BYTE *)(a1 + 90), v7 != -1) )
  {
    *a3 = v7;
    v14 = *(_DWORD *)(a1 + 96);
    sub_100424C0(v14, (_BYTE *)&v14 + 3, 5, a2);
    v12 = *(_DWORD *)(a1 + 100);
    sub_100424C0((int)&v12 + 3, (_BYTE *)&v12 + 3, 5, a6);
    v8 = *(_DWORD *)(a1 + 120);
    v17 = *(_DWORD *)(a1 + 116);
    v18 = v8;
    sub_10026430((int)&v17, v13, (int)&v16, &v11);
    *a4 = *(_BYTE *)(a1 + 89);
    v9 = 84 * (unsigned __int8)sub_100270D0(a1);
    *v15 = *(float *)(v9 + a1 + 172);
  }
  else
  {
    *(_DWORD *)a2 = 538976288;
    *(_BYTE *)(a2 + 4) = 32;
    *a3 = -1;
  }
  *(_BYTE *)(a6 + 5) = 0;
  sub_1002C320(a6, 5);
  *(_BYTE *)(a2 + 5) = 0;
  return sub_1002C320(a2, 5);
}

//----- (10024A00) --------------------------------------------------------
int __usercall sub_10024A00@<eax>(float *a1@<esi>, float a2, float a3, float a4, float a5, int a6)
{
  double v6; // st7@1
  double v7; // st7@6
  int result; // eax@6
  float v9; // [sp+Ch] [bp+8h]@1

  v6 = a2;
  v9 = a3 - a2;
  if ( LOBYTE(a5) == 1 )
  {
    *a1 = v6 - 1.570796370506287;
    if ( v9 > 0.0 )
      v9 = v9 - 6.283185482025146;
  }
  else
  {
    *a1 = v6 + 1.570796370506287;
    if ( v9 < 0.0 )
      v9 = v9 + 6.283185482025146;
  }
  v7 = sub_100680D0(*a1);
  result = a6;
  *a1 = v7;
  *(float *)a6 = COERCE_FLOAT(LODWORD(v9) & 0x7FFFFFFF) * a4;
  return result;
}

//----- (10024AA0) --------------------------------------------------------
double __usercall sub_10024AA0@<st0>(int a1@<eax>, int a2@<ecx>, int a3@<esi>, unsigned int a4)
{
  unsigned int v4; // esi@1
  double v5; // st7@5
  float v6; // ST0C_4@12
  double result; // st7@13
  __int64 v8; // [sp-8h] [bp-10h]@1
  float v9; // [sp+0h] [bp-8h]@1
  float v10; // [sp+0h] [bp-8h]@7
  float v11; // [sp+0h] [bp-8h]@10
  float v12; // [sp+4h] [bp-4h]@1
  float v13; // [sp+4h] [bp-4h]@12

  v12 = *(float *)(a2 + 12);
  HIDWORD(v8) = a3;
  v4 = 0x3FFFF;
  v9 = -1.0;
  if ( !a1 )
    goto LABEL_17;
  if ( *(_BYTE *)(a1 + 7) != 4 )
    v9 = *(float *)(a1 + 12);
  v4 = *(_DWORD *)(a1 + 36);
  if ( v9 > 0.0 )
  {
    v5 = v12 - v9;
  }
  else
  {
LABEL_17:
    LODWORD(v8) = v4;
    if ( sub_10023010(v8) != 5 || (v10 = sub_10024240(v4), 9.9999996e24 == v10) )
      v10 = sub_10026E40(a4);
    v5 = v12 - v10;
  }
  v11 = v5;
  if ( v11 <= 30.47999954223633 )
    v11 = 30.48;
  v6 = v11 * 3.280839920043945 / 500.0 * 1852.0;
  v13 = v6 + 1.0;
  if ( v13 >= 9260.0 )
    result = (float)9260.0;
  else
    result = v13;
  return result;
}
// 10024AA0: could not find valid save-restore pair for esi

//----- (10024BA0) --------------------------------------------------------
char __cdecl sub_10024BA0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10060A60(54, 60000);
  v1 = -1;
  v2 = sub_10026C80(a1);
  if ( v2 )
    v1 = sub_100248D0(v2);
  sub_10060A00(54);
  return v1;
}

//----- (10024BE0) --------------------------------------------------------
int __cdecl sub_10024BE0(unsigned __int8 a1, int a2, _BYTE *a3, _BYTE *a4, int a5, int a6, float *a7)
{
  int v7; // eax@1

  sub_10060A60(54, 60000);
  v7 = sub_10026C80(a1);
  sub_10024900(v7, a2, a3, a4, a5, a6, a7);
  return sub_10060A00(54);
}

//----- (10024C30) --------------------------------------------------------
void __cdecl sub_10024C30(int a1, unsigned __int8 a2, float *a3, float *a4)
{
  signed int v4; // eax@7
  char v5; // al@13
  char v6; // al@13
  double v7; // st6@15
  double v8; // st7@15
  bool v9; // zf@17
  double v10; // st7@17
  double v11; // st7@18
  signed int v12; // eax@23
  signed int v13; // eax@26
  char v14; // di@26
  float v15; // [sp+24h] [bp-DCh]@9
  char v16; // [sp+2Ah] [bp-D6h]@20
  char v17; // [sp+2Bh] [bp-D5h]@20
  int v18; // [sp+2Ch] [bp-D4h]@13
  char v19; // [sp+3Ch] [bp-C4h]@1
  char v20; // [sp+3Dh] [bp-C3h]@3
  char v21; // [sp+42h] [bp-BEh]@20
  float v22; // [sp+64h] [bp-9Ch]@13
  float v23; // [sp+68h] [bp-98h]@3
  float v24; // [sp+6Ch] [bp-94h]@3
  float v25; // [sp+70h] [bp-90h]@3
  int v26; // [sp+78h] [bp-88h]@13
  int v27; // [sp+88h] [bp-78h]@27
  char v28; // [sp+98h] [bp-68h]@11
  float v29; // [sp+C0h] [bp-40h]@28
  float v30; // [sp+C4h] [bp-3Ch]@28
  float v31; // [sp+C8h] [bp-38h]@30
  int v32; // [sp+D4h] [bp-2Ch]@30
  char v33; // [sp+E4h] [bp-1Ch]@20
  char v34; // [sp+ECh] [bp-14h]@20
  char v35; // [sp+F4h] [bp-Ch]@20

  *a3 = 9.9999996e24;
  *a4 = 9.9999996e24;
  sub_10024750(a1, a2, &v19);
  if ( v19 != 24 )
  {
    switch ( v19 )
    {
      case 0:
      case 0x10:
        sub_10024A00(a4, v24, v25, v23, COERCE_FLOAT(v20 & 7), (int)a3);
        return;
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
        goto LABEL_4;
      case 7:
        if ( a2 < (unsigned __int8)sub_10024BA0(a1) || a2 >= (unsigned __int8)sub_10027150(a1) )
          v4 = sub_100246D0(a1);
        else
          v4 = sub_100247D0(a1);
        v15 = *(float *)&v4;
        if ( v4 == 0x3FFFF || !a2 )
          return;
        sub_10024750(a1, a2 - 1, &v28);
        *a3 = sub_10024AA0((int)&v28, (int)&v19, (int)a4, LODWORD(v15));
        goto LABEL_35;
      case 8:
        goto LABEL_12;
      case 9:
        v5 = sub_10042A30((int)&v19);
        sub_10026170(0, v5, (double *)&v18);
        v6 = sub_10027C50((int)&v19);
        sub_10026170(0, v6, (double *)&v26);
        if ( sub_10060340((int)&v26, v24, (int)&v18, v22, (int)&v26) )
          sub_10060410((int)&v18, (int)&v26, 1, a3, (int)a4);
        else
LABEL_4:
          *a3 = 0.0;
        goto LABEL_35;
      case 0xF:
        v15 = v23 - 3704.0;
        v7 = v15;
        *a3 = v15;
        v15 = v7;
        v8 = v15;
        if ( v15 <= 3704.0 )
          v8 = 3704.0;
        v15 = v8;
        v9 = (v20 & 7) == 1;
        *a3 = v15;
        v10 = v22;
        *a4 = v22;
        if ( v9 )
          v11 = v10 - 0.7853981852531433;
        else
          v11 = v10 + 0.7853981852531433;
        goto LABEL_36;
      case 3:
        sub_10024BE0(a1, (int)&v34, &v17, &v16, (int)&v35, (int)&v33, &v15);
        if ( v21 == 2 && a2 != sub_10027110(a1) && v16 == -1 )
          goto LABEL_23;
LABEL_12:
        *a3 = v23;
        goto LABEL_35;
      default:
LABEL_23:
        v12 = sub_10042A30((int)&v19);
        if ( v12 == 0x3FFFF )
          return;
        if ( !a2 || v12 == 262142 )
          goto LABEL_32;
        sub_10026170(0, v12, (double *)&v26);
        sub_10024750(a1, a2 - 1, &v28);
        v13 = sub_10042A30((int)&v28);
        v14 = v13;
        if ( v13 == 0x3FFFF )
          return;
        sub_10026170(0, v13, (double *)&v27);
        if ( v28 == 8 )
        {
          sub_10060540((int)&v27, v30, v29, 1, (int)&v18);
        }
        else if ( v28 == 9 )
        {
          sub_10026170(0, SLOBYTE(v30), (double *)&v32);
          if ( !sub_10060340((int)&v32, v31, (int)&v27, v29, (int)&v18) )
            goto LABEL_32;
        }
        else
        {
          sub_10026170(0, v14, (double *)&v18);
        }
        sub_10060410((int)&v18, (int)&v26, 1, a3, (int)a4);
LABEL_32:
        if ( v19 != 14 && v19 != 17 && v19 != 6 )
        {
LABEL_35:
          v11 = v22;
LABEL_36:
          *a4 = v11;
        }
        break;
    }
  }
}

//----- (10025030) --------------------------------------------------------
char __cdecl sub_10025030(float *a1)
{
  char v1; // bl@1
  char v3; // [sp+8h] [bp-38h]@2
  int v4; // [sp+34h] [bp-Ch]@2

  *a1 = 0.0;
  v1 = 0;
  if ( sub_10042C70(0, 0x4Cu) )
  {
    v1 = 1;
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(dword_10A095D0, 52, &v3);
    *(_DWORD *)a1 = v4;
  }
  return v1;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A095D0: using guessed type int dword_10A095D0;

//----- (10025090) --------------------------------------------------------
void __cdecl sub_10025090(unsigned __int8 a1, int *a2, float *a3, float *a4)
{
  char v4; // bl@2
  signed int v5; // ecx@5
  signed int v6; // eax@5
  bool v7; // zf@5
  bool v8; // sf@5
  int *v9; // edx@6
  int v10; // esi@8
  int v11; // ebx@9
  float *v12; // esi@10
  _DWORD *v13; // edi@10
  int v14; // eax@11
  int v15; // ecx@14
  int v16; // esi@15
  float *v17; // eax@16
  int *v18; // edx@16
  int v19; // ecx@16
  float *v20; // eax@19
  _DWORD *v21; // ebp@19
  signed int v22; // edx@19
  char v23; // [sp+8h] [bp-A0h]@11
  char v24; // [sp+18h] [bp-90h]@9
  __int16 v25; // [sp+28h] [bp-80h]@5
  int v26[31]; // [sp+2Ch] [bp-7Ch]@5

  if ( a2 )
  {
    v4 = sub_1002BC10();
    if ( (unsigned __int8)sub_10030C50() && v4 != 1 && v4 )
    {
      sub_10060A60(100, 60000);
      qmemcpy(&v25, (const void *)((a1 << 7) + dword_10A09AA0 + 248), 0x80u);
      sub_10060A00(100);
      sub_10028040(v25, (char *)v26);
      v5 = v25;
      v6 = 0;
      v7 = v25 == 0;
      v8 = v25 < 0;
      *a2 = 0;
      if ( !v8 && !v7 )
      {
        v9 = a2 + 1;
        do
        {
          if ( v6 >= 25 )
            break;
          v10 = v26[v6];
          ++*a2;
          *v9 = v10;
          ++v6;
          ++v9;
        }
        while ( v6 < v5 );
      }
      sub_10068240(dword_10A09AA0 + 1144, (int)&v24);
      v11 = 0;
      if ( *a2 > 0 )
      {
        v12 = a3;
        v13 = a2 + 1;
        do
        {
          sub_10026170(0, *v13, (double *)&v23);
          LOBYTE(v14) = sub_10062C70();
          sub_10060410((int)&v24, (int)&v23, v14, v12, (int)v12 + (char *)a4 - (char *)a3);
          ++v11;
          ++v13;
          ++v12;
        }
        while ( v11 < *a2 );
        if ( *a2 > 0 )
        {
          do
          {
            if ( a3[*a2 - 1] <= 370380.97 )
              break;
            v15 = *a2 - 1;
            *a2 = v15;
          }
          while ( v15 > 0 );
        }
      }
      v16 = *a2;
      if ( *a2 < 25 )
      {
        v17 = &a4[v16];
        v18 = &a2[v16 + 1];
        v19 = 25 - v16;
        do
        {
          *v18 = 0x3FFFF;
          *(float *)((char *)v17 + (char *)a3 - (char *)a4) = 9.9999996e24;
          *v17 = 9.9999996e24;
          ++v18;
          ++v17;
          --v19;
        }
        while ( v19 );
      }
    }
    else
    {
      v20 = a4;
      *a2 = 0;
      v21 = a2 + 1;
      v22 = 25;
      do
      {
        *v21 = 0x3FFFF;
        *(float *)((char *)v20 + (char *)a3 - (char *)a4) = 9.9999996e24;
        *v20 = 9.9999996e24;
        ++v21;
        ++v20;
        --v22;
      }
      while ( v22 );
    }
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\prx\\prx_intf.c", 515, 0, 0);
  }
}
// 10A09AA0: using guessed type int dword_10A09AA0;
// 10025090: using guessed type int var_7C[31];

//----- (100252B0) --------------------------------------------------------
char __cdecl sub_100252B0(char a1, char *a2)
{
  char v3; // al@5
  char v4; // [sp+4h] [bp-A0h]@1

  memset(&v4, 0, 0x9Cu);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      sub_10028BC0("..\\lib\\acl\\iop\\iop_gps_intf.c", 268, 0, 0);
      return 0;
    }
    v3 = sub_10015AC0(1, 236, &v4);
  }
  else
  {
    v3 = sub_10015AC0(1, 219, &v4);
  }
  if ( !v3 || sub_1001C520((int)&v4) )
    return 0;
  qmemcpy(a2, &v4, 0x9Cu);
  return 1;
}

//----- (10025380) --------------------------------------------------------
void __cdecl sub_10025380(int a1)
{
  unsigned __int8 v1; // bl@1
  int v2; // edi@1
  float v3; // edx@2
  int v4; // eax@7
  char v5; // al@10
  char v6; // al@12
  double v7; // st7@20
  char v8; // [sp+Dh] [bp-9Bh]@1
  char v9; // [sp+Eh] [bp-9Ah]@1
  unsigned __int8 v10; // [sp+Fh] [bp-99h]@1
  float v11; // [sp+10h] [bp-98h]@1
  float v12; // [sp+14h] [bp-94h]@1
  int v13; // [sp+18h] [bp-90h]@1
  int v14; // [sp+1Ch] [bp-8Ch]@1
  float v15; // [sp+20h] [bp-88h]@1
  float v16; // [sp+24h] [bp-84h]@1
  float v17; // [sp+28h] [bp-80h]@1
  int v18; // [sp+2Ch] [bp-7Ch]@1
  int v19; // [sp+30h] [bp-78h]@1
  int v20; // [sp+34h] [bp-74h]@1
  float v21; // [sp+38h] [bp-70h]@1
  int v22; // [sp+3Ch] [bp-6Ch]@1
  char v23; // [sp+40h] [bp-68h]@7
  char v24; // [sp+50h] [bp-58h]@7
  char v25; // [sp+60h] [bp-48h]@7
  char v26; // [sp+80h] [bp-28h]@7

  v15 = sub_10043800();
  v8 = 1;
  v16 = 6.283185;
  v1 = -1;
  v17 = 6.283185;
  v9 = sub_10043380(&v21);
  LOBYTE(v12) = -1;
  v13 = 0x3FFFF;
  LOBYTE(v11) = -1;
  LOBYTE(v18) = sub_10027110(0);
  LOBYTE(v22) = sub_10027190(0);
  v2 = sub_10026EB0(0);
  LOBYTE(v20) = sub_10027150(0);
  LOBYTE(v19) = sub_100271D0(0);
  v14 = sub_10026F90(0);
  v10 = sub_10027210(0);
  if ( sub_1002BA70() )
  {
    sub_100422A0();
    v1 = *(_BYTE *)(dword_10A09ABC + 812);
    v16 = *(float *)(dword_10A09ABC + 776);
    v3 = *(float *)(dword_10A09ABC + 780);
    LOBYTE(v11) = v1;
    v17 = v3;
    if ( v1 >= 0x66u && v1 != -1 )
    {
      v1 = -1;
      LOBYTE(v11) = -1;
    }
    sub_10042290();
    sub_10022D30(v1, &v12, &v13);
  }
  if ( LOBYTE(v12) == -1 )
  {
    sub_1002C120(a1 + 16, "____", 5);
    *(float *)(a1 + 8) = 6.2831855;
    v7 = 9.8999998e24;
    *(_DWORD *)a1 = 0x7FFFFFFF;
    *(float *)(a1 + 4) = 9.8999998e24;
  }
  else
  {
    sub_100237B0(v13, (int)&v25);
    sub_1002C120(a1 + 16, &v26, 5);
    sub_10068240((int)&v16, (int)&v24);
    sub_10026170(0, v13, (double *)&v23);
    LOBYTE(v4) = sub_10062C70();
    sub_10060410((int)&v24, (int)&v23, v4, (float *)(a1 + 4), a1 + 8);
    if ( v2 != 0x3FFFF && (sub_10022C60(LOBYTE(v11), v2, v18, v22) || sub_10022C60(LOBYTE(v11), v14, v20, v19)) )
    {
      v5 = v10;
      if ( v1 > v10 )
        v5 = LOBYTE(v12);
      LOBYTE(v11) = v5;
      v6 = sub_1005F8F0(v11, a1 + 4, a1);
    }
    else
    {
      v6 = sub_1005F8F0(v12, a1 + 4, a1);
    }
    if ( v6 && v9 == 1 && *(_DWORD *)a1 != 0x7FFFFFFF && 9.8999998e24 != v15 && sub_1002ED20((bool *)&v8) && !v8 )
      v7 = v15 - (double)*(unsigned int *)a1 * v21;
    else
      v7 = 9.8999998e24;
  }
  *(float *)(a1 + 12) = v7;
}
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (10025610) --------------------------------------------------------
int __cdecl sub_10025610(int a1, void *a2, void *a3)
{
  int v3; // eax@1
  unsigned __int8 v4; // al@2
  unsigned __int8 v5; // bl@2
  int v6; // eax@2
  int v7; // eax@2
  char v8; // bl@2
  int v9; // eax@3
  bool v10; // zf@4
  unsigned int v11; // eax@4
  unsigned int v12; // eax@5
  int v13; // eax@6
  int v14; // eax@6
  int result; // eax@11
  __int64 v16; // [sp-4h] [bp-68h]@0
  int v17; // [sp+14h] [bp-50h]@1
  int v18; // [sp+18h] [bp-4Ch]@11
  int v19; // [sp+1Ch] [bp-48h]@11
  char v20; // [sp+20h] [bp-44h]@11
  char v21; // [sp+24h] [bp-40h]@2
  unsigned int v22; // [sp+28h] [bp-3Ch]@4
  char v23; // [sp+44h] [bp-20h]@11
  char v24; // [sp+46h] [bp-1Eh]@11
  int v25; // [sp+54h] [bp-10h]@11
  int v26; // [sp+58h] [bp-Ch]@11
  char v27; // [sp+5Ch] [bp-8h]@11

  LODWORD(v16) = a1;
  v3 = (unsigned __int8)sub_10026DA0(v16);
  v17 = (unsigned __int8)v3;
  switch ( v3 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
      v4 = sub_10026CC0(a1);
      v5 = v4;
      v6 = sub_10026CF0(a1, v4, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v6, 29, &v21);
      v7 = v5;
      v8 = 0;
      if ( !v7 )
        goto LABEL_7;
      v9 = v7 - 1;
      if ( !v9 )
        goto LABEL_7;
      v10 = v9 == 1;
      v11 = v22;
      if ( v10 )
        goto LABEL_8;
      v12 = (v22 >> 17) & 0x1FF;
      break;
    case 5:
    case 6:
    case 7:
    case 8:
      v13 = sub_100231E0(a1);
      v8 = 0;
      v14 = sub_10026CF0(v13, 0, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v14, 29, &v21);
LABEL_7:
      v11 = v22;
LABEL_8:
      v12 = (v11 >> 17) & 0x1FF;
      break;
    default:
      v8 = 0;
      v12 = 0;
      break;
  }
  switch ( v17 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
      (*(void (__cdecl **)(unsigned int, signed int, int *))dword_10A09214)(
        dword_10A09264 + v12 * (unsigned __int16)word_10A09268,
        9,
        &v18);
      v25 = v18;
      v26 = v19;
      v27 = v20;
      sub_100424C0((int)&v27, &v27, 12, (int)&v23);
      memcpy_0(a2, &v23, 2u);
      memcpy_0(a3, &v24, 0xAu);
      result = sub_1002C320((int)a3, 10);
      break;
    default:
      result = 1600085855;
      *(_WORD *)a2 = 24415;
      *(_DWORD *)a3 = 1600085855;
      *((_DWORD *)a3 + 1) = 1600085855;
      *((_WORD *)a3 + 4) = 24415;
      break;
  }
  *((_BYTE *)a2 + 2) = v8;
  *((_BYTE *)a3 + 10) = v8;
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09264: using guessed type int dword_10A09264;
// 10A09268: using guessed type __int16 word_10A09268;

//----- (100257C0) --------------------------------------------------------
int __cdecl sub_100257C0(unsigned __int8 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 4u )
    result = sub_10042CB0((unsigned __int8)byte_100A975C[12 * a1]);
  return result;
}

//----- (100257F0) --------------------------------------------------------
char __cdecl sub_100257F0(unsigned __int8 a1, int a2, char a3, int a4)
{
  char result; // al@2

  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, int))dword_10A09214)(
                          a2 + dword_100A9760[3 * a1] - 3,
                          4,
                          a4) )
  {
    *(_BYTE *)(a4 + 4) = a3;
    *(_BYTE *)a4 &= byte_100A8A48[5 * a1];
    *(_BYTE *)(a4 + 1) &= byte_100A8A49[5 * a1];
    *(_BYTE *)(a4 + 2) &= byte_100A8A4A[5 * a1];
    *(_BYTE *)(a4 + 3) &= byte_100A8A4B[5 * a1];
    *(_BYTE *)(a4 + 4) &= byte_100A8A4C[5 * a1];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100A9760: using guessed type int dword_100A9760[];
// 10A09214: using guessed type int dword_10A09214;

//----- (10025870) --------------------------------------------------------
signed int __usercall sub_10025870@<eax>(signed int result@<eax>, int a2@<ecx>)
{
  void *v2; // edi@2
  unsigned int v3; // ecx@2

  if ( result < 31 )
  {
    v2 = (void *)(a2 + 4 * result);
    v3 = 31 - result;
    result = 0x3FFFF;
    memset32(v2, 0x3FFFF, v3);
  }
  return result;
}

//----- (10025890) --------------------------------------------------------
char __usercall sub_10025890@<al>(int a1@<eax>, unsigned __int8 a2)
{
  int v2; // edi@1
  unsigned int v3; // edi@2
  char v4; // dl@2
  signed int v5; // eax@2
  char result; // al@6
  __int16 v7; // [sp+Ch] [bp-1ECh]@1
  char v8[490]; // [sp+Eh] [bp-1EAh]@3

  v2 = a1;
  if ( (unsigned __int8)(*(int (__cdecl **)(int, signed int, __int16 *))dword_10A09214)(
                          dword_10A09240[3 * (unsigned __int8)byte_100A9758[12 * a2]],
                          492,
                          &v7) )
  {
    v3 = v2 - *(_DWORD *)(dword_10A09A90 + 4 * a2 + 20812);
    v4 = 0;
    v5 = 163;
    do
    {
      if ( *(unsigned __int16 *)((char *)&v7 + 3 * v5) + ((v8[3 * v5] & 3u) << 16) <= v3 )
      {
        v4 = v5;
        v5 = 0;
      }
      --v5;
    }
    while ( v5 >= 0 );
    result = v4 + 4;
  }
  else
  {
    result = -92;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09240: using guessed type int dword_10A09240[];
// 10A09A90: using guessed type int dword_10A09A90;
// 10025890: using guessed type char var_1EA[490];

//----- (10025930) --------------------------------------------------------
int __cdecl sub_10025930(int a1)
{
  unsigned __int8 v1; // cl@0
  int result; // eax@1
  int v3; // ecx@2

  result = 0x3FFFF;
  if ( v1 < 4u )
  {
    v3 = 6 * (unsigned __int8)byte_100A9758[12 * v1];
    result = dword_10A09240[2 * v3 / 4u] + a1 * (unsigned __int16)word_10A09244[v3];
  }
  return result;
}
// 10A09240: using guessed type int dword_10A09240[];
// 10A09244: using guessed type __int16 word_10A09244[];

//----- (10025970) --------------------------------------------------------
signed int __usercall sub_10025970@<eax>(unsigned __int8 a1@<bl>, int a2)
{
  char *v2; // ebp@1
  int v3; // esi@1
  int v4; // eax@1
  int v5; // edi@1
  int v6; // eax@3
  int v7; // esi@4
  int v8; // eax@5
  unsigned int v9; // edi@7
  unsigned int v10; // esi@9
  int v11; // eax@9
  signed int result; // eax@15
  unsigned __int8 v13; // [sp+0h] [bp-24h]@0
  unsigned __int16 v14; // [sp+10h] [bp-14h]@3
  char v15; // [sp+12h] [bp-12h]@3
  unsigned int v16; // [sp+14h] [bp-10h]@3
  char v17; // [sp+18h] [bp-Ch]@9
  char v18; // [sp+1Ch] [bp-8h]@9

  v2 = (char *)(a2 + 4);
  v3 = *(_BYTE *)(a2 + 4) - 4;
  v4 = sub_100257C0(v13);
  v5 = v4;
  if ( v3 >= 0
    && v4
    && (v6 = sub_10025930(v3),
        (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_10A09214)(v6, 3, &v14),
        v16 = v14 + ((v15 & 3) << 16),
        v16 != 0x3FFFF) )
  {
    v7 = v3 + 1;
    if ( v7 >= 164 )
      goto LABEL_7;
    while ( 1 )
    {
      v8 = sub_10025930(v7);
      (*(void (__cdecl **)(int, signed int, unsigned __int16 *))dword_10A09214)(v8, 3, &v14);
      if ( v14 + ((v15 & 3) << 16) != 0x3FFFF )
        break;
      if ( ++v7 >= 164 )
        goto LABEL_7;
    }
    if ( v7 >= 164 )
LABEL_7:
      v9 = v5 - 1;
    else
      v9 = v14 + ((v15 & 3) << 16);
    while ( v9 > v16 )
    {
      v10 = (v16 + v9) >> 1;
      v11 = sub_10026CF0(v10, a1, 0);
      sub_100257F0(a1, v11, *v2, (int)&v17);
      if ( sub_100429F0(v2, &v18, 5) <= 0 )
        v9 = v10;
      else
        v16 = v10 + 1;
    }
    result = v9;
  }
  else
  {
    result = 0x3FFFF;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (10025AE0) --------------------------------------------------------
int __fastcall sub_10025AE0(int a1, int a2)
{
  int result; // eax@1

  result = ((*(_WORD *)a1 << 9) + (*(_WORD *)(a1 + 5) & 0x1FF)) << 7;
  *(_DWORD *)a2 = (*(_BYTE *)(a1 + 4) + (*(_WORD *)(a1 + 2) << 8)) << 7;
  *(_DWORD *)(a2 + 4) = result;
  return result;
}

//----- (10025B10) --------------------------------------------------------
void __cdecl sub_10025B10(unsigned int a1, int a2)
{
  unsigned __int8 v2; // bl@4
  int v3; // ebp@4
  char v4; // ST34_1@4
  char v5; // [sp+Ch] [bp-Ch]@4
  char v6; // [sp+10h] [bp-8h]@5

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_10A09A90 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        sub_100282C0(a1, a2);
      else
        sub_10024330(a1, a2);
    }
    else
    {
      v2 = sub_10026CC0(a1);
      v3 = sub_10026CF0(a1, v2, 1);
      v4 = sub_10025890(a1, v2);
      if ( sub_100257F0(v2, v3, v4, (int)&v5) )
      {
        sub_10042BD0(&v6, 6, a2);
        sub_1002C320(a2, 6);
      }
      else
      {
        *(_DWORD *)a2 = *(_DWORD *)"______";
        *(_WORD *)(a2 + 4) = *(_WORD *)"__";
        *(_BYTE *)(a2 + 6) = a______[6];
      }
    }
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)"______";
    *(_WORD *)(a2 + 4) = *(_WORD *)"__";
    *(_BYTE *)(a2 + 6) = a______[6];
  }
}
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10025C50) --------------------------------------------------------
char __cdecl sub_10025C50(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // al@4
  int v4; // eax@4
  char v5; // [sp+4h] [bp-8h]@4

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_10A09A90 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
        result = sub_100284A0(a1, a2);
      else
        result = sub_10024530(a1, a2);
    }
    else
    {
      v3 = sub_10026CC0(a1);
      v4 = sub_10026CF0(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v4, 7, &v5);
      result = sub_10025AE0((int)&v5, a2);
    }
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = 2147483648;
    *(_DWORD *)(a2 + 4) = 2147483648;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10025D00) --------------------------------------------------------
signed int __cdecl sub_10025D00(unsigned __int8 a1)
{
  int v1; // ecx@0
  _DWORD *v2; // esi@1
  signed int result; // eax@1
  signed int v4; // ebp@1
  int v5; // edi@2
  char v6; // ST30_1@2
  unsigned int v7; // eax@2
  char *v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // esi@6
  int v11; // eax@7
  _BYTE *v12; // ecx@7
  _BYTE *v13; // edx@7
  int v14; // eax@9
  _BYTE *v15; // ecx@9
  _BYTE *v16; // edx@9
  _BYTE *v17; // ecx@11
  _BYTE *v18; // edx@11
  signed int v19; // eax@13
  bool v20; // zf@16
  char v21; // [sp+10h] [bp-Ch]@2

  v2 = (_DWORD *)v1;
  result = sub_10025970(a1, v1);
  v4 = result;
  if ( result == 0x3FFFF )
    return result;
  v5 = sub_10026CF0(result, a1, 0);
  v6 = sub_10025890(v4 + *(_DWORD *)(dword_10A09A90 + 4 * a1 + 20812), a1);
  sub_100257F0(a1, v5, v6, (int)&v21);
  v7 = 5;
  v8 = &v21;
  v9 = v2;
  do
  {
    if ( *v9 != *(_DWORD *)v8 )
      goto LABEL_6;
    v7 -= 4;
    v8 += 4;
    ++v9;
  }
  while ( v7 >= 4 );
  if ( !v7 )
  {
LABEL_15:
    v19 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v10 = *(_BYTE *)v9 - (unsigned __int8)*v8;
  if ( *(_BYTE *)v9 == (unsigned __int8)*v8 )
  {
    v11 = v7 - 1;
    v12 = v8 + 1;
    v13 = (char *)v9 + 1;
    if ( !v11 )
      goto LABEL_15;
    v10 = *v13 - *v12;
    if ( *v13 == *v12 )
    {
      v14 = v11 - 1;
      v15 = v12 + 1;
      v16 = v13 + 1;
      if ( !v14 )
        goto LABEL_15;
      v10 = *v16 - *v15;
      if ( *v16 == *v15 )
      {
        v17 = v15 + 1;
        v18 = v16 + 1;
        if ( v14 == 1 )
          goto LABEL_15;
        v10 = *v18 - *v17;
        if ( *v18 == *v17 )
          goto LABEL_15;
      }
    }
  }
  v19 = 1;
  if ( v10 <= 0 )
    v19 = -1;
LABEL_16:
  v20 = v19 == 0;
  result = 0x3FFFF;
  if ( v20 )
    result = v4;
  return result;
}
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10025E20) --------------------------------------------------------
signed int __usercall sub_10025E20@<eax>(unsigned __int8 a1@<dl>, int a2@<ecx>, _DWORD *a3)
{
  unsigned __int8 v3; // bl@1
  unsigned int v4; // edi@1
  int v5; // esi@2
  char v6; // ST30_1@2
  _DWORD *v7; // edx@2
  unsigned int v8; // eax@2
  char *v9; // ecx@2
  int v10; // esi@6
  int v11; // eax@7
  _BYTE *v12; // ecx@7
  _BYTE *v13; // edx@7
  int v14; // eax@9
  _BYTE *v15; // ecx@9
  _BYTE *v16; // edx@9
  _BYTE *v17; // ecx@11
  _BYTE *v18; // edx@11
  signed int v19; // eax@13
  bool v20; // zf@16
  signed int result; // eax@16
  char v22; // [sp+10h] [bp-Ch]@2

  v3 = a1;
  v4 = a2 + 1;
  if ( a2 + 1 >= (unsigned int)sub_100257C0(a1) )
    return 0x3FFFF;
  v5 = sub_10026CF0(v4, v3, 0);
  v6 = sub_10025890(v4 + *(_DWORD *)(dword_10A09A90 + 4 * v3 + 20812), v3);
  sub_100257F0(v3, v5, v6, (int)&v22);
  v7 = a3;
  v8 = 5;
  v9 = &v22;
  do
  {
    if ( *v7 != *(_DWORD *)v9 )
      goto LABEL_6;
    v8 -= 4;
    v9 += 4;
    ++v7;
  }
  while ( v8 >= 4 );
  if ( !v8 )
  {
LABEL_15:
    v19 = 0;
    goto LABEL_16;
  }
LABEL_6:
  v10 = *(_BYTE *)v7 - (unsigned __int8)*v9;
  if ( *(_BYTE *)v7 == (unsigned __int8)*v9 )
  {
    v11 = v8 - 1;
    v12 = v9 + 1;
    v13 = (char *)v7 + 1;
    if ( !v11 )
      goto LABEL_15;
    v10 = *v13 - *v12;
    if ( *v13 == *v12 )
    {
      v14 = v11 - 1;
      v15 = v12 + 1;
      v16 = v13 + 1;
      if ( !v14 )
        goto LABEL_15;
      v10 = *v16 - *v15;
      if ( *v16 == *v15 )
      {
        v17 = v15 + 1;
        v18 = v16 + 1;
        if ( v14 == 1 )
          goto LABEL_15;
        v10 = *v18 - *v17;
        if ( *v18 == *v17 )
          goto LABEL_15;
      }
    }
  }
  v19 = 1;
  if ( v10 <= 0 )
    v19 = -1;
LABEL_16:
  v20 = v19 == 0;
  result = v4;
  if ( !v20 )
    return 0x3FFFF;
  return result;
}
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10025F30) --------------------------------------------------------
void __usercall sub_10025F30(int a1@<ecx>, int a2@<esi>)
{
  int v2; // [sp+0h] [bp-8h]@1
  int v3; // [sp+4h] [bp-4h]@1

  sub_10025AE0(a1, (int)&v2);
  *(double *)a2 = sub_10042B90(v2, 24);
  *(double *)(a2 + 8) = sub_10042B90(v3, 24);
}

//----- (10025F60) --------------------------------------------------------
signed int __cdecl sub_10025F60(const char *a1, int a2, signed int *a3)
{
  int v3; // edi@1
  unsigned __int8 v4; // bl@2
  signed int v5; // edi@2
  int i; // eax@3
  int v7; // eax@9
  unsigned __int8 v9; // [sp+Ch] [bp-14h]@2
  char v10; // [sp+14h] [bp-Ch]@1
  char v11; // [sp+18h] [bp-8h]@1

  v3 = (int)a1;
  *a3 = 0;
  sub_10042A50(a1, (int)&v10);
  if ( v11 )
  {
    v4 = 0;
    v9 = 0;
    v5 = 20812;
    do
    {
      for ( i = sub_10025D00(v9); i != 0x3FFFF; i = sub_10025E20(v4, i, &v10) )
      {
        if ( *a3 >= 31 )
          break;
        *(_DWORD *)(a2 + 4 * (*a3)++) = i + *(_DWORD *)(v5 + dword_10A09A90);
      }
      ++v4;
      v5 += 4;
      v9 = v4;
    }
    while ( v4 < 4u );
    v3 = (int)a1;
  }
  if ( *a3 < 31 )
  {
    v7 = sub_10028090(v3);
    if ( v7 != 0x3FFFF )
      *(_DWORD *)(a2 + 4 * (*a3)++) = v7;
  }
  return sub_10025870(*a3, a2);
}
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10026050) --------------------------------------------------------
char __cdecl sub_10026050(unsigned int a1, int a2)
{
  char result; // al@2
  unsigned __int8 v3; // bl@4
  int v4; // eax@4
  unsigned int v5; // ebx@7
  char v6; // bl@13
  int v7; // [sp+4h] [bp-20h]@4
  int v8; // [sp+8h] [bp-1Ch]@10
  unsigned __int8 v9; // [sp+Ch] [bp-18h]@9
  unsigned int v10; // [sp+Eh] [bp-16h]@7
  unsigned int v11; // [sp+14h] [bp-10h]@8

  if ( a1 >= 0x3E8 )
  {
    if ( a1 >= *(_DWORD *)(dword_10A09A90 + 20828) )
    {
      if ( ((a1 >> 16) & 0xFC00) == 12288 )
      {
        v6 = sub_100284A0(a1, (int)&v7);
        if ( v6 )
        {
          sub_1002EE90(a2, v7, v8);
          result = v6;
        }
        else
        {
          *(double *)a2 = 6.2831853071796;
          *(double *)(a2 + 8) = 6.2831853071796;
          result = 0;
        }
      }
      else
      {
        result = sub_100244C0(a1, a2);
      }
    }
    else
    {
      v3 = sub_10026CC0(a1);
      v4 = sub_10026CF0(a1, v3, 1);
      (*(void (__cdecl **)(int, signed int, int *))dword_10A09214)(v4, 32, &v7);
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          LOBYTE(v5) = v9 >> 1;
        }
        else if ( v3 == 2 )
        {
          v5 = v11 >> 14;
        }
        else
        {
          v5 = v10 >> 23;
        }
      }
      else
      {
        v5 = (unsigned int)v8 >> 29;
      }
      sub_10025F30((int)&v7, a2);
      result = v5 & 1;
    }
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
    result = 0;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10026170) --------------------------------------------------------
double *__cdecl sub_10026170(char a1, char a2, double *a3)
{
  unsigned int v3; // esi@1
  double *result; // eax@10
  __int64 v5; // [sp-4h] [bp-60h]@0
  int v6; // [sp+4h] [bp-58h]@7
  char v7; // [sp+8h] [bp-54h]@10
  double v8; // [sp+10h] [bp-4Ch]@3
  double v9; // [sp+18h] [bp-44h]@10
  char v10; // [sp+20h] [bp-3Ch]@10

  v3 = a2;
  if ( a2 == 0x3FFFF )
    goto LABEL_11;
  if ( (unsigned int)a2 >= 0x3E8 )
  {
    if ( a2 == 262141 )
    {
      sub_1002BC40(a1, (int)&v8);
      goto LABEL_13;
    }
    LODWORD(v5) = a2;
    if ( sub_10023010(v5) != 11 )
    {
      sub_10026050(v3, (int)&v8);
      goto LABEL_13;
    }
    sub_100264B0(v3, &v6, &a2);
    if ( (_BYTE)v6 != -1 && a2 != -1 && sub_10026F30(v6, a2) == v3 )
    {
      sub_10024750(v6, a2, &v10);
      sub_100245D0((int)&v10, (int)&v7);
      sub_10068240((int)&v7, (int)&v8);
      result = a3;
      *a3 = v8;
      result[1] = v9;
      return result;
    }
LABEL_11:
    result = a3;
    v8 = 6.2831853071796;
    v9 = 6.2831853071796;
    *a3 = 6.2831853071796;
    result[1] = v9;
    return result;
  }
  sub_100273D0(a2, (int)&v8);
LABEL_13:
  result = a3;
  *a3 = v8;
  result[1] = v9;
  return result;
}

//----- (100262A0) --------------------------------------------------------
int __cdecl sub_100262A0(_BYTE *a1, _BYTE *a2, int a3)
{
  _BYTE *v3; // edx@1
  _BYTE *v4; // ecx@1
  int v5; // esi@1
  int result; // eax@1

  v3 = a2;
  v4 = a1;
  v5 = a3;
  result = 0;
  do
  {
    if ( v5 <= 0 )
      break;
    result = *v4-- - *v3--;
    --v5;
  }
  while ( !result );
  return result;
}

//----- (100262D0) --------------------------------------------------------
int __cdecl sub_100262D0(int a1, int a2)
{
  unsigned int v2; // edx@1
  int v3; // ebx@1
  int v4; // ecx@1
  signed int v5; // esi@1
  unsigned int v6; // eax@2
  unsigned int v7; // eax@12
  unsigned int v8; // eax@15
  int v9; // ecx@15
  unsigned int v10; // eax@25
  unsigned int v11; // eax@28
  int v12; // ecx@28
  unsigned int v13; // eax@38
  int result; // eax@47

  v2 = 0;
  v3 = 0;
  v4 = 34;
  v5 = 0;
  while ( 1 )
  {
    v6 = *(_BYTE *)(v5 + a1);
    if ( v6 - 65 > 0x19 )
    {
      if ( v6 - 48 > 9 )
      {
        if ( v6 == 32 )
        {
          v6 = 0;
        }
        else if ( !*(_BYTE *)(v5 + a1) )
        {
          goto LABEL_45;
        }
      }
      else
      {
        v6 -= 16;
      }
    }
    else
    {
      v6 -= 64;
    }
    if ( v4 == 34 )
    {
      v3 |= 4 * v6;
    }
    else
    {
      if ( v4 == 28 )
      {
        v3 |= v6 >> 4;
        v7 = v6 << 28;
      }
      else
      {
        v7 = v6 << v4;
      }
      v2 |= v7;
    }
    v8 = *(_BYTE *)(v5 + a1 + 1);
    v9 = v4 - 6;
    if ( v8 - 65 > 0x19 )
    {
      if ( v8 - 48 > 9 )
      {
        if ( v8 == 32 )
        {
          v8 = 0;
        }
        else if ( !*(_BYTE *)(v5 + a1 + 1) )
        {
          ++v5;
          goto LABEL_45;
        }
      }
      else
      {
        v8 -= 16;
      }
    }
    else
    {
      v8 -= 64;
    }
    if ( v9 == 34 )
    {
      v3 |= 4 * v8;
    }
    else
    {
      if ( v9 == 28 )
      {
        v3 |= v8 >> 4;
        v10 = v8 << 28;
      }
      else
      {
        v10 = v8 << v9;
      }
      v2 |= v10;
    }
    v11 = *(_BYTE *)(v5 + a1 + 2);
    v12 = v9 - 6;
    if ( v11 - 65 > 0x19 )
      break;
    v11 -= 64;
LABEL_35:
    if ( v12 == 34 )
    {
      v3 |= 4 * v11;
    }
    else
    {
      if ( v12 == 28 )
      {
        v3 |= v11 >> 4;
        v13 = v11 << 28;
      }
      else
      {
        v13 = v11 << v12;
      }
      v2 |= v13;
    }
    v5 += 3;
    v4 = v12 - 6;
    if ( v5 >= 6 )
      goto LABEL_45;
  }
  if ( v11 - 48 <= 9 )
  {
    v11 -= 16;
    goto LABEL_35;
  }
  if ( v11 == 32 )
  {
    v11 = 0;
    goto LABEL_35;
  }
  if ( *(_BYTE *)(v5 + a1 + 2) )
    goto LABEL_35;
  v5 += 2;
LABEL_45:
  if ( *(_BYTE *)(v5 + a1) )
  {
    v2 = -136348176;
    LOBYTE(v3) = 125;
  }
  result = a2;
  *(_BYTE *)(a2 + 1) = BYTE1(v2);
  *(_BYTE *)a2 = v2;
  *(_BYTE *)(a2 + 4) = v3;
  *(_BYTE *)(a2 + 2) = v2 >> 16;
  *(_BYTE *)(a2 + 3) = BYTE3(v2);
  return result;
}

//----- (10026430) --------------------------------------------------------
int __cdecl sub_10026430(int a1, int a2, int a3, _BYTE *a4)
{
  __int16 v4; // ax@1
  int result; // eax@1
  int v6; // [sp+10h] [bp-10h]@1
  __int16 v7; // [sp+14h] [bp-Ch]@1
  __int16 v8; // [sp+16h] [bp-Ah]@1

  sub_100424C0((int)&v6, (_BYTE *)(a1 + 6), 8, (int)&v6);
  v4 = v7;
  *(_DWORD *)a2 = v6;
  *(_WORD *)(a2 + 4) = v4;
  *(_BYTE *)(a2 + 6) = 0;
  result = sub_1002C320(a2, 6);
  *(_WORD *)a3 = v8;
  *(_BYTE *)(a3 + 2) = 0;
  *a4 = *(_BYTE *)a1 & 0xF;
  return result;
}

//----- (100264B0) --------------------------------------------------------
unsigned int __cdecl sub_100264B0(unsigned int a1, _BYTE *a2, _BYTE *a3)
{
  unsigned int result; // eax@1

  *a2 = a1;
  result = a1 >> 8;
  *a3 = BYTE1(a1);
  return result;
}

//----- (100264D0) --------------------------------------------------------
int __usercall sub_100264D0@<eax>(int a1@<edi>, int a2, int *a3)
{
  int result; // eax@1
  char v4; // [sp+4h] [bp-14h]@1
  int v5; // [sp+8h] [bp-10h]@1
  char v6; // [sp+Ch] [bp-Ch]@1

  sub_10026430(a2, (int)&v6, (int)&v4, &v5);
  result = sub_10023100(a1, (int)&v6, (int)&v4, v5);
  *a3 = result;
  return result;
}

//----- (10026530) --------------------------------------------------------
char __cdecl sub_10026530(int a1, int a2)
{
  char result; // al@2
  int v3; // esi@5
  int v4; // [sp+4h] [bp-A4h]@1
  int v5; // [sp+8h] [bp-A0h]@1
  int v6; // [sp+Ch] [bp-9Ch]@1
  __int16 *v7; // [sp+10h] [bp-98h]@1
  int v8; // [sp+14h] [bp-94h]@1
  int *v9; // [sp+18h] [bp-90h]@1
  int v10; // [sp+1Ch] [bp-8Ch]@1
  int v11; // [sp+20h] [bp-88h]@1
  __int16 v12; // [sp+24h] [bp-84h]@1

  v6 = 0;
  v12 = -32765;
  v11 = 4;
  v7 = &v12;
  v8 = 2;
  v9 = &v4;
  v10 = 400;
  v4 = a2;
  v5 = 1;
  if ( sub_10060A60(56, 1000) )
  {
    sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 118, 0, "Failed to add SMS entry; semaphore reservation error.");
    result = 19;
  }
  else if ( sub_10060ED0(9193, a1, 220) )
  {
    sub_10060A00(56);
    sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 128, 0, "Failed to add SMS entry; registry error");
    result = 18;
  }
  else
  {
    v3 = sub_10060AF0(21, (int)&v7);
    sub_10060A00(56);
    if ( v3 || v5 != 1 )
    {
      sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 144, 0, 0);
      result = 15;
    }
    else
    {
      result = v6;
    }
  }
  return result;
}

//----- (100266B0) --------------------------------------------------------
char __cdecl sub_100266B0(char a1, char a2, int a3)
{
  char result; // al@10
  int v4; // [sp+4h] [bp-A4h]@1
  int v5; // [sp+8h] [bp-A0h]@1
  int v6; // [sp+Ch] [bp-9Ch]@1
  __int16 *v7; // [sp+10h] [bp-98h]@1
  int v8; // [sp+14h] [bp-94h]@1
  int *v9; // [sp+18h] [bp-90h]@1
  int v10; // [sp+1Ch] [bp-8Ch]@1
  int v11; // [sp+20h] [bp-88h]@1
  __int16 v12; // [sp+24h] [bp-84h]@1
  char v13; // [sp+28h] [bp-80h]@1
  char v14; // [sp+2Ah] [bp-7Eh]@1

  v13 = a1;
  v12 = -32741;
  v14 = a2;
  v11 = 4;
  v7 = &v12;
  v8 = 128;
  v9 = &v4;
  v10 = 400;
  v4 = 0;
  v5 = 0;
  v6 = 19;
  if ( !sub_10060A60(56, 1000) )
  {
    if ( sub_10060AF0(21, (int)&v7) || v5 )
    {
      sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 294, 0, 0);
      v6 = 15;
    }
    else if ( !(_BYTE)v6 )
    {
      v6 = 18;
      if ( sub_10060D80(9193, a3, 220) )
        sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 306, 0, "Failed to get SMS entry; registry error");
      else
        v6 = 0;
    }
    sub_10060A00(56);
  }
  result = v6;
  if ( v6 == 19 )
  {
    sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 321, 0, "Failed to get SMS entry; semaphore reservation error.");
    result = v6;
  }
  return result;
}

//----- (10026830) --------------------------------------------------------
char __cdecl sub_10026830(char a1, int a2, int a3)
{
  char result; // al@10
  int v4; // [sp+4h] [bp-A4h]@1
  int v5; // [sp+8h] [bp-A0h]@1
  int v6; // [sp+Ch] [bp-9Ch]@1
  __int16 *v7; // [sp+10h] [bp-98h]@1
  int v8; // [sp+14h] [bp-94h]@1
  int *v9; // [sp+18h] [bp-90h]@1
  int v10; // [sp+1Ch] [bp-8Ch]@1
  int v11; // [sp+20h] [bp-88h]@1
  __int16 v12; // [sp+24h] [bp-84h]@1
  char v13; // [sp+29h] [bp-7Fh]@1

  v13 = a1;
  v12 = -32740;
  v11 = 4;
  v7 = &v12;
  v8 = 128;
  v9 = &v4;
  v10 = 400;
  v4 = a2;
  v5 = 1;
  v6 = 19;
  if ( !sub_10060A60(56, 1000) )
  {
    if ( sub_10060AF0(21, (int)&v7) || v5 != 1 )
    {
      sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 398, 0, 0);
      v6 = 15;
    }
    else if ( !(_BYTE)v6 )
    {
      v6 = 18;
      if ( sub_10060D80(9193, a3, 220) )
        sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 410, 0, "Failed to get SMS entry; registry error");
      else
        v6 = 0;
    }
    sub_10060A00(56);
  }
  result = v6;
  if ( v6 == 19 )
  {
    sub_10028BC0(
      "..\\lib\\adl\\udb_intf_sms.c",
      425,
      0,
      "Failed to get SMS entry by ref num; semaphore reservation error.");
    result = v6;
  }
  return result;
}

//----- (100269B0) --------------------------------------------------------
char __cdecl sub_100269B0(char *a1, char a2, int a3)
{
  char result; // al@2
  int v4; // esi@5
  char *v5; // [sp+4h] [bp-A4h]@1
  int v6; // [sp+8h] [bp-A0h]@1
  int v7; // [sp+Ch] [bp-9Ch]@1
  __int16 *v8; // [sp+10h] [bp-98h]@1
  int v9; // [sp+14h] [bp-94h]@1
  int *v10; // [sp+18h] [bp-90h]@1
  int v11; // [sp+1Ch] [bp-8Ch]@1
  int v12; // [sp+20h] [bp-88h]@1
  __int16 v13; // [sp+24h] [bp-84h]@1
  char v14; // [sp+28h] [bp-80h]@1
  char v15; // [sp+2Ah] [bp-7Eh]@1

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v14 = *a1;
  v15 = a2;
  v13 = -32721;
  v12 = 4;
  v8 = &v13;
  v9 = 128;
  v10 = (int *)&v5;
  v11 = 400;
  v5 = a1;
  v6 = 1;
  if ( sub_10060A60(56, 1000) )
  {
    sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 631, 0, "Failed to replace SMS entry; semaphore reservation error.");
    result = 19;
  }
  else if ( sub_10060ED0(9193, a3, 220) )
  {
    sub_10060A00(56);
    sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 641, 0, "Failed to replace SMS entry; registry error");
    result = 18;
  }
  else
  {
    v4 = sub_10060AF0(21, (int)&v8);
    sub_10060A00(56);
    if ( v4 || v6 != 1 )
    {
      sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 657, 0, 0);
      result = 15;
    }
    else
    {
      result = v7;
    }
  }
  return result;
}

//----- (10026B50) --------------------------------------------------------
char sub_10026B50()
{
  char result; // al@3
  int v1; // [sp+0h] [bp-A4h]@1
  int v2; // [sp+4h] [bp-A0h]@1
  int v3; // [sp+8h] [bp-9Ch]@1
  __int16 *v4; // [sp+Ch] [bp-98h]@1
  int v5; // [sp+10h] [bp-94h]@1
  int *v6; // [sp+14h] [bp-90h]@1
  int v7; // [sp+18h] [bp-8Ch]@1
  int v8; // [sp+1Ch] [bp-88h]@1
  __int16 v9; // [sp+20h] [bp-84h]@1

  v3 = 0;
  v9 = -32710;
  v8 = 4;
  v4 = &v9;
  v5 = 2;
  v6 = &v1;
  v7 = 400;
  v1 = 0;
  v2 = 0;
  if ( sub_10060AF0(21, (int)&v4) || v2 )
  {
    sub_10028BC0("..\\lib\\adl\\udb_intf_sms.c", 866, 0, 0);
    result = 15;
  }
  else
  {
    result = v3;
  }
  return result;
}

//----- (10026C30) --------------------------------------------------------
char __cdecl sub_10026C30(char a1)
{
  __int16 v2; // [sp+0h] [bp-52Ch]@1
  char v3; // [sp+4h] [bp-528h]@1

  v2 = -32713;
  v3 = a1;
  return sub_1002CC60((int)&v2);
}

//----- (10026C80) --------------------------------------------------------
int __cdecl sub_10026C80(unsigned __int8 a1)
{
  int v1; // eax@3
  bool v2; // zf@3
  int result; // eax@3

  if ( a1 >= 0x67u
    || !(unsigned __int8)sub_10022C50()
    || (v1 = 8524 * a1, v2 = a1 == *(_BYTE *)(v1 + dword_10A09220 + 2004), result = v1 + dword_10A09220 + 2004, !v2) )
  {
    result = 0;
  }
  return result;
}
// 10A09220: using guessed type int dword_10A09220;

//----- (10026CC0) --------------------------------------------------------
unsigned __int8 __cdecl sub_10026CC0(unsigned int a1)
{
  unsigned __int8 result; // al@1

  result = 0;
  do
  {
    if ( a1 < *(_DWORD *)(dword_10A09A90 + 4 * result + 20816) )
      break;
    ++result;
  }
  while ( result < 4u );
  return result;
}
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10026CF0) --------------------------------------------------------
int __cdecl sub_10026CF0(unsigned int a1, unsigned __int8 a2, char a3)
{
  unsigned int v3; // esi@2
  char v4; // bl@4
  int result; // eax@5

  if ( a2 >= 4u )
  {
    result = 0xFFFFFF;
  }
  else
  {
    v3 = a1;
    if ( a3 )
      v3 = a1 - *(_DWORD *)(dword_10A09A90 + 4 * a2 + 20812);
    v4 = byte_100A975C[12 * a2];
    if ( sub_10042C70(v3, (unsigned __int8)byte_100A975C[12 * a2]) )
      result = dword_10A09240[3 * (unsigned __int8)v4] + v3 * (unsigned __int16)word_10A09244[6 * (unsigned __int8)v4];
    else
      result = 0xFFFFFF;
  }
  return result;
}
// 10A09240: using guessed type int dword_10A09240[];
// 10A09244: using guessed type __int16 word_10A09244[];
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10026D70) --------------------------------------------------------
int __cdecl sub_10026D70(unsigned int a1)
{
  unsigned __int8 v1; // ST14_1@1

  v1 = sub_10026CC0(a1);
  return sub_10026CF0(a1, v1, 1);
}

//----- (10026DA0) --------------------------------------------------------
char __cdecl sub_10026DA0(__int64 a1)
{
  char v1; // bl@1
  char result; // al@3
  unsigned __int16 v3; // ax@7

  v1 = 9;
  if ( (unsigned int)a1 < 0x3E8 )
  {
LABEL_13:
    result = v1;
  }
  else
  {
    switch ( sub_10026CC0(a1) )
    {
      case 0u:
        result = 0;
        break;
      case 1u:
        result = 1;
        break;
      case 2u:
        result = 2;
        break;
      case 3u:
        result = 3;
        break;
      default:
        v3 = WORD1(a1) >> 10;
        if ( (unsigned __int16)(WORD1(a1) >> 10) >= 0xBu && v3 < 0xDu
          || v3 >= 5u && v3 <= 8u && (unsigned __int16)(a1 - 1000) < (unsigned int)sub_10042CB0(8u) )
        {
          v1 = (*(_DWORD *)((char *)&a1 + 2) >> 10) & 0x3F;
        }
        goto LABEL_13;
    }
  }
  return result;
}

//----- (10026E40) --------------------------------------------------------
double __cdecl sub_10026E40(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-28h]@0
  float v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@2
  int v6; // [sp+12h] [bp-12h]@2

  v4 = 9.9999996e24;
  LODWORD(v3) = a1;
  if ( !sub_10026DA0(v3) )
  {
    v1 = sub_10026D70(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v1, 28, &v5);
    v4 = (double)((v6 & 0x7FFF) - 5000) * 0.3048000037670135;
  }
  return v4;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (10026EB0) --------------------------------------------------------
signed int __cdecl sub_10026EB0(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  v1 = 0x3FFFF;
  sub_10060A60(54, 60000);
  v2 = sub_10026C80(a1);
  if ( v2 && *(_BYTE *)(v2 + 90) != -1 )
    v1 = *(_DWORD *)(v2 + 104);
  sub_10060A00(54);
  return v1;
}

//----- (10026EF0) --------------------------------------------------------
char __cdecl sub_10026EF0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10060A60(54, 60000);
  v1 = 0;
  v2 = sub_10026C80(a1);
  if ( v2 )
    v1 = *(_BYTE *)(v2 + 1);
  sub_10060A00(54);
  return v1;
}

//----- (10026F30) --------------------------------------------------------
signed int __cdecl sub_10026F30(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v2; // esi@1
  int v3; // eax@1

  sub_10060A60(54, 60000);
  v2 = 0x3FFFF;
  v3 = sub_10026C80(a1);
  if ( v3 && a2 < *(_BYTE *)(v3 + 1) )
    v2 = sub_10042A30(84 * a2 + v3 + 148);
  sub_10060A00(54);
  return v2;
}

//----- (10026F90) --------------------------------------------------------
signed int __cdecl sub_10026F90(unsigned __int8 a1)
{
  signed int v1; // esi@1
  int v2; // eax@1

  sub_10060A60(54, 60000);
  v1 = 0x3FFFF;
  v2 = sub_10026C80(a1);
  if ( v2 && *(_BYTE *)(v2 + 60) != 3 && *(_BYTE *)(v2 + 61) != 3 )
    v1 = *(_DWORD *)(v2 + 64);
  sub_10060A00(54);
  return v1;
}

//----- (10026FD0) --------------------------------------------------------
char __cdecl sub_10026FD0(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 1) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10027010) --------------------------------------------------------
char __cdecl sub_10027010(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( !(*(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 125) & 4) )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10027050) --------------------------------------------------------
char __cdecl sub_10027050(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 1) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (10027090) --------------------------------------------------------
char __cdecl sub_10027090(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  _BYTE *v3; // edx@3

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1) - 1;
    if ( v2 >= 0 )
    {
      v3 = (_BYTE *)(84 * v2 + a1 + 125);
      while ( !(*v3 & 4) )
      {
        --v2;
        v3 -= 84;
        if ( v2 < 0 )
          return result;
      }
      result = v2;
    }
  }
  return result;
}

//----- (100270D0) --------------------------------------------------------
char __cdecl sub_100270D0(int a1)
{
  char result; // al@1
  unsigned __int8 v2; // dl@2
  char v3; // cl@2

  result = -1;
  if ( a1 )
  {
    v2 = *(_BYTE *)(a1 + 1);
    v3 = 0;
    if ( v2 )
    {
      while ( *(_BYTE *)(84 * (unsigned __int8)v3 + a1 + 154) != 3 )
      {
        if ( (unsigned __int8)++v3 >= v2 )
          return result;
      }
      result = v3;
    }
  }
  return result;
}

//----- (10027110) --------------------------------------------------------
char __cdecl sub_10027110(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10060A60(54, 60000);
  v1 = -1;
  v2 = sub_10026C80(a1);
  if ( v2 )
    v1 = sub_10026FD0(v2);
  sub_10060A00(54);
  return v1;
}

//----- (10027150) --------------------------------------------------------
char __cdecl sub_10027150(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10060A60(54, 60000);
  v1 = -1;
  v2 = sub_10026C80(a1);
  if ( v2 )
    v1 = sub_10027010(v2);
  sub_10060A00(54);
  return v1;
}

//----- (10027190) --------------------------------------------------------
char __cdecl sub_10027190(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10060A60(54, 60000);
  v1 = -1;
  v2 = sub_10026C80(a1);
  if ( v2 )
    v1 = sub_10027050(v2);
  sub_10060A00(54);
  return v1;
}

//----- (100271D0) --------------------------------------------------------
char __cdecl sub_100271D0(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10060A60(54, 60000);
  v1 = -1;
  v2 = sub_10026C80(a1);
  if ( v2 )
    v1 = sub_10027090(v2);
  sub_10060A00(54);
  return v1;
}

//----- (10027210) --------------------------------------------------------
char __cdecl sub_10027210(unsigned __int8 a1)
{
  char v1; // bl@1
  int v2; // eax@1

  sub_10060A60(54, 60000);
  v1 = -1;
  v2 = sub_10026C80(a1);
  if ( v2 )
    v1 = sub_100270D0(v2);
  sub_10060A00(54);
  return v1;
}

//----- (10027250) --------------------------------------------------------
signed int __cdecl sub_10027250(int a1, _WORD *a2, _BYTE *a3)
{
  signed int result; // eax@1
  int v4; // ecx@2
  int v5; // edi@3
  int i; // ebx@3
  int v7; // esi@4

  result = sub_10022C50();
  if ( (_BYTE)result && (v4 = dword_10A09220, result = *(_WORD *)(dword_10A09220 + 2), (signed __int16)result > 0) )
  {
    v5 = (signed __int16)result - 1;
    for ( i = 0; v5 > i; v4 = dword_10A09220 )
    {
      v7 = (v5 + i) / 2;
      if ( sub_100262A0((_BYTE *)(a1 + 4), (_BYTE *)(v4 + 56 * (*(_WORD *)(v4 + 2 * v7 + 4) + 15721) + 4), 5) <= 0 )
        v5 = (v5 + i) / 2;
      else
        i = v7 + 1;
    }
    result = sub_100262A0((_BYTE *)(a1 + 4), (_BYTE *)(v4 + 56 * (*(_WORD *)(v4 + 2 * v5 + 4) + 15721) + 4), 5);
    if ( result <= 0 )
    {
      if ( result >= 0 )
      {
        result = (signed int)a3;
        *a2 = v5;
        *a3 = 1;
      }
      else
      {
        result = (signed int)a2;
        *a2 = v5;
        *a3 = 0;
      }
    }
    else
    {
      *a2 = v5 + 1;
      *a3 = 0;
    }
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
  }
  return result;
}
// 10A09220: using guessed type int dword_10A09220;

//----- (10027350) --------------------------------------------------------
char __usercall sub_10027350@<al>(unsigned __int16 a1@<ax>, void *a2)
{
  unsigned __int16 v2; // si@1
  char result; // al@4

  v2 = a1;
  if ( (unsigned __int8)sub_10022C50() && v2 < 0x3E8u && *(_WORD *)(dword_10A09220 + 56 * v2 + 880428) == v2 )
  {
    qmemcpy(a2, (const void *)(dword_10A09220 + 56 * (v2 + 15721)), 0x38u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10A09220: using guessed type int dword_10A09220;

//----- (100273B0) --------------------------------------------------------
int __usercall sub_100273B0@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(double *)result = (double)*(signed int *)a2 * 0.000000001462918079267163;
  *(double *)(result + 8) = 0.000000001462918079267163 * (double)*(signed int *)(a2 + 4);
  return result;
}

//----- (100273D0) --------------------------------------------------------
int __cdecl sub_100273D0(unsigned __int16 a1, int a2)
{
  char v3; // [sp+4h] [bp-3Ch]@1
  char v4; // [sp+Ch] [bp-34h]@3

  sub_10060A60(58, 60000);
  if ( sub_10027350(a1, &v3) )
  {
    sub_100273B0(a2, (int)&v4);
  }
  else
  {
    *(double *)a2 = 6.2831853071796;
    *(double *)(a2 + 8) = 6.2831853071796;
  }
  return sub_10060A00(58);
}

//----- (10027440) --------------------------------------------------------
signed int __cdecl sub_10027440(int a1, _WORD *a2, _BYTE *a3)
{
  char v4; // [sp+8h] [bp-Ch]@1

  sub_100262D0(a1, (int)&v4);
  return sub_10027250((int)&v4, a2, a3);
}

//----- (10027490) --------------------------------------------------------
signed int __cdecl sub_10027490(int a1)
{
  signed int v1; // esi@1
  char v3; // [sp+7h] [bp-5h]@1
  __int16 v4; // [sp+8h] [bp-4h]@1

  v1 = 0x3FFFF;
  sub_10060A60(58, 60000);
  sub_10027440(a1, &v4, &v3);
  if ( v3 )
    v1 = *(_WORD *)(dword_10A09220 + 2 * v4 + 4);
  sub_10060A00(58);
  return v1;
}
// 10A09220: using guessed type int dword_10A09220;

//----- (100274F0) --------------------------------------------------------
int sub_100274F0()
{
  int result; // eax@2
  unsigned __int8 v1; // [sp+0h] [bp-Ch]@4
  int v2; // [sp+2h] [bp-Ah]@4
  int v3; // [sp+6h] [bp-6h]@4

  if ( sub_10042C70(0x4Du, 1u) )
  {
    result = dword_10A095DC;
    dword_1094353C = dword_10A095DC;
    if ( dword_10A095DC )
    {
      (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_10A09214)(dword_10A095DC, 8, &v1);
      word_10943534 = v1;
      result = v3 & 0x1FF;
      dword_1094353C += (unsigned __int16)word_10A095E0;
      word_10943538 = v2 & 0x1FF;
      word_10943530 = v3 & 0x1FF;
    }
  }
  else
  {
    word_10943534 = 6;
    word_10943538 = 6;
    result = dword_10A0945C;
    word_10943530 = 60;
    dword_1094353C = dword_10A0945C;
  }
  return result;
}
// 10943530: using guessed type __int16 word_10943530;
// 10943534: using guessed type __int16 word_10943534;
// 10943538: using guessed type __int16 word_10943538;
// 1094353C: using guessed type int dword_1094353C;
// 10A09214: using guessed type int dword_10A09214;
// 10A0945C: using guessed type int dword_10A0945C;
// 10A095DC: using guessed type int dword_10A095DC;
// 10A095E0: using guessed type __int16 word_10A095E0;

//----- (10027590) --------------------------------------------------------
char __cdecl sub_10027590(float *a1)
{
  int v1; // ecx@0
  int v2; // esi@1
  char v3; // bl@1
  char v4; // al@1
  float v5; // ST44_4@4
  double v6; // st6@4
  signed __int16 v7; // si@4
  signed int v8; // eax@4
  signed __int16 v9; // di@4
  float v10; // ST44_4@7
  __int16 v11; // cx@8
  __int16 v12; // ax@8
  signed int v13; // edi@8
  __int16 v14; // bp@8
  int v15; // esi@8
  __int16 v16; // bx@8
  signed int v17; // esi@8
  int *v18; // edi@8
  signed int v19; // ecx@10
  __int64 v20; // rax@11
  __int16 v21; // si@16
  float v23; // [sp+Ch] [bp-1Ch]@8
  float v24; // [sp+10h] [bp-18h]@4
  float v25; // [sp+10h] [bp-18h]@8
  int v26; // [sp+18h] [bp-10h]@8
  int v27; // [sp+1Ch] [bp-Ch]@8

  *a1 = 0.0;
  v2 = v1;
  v3 = 0;
  v4 = sub_10043B50(v1, 0);
  if ( dword_1094353C && v4 && sub_10042C70(0, 0x2Du) )
  {
    v24 = (*(float *)v2 + 1.570796370506287) * 57.29578018188477;
    v5 = 57.29578018188477 * (*(float *)(v2 + 4) + 3.141592741012573);
    v6 = v5;
    v7 = (signed int)v24;
    v8 = (signed int)v5;
    v9 = v8;
    if ( v7 > 179 )
      v7 = 179;
    if ( v9 >= 360 )
    {
      v9 = v8 - 360;
      v10 = v6 - 360.0;
      v6 = v10;
    }
    v11 = v7 / word_10943534;
    v12 = v9 / word_10943538;
    v13 = (signed __int16)(v7 / word_10943534);
    v14 = v7 / word_10943534 + 1;
    v23 = v24 / (double)word_10943534 - (double)v13;
    v15 = v12;
    v25 = v6 / (double)word_10943538 - (double)v12;
    v16 = (v12 + 1) % word_10943530;
    (*(void (__cdecl **)(int, signed int, int *))dword_10A09214)(
      dword_1094353C + (unsigned __int16)word_10A09460 * (v12 + v11 * word_10943530),
      2,
      &v26);
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(
      dword_1094353C + (unsigned __int16)word_10A09460 * (v16 + v13 * word_10943530),
      2,
      (char *)&v26 + 2);
    (*(void (__cdecl **)(int, signed int, int *))dword_10A09214)(
      dword_1094353C + (unsigned __int16)word_10A09460 * (v15 + v14 * word_10943530),
      2,
      &v27);
    (*(void (__cdecl **)(int, _DWORD, char *))dword_10A09214)(
      dword_1094353C + (unsigned __int16)word_10A09460 * (v16 + v14 * word_10943530),
      2,
      (char *)&v27 + 2);
    v3 = 1;
    v17 = 1;
    v18 = &v26;
    do
    {
      if ( !v3 )
        break;
      v19 = v17;
      if ( v17 < 4 )
      {
        while ( 1 )
        {
          v20 = (signed __int16)(*(_WORD *)v18 - *((_WORD *)&v26 + v19));
          if ( (signed int)((HIDWORD(v20) ^ v20) - HIDWORD(v20)) > 1820 )
            break;
          if ( ++v19 >= 4 )
            goto LABEL_15;
        }
        v3 = 0;
      }
LABEL_15:
      ++v17;
      v18 = (int *)((char *)v18 + 2);
    }
    while ( v17 - 1 < 3 );
    v21 = v26 + (signed int)((double)(signed __int16)(v27 - v26) * v23);
    *a1 = (double)(signed __int16)(v21
                                 + (signed int)((double)(signed __int16)(HIWORD(v26)
                                                                       + (signed int)(v23
                                                                                    * (double)(signed __int16)(HIWORD(v27) - HIWORD(v26)))
                                                                       - v21)
                                              * v25))
        * 0.0000958738019107841;
  }
  return v3;
}
// 10943530: using guessed type __int16 word_10943530;
// 10943534: using guessed type __int16 word_10943534;
// 10943538: using guessed type __int16 word_10943538;
// 1094353C: using guessed type int dword_1094353C;
// 10A09214: using guessed type int dword_10A09214;
// 10A09460: using guessed type __int16 word_10A09460;

//----- (10027850) --------------------------------------------------------
char __cdecl sub_10027850(int a1, float *a2)
{
  return sub_10027590(a2);
}

//----- (10027870) --------------------------------------------------------
double __cdecl sub_10027870(unsigned int a1)
{
  int v1; // eax@2
  __int64 v3; // [sp-4h] [bp-44h]@0
  float v4; // [sp+4h] [bp-3Ch]@1
  char v5; // [sp+8h] [bp-38h]@5
  char v6; // [sp+10h] [bp-30h]@5
  char v7; // [sp+20h] [bp-20h]@2
  unsigned int v8; // [sp+24h] [bp-1Ch]@2
  int v9; // [sp+2Eh] [bp-12h]@4

  v4 = 6.2831855;
  LODWORD(v3) = a1;
  if ( sub_10026DA0(v3) == 3 )
  {
    v1 = sub_10026D70(a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v1, 29, &v7);
    if ( v8 >> 29 != 2 && v8 >> 29 != 6 )
      return (float)((double)(v9 >> 23) * 0.01745329238474369 * 0.5);
    sub_10026050(a1, (int)&v6);
    sub_10068110((int)&v6, (int)&v5);
    sub_10027850((int)&v5, &v4);
  }
  return v4;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (10027920) --------------------------------------------------------
char *__cdecl sub_10027920(unsigned __int8 a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *result; // eax@1
  signed int v4; // ebp@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // esi@2
  char v8; // cl@4
  int v9; // ecx@8
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@1
  char v12[28]; // [sp+18h] [bp-20h]@2

  v2 = dword_10A09240[3 * a1];
  result = (char *)(12 * a1);
  v4 = *(_DWORD *)&result[(_DWORD)dword_10A09248];
  v5 = v1;
  v6 = *(_WORD *)&result[(_DWORD)word_10A09244];
  v11 = v1;
  if ( v4 > 0 )
  {
    v7 = v1 - (_DWORD)v12;
    v10 = *(_DWORD *)&result[(_DWORD)dword_10A09248];
    do
    {
      (*(void (__cdecl **)(int, int, char *))dword_10A09214)(v2, v6, v12);
      v12[v6] = 0;
      result = v12;
      do
      {
        v8 = *result;
        result[v7] = *result;
        ++result;
      }
      while ( v8 );
      v2 += v6;
      v7 += 25;
      --v10;
    }
    while ( v10 );
    v5 = v11;
  }
  if ( v4 < 64 )
  {
    result = (char *)(v5 + 25 * v4);
    v9 = 64 - v4;
    do
    {
      *result = 0;
      result += 25;
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09240: using guessed type int dword_10A09240[];
// 10A09244: using guessed type __int16 word_10A09244[];
// 10A09248: using guessed type int dword_10A09248[];
// 10027920: using guessed type char var_20[28];

//----- (100279E0) --------------------------------------------------------
signed int sub_100279E0()
{
  signed int result; // eax@1

  result = 0xFFFFFF;
  byte_10A09218 = 0;
  dword_10A0921C = 0xFFFFFF;
  byte_10A09208 = 0;
  dword_10A0920C = 0xFFFFFF;
  return result;
}
// 10A09208: using guessed type char byte_10A09208;
// 10A0920C: using guessed type int dword_10A0920C;
// 10A09218: using guessed type char byte_10A09218;
// 10A0921C: using guessed type int dword_10A0921C;

//----- (10027A00) --------------------------------------------------------
int sub_10027A00()
{
  int result; // eax@1

  result = (*(int (**)(void))(dword_10A09214 + 16))();
  byte_10A09210 = (_BYTE)result == 0;
  return result;
}
// 10A09210: using guessed type char byte_10A09210;
// 10A09214: using guessed type int dword_10A09214;

//----- (10027A60) --------------------------------------------------------
int sub_10027A60()
{
  int result; // eax@1

  *(_DWORD *)(dword_10A09A90 + 20812) = 1000;
  *(_DWORD *)(dword_10A09A90 + 20816) = dword_10A092A8 + *(_DWORD *)(dword_10A09A90 + 20812);
  *(_DWORD *)(dword_10A09A90 + 20820) = dword_10A09308 + *(_DWORD *)(dword_10A09A90 + 20816);
  *(_DWORD *)(dword_10A09A90 + 20824) = dword_10A09338 + *(_DWORD *)(dword_10A09A90 + 20820);
  result = dword_10A09A90;
  *(_DWORD *)(dword_10A09A90 + 20828) = dword_10A09380 + *(_DWORD *)(dword_10A09A90 + 20824);
  return result;
}
// 10A092A8: using guessed type int dword_10A092A8;
// 10A09308: using guessed type int dword_10A09308;
// 10A09338: using guessed type int dword_10A09338;
// 10A09380: using guessed type int dword_10A09380;
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10027AD0) --------------------------------------------------------
char *sub_10027AD0()
{
  sub_10027920(0x40u);
  sub_10027920(0x39u);
  sub_10027920(0x33u);
  sub_10027920(0x31u);
  sub_10027920(0x32u);
  sub_10027920(0x4Eu);
  sub_10027920(0x4Fu);
  sub_10027920(0x3Du);
  sub_10027920(0x3Eu);
  sub_10027920(0x45u);
  return sub_10027920(0x38u);
}
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10027BA0) --------------------------------------------------------
int __cdecl sub_10027BA0(const void *a1)
{
  int result; // eax@1

  qmemcpy(dword_10943540, a1, 0x1Cu);
  dword_10A09214 = (int)dword_10943540;
  dword_10A09A90 = (int)&unk_10943560;
  memset(&unk_10943560, 0, 0x516Cu);
  dword_10943540[5](dword_10A09A90 + 20832, dword_10A09A90 + 20833, dword_10A09A90 + 20836);
  (*(void (__cdecl **)(int))(dword_10A09214 + 24))(dword_10A09A90 + 20840);
  sub_100428C0();
  sub_10042390();
  sub_10042700();
  sub_10042460();
  sub_10027AD0();
  sub_100279E0();
  sub_10028820();
  sub_100274F0();
  sub_10027A00();
  sub_10027A60();
  *(_DWORD *)(dword_10A09A90 + 20800) = 0;
  *(_DWORD *)(dword_10A09A90 + 20804) = dword_10A09428;
  result = dword_10A09A90;
  *(_DWORD *)(dword_10A09A90 + 20808) = dword_10A09434 + *(_DWORD *)(dword_10A09A90 + 20804);
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09428: using guessed type int dword_10A09428;
// 10A09434: using guessed type int dword_10A09434;
// 10A09A90: using guessed type int dword_10A09A90;

//----- (10027C50) --------------------------------------------------------
signed int __cdecl sub_10027C50(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    switch ( *(_BYTE *)a1 )
    {
      case 0:
      case 0x10:
        result = *(_DWORD *)(a1 + 40);
        break;
      case 2:
      case 5:
      case 9:
      case 0x13:
      case 0x16:
        result = *(_DWORD *)(a1 + 44);
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10027CA0) --------------------------------------------------------
float sub_10027CA0()
{
  float v0; // esi@2
  int v1; // edi@2
  float result; // eax@2

  if ( (unsigned __int8)sub_10030C50() )
  {
    sub_10060A60(100, 60000);
    v0 = *(float *)(dword_10A09AA0 + 1144);
    v1 = *(_DWORD *)(dword_10A09AA0 + 1148);
    sub_10060A00(100);
    result = v0;
  }
  else
  {
    result = 6.283185;
  }
  return result;
}
// 10A09AA0: using guessed type int dword_10A09AA0;

//----- (10027D00) --------------------------------------------------------
void __cdecl sub_10027D00(unsigned int a1, char *a2, float *a3, int a4, char a5)
{
  int v5; // eax@1
  int v6; // edx@1
  unsigned int v7; // eax@2
  float *v8; // edi@2
  int v9; // ebp@2
  int v10; // ecx@3
  int v11; // ebx@3
  float *v12; // esi@3
  int v13; // ebx@6
  char v14; // bl@10
  unsigned int v15; // eax@10
  int v16; // eax@11
  float *v17; // ecx@11
  int v18; // edx@11
  int v19; // edi@11
  int v20; // esi@11
  unsigned int v21; // ebp@11
  int v22; // ST30_4@13
  float v23; // ST30_4@13
  float v24; // ST30_4@13
  int v25; // ST30_4@15
  float v26; // ST30_4@15
  float v27; // ST30_4@15
  int v28; // ST30_4@17
  float v29; // ST30_4@17
  float v30; // ST30_4@17
  int v31; // ST30_4@19
  float v32; // ST30_4@19
  float v33; // ST30_4@19
  float *v34; // edx@23
  int v35; // ecx@23
  int v36; // ST30_4@25
  float v37; // ST30_4@25
  float v38; // ST30_4@25
  unsigned int v39; // [sp+8h] [bp-38h]@9
  int v40; // [sp+Ch] [bp-34h]@23
  unsigned int v41; // [sp+10h] [bp-30h]@11
  int v42; // [sp+10h] [bp-30h]@23
  unsigned int v43; // [sp+14h] [bp-2Ch]@3
  int v44; // [sp+14h] [bp-2Ch]@11
  int v45; // [sp+14h] [bp-2Ch]@23
  int v46; // [sp+18h] [bp-28h]@1
  int v47; // [sp+1Ch] [bp-24h]@1
  char v48; // [sp+20h] [bp-20h]@6
  char v49; // [sp+30h] [bp-10h]@2

  sub_10027CA0();
  v46 = v5;
  v47 = v6;
  if ( sub_10043B50((int)&v46, (int)&unk_100A9D70) )
  {
    sub_10068240((int)&v46, (int)&v49);
    v7 = a1;
    v8 = a3;
    v9 = a4;
    if ( a1 )
    {
      v10 = (int)&a2[-a4];
      v11 = a4 - (_DWORD)a3;
      v12 = a3;
      v43 = a1;
      do
      {
        if ( !a5 || *v12 >= 9.8999998e24 )
        {
          v13 = (int)v12 + v11;
          sub_10026170(0, *(_DWORD *)(v13 + v10), (double *)&v48);
          sub_10060410((int)&v49, (int)&v48, 1, v12, v13);
          v10 = (int)&a2[-a4];
          v11 = a4 - (_DWORD)a3;
        }
        ++v12;
        --v43;
      }
      while ( v43 );
      v7 = a1;
    }
    v39 = v7;
    do
    {
      v14 = 0;
      v15 = 1;
      if ( (signed int)(v39 - 1) >= 4 )
      {
        v44 = a2 - (char *)v8;
        v16 = v9 - (_DWORD)v8;
        v17 = v8;
        v18 = v9 + 8;
        v19 = (int)&a2[-v9];
        v20 = (int)(a2 + 12);
        v21 = ((v39 - 5) >> 2) + 1;
        v41 = v21;
        v46 = 4 * v21 + 1;
        do
        {
          if ( *v17 > (double)v17[1] )
          {
            v22 = *(_DWORD *)((char *)v17 + v44);
            *(float *)((char *)v17 + v44) = *(float *)(v20 - 8);
            v21 = v41;
            *(_DWORD *)(v20 - 8) = v22;
            v23 = *v17;
            v14 = 1;
            *v17 = v17[1];
            v17[1] = v23;
            v24 = *(float *)((char *)v17 + v16);
            *(float *)((char *)v17 + v16) = *(float *)(v18 - 4);
            *(float *)(v18 - 4) = v24;
          }
          if ( v17[1] > (double)v17[2] )
          {
            v25 = *(_DWORD *)(v20 - 8);
            *(_DWORD *)(v20 - 8) = *(_DWORD *)(v18 + v19);
            *(_DWORD *)(v18 + v19) = v25;
            v26 = v17[1];
            v14 = 1;
            v17[1] = v17[2];
            v17[2] = v26;
            v27 = *(float *)(v18 - 4);
            *(float *)(v18 - 4) = *(float *)v18;
            *(float *)v18 = v27;
          }
          if ( v17[2] > (double)v17[3] )
          {
            v28 = *(_DWORD *)(v18 + v19);
            *(_DWORD *)(v18 + v19) = *(_DWORD *)v20;
            *(_DWORD *)v20 = v28;
            v29 = v17[2];
            v14 = 1;
            v17[2] = v17[3];
            v17[3] = v29;
            v30 = *(float *)v18;
            *(float *)v18 = *(float *)(v18 + 4);
            *(float *)(v18 + 4) = v30;
          }
          if ( v17[3] > (double)v17[4] )
          {
            v31 = *(_DWORD *)v20;
            *(_DWORD *)v20 = *(_DWORD *)(v20 + 4);
            *(_DWORD *)(v20 + 4) = v31;
            v32 = v17[3];
            v14 = 1;
            v17[3] = v17[4];
            v17[4] = v32;
            v33 = *(float *)(v18 + 4);
            *(float *)(v18 + 4) = *(float *)(v18 + 8);
            *(float *)(v18 + 8) = v33;
          }
          v17 += 4;
          v18 += 16;
          v20 += 16;
          v41 = --v21;
        }
        while ( v21 );
        v9 = a4;
        v8 = a3;
        v15 = v46;
      }
      if ( v15 < v39 )
      {
        v45 = a2 - (char *)v8;
        v40 = v9 - (_DWORD)v8;
        v42 = (int)&a2[-v9];
        v34 = (float *)(v9 + 4 * v15);
        v35 = (int)&v8[v15 - 1];
        v46 = v39 - v15;
        do
        {
          if ( *(float *)v35 > (double)*(float *)(v35 + 4) )
          {
            v36 = *(_DWORD *)(v45 + v35);
            *(float *)(v45 + v35) = *(float *)((char *)v34 + v42);
            *(_DWORD *)((char *)v34 + v42) = v36;
            v37 = *(float *)v35;
            v14 = 1;
            *(float *)v35 = *(float *)(v35 + 4);
            *(float *)(v35 + 4) = v37;
            v38 = *(float *)(v40 + v35);
            *(float *)(v40 + v35) = *v34;
            *v34 = v38;
          }
          v35 += 4;
          ++v34;
          --v46;
        }
        while ( v46 );
      }
      --v39;
    }
    while ( v14 );
  }
  else if ( a1 )
  {
    memset32(a2, 0x3FFFF, a1);
  }
}

//----- (10028040) --------------------------------------------------------
void __cdecl sub_10028040(signed int a1, char *a2)
{
  unsigned int v2; // eax@1
  char v3; // [sp+0h] [bp-F8h]@5
  char v4; // [sp+7Ch] [bp-7Ch]@5

  v2 = a1;
  if ( a1 <= 31 )
  {
    if ( a1 < 0 )
      v2 = 0;
  }
  else
  {
    v2 = 31;
  }
  sub_10027D00(v2, a2, (float *)&v4, (int)&v3, 0);
}

//----- (10028090) --------------------------------------------------------
int __cdecl sub_10028090(int a1)
{
  int result; // eax@1
  char v2; // al@2
  signed int v3; // ebp@2
  signed int v4; // edi@2
  unsigned __int8 v5; // cl@4
  char v6; // cl@16
  signed int v7; // edi@18
  char v8; // al@19
  char v9; // cl@27
  char v10; // dl@27
  char v11; // al@27
  char v12; // dl@28
  char v13; // cl@28
  char v14; // al@29
  char v15; // cl@29
  char v16; // dl@29
  __int32 v17; // esi@33
  int v18; // esi@33
  char v19; // [sp+8h] [bp-10h]@20
  char v20; // [sp+9h] [bp-Fh]@27
  char v21; // [sp+Ah] [bp-Eh]@28
  char v22; // [sp+Bh] [bp-Dh]@24
  char v23; // [sp+Ch] [bp-Ch]@20
  char v24; // [sp+Dh] [bp-Bh]@28
  char v25; // [sp+Eh] [bp-Ah]@29
  char v26; // [sp+Fh] [bp-9h]@28
  char v27; // [sp+10h] [bp-8h]@28

  result = 0x3FFFF;
  if ( *(_BYTE *)(dword_10A09A90 + 20840) )
  {
    v2 = 1;
    v3 = 5;
    v4 = 0;
    while ( v2 )
    {
      v5 = *(_BYTE *)(a1 + v4);
      switch ( *(_BYTE *)(a1 + v4) )
      {
        case 0x45:
        case 0x4E:
        case 0x53:
        case 0x57:
          if ( v4 == 3 || v3 != 5 )
            goto LABEL_11;
          v3 = v4;
          break;
        default:
          if ( v5 < 0x30u || v5 > 0x39u )
LABEL_11:
            v2 = 0;
          else
            v2 = 1;
          break;
      }
      if ( ++v4 >= 5 )
      {
        if ( !v2 || v3 == 5 || *(_BYTE *)(a1 + v4) )
          break;
        v6 = *(_BYTE *)(a1 + v3);
        if ( v6 == 69 )
        {
          v8 = 43;
          v7 = 1;
LABEL_23:
          v23 = v8;
          v19 = v8;
        }
        else if ( v6 == 78 )
        {
          v19 = 43;
          v23 = 45;
          v7 = 1;
        }
        else
        {
          v7 = -1;
          if ( v6 != 83 )
          {
            v8 = 45;
            goto LABEL_23;
          }
          v19 = 45;
          v23 = 43;
        }
        v22 = 0;
        if ( v3 )
        {
          if ( v3 == 1 )
          {
            v14 = *(_BYTE *)(a1 + 2);
            v15 = *(_BYTE *)(a1 + 3);
            v20 = *(_BYTE *)a1;
            v16 = *(_BYTE *)(a1 + 4);
            v21 = v14;
            v24 = 49;
            v25 = v15;
            v26 = v16;
            v27 = 0;
          }
          else
          {
            v7 = 0;
            if ( v3 != 2 )
            {
              v9 = *(_BYTE *)(a1 + 1);
              v10 = *(_BYTE *)(a1 + 2);
              v20 = *(_BYTE *)a1;
              v11 = *(_BYTE *)(a1 + 3);
              goto LABEL_31;
            }
            v12 = *(_BYTE *)(a1 + 1);
            v11 = *(_BYTE *)(a1 + 3);
            v20 = *(_BYTE *)a1;
            v13 = *(_BYTE *)(a1 + 4);
            v21 = v12;
            v24 = 49;
            v26 = v13;
            v27 = 0;
LABEL_32:
            v25 = v11;
          }
          v17 = (v7 + 2 * j_j__atol(&v19) + 180) & 0x1FF | 0x3FE00;
          v18 = (v17 ^ ((unsigned __int16)(j_j__atol(&v23) + 180) << 9)) & 0x3FE00 ^ v17;
          if ( (v18 & 0x1FFu) <= 0x168 && (v18 & 0x3FE00u) <= 0x2D000 )
            return v18 & 0x3FFFFFF | 0x30000000;
          break;
        }
        v9 = *(_BYTE *)(a1 + 2);
        v10 = *(_BYTE *)(a1 + 3);
        v20 = *(_BYTE *)(a1 + 1);
        v11 = *(_BYTE *)(a1 + 4);
LABEL_31:
        v26 = 0;
        v24 = v10;
        v21 = v9;
        goto LABEL_32;
      }
    }
    result = 0x3FFFF;
  }
  return result;
}
// 10A09A90: using guessed type int dword_10A09A90;

//----- (100282C0) --------------------------------------------------------
void __cdecl sub_100282C0(unsigned int a1, int a2)
{
  unsigned int v2; // ebx@3
  unsigned int v3; // ebp@4
  unsigned int v4; // eax@5
  int v5; // ecx@5
  int v6; // eax@6
  char v7; // dl@10
  char v8; // cl@10
  char v9; // al@10
  char v10; // cl@11
  char v11; // dl@11
  char v12; // dl@13
  char v13; // cl@13
  char v14; // al@13
  char v15; // cl@14
  char v16; // dl@14
  char v17; // cl@14
  char v18; // [sp+4h] [bp-10h]@5
  char v19; // [sp+5h] [bp-Fh]@10
  char v20; // [sp+6h] [bp-Eh]@10
  char v21; // [sp+8h] [bp-Ch]@5
  char v22; // [sp+Ah] [bp-Ah]@10
  char v23; // [sp+Bh] [bp-9h]@10

  if ( a2 )
  {
    if ( (a1 & 0xFC000000) != 805306368 || (v2 = a1 & 0x1FF, v2 > 0x168) || (v3 = (a1 >> 9) & 0x1FF, v3 > 0x168) )
    {
      *(_DWORD *)a2 = *(_DWORD *)"______";
      *(_WORD *)(a2 + 4) = *(_WORD *)"__";
      *(_BYTE *)(a2 + 6) = a______[6];
    }
    else
    {
      sub_1002C2B0(&v18, 4u, "%+03d", (signed int)(v2 - 180) / 2);
      sub_1002C2B0(&v21, 5u, "%+04d", v3 - 180);
      v4 = (v3 - 180) >> 31;
      v5 = (v3 - 180 - v4) ^ ((signed int)(v3 - 180 - v4) >> 31);
      if ( v2 < 0xB4 )
      {
        LOBYTE(v4) = v3 < 0xB4;
        v6 = 4 * v4 + 83;
      }
      else
      {
        LOBYTE(v6) = v3 < 0xB4 ? 78 : 69;
      }
      *(_BYTE *)(a2 + 5) = 0;
      if ( a1 & 1 )
      {
        if ( v5 >= 100 )
        {
          v10 = v22;
          *(_BYTE *)a2 = v19;
          v11 = v23;
          *(_BYTE *)(a2 + 1) = v6;
          *(_BYTE *)(a2 + 2) = v20;
          *(_BYTE *)(a2 + 3) = v10;
          *(_BYTE *)(a2 + 4) = v11;
        }
        else
        {
          v7 = v20;
          *(_BYTE *)(a2 + 1) = v19;
          v8 = v23;
          *(_BYTE *)a2 = v6;
          v9 = v22;
          *(_BYTE *)(a2 + 2) = v7;
          *(_BYTE *)(a2 + 3) = v9;
          *(_BYTE *)(a2 + 4) = v8;
        }
      }
      else if ( v5 < 100 )
      {
        v15 = v20;
        *(_BYTE *)a2 = v19;
        v16 = v22;
        *(_BYTE *)(a2 + 1) = v15;
        v17 = v23;
        *(_BYTE *)(a2 + 2) = v16;
        *(_BYTE *)(a2 + 3) = v17;
        *(_BYTE *)(a2 + 4) = v6;
      }
      else
      {
        v12 = v20;
        *(_BYTE *)a2 = v19;
        v13 = v23;
        *(_BYTE *)(a2 + 2) = v6;
        v14 = v22;
        *(_BYTE *)(a2 + 1) = v12;
        *(_BYTE *)(a2 + 3) = v14;
        *(_BYTE *)(a2 + 4) = v13;
      }
    }
  }
}

//----- (100284A0) --------------------------------------------------------
char __cdecl sub_100284A0(unsigned int a1, int a2)
{
  char result; // al@1
  unsigned int v3; // edx@3
  unsigned int v4; // ecx@4

  result = 0;
  if ( a2 )
  {
    if ( (a1 & 0xFC000000) == 805306368 )
    {
      v3 = a1 & 0x1FF;
      if ( v3 <= 0x168 )
      {
        v4 = (a1 >> 9) & 0x1FF;
        if ( v4 <= 0x168 )
        {
          *(_DWORD *)a2 = (signed int)(11930464 * (v3 - 180)) / 2;
          *(_DWORD *)(a2 + 4) = 11930464 * (v4 - 180);
          result = 1;
        }
      }
    }
  }
  return result;
}

//----- (10028510) --------------------------------------------------------
int __cdecl sub_10028510(_BYTE *a1, _BYTE *a2)
{
  int result; // eax@1

  result = sub_10042CB0(0x2Bu);
  *a1 = result;
  if ( (_BYTE)result )
  {
    result = (int)a2;
    *a2 = 1;
  }
  else
  {
    *a2 = 0;
    *a1 = 1;
  }
  return result;
}

//----- (10028540) --------------------------------------------------------
int sub_10028540()
{
  return (*(int (**)(void))(dword_10A09214 + 8))();
}
// 10A09214: using guessed type int dword_10A09214;

//----- (10028550) --------------------------------------------------------
int __fastcall sub_10028550(unsigned __int8 a1)
{
  return dword_10A09444 + a1 * (unsigned __int16)word_10A09448;
}
// 10A09444: using guessed type int dword_10A09444;
// 10A09448: using guessed type __int16 word_10A09448;

//----- (10028570) --------------------------------------------------------
int __fastcall sub_10028570(unsigned __int8 a1)
{
  return dword_10A09450 + a1 * (unsigned __int16)word_10A09454;
}
// 10A09450: using guessed type int dword_10A09450;
// 10A09454: using guessed type __int16 word_10A09454;

//----- (10028590) --------------------------------------------------------
void *__cdecl sub_10028590(char a1, void *a2)
{
  void *result; // eax@2
  int v3; // eax@4
  int v4; // eax@4
  char v5; // [sp+6h] [bp-1Eh]@1
  unsigned __int8 v6; // [sp+7h] [bp-1Dh]@1
  char v7; // [sp+8h] [bp-1Ch]@4
  char v8; // [sp+16h] [bp-Eh]@4

  sub_10028510(&v6, &v5);
  if ( (unsigned __int8)a1 < v6 )
  {
    if ( v5 )
    {
      v3 = sub_10028550(a1);
      v4 = (*(int (__cdecl **)(int, signed int, char *))dword_10A09214)(v3, 22, &v7);
      result = (void *)sub_100424C0(v4, &v8, 20, (int)a2);
      *((_BYTE *)a2 + 20) = 0;
    }
    else
    {
      result = memcpy_0(a2, &aWgs84[21 * (unsigned __int8)a1], 0x14u);
      *((_BYTE *)a2 + 20) = 0;
    }
  }
  else
  {
    result = (void *)1600085855;
    *(_DWORD *)a2 = 1600085855;
    *((_DWORD *)a2 + 1) = 1600085855;
    *((_DWORD *)a2 + 2) = 1600085855;
    *((_DWORD *)a2 + 3) = 1600085855;
    *((_DWORD *)a2 + 4) = 1600085855;
    *((_BYTE *)a2 + 20) = 0;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (10028660) --------------------------------------------------------
int __cdecl sub_10028660(int a1)
{
  bool v1; // zf@1
  int v2; // eax@2
  signed int v3; // eax@2
  float v4; // ST24_4@2
  unsigned __int8 v5; // cl@2
  int v6; // eax@2
  char v7; // al@2
  char v8; // cl@2
  float v9; // ST24_4@3
  double v10; // st6@3
  float v11; // ST24_4@3
  float v12; // ST24_4@3
  double v13; // st7@3
  float v14; // ST24_4@3
  float v16; // [sp+10h] [bp-34h]@2
  char v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+15h] [bp-2Fh]@2
  char v19; // [sp+16h] [bp-2Eh]@2
  char v20; // [sp+17h] [bp-2Dh]@2
  char v21; // [sp+26h] [bp-1Eh]@2
  char v22; // [sp+28h] [bp-1Ch]@2
  char v23; // [sp+36h] [bp-Eh]@2
  unsigned __int8 v24; // [sp+37h] [bp-Dh]@2
  __int16 v25; // [sp+38h] [bp-Ch]@2
  __int16 v26; // [sp+3Ah] [bp-Ah]@2
  __int16 v27; // [sp+3Ch] [bp-8h]@2

  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 36) = 6378137.0;
  *(float *)(a1 + 40) = 0.0033528106;
  *(_BYTE *)(a1 + 56) = 0;
  memcpy_0((void *)(a1 + 1), "WGS 84              ", 0x15u);
  v1 = *(_BYTE *)(a1 + 81) == 0;
  *(_BYTE *)(a1 + 80) = 1;
  if ( !v1 )
  {
    v2 = sub_10028550(*(_BYTE *)a1);
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(v2, 22, &v22);
    sub_100424C0((int)&v23, &v23, 20, a1 + 1);
    v3 = v27;
    LODWORD(v4) = v26;
    v5 = v24;
    *(float *)(a1 + 24) = (double)v25;
    *(_BYTE *)(a1 + 21) = 0;
    *(float *)(a1 + 28) = (double)SLODWORD(v4);
    *(float *)(a1 + 32) = (double)v3;
    v6 = sub_10028570(v5);
    (*(void (__cdecl **)(int, signed int, float *))dword_10A09214)(v6, 23, &v16);
    v7 = v18;
    v8 = v19;
    LOBYTE(v4) = v17;
    *(float *)(a1 + 36) = v16;
    BYTE1(v4) = v7;
    BYTE2(v4) = v8;
    BYTE3(v4) = v20;
    *(float *)(a1 + 40) = v4;
    sub_100424C0((int)&v21, &v21, 20, a1 + 56);
    *(_BYTE *)(a1 + 76) = 0;
  }
  *(float *)(a1 + 44) = *(float *)(a1 + 40) + *(float *)(a1 + 40) - *(float *)(a1 + 40) * *(float *)(a1 + 40);
  v9 = *(float *)(a1 + 36) - 6378137.0;
  v10 = v9;
  *(float *)(a1 + 48) = v9;
  v11 = *(float *)(a1 + 40) - 0.003352810628712177;
  v12 = 6378137.0 * v11;
  v13 = v12;
  v14 = v10 * 0.00335281066474748;
  *(float *)(a1 + 52) = v13 + v14;
  return (*(int (__cdecl **)(int))(dword_10A09214 + 12))(a1);
}
// 10A09214: using guessed type int dword_10A09214;

//----- (10028820) --------------------------------------------------------
char sub_10028820()
{
  int v0; // eax@1
  unsigned __int8 v1; // bl@1
  char v2; // al@7
  unsigned __int8 v3; // bl@10
  unsigned __int8 v5; // [sp+6h] [bp-76h]@1
  unsigned __int8 v6; // [sp+7h] [bp-75h]@1
  char v7[4]; // [sp+8h] [bp-74h]@1
  char v8; // [sp+Ch] [bp-70h]@10
  unsigned __int8 v9; // [sp+5Ch] [bp-20h]@5
  char v10; // [sp+5Dh] [bp-1Fh]@8
  char v11; // [sp+5Eh] [bp-1Eh]@6
  char v12; // [sp+60h] [bp-1Ch]@2

  sub_10028540();
  sub_10028510(&v6, &v5);
  LOBYTE(v0) = v6;
  v1 = 0;
  v5 = v6;
  v7[0] = 0;
  if ( v6 )
  {
    do
    {
      sub_10028590(v7[0], &v12);
      v0 = strcmp(&v12, "WGS 84              ");
      if ( !v0 )
        v5 = v1;
      v7[0] = ++v1;
    }
    while ( v1 < v6 );
  }
  if ( !v9 || v5 != v11 )
  {
    v2 = sub_10042CB0(0x2Bu);
    v9 = v2;
    if ( v2 )
    {
      v10 = 1;
    }
    else
    {
      v2 = 1;
      v10 = 0;
      v9 = 1;
    }
    v3 = 0;
    v8 = v2;
    v11 = v2;
    v7[0] = 0;
    if ( v2 )
    {
      do
      {
        sub_10028590(v7[0], &v12);
        if ( !strcmp(&v12, "WGS 84              ") )
        {
          v11 = v3;
          v8 = v3;
        }
        v7[0] = ++v3;
      }
      while ( v3 < v9 );
    }
    LOBYTE(v0) = sub_10028660((int)&v8);
  }
  return v0;
}

//----- (10028980) --------------------------------------------------------
char *__cdecl sub_10028980(int a1, char *a2, int a3, char *a4, int a5)
{
  char *v5; // edi@1
  char *result; // eax@4
  char v7[4]; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v5 = a2;
  *(_DWORD *)v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  *(_DWORD *)(a5 + 16) = sub_10060830();
  *(_DWORD *)(a5 + 596) = sub_10060900();
  sub_10060920((int)v7, 1, *(_DWORD *)(a5 + 16), 40);
  *(_WORD *)(a5 + 594) = 0x7FFF;
  sub_1002C120(a5 + 585, "14.01", 8);
  *(_DWORD *)a5 = a1;
  sub_10032600((char *)(a5 + 4));
  *(_DWORD *)(a5 + 460) = a3;
  if ( strrchr(a2, 92) )
    v5 = strrchr(a2, 92) + 1;
  strncpy((char *)(a5 + 464), v5, 0x14u);
  *(_BYTE *)(a5 + 484) = 0;
  if ( a4 )
  {
    result = strncpy((char *)(a5 + 485), a4, 0x63u);
    *(_BYTE *)(a5 + 584) = 0;
  }
  else
  {
    result = strncpy((char *)(a5 + 485), v7, 0x64u);
  }
  return result;
}

//----- (10028AB0) --------------------------------------------------------
char sub_10028AB0()
{
  char result; // al@1

  result = 0;
  byte_1094DCC0 = 0;
  byte_1094DCC1 = 0;
  return result;
}
// 1094DCC0: using guessed type char byte_1094DCC0;
// 1094DCC1: using guessed type char byte_1094DCC1;

//----- (10028AC0) --------------------------------------------------------
char __cdecl sub_10028AC0(char *a1, int a2, char a3, char *a4, int a5)
{
  char result; // al@7
  char v6; // [sp+Bh] [bp-2Dh]@4
  int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1
  int v15; // [sp+2Ch] [bp-Ch]@1
  int v16; // [sp+30h] [bp-8h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a3 & 3 )
    sub_10028980(-5, a1, a2, a4, a5);
  else
    sub_10028980(-44, a1, a2, a4, a5);
  v6 = a3 & 8;
  if ( a3 & 8 )
    sub_1002C2E0((const char *)(a5 + 485), " DBGA", 100);
  sub_10060920((int)&v7, 0, 0, 40);
  if ( a3 & 3 )
  {
    result = a3 & 8;
    if ( v6 )
    {
      if ( byte_1094DCC0 )
        return result;
      if ( v6 )
        goto LABEL_15;
    }
    if ( !byte_1094DCC1 )
LABEL_15:
      result = sub_100609B0(36, 1, *(_DWORD *)a5, a5);
  }
  else
  {
    result = j_HWM_pvg_log_err(a5);
  }
  return result;
}
// 10061660: using guessed type int __cdecl j_HWM_pvg_log_err(_DWORD);
// 1094DCC0: using guessed type char byte_1094DCC0;
// 1094DCC1: using guessed type char byte_1094DCC1;

//----- (10028BC0) --------------------------------------------------------
char __cdecl sub_10028BC0(char *a1, int a2, char a3, char *a4)
{
  int v5; // [sp+8h] [bp-284h]@1

  memset(&v5, 0, 0x280u);
  return sub_10028AC0(a1, a2, a3, a4, (int)&v5);
}

//----- (10028C30) --------------------------------------------------------
int sub_10028C30()
{
  __int16 v1; // [sp+0h] [bp-3Ch]@1

  v1 = -32754;
  return sub_10060AC0(49, (int)&v1, 500, 1);
}

//----- (10028C70) --------------------------------------------------------
int __cdecl sub_10028C70(__int16 a1)
{
  __int16 v2; // [sp+0h] [bp-3Ch]@1
  __int16 v3; // [sp+6h] [bp-36h]@1

  v2 = -32751;
  v3 = a1;
  return sub_10060AC0(49, (int)&v2, 500, 1);
}

//----- (10028CC0) --------------------------------------------------------
int __cdecl sub_10028CC0(char a1, __int16 a2, char *a3)
{
  __int16 v4; // [sp+0h] [bp-3Ch]@1
  char v5; // [sp+8h] [bp-34h]@1
  __int16 v6; // [sp+Ah] [bp-32h]@1
  char v7; // [sp+Ch] [bp-30h]@1

  v4 = -32753;
  v7 = 0;
  v5 = a1;
  v6 = a2;
  if ( a3 && *a3 )
    strncpy(&v7, a3, 0x28u);
  return sub_10060AC0(49, (int)&v4, 500, 1);
}

//----- (10028D30) --------------------------------------------------------
int __cdecl sub_10028D30(char a1, __int16 a2, char a3)
{
  __int16 v4; // [sp+0h] [bp-3Ch]@1
  __int16 v5; // [sp+4h] [bp-38h]@1
  char v6; // [sp+6h] [bp-36h]@1
  char v7; // [sp+7h] [bp-35h]@1

  memset(&v4, 0, 0x38u);
  v6 = a1;
  v4 = -32744;
  v5 = a2;
  v7 = a3;
  return sub_10060AC0(49, (int)&v4, 0, 1);
}

//----- (10028D90) --------------------------------------------------------
int __cdecl sub_10028D90(char a1, __int16 a2, char a3)
{
  __int16 v4; // [sp+0h] [bp-3Ch]@1
  __int16 v5; // [sp+4h] [bp-38h]@1
  char v6; // [sp+6h] [bp-36h]@1
  char v7; // [sp+7h] [bp-35h]@1

  memset(&v4, 0, 0x38u);
  v6 = a1;
  v4 = -32743;
  v5 = a2;
  v7 = a3;
  return sub_10060AC0(49, (int)&v4, 0, 1);
}

//----- (10028DF0) --------------------------------------------------------
int __usercall sub_10028DF0@<eax>(int a1@<edx>, int a2@<ecx>, int a3)
{
  int result; // eax@4
  int v4; // [sp+0h] [bp-20h]@1
  int v5; // [sp+4h] [bp-1Ch]@1
  int v6; // [sp+8h] [bp-18h]@1
  int v7; // [sp+Ch] [bp-14h]@1
  int v8; // [sp+10h] [bp-10h]@1
  int *v9; // [sp+14h] [bp-Ch]@1
  int v10; // [sp+18h] [bp-8h]@1
  int v11; // [sp+1Ch] [bp-4h]@1

  v6 = 0;
  v11 = a2 != 0 ? 4 : 1;
  v4 = a2;
  v7 = a1;
  v8 = 56;
  v9 = &v4;
  v10 = 500;
  v5 = a3;
  if ( sub_10060830() == 37 )
    v10 = 0;
  if ( sub_10060AF0(49, (int)&v7) )
  {
    sub_10028BC0("..\\lib\\adl\\mon_log_intf.c", 1267, 0, 0);
    result = 0;
  }
  else
  {
    result = (unsigned __int8)v6;
  }
  return result;
}

//----- (10028EA0) --------------------------------------------------------
int __cdecl sub_10028EA0(unsigned __int8 a1)
{
  __int16 v2; // [sp+0h] [bp-3Ch]@1
  __int16 v3; // [sp+4h] [bp-38h]@1

  v2 = -32766;
  v3 = a1;
  return sub_10028DF0((int)&v2, 0, 0);
}

//----- (10028EE0) --------------------------------------------------------
int __cdecl sub_10028EE0(char a1, __int16 a2, _BYTE *a3, char a4)
{
  __int16 v5; // [sp+0h] [bp-3Ch]@1
  char v6; // [sp+8h] [bp-34h]@1
  __int16 v7; // [sp+Ah] [bp-32h]@1
  char v8; // [sp+Ch] [bp-30h]@1
  char v9; // [sp+35h] [bp-7h]@1

  v5 = -32749;
  sub_1002C120((int)&v8, a3, 41);
  v6 = a1;
  v7 = a2;
  v9 = a4;
  return sub_10028DF0((int)&v5, 0, 0);
}

//----- (10028F40) --------------------------------------------------------
void sub_10028F40()
{
  dword_10A09AD0 = -15;
}
// 10A09AD0: using guessed type int dword_10A09AD0;

//----- (10028F50) --------------------------------------------------------
signed int sub_10028F50()
{
  signed int result; // eax@1

  result = -15;
  dword_10A09ACC = -15;
  dword_10A09AC8 = -15;
  return result;
}
// 10A09AC8: using guessed type int dword_10A09AC8;
// 10A09ACC: using guessed type int dword_10A09ACC;

//----- (10028F60) --------------------------------------------------------
signed int sub_10028F60()
{
  return sub_10061AA0((int)&off_100ADBA8);
}
// 100ADBA8: using guessed type char *off_100ADBA8;

//----- (10028F70) --------------------------------------------------------
signed int sub_10028F70()
{
  return sub_10061AA0((int)&off_100ADBBC);
}
// 100ADBBC: using guessed type char *off_100ADBBC;

//----- (10028F80) --------------------------------------------------------
char __cdecl sub_10028F80(char a1, int a2, void *a3)
{
  char v3; // bl@1
  const void *v5; // edx@7

  v3 = 0;
  if ( !a1 )
  {
    if ( !(unsigned __int8)sub_10028F60() || (unsigned int)a2 >= 0xA )
      return v3;
    v5 = (const void *)(6916 * a2 + dword_10A09ACC + 136004);
    goto LABEL_14;
  }
  if ( a1 == 1 )
  {
    if ( !(unsigned __int8)sub_10028F70() || (unsigned int)a2 >= 0xA )
      return v3;
    v5 = (const void *)(6916 * a2 + dword_10A09AC8 + 136044);
    goto LABEL_14;
  }
  if ( a1 != 2 )
    return 0;
  if ( (unsigned __int8)sub_10028F70() && (unsigned int)a2 < 0xA )
  {
    v5 = (const void *)(6916 * a2 + dword_10A09AC8 + 237208);
LABEL_14:
    v3 = 1;
    memcpy(a3, v5, 0x1B04u);
  }
  return v3;
}
// 10A09AC8: using guessed type int dword_10A09AC8;
// 10A09ACC: using guessed type int dword_10A09ACC;

//----- (10029030) --------------------------------------------------------
BOOL __cdecl sub_10029030(unsigned int a1)
{
  int v1; // edi@1
  __int16 i; // si@1
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = sub_10060900();
  for ( i = sub_10061CC0(6, 0, 1, (int)&v4); i == 12; i = sub_10061CC0(6, 0, 1, (int)&v4) )
  {
    if ( sub_10060900() - v1 >= a1 )
      break;
    sub_10060B90(100);
  }
  return i == 12;
}

//----- (100290A0) --------------------------------------------------------
char __thiscall sub_100290A0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10061C40(81, (_BYTE *)&v2 + 3);
  return BYTE3(v2);
}

//----- (100290C0) --------------------------------------------------------
void __cdecl sub_100290C0(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  sub_10061C40(120, a1);
  sub_10061C40(124, a2);
  sub_10061C40(121, a3);
}

//----- (100290F0) --------------------------------------------------------
int __cdecl sub_100290F0(int a1)
{
  return sub_10060D80(3025, a1, 84);
}

//----- (10029110) --------------------------------------------------------
signed int sub_10029110()
{
  bool v0; // zf@1
  signed int result; // eax@1
  char v2; // [sp+3h] [bp-5h]@1
  int v3; // [sp+4h] [bp-4h]@1

  v0 = sub_10061D00(6, &v3, &v2) == 0;
  result = -4;
  if ( v0 )
    result = v3;
  return result;
}

//----- (10029140) --------------------------------------------------------
void __cdecl sub_10029140(_BYTE *a1)
{
  sub_10061C40(129, a1);
}

//----- (10029160) --------------------------------------------------------
char __cdecl sub_10029160(int a1, size_t a2, void *a3)
{
  char result; // al@2

  if ( sub_10061CC0(6, a1, a2, (int)a3) )
  {
    memset(a3, 0, a2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100291A0) --------------------------------------------------------
int __cdecl sub_100291A0(int a1)
{
  return sub_10060ED0(3025, a1, 84);
}

//----- (100291C0) --------------------------------------------------------
char __fastcall sub_100291C0(int *a1)
{
  char v1; // bl@1
  unsigned int v2; // eax@7
  int *v3; // edx@7
  int v4; // esi@11
  int v5; // eax@12
  _BYTE *v6; // edx@12
  int v7; // eax@14
  _BYTE *v8; // edx@14
  _BYTE *v9; // edx@16
  signed int v10; // eax@18
  char result; // al@25
  char v12; // [sp+4h] [bp-68h]@1
  int v13; // [sp+8h] [bp-64h]@2
  int v14; // [sp+Ch] [bp-60h]@29
  int v15; // [sp+10h] [bp-5Ch]@29
  char v16; // [sp+12h] [bp-5Ah]@3
  char v17; // [sp+13h] [bp-59h]@4
  int v18; // [sp+14h] [bp-58h]@5
  char v19; // [sp+18h] [bp-54h]@6
  int v20; // [sp+1Ch] [bp-50h]@2
  int v21; // [sp+20h] [bp-4Ch]@29
  int v22; // [sp+24h] [bp-48h]@29
  char v23; // [sp+26h] [bp-46h]@3
  char v24; // [sp+27h] [bp-45h]@4
  int v25; // [sp+28h] [bp-44h]@5
  char v26; // [sp+2Ch] [bp-40h]@6
  int v27; // [sp+2Dh] [bp-3Fh]@7
  int v28; // [sp+31h] [bp-3Bh]@29
  int v29; // [sp+35h] [bp-37h]@29
  int v30; // [sp+3Ch] [bp-30h]@2
  int v31; // [sp+40h] [bp-2Ch]@2
  int v32; // [sp+44h] [bp-28h]@2
  int v33; // [sp+48h] [bp-24h]@2
  int v34; // [sp+4Ch] [bp-20h]@2
  int v35; // [sp+50h] [bp-1Ch]@2
  int v36; // [sp+54h] [bp-18h]@2
  char v37; // [sp+58h] [bp-14h]@2
  int v38; // [sp+5Ch] [bp-10h]@2
  int v39; // [sp+60h] [bp-Ch]@29
  int v40; // [sp+64h] [bp-8h]@29

  v1 = 1;
  v12 = 1;
  if ( byte_10A09A94 )
  {
    v1 = 3;
    goto LABEL_24;
  }
  sub_10029160(147, 0xCu, &v38);
  sub_10029160(129, 0x11u, &v13);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  sub_10060E40(2000, &v20, 29, &v30);
  LOWORD(a1) = v20;
  if ( (_WORD)v20 != (_WORD)v13
    || v23 != v16
    || v24 != v17
    || (LOWORD(a1) = v25, v25 != v18)
    || (LOBYTE(a1) = v26, v26 != v19) )
  {
LABEL_22:
    v1 = 2;
LABEL_24:
    v12 = v1;
    goto LABEL_25;
  }
  v2 = 12;
  a1 = &v38;
  v3 = &v27;
  do
  {
    if ( *v3 != *a1 )
      goto LABEL_11;
    v2 -= 4;
    ++a1;
    ++v3;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_20:
    v10 = 0;
    goto LABEL_21;
  }
LABEL_11:
  v4 = *(_BYTE *)v3 - *(_BYTE *)a1;
  if ( *(_BYTE *)v3 == *(_BYTE *)a1 )
  {
    v5 = v2 - 1;
    a1 = (int *)((char *)a1 + 1);
    v6 = (char *)v3 + 1;
    if ( !v5 )
      goto LABEL_20;
    v4 = *v6 - *(_BYTE *)a1;
    if ( *v6 == *(_BYTE *)a1 )
    {
      v7 = v5 - 1;
      a1 = (int *)((char *)a1 + 1);
      v8 = v6 + 1;
      if ( !v7 )
        goto LABEL_20;
      v4 = *v8 - *(_BYTE *)a1;
      if ( *v8 == *(_BYTE *)a1 )
      {
        a1 = (int *)((char *)a1 + 1);
        v9 = v8 + 1;
        if ( v7 == 1 )
          goto LABEL_20;
        v4 = *v9 - *(_BYTE *)a1;
        if ( *v9 == *(_BYTE *)a1 )
          goto LABEL_20;
      }
    }
  }
  v10 = 1;
  if ( v4 <= 0 )
    v10 = -1;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_25:
  result = sub_1002C630(a1);
  if ( !result || result == 3 )
    result = sub_1002C620(v12);
  if ( v1 == 2 )
  {
    v22 = v15;
    v20 = v13;
    v21 = v14;
    v27 = v38;
    v25 = v18;
    v26 = v19;
    v28 = v39;
    v29 = v40;
    result = sub_10060ED0(2000, (int)&v20, 29);
  }
  return result;
}
// 10A09A94: using guessed type char byte_10A09A94;

//----- (100293E0) --------------------------------------------------------
char sub_100293E0()
{
  int *v0; // ecx@1

  sub_10029030(0x9C40u);
  sub_10027BA0(&off_100AE0F8);
  return sub_100291C0(v0);
}
// 100AE0F8: using guessed type int (__cdecl *off_100AE0F8)(int, size_t, void *);

//----- (10029400) --------------------------------------------------------
void sub_10029400()
{
  dword_1094DCC4 = -15;
}
// 1094DCC4: using guessed type int dword_1094DCC4;

//----- (10029410) --------------------------------------------------------
signed int sub_10029410()
{
  return sub_10061AA0((int)&off_100AE19C);
}
// 100AE19C: using guessed type char *off_100AE19C;

//----- (10029420) --------------------------------------------------------
char __cdecl sub_10029420(void *a1)
{
  char v1; // bl@1

  v1 = 0;
  if ( a1 && (unsigned __int8)sub_10029410() == 1 && !sub_10060A60(37, 100) )
  {
    qmemcpy(a1, (const void *)(dword_1094DCC4 + 8), 0x34u);
    v1 = 1;
    sub_10060A00(37);
  }
  return v1;
}
// 1094DCC4: using guessed type int dword_1094DCC4;

//----- (10029470) --------------------------------------------------------
bool sub_10029470()
{
  char v0; // bl@1
  unsigned int v2; // [sp+4h] [bp-4h]@1

  v0 = sub_10032600((char *)&v2);
  return (unsigned __int8)sub_10029410() && v0 && v2 < *(_DWORD *)(dword_1094DCC4 + 60) + 18;
}
// 1094DCC4: using guessed type int dword_1094DCC4;

//----- (100294B0) --------------------------------------------------------
void sub_100294B0()
{
  dword_10A09AC4 = -15;
}
// 10A09AC4: using guessed type int dword_10A09AC4;

//----- (100294C0) --------------------------------------------------------
char __cdecl sub_100294C0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  int v3; // eax@1
  char result; // al@2
  char v5[68]; // [sp+0h] [bp-48h]@1

  v2 = sub_10043C20(v1);
  v3 = sub_10043DC0(v2);
  if ( sub_10060D80(v3, (int)v5, 67) )
    result = 0;
  else
    result = v5[a1];
  return result;
}
// 100294C0: using guessed type char var_48[68];

//----- (10029520) --------------------------------------------------------
signed int sub_10029520()
{
  return sub_10061AA0((int)&off_100AE1D0);
}
// 100AE1D0: using guessed type char *off_100AE1D0;

//----- (10029530) --------------------------------------------------------
char __usercall sub_10029530@<al>(unsigned __int8 a1@<al>, char a2, void *a3)
{
  unsigned __int8 v3; // bl@1
  char result; // al@7

  v3 = a1;
  if ( (unsigned __int8)(a1 - 53) > 0xDu
    || (unsigned __int8)a2 >= 3u
    || !(unsigned __int8)sub_10029520()
    || sub_10060A60(33, 10) )
  {
    sub_10028BC0("..\\lib\\adl\\iop_data.c", 366, 0, 0);
    result = 0;
  }
  else if ( (unsigned int)(sub_10060900()
                         - *(_DWORD *)(dword_10A09AC4 + 4 * (v3 - 33 + (unsigned __int8)a2 + 2 * (v3 - 33)))) <= 0x258
         && *(_BYTE *)(v3 + (unsigned __int8)a2 + 2 * v3 + dword_10A09AC4 + 37) )
  {
    memcpy(
      a3,
      (const void *)(dword_10A09AC4 + 4 * (v3 - 53 + (unsigned __int8)a2 + 2 * (v3 - 53))),
      *(_WORD *)(dword_10A09AC4 + 2 * v3 + 62));
    sub_10060A00(33);
    result = 1;
  }
  else
  {
    sub_10060A00(33);
    result = 0;
  }
  return result;
}
// 10A09AC4: using guessed type int dword_10A09AC4;

//----- (10029610) --------------------------------------------------------
char __cdecl sub_10029610(int a1, char a2, void *a3)
{
  char result; // al@1
  int v4; // eax@4
  int v5; // esi@6
  int v6; // edi@7

  result = 0;
  if ( (unsigned __int8)a1 < 0x43u && (unsigned __int8)a2 < 3u )
  {
    if ( (unsigned __int8)a1 > 0x34u )
    {
      result = sub_10029530(a1, a2, a3);
    }
    else
    {
      v4 = sub_10043EF0(a1);
      if ( v4
        && (v5 = v4 + 4 * (unsigned __int8)a2, *(_BYTE *)v5 < 7)
        && (v6 = *(_WORD *)(v5 + 2), (unsigned __int16)v6 < (unsigned __int16)sub_10014DC0(*(_BYTE *)v5)) )
      {
        result = sub_10015AC0(*(_BYTE *)v5, v6, a3);
      }
      else
      {
        result = 0;
      }
    }
  }
  return result;
}
// 10043EF0: using guessed type _DWORD __cdecl sub_10043EF0(char);

//----- (10029690) --------------------------------------------------------
char __cdecl sub_10029690(int a1, void *a2)
{
  char v2; // al@1

  v2 = sub_100294C0(a1);
  return sub_10029610(a1, v2, a2);
}

//----- (100296B0) --------------------------------------------------------
int __cdecl sub_100296B0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1002CC90(&a1, 1u, (int)&unk_100AFC70, 8, 67, 0);
  if ( v1 )
  {
    result = dword_100AFC74[2 * v1];
  }
  else
  {
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 1932, 0, 0);
    result = 0;
  }
  return result;
}
// 100AFC74: using guessed type int dword_100AFC74[];

//----- (10029700) --------------------------------------------------------
char __cdecl sub_10029700(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int (__cdecl *v7)(int, int, int, int, int, int); // eax@2

  v6 = sub_1002CC90(&a1, 1u, (int)&unk_100AF8D0, 16, 58, 57);
  if ( v6 == 57 )
  {
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2231, 0, 0);
  }
  else
  {
    v7 = (int (__cdecl *)(int, int, int, int, int, int))dword_100AF8D4[4 * v6];
    if ( v7 )
      return v7(a1, a2, a3, a4, a5, a6);
  }
  return 0;
}
// 100AF8D4: using guessed type int dword_100AF8D4[];

//----- (10029770) --------------------------------------------------------
int __cdecl sub_10029770(char a1, _WORD *a2)
{
  int v2; // eax@1
  int v3; // ecx@1

  v2 = 8 * sub_1002CC90(&a1, 1u, (int)&unk_100AF8D0, 16, 58, 67);
  v3 = *(int *)((char *)&off_100AF8D8 + v2 * 2);
  *a2 = word_100AF8DC[v2];
  return v3;
}
// 100AF8D8: using guessed type void *off_100AF8D8;
// 100AF8DC: using guessed type __int16 word_100AF8DC[];

//----- (100297B0) --------------------------------------------------------
char __cdecl sub_100297B0(unsigned int a1)
{
  bool v1; // zf@2
  char result; // al@2
  unsigned int v3; // [sp+4h] [bp-4h]@1

  v3 = sub_10060D20(a1);
  if ( sub_1002CC90(&v3, 4u, (int)&unk_100AFE88, 4, 16, -1) == -1
    || (v1 = sub_1002CC90(&a1, 4u, (int)&unk_100AF8C4, 4, 3, -1) == -1, result = 1, !v1) )
  {
    result = 0;
  }
  return result;
}

//----- (10029810) --------------------------------------------------------
signed int sub_10029810()
{
  signed int result; // eax@1

  result = -15;
  dword_1094DCC8 = -15;
  dword_1094DCCC = -15;
  return result;
}
// 1094DCC8: using guessed type int dword_1094DCC8;
// 1094DCCC: using guessed type int dword_1094DCCC;

//----- (10029820) --------------------------------------------------------
signed int sub_10029820()
{
  return sub_10061AA0((int)&off_100AFEC8);
}
// 100AFEC8: using guessed type char *off_100AFEC8;

//----- (10029830) --------------------------------------------------------
signed int sub_10029830()
{
  return sub_10061AA0((int)&off_100AFEDC);
}
// 100AFEDC: using guessed type char *off_100AFEDC;

//----- (10029840) --------------------------------------------------------
char __usercall sub_10029840@<al>(char a1@<bl>, int a2@<edi>, const void *a3@<esi>, char a4, char a5, char a6, unsigned int a7)
{
  char v7; // dl@12
  __int16 v9; // [sp+4h] [bp-528h]@1
  char v10; // [sp+8h] [bp-524h]@11
  char v11; // [sp+9h] [bp-523h]@11
  char v12; // [sp+Ah] [bp-522h]@11
  char v13; // [sp+Bh] [bp-521h]@11
  __int16 v14; // [sp+Ch] [bp-520h]@12
  char v15; // [sp+Eh] [bp-51Eh]@12
  char v16; // [sp+Fh] [bp-51Dh]@15
  unsigned int v17; // [sp+524h] [bp-8h]@15

  memset(&v9, 0, 0x524u);
  if ( (unsigned __int8)a1 >= 8u )
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3425, 0, 0);
  if ( (unsigned __int8)a4 >= 0x39u )
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3426, 0, 0);
  if ( (unsigned __int8)a5 >= 2u )
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3427, 0, 0);
  if ( (unsigned __int8)a6 >= 0x2Cu )
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3428, 0, 0);
  if ( a7 >= 0x514 )
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 3429, 0, 0);
  v13 = a6;
  v9 = -32749;
  v10 = a1;
  v11 = a4;
  v12 = a5;
  if ( a2 )
  {
    v7 = *(_BYTE *)(a2 + 2);
    v14 = *(_WORD *)a2;
    v15 = v7;
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  if ( a3 )
  {
    memcpy(&v16, a3, a7);
    v17 = a7;
  }
  else
  {
    v17 = 0;
  }
  return sub_1002CC40((int)&v9);
}

//----- (100299A0) --------------------------------------------------------
char __cdecl sub_100299A0(_BYTE *a1)
{
  char result; // al@2

  if ( (unsigned __int8)sub_10029820() == 1 )
  {
    *a1 = *(_BYTE *)dword_1094DCC8;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1094DCC8: using guessed type int dword_1094DCC8;

//----- (100299D0) --------------------------------------------------------
char __cdecl sub_100299D0(unsigned __int8 a1, _BYTE *a2)
{
  char result; // al@3

  if ( (unsigned __int8)sub_10029830() != 1 || a1 >= 0x43u )
  {
    result = 0;
  }
  else
  {
    *a2 = *(_BYTE *)(a1 + dword_1094DCCC);
    result = 1;
  }
  return result;
}
// 1094DCCC: using guessed type int dword_1094DCCC;

//----- (10029A00) --------------------------------------------------------
char __cdecl sub_10029A00(char a1, char a2, int a3)
{
  return sub_10029840(2, a3, 0, a1, 0, a2, 0);
}

//----- (10029A30) --------------------------------------------------------
char __cdecl sub_10029A30(unsigned __int8 a1, char a2)
{
  char result; // al@3
  char v3; // [sp+7h] [bp-Dh]@3
  int v4; // [sp+8h] [bp-Ch]@1
  __int16 v5; // [sp+Ch] [bp-8h]@1

  v4 = 0;
  v5 = 0;
  if ( a1 >= 0x43u )
    sub_10028BC0("..\\lib\\adl\\iop_cnfg_mngr_intf.c", 2085, 0, 0);
  result = sub_100299D0(a1, &v3);
  if ( result == 1 )
  {
    result = a2;
    if ( v3 != a2 )
    {
      LOWORD(v4) = -32748;
      LOBYTE(v5) = a1;
      HIBYTE(v5) = a2;
      result = sub_1002CC40((int)&v4);
    }
  }
  return result;
}

//----- (10029AB0) --------------------------------------------------------
char __cdecl sub_10029AB0(unsigned __int8 a1, int a2)
{
  char result; // al@1

  qmemcpy((void *)a2, (const void *)(dword_10A09AC0 + 72 * a1 + 1660), 0x48u);
  result = 1;
  if ( !*(_BYTE *)(a2 + 60) && !*(_BYTE *)(a2 + 52) )
    result = 0;
  return result;
}
// 10A09AC0: using guessed type int dword_10A09AC0;

//----- (10029AF0) --------------------------------------------------------
char __cdecl sub_10029AF0(int a1, void *a2)
{
  char v2; // al@1
  int v3; // esi@2
  char v5; // [sp+13h] [bp-1h]@1

  memset(a2, 0, 0x48u);
  v5 = 0;
  v2 = 0;
  do
  {
    v3 = dword_10A09AC0 + 72 * (unsigned __int8)v2;
    if ( !strcmp((const char *)(v3 + 1720), (const char *)a1) )
    {
      qmemcpy(a2, (const void *)(v3 + 1660), 0x48u);
      v5 = 1;
      v2 = 30;
    }
    ++v2;
  }
  while ( (unsigned __int8)v2 < 0x1Eu );
  return v5;
}
// 10A09AC0: using guessed type int dword_10A09AC0;

//----- (10029B80) --------------------------------------------------------
bool __cdecl sub_10029B80(unsigned __int8 a1, _BYTE *a2, int a3)
{
  bool result; // al@1
  int v4; // esi@2

  result = 0;
  if ( a1 < 0x14u )
  {
    v4 = 12 * a1;
    sub_1002C120((int)a2, (_BYTE *)(v4 + dword_10A09AC0 + 29636), 12);
    sub_1002C120(a3, (_BYTE *)(v4 + dword_10A09AC0 + 29876), 12);
    result = *a2 != 0;
  }
  return result;
}
// 10A09AC0: using guessed type int dword_10A09AC0;

//----- (10029BE0) --------------------------------------------------------
void *__usercall sub_10029BE0@<eax>(unsigned __int16 a1@<bx>, int a2@<edi>, void *a3@<esi>)
{
  void *result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@0
  int v5; // [sp+4h] [bp-8h]@0
  int v6; // [sp+8h] [bp-4h]@0

  result = (void *)sub_10060D80(v4, v5, v6);
  if ( a2 == 6011 )
  {
    if ( result || *(_BYTE *)a3 > 0x3Fu )
    {
      *(_BYTE *)a3 = 63;
      result = (void *)sub_10060F50(6011, (int)a3, a1);
    }
  }
  else if ( result )
  {
    result = memset(a3, 204, a1);
  }
  return result;
}

//----- (10029C30) --------------------------------------------------------
signed int sub_10029C30()
{
  int v0; // edi@5
  void *v1; // esi@5
  signed int v2; // ebp@5
  signed int result; // eax@7
  char v4; // [sp+13h] [bp-1h]@1

  dword_10A09AC0 = 0;
  v4 = 0;
  sub_10061C40(94, &v4);
  if ( v4 == 3 )
  {
    v4 = 1;
    sub_10060ED0(3201, (int)&v4, 1);
    sub_10061C70(94, (int)&v4);
  }
  else if ( v4 == 2 )
  {
    v4 = 0;
    sub_10060ED0(3201, (int)&v4, 1);
    sub_10061C70(94, (int)&v4);
  }
  sub_10029BE0(1u, 6011, &unk_1094DCD0);
  sub_10029BE0(0x16u, 6194, &unk_1094DCD1);
  sub_10029BE0(1u, 6012, &unk_1094DCE7);
  sub_10029BE0(1u, 6013, &unk_1094DCE8);
  sub_10029BE0(1u, 6014, &unk_1094DCE9);
  sub_10029BE0(1u, 6015, &unk_1094DCEA);
  sub_10029BE0(4u, 6078, &unk_1094DCEC);
  sub_10029BE0(4u, 6104, &unk_1094DCF0);
  sub_10029BE0(0x20u, 6016, &unk_1094DCF4);
  sub_10029BE0(0x20u, 6017, &unk_1094DD14);
  sub_10029BE0(0x20u, 6018, &unk_1094DD34);
  sub_10029BE0(0x20u, 6019, &unk_1094DD54);
  sub_10029BE0(0x20u, 6020, &unk_1094DD74);
  sub_10029BE0(0x20u, 6021, &unk_1094DD94);
  sub_10029BE0(0x20u, 6022, &unk_1094DDB4);
  sub_10029BE0(0x20u, 6023, &unk_1094DDD4);
  sub_10029BE0(0x20u, 6024, &unk_1094DDF4);
  sub_10029BE0(0x20u, 6025, &unk_1094DE14);
  sub_10029BE0(0x20u, 6026, &unk_1094DE34);
  sub_10029BE0(0x20u, 6027, &unk_1094DE54);
  sub_10029BE0(0x20u, 6028, &unk_1094DE74);
  sub_10029BE0(0x20u, 6029, &unk_1094DE94);
  sub_10029BE0(0x20u, 6030, &unk_1094DEB4);
  sub_10029BE0(0x20u, 6031, &unk_1094DED4);
  sub_10029BE0(0x20u, 6032, &unk_1094DEF4);
  sub_10029BE0(0x20u, 6033, &unk_1094DF14);
  sub_10029BE0(0x20u, 6034, &unk_1094DF34);
  sub_10029BE0(0x20u, 6035, &unk_1094DF54);
  sub_10029BE0(0x20u, 6036, &unk_1094DF74);
  sub_10029BE0(0x20u, 6037, &unk_1094DF94);
  sub_10029BE0(0x20u, 6038, &unk_1094DFB4);
  sub_10029BE0(0x20u, 6039, &unk_1094DFD4);
  sub_10029BE0(0x20u, 6040, &unk_1094DFF4);
  sub_10029BE0(0x20u, 6041, &unk_1094E014);
  sub_10029BE0(0x20u, 6042, &unk_1094E034);
  sub_10029BE0(0x20u, 6043, &unk_1094E054);
  sub_10029BE0(4u, 6044, &unk_1094E074);
  sub_10029BE0(4u, 6045, &unk_1094E078);
  sub_10029BE0(4u, 6046, &unk_1094E07C);
  sub_10029BE0(4u, 6357, &unk_1094E080);
  sub_10029BE0(4u, 6358, &unk_1094E084);
  sub_10029BE0(4u, 6359, &unk_1094E088);
  sub_10029BE0(0x20u, 6047, &unk_1094E08C);
  sub_10029BE0(0x20u, 6048, &unk_1094E0AC);
  sub_10029BE0(0x20u, 6049, &unk_1094E0CC);
  sub_10029BE0(0x20u, 6050, &unk_1094E0EC);
  sub_10029BE0(0x20u, 6051, &unk_1094E10C);
  sub_10029BE0(0x20u, 6052, &unk_1094E12C);
  sub_10029BE0(0x20u, 6053, &unk_1094E14C);
  sub_10029BE0(0x20u, 6054, &unk_1094E16C);
  sub_10029BE0(1u, 6511, &unk_1094E18C);
  sub_10029BE0(1u, 6522, &unk_1094E18D);
  sub_10029BE0(1u, 6057, &unk_1094E18E);
  sub_10029BE0(0x20u, 6075, &unk_1094E1E0);
  sub_10029BE0(0x20u, 6076, &unk_1094E200);
  sub_10029BE0(1u, 6077, &unk_1094E220);
  sub_10029BE0(4u, 6079, &unk_1094E224);
  sub_10029BE0(4u, 6080, &unk_1094E228);
  sub_10029BE0(0x20u, 6082, &unk_1094E22C);
  sub_10029BE0(0x20u, 6083, &unk_1094E24C);
  sub_10029BE0(0x20u, 6084, &unk_1094E26C);
  sub_10029BE0(0x20u, 6085, &unk_1094E28C);
  sub_10029BE0(0x20u, 6086, &unk_1094E2AC);
  sub_10029BE0(0x20u, 6087, &unk_1094E2CC);
  sub_10029BE0(0x20u, 6088, &unk_1094E2EC);
  sub_10029BE0(0x20u, 6089, &unk_1094E30C);
  sub_10029BE0(0x20u, 6123, &unk_1094E32C);
  sub_10029BE0(0x48u, 6906, &unk_1094E34C);
  sub_10029BE0(0x48u, 6907, &unk_1094E394);
  sub_10029BE0(0x48u, 6908, &unk_1094E3DC);
  sub_10029BE0(0x48u, 6909, &unk_1094E424);
  sub_10029BE0(0x48u, 6910, &unk_1094E46C);
  sub_10029BE0(0x48u, 6911, &unk_1094E4B4);
  sub_10029BE0(0x48u, 6912, &unk_1094E4FC);
  sub_10029BE0(0x48u, 6913, &unk_1094E544);
  sub_10029BE0(0x48u, 6914, &unk_1094E58C);
  sub_10029BE0(0x48u, 6915, &unk_1094E5D4);
  sub_10029BE0(0x48u, 6916, &unk_1094E61C);
  sub_10029BE0(0x48u, 6917, &unk_1094E664);
  sub_10029BE0(0x48u, 6918, &unk_1094E6AC);
  sub_10029BE0(0x48u, 6919, &unk_1094E6F4);
  sub_10029BE0(0x48u, 6920, &unk_1094E73C);
  sub_10029BE0(0x48u, 6921, &unk_1094E784);
  sub_10029BE0(0x48u, 6922, &unk_1094E7CC);
  sub_10029BE0(0x48u, 6923, &unk_1094E814);
  sub_10029BE0(0x48u, 6924, &unk_1094E85C);
  sub_10029BE0(0x48u, 6925, &unk_1094E8A4);
  sub_10029BE0(0x48u, 6926, &unk_1094E8EC);
  sub_10029BE0(0x48u, 6927, &unk_1094E934);
  sub_10029BE0(0x48u, 6928, &unk_1094E97C);
  sub_10029BE0(0x48u, 6929, &unk_1094E9C4);
  sub_10029BE0(0x48u, 6930, &unk_1094EA0C);
  sub_10029BE0(0x48u, 6931, &unk_1094EA54);
  sub_10029BE0(0x48u, 6932, &unk_1094EA9C);
  sub_10029BE0(0x48u, 6933, &unk_1094EAE4);
  sub_10029BE0(0x48u, 6934, &unk_1094EB2C);
  sub_10029BE0(0x48u, 6935, &unk_1094EB74);
  sub_10029BE0(0x18u, 6163, &unk_1094EBBC);
  sub_10029BE0(0x20u, 6164, &unk_1094EBD4);
  sub_10029BE0(0x20u, 6165, &unk_1094EBF4);
  sub_10029BE0(2u, 6166, &unk_1094EC14);
  sub_10029BE0(0xA4u, 40100, &unk_1094EC18);
  sub_10029BE0(0xA4u, 40101, &unk_1094ECBC);
  sub_10029BE0(0xA4u, 40102, &unk_1094ED60);
  sub_10029BE0(0xA4u, 40103, &unk_1094EE04);
  sub_10029BE0(0xA4u, 40104, &unk_1094EEA8);
  sub_10029BE0(0xA4u, 40105, &unk_1094EF4C);
  sub_10029BE0(0xA4u, 40106, &unk_1094EFF0);
  sub_10029BE0(0xA4u, 40107, &unk_1094F094);
  sub_10029BE0(0xA4u, 40108, &unk_1094F138);
  sub_10029BE0(0xA4u, 40109, &unk_1094F1DC);
  sub_10029BE0(0xA4u, 40110, &unk_1094F280);
  sub_10029BE0(0xA4u, 40111, &unk_1094F324);
  sub_10029BE0(0xA4u, 40112, &unk_1094F3C8);
  sub_10029BE0(0xA4u, 40113, &unk_1094F46C);
  sub_10029BE0(0xA4u, 40114, &unk_1094F510);
  sub_10029BE0(0xA4u, 40115, &unk_1094F5B4);
  sub_10029BE0(0xA4u, 40116, &unk_1094F658);
  sub_10029BE0(0xA4u, 40117, &unk_1094F6FC);
  sub_10029BE0(0xA4u, 40118, &unk_1094F7A0);
  sub_10029BE0(0xA4u, 40119, &unk_1094F844);
  sub_10029BE0(0xA4u, 40120, &unk_1094F8E8);
  sub_10029BE0(0xA4u, 40121, &unk_1094F98C);
  sub_10029BE0(0xA4u, 40122, &unk_1094FA30);
  sub_10029BE0(0xA4u, 40123, &unk_1094FAD4);
  sub_10029BE0(0xA4u, 40124, &unk_1094FB78);
  sub_10029BE0(0xA4u, 40125, &unk_1094FC1C);
  sub_10029BE0(0xA4u, 40126, &unk_1094FCC0);
  sub_10029BE0(0xA4u, 40127, &unk_1094FD64);
  sub_10029BE0(0xA4u, 40128, &unk_1094FE08);
  sub_10029BE0(0xA4u, 40129, &unk_1094FEAC);
  sub_10029BE0(0xA4u, 40130, &unk_1094FF50);
  sub_10029BE0(0xA4u, 40131, &unk_1094FFF4);
  sub_10029BE0(0xA4u, 40132, &unk_10950098);
  sub_10029BE0(0xA4u, 40133, &unk_1095013C);
  sub_10029BE0(0xA4u, 40134, &unk_109501E0);
  sub_10029BE0(0xA4u, 40135, &unk_10950284);
  sub_10029BE0(0xA4u, 40136, &unk_10950328);
  sub_10029BE0(0xA4u, 40137, &unk_109503CC);
  sub_10029BE0(0xA4u, 40138, &unk_10950470);
  sub_10029BE0(0xA4u, 40139, &unk_10950514);
  sub_10029BE0(0xA4u, 40140, &unk_109505B8);
  sub_10029BE0(0xA4u, 40141, &unk_1095065C);
  sub_10029BE0(0xA4u, 40142, &unk_10950700);
  sub_10029BE0(0xA4u, 40143, &unk_109507A4);
  sub_10029BE0(0xA4u, 40144, &unk_10950848);
  sub_10029BE0(0xA4u, 40145, &unk_109508EC);
  sub_10029BE0(0xA4u, 40146, &unk_10950990);
  sub_10029BE0(0xA4u, 40147, &unk_10950A34);
  sub_10029BE0(0xA4u, 40148, &unk_10950AD8);
  sub_10029BE0(0xA4u, 40149, &unk_10950B7C);
  sub_10029BE0(0xA4u, 40150, &unk_10950C20);
  sub_10029BE0(0xA4u, 40151, &unk_10950CC4);
  sub_10029BE0(0xA4u, 40152, &unk_10950D68);
  sub_10029BE0(0xA4u, 40153, &unk_10950E0C);
  sub_10029BE0(0xA4u, 40154, &unk_10950EB0);
  sub_10029BE0(0xA4u, 40155, &unk_10950F54);
  sub_10029BE0(0xA4u, 40156, &unk_10950FF8);
  sub_10029BE0(0xA4u, 40157, &unk_1095109C);
  sub_10029BE0(0xA4u, 40158, &unk_10951140);
  sub_10029BE0(0xA4u, 40159, &unk_109511E4);
  sub_10029BE0(0xA4u, 40160, &unk_10951288);
  sub_10029BE0(0xA4u, 40161, &unk_1095132C);
  sub_10029BE0(0xA4u, 40162, &unk_109513D0);
  sub_10029BE0(0xA4u, 40163, &unk_10951474);
  sub_10029BE0(0xA4u, 40164, &unk_10951518);
  sub_10029BE0(0xA4u, 40165, &unk_109515BC);
  sub_10029BE0(0xA4u, 40166, &unk_10951660);
  sub_10029BE0(0xA4u, 40167, &unk_10951704);
  sub_10029BE0(0xA4u, 40168, &unk_109517A8);
  sub_10029BE0(0xA4u, 40169, &unk_1095184C);
  sub_10029BE0(0xA4u, 40170, &unk_109518F0);
  sub_10029BE0(0xA4u, 40171, &unk_10951994);
  sub_10029BE0(0xA4u, 40172, &unk_10951A38);
  sub_10029BE0(0xA4u, 40173, &unk_10951ADC);
  sub_10029BE0(0xA4u, 40174, &unk_10951B80);
  sub_10029BE0(0xA4u, 40175, &unk_10951C24);
  sub_10029BE0(0xA4u, 40176, &unk_10951CC8);
  sub_10029BE0(0xA4u, 40177, &unk_10951D6C);
  sub_10029BE0(0xA4u, 40178, &unk_10951E10);
  sub_10029BE0(0xA4u, 40179, &unk_10951EB4);
  sub_10029BE0(0xA4u, 40180, &unk_10951F58);
  sub_10029BE0(0xA4u, 40181, &unk_10951FFC);
  sub_10029BE0(0xA4u, 40182, &unk_109520A0);
  sub_10029BE0(0xA4u, 40183, &unk_10952144);
  sub_10029BE0(0xA4u, 40184, &unk_109521E8);
  sub_10029BE0(0xA4u, 40185, &unk_1095228C);
  sub_10029BE0(0xA4u, 40186, &unk_10952330);
  sub_10029BE0(0xA4u, 40187, &unk_109523D4);
  sub_10029BE0(0xA4u, 40188, &unk_10952478);
  sub_10029BE0(0xA4u, 40189, &unk_1095251C);
  sub_10029BE0(0xA4u, 40190, &unk_109525C0);
  sub_10029BE0(0xA4u, 40191, &unk_10952664);
  sub_10029BE0(0xA4u, 40192, &unk_10952708);
  sub_10029BE0(0xA4u, 40193, &unk_109527AC);
  sub_10029BE0(0xA4u, 40194, &unk_10952850);
  sub_10029BE0(0xA4u, 40195, &unk_109528F4);
  sub_10029BE0(0xA4u, 40196, &unk_10952998);
  sub_10029BE0(0xA4u, 40197, &unk_10952A3C);
  sub_10029BE0(0xA4u, 40198, &unk_10952AE0);
  sub_10029BE0(0xA4u, 40199, &unk_10952B84);
  sub_10029BE0(0x20u, 6190, &unk_10952C28);
  sub_10029BE0(0x20u, 6191, &unk_10952C48);
  sub_10029BE0(0x20u, 6192, &unk_10952C68);
  sub_10029BE0(0x20u, 6199, &unk_10952C88);
  sub_10029BE0(0x28u, 6207, &unk_10952CA8);
  sub_10029BE0(4u, 6231, &unk_109537C0);
  sub_10029BE0(4u, 6232, &unk_109537C4);
  sub_10029BE0(4u, 6233, &unk_109537C8);
  sub_10029BE0(4u, 6234, &unk_109537CC);
  sub_10029BE0(0x1Cu, 40000, &unk_10952CD0);
  sub_10029BE0(0x1Cu, 40001, &unk_10952CEC);
  sub_10029BE0(0x1Cu, 40002, &unk_10952D08);
  sub_10029BE0(0x1Cu, 40003, &unk_10952D24);
  sub_10029BE0(0x1Cu, 40004, &unk_10952D40);
  sub_10029BE0(0x1Cu, 40005, &unk_10952D5C);
  sub_10029BE0(0x1Cu, 40006, &unk_10952D78);
  sub_10029BE0(0x1Cu, 40007, &unk_10952D94);
  sub_10029BE0(0x1Cu, 40008, &unk_10952DB0);
  sub_10029BE0(0x1Cu, 40009, &unk_10952DCC);
  sub_10029BE0(0x1Cu, 40010, &unk_10952DE8);
  sub_10029BE0(0x1Cu, 40011, &unk_10952E04);
  sub_10029BE0(0x1Cu, 40012, &unk_10952E20);
  sub_10029BE0(0x1Cu, 40013, &unk_10952E3C);
  sub_10029BE0(0x1Cu, 40014, &unk_10952E58);
  sub_10029BE0(0x1Cu, 40015, &unk_10952E74);
  sub_10029BE0(0x1Cu, 40016, &unk_10952E90);
  sub_10029BE0(0x1Cu, 40017, &unk_10952EAC);
  sub_10029BE0(0x1Cu, 40018, &unk_10952EC8);
  sub_10029BE0(0x1Cu, 40019, &unk_10952EE4);
  sub_10029BE0(0x1Cu, 40020, &unk_10952F00);
  sub_10029BE0(0x1Cu, 40021, &unk_10952F1C);
  sub_10029BE0(0x1Cu, 40022, &unk_10952F38);
  sub_10029BE0(0x1Cu, 40023, &unk_10952F54);
  sub_10029BE0(0x1Cu, 40024, &unk_10952F70);
  sub_10029BE0(0x1Cu, 40025, &unk_10952F8C);
  sub_10029BE0(0x1Cu, 40026, &unk_10952FA8);
  sub_10029BE0(0x1Cu, 40027, &unk_10952FC4);
  sub_10029BE0(0x1Cu, 40028, &unk_10952FE0);
  sub_10029BE0(0x1Cu, 40029, &unk_10952FFC);
  sub_10029BE0(0x1Cu, 40030, &unk_10953018);
  sub_10029BE0(0x1Cu, 40031, &unk_10953034);
  sub_10029BE0(0x1Cu, 40032, &unk_10953050);
  sub_10029BE0(0x1Cu, 40033, &unk_1095306C);
  sub_10029BE0(0x1Cu, 40034, &unk_10953088);
  sub_10029BE0(0x1Cu, 40035, &unk_109530A4);
  sub_10029BE0(0x1Cu, 40036, &unk_109530C0);
  sub_10029BE0(0x1Cu, 40037, &unk_109530DC);
  sub_10029BE0(0x1Cu, 40038, &unk_109530F8);
  sub_10029BE0(0x1Cu, 40039, &unk_10953114);
  sub_10029BE0(0x1Cu, 40040, &unk_10953130);
  sub_10029BE0(0x1Cu, 40041, &unk_1095314C);
  sub_10029BE0(0x1Cu, 40042, &unk_10953168);
  sub_10029BE0(0x1Cu, 40043, &unk_10953184);
  sub_10029BE0(0x1Cu, 40044, &unk_109531A0);
  sub_10029BE0(0x1Cu, 40045, &unk_109531BC);
  sub_10029BE0(0x1Cu, 40046, &unk_109531D8);
  sub_10029BE0(0x1Cu, 40047, &unk_109531F4);
  sub_10029BE0(0x1Cu, 40048, &unk_10953210);
  sub_10029BE0(0x1Cu, 40049, &unk_1095322C);
  sub_10029BE0(0x1Cu, 40050, &unk_10953248);
  sub_10029BE0(0x1Cu, 40051, &unk_10953264);
  sub_10029BE0(0x1Cu, 40052, &unk_10953280);
  sub_10029BE0(0x1Cu, 40053, &unk_1095329C);
  sub_10029BE0(0x1Cu, 40054, &unk_109532B8);
  sub_10029BE0(0x1Cu, 40055, &unk_109532D4);
  sub_10029BE0(0x1Cu, 40056, &unk_109532F0);
  sub_10029BE0(0x1Cu, 40057, &unk_1095330C);
  sub_10029BE0(0x1Cu, 40058, &unk_10953328);
  sub_10029BE0(0x1Cu, 40059, &unk_10953344);
  sub_10029BE0(0x1Cu, 40060, &unk_10953360);
  sub_10029BE0(0x1Cu, 40061, &unk_1095337C);
  sub_10029BE0(0x1Cu, 40062, &unk_10953398);
  sub_10029BE0(0x1Cu, 40063, &unk_109533B4);
  sub_10029BE0(0x1Cu, 40064, &unk_109533D0);
  sub_10029BE0(0x1Cu, 40065, &unk_109533EC);
  sub_10029BE0(0x1Cu, 40066, &unk_10953408);
  sub_10029BE0(0x1Cu, 40067, &unk_10953424);
  sub_10029BE0(0x1Cu, 40068, &unk_10953440);
  sub_10029BE0(0x1Cu, 40069, &unk_1095345C);
  sub_10029BE0(0x1Cu, 40070, &unk_10953478);
  sub_10029BE0(0x1Cu, 40071, &unk_10953494);
  sub_10029BE0(0x1Cu, 40072, &unk_109534B0);
  sub_10029BE0(0x1Cu, 40073, &unk_109534CC);
  sub_10029BE0(0x1Cu, 40074, &unk_109534E8);
  sub_10029BE0(0x1Cu, 40075, &unk_10953504);
  sub_10029BE0(0x1Cu, 40076, &unk_10953520);
  sub_10029BE0(0x1Cu, 40077, &unk_1095353C);
  sub_10029BE0(0x1Cu, 40078, &unk_10953558);
  sub_10029BE0(0x1Cu, 40079, &unk_10953574);
  sub_10029BE0(0x1Cu, 40080, &unk_10953590);
  sub_10029BE0(0x1Cu, 40081, &unk_109535AC);
  sub_10029BE0(0x1Cu, 40082, &unk_109535C8);
  sub_10029BE0(0x1Cu, 40083, &unk_109535E4);
  sub_10029BE0(0x1Cu, 40084, &unk_10953600);
  sub_10029BE0(0x1Cu, 40085, &unk_1095361C);
  sub_10029BE0(0x1Cu, 40086, &unk_10953638);
  sub_10029BE0(0x1Cu, 40087, &unk_10953654);
  sub_10029BE0(0x1Cu, 40088, &unk_10953670);
  sub_10029BE0(0x1Cu, 40089, &unk_1095368C);
  sub_10029BE0(0x1Cu, 40090, &unk_109536A8);
  sub_10029BE0(0x1Cu, 40091, &unk_109536C4);
  sub_10029BE0(0x1Cu, 40092, &unk_109536E0);
  sub_10029BE0(0x1Cu, 40093, &unk_109536FC);
  sub_10029BE0(0x1Cu, 40094, &unk_10953718);
  sub_10029BE0(0x1Cu, 40095, &unk_10953734);
  sub_10029BE0(0x1Cu, 40096, &unk_10953750);
  sub_10029BE0(0x1Cu, 40097, &unk_1095376C);
  sub_10029BE0(0x1Cu, 40098, &unk_10953788);
  sub_10029BE0(0x1Cu, 40099, &unk_109537A4);
  sub_10029BE0(4u, 6238, &unk_109537D0);
  sub_10029BE0(4u, 6239, &unk_109537D4);
  sub_10029BE0(4u, 6240, &unk_109537D8);
  sub_10029BE0(4u, 6242, &unk_109537DC);
  sub_10029BE0(4u, 6244, &unk_109537E0);
  sub_10029BE0(4u, 6245, &unk_109537E4);
  sub_10029BE0(4u, 6246, &unk_109537E8);
  sub_10029BE0(4u, 6251, &unk_109537EC);
  sub_10029BE0(4u, 6252, &unk_109537F0);
  sub_10029BE0(4u, 6253, &unk_109537F4);
  sub_10029BE0(4u, 6254, &unk_109537F8);
  sub_10029BE0(1u, 6255, &unk_109537FC);
  sub_10029BE0(4u, 6256, &unk_10953800);
  sub_10029BE0(4u, 6257, &unk_10953804);
  sub_10029BE0(0xE2u, 6286, &unk_10953808);
  v0 = 18000;
  v1 = &unk_109538EC;
  v2 = 16;
  do
  {
    sub_10029BE0(0x11Cu, v0, v1);
    v1 = (char *)v1 + 284;
    ++v0;
    --v2;
  }
  while ( v2 );
  sub_10029BE0(4u, 6262, &unk_10954AAC);
  sub_10029BE0(0x28u, 6263, &unk_10954AB0);
  sub_10029BE0(0x28u, 6264, &unk_10954AD8);
  sub_10029BE0(0x40u, 6268, &unk_10954B00);
  sub_10029BE0(4u, 6272, &unk_10954BC0);
  sub_10029BE0(4u, 6273, &unk_10954BC4);
  sub_10029BE0(1u, 6274, &unk_10954BC8);
  sub_10029BE0(2u, 6275, &unk_10954BCA);
  sub_10029BE0(1u, 6276, &unk_10954BCC);
  sub_10029BE0(1u, 6277, &unk_10954BCD);
  sub_10029BE0(1u, 6278, &unk_10954BCE);
  sub_10029BE0(0x40u, 6279, &unk_10954BD0);
  sub_10029BE0(0x28u, 6753, &unk_10955A85);
  sub_10029BE0(0x30u, 6754, &unk_10955AB0);
  sub_10029BE0(0x28u, 6958, &unk_10955AE0);
  sub_10029BE0(0x80u, 6802, &unk_10954B40);
  sub_10029BE0(1u, 6760, &unk_10955B08);
  sub_10029BE0(0x10u, 6312, &unk_10954F54);
  sub_10029BE0(0x10u, 6313, &unk_10954F64);
  sub_10029BE0(0x10u, 6314, &unk_10954F74);
  sub_10029BE0(1u, 6307, &unk_10954F84);
  sub_10029BE0(1u, 6308, &unk_10954F85);
  sub_10029BE0(1u, 6309, &unk_10954F86);
  sub_10029BE0(4u, 6285, &unk_10954F88);
  sub_10029BE0(0xA8u, 6318, &unk_10954F8C);
  sub_10029BE0(4u, 6319, &unk_10955034);
  sub_10029BE0(1u, 6350, &unk_10955038);
  sub_10029BE0(0x50u, 6351, &unk_1095503C);
  sub_10029BE0(4u, 6352, &unk_1095508C);
  sub_10029BE0(4u, 6353, &unk_10955090);
  sub_10029BE0(0x54u, 6448, &unk_109552DC);
  sub_10029BE0(0x54u, 6449, &unk_10955330);
  sub_10029BE0(8u, 6287, &unk_10954C34);
  sub_10029BE0(8u, 6288, &unk_10954C3C);
  sub_10029BE0(8u, 6289, &unk_10954C44);
  sub_10029BE0(8u, 6290, &unk_10954C4C);
  sub_10029BE0(8u, 6291, &unk_10954C54);
  sub_10029BE0(8u, 6292, &unk_10954C5C);
  sub_10029BE0(8u, 6293, &unk_10954C64);
  sub_10029BE0(8u, 6294, &unk_10954C6C);
  sub_10029BE0(8u, 6295, &unk_10954C74);
  sub_10029BE0(8u, 6296, &unk_10954C7C);
  sub_10029BE0(8u, 6297, &unk_10954C84);
  sub_10029BE0(8u, 6298, &unk_10954C8C);
  sub_10029BE0(8u, 6299, &unk_10954C94);
  sub_10029BE0(8u, 6300, &unk_10954C9C);
  sub_10029BE0(8u, 6301, &unk_10954CA4);
  sub_10029BE0(8u, 6302, &unk_10954CAC);
  sub_10029BE0(8u, 6303, &unk_10954CB4);
  sub_10029BE0(8u, 6304, &unk_10954CBC);
  sub_10029BE0(8u, 6305, &unk_10954CC4);
  sub_10029BE0(8u, 6306, &unk_10954CCC);
  sub_10029BE0(8u, 6409, &unk_10954CD4);
  sub_10029BE0(8u, 6410, &unk_10954CDC);
  sub_10029BE0(8u, 6411, &unk_10954CE4);
  sub_10029BE0(8u, 6412, &unk_10954CEC);
  sub_10029BE0(8u, 6413, &unk_10954CF4);
  sub_10029BE0(8u, 6414, &unk_10954CFC);
  sub_10029BE0(8u, 6415, &unk_10954D04);
  sub_10029BE0(8u, 6416, &unk_10954D0C);
  sub_10029BE0(8u, 6417, &unk_10954D14);
  sub_10029BE0(8u, 6418, &unk_10954D1C);
  sub_10029BE0(8u, 6419, &unk_10954D24);
  sub_10029BE0(8u, 6420, &unk_10954D2C);
  sub_10029BE0(8u, 6421, &unk_10954D34);
  sub_10029BE0(8u, 6422, &unk_10954D3C);
  sub_10029BE0(8u, 6423, &unk_10954D44);
  sub_10029BE0(8u, 6424, &unk_10954D4C);
  sub_10029BE0(8u, 6425, &unk_10954D54);
  sub_10029BE0(8u, 6426, &unk_10954D5C);
  sub_10029BE0(8u, 6427, &unk_10954D64);
  sub_10029BE0(8u, 6428, &unk_10954D6C);
  sub_10029BE0(4u, 6429, &unk_10955274);
  sub_10029BE0(8u, 6430, &unk_10955278);
  sub_10029BE0(8u, 6431, &unk_10955280);
  sub_10029BE0(8u, 6432, &unk_10955288);
  sub_10029BE0(8u, 6433, &unk_10955290);
  sub_10029BE0(8u, 6434, &unk_10955298);
  sub_10029BE0(8u, 6435, &unk_109552A0);
  sub_10029BE0(8u, 6436, &unk_109552A8);
  sub_10029BE0(8u, 6437, &unk_109552B0);
  sub_10029BE0(8u, 6438, &unk_109552B8);
  sub_10029BE0(8u, 6439, &unk_109552C0);
  sub_10029BE0(8u, 6440, &unk_109552C8);
  sub_10029BE0(0xAu, 6519, &unk_10955734);
  sub_10029BE0(4u, 6442, &unk_109552D0);
  sub_10029BE0(4u, 6443, &unk_109552D4);
  sub_10029BE0(0xF0u, 6367, &unk_10955094);
  sub_10029BE0(0xF0u, 6368, &unk_10955184);
  sub_10029BE0(1u, 6446, &unk_109552D8);
  sub_10029BE0(6u, 6452, &unk_10955384);
  sub_10029BE0(4u, 6457, &unk_1095538C);
  sub_10029BE0(4u, 6458, &unk_10955390);
  sub_10029BE0(4u, 6459, &unk_10955394);
  sub_10029BE0(4u, 6460, &unk_10955398);
  sub_10029BE0(0x208u, 6515, &unk_1095539C);
  sub_10029BE0(0x160u, 6516, &unk_109555A4);
  sub_10029BE0(0x18u, 6517, &unk_10955704);
  sub_10029BE0(0x18u, 6518, &unk_1095571C);
  sub_10029BE0(1u, 6520, &unk_1095573E);
  sub_10029BE0(0x10u, 6521, &unk_10955740);
  sub_10029BE0(4u, 6523, &unk_10955750);
  sub_10029BE0(4u, 6524, &unk_10955754);
  sub_10029BE0(4u, 6525, &unk_10955758);
  sub_10029BE0(1u, 6526, &unk_1095575C);
  sub_10029BE0(1u, 6527, &unk_1095575D);
  sub_10029BE0(0x50u, 6528, &unk_10955760);
  sub_10029BE0(4u, 6529, &unk_109557B0);
  sub_10029BE0(1u, 6530, &unk_109557B4);
  sub_10029BE0(1u, 6531, &unk_109557B5);
  sub_10029BE0(1u, 6532, &unk_109557B6);
  sub_10029BE0(0x14u, 6533, &unk_109557B7);
  sub_10029BE0(0xAu, 6883, &unk_10955ED0);
  sub_10029BE0(0xAu, 6884, &unk_10955EDA);
  sub_10029BE0(0xAu, 6885, &unk_10955EE4);
  sub_10029BE0(1u, 6664, &unk_109557CB);
  sub_10029BE0(1u, 6666, &unk_109557CC);
  sub_10029BE0(1u, 6667, &unk_109557CD);
  sub_10029BE0(1u, 6668, &unk_109557CE);
  sub_10029BE0(0xA0u, 6669, &unk_109557D0);
  sub_10029BE0(2u, 6670, &unk_109558C0);
  sub_10029BE0(4u, 6671, &unk_109558C4);
  sub_10029BE0(4u, 6672, &unk_109558C8);
  sub_10029BE0(4u, 6673, &unk_109558CC);
  sub_10029BE0(4u, 6674, &unk_109558D0);
  sub_10029BE0(4u, 6675, &unk_109558D4);
  sub_10029BE0(4u, 6676, &unk_109558DC);
  sub_10029BE0(4u, 6677, &unk_109558E4);
  sub_10029BE0(4u, 6678, &unk_109558E8);
  sub_10029BE0(1u, 6679, &unk_109558EC);
  sub_10029BE0(0x140u, 6680, &unk_109558F0);
  sub_10029BE0(4u, 6882, &unk_10955ECC);
  sub_10029BE0(0xCu, 6652, &unk_10955A30);
  sub_10029BE0(0x48u, 6653, &unk_10955A3C);
  sub_10029BE0(1u, 6688, &unk_10955A84);
  sub_10029BE0(4u, 6771, &unk_10955B0C);
  sub_10029BE0(4u, 6772, &unk_10955B10);
  sub_10029BE0(8u, 6787, &unk_10955B14);
  sub_10029BE0(1u, 6832, &unk_10955B44);
  sub_10029BE0(1u, 6833, &unk_10955B45);
  sub_10029BE0(1u, 6834, &unk_10955B46);
  sub_10029BE0(4u, 6835, &unk_10955B48);
  sub_10029BE0(4u, 6836, &unk_10955B4C);
  sub_10029BE0(4u, 6837, &unk_10955B50);
  sub_10029BE0(4u, 6838, &unk_10955B54);
  sub_10029BE0(1u, 6839, &unk_10955B58);
  sub_10029BE0(0x50u, 6840, &unk_10955870);
  sub_10029BE0(4u, 6841, &unk_10955B5C);
  sub_10029BE0(4u, 6842, &unk_10955B60);
  sub_10029BE0(4u, 6843, &unk_10955B64);
  sub_10029BE0(1u, 6844, &unk_10955B68);
  sub_10029BE0(0x360u, 6845, &unk_10955B6C);
  sub_10029BE0(4u, 6846, &unk_109558D8);
  sub_10029BE0(4u, 6847, &unk_109558E0);
  result = 1;
  dword_10A09AC0 = (int)&unk_1094DCD0;
  return result;
}
// 10A09AC0: using guessed type int dword_10A09AC0;

//----- (1002BA30) --------------------------------------------------------
int __fastcall sub_1002BA30(int a1, int a2)
{
  byte_10A0922C = 0;
  return nullsub_1(a1, a2);
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10A0922C: using guessed type char byte_10A0922C;

//----- (1002BA40) --------------------------------------------------------
int sub_1002BA40()
{
  int result; // eax@1

  result = 0;
  dword_109576A0 = -15;
  dword_10A09ABC = 0;
  dword_10A09AB0 = 0;
  dword_10A09AB4 = 0;
  dword_10A09AB8 = 0;
  return result;
}
// 109576A0: using guessed type int dword_109576A0;
// 10A09AB0: using guessed type int dword_10A09AB0;
// 10A09AB4: using guessed type int dword_10A09AB4;
// 10A09AB8: using guessed type int dword_10A09AB8;
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (1002BA70) --------------------------------------------------------
char sub_1002BA70()
{
  char v0; // bl@1
  signed int v1; // esi@2
  char result; // al@4

  v0 = sub_10061AA0((int)&off_100B37E0);
  if ( v0 )
  {
    dword_10A09ABC = dword_109576A0;
    v1 = *(_BYTE *)(dword_109576A0 + 667) != 0 ? 1100 : 2000;
    if ( v1 + *(_DWORD *)(dword_10A09ABC + 36) < (unsigned int)sub_10060900() )
      v0 = 0;
    dword_10A09AB8 = dword_109576A0 + 56116;
    result = v0;
    dword_10A09AB0 = dword_109576A0 + 1516;
    dword_10A09AB4 = dword_109576A0 + 20484;
  }
  else
  {
    dword_10A09ABC = 0;
    dword_10A09AB0 = 0;
    dword_10A09AB4 = 0;
    dword_10A09AB8 = 0;
    result = 0;
  }
  return result;
}
// 100B37E0: using guessed type char *off_100B37E0;
// 109576A0: using guessed type int dword_109576A0;
// 10A09AB0: using guessed type int dword_10A09AB0;
// 10A09AB4: using guessed type int dword_10A09AB4;
// 10A09AB8: using guessed type int dword_10A09AB8;
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (1002BB10) --------------------------------------------------------
void *sub_1002BB10()
{
  dword_10A09AAC = -15;
  return sub_100304B0();
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (1002BB20) --------------------------------------------------------
signed int sub_1002BB20()
{
  return sub_10061AA0((int)&off_100B3D6C);
}
// 100B3D6C: using guessed type char *off_100B3D6C;

//----- (1002BB30) --------------------------------------------------------
int __cdecl sub_1002BB30(double a1, double a2)
{
  double *v2; // ecx@0
  double v3; // ST00_8@1
  double v4; // st7@1
  int result; // eax@4

  v3 = *v2;
  v4 = a1;
  if ( (HIDWORD(v3) & 0x7FF00000) == 2146435072 || a1 < *v2 || (v4 = a2, a2 > *v2) )
  {
    *v2 = v4;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002BB80) --------------------------------------------------------
void sub_1002BB80()
{
  dword_10A09AA8 = -15;
}
// 10A09AA8: using guessed type int dword_10A09AA8;

//----- (1002BB90) --------------------------------------------------------
signed int sub_1002BB90()
{
  return sub_10061AA0((int)&off_100B3D98);
}
// 100B3D98: using guessed type char *off_100B3D98;

//----- (1002BBA0) --------------------------------------------------------
char __usercall sub_1002BBA0@<al>(float *a1@<esi>)
{
  char result; // al@1
  int v2; // ecx@1
  __int16 v3; // dx@1
  double v4; // st7@4
  float v5; // ST08_4@6

  result = 0;
  *a1 = 9.9999996e24;
  v2 = dword_10A09AA8;
  v3 = *(_WORD *)(dword_10A09AA8 + 1456);
  if ( v3 == 3 || v3 == 5 )
  {
    if ( *(_BYTE *)(dword_10A09AA8 + 1296) )
    {
      v4 = sub_10046720(*(_DWORD *)(dword_10A09AA8 + 1292));
      v2 = dword_10A09AA8;
    }
    else
    {
      v4 = 0.0;
    }
    v5 = v4;
    result = 1;
    *a1 = *(float *)(v2 + 1520) * v5 + *(float *)(v2 + 1468);
  }
  return result;
}
// 10A09AA8: using guessed type int dword_10A09AA8;

//----- (1002BC10) --------------------------------------------------------
signed int sub_1002BC10()
{
  char v0; // bl@1
  signed int result; // eax@3

  v0 = 1;
  if ( (unsigned __int8)sub_1002BB90() )
    v0 = *(_BYTE *)(dword_10A09AA8 + 1456);
  result = (unsigned __int8)v0;
  if ( (unsigned __int8)v0 >= 8u )
    result = 1;
  return result;
}
// 10A09AA8: using guessed type int dword_10A09AA8;

//----- (1002BC40) --------------------------------------------------------
bool __cdecl sub_1002BC40(char a1, int a2)
{
  bool v2; // bl@1
  double v3; // st7@4
  int v4; // eax@4
  int v5; // ecx@8
  int v6; // eax@8
  double v7; // st5@14
  double v8; // st6@14
  float v9; // ST40_4@15
  double v10; // st5@16
  double v11; // st7@19
  float v13; // ST40_4@23
  float v14; // [sp+40h] [bp-10h]@5
  float v15; // [sp+40h] [bp-10h]@12
  float v16; // [sp+40h] [bp-10h]@16
  int v17; // [sp+44h] [bp-Ch]@8
  float v18; // [sp+48h] [bp-8h]@9
  float v19; // [sp+4Ch] [bp-4h]@9

  v2 = 0;
  if ( sub_10060D80(2047, a2, 16) )
  {
    *(double *)a2 = 0.68067840827779;
    *(double *)(a2 + 8) = -1.658062789394617;
  }
  if ( (unsigned __int8)sub_1002BB90() )
  {
    sub_10060A60(101, 10000);
    v3 = 0.0;
    v4 = dword_10A09AA8;
    v2 = *(_WORD *)(dword_10A09AA8 + 1456) > 1u;
    if ( *(_BYTE *)(dword_10A09AA8 + 1296) )
    {
      v14 = sub_10046720(*(_DWORD *)(dword_10A09AA8 + 1292));
      v4 = dword_10A09AA8;
      v3 = 0.0;
    }
    else
    {
      v14 = 0.0;
    }
    if ( v2 )
    {
      v5 = *(_DWORD *)(v4 + 1524);
      v6 = v4 + 1524;
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v6 + 12);
      sub_1002BB30(6.2831853071796, -6.2831853071796);
      sub_1002BB30(6.2831853071796, -6.2831853071796);
      sub_100684E0(v14, dword_10A09AA8 + 1512, (int)&v17);
      v4 = dword_10A09AA8;
      v3 = 0.0;
    }
    else
    {
      *(float *)&v17 = v3;
      v18 = v3;
      v19 = v3;
    }
    if ( a1 == 1 )
    {
      sub_100684B0((int)&v17, v4 + 1432, (int)&v17);
      v3 = 0.0;
      v4 = dword_10A09AA8;
    }
    v15 = *(float *)(v4 + 1280);
    if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || v15 > 0.0053898906 )
    {
      v8 = 0.0053898906;
    }
    else
    {
      v7 = v15;
      v8 = 0.0053898906;
      if ( v15 >= v3 )
        goto LABEL_16;
    }
    v9 = v3;
    v7 = v9;
LABEL_16:
    *(double *)a2 = v7 * v18 + *(double *)a2;
    v16 = *(float *)(dword_10A09AA8 + 1284);
    v10 = v16;
    if ( (LODWORD(v16) & 0x7F800000) == 2139095040 || v10 > v8 || v10 < v3 )
    {
      v13 = v3;
      v11 = v13;
    }
    else
    {
      v11 = v16;
    }
    *(double *)(a2 + 8) = v11 * *(float *)&v17 + *(double *)(a2 + 8);
    sub_10060A00(101);
    sub_10043A50(a2);
  }
  return v2;
}
// 10A09AA8: using guessed type int dword_10A09AA8;

//----- (1002BE60) --------------------------------------------------------
char __cdecl sub_1002BE60(float *a1)
{
  char v1; // bl@1

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_1002BB90() )
  {
    sub_10060A60(101, 60000);
    v1 = sub_1002BBA0(a1);
    sub_10060A00(101);
  }
  return v1;
}

//----- (1002BEA0) --------------------------------------------------------
char sub_1002BEA0()
{
  char v0; // bl@1

  v0 = 0;
  if ( (unsigned __int8)sub_1002BB90() )
  {
    sub_10060A60(101, 10000);
    if ( !*(_BYTE *)(dword_10A09AA8 + 1444)
      || !*(_BYTE *)(dword_10A09AA8 + 1451)
      || (v0 = 1, *(_WORD *)(dword_10A09AA8 + 1456) <= 1u)
      || *(float *)(dword_10A09AA8 + 1480) <= 15.433242 )
    {
      v0 = 0;
    }
    sub_10060A00(101);
  }
  return v0;
}
// 10A09AA8: using guessed type int dword_10A09AA8;

//----- (1002BF10) --------------------------------------------------------
bool __cdecl sub_1002BF10(float *a1)
{
  bool v1; // bl@1
  double v2; // st7@3

  *a1 = 9.9999996e24;
  v1 = 0;
  if ( (unsigned __int8)sub_1002BB90() )
  {
    sub_10060A60(101, 10000);
    if ( *(_BYTE *)(dword_10A09AA8 + 1444) )
      v2 = (double)(unsigned int)(sub_10060900() - *(_DWORD *)(dword_10A09AA8 + 1292))
         / 1000.0
         * *(float *)(dword_10A09AA8 + 1488)
         + *(float *)(dword_10A09AA8 + 1484);
    else
      v2 = *(float *)(dword_10A09AA8 + 1484);
    *a1 = v2;
    *a1 = sub_100680D0(*a1);
    v1 = *(_WORD *)(dword_10A09AA8 + 1456) > 1u;
    sub_10060A00(101);
  }
  return v1;
}
// 10A09AA8: using guessed type int dword_10A09AA8;

//----- (1002BFC0) --------------------------------------------------------
bool __cdecl sub_1002BFC0(float *a1)
{
  bool v1; // bl@1
  int v2; // eax@2

  *a1 = 0.0;
  v1 = 0;
  if ( (unsigned __int8)sub_1002BB90() )
  {
    sub_10060A60(101, 60000);
    v2 = dword_10A09AA8;
    if ( *(_BYTE *)(dword_10A09AA8 + 1451) )
    {
      *a1 = *(float *)(dword_10A09AA8 + 1480);
      v2 = dword_10A09AA8;
    }
    v1 = *(_WORD *)(v2 + 1456) > 1u;
    sub_10060A00(101);
  }
  return v1;
}
// 10A09AA8: using guessed type int dword_10A09AA8;

//----- (1002C020) --------------------------------------------------------
signed int sub_1002C020()
{
  return 1000;
}

//----- (1002C050) --------------------------------------------------------
int sub_1002C050()
{
  return sub_10046770((int)off_100B42D8);
}
// 100B42D8: using guessed type int (*off_100B42D8[4])();

//----- (1002C060) --------------------------------------------------------
bool __cdecl sub_1002C060(signed int a1, signed int a2, _BYTE *a3)
{
  bool result; // al@2
  signed int v4; // ebx@3
  signed int v5; // edi@3
  signed int i; // esi@5

  if ( a3 )
  {
    v4 = a1;
    v5 = 0;
    if ( a1 < 0 )
    {
      v4 = -a1;
      *a3 = 45;
      v5 = 1;
    }
    for ( i = a2; i > v5; v4 /= 10 )
      a3[--i] = v4 % 10 + 48;
    result = v4 == 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002C0D0) --------------------------------------------------------
void __cdecl sub_1002C0D0(const char *a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax@2

  if ( a1 )
  {
    v3 = strlen(a1);
    if ( v3 < a2 )
      memset((void *)&a1[v3], a3, a2 - v3);
    a1[a2] = 0;
  }
}

//----- (1002C120) --------------------------------------------------------
int __cdecl sub_1002C120(int a1, _BYTE *a2, int a3)
{
  int v3; // esi@2
  int v4; // eax@2
  _BYTE *v5; // ecx@3
  int result; // eax@7

  if ( a3 <= 0 )
    goto LABEL_11;
  v3 = a3 - 1;
  v4 = 0;
  if ( a3 - 1 > 0 )
  {
    v5 = a2;
    do
    {
      if ( !*v5 )
        break;
      v5[a1 - (_DWORD)a2] = *v5;
      ++v4;
      ++v5;
    }
    while ( v4 < v3 );
  }
  *(_BYTE *)(v4 + a1) = 0;
  *(_BYTE *)(v3 + a1) = 0;
  if ( a2[v4] )
LABEL_11:
    result = -1;
  else
    result = v4 + 1;
  return result;
}

//----- (1002C170) --------------------------------------------------------
signed int __cdecl sub_1002C170(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // ebx@2
  _BYTE *v5; // edi@2
  int v6; // esi@3
  int v7; // eax@3
  signed int result; // eax@7

  v3 = a3;
  if ( a3 <= 0 )
  {
LABEL_7:
    result = -2;
  }
  else
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = tolower(*v5++);
      v7 = tolower(*v4++);
      if ( v6 > v7 )
        return 1;
      if ( v6 < v7 )
        return -1;
      if ( !v6 )
        break;
      if ( --v3 <= 0 )
        goto LABEL_7;
    }
    result = 0;
  }
  return result;
}

//----- (1002C1E0) --------------------------------------------------------
int __cdecl sub_1002C1E0(void *a1, size_t a2)
{
  _BYTE *v2; // eax@1
  int result; // eax@2

  v2 = memchr(a1, 0, a2);
  if ( v2 )
    result = v2 - (_BYTE *)a1;
  else
    result = -2;
  return result;
}

//----- (1002C210) --------------------------------------------------------
int __cdecl sub_1002C210(int a1, char *a2, int a3)
{
  int v3; // eax@3
  int i; // esi@5
  int v5; // esi@8
  int result; // eax@8

  if ( a1 && a2 )
  {
    v3 = a3;
    if ( !a3 )
      v3 = strlen((const char *)a1);
    for ( i = v3 - 1; i >= 0; --i )
    {
      if ( !strchr(a2, *(_BYTE *)(i + a1)) )
        break;
    }
    v5 = i + 1;
    *(_BYTE *)(v5 + a1) = 0;
    result = v5;
  }
  else
  {
    result = a3;
  }
  return result;
}

//----- (1002C270) --------------------------------------------------------
int __cdecl sub_1002C270(char *a1, size_t a2, char *a3, va_list a4)
{
  int result; // eax@2

  if ( (signed int)a2 > 0 )
  {
    result = _vsnprintf(a1, a2, a3, a4);
    if ( result < 0 )
      result = -1;
    a1[a2 - 1] = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1002C2B0) --------------------------------------------------------
int sub_1002C2B0(char *a1, size_t a2, char *a3, ...)
{
  int result; // eax@1
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, a3);
  result = sub_1002C270(a1, a2, a3, va);
  if ( result < 0 )
    result = -1;
  return result;
}

//----- (1002C2E0) --------------------------------------------------------
int __cdecl sub_1002C2E0(const char *a1, _BYTE *a2, int a3)
{
  unsigned int v3; // kr00_4@1

  v3 = strlen(a1);
  return sub_1002C120((int)&a1[v3], a2, a3 - v3);
}

//----- (1002C320) --------------------------------------------------------
int __cdecl sub_1002C320(int a1, int a2)
{
  return sub_1002C210(a1, "_ ", a2);
}

//----- (1002C340) --------------------------------------------------------
void sub_1002C340()
{
  float v0; // ST00_4@1

  v0 = sub_10043A40();
  sub_10063470(v0);
}
// 10043A40: using guessed type double sub_10043A40(void);

//----- (1002C360) --------------------------------------------------------
char __thiscall sub_1002C360(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( sub_10060D80(3137, (int)&v2 + 3, 1) )
  {
    sub_10061C40(86, (_BYTE *)&v2 + 3);
    sub_10060ED0(3137, (int)&v2 + 3, 1);
  }
  return BYTE3(v2);
}

//----- (1002C3A0) --------------------------------------------------------
char __thiscall sub_1002C3A0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 0;
  sub_10061000(6077, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1002C3D0) --------------------------------------------------------
char __fastcall sub_1002C3D0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10061C40(3, (_BYTE *)&v2 + 2);
  if ( sub_10060D80(3003, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10060F90(3003, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1002C420) --------------------------------------------------------
char __thiscall sub_1002C420(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  BYTE2(v2) = 1;
  sub_10061000(3008, (char *)&v2 + 3, 1, (char *)&v2 + 2);
  return BYTE3(v2);
}

//----- (1002C450) --------------------------------------------------------
int sub_1002C450()
{
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@1

  v1 = 0;
  sub_10061000(3012, &v2, 4, &v1);
  return v2;
}

//----- (1002C480) --------------------------------------------------------
char __fastcall sub_1002C480(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  sub_10061C40(42, (_BYTE *)&v2 + 2);
  if ( sub_10060D80(3162, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 0x3Fu) )
  {
    sub_10060F90(3162, (int)&v2 + 2, 1);
    result = BYTE2(v2);
  }
  return result;
}

//----- (1002C4D0) --------------------------------------------------------
char __cdecl sub_1002C4D0(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_is_booting(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068512: using guessed type int __cdecl SYS_pvg_is_booting(_DWORD);
// 10068518: using guessed type int SYS_enter_krnl(void);

//----- (1002C4F0) --------------------------------------------------------
bool __thiscall sub_1002C4F0(void *this)
{
  return sub_1002C3D0((int)this) == 24;
}

//----- (1002C500) --------------------------------------------------------
int __cdecl sub_1002C500(int a1, char *a2)
{
  if ( (unsigned __int8)a1 >= 0x5Fu )
    sub_10028BC0("..\\lib\\adl\\sys_usr.c", 5389, 1, 0);
  if ( !a2 )
    sub_10028BC0("..\\lib\\adl\\sys_usr.c", 5390, 1, 0);
  SYS_enter_krnl();
  SYS_pvg_var_ctrl(a1, a2);
  return SYS_exit_krnl();
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006851E: using guessed type int __cdecl SYS_pvg_var_ctrl(_DWORD, _DWORD);

//----- (1002C560) --------------------------------------------------------
char __thiscall sub_1002C560(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1002C500(35, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1002C580) --------------------------------------------------------
char __thiscall sub_1002C580(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1002C500(18, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1002C5A0) --------------------------------------------------------
char __thiscall sub_1002C5A0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1002C500(17, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1002C5C0) --------------------------------------------------------
int __thiscall sub_1002C5C0(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1002C500(29, (char *)&v2);
  return (int)v2;
}

//----- (1002C5E0) --------------------------------------------------------
char __thiscall sub_1002C5E0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1002C500(34, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1002C600) --------------------------------------------------------
char __thiscall sub_1002C600(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_1002C500(44, (char *)&v2 + 3);
  return BYTE3(v2);
}

//----- (1002C620) --------------------------------------------------------
int __cdecl sub_1002C620(char a1)
{
  return sub_1002C500(56, &a1);
}

//----- (1002C630) --------------------------------------------------------
char __thiscall sub_1002C630(void *this)
{
  char result; // al@1
  bool v2; // zf@2
  void *v3; // [sp-2h] [bp-4h]@1

  v3 = this;
  sub_1002C500(4, (char *)&v3 + 3);
  result = BYTE3(v3);
  if ( BYTE3(v3) == 1 )
  {
    v2 = SIM_proc_rqst(50) == 0;
    result = 2;
    if ( v2 )
      result = BYTE3(v3);
  }
  return result;
}
// 10068506: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (1002C660) --------------------------------------------------------
int __thiscall sub_1002C660(void *this)
{
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  sub_1002C500(46, (char *)&v2);
  return (int)v2;
}

//----- (1002C680) --------------------------------------------------------
bool __cdecl sub_1002C680(char a1)
{
  void *v1; // ecx@0
  bool result; // al@2
  void *v3; // ecx@4

  switch ( a1 )
  {
    case 5:
      result = sub_10043CE0(0) == 1;
      break;
    case 6:
      goto LABEL_3;
    case 9:
      if ( sub_1002C660(v1) & 3 || sub_1002C600(v3) == 1 )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 8:
      result = sub_1002C600(v1) != 1;
      break;
    default:
      result = sub_1002C600(v1) == 1;
      break;
  }
  return result;
}

//----- (1002C6F0) --------------------------------------------------------
int __cdecl sub_1002C6F0(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int result; // eax@1
  unsigned int v4; // edx@1
  char v5; // bl@8
  char v6; // dl@13
  char v7; // cl@13

  v2 = a2 / 0x15180 % 0x5B5;
  result = a1;
  v4 = 4 * (a2 / 0x15180 / 0x5B5) + 1990;
  *(_WORD *)(a1 + 2) = v4;
  if ( v2 > 0x16D )
  {
    do
    {
      v2 -= 365;
      if ( !((unsigned __int16)v4 % 4) )
        --v2;
      LOWORD(v4) = v4 + 1;
    }
    while ( v2 > 0x16D );
    *(_WORD *)(a1 + 2) = v4;
  }
  if ( v2 >= 1 )
  {
    v5 = 0;
    if ( v2 > 0x3B && !(*(_WORD *)(a1 + 2) % 4) )
    {
      --v2;
      v5 = 1;
    }
    *(_BYTE *)a1 = 12;
    if ( v2 <= 0x14E )
    {
      do
        --*(_BYTE *)a1;
      while ( v2 <= *(_WORD *)&word_100B55A6[2 * *(_BYTE *)a1] );
    }
    v6 = *(_BYTE *)a1;
    v7 = v2 - word_100B55A6[2 * *(_BYTE *)a1];
    *(_BYTE *)(a1 + 1) = v7;
    if ( v5 == 1 && v6 == 2 )
      *(_BYTE *)(a1 + 1) = v7 + 1;
  }
  else
  {
    --*(_WORD *)(a1 + 2);
    *(_BYTE *)a1 = 12;
    *(_BYTE *)(a1 + 1) = 31;
  }
  return result;
}

//----- (1002C7E0) --------------------------------------------------------
int __cdecl sub_1002C7E0(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( (a3 - a2) % 4 )
    result = -1;
  else
    result = a1 + 126230400 * ((a3 - a2) / 4);
  return result;
}

//----- (1002C820) --------------------------------------------------------
int __cdecl sub_1002C820(int *a1, unsigned int a2)
{
  int result; // eax@1
  int v3; // eax@9
  int v4; // ecx@9
  signed int v5; // eax@9
  int i; // ecx@9
  int v7; // ecx@13

  result = a2 >> 16;
  if ( HIWORD(a2) > 0x7C5u )
  {
    if ( HIWORD(a2) > 0x84Eu
      || HIWORD(a2) == 2126 && (unsigned __int8)a2 > 2u
      || HIWORD(a2) == 2126 && (_BYTE)a2 == 2 && BYTE1(a2) > 5u )
    {
      *a1 = -23296;
    }
    else
    {
      v3 = (HIWORD(a2) - 1990) / 4;
      v4 = v3;
      v5 = 4 * v3 + 1990;
      for ( i = 1461 * v4; v5 < HIWORD(a2); ++v5 )
      {
        i += 365;
        if ( !(v5 % 4) )
          ++i;
      }
      v7 = *(_WORD *)&word_100B55A6[2 * (unsigned __int8)a2] + i;
      if ( (unsigned __int8)a2 > 2u && !(HIWORD(a2) % 4) )
        ++v7;
      result = 86400 * (v7 + BYTE1(a2));
      *a1 = result;
    }
  }
  else
  {
    result = (int)a1;
    *a1 = 0;
  }
  return result;
}

//----- (1002C910) --------------------------------------------------------
__int16 __cdecl sub_1002C910(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  __int16 result; // ax@1

  v2 = a2 % 0x15180 % 0xE10;
  *(_WORD *)a1 = a2 % 0x15180 / 0xE10;
  *(_BYTE *)(a1 + 2) = v2 / 0x3C;
  result = 60 * (char)(v2 / 0x3C);
  *(_BYTE *)(a1 + 3) = v2 % 0x3C;
  return result;
}

//----- (1002C960) --------------------------------------------------------
int __cdecl sub_1002C960(int *a1, unsigned int a2)
{
  int result; // eax@1

  result = (a2 >> 24) + 60 * ((unsigned __int8)(a2 >> 16) + 60 * (unsigned __int16)a2);
  *a1 = result;
  return result;
}

//----- (1002C990) --------------------------------------------------------
int __cdecl sub_1002C990(signed __int64 a1)
{
  int result; // eax@2

  if ( a1 >= 116444736000000000i64 )
    result = sub_1002C7E0((a1 - 116444736000000000i64) / 10000000, 1990, 1970) + 86400;
  else
    result = 0;
  return result;
}

//----- (1002C9E0) --------------------------------------------------------
__int16 __cdecl sub_1002C9E0(unsigned int *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3; // esi@1
  __int16 result; // ax@1
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1

  v3 = *a1;
  sub_1002C910((int)&v5, *a1);
  sub_1002C6F0((int)&v6, v3);
  *a3 = (unsigned __int8)(BYTE3(v5) >> 1) | (unsigned __int16)(32 * (BYTE2(v5) | (unsigned __int16)((_WORD)v5 << 6)));
  result = BYTE1(v6);
  *a2 = BYTE1(v6) | (unsigned __int16)(32 * ((unsigned __int8)v6 | (unsigned __int16)(16 * (HIWORD(v6) - 60))));
  return result;
}

//----- (1002CA60) --------------------------------------------------------
_DWORD *__cdecl sub_1002CA60(unsigned int a1, unsigned int a2, _DWORD *a3)
{
  unsigned int v3; // ecx@0
  unsigned int v4; // ecx@1
  _DWORD *result; // eax@1
  bool v6; // zf@2
  unsigned int v7; // [sp+0h] [bp-4h]@1

  v7 = v3;
  v4 = a2;
  result = (_DWORD *)a1;
  if ( (_WORD)a2 )
    v6 = (_WORD)a2 == -1;
  else
    v6 = (_WORD)a1 == 0;
  if ( v6 || (_WORD)a1 == -1 )
  {
    *a3 = -1;
  }
  else
  {
    BYTE3(a2) = 2 * (a2 & 0x1F);
    BYTE2(a2) = (v4 >> 5) & 0x3F;
    LOWORD(a2) = (unsigned __int16)v4 >> 11;
    HIWORD(v7) = ((unsigned __int16)a1 >> 9) + 1980;
    BYTE1(v7) = a1 & 0x1F;
    LOBYTE(v7) = (a1 >> 5) & 0xF;
    sub_1002C960((int *)&a2, a2);
    sub_1002C820((int *)&v7, v7);
    result = a3;
    *a3 = a2 + v7;
  }
  return result;
}

//----- (1002CB10) --------------------------------------------------------
char __cdecl sub_1002CB10(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@11
  int v4; // eax@16
  int v6; // [sp+8h] [bp-54h]@1
  int v7; // [sp+Ch] [bp-50h]@1
  int v8; // [sp+10h] [bp-4Ch]@1
  int v9; // [sp+14h] [bp-48h]@1
  int v10; // [sp+18h] [bp-44h]@1
  char v11; // [sp+1Ch] [bp-40h]@16

  LOBYTE(v2) = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( a1 == 28 || a1 == 29 || a1 == 30 || a1 == 31 || a1 == 32 || a1 == 48 || a1 == 33 || a1 == 34 )
  {
    v2 = sub_1002CC90((_DWORD *)a2, 2u, (int)&unk_100B60B8, 8, 77, 77);
    if ( v2 != 77 )
    {
      if ( *(_WORD *)a2 == -32768 )
      {
        v3 = *(_WORD *)(a2 + 10) + 16;
      }
      else if ( *(_WORD *)a2 == -32767 )
      {
        v3 = *(_DWORD *)(a2 + 4) + 8;
      }
      else
      {
        v3 = dword_100B60BC[2 * v2] + 4;
      }
      v7 = v3;
      v10 = 65;
      v6 = a2;
      v9 = 10;
      v2 = sub_10060AF0(a1, (int)&v6);
      if ( v2 == 16 )
      {
        v4 = sub_10060830();
        sub_1002C2B0(&v11, 0x3Cu, "message queue timed out sending from: %d to %d", v4, a1);
        LOBYTE(v2) = sub_10028BC0("..\\lib\\adl\\iop_msg_intf.c", 433, 0, &v11);
      }
    }
  }
  return v2;
}
// 100B60BC: using guessed type int dword_100B60BC[];

//----- (1002CC30) --------------------------------------------------------
char __cdecl sub_1002CC30(int a1)
{
  return sub_1002CB10(34, a1);
}

//----- (1002CC40) --------------------------------------------------------
char __cdecl sub_1002CC40(int a1)
{
  return sub_1002CB10(28, a1);
}

//----- (1002CC50) --------------------------------------------------------
char __cdecl sub_1002CC50(int a1)
{
  return sub_1002CB10(29, a1);
}

//----- (1002CC60) --------------------------------------------------------
char __cdecl sub_1002CC60(int a1)
{
  return sub_1002CB10(30, a1);
}

//----- (1002CC70) --------------------------------------------------------
char __cdecl sub_1002CC70(int a1)
{
  return sub_1002CB10(32, a1);
}

//----- (1002CC80) --------------------------------------------------------
char __cdecl sub_1002CC80(int a1)
{
  return sub_1002CB10(31, a1);
}

//----- (1002CC90) --------------------------------------------------------
int __cdecl sub_1002CC90(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@6
  int v7; // ebx@6
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  _DWORD *v21; // esi@23
  unsigned int v22; // ecx@23
  _DWORD *v23; // edx@23
  int v24; // edi@27
  int v25; // ecx@28
  _BYTE *v26; // edx@28
  _BYTE *v27; // esi@28
  int v28; // ecx@30
  _BYTE *v29; // edx@30
  _BYTE *v30; // esi@30
  _BYTE *v31; // edx@32
  _BYTE *v32; // esi@32
  int v33; // edx@33
  signed int v34; // ecx@34
  int v35; // [sp+4h] [bp-4h]@6

  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && a5 > 0 )
  {
    result = a5 - 1;
    v7 = a3 + a4 * (a5 - 1);
    v35 = a5 - 1;
    if ( a5 - 1 > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v35;
        if ( v20 )
        {
          v7 -= a4;
          result = v35 - 1;
          v35 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a1;
    v22 = a2;
    v23 = (_DWORD *)v7;
    if ( a2 < 4 )
    {
LABEL_26:
      if ( !v22 )
        goto LABEL_36;
    }
    else
    {
      while ( *v21 == *v23 )
      {
        v22 -= 4;
        ++v23;
        ++v21;
        if ( v22 < 4 )
          goto LABEL_26;
      }
    }
    v24 = *(_BYTE *)v21 - *(_BYTE *)v23;
    if ( *(_BYTE *)v21 != *(_BYTE *)v23
      || (v25 = v22 - 1, v26 = (char *)v23 + 1, v27 = (char *)v21 + 1, v25)
      && ((v24 = *v27 - *v26, *v27 != *v26)
       || (v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, v28)
       && ((v24 = *v30 - *v29, *v30 != *v29)
        || (v31 = v29 + 1, v32 = v30 + 1, v28 != 1) && (v33 = *v31, v24 = *v32 - v33, *v32 != v33))) )
    {
      v34 = 1;
      if ( v24 <= 0 )
        v34 = -1;
LABEL_37:
      if ( !v34 )
        return result;
      return a6;
    }
LABEL_36:
    v34 = 0;
    goto LABEL_37;
  }
  return a6;
}

//----- (1002CE20) --------------------------------------------------------
int __cdecl sub_1002CE20(_DWORD *a1, unsigned int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int result; // eax@1
  int v7; // ebx@1
  _DWORD *v8; // esi@7
  unsigned int v9; // ecx@7
  _DWORD *v10; // edx@7
  int v11; // edi@11
  int v12; // ecx@12
  _BYTE *v13; // edx@12
  _BYTE *v14; // esi@12
  int v15; // ecx@14
  _BYTE *v16; // edx@14
  _BYTE *v17; // esi@14
  _BYTE *v18; // edx@16
  _BYTE *v19; // esi@16
  signed int v20; // ecx@18
  unsigned int v21; // edx@23
  char *i; // ecx@23
  int v23; // [sp+20h] [bp+14h]@1

  v5 = a5;
  result = a5 - 1;
  v7 = a3 + a4 * (a5 - 1);
  v23 = a5 - 1;
  if ( a1 && (signed int)a2 > 0 && a3 && a4 > 0 && v5 > 0 )
  {
    if ( result > 0 )
    {
      while ( 1 )
      {
        v8 = a1;
        v9 = a2;
        v10 = (_DWORD *)v7;
        if ( a2 < 4 )
        {
LABEL_10:
          if ( !v9 )
            goto LABEL_20;
        }
        else
        {
          while ( *v8 == *v10 )
          {
            v9 -= 4;
            ++v10;
            ++v8;
            if ( v9 < 4 )
              goto LABEL_10;
          }
        }
        v11 = *(_BYTE *)v8 - *(_BYTE *)v10;
        if ( *(_BYTE *)v8 != *(_BYTE *)v10
          || (v12 = v9 - 1, v13 = (char *)v10 + 1, v14 = (char *)v8 + 1, v12)
          && ((v11 = *v14 - *v13, *v14 != *v13)
           || (v15 = v12 - 1, v16 = v13 + 1, v17 = v14 + 1, v15)
           && ((v11 = *v17 - *v16, *v17 != *v16)
            || (v18 = v16 + 1, v19 = v17 + 1, v15 != 1) && (v11 = *v19 - *v18, *v19 != *v18))) )
        {
          v20 = 1;
          if ( v11 <= 0 )
            v20 = -1;
          goto LABEL_21;
        }
LABEL_20:
        v20 = 0;
LABEL_21:
        result = v23;
        if ( v20 )
        {
          v7 -= a4;
          result = v23 - 1;
          v23 = result;
          if ( result > 0 )
            continue;
        }
        break;
      }
    }
    v21 = a2;
    for ( i = (char *)v7; v21 >= 4; i += 4 )
    {
      if ( *(_DWORD *)&i[(_DWORD)a1 - v7] != *(_DWORD *)i )
        break;
      v21 -= 4;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002CF40) --------------------------------------------------------
char sub_1002CF40()
{
  int v1; // [sp+0h] [bp-4h]@1

  v1 = 0;
  LOWORD(v1) = -32761;
  return sub_1002CC40((int)&v1);
}

//----- (1002CF60) --------------------------------------------------------
char __cdecl sub_1002CF60(char a1, _DWORD *a2)
{
  int v2; // eax@1
  char result; // al@2

  v2 = sub_1002CC90(&a1, 2u, (int)&unk_100F700A, 8, 415, -1);
  if ( v2 == -1 )
  {
    result = 0;
  }
  else
  {
    *a2 = *(&dword_100F700C + 2 * v2);
    result = 1;
  }
  return result;
}

//----- (1002CFA0) --------------------------------------------------------
__int16 __usercall sub_1002CFA0@<ax>(int a1@<edi>, char a2)
{
  __int16 v2; // ax@1
  __int16 result; // ax@3

  v2 = sub_1002CC90(&a2, 2u, (int)&unk_100F7E80, 16, 18, -1);
  if ( v2 == -1 )
  {
LABEL_11:
    result = -1;
  }
  else
  {
    switch ( a1 )
    {
      case 1:
        result = word_100F7E82[8 * v2];
        break;
      case 2:
        result = word_100F7E86[8 * v2];
        break;
      case 4:
        result = word_100F7E84[8 * v2];
        break;
      case 64:
        result = word_100F7E88[8 * v2];
        break;
      case 128:
        result = word_100F7E8A[8 * v2];
        break;
      case 16:
        result = word_100F7E8C[8 * v2];
        break;
      case 32:
        result = word_100F7E8E[8 * v2];
        break;
      default:
        sub_1002C2B0(byte_109576A8, 0x64u, "Unrecognized LRU (%u) passed into alert processing.", a1);
        sub_10028BC0("..\\lib\\adl\\sys_updt_alrt_data.c", 1037, 0, byte_109576A8);
        goto LABEL_11;
    }
  }
  return result;
}
// 100F7E82: using guessed type __int16 word_100F7E82[];
// 100F7E84: using guessed type __int16 word_100F7E84[];
// 100F7E86: using guessed type __int16 word_100F7E86[];
// 100F7E88: using guessed type __int16 word_100F7E88[];
// 100F7E8A: using guessed type __int16 word_100F7E8A[];
// 100F7E8C: using guessed type __int16 word_100F7E8C[];
// 100F7E8E: using guessed type __int16 word_100F7E8E[];

//----- (1002D140) --------------------------------------------------------
signed __int16 __usercall sub_1002D140@<ax>(void *a1@<ecx>, signed __int16 a2@<bx>, const char *a3@<esi>)
{
  signed __int16 v3; // di@1
  void *v4; // ecx@4
  int v5; // eax@19
  char v7; // [sp+4h] [bp-38h]@2

  v3 = a2;
  if ( a3 )
    memset(&v7, 0, 0x33u);
  if ( a2 == 300 )
  {
    switch ( sub_1002C660(a1) )
    {
      case 1:
        v3 = 380;
        if ( !a3 )
          return v3;
        sub_1002C2E0(&v7, "PFD1", 51);
        break;
      case 4:
        v3 = 381;
        if ( !a3 )
          return v3;
        sub_1002C2E0(&v7, "MFD1", 51);
        break;
      case 2:
        v3 = 382;
        if ( !a3 )
          return v3;
        sub_1002C2E0(&v7, "PFD2", 51);
        break;
      case 64:
        v3 = 383;
        if ( !a3 )
          return v3;
        sub_1002C2E0(&v7, "GTC1", 51);
        break;
      case 128:
        v3 = 384;
        if ( !a3 )
          return v3;
        sub_1002C2E0(&v7, "GTC2", 51);
        break;
      case 16:
        v3 = 385;
        if ( !a3 )
          return v3;
        sub_1002C2E0(&v7, "GTC3", 51);
        break;
      case 32:
        v3 = 386;
        if ( !a3 )
          return v3;
        sub_1002C2E0(&v7, "GTC4", 51);
        break;
      default:
        v3 = -1;
        v5 = sub_1002C660(v4);
        sub_1002C2B0(byte_109576A8, 0x64u, "Unrecognized LRU (%u) passed into DB error alert processing.", v5);
        sub_10028BC0("..\\lib\\adl\\sys_updt_alrt_data.c", 1286, 0, byte_109576A8);
        break;
    }
  }
  if ( a3 )
    sub_1002C2E0(a3, &v7, 51);
  return v3;
}

//----- (1002D390) --------------------------------------------------------
char __cdecl sub_1002D390(signed __int16 a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  char result; // al@2
  char v4; // [sp+Ah] [bp-6h]@1
  char v5; // [sp+Bh] [bp-5h]@1
  int v6; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = (unsigned __int16)sub_1002D140(v1, a1, 0);
  v2 = sub_1002CC90(&v6, 2u, (int)&unk_100F700A, 8, 415, -1);
  if ( v2 < 0 )
  {
    sub_10028BC0("..\\lib\\adl\\sys_updt_alrt_data.c", 152, 0, 0);
    result = 0;
  }
  else
  {
    sub_10061000(*(&dword_100F700C + 2 * v2), &v4, 1, &v5);
    result = v4;
  }
  return result;
}

//----- (1002D420) --------------------------------------------------------
char __cdecl sub_1002D420(char a1, int a2)
{
  __int16 v2; // ax@1

  v2 = sub_1002CFA0(a2, a1);
  return sub_1002D390(v2);
}

//----- (1002D440) --------------------------------------------------------
int __cdecl sub_1002D440(signed __int16 a1)
{
  void *v1; // ecx@1
  signed __int16 v2; // ax@1
  int v3; // esi@2
  int result; // eax@6
  char v5; // [sp+Ah] [bp-42h]@1
  char v6; // [sp+Bh] [bp-41h]@1
  int v7; // [sp+Ch] [bp-40h]@1
  int v8; // [sp+10h] [bp-3Ch]@1
  char v9; // [sp+14h] [bp-38h]@1

  memset(&v9, 0, 0x33u);
  v5 = 0;
  v6 = 0;
  v2 = sub_1002D140(v1, a1, 0);
  v8 = (unsigned __int16)v2;
  if ( sub_1002CF60(v2, &v7) )
  {
    v3 = v7;
    if ( !sub_10061000(v7, &v5, 1, &v6) && v5 )
    {
      v5 = 0;
      sub_10060ED0(v3, (int)&v5, 1);
    }
  }
  else
  {
    sub_1002C2B0(
      byte_109576A8,
      0x64u,
      "An attempt to clear a system trigger was performed with an invalid trigger id (%u)",
      (unsigned __int16)a1);
    sub_10028BC0("..\\lib\\adl\\sys_updt_alrt_data.c", 522, 0, byte_109576A8);
  }
  result = (unsigned __int16)sub_1002CC90(&v8, 2u, (int)&unk_100F7D08, 12, 32, -1);
  if ( (_WORD)result != -1 )
    result = sub_10060ED0(dword_100F7D04[3 * (signed __int16)result], (int)&v9, 51);
  return result;
}
// 100F7D04: using guessed type int dword_100F7D04[];

//----- (1002D550) --------------------------------------------------------
char __cdecl sub_1002D550(unsigned __int16 a1)
{
  int v1; // esi@2
  int v2; // eax@2
  char v4; // [sp+6h] [bp-6h]@1
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v5 = 1;
  if ( sub_1002CF60(a1, &v6) )
  {
    v1 = v6;
    v2 = sub_10061000(v6, &v4, 1, &v5);
    if ( !v2 && !v4 )
    {
      v4 = 1;
      LOBYTE(v2) = sub_10060ED0(v1, (int)&v4, 1);
    }
  }
  else
  {
    sub_1002C2B0(
      byte_109576A8,
      0x64u,
      "An attempt to set a system trigger was performed with an invalid trigger id (%u)",
      a1);
    LOBYTE(v2) = sub_10028BC0("..\\lib\\adl\\sys_updt_alrt_data.c", 666, 0, byte_109576A8);
  }
  return v2;
}

//----- (1002D5F0) --------------------------------------------------------
char __cdecl sub_1002D5F0(char a1)
{
  char result; // al@1

  result = -80;
  switch ( a1 )
  {
    case 3:
      result = -126;
      break;
    case 4:
      result = -123;
      break;
    case 5:
      result = -108;
      break;
    case 6:
      result = -105;
      break;
    default:
      return result;
  }
  return result;
}

//----- (1002D630) --------------------------------------------------------
char __cdecl sub_1002D630(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 3;
      break;
    case 1:
      result = 4;
      break;
    case 2:
      result = 5;
      break;
    case 3:
      result = 40;
      break;
    case 4:
      result = 41;
      break;
    case 5:
      result = 51;
      break;
    case 6:
      result = 52;
      break;
    default:
      sub_10028BC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 490, 0, 0);
      result = 67;
      break;
  }
  return result;
}

//----- (1002D6A0) --------------------------------------------------------
char __cdecl sub_1002D6A0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 74;
      break;
    case 1:
      result = 73;
      break;
    case 2:
      result = 75;
      break;
    case 3:
      result = -127;
      break;
    case 4:
      result = -124;
      break;
    case 5:
      result = -109;
      break;
    case 6:
      result = -106;
      break;
    default:
      sub_10028BC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 564, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1002D710) --------------------------------------------------------
signed int __cdecl sub_1002D710(char a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = 4;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 3:
      result = 64;
      break;
    case 4:
      result = 128;
      break;
    case 5:
      result = 16;
      break;
    case 6:
      result = 32;
      break;
    default:
      sub_10028BC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 638, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (1002D790) --------------------------------------------------------
char __cdecl sub_1002D790(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0:
      result = 13;
      break;
    case 1:
      result = 12;
      break;
    case 2:
      result = 14;
      break;
    case 3:
      result = -128;
      break;
    case 4:
      result = -125;
      break;
    case 5:
      result = -110;
      break;
    case 6:
      result = -107;
      break;
    default:
      sub_10028BC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 712, 0, 0);
      result = -80;
      break;
  }
  return result;
}

//----- (1002D800) --------------------------------------------------------
char __cdecl sub_1002D800(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 3:
      result = 0;
      break;
    case 4:
      result = 1;
      break;
    case 5:
      result = 2;
      break;
    case 0x28:
      result = 3;
      break;
    case 0x29:
      result = 4;
      break;
    case 0x33:
      result = 5;
      break;
    case 0x34:
      result = 6;
      break;
    default:
      sub_10028BC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 786, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1002D8B0) --------------------------------------------------------
char __cdecl sub_1002D8B0(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 4:
      result = 0;
      break;
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      if ( !(_BYTE)a1 )
        sub_10028BC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 859, 0, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1002D9C0) --------------------------------------------------------
char __cdecl sub_1002D9C0(int a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 1:
      result = 1;
      break;
    case 2:
      result = 2;
      break;
    case 4:
      result = 0;
      break;
    case 64:
      result = 3;
      break;
    case 128:
      result = 4;
      break;
    case 16:
      result = 5;
      break;
    case 32:
      result = 6;
      break;
    default:
      sub_10028BC0("..\\lib\\adl\\iop_cdu_unit_intf.c", 1096, 1, 0);
      result = 7;
      break;
  }
  return result;
}

//----- (1002DAC0) --------------------------------------------------------
char __cdecl sub_1002DAC0(char a1)
{
  return sub_10031C40((int)&unk_100B7020, a1, 0xBu);
}

//----- (1002DAE0) --------------------------------------------------------
char __cdecl sub_1002DAE0(char a1)
{
  return sub_10031C40((int)&unk_100B7038, a1, 0x13u);
}

//----- (1002DB00) --------------------------------------------------------
char __thiscall sub_1002DB00(void *this)
{
  int v1; // eax@1

  v1 = sub_1002C660(this);
  return sub_1002D9C0(v1);
}

//----- (1002DB10) --------------------------------------------------------
char __cdecl sub_1002DB10(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_1002DAC0(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_1002DB80(v2);
  return result;
}

//----- (1002DB40) --------------------------------------------------------
int __cdecl sub_1002DB40(char a1)
{
  return sub_1002CC90(&a1, 2u, (int)"+", 6, 177, 176);
}

//----- (1002DB70) --------------------------------------------------------
signed int __fastcall sub_1002DB70(unsigned __int8 a1)
{
  signed int result; // eax@1

  result = 176;
  if ( a1 < 0xB0u )
    result = a1;
  return result;
}

//----- (1002DB80) --------------------------------------------------------
char __cdecl sub_1002DB80(unsigned __int8 a1)
{
  return byte_100B70BC[6 * sub_1002DB70(a1)];
}

//----- (1002DBA0) --------------------------------------------------------
__int16 __cdecl sub_1002DBA0(unsigned __int8 a1)
{
  return *(_WORD *)&asc_100B70B8[6 * sub_1002DB70(a1)];
}

//----- (1002DBC0) --------------------------------------------------------
__int16 __cdecl sub_1002DBC0(unsigned __int8 a1)
{
  return word_100B70BA[3 * sub_1002DB70(a1)];
}
// 100B70BA: using guessed type __int16 word_100B70BA[];

//----- (1002DBE0) --------------------------------------------------------
char __cdecl sub_1002DBE0(int a1, int a2)
{
  char v2; // bl@1

  SYS_enter_krnl();
  v2 = SYS_pvg_alrt_id_is_set(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068524: using guessed type int __cdecl SYS_pvg_alrt_id_is_set(_DWORD, _DWORD);

//----- (1002DC10) --------------------------------------------------------
char __cdecl sub_1002DC10(int a1)
{
  char v1; // bl@1

  SYS_enter_krnl();
  v1 = SYS_pvg_alrt_is_set_text(a1, 1);
  SYS_exit_krnl();
  return v1;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006852A: using guessed type int __cdecl SYS_pvg_alrt_is_set_text(_DWORD, _DWORD);

//----- (1002DC80) --------------------------------------------------------
unsigned __int8 __cdecl sub_1002DC80(unsigned __int8 a1)
{
  char v2; // [sp+1h] [bp-1h]@1

  v2 = 0;
  sub_10061000(a1 + 2071, &a1, 1, &v2);
  return a1;
}

//----- (1002DCB0) --------------------------------------------------------
int __cdecl sub_1002DCB0(char a1, float a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  unsigned int v6; // esi@7
  int result; // eax@7
  double v8; // st6@11
  unsigned int v9; // ecx@14
  unsigned int v10; // edi@14
  char *v11; // edx@14
  signed int v12; // ebx@14
  int v13; // edx@56
  int v14; // edi@56
  char *v15; // ecx@56
  signed int v16; // ebp@56
  int v17; // ebp@63
  unsigned int v18; // ecx@63
  double v19; // st7@63
  signed int v20; // edi@64
  char *v21; // edx@64
  float *v22; // edx@81
  char v23; // [sp+Fh] [bp-4D9h]@7
  int v24; // [sp+18h] [bp-4D0h]@7
  float v25; // [sp+1Ch] [bp-4CCh]@61
  float v26; // [sp+20h] [bp-4C8h]@7
  float v27; // [sp+24h] [bp-4C4h]@11
  float v28[4]; // [sp+28h] [bp-4C0h]@11
  char v29; // [sp+38h] [bp-4B0h]@64
  float v30; // [sp+278h] [bp-270h]@7
  float v31; // [sp+27Ch] [bp-26Ch]@10
  float v32; // [sp+280h] [bp-268h]@9
  char v33; // [sp+284h] [bp-264h]@14
  char v34; // [sp+4C4h] [bp-24h]@56

  v5 = 0;
  if ( a3 )
    *(float *)a3 = 0.0;
  if ( a4 )
    *(float *)a4 = 0.0;
  if ( a5 )
    *(float *)a5 = 0.0;
  *(float *)&v24 = 9.8999998e24;
  v23 = 0;
  v6 = 0;
  memset(&v26, 0, 0x258u);
  result = sub_10060D80(42065, (int)&v30, 624);
  if ( !a1 )
  {
    if ( v30 == 0.0 )
    {
      v8 = 9.8999998e24;
    }
    else if ( v32 == 9.8999998e24 || v31 == 9.8999998e24 )
    {
      v8 = 9.8999998e24;
    }
    else
    {
      v6 = 1;
      v26 = v30;
      v28[0] = v32;
      v8 = 9.8999998e24;
      v27 = v31;
    }
    v9 = 12 * v6;
    v10 = 0;
    v11 = &v33;
    v12 = 6;
    do
    {
      if ( 0.0 != *(float *)v11
        && *(float *)((char *)&v26 + v10) < (double)*(float *)v11
        && v8 != *((float *)v11 + 2)
        && v8 != *((float *)v11 + 1) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *(float *)v11;
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 2);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 1);
      }
      if ( 0.0 != *((float *)v11 + 3)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 3)
        && v8 != *((float *)v11 + 5)
        && v8 != *((float *)v11 + 4) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 3);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 5);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 4);
      }
      if ( 0.0 != *((float *)v11 + 6)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 6)
        && v8 != *((float *)v11 + 8)
        && v8 != *((float *)v11 + 7) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 6);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 8);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 7);
      }
      if ( 0.0 != *((float *)v11 + 9)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 9)
        && v8 != *((float *)v11 + 11)
        && v8 != *((float *)v11 + 10) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 9);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 11);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 10);
      }
      if ( 0.0 != *((float *)v11 + 12)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 12)
        && v8 != *((float *)v11 + 14)
        && v8 != *((float *)v11 + 13) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 12);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 14);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 13);
      }
      if ( 0.0 != *((float *)v11 + 15)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 15)
        && v8 != *((float *)v11 + 17)
        && v8 != *((float *)v11 + 16) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 15);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 17);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 16);
      }
      if ( 0.0 != *((float *)v11 + 18)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 18)
        && v8 != *((float *)v11 + 20)
        && v8 != *((float *)v11 + 19) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 18);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 20);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 19);
      }
      if ( 0.0 != *((float *)v11 + 21)
        && *(float *)((char *)&v26 + v10) < (double)*((float *)v11 + 21)
        && v8 != *((float *)v11 + 23)
        && v8 != *((float *)v11 + 22) )
      {
        v5 = v6;
        *(float *)((char *)&v26 + v9) = *((float *)v11 + 21);
        v10 = v9;
        ++v6;
        v28[v9 / 4] = *((float *)v11 + 23);
        v9 += 12;
        *(int *)((char *)&v24 + v9) = *((int *)v11 + 22);
      }
      v11 += 96;
      --v12;
    }
    while ( v12 );
    v13 = 12 * v6;
    v14 = 12 * v5;
    v15 = &v34;
    v16 = 1;
    do
    {
      if ( 0.0 != *(float *)v15
        && *(float *)((char *)&v26 + v14) < (double)*(float *)v15
        && v8 != *((float *)v15 + 2)
        && v8 != *((float *)v15 + 1) )
      {
        v14 = v13;
        *(float *)((char *)&v26 + v13) = *(float *)v15;
        ++v6;
        v13 += 12;
        *(float *)((char *)&v25 + v13) = *((float *)v15 + 2);
        *(int *)((char *)&v24 + v13) = *((int *)v15 + 1);
      }
      v15 += 12;
      --v16;
    }
    while ( v16 );
    v17 = 0;
    v18 = 0;
    v19 = a2;
    if ( (signed int)v6 < 4 )
    {
LABEL_80:
      if ( v18 < v6 )
      {
        v22 = &v26 + 3 * v18;
        do
        {
          if ( v23 )
            break;
          if ( v19 == *v22 )
          {
            v23 = 1;
            v17 = v18;
          }
          else
          {
            v25 = *v22 - v19;
            if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
            {
              v17 = v18;
              v24 = LODWORD(v25) & 0x7FFFFFFF;
            }
          }
          ++v18;
          v22 += 3;
        }
        while ( v18 < v6 );
      }
    }
    else
    {
      v20 = 3;
      v21 = &v29;
      while ( !v23 )
      {
        if ( v19 == *((float *)v21 - 6) )
        {
          v17 = v18;
          break;
        }
        v25 = *((float *)v21 - 6) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v18;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 - 3) )
        {
          v17 = v18 + 1;
          break;
        }
        v25 = *((float *)v21 - 3) - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 2;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *(float *)v21 )
        {
          v17 = v18 + 2;
          break;
        }
        v25 = *(float *)v21 - v19;
        if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
        {
          v17 = v20 - 1;
          v24 = LODWORD(v25) & 0x7FFFFFFF;
        }
        if ( v19 == *((float *)v21 + 3) )
        {
          v23 = 1;
          v17 = v20;
        }
        else
        {
          v25 = *((float *)v21 + 3) - v19;
          if ( COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) < (double)*(float *)&v24 )
          {
            v17 = v20;
            v24 = LODWORD(v25) & 0x7FFFFFFF;
          }
        }
        v18 += 4;
        v21 += 48;
        v20 += 4;
        if ( v18 >= v6 - 3 )
          goto LABEL_80;
      }
    }
    if ( a3 )
      *(float *)a3 = sub_100467B0(*(&v26 + 3 * v17));
    if ( a4 )
      *(float *)a4 = v28[3 * v17] * 0.02539999969303608;
    result = a5;
    if ( a5 )
      *(float *)a5 = 0.02539999969303608 * *(&v27 + 3 * v17);
  }
  return result;
}
// 1002DCB0: using guessed type float var_4C0[4];

//----- (1002E300) --------------------------------------------------------
double sub_1002E300()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 0.0;
  v2 = 0.0;
  sub_10061000(3875, &v1, 4, &v2);
  return v1;
}

//----- (1002E330) --------------------------------------------------------
char __cdecl sub_1002E330(float a1)
{
  float *v1; // esi@1
  double v2; // st7@3
  float v4; // [sp+4h] [bp-10h]@2
  float v5; // [sp+8h] [bp-Ch]@3
  float v6; // [sp+Ch] [bp-8h]@2
  float v7; // [sp+10h] [bp-4h]@5

  v1 = (float *)LODWORD(a1);
  if ( a1 == 0.0 )
    return 0;
  v4 = 9.8999998e24;
  v6 = 9.8999998e24;
  LOBYTE(a1) = 0;
  sub_10060D80(9121, (int)&a1, 1);
  if ( LOBYTE(a1) == 1 )
  {
    sub_10060E40(9120, &v5, 4, &v4);
    v2 = v5;
  }
  else
  {
    if ( LOBYTE(a1) != 3 )
      return 0;
    sub_10060E40(9145, &v7, 4, &v6);
    v2 = v7;
  }
  a1 = v2;
  if ( a1 != 9.8999998e24 )
  {
    *v1 = a1;
    return 1;
  }
  return 0;
}

//----- (1002E3E0) --------------------------------------------------------
unsigned __int8 __cdecl sub_1002E3E0(unsigned __int8 a1)
{
  char v2; // [sp+1h] [bp-1h]@1

  v2 = 0;
  sub_10061000(a1 + 9072, &a1, 1, &v2);
  return a1;
}

//----- (1002E410) --------------------------------------------------------
double __cdecl sub_1002E410(int a1, float a2, float a3)
{
  int v3; // ecx@0
  double result; // st7@2

  if ( sub_1002C480(v3) == 24 )
  {
    *(float *)a1 = a2 * 453.5924;
    result = a2;
  }
  else
  {
    *(float *)a1 = a3 * 1000.0;
    result = a3;
  }
  return result;
}

//----- (1002E450) --------------------------------------------------------
char sub_1002E450()
{
  bool v0; // bl@1
  bool v1; // al@1
  bool v3; // [sp+4h] [bp-4h]@1
  char v4; // [sp+5h] [bp-3h]@1
  char v5; // [sp+6h] [bp-2h]@1
  char v6; // [sp+7h] [bp-1h]@1

  v0 = sub_10033230(26, &v4);
  v3 = sub_10033230(27, &v5);
  v1 = sub_10033230(28, &v6);
  if ( v0 )
  {
    if ( !v4 )
      return 0;
    if ( !v3 )
    {
LABEL_8:
      if ( !v1 )
        return 1;
      goto LABEL_9;
    }
LABEL_7:
    if ( !v5 )
      return 0;
    goto LABEL_8;
  }
  if ( v3 )
    goto LABEL_7;
  if ( !v1 )
    return 0;
LABEL_9:
  if ( !v6 )
    return 0;
  return 1;
}

//----- (1002E4C0) --------------------------------------------------------
char __cdecl sub_1002E4C0(unsigned __int8 a1, char a2)
{
  char v3; // [sp+7h] [bp-1h]@1

  v3 = 0;
  sub_10060F90(a1 + 9042, (int)&a2, 4);
  return sub_10060F90(a1 + 9072, (int)&v3, 1);
}

//----- (1002E500) --------------------------------------------------------
void __cdecl sub_1002E500(unsigned __int8 a1)
{
  float v1; // ST18_4@8
  float v2; // [sp+10h] [bp-54h]@5
  float v3; // [sp+14h] [bp-50h]@1
  char v4; // [sp+18h] [bp-4Ch]@1
  float v5; // [sp+34h] [bp-30h]@1
  char v6; // [sp+54h] [bp-10h]@1

  sub_10029AB0(a1, (int)&v4);
  v3 = v5;
  if ( !memcmp(&v6, "Vy", 3u) && sub_1002E450() && sub_10029AF0((int)"Vy_GEAR_UP", &v4) )
    v3 = v5;
  sub_10061000(a1 + 9042, &v2, 4, &v3);
  if ( !strncmp(&v6, "Vy", 2u) && !sub_1002E3E0(a1) && v3 != v2 )
  {
    v2 = v3;
    v1 = v3;
    sub_1002E4C0(a1, SLOBYTE(v1));
  }
}

//----- (1002E600) --------------------------------------------------------
char __cdecl sub_1002E600(float *a1, float *a2, float *a3, char a4)
{
  float *v4; // ecx@10
  signed int v5; // edx@10
  double v6; // st7@29
  double v7; // st7@34
  double v8; // st7@37
  double v9; // st6@37
  double v10; // st5@43
  double v11; // rtt@48
  double v12; // st5@48
  double v13; // st7@48
  char result; // al@48
  char v15; // [sp+22h] [bp-3EEh]@1
  char v16; // [sp+23h] [bp-3EDh]@1
  float v17; // [sp+24h] [bp-3ECh]@1
  float v18; // [sp+28h] [bp-3E8h]@1
  float v19; // [sp+2Ch] [bp-3E4h]@1
  float v20; // [sp+30h] [bp-3E0h]@1
  float v21; // [sp+34h] [bp-3DCh]@1
  float v22; // [sp+38h] [bp-3D8h]@1
  int v23; // [sp+3Ch] [bp-3D4h]@1
  int v24; // [sp+40h] [bp-3D0h]@1
  float v25; // [sp+44h] [bp-3CCh]@29
  int v26; // [sp+48h] [bp-3C8h]@10
  char v27; // [sp+4Ch] [bp-3C4h]@10
  char v28; // [sp+68h] [bp-3A8h]@10
  char v29; // [sp+6Ch] [bp-3A4h]@10
  char v30; // [sp+8Ch] [bp-384h]@10
  char v31; // [sp+ACh] [bp-364h]@10
  char v32; // [sp+CCh] [bp-344h]@10
  char v33; // [sp+ECh] [bp-324h]@10
  char v34; // [sp+10Ch] [bp-304h]@10
  char v35; // [sp+12Ch] [bp-2E4h]@10
  char v36; // [sp+14Ch] [bp-2C4h]@10
  char v37; // [sp+16Ch] [bp-2A4h]@10
  char v38; // [sp+18Ch] [bp-284h]@10
  char v39; // [sp+1ACh] [bp-264h]@10
  char v40; // [sp+1CCh] [bp-244h]@10
  char v41; // [sp+1ECh] [bp-224h]@10
  char v42; // [sp+20Ch] [bp-204h]@10
  char v43; // [sp+22Ch] [bp-1E4h]@10
  char v44; // [sp+24Ch] [bp-1C4h]@10
  char v45; // [sp+26Ch] [bp-1A4h]@10
  char v46; // [sp+28Ch] [bp-184h]@10
  char v47; // [sp+2ACh] [bp-164h]@10
  char v48; // [sp+2CCh] [bp-144h]@10
  char v49; // [sp+2ECh] [bp-124h]@10
  char v50; // [sp+30Ch] [bp-104h]@10
  char v51; // [sp+32Ch] [bp-E4h]@10
  char v52; // [sp+34Ch] [bp-C4h]@10
  char v53; // [sp+36Ch] [bp-A4h]@10
  char v54; // [sp+38Ch] [bp-84h]@10
  char v55; // [sp+3ACh] [bp-64h]@10
  char v56; // [sp+3CCh] [bp-44h]@10
  char v57; // [sp+3ECh] [bp-24h]@10

  v20 = 0.0;
  *(float *)&v24 = 0.0;
  *(float *)&v23 = 0.0;
  v21 = 0.0;
  v18 = 0.0;
  v19 = 0.0;
  v22 = 0.0;
  v16 = 0;
  v17 = 0.0;
  v15 = 0;
  if ( a1 && 9.8999998e24 != *a1 )
    *a1 = 0.0;
  if ( a3 && 9.8999998e24 != *a3 )
    *a3 = 0.0;
  if ( a2 && 9.8999998e24 != *a2 )
    *a2 = 0.0;
  sub_1002E410((int)&v26, 5.0, 2.0);
  sub_10060D80(41113, (int)&v15, 1);
  sub_10060D80(9149, (int)&v16, 1);
  sub_10060D80(42004, (int)&v27, 32);
  sub_10060D80(42006, (int)&v29, 32);
  sub_10060D80(42008, (int)&v30, 32);
  sub_10060D80(42010, (int)&v31, 32);
  sub_10060D80(42012, (int)&v32, 32);
  sub_10060D80(42014, (int)&v33, 32);
  sub_10060D80(42016, (int)&v34, 32);
  sub_10060D80(42018, (int)&v35, 32);
  sub_10060D80(42020, (int)&v36, 32);
  sub_10060D80(42022, (int)&v37, 32);
  sub_10060D80(42024, (int)&v38, 32);
  sub_10060D80(42026, (int)&v39, 32);
  sub_10060D80(42028, (int)&v40, 32);
  sub_10060D80(42030, (int)&v41, 32);
  sub_10060D80(42032, (int)&v42, 32);
  sub_10060D80(42034, (int)&v43, 32);
  sub_10060D80(42036, (int)&v44, 32);
  sub_10060D80(42038, (int)&v45, 32);
  sub_10060D80(42040, (int)&v46, 32);
  sub_10060D80(42042, (int)&v47, 32);
  sub_10060D80(42044, (int)&v48, 32);
  sub_10060D80(42046, (int)&v49, 32);
  sub_10060D80(42048, (int)&v50, 32);
  sub_10060D80(42050, (int)&v51, 32);
  sub_10060D80(42052, (int)&v52, 32);
  sub_10060D80(42054, (int)&v53, 32);
  sub_10060D80(42056, (int)&v54, 32);
  sub_10060D80(42058, (int)&v55, 32);
  sub_10060D80(42060, (int)&v56, 32);
  sub_10060D80(42062, (int)&v57, 32);
  v4 = (float *)&v28;
  v5 = 30;
  do
  {
    if ( *((_BYTE *)v4 - 28) == 1 )
    {
      if ( 9.8999998e24 != *(v4 - 1) )
        v20 = *(v4 - 1) + v20;
      if ( a4 )
      {
        if ( 9.8999998e24 != *v4 )
        {
          v22 = *v4 + v22;
          if ( 9.8999998e24 != *v4 )
          {
            if ( 9.8999998e24 != *(v4 - 3) )
              v19 = *v4 * *(v4 - 3) + v19;
            if ( 9.8999998e24 != *(v4 - 2) )
              v18 = *v4 * *(v4 - 2) + v18;
          }
        }
      }
      if ( 9.8999998e24 != *(v4 - 1) )
      {
        if ( 9.8999998e24 != *(v4 - 3) )
          v19 = *(v4 - 3) * *(v4 - 1) + v19;
        if ( 9.8999998e24 != *(v4 - 2) )
          v18 = *(v4 - 2) * *(v4 - 1) + v18;
      }
    }
    v4 += 8;
    --v5;
  }
  while ( v5 );
  if ( v16 && a4 == 2 )
  {
    v25 = sub_10043800();
    v21 = sub_100467B0(v25);
    v21 = sub_10068180(v21, *(float *)&v26);
    sub_1002DCB0(0, v25, 0, (int)&v24, (int)&v23);
    *(float *)&v24 = *(float *)&v24 * 39.37007904052734;
    *(float *)&v23 = 39.37007904052734 * *(float *)&v23;
    v6 = v21;
    v18 = v21 * *(float *)&v24 + v18;
    v19 = v21 * *(float *)&v23 + v19;
  }
  else
  {
    v6 = v21;
  }
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v7 = v22 + v20;
    }
    else
    {
      if ( a4 != 2 )
      {
        v8 = 0.0;
        goto LABEL_40;
      }
      v7 = v6 + v20 + v22;
    }
  }
  else
  {
    v7 = v20;
  }
  v17 = v7;
  v8 = 0.0;
  v9 = v17;
  if ( v17 >= 0.0 )
    goto LABEL_41;
  v17 = 0.0;
LABEL_40:
  v9 = v17;
LABEL_41:
  if ( a1 )
    *a1 = v9;
  v10 = 0.02539999969303608;
  if ( a3 )
  {
    if ( v9 > v8 )
      *a3 = v18 / v9 * 0.02539999969303608;
    v10 = 0.02539999969303608;
  }
  if ( a2 )
  {
    v11 = v10;
    v12 = v8;
    v13 = v11;
    result = v15;
    if ( v12 < v9 )
      *a2 = v13 * (v19 / v9);
  }
  else
  {
    result = v15;
  }
  return result;
}

//----- (1002EB90) --------------------------------------------------------
double sub_1002EB90()
{
  double v0; // st7@3
  double v1; // st7@4
  char v3; // [sp+Bh] [bp-1Dh]@1
  float v4; // [sp+Ch] [bp-1Ch]@1
  int v5; // [sp+10h] [bp-18h]@3
  float v6; // [sp+14h] [bp-14h]@1
  float v7; // [sp+18h] [bp-10h]@1
  float v8; // [sp+1Ch] [bp-Ch]@1
  double v9; // [sp+20h] [bp-8h]@4

  v6 = 0.0;
  v8 = 0.0;
  v7 = 0.0;
  v4 = 0.0;
  sub_10061C40(43, &v3);
  if ( sub_10060D80(9146, (int)&v4, 4) )
  {
    if ( v3 == 7 )
    {
      sub_1002E600(&v6, 0, 0, 1);
      sub_1002E410((int)&v5, 5.0, 2.0);
      v0 = sub_10068180(v6, *(float *)&v5);
    }
    else
    {
      sub_10061000(3163, &v6, 4, &v7);
      sub_10061000(3164, &v8, 4, &v7);
      sub_1002E410((int)&v5, 10.0, 5.0);
      v9 = sub_10068180(v8, *(float *)&v5);
      v1 = sub_10068180(v6, *(float *)&v5);
      v0 = v1 + v9;
    }
    v4 = v0;
    sub_10060ED0(9146, (int)&v4, 4);
  }
  return v4;
}

//----- (1002ECD0) --------------------------------------------------------
double sub_1002ECD0()
{
  double v0; // st7@1
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@1

  v2 = 0.0;
  v3 = sub_1002EB90();
  sub_10043980(&v2);
  v0 = sub_100467B0(v2);
  return (float)(v0 + v3);
}

//----- (1002ED10) --------------------------------------------------------
__int16 __cdecl sub_1002ED10(unsigned __int16 a1)
{
  return word_100B8480[a1];
}
// 100B8480: using guessed type __int16 word_100B8480[];

//----- (1002ED20) --------------------------------------------------------
char __cdecl sub_1002ED20(bool *a1)
{
  unsigned __int8 v1; // bl@1
  unsigned __int16 *v2; // esi@1
  signed int v3; // edi@4
  void *v4; // ecx@5
  char v5; // al@9
  void *v6; // ecx@13
  char v8; // [sp+1h] [bp-Bh]@1
  char v9; // [sp+2h] [bp-Ah]@1
  unsigned __int8 v10; // [sp+3h] [bp-9h]@1
  unsigned __int8 v11; // [sp+4h] [bp-8h]@1
  bool v12; // [sp+5h] [bp-7h]@1
  char v13; // [sp+6h] [bp-6h]@6
  bool v14; // [sp+7h] [bp-5h]@1
  float v15; // [sp+8h] [bp-4h]@1

  v14 = (unsigned __int8)sub_1002BC10() > 1u;
  v1 = 0;
  v12 = sub_10033CF0(&v15);
  v8 = 1;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v2 = (unsigned __int16 *)&unk_100B8508;
  if ( sub_10033040(0x2E6u) || sub_10033040(0x2E7u) )
    v2 = (unsigned __int16 *)&unk_100B8500;
  v3 = 4;
  do
  {
    if ( sub_10033040(*v2) && sub_10033230(*v2, &v13) )
    {
      v10 += v13;
      ++v1;
      LOBYTE(v4) = v13 == 0;
      v11 += v13 == 0;
    }
    ++v2;
    --v3;
  }
  while ( v3 );
  v5 = byte_100B8510[v1];
  if ( v10 >= (unsigned __int8)v5 )
    goto LABEL_20;
  if ( v11 >= (unsigned __int8)v5 )
    goto LABEL_19;
  if ( v14 )
  {
    if ( !sub_1002BEA0() )
    {
      if ( !v12 )
        goto LABEL_20;
      goto LABEL_18;
    }
LABEL_19:
    v8 = 1;
LABEL_21:
    v9 = 1;
    goto LABEL_22;
  }
  if ( v12 )
  {
LABEL_18:
    if ( v15 > 25.72207 )
      goto LABEL_19;
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  if ( sub_1002C5E0(v4) == 2 || sub_1002C5E0(v6) == 8 )
  {
    *a1 = 1;
    return 0;
  }
LABEL_22:
  *a1 = v8 == 0;
  return v9;
}

//----- (1002EE60) --------------------------------------------------------
bool __thiscall sub_1002EE60(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  return sub_1002C5E0(this) == 1 && sub_1002ED20((bool *)&v2 + 3) && BYTE3(v2);
}

//----- (1002EE90) --------------------------------------------------------
int __cdecl sub_1002EE90(int a1, signed int a2, signed int a3)
{
  int result; // eax@1

  result = a1;
  *(double *)(a1 + 8) = (double)a3 * 0.000000001462918079267163;
  *(double *)a1 = 0.000000001462918079267163 * (double)a2;
  return result;
}

//----- (1002EEB0) --------------------------------------------------------
int __cdecl sub_1002EEB0(int a1, double a2, double a3)
{
  long double v3; // st6@1
  long double v4; // st4@1
  int result; // eax@3
  double v6; // st7@6
  double v7; // [sp+0h] [bp-10h]@6
  double v8; // [sp+8h] [bp-8h]@6

  v3 = fabs(a2);
  v4 = fabs(a3);
  if ( v3 > 1.5707963267949 || v4 >= 3.1415926535898 )
  {
    if ( v3 > 4.7123889803847 || v4 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = a2;
      v8 = a3;
      sub_10043A50((int)&v7);
      v6 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v6;
      *(_DWORD *)(a1 + 4) = (signed int)v6;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(a2 * 683565275.5764301);
    result = (signed int)(683565275.5764301 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (1002EF90) --------------------------------------------------------
int __cdecl sub_1002EF90(int a1, float a2, float a3)
{
  double v3; // st7@1
  int result; // eax@3
  double v5; // st7@6
  float v6; // [sp+0h] [bp-14h]@1
  double v7; // [sp+4h] [bp-10h]@6
  double v8; // [sp+Ch] [bp-8h]@6
  float v9; // [sp+1Ch] [bp+8h]@1

  v3 = a2;
  v6 = fabs(a2);
  v9 = fabs(a3);
  if ( v6 > 1.570796370506287 || v9 >= 3.141592741012573 )
  {
    if ( v6 > 4.7123889803847 || v9 > 12.5663706143592 )
    {
      result = a1;
      *(_DWORD *)a1 = 2147483648;
      *(_DWORD *)(a1 + 4) = 2147483648;
    }
    else
    {
      v7 = v3;
      v8 = a3;
      sub_10043A50((int)&v7);
      v5 = 683565275.5764301 * v8;
      *(_DWORD *)a1 = (signed int)(v7 * 683565275.5764301);
      result = (signed int)v5;
      *(_DWORD *)(a1 + 4) = (signed int)v5;
    }
  }
  else
  {
    *(_DWORD *)a1 = (signed int)(v3 * 683565248.0);
    result = (signed int)(683565248.0 * a3);
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (1002F080) --------------------------------------------------------
char __cdecl sub_1002F080(float *a1)
{
  float *v1; // esi@1
  char result; // al@3
  char v3; // bl@4
  char v4; // [sp+Ah] [bp-Eh]@1
  char v5; // [sp+Bh] [bp-Dh]@4
  float v6; // [sp+Ch] [bp-Ch]@25
  float v7; // [sp+10h] [bp-8h]@4
  float v8; // [sp+14h] [bp-4h]@4

  v1 = a1;
  *a1 = 9.8999998e24;
  sub_10060D80(6612, (int)&v4, 1);
  if ( v4 != 6 )
  {
    if ( v4 != 7 )
    {
      result = 0;
      flt_10957730 = 2.0;
      *v1 = 2.0;
      return result;
    }
    v5 = sub_10015A90(0, 239, 0, 4, &v7);
    v3 = sub_10015A90(0, 240, 0, 4, &v8);
    LOBYTE(a1) = sub_1002DC10((int)"_on_ground");
    if ( !(_BYTE)a1 )
      goto LABEL_40;
    if ( dword_10957738 == -1 || (unsigned int)(sub_10060900() - dword_10957738) > 0x3A98 )
    {
      byte_10A09AA4 = 1;
      flt_10957730 = 0.75;
      result = 1;
      *v1 = 0.75;
      return result;
    }
    if ( !(_BYTE)a1 )
    {
LABEL_40:
      dword_10957738 = sub_10060900();
      if ( !v5 && !v3 || v7 < 0.52359879 && !v3 || !v5 && v8 < 0.52359879 )
      {
        byte_10A09AA4 = 0;
        flt_10957730 = 0.69999999;
        result = 1;
        *v1 = 0.69999999;
        return result;
      }
      if ( v7 < 0.52359879 && v8 < 0.52359879 )
      {
        byte_10A09AA4 = 0;
        flt_10957730 = 0.69999999;
        result = 1;
        *v1 = 0.69999999;
        return result;
      }
    }
    if ( byte_10A09AA4 == 1 )
    {
      flt_10957730 = 0.75;
      result = 1;
      *v1 = 0.75;
      return result;
    }
    goto LABEL_37;
  }
  sub_1002ED20((bool *)&a1);
  if ( byte_10957734 )
  {
    if ( !sub_100472F0(0x20Eu, &v6) )
      v6 = 9.8999998e24;
    if ( (_BYTE)a1 )
    {
      flt_1095772C = v6;
      if ( dword_10957738 == -1 || (unsigned int)(sub_10060900() - dword_10957738) > 0x3A98 )
      {
        flt_10957730 = 0.75;
        result = 1;
        *v1 = 0.75;
        return result;
      }
    }
    else
    {
      dword_10957738 = sub_10060900();
      if ( v6 == 9.8999998e24
        || flt_1095772C == 9.8999998e24
        || fabs(flt_1095772C - v6) > 0.05235987901687622
        || flt_1095772C <= 0.05235987901687622 )
      {
        flt_1095772C = 9.8999998e24;
LABEL_37:
        flt_10957730 = 0.69999999;
        result = 1;
        *v1 = 0.69999999;
        return result;
      }
    }
    *v1 = flt_10957730;
    return 1;
  }
  byte_10957734 = 1;
  if ( (_BYTE)a1 )
  {
    result = 1;
    flt_10957730 = 0.75;
    *v1 = 0.75;
  }
  else
  {
    result = 1;
    flt_10957730 = 0.69999999;
    *v1 = 0.69999999;
  }
  return result;
}
// 1095772C: using guessed type float flt_1095772C;
// 10957730: using guessed type float flt_10957730;
// 10957734: using guessed type char byte_10957734;
// 10957738: using guessed type int dword_10957738;
// 10A09AA4: using guessed type char byte_10A09AA4;

//----- (1002F3A0) --------------------------------------------------------
char __cdecl sub_1002F3A0(bool *a1, unsigned int a2)
{
  bool *v2; // esi@1
  _BYTE *v3; // edi@1
  char v4; // bl@1
  bool v5; // al@8
  char result; // al@14
  unsigned int v7; // [sp+Ch] [bp-4h]@6

  v2 = a1;
  v3 = (_BYTE *)a2;
  v4 = 0;
  *a1 = 0;
  *v3 = 0;
  sub_10060D80(6612, (int)&a1, 1);
  if ( (_BYTE)a1 == 4 || (_BYTE)a1 == 5 || (_BYTE)a1 == 8 )
  {
    v4 = 1;
    v5 = sub_10015A90(6, 95, 0, 4, &a2) && (a2 >> 18) & 1 || sub_10015A90(6, 96, 0, 4, &v7) && (v7 >> 18) & 1;
    *v2 = v5;
    if ( sub_10015A90(6, 95, 0, 4, &a2) && (a2 >> 21) & 1 || sub_10015A90(6, 96, 0, 4, &v7) && (v7 >> 21) & 1 )
    {
      result = 1;
      *v3 = 1;
      return result;
    }
    *v3 = 0;
  }
  return v4;
}

//----- (1002F4A0) --------------------------------------------------------
void sub_1002F4A0()
{
  dword_10957738 = -1;
  flt_1095772C = 9.8999998e24;
  byte_10957734 = 0;
}
// 1095772C: using guessed type float flt_1095772C;
// 10957734: using guessed type char byte_10957734;
// 10957738: using guessed type int dword_10957738;

//----- (1002F4C0) --------------------------------------------------------
char __cdecl sub_1002F4C0(float a1, float a2, int a3)
{
  int v3; // ecx@0
  char result; // al@3
  int v5; // [sp+10h] [bp-4h]@1

  v5 = v3;
  if ( !sub_10015A90(6, v3, 0, 4, &v5) || sub_100338A0((int)&v5, a1, a2, COERCE_INT(0.0), 0) )
  {
    result = 0;
  }
  else
  {
    *(float *)a3 = *(float *)&v5;
    result = 1;
  }
  return result;
}

//----- (1002F520) --------------------------------------------------------
char __usercall sub_1002F520@<al>(float *a1@<esi>)
{
  char result; // al@7
  char v2; // [sp+7h] [bp-5h]@1
  float v3; // [sp+8h] [bp-4h]@1

  *a1 = 0.0;
  v3 = 0.0;
  v2 = 0;
  if ( sub_10033040(0x8Fu) && !sub_10033230(143, &v2) )
    v2 = 1;
  if ( !sub_10046830(0x9Au, &v3) || v2 )
  {
    result = 0;
  }
  else if ( v3 <= 0.0 )
  {
    result = 1;
    v3 = 0.0;
    *a1 = 0.0;
  }
  else
  {
    result = 1;
    *a1 = v3;
  }
  return result;
}

//----- (1002F5C0) --------------------------------------------------------
char __thiscall sub_1002F5C0(void *this)
{
  void *v1; // ecx@1
  char v2; // al@2
  int v3; // eax@2
  void *v4; // ecx@2
  char result; // al@4
  void *v6; // [sp-2h] [bp-4h]@1

  v6 = this;
  sub_10060D80(6612, (int)&v6 + 3, 1);
  if ( BYTE3(v6) == 5 )
  {
    v2 = sub_10043C20(v1);
    v3 = (unsigned __int8)sub_10043EA0(v2, 0);
    if ( (_BYTE)v3 )
    {
      if ( v3 == 1 )
        result = 1;
      else
        result = sub_10043C20(v4);
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = sub_1002C660(v1) == 2;
  }
  return result;
}

//----- (1002F620) --------------------------------------------------------
char __cdecl sub_1002F620(float *a1)
{
  void *v1; // ecx@0
  __int16 v2; // cx@1

  *a1 = 0.0;
  v2 = word_100B8A7C[11 * (unsigned __int8)sub_1002F5C0(v1)];
  return sub_1002F4C0(-3.1415927, 3.1415927, (int)a1);
}
// 100B8A7C: using guessed type __int16 word_100B8A7C[];

//----- (1002F660) --------------------------------------------------------
char __cdecl sub_1002F660(float *a1)
{
  void *v1; // ecx@0
  float *v2; // esi@1
  void *v3; // ecx@1
  char v4; // al@3
  char result; // al@7
  void *v6; // ecx@9
  char v7; // al@11
  __int16 v8; // cx@17
  unsigned __int16 v9; // [sp+4h] [bp-Ch]@3
  float *v10; // [sp+8h] [bp-8h]@3

  v2 = a1;
  *a1 = 0.0;
  if ( !sub_1002F5C0(v1) && (unsigned __int8)sub_100476B0(0x273u) )
  {
    v4 = sub_100476B0(0x275u);
    v10 = v2;
    v9 = 627;
    if ( v4 )
    {
      if ( sub_100472F0(0x273u, v2) && sub_100475F0(0x275u, &a1) && (_BYTE)a1 )
        return 1;
      return 0;
    }
    return sub_100472F0(v9, v10);
  }
  if ( sub_1002F5C0(v3) == 1 && (unsigned __int8)sub_100476B0(0x274u) )
  {
    v7 = sub_100476B0(0x276u);
    v10 = v2;
    v9 = 628;
    if ( !v7 )
      return sub_100472F0(v9, v10);
    if ( !sub_100472F0(0x274u, v2) || !sub_100475F0(0x276u, &a1) || !(_BYTE)a1 )
      return 0;
    result = 1;
  }
  else
  {
    v8 = word_100B8A7E[11 * (unsigned __int8)sub_1002F5C0(v6)];
    result = sub_1002F4C0(0.0, 1.0, (int)v2);
  }
  return result;
}
// 100B8A7E: using guessed type __int16 word_100B8A7E[];

//----- (1002F770) --------------------------------------------------------
char __cdecl sub_1002F770(float *a1)
{
  void *v1; // ecx@0
  __int16 v2; // cx@1

  *a1 = 0.0;
  v2 = word_100B8A80[11 * (unsigned __int8)sub_1002F5C0(v1)];
  return sub_1002F4C0(0.0, 1.0, (int)a1);
}
// 100B8A80: using guessed type __int16 word_100B8A80[];

//----- (1002F7B0) --------------------------------------------------------
char __usercall sub_1002F7B0@<al>(void *a1@<ecx>, float *a2@<esi>, char a3)
{
  char v3; // al@2
  char result; // al@4
  __int16 v5; // cx@6
  int v6; // [sp+10h] [bp-4h]@1

  *a2 = 0.0;
  *(float *)&v6 = 0.0;
  if ( a3 )
  {
    v3 = sub_1002F5C0(a1);
    if ( !sub_10029610(60, v3, &v6) || sub_100338A0((int)&v6, 0.0, 2.0, COERCE_INT(0.0), 0) )
    {
      result = 0;
    }
    else
    {
      result = 1;
      *a2 = *(float *)&v6;
    }
  }
  else
  {
    v5 = word_100B8A70[11 * (unsigned __int8)sub_1002F5C0(a1)];
    result = sub_1002F4C0(0.0, 2.0, (int)a2);
  }
  return result;
}
// 100B8A70: using guessed type __int16 word_100B8A70[];

//----- (1002F840) --------------------------------------------------------
char __usercall sub_1002F840@<al>(void *a1@<ecx>, float *a2@<esi>, char a3)
{
  char v3; // al@2
  char result; // al@4
  __int16 v5; // cx@6
  int v6; // [sp+10h] [bp-4h]@1

  *a2 = 0.0;
  *(float *)&v6 = 0.0;
  if ( a3 )
  {
    v3 = sub_1002F5C0(a1);
    if ( !sub_10029610(63, v3, &v6) || sub_100338A0((int)&v6, 0.0, 2.0, COERCE_INT(0.0), 0) )
    {
      result = 0;
    }
    else
    {
      result = 1;
      *a2 = *(float *)&v6;
    }
  }
  else
  {
    v5 = word_100B8A72[11 * (unsigned __int8)sub_1002F5C0(a1)];
    result = sub_1002F4C0(0.0, 2.0, (int)a2);
  }
  return result;
}
// 100B8A72: using guessed type __int16 word_100B8A72[];

//----- (1002F8D0) --------------------------------------------------------
char __usercall sub_1002F8D0@<al>(void *a1@<ecx>, float *a2@<esi>, char a3)
{
  char v3; // al@2
  char result; // al@4
  __int16 v5; // cx@6
  int v6; // [sp+10h] [bp-4h]@1

  *a2 = 0.0;
  *(float *)&v6 = 0.0;
  if ( a3 )
  {
    v3 = sub_1002F5C0(a1);
    if ( !sub_10029610(61, v3, &v6) || sub_100338A0((int)&v6, 0.0, 2.0, COERCE_INT(0.0), 0) )
    {
      result = 0;
    }
    else
    {
      result = 1;
      *a2 = *(float *)&v6;
    }
  }
  else
  {
    v5 = word_100B8A74[11 * (unsigned __int8)sub_1002F5C0(a1)];
    result = sub_1002F4C0(0.0, 2.0, (int)a2);
  }
  return result;
}
// 100B8A74: using guessed type __int16 word_100B8A74[];

//----- (1002F960) --------------------------------------------------------
char __usercall sub_1002F960@<al>(void *a1@<ecx>, float *a2@<esi>, char a3)
{
  char v3; // al@2
  char result; // al@4
  __int16 v5; // cx@6
  int v6; // [sp+10h] [bp-4h]@1

  *a2 = 0.0;
  *(float *)&v6 = 0.0;
  if ( a3 )
  {
    v3 = sub_1002F5C0(a1);
    if ( !sub_10029610(64, v3, &v6) || sub_100338A0((int)&v6, 0.0, 526.79114, COERCE_INT(0.0), 0) )
    {
      result = 0;
    }
    else
    {
      result = 1;
      *a2 = *(float *)&v6;
    }
  }
  else
  {
    v5 = word_100B8A76[11 * (unsigned __int8)sub_1002F5C0(a1)];
    result = sub_1002F4C0(0.0, 526.79114, (int)a2);
  }
  return result;
}
// 100B8A76: using guessed type __int16 word_100B8A76[];

//----- (1002F9F0) --------------------------------------------------------
char __usercall sub_1002F9F0@<al>(float *a1@<eax>, void *a2@<ecx>)
{
  int v2; // ST08_4@1
  __int16 v3; // cx@1

  v2 = (int)a1;
  *a1 = 0.0;
  v3 = word_100B8A78[11 * (unsigned __int8)sub_1002F5C0(a2)];
  return sub_1002F4C0(0.0, 526.79114, v2);
}
// 100B8A78: using guessed type __int16 word_100B8A78[];

//----- (1002FA20) --------------------------------------------------------
char __usercall sub_1002FA20@<al>(void *a1@<ecx>, float *a2@<esi>, char a3)
{
  char v3; // al@2
  char result; // al@4
  __int16 v5; // cx@6
  int v6; // [sp+10h] [bp-4h]@1

  *a2 = 0.0;
  *(float *)&v6 = 0.0;
  if ( a3 )
  {
    v3 = sub_1002F5C0(a1);
    if ( !sub_10029610(62, v3, &v6) || sub_100338A0((int)&v6, 1.0, 2.0, COERCE_INT(0.0), 0) )
    {
      result = 0;
    }
    else
    {
      result = 1;
      *a2 = *(float *)&v6;
    }
  }
  else
  {
    v5 = word_100B8A7A[11 * (unsigned __int8)sub_1002F5C0(a1)];
    result = sub_1002F4C0(1.0, 2.0, (int)a2);
  }
  return result;
}
// 100B8A7A: using guessed type __int16 word_100B8A7A[];

//----- (1002FAC0) --------------------------------------------------------
char __cdecl sub_1002FAC0(float *a1)
{
  float *v1; // edi@1
  char v2; // bl@1
  void *v3; // ecx@1
  char result; // al@3
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 0.0;
  v1 = a1;
  *a1 = 0.0;
  v2 = 0;
  sub_10060D80(6612, (int)&a1, 1);
  switch ( (unsigned __int8)a1 )
  {
    case 1u:
      if ( !sub_1002F520(&v5) )
        goto LABEL_8;
      *(float *)&a1 = sqrt(v5);
      result = 1;
      *v1 = *(float *)&a1 * 1.299999952316284;
      break;
    case 4u:
      result = sub_1002F7B0(v3, v1, 0);
      break;
    case 5u:
    case 8u:
      result = sub_1002F7B0(v3, v1, 1);
      break;
    case 6u:
    case 7u:
      if ( sub_1002F660(&v5) )
      {
        *(float *)&a1 = sqrt(v5);
        v2 = 1;
        *v1 = *(float *)&a1 * 1.299999952316284;
      }
      goto LABEL_8;
    default:
LABEL_8:
      result = v2;
      break;
  }
  return result;
}

//----- (1002FBB0) --------------------------------------------------------
char __cdecl sub_1002FBB0(float *a1)
{
  float *v1; // esi@1
  void *v2; // ecx@1
  char result; // al@4

  v1 = a1;
  *a1 = 0.0;
  sub_10060D80(6612, (int)&a1, 1);
  if ( (unsigned __int8)a1 == 4 )
  {
    result = sub_1002F840(v2, v1, 0);
  }
  else if ( (unsigned __int8)a1 != 5 && (unsigned __int8)a1 != 8 )
  {
    result = 0;
  }
  else
  {
    result = sub_1002F840(v2, v1, 1);
  }
  return result;
}

//----- (1002FC10) --------------------------------------------------------
char __cdecl sub_1002FC10(float *a1)
{
  float *v1; // edi@1
  void *v2; // ecx@1
  char result; // al@3
  float v4; // [sp+8h] [bp-8h]@1
  float v5; // [sp+Ch] [bp-4h]@3

  v4 = 0.0;
  v1 = a1;
  *a1 = 0.0;
  sub_10060D80(6612, (int)&a1, 1);
  switch ( (unsigned __int8)a1 )
  {
    case 1u:
      if ( !sub_1002F520(&v4) )
        goto LABEL_13;
      sub_10060E80(6454, (int)&v5, 4);
      *(float *)&a1 = sqrt(v4);
      result = 1;
      *v1 = *(float *)&a1 * v5;
      break;
    case 4u:
      result = sub_1002F8D0(v2, v1, 0);
      break;
    case 5u:
    case 8u:
      result = sub_1002F8D0(v2, v1, 1);
      break;
    case 6u:
      if ( !sub_1002F660(&v4) || !sub_1002F770(&v5) || v5 == 0.0 )
        goto LABEL_13;
      *v1 = sqrt(v4 / v5);
      result = 1;
      break;
    case 7u:
      v5 = *(float *)(dword_10A09AC0 + 32100);
      if ( !sub_1002F660(&v4) || v5 == 0.0 )
        goto LABEL_13;
      *v1 = sqrt(v4 / v5);
      result = 1;
      break;
    default:
LABEL_13:
      result = 0;
      break;
  }
  return result;
}
// 10A09AC0: using guessed type int dword_10A09AC0;

//----- (1002FD90) --------------------------------------------------------
char __cdecl sub_1002FD90(float *a1)
{
  float *v1; // esi@1
  void *v2; // ecx@1
  char result; // al@4

  v1 = a1;
  *a1 = 0.0;
  sub_10060D80(6612, (int)&a1, 1);
  if ( (unsigned __int8)a1 == 4 )
  {
    result = sub_1002F960(v2, v1, 0);
  }
  else if ( (unsigned __int8)a1 != 5 && (unsigned __int8)a1 != 8 )
  {
    result = 0;
  }
  else
  {
    result = sub_1002F960(v2, v1, 1);
  }
  return result;
}

//----- (1002FDF0) --------------------------------------------------------
char __cdecl sub_1002FDF0(float *a1)
{
  float *v1; // esi@1
  void *v2; // ecx@1
  char result; // al@4

  v1 = a1;
  *a1 = 0.0;
  sub_10060D80(6612, (int)&a1, 1);
  if ( (unsigned __int8)a1 == 4 )
  {
    result = sub_1002FA20(v2, v1, 0);
  }
  else if ( (unsigned __int8)a1 != 5 && (unsigned __int8)a1 != 8 )
  {
    result = 0;
  }
  else
  {
    result = sub_1002FA20(v2, v1, 1);
  }
  return result;
}

//----- (1002FE50) --------------------------------------------------------
char __cdecl sub_1002FE50(int a1, float a2)
{
  void *v2; // ecx@1
  char v3; // di@5
  void *v4; // ecx@5
  char result; // al@7
  double v6; // st7@12
  char v7; // [sp+Fh] [bp-Dh]@1
  float v8; // [sp+10h] [bp-Ch]@5
  float v9; // [sp+14h] [bp-8h]@3
  float v10; // [sp+18h] [bp-4h]@7

  sub_10060D80(6612, (int)&v7, 1);
  LOBYTE(v2) = v7;
  switch ( v7 )
  {
    case 4:
    case 5:
    case 8:
      if ( v7 == 5 || (LOBYTE(v9) = 0, v7 == 8) )
        LOBYTE(v9) = 1;
      v3 = LOBYTE(v9);
      if ( sub_1002FA20(v2, &v8, SLOBYTE(v9)) && sub_1002F8D0(v4, &v9, v3) )
      {
        v10 = a2 * 0.5144444704055786;
        result = 1;
        *(float *)a1 = v10 * v9 * (v8 - 1.0);
      }
      else
      {
        result = sub_1002F9F0((float *)a1, v4);
      }
      break;
    case 6:
    case 7:
      sub_1002F080(&v8);
      if ( !sub_1002F660(&v10) || !sub_1002FC10(&v9) || v8 == 0.0 )
        goto LABEL_13;
      v10 = sqrt(v10 / v8);
      v6 = v10 - v9;
      result = 1;
      v10 = a2 * 0.5144444704055786;
      *(float *)a1 = v6 * v10;
      break;
    default:
LABEL_13:
      result = 0;
      break;
  }
  return result;
}

//----- (1002FFA0) --------------------------------------------------------
char __cdecl sub_1002FFA0(void *a1)
{
  char v1; // al@3
  float v2; // ST14_4@3
  char result; // al@3
  float v4; // [sp+8h] [bp-8h]@1
  float v5; // [sp+Ch] [bp-4h]@1

  v5 = 0.0;
  v4 = 0.0;
  memset(a1, 0, 0x2Cu);
  if ( sub_10033E20(&v4) )
    v5 = v4 * 1.943844437599182;
  *(_BYTE *)a1 = sub_1002F620((float *)a1 + 3);
  *((_BYTE *)a1 + 1) = sub_1002F3A0((bool *)a1 + 3, (unsigned int)a1 + 4);
  *((_BYTE *)a1 + 2) = sub_1002FC10((float *)a1 + 4);
  *((_BYTE *)a1 + 7) = sub_1002FAC0((float *)a1 + 2);
  v1 = sub_1002FDF0((float *)a1 + 5);
  v2 = v5;
  *((_BYTE *)a1 + 5) = v1;
  *((_BYTE *)a1 + 6) = sub_1002FE50((int)a1 + 24, v2);
  *((_BYTE *)a1 + 28) = sub_1002FBB0((float *)a1 + 8);
  result = sub_1002FD90((float *)a1 + 10);
  *((_BYTE *)a1 + 36) = result;
  return result;
}

//----- (10030050) --------------------------------------------------------
bool __cdecl sub_10030050(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  char v4; // dl@5
  bool result; // al@5

  v3 = a2;
  if ( a2 >= 0xFFu || a2 > 1u )
  {
    result = 0;
  }
  else
  {
    if ( dword_10957740 != 1379255385 )
    {
      sub_100386C0(a1, (int)&byte_10957748[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v4 = byte_1095774D[4 * (v3 + 6 * (unsigned __int8)a1)];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_1095774C[4 * (v3 + 6 * (unsigned __int8)a1)];
    result = (unsigned __int8)v4 < 0xBu;
  }
  return result;
}
// 10957740: using guessed type int dword_10957740;

//----- (100300C0) --------------------------------------------------------
bool __cdecl sub_100300C0(char a1, unsigned __int8 a2, int a3)
{
  bool result; // al@2

  if ( a2 < 1u )
  {
    if ( dword_10957740 != 1379255385 )
      sub_100386C0(a1, (int)&byte_10957748[24 * (unsigned __int8)a1]);
    *(_DWORD *)a3 = dword_1095775C[a2 + 6 * (unsigned __int8)a1];
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10957740: using guessed type int dword_10957740;
// 1095775C: using guessed type int dword_1095775C[];

//----- (10030120) --------------------------------------------------------
bool __cdecl sub_10030120(char a1, unsigned __int8 a2, int a3)
{
  unsigned __int8 v3; // cl@1
  bool result; // al@1
  int v5; // edx@5

  v3 = a2;
  result = 0;
  if ( (a2 & 0x80u) == 0 && a2 <= 1u )
  {
    if ( dword_10957740 != 1379255385 )
    {
      sub_100386C0(a1, (int)&byte_10957748[24 * (unsigned __int8)a1]);
      v3 = a2;
    }
    v5 = dword_10957754[v3 + 6 * (unsigned __int8)a1];
    *(_DWORD *)a3 = v5;
    result = (unsigned __int8)v5 < 0x13u && *(_BYTE *)(a3 + 1) < 0x13u;
  }
  return result;
}
// 10957740: using guessed type int dword_10957740;
// 10957754: using guessed type int dword_10957754[];

//----- (10030190) --------------------------------------------------------
char __cdecl sub_10030190(char a1, _BYTE *a2)
{
  if ( dword_10957740 != 1379255385 )
    sub_100386C0(a1, (int)&byte_10957748[24 * (unsigned __int8)a1]);
  *a2 = byte_10957748[24 * (unsigned __int8)a1];
  return 1;
}
// 10957740: using guessed type int dword_10957740;

//----- (100301D0) --------------------------------------------------------
char __thiscall sub_100301D0(void *this)
{
  char v1; // bl@1
  char *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_10957740 = sub_1002C5E0(this) != 2 ? 1379255385 : 1916032632;
  memset(byte_10957748, 0, 0x48u);
  v1 = 0;
  v4 = 0;
  v2 = byte_10957748;
  do
  {
    result = sub_100386C0(v4, (int)v2);
    ++v1;
    v2 += 24;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 3u );
  return result;
}
// 10957740: using guessed type int dword_10957740;

//----- (10030240) --------------------------------------------------------
char __cdecl sub_10030240(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1002D710(a1);
  v3 = sub_10061E60(a2, 0, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (10030270) --------------------------------------------------------
char __cdecl sub_10030270(char a1, int a2)
{
  int v2; // eax@1
  bool v3; // zf@1
  char result; // al@1

  v2 = sub_1002D710(a1);
  v3 = sub_10061ED0(a2, 0, v2) == 0;
  result = 1;
  if ( !v3 )
    result = 0;
  return result;
}

//----- (100302A0) --------------------------------------------------------
char __cdecl sub_100302A0(char a1, int a2, char a3, unsigned __int8 *a4, _BYTE *a5, unsigned int a6)
{
  char result; // al@3
  char v7; // [sp+0h] [bp-4h]@1

  v7 = sub_1002D800(a1);
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        result = sub_10030120(v7, *a4, (int)a5);
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 531, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        result = sub_10030050(v7, *a4, (int)a5);
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 548, 0, 0);
        result = 0;
      }
      break;
    case 3:
      if ( a6 >= 4 )
      {
        result = sub_100300C0(v7, *a4, (int)a5);
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 565, 0, 0);
        result = 0;
      }
      break;
    case 7:
      if ( a6 >= 1 )
      {
        result = sub_10030190(v7, a5);
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 582, 0, 0);
        result = 0;
      }
      break;
    case 0x10:
      if ( a6 >= 0x40 )
      {
        result = sub_10030270(v7, (int)a5);
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 598, 0, 0);
        result = 0;
      }
      break;
    case 0xF:
      if ( a6 >= 0x68 )
      {
        result = sub_10030240(v7, (int)a5);
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 616, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10028BC0("..\\lib\\acl\\iop\\iop_cdu_cnfg_intf.c", 633, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10030470) --------------------------------------------------------
char __cdecl sub_10030470(char a1, void *a2, void *a3, __int16 a4)
{
  char result; // al@1
  int v5; // esi@2

  result = 0;
  if ( a1 )
  {
    v5 = sub_10060A60(49, 40);
    memcpy_0(a2, a3, (unsigned __int16)a4);
    if ( !v5 )
      sub_10060A00(49);
    result = 1;
  }
  return result;
}

//----- (100304B0) --------------------------------------------------------
void *sub_100304B0()
{
  void *v0; // ebp@1
  void *v1; // esi@2
  signed int v2; // edi@2
  void *result; // eax@3
  signed int v4; // [sp+0h] [bp-14h]@1
  char v5; // [sp+4h] [bp-10h]@1
  float v6; // [sp+8h] [bp-Ch]@1
  int v7; // [sp+Ch] [bp-8h]@1
  int v8; // [sp+10h] [bp-4h]@1

  v6 = 9.9999996e24;
  byte_10957790 = 0;
  byte_10957791 = 0;
  byte_10957792 = 0;
  v5 = 0;
  v7 = 0x7FFFFFFF;
  v8 = 0x7FFFFFFF;
  v0 = &unk_109577B4;
  v4 = 2;
  do
  {
    *((_WORD *)v0 - 2) = 0;
    v1 = v0;
    v2 = 10;
    do
    {
      result = memcpy_0(v1, &v5, 0x10u);
      v1 = (char *)v1 + 16;
      --v2;
    }
    while ( v2 );
    v0 = (char *)v0 + 164;
    --v4;
  }
  while ( v4 );
  byte_10957793 = 0;
  return result;
}
// 10957790: using guessed type char byte_10957790;
// 10957791: using guessed type char byte_10957791;
// 10957792: using guessed type char byte_10957792;
// 10957793: using guessed type char byte_10957793;

//----- (10030550) --------------------------------------------------------
__int16 sub_10030550()
{
  int v1; // [sp+0h] [bp-8h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 1376), 2);
  sub_10047700(&v1, 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (100305A0) --------------------------------------------------------
char sub_100305A0()
{
  char v1; // [sp+3h] [bp-5h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  v2[0] = sub_1002BB20();
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 1714), 1);
  sub_100476D0((unsigned __int8 *)&v1, 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (100305F0) --------------------------------------------------------
__int16 sub_100305F0()
{
  int v1; // [sp+0h] [bp-8h]@1
  char v2[4]; // [sp+4h] [bp-4h]@1

  v2[0] = sub_1002BB20();
  v1 = 0;
  sub_10030470(v2[0], &v1, (void *)(dword_10A09AAC + 1378), 2);
  sub_10047700(&v1, 1);
  return v1;
}
// 10A09AAC: using guessed type int dword_10A09AAC;

//----- (10030640) --------------------------------------------------------
int __thiscall sub_10030640(void *this)
{
  int v1; // esi@1
  int v2; // ecx@1

  v1 = sub_1002C5C0(this);
  return v1 & ~j_HWM_pvg_hsdb_get_lrus_online(v2);
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);

//----- (10030660) --------------------------------------------------------
char __thiscall sub_10030660(void *this)
{
  char v1; // di@1
  void *v2; // esi@1
  char v3; // di@3
  void *v4; // esi@3
  char result; // al@4

  dword_109578F8 = sub_1002C5E0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_10957900, 0, 0x1540u);
  memset(&unk_10958E40, 0, 0x19B0u);
  v1 = 0;
  v2 = &unk_10957900;
  do
  {
    sub_100386E0(v1, (int)v2);
    v2 = (char *)v2 + 2720;
    ++v1;
  }
  while ( (signed int)v2 < (signed int)&unk_10958E40 );
  v3 = 0;
  v4 = &unk_10958E40;
  do
  {
    result = sub_10038760(v3, (int)v4);
    v4 = (char *)v4 + 2192;
    ++v3;
  }
  while ( (signed int)v4 < (signed int)&dword_1095A7F0 );
  return result;
}
// 109578F8: using guessed type int dword_109578F8;
// 1095A7F0: using guessed type int dword_1095A7F0;

//----- (100306F0) --------------------------------------------------------
char __cdecl sub_100306F0(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@3
  char v4; // [sp+4h] [bp-20h]@1
  char v5; // [sp+8h] [bp-1Ch]@3
  char v6[19]; // [sp+Dh] [bp-17h]@5

  v1 = 0;
  v4 = 0;
  do
  {
    if ( v1 )
      break;
    sub_100386C0(v4, (int)&v5);
    v2 = 0;
    do
    {
      if ( v1 )
        break;
      if ( v6[4 * v2] == a1 )
        v1 = 1;
      ++v2;
    }
    while ( v2 <= 1u );
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  return v1;
}
// 100306F0: using guessed type char var_17[19];

//----- (10030760) --------------------------------------------------------
char __cdecl sub_10030760(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // al@6
  char v6; // [sp+6h] [bp-2h]@1
  bool v7; // [sp+7h] [bp-1h]@1

  v2 = dword_109578F8 != 1379255385;
  v6 = 0;
  v7 = dword_109578F8 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10060C90(86, 10);
      memset((char *)&unk_10957900 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_100386E0(a1, (int)&unk_10957900 + 2720 * (unsigned __int8)a1);
      v2 = v7;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( byte_10957919[4 * (680 * (unsigned __int8)a1 + v5)] != a2 )
    {
      if ( ++v5 >= 0xBu )
        goto LABEL_11;
    }
    v6 = 1;
LABEL_11:
    if ( v2 )
      sub_10060C60(v4, 86);
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 109578F8: using guessed type int dword_109578F8;

//----- (10030820) --------------------------------------------------------
char __cdecl sub_10030820(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_109578F8 != 1379255385;
  v7 = 0;
  v8 = dword_109578F8 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10060C90(86, 10);
      memset((char *)&unk_10957900 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_100386E0(a1, (int)&unk_10957900 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 4 * (680 * (unsigned __int8)a1 + v5);
      if ( byte_10957BD8[v6] == a2 || byte_10957BD9[v6] == a2 )
        break;
      if ( ++v5 >= 8u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10060C60(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 109578F8: using guessed type int dword_109578F8;

//----- (100308E0) --------------------------------------------------------
char __cdecl sub_100308E0(int a1, char a2)
{
  bool v2; // dl@1
  char result; // al@2
  int v4; // edi@4
  unsigned __int8 v5; // cl@6
  int v6; // eax@7
  char v7; // [sp+6h] [bp-2h]@1
  bool v8; // [sp+7h] [bp-1h]@1

  v2 = dword_109578F8 != 1379255385;
  v7 = 0;
  v8 = dword_109578F8 != 1379255385;
  if ( (unsigned __int8)a1 < 2u )
  {
    if ( v2 )
    {
      v4 = sub_10060C90(86, 10);
      memset((char *)&unk_10957900 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
      sub_100386E0(a1, (int)&unk_10957900 + 2720 * (unsigned __int8)a1);
      v2 = v8;
    }
    else
    {
      v4 = a1;
    }
    v5 = 0;
    while ( 1 )
    {
      v6 = 8 * (340 * (unsigned __int8)a1 + v5);
      if ( byte_10957BF8[v6] == a2 || byte_10957BF9[v6] == a2 )
        break;
      if ( ++v5 >= 5u )
        goto LABEL_12;
    }
    v7 = 1;
LABEL_12:
    if ( v2 )
      sub_10060C60(v4, 86);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 109578F8: using guessed type int dword_109578F8;

//----- (100309A0) --------------------------------------------------------
char sub_100309A0()
{
  int v0; // esi@1

  v0 = 0;
  while ( !sub_10034410(v0) )
  {
    if ( ++v0 >= 2 )
      return 0;
  }
  return 1;
}

//----- (100309D0) --------------------------------------------------------
char __cdecl sub_100309D0(unsigned __int8 a1, char *a2, unsigned __int8 *a3)
{
  char result; // al@1
  unsigned __int8 v4; // bl@4
  char v5; // [sp+3h] [bp-Dh]@1
  char v6; // [sp+4h] [bp-Ch]@2
  int v7; // [sp+8h] [bp-8h]@1
  char v8[4]; // [sp+Ch] [bp-4h]@4

  result = 0;
  v5 = 0;
  v7 = 0;
  if ( a1 < 0x31u )
  {
    v6 = 0;
    do
    {
      if ( result )
        break;
      v4 = 0;
      v8[0] = 0;
      do
      {
        if ( result )
          break;
        sub_10046230(v6, v8[0], &v7);
        if ( (_BYTE)v7 == a1 )
        {
          *a2 = v6;
          v5 = 1;
          *a3 = v4;
        }
        result = v5;
        v8[0] = ++v4;
      }
      while ( v4 < 8u );
      ++v6;
    }
    while ( (unsigned __int8)v6 < 2u );
  }
  return result;
}

//----- (10030A60) --------------------------------------------------------
char __cdecl sub_10030A60(unsigned __int8 a1, char *a2, unsigned __int8 *a3)
{
  char result; // al@1
  unsigned __int8 v4; // bl@4
  char v5; // [sp+13h] [bp-15h]@1
  char v6; // [sp+14h] [bp-14h]@2
  char v7; // [sp+18h] [bp-10h]@4
  int v8; // [sp+1Ch] [bp-Ch]@1
  int v9; // [sp+20h] [bp-8h]@1

  result = 0;
  v5 = 0;
  v8 = 0;
  v9 = 0;
  if ( a1 < 0x1Du )
  {
    v6 = 0;
    do
    {
      if ( result )
        break;
      v4 = 0;
      v7 = 0;
      do
      {
        if ( result )
          break;
        sub_100462C0(v6, v7, &v8);
        if ( (_BYTE)v8 == a1 )
        {
          *a2 = v6;
          v5 = 1;
          *a3 = v4;
        }
        result = v5;
        v7 = ++v4;
      }
      while ( v4 < 5u );
      ++v6;
    }
    while ( (unsigned __int8)v6 < 2u );
  }
  return result;
}

//----- (10030B10) --------------------------------------------------------
char __cdecl sub_10030B10(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10030760(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10030B40) --------------------------------------------------------
char __cdecl sub_10030B40(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_10030820(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10030B70) --------------------------------------------------------
char __cdecl sub_10030B70(char a1)
{
  char result; // al@1
  int v2; // esi@1

  result = 0;
  v2 = 0;
  do
  {
    if ( result )
      break;
    result = sub_100308E0(v2++, a1);
  }
  while ( v2 < 2 );
  return result;
}

//----- (10030BA0) --------------------------------------------------------
bool sub_10030BA0()
{
  char v1; // [sp+7h] [bp-1h]@1

  v1 = 4;
  sub_10061C40(115, &v1);
  return v1 == 2 || sub_10030B10(37);
}

//----- (10030BE0) --------------------------------------------------------
bool sub_10030BE0()
{
  void *v0; // ecx@3

  return sub_100309A0() == 1 || sub_10030B40(17) == 1 || sub_10030B10(10) == 1 || sub_10038840(v0) == 1;
}

//----- (10030C20) --------------------------------------------------------
BOOL sub_10030C20()
{
  return sub_10030BE0() || sub_10030BA0();
}

//----- (10030C40) --------------------------------------------------------
void sub_10030C40()
{
  dword_10A09AA0 = -15;
}
// 10A09AA0: using guessed type int dword_10A09AA0;

//----- (10030C50) --------------------------------------------------------
signed int sub_10030C50()
{
  return sub_10061AA0((int)&off_100B971C);
}
// 100B971C: using guessed type char *off_100B971C;

//----- (10030C60) --------------------------------------------------------
void sub_10030C60()
{
  dword_1095A7F0 = -15;
}
// 1095A7F0: using guessed type int dword_1095A7F0;

//----- (10030C70) --------------------------------------------------------
char __cdecl sub_10030C70(unsigned __int8 a1, unsigned __int8 a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // eax@4
  __int16 v6; // di@4
  char result; // al@8
  char v8; // [sp+4h] [bp-30h]@1
  char v9[2]; // [sp+8h] [bp-2Ch]@4
  __int16 v10[19]; // [sp+Ah] [bp-2Ah]@4

  memset(&v8, 0, 0x2Cu);
  if ( a1 >= 0xB0u )
  {
    LOBYTE(v4) = v8;
  }
  else
  {
    LOBYTE(v4) = 0;
    if ( a2 )
    {
      do
      {
        if ( (unsigned __int8)v4 >= 0xAu )
          break;
        v5 = (unsigned __int8)v4;
        v6 = *(_WORD *)(a3 + 2 * (unsigned __int8)v4);
        LOBYTE(v4) = v4 + 1;
        v9[4 * v5] = a1;
        v10[2 * v5] = v6;
      }
      while ( (unsigned __int8)v4 < a2 );
    }
    v8 = v4;
  }
  if ( (_BYTE)v4 )
  {
    LOWORD(v4) = 4 * ((unsigned __int8)v4 + 1);
    sub_10015560(2, 570, &v8, 1, v4, 1);
    sub_10015710(2, 570, a4);
    result = v8;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10030C70: using guessed type char var_2C[2];
// 10030C70: using guessed type __int16 var_2A[19];

//----- (10030D40) --------------------------------------------------------
int __cdecl sub_10030D40(char a1, __int16 a2, int a3)
{
  __int16 v4; // [sp+0h] [bp-52Ch]@1
  char v5; // [sp+4h] [bp-528h]@1
  __int16 v6; // [sp+6h] [bp-526h]@1
  int v7; // [sp+8h] [bp-524h]@1

  v5 = a1;
  v4 = -32710;
  v6 = a2;
  v7 = a3;
  return sub_10060AC0(28, (int)&v4, 50000, 0);
}

//----- (10030DB0) --------------------------------------------------------
signed int sub_10030DB0()
{
  return sub_10061AA0((int)&off_100B9C78);
}
// 100B9C78: using guessed type char *off_100B9C78;

//----- (10030DC0) --------------------------------------------------------
unsigned __int8 __cdecl sub_10030DC0(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  unsigned __int8 v3; // bl@1
  int v4; // ebp@5
  int v5; // eax@7
  int v6; // edx@7

  v3 = 0;
  if ( (unsigned __int8)sub_10030DB0() && a1 < 0xB0u && !sub_10060A60(97, 100) )
  {
    if ( a3 > 0u )
    {
      v4 = 4 * a1;
      do
      {
        if ( v3 >= *(_BYTE *)(dword_1095A7F0 + v4) )
          break;
        v5 = 136 * (v3 + *(_WORD *)(dword_1095A7F0 + v4 + 2));
        v6 = a2 + 120 * v3;
        *(_BYTE *)v6 = *(_BYTE *)(v5 + dword_1095A7F0 + 705);
        *(_BYTE *)(v6 + 1) = *(_BYTE *)(v5 + dword_1095A7F0 + 706);
        qmemcpy((void *)(v6 + 4), (const void *)(v5 + dword_1095A7F0 + 724), 0x74u);
        ++v3;
        *(_WORD *)(v6 + 2) = *(_WORD *)(v5 + dword_1095A7F0 + 710);
      }
      while ( v3 < a3 );
    }
    sub_10060A00(97);
  }
  return v3;
}
// 1095A7F0: using guessed type int dword_1095A7F0;

//----- (10030E90) --------------------------------------------------------
char __cdecl sub_10030E90(unsigned __int8 a1, __int16 a2, char *a3)
{
  unsigned __int8 v3; // al@1
  unsigned __int8 v4; // cl@1
  char result; // al@4
  int v6; // ecx@6
  char v7[2]; // [sp+8h] [bp-3844h]@1
  __int16 v8; // [sp+Ah] [bp-3842h]@2
  char v9[14396]; // [sp+Ch] [bp-3840h]@6

  v3 = sub_10030DC0(a1, (int)v7, 0x78u);
  v4 = 0;
  if ( v3 )
  {
    while ( *(&v8 + 60 * v4) != a2 )
    {
      if ( ++v4 >= v3 )
        return 0;
    }
    v6 = 120 * v4;
    result = v7[v6];
    qmemcpy(a3, &v9[v6], 0x74u);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10030E90: using guessed type char var_3844[2];
// 10030E90: using guessed type char var_3840[14396];

//----- (10030F50) --------------------------------------------------------
void sub_10030F50()
{
  dword_1095A7F4 = -15;
}
// 1095A7F4: using guessed type int dword_1095A7F4;

//----- (10030F70) --------------------------------------------------------
signed int sub_10030F70()
{
  return sub_10061AA0((int)&off_100B9CE8);
}
// 100B9CE8: using guessed type char *off_100B9CE8;

//----- (10030F80) --------------------------------------------------------
int sub_10030F80()
{
  return (unsigned __int8)sub_10030F70() != 0 ? dword_1095A7F4 : 0;
}
// 1095A7F4: using guessed type int dword_1095A7F4;

//----- (10030F90) --------------------------------------------------------
int sub_10030F90()
{
  int result; // eax@2

  if ( (unsigned __int8)sub_10030F70() )
    result = dword_1095A7F4 + 55656;
  else
    result = 0;
  return result;
}
// 1095A7F4: using guessed type int dword_1095A7F4;

//----- (10030FB0) --------------------------------------------------------
int __cdecl sub_10030FB0(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 0, 0, 0);
}

//----- (10030FD0) --------------------------------------------------------
unsigned int __cdecl sub_10030FD0(void *a1)
{
  return sub_10033AA0(a1, 0x20u, 0);
}

//----- (10030FF0) --------------------------------------------------------
unsigned int __cdecl sub_10030FF0(void *a1)
{
  return sub_10033AA0(a1, 0x1Cu, 0);
}

//----- (10031010) --------------------------------------------------------
unsigned int __cdecl sub_10031010(void *a1)
{
  return sub_10033AA0(a1, 0x10u, 0);
}

//----- (10031030) --------------------------------------------------------
unsigned int __cdecl sub_10031030(void *a1)
{
  return sub_10033AA0(a1, 0xCu, 0);
}

//----- (10031050) --------------------------------------------------------
unsigned int __cdecl sub_10031050(void *a1)
{
  return sub_10033AA0(a1, 8u, 0);
}

//----- (10031070) --------------------------------------------------------
int __cdecl sub_10031070(int a1)
{
  int result; // eax@1

  result = sub_10033B00((unsigned __int8 *)(a1 + 1), 1u, 0x1Fu, 1u, 0);
  if ( !result )
  {
    result = sub_10033B00((unsigned __int8 *)a1, 1u, 0xCu, 1u, 0);
    if ( !result )
      result = sub_10033B50((_BYTE *)(a1 + 2), 0x7C6u, 0xFFFFu, 1990, 0);
  }
  return result;
}

//----- (100310C0) --------------------------------------------------------
int __cdecl sub_100310C0(int a1)
{
  int result; // eax@1

  result = sub_10033750(
             a1,
             -3.1415926535898,
             3.1415926535898,
             COERCE_UNSIGNED_INT64(0.0),
             COERCE_UNSIGNED_INT64(0.0) >> 32,
             0);
  if ( !result )
    result = sub_10033750(
               a1 + 8,
               -6.2831853071796,
               6.2831853071796,
               COERCE_UNSIGNED_INT64(0.0),
               COERCE_UNSIGNED_INT64(0.0) >> 32,
               0);
  return result;
}

//----- (10031120) --------------------------------------------------------
int __cdecl sub_10031120(int a1)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int result; // eax@2

  v1 = a1;
  v2 = 0;
  do
  {
    result = sub_100338A0(v1, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0);
    if ( result )
      break;
    ++v2;
    v1 += 4;
  }
  while ( v2 < 3 );
  return result;
}

//----- (10031170) --------------------------------------------------------
int __cdecl sub_10031170(void *a1)
{
  int result; // eax@1

  result = sub_10030FD0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10030FD0((char *)a1 + 128);
    if ( !result )
    {
      result = sub_10031050((char *)a1 + 120);
      if ( !result )
      {
        result = sub_10030FF0((char *)a1 + 36);
        if ( !result )
        {
          result = sub_10031070((int)a1 + 168);
          if ( !result )
          {
            result = sub_10031070((int)a1 + 160);
            if ( !result )
            {
              result = sub_10031070((int)a1 + 164);
              if ( !result )
              {
                result = sub_10031010(a1);
                if ( !result )
                {
                  result = sub_10031030((char *)a1 + 96);
                  if ( !result )
                  {
                    result = sub_10031030((char *)a1 + 24);
                    if ( !result )
                      result = sub_10031050((char *)a1 + 16);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10031240) --------------------------------------------------------
unsigned int __cdecl sub_10031240(void *a1)
{
  unsigned int result; // eax@1

  result = sub_10030FD0((char *)a1 + 64);
  if ( !result )
  {
    result = sub_10030FF0((char *)a1 + 36);
    if ( !result )
    {
      result = sub_10031010(a1);
      if ( !result )
      {
        result = sub_10031030((char *)a1 + 96);
        if ( !result )
        {
          result = sub_10031030((char *)a1 + 24);
          if ( !result )
            result = sub_10031050((char *)a1 + 16);
        }
      }
    }
  }
  return result;
}

//----- (100312A0) --------------------------------------------------------
int __cdecl sub_100312A0(char *a1, char a2)
{
  signed int v2; // eax@2
  int result; // eax@4
  int v4; // [sp+8h] [bp-ECh]@1
  char v5; // [sp+24h] [bp-D0h]@4

  v4 = 0;
  if ( a2 == 1 )
    v2 = 2;
  else
    v2 = a2 == 2;
  result = j_HWM_pvg_rgn_get_info(v2, &v4);
  qmemcpy(a1, &v5, 0x74u);
  return result;
}
// 10061CF0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10031310) --------------------------------------------------------
bool __cdecl sub_10031310(int a1, void *a2)
{
  void *v2; // ecx@0
  char v3; // si@1
  char v4; // bl@1
  int v5; // esi@4
  bool result; // al@7

  v3 = sub_1002DB00(v2);
  v4 = 0;
  do
  {
    if ( (_BYTE)a1 == (char)off_100BA230[(unsigned __int8)v4](v3) )
    {
      sub_100312A0((char *)a2, v4);
      return 1;
    }
    ++v4;
  }
  while ( (unsigned __int8)v4 < 3u );
  v5 = (unsigned __int16)sub_1002DBA0(a1);
  if ( (unsigned __int16)v5 >= (unsigned __int16)sub_10014DC0(2) )
    result = 0;
  else
    result = sub_10015AC0(2, v5, a2) == 1 && !sub_10031240(a2);
  return result;
}
// 100BA230: using guessed type int (__cdecl *off_100BA230[3])(char);

//----- (100313D0) --------------------------------------------------------
char __cdecl sub_100313D0(int a1, bool *a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-78h]@2
  int v4; // [sp+78h] [bp-8h]@3

  switch ( (unsigned __int8)a1 )
  {
    case 1u:
    case 4u:
    case 7u:
    case 0xAu:
      if ( sub_10031310(a1, &v3) )
      {
        *a2 = (v4 & 1) == 1;
        result = 1;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      *a2 = sub_1002DB80(a1) != 67;
      result = 1;
      break;
  }
  return result;
}

//----- (10031490) --------------------------------------------------------
int __cdecl sub_10031490(int *a1)
{
  int result; // eax@1

  result = sub_10049620((int)(a1 + 1), 0);
  if ( result )
  {
    *a1 = sub_10060900();
    result = sub_10049460();
  }
  return result;
}

//----- (100314C0) --------------------------------------------------------
char __usercall sub_100314C0@<al>(int a1@<eax>, int a2@<ecx>)
{
  int v2; // eax@2
  char *v3; // eax@2
  char result; // al@2
  int v5; // eax@4
  char *v6; // eax@4

  if ( a2 == 13 )
  {
    v2 = sub_10060A60(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 88));
    v3 = sub_1004A6E0("%i %i\r\n", 13, v2);
    sub_10049C80(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"356", (int)v3);
    result = 1;
  }
  else if ( a2 == 14 )
  {
    v5 = sub_10060A00(*(_DWORD *)(a1 + 4));
    v6 = sub_1004A6E0("%i %i\r\n", 14, v5);
    sub_10049C80(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)&unk_100BA614, (int)v6);
    result = 1;
  }
  else
  {
    sub_10028BC0(".\\test\\tst_tsk_common.c", 405, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10031560) --------------------------------------------------------
int __cdecl sub_10031560(const char *a1)
{
  int result; // eax@1

  result = sub_10047780();
  if ( a1 )
    result = sub_10049650(dword_1095A7FC[result] + 4, (int)a1, strlen(a1));
  return result;
}
// 1095A7FC: using guessed type int dword_1095A7FC[];

//----- (100315A0) --------------------------------------------------------
char __cdecl sub_100315A0(void *a1)
{
  int (**v1)(); // eax@1
  char **v2; // eax@1

  memset(a1, 0, 0xE0u);
  sub_100495A0((char *)a1 + 4);
  v1 = sub_10020AA0();
  sub_10049540((int)v1, 0, 0);
  dword_1095A7FC[sub_10047780()] = (int)a1;
  v2 = sub_1004FFC0((int)sub_10031560);
  return sub_10049670(v2);
}
// 1095A7FC: using guessed type int dword_1095A7FC[];

//----- (100315F0) --------------------------------------------------------
signed int __cdecl sub_100315F0(unsigned int a1, int a2)
{
  signed int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // ebx@1
  int v5; // ebp@1
  signed int result; // eax@3
  char *v7; // eax@10
  __int16 v8; // ax@11
  char *v9; // eax@13
  char *v10; // eax@14
  char *v11; // eax@16
  int v12; // ebx@17
  char *v13; // eax@18
  char *v14; // eax@19
  char **v15; // eax@23
  char **v16; // eax@23
  char **v17; // eax@23
  char **v18; // eax@24
  char **v19; // eax@24
  char **v20; // eax@24
  int v21; // [sp-4h] [bp-30h]@9
  int v22; // [sp-4h] [bp-30h]@17
  char v23; // [sp+10h] [bp-1Ch]@6
  char v24; // [sp+14h] [bp-18h]@14

  v2 = 4;
  v3 = sub_10060900();
  v4 = *(_DWORD *)(a2 + 4);
  v5 = v3;
  if ( a1 < 8 )
  {
LABEL_28:
    result = v2;
  }
  else
  {
    switch ( a1 )
    {
      case 0xBu:
        sub_10060B90(*(_DWORD *)(a2 + 4));
        result = 0;
        break;
      case 0xCu:
        if ( sub_10060900() - v3 < v4 )
        {
          do
          {
            if ( *(_BYTE *)(a2 + 88) )
              sub_10060C20(&v23);
          }
          while ( sub_10060900() - v5 < v4 );
        }
        result = 0;
        break;
      case 8u:
        v21 = *(_DWORD *)(a2 + 4);
        if ( v4 < 0x40 )
        {
          v8 = sub_100608B0(v21);
          if ( v8 & 0xF32 || v8 & 0xC4 )
          {
            sub_10060920((int)&v24, 1, *(_DWORD *)(a2 + 4), 20);
            v10 = sub_1004A6E0("The %s task is loaded.", &v24);
            sub_10049C80(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"512", (int)v10);
            result = 0;
          }
          else
          {
            v9 = sub_1004A6E0("Task #%d is not loaded.", *(_DWORD *)(a2 + 4));
            sub_10049C80(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"520", (int)v9);
            result = 12;
          }
        }
        else
        {
          v7 = sub_1004A6E0("Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.", v21);
          sub_10049C80(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"489", (int)v7);
          result = 9;
        }
        break;
      case 9u:
        if ( v4 >= 0x40 )
        {
          v11 = sub_1004A6E0(
                  "Task id %d is not valid, it must be between TSK_BKGD_TSK and TSK_TASK_COUNT.",
                  *(_DWORD *)(a2 + 4));
          sub_10049C80(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"543", (int)v11);
        }
        v12 = sub_10060810(*(_DWORD *)(a2 + 4));
        v22 = *(_DWORD *)(a2 + 88);
        if ( v12 == *(_DWORD *)(a2 + 88) )
        {
          v13 = sub_1004A6E0("The %d task's level is equal to %d.", *(_DWORD *)(a2 + 4), v22);
          sub_10049C80(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"557", (int)v13);
          v2 = 0;
        }
        else
        {
          v14 = sub_1004A6E0("The %d task's level is equal to %d, not %d.", *(_DWORD *)(a2 + 4), v12, v22);
          sub_10049C80(3, (int)"**MSG**", (int)".\\test\\tst_tsk_common.c", (int)"562", (int)v14);
          v2 = 12;
        }
        if ( v12 )
          goto LABEL_28;
        sub_10049C80(
          3,
          (int)"**MSG**",
          (int)".\\test\\tst_tsk_common.c",
          (int)"572",
          (int)"The task's criticality level is zero, make sure the task is running.");
        result = v2;
        break;
      case 0xAu:
        sub_100609B0(v4, *(_DWORD *)(a2 + 88), 0, 0);
        result = 4;
        break;
      case 0x12u:
        v15 = sub_1004FFC0((int)sub_10031560);
        sub_10049D50((int)v15);
        v16 = sub_10051390((int)sub_10031560);
        sub_10049D50((int)v16);
        v17 = sub_10051390((int)sub_10031560);
        sub_10049670(v17);
        result = 4;
        break;
      case 0x13u:
        v18 = sub_1004FFC0((int)sub_10031560);
        sub_10049D50((int)v18);
        v19 = sub_10051390((int)sub_10031560);
        sub_10049D50((int)v19);
        v20 = sub_1004FFC0((int)sub_10031560);
        sub_10049670(v20);
        result = 4;
        break;
      default:
        if ( a1 - 13 > 4 )
        {
          v2 = 11;
          goto LABEL_28;
        }
        result = sub_100314C0(a2, a1) != 0 ? 0 : 12;
        break;
    }
  }
  return result;
}

//----- (10031990) --------------------------------------------------------
char **sub_10031990()
{
  return off_100BA600;
}
// 100BA600: using guessed type char *off_100BA600[3];

//----- (100319A0) --------------------------------------------------------
char sub_100319A0()
{
  void *v0; // ecx@1
  char result; // al@1
  int v2; // edx@1
  int v3; // ecx@1
  void *v4; // ecx@1
  void *v5; // ecx@1
  void *v6; // ecx@1

  j_FIL_vfs_dyn_linker();
  nullsub_1(v3, v2);
  sub_10048660();
  sub_10030660(v4);
  sub_100301D0(v5);
  sub_10045C60(v6);
  sub_10033D90();
  sub_10001100();
  dword_10957728 = sub_1002C660(v0);
  sub_10060E80(6465, (int)&dword_1095770C, 28);
  result = sub_10043D40();
  if ( !result )
  {
    result = dword_10957728;
    dword_1095770C = dword_10957728;
    dword_10957710 = dword_10957728;
    dword_10957714 = dword_10957728;
    dword_10957718 = dword_10957728;
    dword_1095771C = dword_10957728;
    dword_10957720 = dword_10957728;
    dword_10957724 = dword_10957728;
  }
  return result;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 100610E0: using guessed type int j_FIL_vfs_dyn_linker(void);
// 1095770C: using guessed type int dword_1095770C;
// 10957710: using guessed type int dword_10957710;
// 10957714: using guessed type int dword_10957714;
// 10957718: using guessed type int dword_10957718;
// 1095771C: using guessed type int dword_1095771C;
// 10957720: using guessed type int dword_10957720;
// 10957724: using guessed type int dword_10957724;
// 10957728: using guessed type int dword_10957728;

//----- (100319D0) --------------------------------------------------------
char __cdecl sub_100319D0(char a1)
{
  char result; // al@4

  switch ( a1 )
  {
    case 25:
      result = 0;
      break;
    case 26:
      result = 1;
      break;
    case 43:
      result = 2;
      break;
    default:
      sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 169, 0, 0);
      result = 3;
      break;
  }
  return result;
}

//----- (10031A10) --------------------------------------------------------
char __cdecl sub_10031A10(char a1)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 26;
    }
    else if ( a1 == 2 )
    {
      result = 43;
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 259, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 25;
  }
  return result;
}

//----- (10031A50) --------------------------------------------------------
signed int __cdecl sub_10031A50(char a1)
{
  signed int result; // eax@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 0x2000;
    }
    else if ( a1 == 2 )
    {
      result = 0x80000;
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_data_intf.c", 317, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 4096;
  }
  return result;
}

//----- (10031AA0) --------------------------------------------------------
char __cdecl sub_10031AA0(char a1)
{
  return sub_10031C40((int)&unk_100BACD0, a1, 0x21u);
}

//----- (10031AC0) --------------------------------------------------------
char __cdecl sub_10031AC0(char a1)
{
  char result; // al@3

  if ( a1 == 6 )
  {
    result = 0;
  }
  else if ( a1 == 7 )
  {
    result = 1;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 294, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10031B00) --------------------------------------------------------
char __cdecl sub_10031B00(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 11;
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 597, 0, 0);
      result = -80;
    }
  }
  else
  {
    result = 5;
  }
  return result;
}

//----- (10031B40) --------------------------------------------------------
char __cdecl sub_10031B40(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 7;
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 648, 0, 0);
      result = 67;
    }
  }
  else
  {
    result = 6;
  }
  return result;
}

//----- (10031B80) --------------------------------------------------------
signed int __cdecl sub_10031B80(char a1)
{
  signed int result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 512;
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 699, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = 256;
  }
  return result;
}

//----- (10031BC0) --------------------------------------------------------
char __cdecl sub_10031BC0(char a1)
{
  char result; // al@3

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = 6;
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 750, 0, 0);
      result = -80;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10031C00) --------------------------------------------------------
char __cdecl sub_10031C00(int a1)
{
  char result; // al@3

  if ( a1 == 256 )
  {
    result = 0;
  }
  else if ( a1 == 512 )
  {
    result = 1;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_data_intf.c", 800, 0, 0);
    result = 2;
  }
  return result;
}

//----- (10031C40) --------------------------------------------------------
char __usercall sub_10031C40@<al>(int a1@<edi>, char a2, unsigned __int8 a3)
{
  int v3; // esi@1
  int v4; // eax@1
  char result; // al@2

  v3 = a3;
  v4 = sub_1002CC90(&a2, 1u, a1, 2, a3, a3);
  if ( v4 >= v3 )
    result = -80;
  else
    result = *(_BYTE *)(a1 + 2 * v4 + 1);
  return result;
}

//----- (10031C70) --------------------------------------------------------
char __cdecl sub_10031C70(char a1)
{
  return sub_10031C40((int)&unk_100BAD98, a1, 0x33u);
}

//----- (10031C90) --------------------------------------------------------
char __cdecl sub_10031C90(char a1)
{
  return sub_10031C40((int)&unk_100BAE00, a1, 0x31u);
}

//----- (10031CB0) --------------------------------------------------------
char __cdecl sub_10031CB0(char a1)
{
  return sub_10031C40((int)&unk_100BAE64, a1, 0x1Du);
}

//----- (10031CD0) --------------------------------------------------------
char __cdecl sub_10031CD0(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10031C70(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_1002DB80(v2);
  return result;
}

//----- (10031D00) --------------------------------------------------------
char __cdecl sub_10031D00(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10031C90(a1);
  if ( v2 == -80 )
    result = 67;
  else
    result = sub_1002DB80(v2);
  return result;
}

//----- (10031D30) --------------------------------------------------------
char __cdecl sub_10031D30(char a1)
{
  char result; // al@2
  unsigned __int8 v2; // [sp+4h] [bp-4h]@1

  v2 = sub_10031CB0(a1);
  if ( v2 == -80 )
  {
    result = 57;
    if ( a1 != 4 )
      result = 67;
  }
  else
  {
    result = sub_1002DB80(v2);
  }
  return result;
}

//----- (10031D70) --------------------------------------------------------
char __cdecl sub_10031D70(char a1, char a2, char *a3, char *a4)
{
  char *v4; // ebp@1
  int v5; // edi@1
  int v6; // esi@1
  char v7; // bl@1
  int v8; // eax@1
  int v9; // esi@5
  char v10; // al@11
  unsigned __int8 v11; // al@26
  bool v12; // cf@26
  bool v13; // zf@26
  char v15[4]; // [sp+10h] [bp-58h]@9
  char v16[24]; // [sp+14h] [bp-54h]@22
  char v17[56]; // [sp+2Ch] [bp-3Ch]@33

  v4 = a4;
  v5 = 904;
  v6 = 1000;
  v7 = 0;
  v8 = sub_1002CC90(&a1, 1u, (int)&unk_100BBD30, 4, 8, 8);
  if ( v8 < 8 )
    v5 = (unsigned __int16)word_100BBD32[2 * v8];
  switch ( a1 )
  {
    case 3:
    case 4:
    case 5:
      if ( a2 )
        v9 = (unsigned __int8)*a3 + 2;
      else
        v9 = (unsigned __int8)*a3;
      if ( (unsigned __int16)v5 < 0x388u && v9 < 4 && sub_10015AC0(2, v5, v15) == 1 && !sub_1001B140((int)v15) )
      {
        v10 = v15[v9];
        goto LABEL_36;
      }
      return v7;
    case 6:
    case 7:
      if ( a2 )
      {
        if ( a2 == 1 )
        {
          v6 = (unsigned __int8)*a3 + 8;
        }
        else if ( a2 == 2 )
        {
          if ( (unsigned __int8)*a3 < 8u )
            v6 = (unsigned __int8)*a3 + 13;
        }
        else
        {
          v6 = (unsigned __int8)*a3 + 21;
        }
      }
      else
      {
        v6 = (unsigned __int8)*a3;
      }
      if ( (unsigned __int16)v5 < 0x388u && v6 < 23 && sub_10015AC0(2, v5, v16) == 1 && !sub_1001B1F0((int)v16) )
      {
        *v4 = v16[v6];
        goto LABEL_37;
      }
      return v7;
    case 0x19:
    case 0x1A:
    case 0x2B:
      if ( a2 == 2 )
      {
        v11 = *a3;
        if ( (unsigned __int8)*a3 < 0x10u )
          goto LABEL_31;
        v12 = v11 < 0x28u;
        v13 = v11 == 40;
      }
      else
      {
        v11 = *a3;
        v12 = (unsigned __int8)*a3 < 0x10u;
        v13 = *a3 == 16;
      }
      if ( v12 || v13 )
        v6 = v11;
LABEL_31:
      if ( (unsigned __int16)v5 < 0x388u && v6 < 56 && sub_10015AC0(2, v5, v17) == 1 && !sub_1001B9A0((int)v17) )
      {
        v10 = v17[v6];
LABEL_36:
        *v4 = v10;
LABEL_37:
        v7 = 1;
      }
      return v7;
    default:
      return v7;
  }
}
// 100BBD32: using guessed type __int16 word_100BBD32[];
// 10031D70: using guessed type char var_58[4];
// 10031D70: using guessed type char var_54[24];
// 10031D70: using guessed type char var_3C[56];

//----- (10031F80) --------------------------------------------------------
char __usercall sub_10031F80@<al>(char a1@<bl>, char *a2@<edi>, char a3, char a4, char *a5)
{
  int v5; // esi@1
  int v6; // eax@2
  char v7; // al@4
  signed int v8; // ecx@4
  char v9; // dl@8
  char v10; // al@12
  int v11; // ecx@23
  unsigned __int8 v12; // cl@25
  bool v13; // cf@26
  bool v14; // zf@26
  char v15; // cl@34
  char v17; // [sp+Bh] [bp-E5h]@1
  char v18[46]; // [sp+Ch] [bp-E4h]@1
  char v19[12]; // [sp+3Ah] [bp-B6h]@9
  char v20[170]; // [sp+46h] [bp-AAh]@34

  v5 = 1000;
  v17 = 0;
  if ( sub_10060D80(6286, (int)v18, 226) )
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    switch ( a1 )
    {
      case 3:
      case 4:
      case 5:
        v7 = sub_1002D800(a1);
        v8 = (unsigned __int8)*a2;
        if ( a3 )
          v8 += 2;
        if ( (unsigned __int8)v7 >= 3u || v8 >= 4 )
          goto LABEL_10;
        v9 = 1;
        v17 = 1;
        if ( !a4 )
        {
          *a5 = *(&v19[4 * (unsigned __int8)v7] + v8);
          goto LABEL_10;
        }
        *(&v19[4 * (unsigned __int8)v7] + v8) = *a5;
        goto LABEL_36;
      default:
        goto LABEL_10;
      case 6:
      case 7:
        v10 = sub_10031AC0(a1);
        v9 = 1;
        if ( a3 )
        {
          if ( a3 == 1 )
          {
            v5 = (unsigned __int8)*a2 + 8;
          }
          else if ( a3 == 2 )
          {
            if ( (unsigned __int8)*a2 < 8u )
              v5 = (unsigned __int8)*a2 + 13;
          }
          else
          {
            v5 = (unsigned __int8)*a2 + 21;
          }
        }
        else
        {
          v5 = (unsigned __int8)*a2;
        }
        if ( (unsigned __int8)v10 >= 2u || v5 >= 23 )
          goto LABEL_10;
        v17 = 1;
        if ( !a4 )
        {
          v11 = (unsigned __int8)v6;
          LOBYTE(v6) = 1;
          *a5 = *(&v18[23 * v11] + v5);
          return v6;
        }
        *(&v18[23 * (unsigned __int8)v10] + v5) = *a5;
        goto LABEL_36;
      case 0x19:
      case 0x1A:
      case 0x2B:
        LOBYTE(v6) = sub_100319D0(a1);
        v12 = *a2;
        if ( a3 == 2 )
        {
          if ( v12 < 0x10u )
            goto LABEL_31;
          v13 = v12 < 0x28u;
          v14 = v12 == 40;
        }
        else
        {
          v13 = v12 < 0x10u;
          v14 = v12 == 16;
        }
        if ( v13 || v14 )
          v5 = v12;
LABEL_31:
        if ( (unsigned __int8)v6 >= 3u || v5 >= 56 )
          goto LABEL_10;
        v9 = 1;
        v17 = 1;
        v6 = (unsigned __int8)v6;
        if ( a4 )
        {
          *(&v20[56 * v6] + v5) = *a5;
LABEL_36:
          if ( a4 == v9 )
            v6 = sub_10060ED0(6286, (int)v18, 226) == 0;
          else
LABEL_10:
            LOBYTE(v6) = v17;
        }
        else
        {
          v15 = *(&v20[56 * v6] + v5);
          LOBYTE(v6) = 1;
          *a5 = v15;
        }
        break;
    }
  }
  return v6;
}
// 10031F80: using guessed type char var_E4[46];
// 10031F80: using guessed type char var_B6[12];
// 10031F80: using guessed type char var_AA[170];

//----- (100321C0) --------------------------------------------------------
char __cdecl sub_100321C0(char a1, char a2, char *a3, char *a4)
{
  return sub_10031F80(a1, a3, a2, 0, a4);
}

//----- (100321F0) --------------------------------------------------------
signed int __cdecl sub_100321F0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  bool v2; // dl@2
  unsigned __int8 v3; // cl@2
  signed int v4; // ebp@8
  void *v5; // ecx@8
  unsigned __int8 v6; // bl@9
  signed int result; // eax@14
  int v8; // [sp+8h] [bp-250h]@0
  char v9[68]; // [sp+Ch] [bp-24Ch]@9
  char v10; // [sp+50h] [bp-208h]@2
  char v11[2]; // [sp+A8h] [bp-1B0h]@5
  char v12[426]; // [sp+AAh] [bp-1AEh]@4

  if ( sub_10032830(v1) )
  {
    v2 = sub_10060D80(6444, (int)&v10, 514) == 0;
    v3 = 0;
    while ( !v2 || !v12[12 * v3] || !(a1 & (unsigned __int8)v11[v3]) )
    {
      if ( ++v3 >= 2u )
        goto LABEL_7;
    }
    result = 0x8000;
  }
  else
  {
LABEL_7:
    LOBYTE(v8) = 0;
    while ( 1 )
    {
      v4 = sub_10031B80(v8);
      if ( (v4 & sub_1002C5C0(v5)) == v4 )
        break;
LABEL_13:
      LOBYTE(v8) = v8 + 1;
      if ( (unsigned __int8)v8 >= 2u )
        return 0;
    }
    sub_100461C0(v8, v9);
    v6 = 0;
    while ( !sub_10030820(v8, byte_100BBDAD[2 * v6]) || !(a1 & (unsigned __int8)v9[12 * v6]) )
    {
      if ( ++v6 >= 2u )
        goto LABEL_13;
    }
    result = v4;
  }
  return result;
}
// 100321F0: using guessed type char var_1AE[426];
// 100321F0: using guessed type char var_1B0[2];
// 100321F0: using guessed type char var_24C[68];

//----- (10032320) --------------------------------------------------------
bool __cdecl sub_10032320(int a1)
{
  return sub_10060D80(3205, a1, 1) == 0;
}

//----- (10032340) --------------------------------------------------------
char __cdecl sub_10032340(unsigned __int8 a1, unsigned __int8 a2)
{
  int v2; // eax@1
  int v4; // [sp+8h] [bp-250h]@0
  char v5[68]; // [sp+Ch] [bp-24Ch]@7
  char v6; // [sp+50h] [bp-208h]@1
  char v7[2]; // [sp+A8h] [bp-1B0h]@5
  char v8[426]; // [sp+AAh] [bp-1AEh]@4

  memset(&v6, 0, 0x202u);
  v2 = sub_100321F0(a2);
  if ( v2 == 256 || v2 == 512 )
  {
    LOBYTE(v4) = sub_10031C00(v2);
    sub_100461C0(v4, v5);
    if ( sub_10030820(v4, byte_100BBDAD[2 * a1]) && (a2 & (unsigned __int8)v5[12 * a1]) == a2 )
      return 1;
  }
  else if ( v2 == 0x8000 )
  {
    sub_10060D80(6444, (int)&v6, 514);
    if ( v8[12 * a1] )
    {
      if ( (a2 & (unsigned __int8)v7[a1]) == a2 )
        return 1;
    }
  }
  return 0;
}
// 10032340: using guessed type char var_1AE[426];
// 10032340: using guessed type char var_1B0[2];
// 10032340: using guessed type char var_24C[68];

//----- (10032470) --------------------------------------------------------
char __thiscall sub_10032470(void *this)
{
  char result; // al@2
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  if ( sub_10060D80(9196, (int)&v2 + 3, 1) )
    result = 0;
  else
    result = BYTE3(v2);
  return result;
}

//----- (100324A0) --------------------------------------------------------
char __cdecl sub_100324A0(char a1)
{
  void *v1; // ecx@0
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      sub_10060E00(6470, (int)&a1, 1);
      result = a1 && sub_100321F0(2u);
    }
    else if ( a1 == 2 )
    {
      result = sub_10030B70(14);
    }
    else
    {
      sub_10028BC0("..\\lib\\adl\\iop_dl_wx_intf_a.c", 475, 1, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_100336A0(v1);
  }
  return result;
}

//----- (10032520) --------------------------------------------------------
BOOL sub_10032520()
{
  return sub_100324A0(0) || sub_100324A0(1) || sub_100324A0(2);
}

//----- (10032560) --------------------------------------------------------
char __cdecl sub_10032560(unsigned __int8 a1)
{
  unsigned __int8 v1; // bl@1
  char result; // al@10
  int v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@4

  v1 = 0;
  LOBYTE(v3) = 0;
  if ( (unsigned __int8)sub_10032520() )
  {
    if ( sub_10060D80(dword_100BC2E0[a1], (int)&v3, 1) || !sub_100324A0(v3) )
    {
      LOBYTE(v3) = 0;
      LOBYTE(v4) = 0;
      while ( !sub_100324A0(v4) )
      {
        LOBYTE(v4) = ++v1;
        if ( v1 > 3u )
          goto LABEL_9;
      }
      LOBYTE(v3) = v1;
LABEL_9:
      sub_10060ED0(dword_100BC2E0[a1], (int)&v3, 1);
    }
    result = v3;
  }
  else
  {
    result = v3;
  }
  return result;
}
// 100BC2E0: using guessed type int dword_100BC2E0[];

//----- (10032600) --------------------------------------------------------
char __cdecl sub_10032600(char *a1)
{
  int v1; // ecx@0
  int v3; // [sp-2h] [bp-4h]@1

  v3 = v1;
  sub_1002C500(13, (char *)&v3 + 3);
  sub_1002C500(12, a1);
  return BYTE3(v3);
}

//----- (10032630) --------------------------------------------------------
char __cdecl sub_10032630(int a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  v2 = sub_10032600((char *)&v4);
  if ( v2 )
  {
    if ( sub_1002C420(v1) == 1 )
      sub_10051400((int *)&v4, v4);
    sub_1002C910(a1, v4);
  }
  return v2;
}

//----- (10032680) --------------------------------------------------------
int __cdecl sub_10032680(unsigned __int8 a1)
{
  int result; // eax@2

  if ( a1 >= 0x34u )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\wx\\iop_wx_intf.c", 632, 1, 0);
    result = 138;
  }
  else
  {
    result = dword_100BCAF4[4 * a1];
  }
  return result;
}
// 100BCAF4: using guessed type int dword_100BCAF4[];

//----- (100326C0) --------------------------------------------------------
char __cdecl sub_100326C0(void *a1)
{
  *(_DWORD *)a1 = 0;
  return sub_10015AC0(2, 363, a1);
}

//----- (100326E0) --------------------------------------------------------
char __cdecl sub_100326E0(void *a1)
{
  int v1; // edx@2
  int v2; // eax@2
  int v3; // ecx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // esi@2
  signed int v7; // edi@2
  char *v8; // eax@4
  signed int v9; // edx@4
  char result; // al@6
  char v11; // [sp+8h] [bp-208h]@1
  int v12; // [sp+47h] [bp-1C9h]@2
  int v13; // [sp+4Bh] [bp-1C5h]@2
  int v14; // [sp+4Fh] [bp-1C1h]@2
  int v15; // [sp+53h] [bp-1BDh]@2
  int v16; // [sp+58h] [bp-1B8h]@2
  int v17; // [sp+5Ch] [bp-1B4h]@2
  __int16 v18; // [sp+60h] [bp-1B0h]@2
  char v19; // [sp+62h] [bp-1AEh]@2
  char v20; // [sp+B6h] [bp-15Ah]@2
  char v21; // [sp+F6h] [bp-11Ah]@2

  *(_DWORD *)a1 = 0;
  if ( sub_10060D80(6444, (int)&v11, 514) )
  {
    result = 0;
  }
  else
  {
    v1 = v13;
    v2 = v14;
    *((_DWORD *)a1 + 3330) = v12;
    v3 = v15;
    *((_DWORD *)a1 + 3331) = v1;
    LOWORD(v1) = v18;
    *((_DWORD *)a1 + 3332) = v2;
    v4 = v16;
    *((_DWORD *)a1 + 3333) = v3;
    qmemcpy((char *)a1 + 13340, &v19, 0x54u);
    v5 = v17;
    *((_WORD *)a1 + 6668) = v1;
    LOBYTE(v1) = v21;
    *((_DWORD *)a1 + 3009) = v5;
    qmemcpy((char *)a1 + 13424, &v20, 0x40u);
    *((_DWORD *)a1 + 3008) = v4;
    *((_BYTE *)a1 + 13488) = v1 & 2;
    v6 = a1;
    v7 = 32;
    do
    {
      memset(v6, 0, 0x38u);
      *((_DWORD *)v6 + 9) = 2048;
      v6 = (char *)v6 + 56;
      --v7;
    }
    while ( v7 );
    v8 = (char *)a1 + 1799;
    v9 = 512;
    do
    {
      *(_DWORD *)(v8 - 7) = 0;
      *(_DWORD *)(v8 - 3) = 0;
      *(_DWORD *)(v8 + 1) = 0;
      *(_DWORD *)(v8 + 5) = 0;
      *(_DWORD *)(v8 + 9) = 0;
      *v8 = -1;
      v8 += 20;
      --v9;
    }
    while ( v9 );
    result = 1;
  }
  return result;
}

//----- (10032830) --------------------------------------------------------
bool __thiscall sub_10032830(void *this)
{
  return (sub_1002C5C0(this) & 0x8000) == 0x8000;
}

//----- (10032850) --------------------------------------------------------
char __cdecl sub_10032850(unsigned __int8 a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-208h]@1
  char v3[453]; // [sp+3Fh] [bp-1C9h]@2

  if ( sub_10060D80(6444, (int)&v2, 514) == 0 )
    result = v3[a1];
  else
    result = 0;
  return result;
}
// 10032850: using guessed type char var_1C9[453];

//----- (100328C0) --------------------------------------------------------
char __cdecl sub_100328C0(int a1, char a2, char a3, int a4, void *a5, size_t a6)
{
  char result; // al@3
  char v7; // al@6
  char v8; // bl@8
  char v9; // al@10
  char v10; // bl@12
  char v11; // al@14
  char v12; // bl@16
  char v13; // al@18
  char v14; // bl@20

  switch ( a3 )
  {
    case 0x18:
      if ( a2 )
        result = sub_100326E0(a5);
      else
        result = sub_100326C0(a5);
      break;
    case 0x19:
      if ( a2 )
        v7 = sub_100326E0(&unk_1095A810);
      else
        v7 = sub_100326C0(&unk_1095A810);
      v8 = v7;
      memcpy(a5, (char *)&unk_1095A810 + 56 * *(_BYTE *)a4, a6);
      result = v8;
      break;
    case 0x1A:
      if ( a2 )
        v9 = sub_100326E0(&unk_1095A810);
      else
        v9 = sub_100326C0(&unk_1095A810);
      v10 = v9;
      memcpy(a5, (char *)&unk_1095D718 + 40 * *(_BYTE *)a4, a6);
      result = v10;
      break;
    case 0x1B:
      if ( a2 )
        v11 = sub_100326E0(&unk_1095A810);
      else
        v11 = sub_100326C0(&unk_1095A810);
      v12 = v11;
      memcpy(a5, (char *)&unk_1095DC18 + *(_BYTE *)a4, a6);
      result = v12;
      break;
    case 0x2B:
      if ( a2 )
        v13 = sub_100326E0(&unk_1095A810);
      else
        v13 = sub_100326C0(&unk_1095A810);
      v14 = v13;
      memcpy(a5, &unk_1095DCC0, a6);
      result = v14;
      break;
    default:
      sub_10028BC0("..\\lib\\acl\\iop\\gdl59\\iop_gdl59_cnfg_intf.c", 709, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10032A60) --------------------------------------------------------
void __usercall sub_10032A60(void *a1@<ecx>, bool *a2@<esi>)
{
  void *v2; // ecx@2

  if ( *a2 == 6 )
  {
    if ( sub_1002C660(a1) == 4 )
      *a2 = sub_10043C20(v2) == 1;
    else
      *a2 = byte_1095DCE8;
  }
}
// 1095DCE8: using guessed type char byte_1095DCE8;

//----- (10032A90) --------------------------------------------------------
void __usercall sub_10032A90(_BYTE *a1@<esi>, unsigned __int16 a2)
{
  char v2; // al@6
  __int16 *v3; // [sp-18h] [bp-18h]@4
  void *v4; // [sp-10h] [bp-10h]@4

  if ( *a1 == -1 && byte_1095DCE5 )
  {
    if ( a2 > 4u )
    {
      v4 = &unk_1095DD52;
      v3 = (__int16 *)&a2;
    }
    else
    {
      v4 = &unk_1095DD2A;
      v3 = (__int16 *)&a2;
    }
    v2 = sub_1002CC90(v3, 2u, (int)v4, 2, 20, 255);
    if ( v2 != -1 )
      ++v2;
    *a1 = v2;
  }
}
// 1095DCE5: using guessed type char byte_1095DCE5;

//----- (10032AE0) --------------------------------------------------------
signed int sub_10032AE0()
{
  return sub_10061AA0((int)&off_100BE58C);
}
// 100BE58C: using guessed type char *off_100BE58C;

//----- (10032AF0) --------------------------------------------------------
int sub_10032AF0()
{
  int result; // eax@3

  if ( (unsigned __int8)byte_1095DCE4 <= 1u )
  {
    result = sub_10060A00(98);
    byte_1095DCE4 = 0;
  }
  else
  {
    --byte_1095DCE4;
  }
  return result;
}
// 1095DCE4: using guessed type char byte_1095DCE4;

//----- (10032B20) --------------------------------------------------------
char sub_10032B20()
{
  char result; // al@2

  if ( sub_10060CB0(98) )
  {
    result = 1;
    ++byte_1095DCE4;
  }
  else if ( sub_10060A60(98, 500) )
  {
    byte_1095DCE4 = 0;
    result = 0;
  }
  else
  {
    result = 1;
    byte_1095DCE4 = 1;
  }
  return result;
}
// 1095DCE4: using guessed type char byte_1095DCE4;

//----- (10032B60) --------------------------------------------------------
char __cdecl sub_10032B60(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  unsigned __int8 v3; // al@5
  char v5; // dl@12
  char v6; // [sp+7h] [bp-1h]@19

  v2 = 0;
  if ( ((unsigned int)sub_1002C5C0(v1) >> 7) & 1 || !(unsigned __int8)sub_10032AE0() || !sub_10032B20() )
    return v2;
  if ( byte_1095DCE5 )
  {
    v3 = 0;
    while ( a1 != byte_1095DD7B[1846 * v3] )
    {
      if ( ++v3 >= 4u )
      {
        sub_10032AF0();
        return 0;
      }
    }
    if ( v3 < 4u && byte_1095DD86[1846 * v3] )
    {
      if ( a1 == 1 )
      {
        v5 = *(_BYTE *)(dword_1095DCE0 + 91140);
        goto LABEL_19;
      }
      if ( a1 == 2 )
      {
        v5 = *(_BYTE *)(dword_1095DCE0 + 98880);
        goto LABEL_19;
      }
      if ( a1 == 3 )
      {
        v5 = *(_BYTE *)(dword_1095DCE0 + 99740);
        goto LABEL_19;
      }
      if ( a1 == 5 )
      {
        v5 = *(_BYTE *)(dword_1095DCE0 + 98020);
LABEL_19:
        v6 = v5;
        sub_10033B00((unsigned __int8 *)&v6, 0, 0xFFu, 0, 1);
        if ( !(v6 & 1) )
          v2 = 1;
        goto LABEL_21;
      }
    }
  }
LABEL_21:
  sub_10032AF0();
  return v2;
}
// 1095DCE0: using guessed type int dword_1095DCE0;
// 1095DCE5: using guessed type char byte_1095DCE5;

//----- (10032C60) --------------------------------------------------------
char __usercall sub_10032C60@<al>(int a1@<ecx>, unsigned __int8 a2@<bl>, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5)
{
  char result; // al@7
  int v6; // [sp-2h] [bp-4h]@1

  v6 = a1;
  BYTE3(v6) = 0;
  if ( a2 < 0xEu && a3 < 0xAu && a4 < 0x2Bu && a5 < 0x14u && (unsigned __int8)sub_10032AE0() && sub_10032B20() )
  {
    BYTE3(v6) = *(_BYTE *)(dword_1095DCE0 + a5 + 20 * (43 * (a3 + 10 * a2) + a4 + 4004));
    sub_10032AF0();
    sub_10033B00((unsigned __int8 *)&v6 + 3, 0, 0xFFu, 0, 1);
    result = BYTE3(v6);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1095DCE0: using guessed type int dword_1095DCE0;

//----- (10032CF0) --------------------------------------------------------
char __cdecl sub_10032CF0(int a1, unsigned __int16 a2)
{
  void *v2; // ecx@0
  unsigned __int8 v3; // al@4
  int v4; // eax@6
  unsigned __int8 v5; // bl@6
  char v6; // al@6
  int v7; // eax@7
  char result; // al@8
  unsigned __int8 v9; // [sp+4h] [bp-8h]@7
  unsigned __int8 v10; // [sp+8h] [bp-4h]@6

  if ( (unsigned __int8)a1 > 6u || a2 >= 0x1Au )
  {
    result = 0;
  }
  else
  {
    sub_10032A60(v2, (bool *)&a1);
    if ( sub_10032B60(a1) )
      v3 = 0;
    else
      v3 = a1;
    v4 = 13 * v3;
    v5 = byte_100BE3A1[v4];
    v10 = byte_100BE3A2[v4];
    v6 = sub_1002CC90(&a2, 2u, (int)&unk_100BE420, 6, 18, -1);
    if ( v6 < 0
      || (v7 = 3 * v6,
          v9 = byte_100BE422[2 * v7],
          LOBYTE(a1) = byte_100BE423[2 * v7],
          sub_10032A90(&a1, a2),
          (_BYTE)a1 == -1) )
    {
      result = 0;
    }
    else
    {
      result = sub_10032C60(a1, v5, v10, v9, a1);
    }
  }
  return result;
}

//----- (10032DD0) --------------------------------------------------------
char __cdecl sub_10032DD0(const void *a1)
{
  __int16 v2; // [sp+8h] [bp-530h]@1
  char v3; // [sp+Ch] [bp-52Ch]@1

  memset(&v2, 0, 0x528u);
  v2 = -32746;
  qmemcpy(&v3, a1, 0x11Cu);
  return sub_1002CC50((int)&v2);
}

//----- (10032E40) --------------------------------------------------------
int __cdecl sub_10032E40(unsigned __int8 a1)
{
  char v2; // [sp+0h] [bp-120h]@1
  char v3; // [sp+1Fh] [bp-101h]@1

  memset(&v2, 0, 0x11Cu);
  sub_100386A0(a1, (int)&v2);
  v3 = 3;
  sub_10032DD0(&v2);
  return SIM_proc_rqst(48);
}
// 10068506: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10032EB0) --------------------------------------------------------
int __cdecl sub_10032EB0(unsigned __int8 a1)
{
  void *v1; // ecx@1
  char v2; // bl@1
  char v4; // [sp+8h] [bp-120h]@1
  char v5; // [sp+27h] [bp-101h]@1

  memset(&v4, 0, 0x11Cu);
  sub_100386A0(a1, (int)&v4);
  v5 = 0;
  sub_10032DD0(&v4);
  v2 = sub_1002C360(v1);
  sub_10051420(a1, SIM_intf + 24);
  *(_BYTE *)(SIM_intf + 320) = v2;
  return SIM_proc_rqst(49);
}
// 10051420: using guessed type _DWORD __cdecl sub_10051420(_DWORD, _DWORD);
// 10068506: using guessed type int __cdecl SIM_proc_rqst(_DWORD);

//----- (10032F40) --------------------------------------------------------
bool __cdecl sub_10032F40(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_10051430(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_10014DC0(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_10015AC0(v5[0], v6, a2) && !sub_10033700(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (10032FC0) --------------------------------------------------------
bool __cdecl sub_10032FC0(int a1, void *a2, int a3)
{
  unsigned __int16 v3; // ax@2
  bool result; // al@5
  char v5[4]; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5[0] = -1;
  v6 = 0;
  result = 0;
  if ( sub_10051490(a1, a3, v5, &v6) == 1 )
  {
    v3 = sub_10014DC0(v5[0]);
    if ( (unsigned __int16)v6 < v3 && sub_10015AC0(v5[0], v6, a2) && !sub_10033700(a2, 0, 0) )
      result = 1;
  }
  return result;
}

//----- (10033040) --------------------------------------------------------
char __cdecl sub_10033040(unsigned __int16 a1)
{
  char result; // al@3
  char v2; // [sp+Bh] [bp-9h]@3
  int v3; // [sp+Ch] [bp-8h]@1
  int v4; // [sp+10h] [bp-4h]@1

  LOBYTE(v4) = 7;
  v3 = 0;
  if ( sub_10051430(a1, 0, &v4, &v3) != 1 && sub_10051430(a1, 1u, &v4, &v3) != 1
    || (result = sub_10015140(v4, v3, &v2), result != 1)
    || v2 != 1 )
  {
    result = 0;
  }
  return result;
}

//----- (100330B0) --------------------------------------------------------
char __cdecl sub_100330B0(unsigned __int16 a1, char a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  unsigned __int16 v4; // ax@1
  int v6; // [sp+0h] [bp-Ch]@1
  int v7; // [sp+4h] [bp-8h]@1
  int v8; // [sp+8h] [bp-4h]@1

  LOBYTE(v6) = -1;
  v7 = 0;
  v3 = sub_10043C20(v2);
  LOBYTE(v8) = v3 != 0;
  LOBYTE(v4) = sub_10051490(a1, v3 != 0, &v6, &v7);
  if ( (_BYTE)v4 == 1 )
  {
    v4 = sub_10014DC0(v6);
    if ( (unsigned __int16)v7 < v4 )
      LOBYTE(v4) = sub_10015560(v6, v7, &a2, 0, 1, 1);
  }
  return v4;
}

//----- (10033120) --------------------------------------------------------
char __cdecl sub_10033120(int a1, int a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  unsigned __int16 v4; // ax@1
  bool v5; // cf@5
  int v6; // eax@7
  unsigned __int8 v8; // [sp+9h] [bp-23h]@1
  char v9; // [sp+Ah] [bp-22h]@1
  char v10; // [sp+Bh] [bp-21h]@2
  __int16 v11; // [sp+Ch] [bp-20h]@2
  int v12; // [sp+10h] [bp-1Ch]@1
  int v13; // [sp+14h] [bp-18h]@1
  int v14; // [sp+18h] [bp-14h]@1
  int v15; // [sp+1Ch] [bp-10h]@1
  int v16; // [sp+20h] [bp-Ch]@1
  int v17; // [sp+24h] [bp-8h]@1

  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v9 = 0;
  v3 = sub_1002DB00(v2);
  sub_100386C0(v3, (int)&v12);
  LOBYTE(v4) = 0;
  v8 = 0;
  while ( sub_10051430(*((_WORD *)&v17 + 2 * (unsigned __int8)v4 + 1), 0, &v10, &v11) != 1
       || *(_BYTE *)(a2 + 1) != v10
       || (_WORD)a1 != v11 )
  {
    LOBYTE(v4) = v8 + 1;
    v5 = v8++ >= 0xFFu;
    if ( !v5 )
      return v4;
  }
  v6 = sub_1002CE20(&v8, 1u, (int)&unk_100BEE68, 2, 1);
  v9 = *((_BYTE *)&v17 + 4 * v8 + 1) ^ j_HWM_pvg_read_reg((unsigned __int8)byte_100BEE69[2 * v6]);
  v4 = sub_10014DC0(*(_BYTE *)(a2 + 1));
  if ( (unsigned __int16)a1 < v4 )
    LOBYTE(v4) = sub_10015560(*(_BYTE *)(a2 + 1), a1, &v9, 0, 1, 1);
  return v4;
}
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10033230) --------------------------------------------------------
bool __cdecl sub_10033230(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_10043C20(v2) != 0;
  return sub_10032F40(a1, a2, v3);
}

//----- (10033260) --------------------------------------------------------
bool __cdecl sub_10033260(int a1, void *a2)
{
  void *v2; // ecx@0
  int v3; // ST0C_4@1

  v3 = (int)v2;
  LOBYTE(v3) = sub_10043C20(v2) != 0;
  return sub_10032FC0(a1, a2, v3);
}

//----- (10033290) --------------------------------------------------------
char __cdecl sub_10033290(int a1, int a2)
{
  char v2; // bl@1
  char v4; // [sp+8h] [bp-A0h]@1
  char v5; // [sp+7Ch] [bp-2Ch]@2

  v2 = sub_10015AC0(2, 371, &v4);
  if ( v2 )
    sub_1002C120(a1, &v5, a2);
  return v2;
}

//----- (10033300) --------------------------------------------------------
char __cdecl sub_10033300(int a1, int a2)
{
  char v2; // bl@1
  char v4; // [sp+8h] [bp-A0h]@1
  char v5; // [sp+18h] [bp-90h]@2

  v2 = sub_10015AC0(2, 371, &v4);
  if ( v2 )
    sub_1002C120(a1, &v5, a2);
  return v2;
}

//----- (10033370) --------------------------------------------------------
char __cdecl sub_10033370(_BYTE *a1)
{
  char result; // al@1
  char v2; // [sp+4h] [bp-A0h]@1
  char v3; // [sp+7h] [bp-9Dh]@2

  result = sub_10015AC0(2, 371, &v2);
  if ( result )
    *a1 = v3;
  return result;
}

//----- (100333C0) --------------------------------------------------------
unsigned int __cdecl sub_100333C0(int a1, int a2, size_t a3, int a4, int a5)
{
  int v5; // ecx@1
  unsigned int result; // eax@1
  int v7; // ebp@4
  int v8; // ebx@4
  int v9; // esi@6
  char *v10; // ebx@7
  char *v11; // [sp+0h] [bp-190h]@5
  char *v12; // [sp+4h] [bp-18Ch]@7
  char *v13; // [sp+8h] [bp-188h]@5
  int v14; // [sp+10h] [bp-180h]@4
  int v15; // [sp+14h] [bp-17Ch]@3
  size_t v16; // [sp+1Ch] [bp-174h]@5
  char v17; // [sp+24h] [bp-16Ch]@6

  v5 = a1;
  result = a4;
  if ( a1 && (signed int)a3 <= 360 )
  {
    result = 0;
    v15 = 0;
    do
    {
      v7 = *(int *)((char *)&dword_100BF488 + result);
      v8 = *(int *)((char *)&dword_100BF488 + result);
      v14 = *(int *)((char *)&dword_100BF488 + result);
      if ( v7 < a2 )
      {
        v16 = a3 * v7;
        v11 = (char *)(v5 + a3 * v7);
        v13 = (char *)v5;
        do
        {
          memcpy(&v17, v11, a3);
          v9 = v8;
          if ( v8 >= v7 )
          {
            v10 = v13;
            v12 = v11;
            do
            {
              if ( ((int (__cdecl *)(char *, char *, int))a4)(&v17, v10, a5) >= 0 )
                break;
              memcpy(v12, v10, a3);
              v12 -= v16;
              v9 -= v7;
              v10 -= v16;
            }
            while ( v9 >= v7 );
            v8 = v14;
          }
          memcpy((void *)(a1 + a3 * v9), &v17, a3);
          v11 += a3;
          v13 += a3;
          v14 = ++v8;
        }
        while ( v8 < a2 );
        result = v15;
        v5 = a1;
      }
      result += 4;
      v15 = result;
    }
    while ( result < 0x40 );
  }
  return result;
}
// 100BF488: using guessed type int dword_100BF488;

//----- (10033540) --------------------------------------------------------
unsigned int __cdecl sub_10033540(int a1, int a2, size_t a3, int a4)
{
  return sub_100333C0(a1, a2, a3, (int)sub_10033520, a4);
}
// 10033520: using guessed type int sub_10033520();

//----- (10033570) --------------------------------------------------------
char sub_10033570()
{
  return 0;
}

//----- (10033580) --------------------------------------------------------
char sub_10033580()
{
  return sub_10032560(1u);
}

//----- (10033590) --------------------------------------------------------
char __cdecl sub_10033590(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // edx@3
  int v4; // ecx@3
  char result; // al@3
  int v6; // [sp+4h] [bp-1Ch]@1
  int v7; // [sp+8h] [bp-18h]@1
  int v8; // [sp+Ch] [bp-14h]@1
  int v9; // [sp+10h] [bp-10h]@1
  int v10; // [sp+14h] [bp-Ch]@1
  __int16 v11; // [sp+18h] [bp-8h]@1
  char v12; // [sp+1Ah] [bp-6h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( !sub_10015AC0(2, 284, &v6) || sub_1001C1C0((int)&v6) )
  {
    result = 0;
  }
  else
  {
    v2 = v8;
    *(_DWORD *)a2 = v7;
    v3 = v9;
    *(_DWORD *)(a2 + 4) = v2;
    v4 = v10;
    *(_DWORD *)(a2 + 8) = v3;
    LOWORD(v3) = v11;
    *(_DWORD *)(a2 + 12) = v4;
    LOBYTE(v4) = v12;
    *(_WORD *)(a2 + 16) = v3;
    *(_BYTE *)(a2 + 18) = v4;
    result = 1;
  }
  return result;
}

//----- (10033640) --------------------------------------------------------
BOOL __cdecl sub_10033640(int a1, int a2)
{
  return sub_10060D80(6169, a2, 40) == 0;
}

//----- (10033660) --------------------------------------------------------
char __cdecl sub_10033660(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10033640(a1, a5);
  }
  else
  {
    result = sub_10033590(a1, a5);
  }
  return result;
}

//----- (100336A0) --------------------------------------------------------
bool __thiscall sub_100336A0(void *this)
{
  return (sub_1002C5C0(this) & 0x800) == 2048;
}

//----- (100336C0) --------------------------------------------------------
char __cdecl sub_100336C0(char a1)
{
  char result; // al@1

  result = a1;
  switch ( a1 )
  {
    case 0x16:
      result = 0;
      break;
    case 0x17:
      result = 1;
      break;
    case 0x18:
      result = 9;
      break;
    case 0x19:
      result = 8;
      break;
    case 0x1A:
      result = 10;
      break;
    case 0x1B:
      result = 14;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10033700) --------------------------------------------------------
signed int __cdecl sub_10033700(_BYTE *a1, char a2, int a3)
{
  signed int result; // eax@1

  result = -4;
  if ( a3 && a3 != 1 || (!*a1 || *a1 == 1 ? (result = 0) : (result = -2), a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_11;
  }
  if ( result )
  {
LABEL_11:
    *a1 = a2;
    result = 1;
  }
  return result;
}

//----- (10033750) --------------------------------------------------------
int __cdecl sub_10033750(int a1, double a2, double a3, int a4, int a5, int a6)
{
  int result; // eax@1
  int v7; // edx@20
  unsigned __int64 v8; // rax@21
  int v9; // esi@21
  double v10; // [sp+4h] [bp-8h]@2

  result = -4;
  if ( a1 & 3 || (unsigned int)&v10 & 3 )
  {
    LOBYTE(v10) = *(_BYTE *)a1;
    BYTE1(v10) = *(_BYTE *)(a1 + 1);
    BYTE2(v10) = *(_BYTE *)(a1 + 2);
    BYTE3(v10) = *(_BYTE *)(a1 + 3);
    BYTE4(v10) = *(_BYTE *)(a1 + 4);
    BYTE5(v10) = *(_BYTE *)(a1 + 5);
    BYTE6(v10) = *(_BYTE *)(a1 + 6);
    BYTE7(v10) = *(_BYTE *)(a1 + 7);
  }
  else
  {
    v10 = *(double *)a1;
  }
  if ( a6 && a6 != 1
    || ((HIDWORD(v10) & 0x7FF00000) != 2146435072 ? (a2 <= v10 ? (v10 <= a3 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a6 != 1) )
  {
    if ( a6 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || a1 & 3 )
  {
    LODWORD(v8) = a4;
    v9 = a5;
    *(_BYTE *)(a1 + 1) = BYTE1(a4);
    *(_BYTE *)(a1 + 2) = __PAIR__((unsigned int)v9, (unsigned int)v8) >> 16;
    HIDWORD(v8) = a5;
    *(_BYTE *)a1 = v8;
    *(_BYTE *)(a1 + 3) = v8 >> 24;
    LOBYTE(v8) = BYTE2(a5);
    *(_BYTE *)(a1 + 4) = BYTE4(v8);
    BYTE4(v8) = BYTE3(a5);
    *(_BYTE *)(a1 + 6) = v8;
    *(_BYTE *)(a1 + 5) = BYTE5(v8);
    *(_BYTE *)(a1 + 7) = BYTE4(v8);
    result = 1;
  }
  else
  {
    v7 = a5;
    *(_DWORD *)a1 = a4;
    result = 1;
    *(_DWORD *)(a1 + 4) = v7;
  }
  return result;
}

//----- (100338A0) --------------------------------------------------------
int __cdecl sub_100338A0(int a1, float a2, float a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  char v7; // dl@4
  char v8; // al@4
  char v9; // dl@4
  int result; // eax@5
  double v11; // st7@7
  unsigned int v12; // eax@21

  v5 = a1;
  v6 = a1 & 3;
  if ( a1 & 3 || (unsigned int)&a1 & 3 )
  {
    v7 = *(_BYTE *)(a1 + 1);
    LOBYTE(a1) = *(_BYTE *)a1;
    v8 = *(_BYTE *)(v5 + 2);
    BYTE1(a1) = v7;
    v9 = *(_BYTE *)(v5 + 3);
    BYTE2(a1) = v8;
    BYTE3(a1) = v9;
  }
  else
  {
    a1 = *(int *)a1;
  }
  result = -4;
  if ( a5 && a5 != 1
    || ((v11 = *(float *)&a1, (a1 & 0x7F800000) != 2139095040) ? (a2 <= v11 ? (a3 >= v11 ? (result = 0) : (result = -2)) : (result = -1)) : (result = -3),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v12 = a4;
    *(_BYTE *)(v5 + 1) = BYTE1(a4);
    *(_BYTE *)v5 = v12;
    *(_BYTE *)(v5 + 3) = BYTE3(v12);
    *(_BYTE *)(v5 + 2) = v12 >> 16;
    result = 1;
  }
  else
  {
    *(_DWORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10033990) --------------------------------------------------------
unsigned int __cdecl sub_10033990(char *a1, char a2, char a3, char a4, int a5)
{
  char v5; // dl@1
  unsigned int result; // eax@1
  int v7; // eax@5

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1
    || (v5 >= a2 ? (v7 = v5 < a3, LOBYTE(v7) = v5 <= a3, result = (v7 - 1) & 0xFFFFFFFE) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (100339E0) --------------------------------------------------------
unsigned int __cdecl sub_100339E0(_BYTE *a1, signed int a2, signed int a3, signed int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  unsigned int result; // eax@1
  _BYTE *v8; // esi@3
  int v9; // eax@9
  signed int v10; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((signed int)v8 >= a2 ? (v9 = (signed int)v8 < a3,
                                LOBYTE(v9) = (signed int)v8 <= a3,
                                result = (v9 - 1) & 0xFFFFFFFE) : (result = -1),
        a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v10 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v10;
    v5[3] = BYTE3(v10);
    v5[2] = v10 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10033AA0) --------------------------------------------------------
unsigned int __cdecl sub_10033AA0(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // eax@3
  int v5; // ecx@3
  unsigned int v6; // ecx@3

  result = -4;
  if ( a3 && a3 != 1
    || (v4 = sub_1002C1E0(a1, a2), v5 = v4 < 0, LOBYTE(v5) = v4 >= 0, v6 = (v5 - 1) & 0xFFFFFFFC, result = v6, a3 != 1) )
  {
    if ( a3 != 2 )
      return result;
    goto LABEL_7;
  }
  if ( v6 )
  {
LABEL_7:
    memset(a1, 0, a2);
    result = 1;
  }
  return result;
}

//----- (10033B00) --------------------------------------------------------
int __cdecl sub_10033B00(unsigned __int8 *a1, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v5; // dl@1
  int result; // eax@1

  v5 = *a1;
  result = -4;
  if ( a5 && a5 != 1 || (v5 >= a2 ? (result = a3 < v5 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
    goto LABEL_10;
  }
  if ( result )
  {
LABEL_10:
    *a1 = a4;
    result = 1;
  }
  return result;
}

//----- (10033B50) --------------------------------------------------------
int __cdecl sub_10033B50(_BYTE *a1, unsigned __int16 a2, unsigned __int16 a3, __int16 a4, int a5)
{
  _BYTE *v5; // edx@1
  int v6; // esi@1
  int result; // eax@1
  char v8; // ah@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 1;
  result = -4;
  if ( (unsigned __int8)a1 & 1 || (unsigned int)&a1 & 1 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
  }
  else
  {
    a1 = (_BYTE *)*(_WORD *)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned __int16)a1 >= a2 ? (result = a3 < (unsigned __int16)a1 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 1 || v6 )
  {
    v8 = HIBYTE(a4);
    *v5 = a4;
    v5[1] = v8;
    result = 1;
  }
  else
  {
    *(_WORD *)v5 = a4;
    result = 1;
  }
  return result;
}

//----- (10033BF0) --------------------------------------------------------
int __cdecl sub_10033BF0(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  _BYTE *v5; // ecx@1
  int v6; // edi@1
  int result; // eax@1
  _BYTE *v8; // esi@3
  unsigned int v9; // eax@17

  v5 = a1;
  v6 = (unsigned __int8)a1 & 3;
  result = -4;
  if ( (unsigned __int8)a1 & 3 || (unsigned int)&a1 & 3 )
  {
    LOBYTE(a1) = *a1;
    BYTE1(a1) = v5[1];
    BYTE2(a1) = v5[2];
    BYTE3(a1) = v5[3];
    v8 = a1;
  }
  else
  {
    v8 = *(_BYTE **)a1;
  }
  if ( a5 && a5 != 1
    || ((unsigned int)v8 >= a2 ? (result = a3 < (unsigned int)v8 ? 0xFFFFFFFE : 0) : (result = -1), a5 != 1) )
  {
    if ( a5 != 2 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  if ( (unsigned int)&a4 & 3 || v6 )
  {
    v9 = a4;
    v5[1] = BYTE1(a4);
    *v5 = v9;
    v5[3] = BYTE3(v9);
    v5[2] = v9 >> 16;
    result = 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v5 = a4;
  }
  return result;
}

//----- (10033CA0) --------------------------------------------------------
int __cdecl sub_10033CA0(float a1, float a2)
{
  float *v2; // ecx@0
  double v3; // st7@1
  double v4; // st7@3
  bool v5; // c0@3
  bool v6; // c3@3
  int result; // eax@4

  v3 = a1;
  if ( (COERCE_UNSIGNED_INT(*v2) & 0x7F800000) != 2139095040
    && *v2 <= v3
    && (v4 = *v2, v5 = a2 < v4, v6 = a2 == v4, v3 = a2, v5 || v6) )
  {
    result = 1;
  }
  else
  {
    *v2 = v3;
    result = 0;
  }
  return result;
}

//----- (10033CF0) --------------------------------------------------------
bool __cdecl sub_10033CF0(float *a1)
{
  void *v1; // ecx@0
  float *v2; // edi@1
  unsigned int v3; // ebp@1
  char v4; // bl@1
  _DWORD *v5; // esi@1
  char v6; // al@3
  bool result; // al@6
  int v8; // [sp+10h] [bp-8h]@1
  float v9; // [sp+14h] [bp-4h]@3
  char v10; // [sp+1Ch] [bp+4h]@1

  v2 = a1;
  *a1 = 0.0;
  v3 = 0;
  v4 = 0;
  v8 = sub_1002C5C0(v1);
  v10 = 0;
  v5 = &unk_100C0C48;
  do
  {
    if ( v8 & *v5 )
    {
      v6 = sub_10043EA0(v10, 0);
      if ( sub_10029610(3, v6, &v9) )
      {
        ++v3;
        *v2 = *v2 + v9;
      }
    }
    ++v4;
    ++v5;
    v10 = v4;
  }
  while ( (unsigned __int8)v4 < 2u );
  result = v3 != 0;
  if ( v3 )
    *v2 = *v2 / (double)v3;
  return result;
}

//----- (10033D90) --------------------------------------------------------
int sub_10033D90()
{
  int result; // eax@1

  sub_10060E80(6361, (int)&flt_1095FC68, 4);
  result = sub_10060E80(6362, (int)&flt_1095FC6C, 4);
  dword_1095FC70 = 1379255385;
  return result;
}
// 1095FC68: using guessed type float flt_1095FC68;
// 1095FC6C: using guessed type float flt_1095FC6C;
// 1095FC70: using guessed type int dword_1095FC70;

//----- (10033DC0) --------------------------------------------------------
char __cdecl sub_10033DC0(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10029690(7, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 39950.746
     || *(float *)a1 < -39950.746) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10033E20) --------------------------------------------------------
char __cdecl sub_10033E20(float *a1)
{
  char v1; // bl@1
  double v2; // st7@2
  double v3; // st7@6
  char result; // al@9
  float v5; // [sp+Ch] [bp-Ch]@1
  float v6; // [sp+10h] [bp-8h]@5
  float v7; // [sp+14h] [bp-4h]@2

  v1 = sub_10029690(53, &v5);
  if ( v1 )
  {
    v2 = v5;
    v7 = v5;
    if ( (LODWORD(v5) & 0x7F800000) == 2139095040 || v2 > 526.79114 || v2 < -526.79114 )
      return 0;
    if ( sub_10029690(59, &v6) )
    {
      v3 = v6;
      v7 = v6;
      if ( (LODWORD(v6) & 0x7F800000) != 2139095040 && v3 <= 526.79114 && v3 >= -526.79114 )
      {
        sub_10033CA0(flt_1095FC68, 0.0);
        result = v1;
        v5 = flt_1095FC6C * v6 + v5;
        *a1 = v5;
        return result;
      }
    }
    *a1 = v5;
  }
  return v1;
}
// 1095FC68: using guessed type float flt_1095FC68;
// 1095FC6C: using guessed type float flt_1095FC6C;

//----- (10033F20) --------------------------------------------------------
char __cdecl sub_10033F20(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10029690(2, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040 || *(float *)a1 > 512.0 || *(float *)a1 < -512.0) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10033F80) --------------------------------------------------------
char __cdecl sub_10033F80(void *a1)
{
  char v1; // cl@1
  char result; // al@5

  v1 = sub_10029690(56, a1);
  if ( v1
    && ((COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
     || *(float *)a1 > 1053.5823
     || *(float *)a1 < -1053.5823) )
  {
    result = 0;
    *(float *)a1 = 0.0;
  }
  else
  {
    result = v1;
  }
  return result;
}

//----- (10033FE0) --------------------------------------------------------
char __cdecl sub_10033FE0(float *a1)
{
  float *v1; // esi@1
  char v2; // bl@1

  v1 = a1;
  *a1 = 0.0;
  v2 = sub_10033DC0(&a1);
  if ( v2 )
    *v1 = sub_1002C340() + *(float *)&a1;
  return v2;
}
// 1002C340: using guessed type double sub_1002C340(void);

//----- (10034010) --------------------------------------------------------
char __cdecl sub_10034010(float *a1)
{
  float *v1; // esi@1
  char result; // al@4
  float v3; // [sp+8h] [bp-4h]@1

  v1 = a1;
  *a1 = 9.8999998e24;
  if ( sub_10033F20(&v3) && sub_10033FE0((float *)&a1) )
  {
    *(float *)&a1 = *(float *)&a1 * 3.280839920043945;
    if ( *(float *)&a1 < 36089.0 )
    {
      result = 1;
      *v1 = v3 - (15.0 - *(float *)&a1 / 1000.0 * 1.981199979782104);
    }
    else
    {
      result = 1;
      *v1 = v3 - -56.5;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100340B0) --------------------------------------------------------
char __cdecl sub_100340B0(int a1)
{
  int v1; // ecx@0
  char v2; // bl@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // eax@1

  v2 = 0;
  v3 = j_HWM_pvg_hsdb_get_lrus_online(v1);
  j_HWM_pvg_hsdb_set_sim_lrus_online(0);
  v5 = j_HWM_pvg_hsdb_get_lrus_online(v4);
  if ( (a1 & v5) == a1 )
    v2 = 1;
  j_HWM_pvg_hsdb_set_sim_lrus_online(v3 - v5);
  return v2;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 10061650: using guessed type int __cdecl j_HWM_pvg_hsdb_set_sim_lrus_online(_DWORD);

//----- (100340F0) --------------------------------------------------------
void *__usercall sub_100340F0@<eax>(void *a1@<ebx>, const void *a2@<edi>, int a3@<esi>, int a4)
{
  void *result; // eax@1
  int v5; // [sp+0h] [bp-Ch]@0
  int v6; // [sp+4h] [bp-8h]@0

  result = (void *)sub_10060D80(a4, v5, v6);
  if ( result )
  {
    sub_10060ED0(a4, (int)a2, a3);
    result = memcpy(a1, a2, (unsigned __int16)a3);
  }
  return result;
}

//----- (10034120) --------------------------------------------------------
void *__cdecl sub_10034120(void *a1)
{
  return sub_100340F0(a1, &unk_100C0CF0, 60, 2116);
}

//----- (10034150) --------------------------------------------------------
char sub_10034150()
{
  char v1; // [sp+Fh] [bp-1h]@1

  sub_100340F0(&v1, &unk_100C0CC2, 1, 2119);
  return v1;
}

//----- (10034180) --------------------------------------------------------
int __cdecl sub_10034180(int a1)
{
  return sub_10060E80(6954, a1, 8);
}

//----- (100341A0) --------------------------------------------------------
int __cdecl sub_100341A0(int a1)
{
  return sub_10060ED0(6954, a1, 8);
}

//----- (100341C0) --------------------------------------------------------
char __cdecl sub_100341C0(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xA:
    case 0x30:
      result = 0;
      break;
    case 0xB:
    case 0x31:
      result = 1;
      break;
    default:
      sub_10028BC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_utl.c", 155, 0, 0);
      result = 2;
      break;
  }
  return result;
}

//----- (10034240) --------------------------------------------------------
char __cdecl sub_10034240(unsigned __int16 a1, _WORD *a2)
{
  unsigned int v2; // ebx@2
  _WORD *v3; // edi@2
  char result; // al@2
  signed __int16 v5; // cx@2
  __int16 v6; // si@2
  __int16 v7; // dx@3

  if ( sub_1001BCD0(&a1) )
  {
    result = 0;
  }
  else
  {
    v2 = a1;
    v3 = a2;
    result = 1;
    *a2 = 0;
    v5 = 1;
    v6 = 0;
    do
    {
      v7 = v5 * (v2 & 7);
      v5 *= 10;
      v2 >>= 3;
      v6 += v7;
    }
    while ( (unsigned __int16)v5 <= 0x3E8u );
    *v3 = v6;
  }
  return result;
}

//----- (100342A0) --------------------------------------------------------
char __fastcall sub_100342A0(int a1)
{
  char result; // al@2
  int v2; // [sp-2h] [bp-4h]@1

  v2 = a1;
  BYTE3(v2) = 0;
  if ( sub_10060D80(2018, (int)&v2 + 3, 1) || (result = BYTE3(v2), BYTE3(v2) >= 2u) )
  {
    BYTE3(v2) = 0;
    sub_10060ED0(2018, (int)&v2 + 3, 1);
    result = BYTE3(v2);
  }
  return result;
}

//----- (100342F0) --------------------------------------------------------
char __cdecl sub_100342F0(unsigned int a1)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // ebx@1
  unsigned int v3; // ebx@1
  unsigned int v4; // eax@1
  unsigned __int8 v5; // bl@4
  char result; // al@4
  unsigned __int8 v7; // [sp+8h] [bp+4h]@1

  v1 = (unsigned int)(a1 * (unsigned __int64)(unsigned int)&unk_10624DD3 >> 32) >> 6;
  v2 = a1 - 1000 * (unsigned __int8)v1;
  v7 = v2 / 0x64;
  v3 = v2 % 0x64;
  v4 = v3 / 0xA;
  if ( (unsigned __int8)v1 >= 8u || v7 >= 8u || (unsigned __int8)v4 >= 8u || (v5 = v3 - 10 * v4, result = 1, v5 >= 8u) )
    result = 0;
  return result;
}

//----- (10034360) --------------------------------------------------------
char __cdecl sub_10034360(char a1)
{
  char result; // al@1

  result = 0;
  if ( !a1 )
  {
    if ( sub_10030B40(33) || sub_10030B70(17) )
      return 1;
    return 0;
  }
  if ( a1 != 1 )
    return result;
  if ( !sub_10030B40(34) && !sub_10030B70(19) )
    return 0;
  return 1;
}

//----- (100343B0) --------------------------------------------------------
char __cdecl sub_100343B0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10030B40(11);
  }
  else
  {
    result = sub_10030B40(5);
  }
  return result;
}

//----- (100343E0) --------------------------------------------------------
char __cdecl sub_100343E0(char a1)
{
  char result; // al@1

  result = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = sub_10033040(0x1EDu);
  }
  else
  {
    result = sub_10033040(0x1ECu);
  }
  return result;
}

//----- (10034410) --------------------------------------------------------
char __cdecl sub_10034410(char a1)
{
  char v1; // al@4

  if ( a1 )
  {
    if ( a1 != 1 )
      return 0;
    if ( sub_10030B40(13) )
      return 1;
    v1 = sub_10030B40(29);
  }
  else
  {
    if ( sub_10030B40(7) )
      return 1;
    v1 = sub_10030B40(27);
  }
  if ( v1 )
    return 1;
  return 0;
}

//----- (10034460) --------------------------------------------------------
char __usercall sub_10034460@<al>(unsigned __int8 a1@<al>, _BYTE *a2)
{
  int v2; // ecx@1

  v2 = 0;
  while ( (a1 & (unsigned __int8)byte_100C2AE0[2 * v2]) != byte_100C2AE0[2 * v2] )
  {
    if ( ++v2 >= 5 )
      return 0;
  }
  *a2 = byte_100C2AE1[2 * v2];
  return 1;
}

//----- (10034490) --------------------------------------------------------
char __cdecl sub_10034490(void *a1, int a2)
{
  unsigned __int8 v2; // al@3
  char v3; // al@6
  bool v4; // al@8
  bool v5; // zf@8
  char v6; // cl@8
  int v7; // eax@8
  unsigned __int8 v8; // al@18
  int v9; // ecx@18
  int v10; // edx@18
  char v11; // al@22
  char result; // al@32
  char v13; // [sp+Ah] [bp-4Eh]@1
  bool v14; // [sp+Bh] [bp-4Dh]@1
  int v15; // [sp+Ch] [bp-4Ch]@1
  int v16; // [sp+10h] [bp-48h]@1
  unsigned __int8 v17; // [sp+14h] [bp-44h]@13
  int v18; // [sp+18h] [bp-40h]@14
  char v19; // [sp+20h] [bp-38h]@5
  char v20; // [sp+23h] [bp-35h]@10
  char v21; // [sp+26h] [bp-32h]@8
  int v22; // [sp+4Ah] [bp-Eh]@6
  char v23; // [sp+52h] [bp-6h]@8

  *(_DWORD *)a1 = 0;
  *((_DWORD *)a1 + 1) = 0;
  *((_DWORD *)a1 + 2) = 0;
  *((_DWORD *)a1 + 3) = 0;
  v14 = 0;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  if ( (unsigned __int8)a2 >= 2u )
    goto LABEL_25;
  if ( !sub_100343E0(a2) )
  {
    if ( !sub_10034360(a2) )
    {
      if ( (unsigned __int8)a2 == 1 )
        v11 = sub_10015AC0(1, 1221, a1);
      else
        v11 = sub_10015AC0(1, 1209, a1);
      v13 = v11;
      goto LABEL_25;
    }
    if ( sub_10044130(a2, 1, &v17)
      && sub_10034240(v18, &v15)
      && sub_10034240(HIWORD(v18), &v16)
      && sub_10034460(v17, (_BYTE *)a1 + 3)
      && sub_10044130(a2, 2, &v17) )
    {
      v8 = v17;
      v5 = (v17 & 0x80) == -128;
      v9 = (unsigned __int16)v15;
      *(_BYTE *)a1 = (v17 & 0x10) == 16;
      *((_BYTE *)a1 + 2) = v5;
      v10 = (unsigned __int16)v16;
      v13 = 1;
      *((_DWORD *)a1 + 3) = v9;
      *((_DWORD *)a1 + 2) = v10;
      if ( v8 & 2 )
        *((_BYTE *)a1 + 1) = 2;
      else
        *((_BYTE *)a1 + 1) = (v8 & 8) == 8;
      goto LABEL_25;
    }
LABEL_11:
    v13 = 0;
    goto LABEL_25;
  }
  v2 = sub_1002CC90(&a2, 1u, (int)&unk_100C2AD0, 4, 2, 0);
  if ( !sub_10033230((unsigned __int16)word_100C2AD2[2 * v2], &v13) || !v13 )
    goto LABEL_11;
  if ( !sub_10029420(&v19) || (v3 = sub_10034240(v22, &v15), v13 = 1, !v3) )
    v13 = 0;
  v4 = sub_10029470();
  v5 = v23 == 1;
  v6 = v21;
  *(_BYTE *)a1 = v4;
  v7 = (unsigned __int16)v15;
  *((_BYTE *)a1 + 3) = 0;
  *((_BYTE *)a1 + 2) = v6;
  *((_DWORD *)a1 + 3) = v7;
  *((_DWORD *)a1 + 2) = v7;
  if ( v5 )
    *((_BYTE *)a1 + 1) = 2;
  else
    *((_BYTE *)a1 + 1) = v20 == 0;
LABEL_25:
  if ( sub_1001CD50((unsigned __int8 *)a1)
    || !sub_100342F0(*((_DWORD *)a1 + 2))
    || !sub_100342F0(*((_DWORD *)a1 + 3))
    || sub_100343B0(a2) && *((_BYTE *)a1 + 1) == 3 )
  {
    result = 0;
  }
  else
  {
    sub_10060D80(9241, (int)&v14, 1);
    if ( v14 != (*(_BYTE *)a1 == 1) )
    {
      v14 = *(_BYTE *)a1 == 1;
      sub_10060ED0(9241, (int)&v14, 1);
    }
    result = v13;
  }
  return result;
}
// 100C2AD2: using guessed type __int16 word_100C2AD2[];

//----- (10034740) --------------------------------------------------------
char __cdecl sub_10034740(void *a1)
{
  int v1; // ecx@0
  int v2; // ST08_4@1

  v2 = v1;
  LOBYTE(v2) = sub_100342A0(v1);
  return sub_10034490(a1, v2);
}

//----- (10034760) --------------------------------------------------------
BOOL sub_10034760()
{
  return sub_100306F0(9) || sub_100306F0(10);
}

//----- (10034790) --------------------------------------------------------
int __usercall sub_10034790@<eax>(char a1@<al>, int a2@<ecx>)
{
  int v2; // esi@3
  int result; // eax@3

  if ( a1 && a1 != 2 )
  {
    v2 = a2 - sub_100626E0(a1);
    result = v2 + sub_100626E0(0);
  }
  else
  {
    result = a2;
  }
  return result;
}

//----- (100347C0) --------------------------------------------------------
char __thiscall sub_100347C0(void *this)
{
  char v1; // al@1
  char result; // al@2
  char v3; // [sp+4h] [bp-8h]@1
  int v4; // [sp+8h] [bp-4h]@2

  v1 = sub_10043C20(this);
  v3 = sub_10043EA0(v1, 1);
  if ( (unsigned __int8)sub_10034760() )
  {
    result = sub_10029610(28, v3, &v4);
    if ( result != 1 || !(v4 & 0x800) )
      result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10034820) --------------------------------------------------------
char __thiscall sub_10034820(void *this)
{
  char v1; // al@1
  char v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@2
  int v5; // [sp+8h] [bp-4h]@5

  v1 = sub_10043C20(this);
  v3 = sub_10043EA0(v1, 1);
  if ( (unsigned __int8)sub_10034760() )
  {
    if ( sub_10029610(28, v3, &v4) != 1 || v4 & 0x2000 )
      return 0;
  }
  else if ( sub_100514F0(&v5) != 1 || !(v5 & 0x10000) )
  {
    return 0;
  }
  return 1;
}

//----- (10034890) --------------------------------------------------------
char __cdecl sub_10034890(char a1, char a2, int *a3)
{
  char v3; // bl@1
  void *v4; // ecx@1
  void *v5; // ecx@2
  char result; // al@4
  int v7; // esi@9
  void *v8; // ecx@12
  int v9; // esi@14
  char v10; // [sp+8h] [bp-14h]@1
  char v11; // [sp+9h] [bp-13h]@1
  char v12; // [sp+Ah] [bp-12h]@1
  char v13; // [sp+Bh] [bp-11h]@1
  int v14; // [sp+Ch] [bp-10h]@1
  int v15; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1

  v3 = sub_10029610(16, a2, &v14);
  v12 = sub_10029610(17, a2, &v16);
  v10 = sub_10062C70();
  v11 = sub_10029610(51, a2, &v15);
  v13 = sub_10029610(52, a2, &v17);
  switch ( a1 )
  {
    case 0:
    case 2:
    case 3:
      if ( sub_10034820(v4) )
      {
        if ( !v3 )
          return 0;
        v7 = v14;
        if ( v10 == 1 )
          v7 -= sub_100626E0(0);
        *a3 = sub_10034790(a1, v7);
        result = 1;
      }
      else if ( v3 )
      {
        *a3 = sub_10034790(a1, v14);
        result = 1;
      }
      else
      {
        if ( !v11 || !sub_100347C0(v5) )
          return 0;
        *a3 = sub_10034790(a1, v15);
        result = 1;
      }
      return result;
    case 1:
      if ( sub_10034820(v4) )
      {
        if ( !v3 )
          return 0;
        v9 = v14;
        if ( v10 == 1 )
          goto LABEL_15;
        *a3 = sub_100626E0(0) + v9;
        result = 1;
      }
      else
      {
        if ( v12 )
        {
          v9 = v16;
LABEL_15:
          *a3 = v9;
          return 1;
        }
        if ( !v13 || !sub_100347C0(v8) )
          return 0;
        *a3 = v17;
        result = 1;
      }
      return result;
    default:
      sub_10028BC0("..\\lib\\acl\\iop\\iop_ahrs_data_intf.c", 1859, 1, 0);
      return 0;
  }
}

//----- (10034A40) --------------------------------------------------------
char __cdecl sub_10034A40(char a1, int *a2, char a3)
{
  char result; // al@3
  char v4; // bl@4
  int v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  if ( a3 != 2 && sub_100306F0(a3 + 9) )
  {
    result = sub_10034890(a1, a3, a2);
  }
  else
  {
    v4 = sub_10029610(16, a3, &v5);
    if ( v4 )
      *a2 = sub_10034790(a1, v5);
    result = v4;
  }
  return result;
}

//----- (10034AB0) --------------------------------------------------------
char __cdecl sub_10034AB0(char a1, int *a2)
{
  void *v2; // ecx@0
  char v3; // al@1
  char v4; // al@1

  v3 = sub_10043C20(v2);
  v4 = sub_10043EA0(v3, 1);
  return sub_10034A40(a1, a2, v4);
}

//----- (10034AE0) --------------------------------------------------------
int __cdecl sub_10034AE0(unsigned int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi@1
  unsigned int v4; // ecx@1
  unsigned int v5; // esi@1
  int result; // eax@2
  unsigned int i; // ebp@3
  unsigned int v8; // ebx@4
  int v9; // eax@8
  signed int v10; // edx@8
  int v11; // ecx@9
  int v12; // esi@9
  int v13; // ecx@9
  int v14; // esi@9
  int v15; // ecx@9
  int v16; // esi@9
  unsigned int v17; // [sp+Ch] [bp+4h]@7

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = a1 >> 16;
  if ( a2 )
  {
    for ( i = a3; i; v5 %= 0xFFF1u )
    {
      v8 = i;
      if ( i >= 0x15B0 )
        v8 = 5552;
      i -= v8;
      if ( (signed int)v8 >= 16 )
      {
        v17 = v8 >> 4;
        v8 += -16 * (v8 >> 4);
        do
        {
          v9 = (int)(v3 + 1);
          v10 = 4;
          do
          {
            v11 = *(_BYTE *)(v9 - 1) + v4;
            v12 = v11 + v5;
            v13 = *(_BYTE *)v9 + v11;
            v14 = v13 + v12;
            v15 = *(_BYTE *)(v9 + 1) + v13;
            v16 = v15 + v14;
            v4 = *(_BYTE *)(v9 + 2) + v15;
            v5 = v4 + v16;
            v9 += 4;
            --v10;
          }
          while ( v10 );
          v3 += 16;
          --v17;
        }
        while ( v17 );
      }
      for ( ; v8; --v8 )
      {
        v4 += *v3++;
        v5 += v4;
      }
      v4 %= 0xFFF1u;
    }
    result = v4 | (v5 << 16);
  }
  else
  {
    result = (int)(a2 + 1);
  }
  return result;
}

//----- (10034BE0) --------------------------------------------------------
signed int __cdecl sub_10034BE0(int a1)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)(a1 + 24) )
  {
    *(_DWORD *)(a1 + 24) = 0;
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10034C00) --------------------------------------------------------
signed int __usercall sub_10034C00@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, int a4, int a5, int a6, int *a7, int a8, unsigned int *a9, unsigned int *a10)
{
  unsigned int v10; // ebp@1
  unsigned int *v11; // edi@1
  _DWORD *v12; // eax@1
  unsigned int v13; // edx@1
  signed int result; // eax@4
  unsigned int v15; // eax@5
  int v16; // ecx@7
  signed int v17; // edx@9
  signed int v18; // esi@13
  int i; // edi@13
  int v20; // esi@14
  int v21; // edi@16
  int v22; // esi@16
  int v23; // edi@17
  int v24; // ebx@17
  int v25; // esi@17
  int v26; // edi@18
  _DWORD *v27; // edi@20
  unsigned int v28; // ebx@20
  int v29; // esi@21
  int v30; // edi@22
  signed int v31; // edi@24
  int v32; // ebx@24
  unsigned int v33; // esi@25
  int v34; // edx@27
  int l; // ebp@28
  unsigned int v36; // edx@31
  unsigned int v37; // ecx@33
  int *v38; // ebp@34
  int v39; // eax@34
  unsigned int v40; // edi@36
  unsigned int v41; // eax@36
  unsigned int v42; // edx@39
  int v43; // eax@40
  unsigned int v44; // eax@41
  int v45; // ecx@41
  int v46; // esi@48
  signed int v47; // edx@50
  unsigned int v48; // eax@50
  int v49; // ecx@51
  unsigned int j; // eax@54
  int v51; // [sp+Ch] [bp-F4h]@7
  unsigned int v52; // [sp+Ch] [bp-F4h]@24
  signed int v53; // [sp+Ch] [bp-F4h]@31
  unsigned int v54; // [sp+10h] [bp-F0h]@9
  int v55; // [sp+14h] [bp-ECh]@24
  int v56; // [sp+18h] [bp-E8h]@26
  _DWORD *v57; // [sp+1Ch] [bp-E4h]@21
  int v58; // [sp+1Ch] [bp-E4h]@31
  unsigned int k; // [sp+20h] [bp-E0h]@24
  int *v60; // [sp+24h] [bp-DCh]@25
  int v61; // [sp+28h] [bp-D8h]@0
  unsigned int v62; // [sp+2Ch] [bp-D4h]@0
  int v63; // [sp+30h] [bp-D0h]@24
  unsigned int *v64; // [sp+34h] [bp-CCh]@24
  int v65; // [sp+38h] [bp-C8h]@11
  int v66; // [sp+3Ch] [bp-C4h]@31
  int v67; // [sp+40h] [bp-C0h]@16
  int v68; // [sp+44h] [bp-BCh]@1
  int v69; // [sp+48h] [bp-B8h]@1
  int v70; // [sp+4Ch] [bp-B4h]@1
  int v71; // [sp+50h] [bp-B0h]@1
  int v72; // [sp+54h] [bp-ACh]@1
  int v73; // [sp+58h] [bp-A8h]@1
  int v74; // [sp+5Ch] [bp-A4h]@1
  int v75; // [sp+60h] [bp-A0h]@1
  int v76; // [sp+64h] [bp-9Ch]@1
  int v77; // [sp+68h] [bp-98h]@1
  int v78; // [sp+6Ch] [bp-94h]@1
  int v79; // [sp+70h] [bp-90h]@1
  int v80; // [sp+74h] [bp-8Ch]@1
  int v81; // [sp+78h] [bp-88h]@1
  int v82; // [sp+7Ch] [bp-84h]@1
  int v83; // [sp+80h] [bp-80h]@1
  int v84; // [sp+84h] [bp-7Ch]@22
  int v85[14]; // [sp+88h] [bp-78h]@17
  int v86; // [sp+C0h] [bp-40h]@41
  int v87[15]; // [sp+C4h] [bp-3Ch]@24
  int v88; // [sp+108h] [bp+8h]@24

  v10 = 0;
  v11 = a1;
  v12 = a2;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v13 = a3;
  do
  {
    ++*(&v68 + *v12);
    ++v12;
    --v13;
  }
  while ( v13 );
  if ( v68 == a3 )
  {
    *a7 = 0;
    *v11 = 0;
    return 0;
  }
  v15 = 1;
  if ( !v69 )
  {
    do
      ++v15;
    while ( !*(&v68 + v15) );
  }
  v16 = v15;
  v51 = v15;
  if ( *v11 > v15 )
    v15 = *v11;
  v54 = v15;
  v17 = 15;
  if ( !v83 )
  {
    do
      --v17;
    while ( !*(&v68 + v17) );
  }
  v65 = v17;
  if ( (signed int)v15 > v17 )
  {
    v54 = v17;
    v15 = v17;
  }
  v18 = 1 << v16;
  *v11 = v15;
  for ( i = v16; i < v17; v18 = 2 * v20 )
  {
    v20 = v18 - *(&v68 + i);
    if ( v20 < 0 )
      return -3;
    ++i;
  }
  v21 = *(&v68 + v17);
  v22 = v18 - v21;
  v67 = v22;
  if ( v22 < 0 )
    return -3;
  v23 = v22 + v21;
  v24 = v17 - 1;
  v25 = 0;
  *(&v68 + v17) = v23;
  v85[0] = 0;
  if ( v17 != 1 )
  {
    v26 = 0;
    do
    {
      v25 += *(int *)((char *)&v69 + v26 * 4);
      ++v26;
      --v24;
      v85[v26] = v25;
    }
    while ( v24 );
  }
  v27 = a2;
  v28 = 0;
  do
  {
    v29 = *v27;
    ++v27;
    v57 = v27;
    if ( v29 )
    {
      v30 = *(&v84 + v29);
      a10[v30] = v28;
      v16 = v51;
      *(&v84 + v29) = v30 + 1;
      v27 = v57;
    }
    ++v28;
  }
  while ( v28 < a3 );
  v88 = *(&v84 + v17);
  v31 = -1;
  v32 = -v15;
  v84 = 0;
  k = 0;
  v64 = a10;
  v87[0] = 0;
  v63 = 0;
  v52 = 0;
  v55 = v16;
  if ( v16 > v17 )
  {
LABEL_60:
    if ( v67 && v17 != 1 )
      result = -5;
    else
      result = 0;
  }
  else
  {
    v33 = v62;
    v60 = &v68 + v16;
    while ( 1 )
    {
      v56 = *v60;
      if ( *v60 )
        break;
LABEL_59:
      v17 = v65;
      ++v60;
      v55 = ++v16;
      if ( v16 > v65 )
        goto LABEL_60;
    }
    while ( 1 )
    {
      --v56;
      v34 = v32 + v15;
      if ( (signed int)(v32 + v15) < v16 )
        break;
LABEL_44:
      BYTE1(v61) = v16 - v32;
      if ( v64 < &a10[v88] )
      {
        v33 = *v64;
        if ( *v64 >= a4 )
        {
          v46 = 4 * (v33 - a4);
          LOBYTE(v61) = *(_BYTE *)(v46 + a6) + 80;
          v33 = *(_DWORD *)(v46 + a5);
        }
        else
        {
          LOBYTE(v61) = v33 < 0x100 ? 0 : 96;
        }
        ++v64;
      }
      else
      {
        LOBYTE(v61) = -64;
      }
      v47 = 1 << (v16 - v32);
      v48 = v10 >> v32;
      if ( v10 >> v32 < v52 )
      {
        v49 = v63 + 8 * v48;
        do
        {
          *(_DWORD *)v49 = v61;
          *(_DWORD *)(v49 + 4) = v33;
          v48 += v47;
          v49 += 8 * v47;
        }
        while ( v48 < v52 );
        v10 = k;
      }
      for ( j = 1 << (v55 - 1); v10 & j; j >>= 1 )
        v10 ^= j;
      v10 ^= j;
      for ( k = v10; (v10 & ((1 << v32) - 1)) != *(&v84 + v31); --v31 )
        v32 -= v54;
      v15 = v54;
      v16 = v55;
      if ( !v56 )
        goto LABEL_59;
    }
    for ( l = v32 - v15; ; l = v58 )
    {
      v66 = v15 + v34;
      v32 += v15;
      ++v31;
      v36 = v65 - v32;
      v53 = v31;
      v58 = v15 + l;
      if ( v65 - v32 > v15 )
        v36 = v15;
      v37 = v16 - v32;
      if ( 1 << v37 > (unsigned int)(v56 + 1) )
      {
        v38 = v60;
        v39 = -1 - v56 + (1 << v37);
        if ( v37 < v36 )
        {
          while ( ++v37 < v36 )
          {
            v40 = v38[1];
            ++v38;
            v41 = 2 * v39;
            if ( v41 <= v40 )
              break;
            v39 = v41 - v40;
          }
        }
        v31 = v53;
      }
      v52 = 1 << v37;
      v42 = *a9 + (1 << v37);
      if ( v42 > 0x5A0 )
        break;
      v43 = a8 + 8 * *a9;
      *a9 = v42;
      v10 = k;
      v87[v31] = v43;
      v63 = v43;
      if ( v31 )
      {
        LOBYTE(v61) = v37;
        v44 = k >> v58;
        v45 = *(&v86 + v31);
        BYTE1(v61) = v54;
        v33 = ((v63 - v45) >> 3) - (k >> v58);
        *(_DWORD *)(v45 + 8 * v44) = v61;
        *(&v84 + v31) = k;
        *(_DWORD *)(v45 + 8 * v44 + 4) = v33;
      }
      else
      {
        *a7 = v43;
      }
      v34 = v66;
      v16 = v55;
      if ( v66 >= v55 )
        goto LABEL_44;
      v15 = v54;
    }
    result = -3;
  }
  return result;
}
// 10034C00: using guessed type int var_78[14];
// 10034C00: using guessed type int var_3C[15];

//----- (100350A0) --------------------------------------------------------
int (__cdecl *__usercall sub_100350A0@<eax>(_DWORD *a1@<eax>, int a2@<esi>, int a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax@3
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax@3

  if ( a1 )
    *a1 = *(_DWORD *)(a2 + 14124);
  v3 = *(_DWORD *)(a2 + 14104);
  *(_DWORD *)(a2 + 14112) = v3;
  *(_DWORD *)(a2 + 14116) = v3;
  result = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a2 + 14120);
  *(_BYTE *)a2 = 0;
  *(_DWORD *)(a2 + 1424) = 0;
  *(_DWORD *)(a2 + 1428) = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    *(_DWORD *)(a2 + 14124) = result;
    *(_DWORD *)(a3 + 28) = result;
  }
  return result;
}

//----- (100350F0) --------------------------------------------------------
int __usercall sub_100350F0@<eax>(int result@<eax>, char a2, char a3, int a4, int a5)
{
  *(_BYTE *)(result + 16) = a2;
  *(_BYTE *)(result + 17) = a3;
  *(_BYTE *)result = 0;
  *(_DWORD *)(result + 20) = a4;
  *(_DWORD *)(result + 24) = a5;
  return result;
}

//----- (10035110) --------------------------------------------------------
signed int __cdecl sub_10035110(int a1, int a2, int a3, int a4, int a5, int a6)
{
  _BYTE *v6; // ebp@1
  unsigned int v7; // ecx@1
  unsigned int v8; // edx@1
  _BYTE *v9; // edi@1
  unsigned int v10; // eax@1
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // esi@8
  int v14; // ecx@8
  int v15; // ecx@11
  int v16; // ebx@13
  unsigned int v17; // eax@13
  unsigned int v18; // edx@13
  int v19; // esi@14
  int v20; // ebx@16
  int v21; // esi@16
  unsigned int v22; // edx@16
  unsigned int v23; // eax@16
  int v24; // ecx@18
  int v25; // ecx@18
  int i; // ebx@19
  char v27; // cl@21
  int v28; // ebx@21
  int v29; // ecx@21
  int v30; // esi@22
  _BYTE *v31; // edi@22
  _BYTE *v32; // esi@22
  unsigned int v33; // ecx@23
  unsigned int v34; // ecx@32
  int v35; // ebp@34
  int v36; // ebx@34
  unsigned int v38; // ecx@35
  int v39; // ebp@37
  int v40; // ebx@37
  int v41; // esi@37
  int v42; // eax@37
  unsigned int v43; // ecx@38
  int v44; // ebp@41
  int v45; // ebx@41
  int v46; // ebp@44
  unsigned int v47; // [sp+10h] [bp-14h]@1
  unsigned int v48; // [sp+14h] [bp-10h]@2
  _BYTE *v49; // [sp+18h] [bp-Ch]@1
  int v50; // [sp+1Ch] [bp-8h]@4
  int v51; // [sp+20h] [bp-4h]@4
  unsigned int v52; // [sp+28h] [bp+4h]@21
  unsigned int v53; // [sp+2Ch] [bp+8h]@13
  int v54; // [sp+2Ch] [bp+8h]@24

  v6 = *(_BYTE **)a6;
  v7 = *(_DWORD *)(a5 + 14112);
  v8 = *(_DWORD *)(a5 + 1428);
  v9 = *(_BYTE **)(a5 + 14116);
  v47 = *(_DWORD *)(a6 + 4);
  v10 = *(_DWORD *)(a5 + 1424);
  v49 = *(_BYTE **)a6;
  if ( (unsigned int)v9 >= v7 )
    v48 = *(_DWORD *)(a5 + 14108) - (_DWORD)v9;
  else
    v48 = v7 - (_DWORD)v9 - 1;
  v50 = dword_100C2B78[a1];
  v51 = dword_100C2B78[a2];
  while ( 1 )
  {
    if ( v10 < 0x14 )
    {
      do
      {
        --v47;
        v11 = *v6 << v10;
        v10 += 8;
        ++v6;
        v8 |= v11;
      }
      while ( v10 < 0x14 );
      v49 = v6;
    }
    v12 = *(_BYTE *)(a3 + 8 * (v8 & v50));
    v13 = a3 + 8 * (v8 & v50);
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( v12 )
      break;
LABEL_29:
    v10 -= v14;
    *v9++ = *(_BYTE *)(v13 + 4);
    --v48;
LABEL_30:
    if ( v48 < 0x102 || v47 < 0xA )
    {
      v34 = *(_DWORD *)(a6 + 4) - v47;
      if ( v10 >> 3 < v34 )
        v34 = v10 >> 3;
      v35 = (int)&v6[-v34];
      *(_DWORD *)(a6 + 4) = v34 + v47;
      v36 = v35 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v35;
      *(_DWORD *)(a6 + 8) += v36;
      *(_DWORD *)(a5 + 14116) = v9;
      *(_DWORD *)(a5 + 1424) = v10 - 8 * v34;
      *(_DWORD *)(a5 + 1428) = v8;
      return 0;
    }
  }
  v10 -= *(_BYTE *)(v13 + 1);
  if ( v12 & 0x10 )
  {
LABEL_13:
    v16 = v12 & 0xF;
    v17 = v10 - v16;
    v53 = *(_DWORD *)(v13 + 4) + (v8 & dword_100C2B78[v16]);
    v18 = v8 >> v16;
    if ( v17 < 0xF )
    {
      do
      {
        --v47;
        v19 = *v6 << v17;
        v17 += 8;
        ++v6;
        v18 |= v19;
      }
      while ( v17 < 0xF );
      v49 = v6;
    }
    v20 = *(_BYTE *)(a4 + 8 * (v18 & v51));
    v21 = a4 + 8 * (v18 & v51);
    v22 = v18 >> *(_BYTE *)(v21 + 1);
    v23 = v17 - *(_BYTE *)(v21 + 1);
    if ( !(v20 & 0x10) )
    {
      while ( !(v20 & 0x40) )
      {
        v24 = *(_DWORD *)(v21 + 4) + (v22 & dword_100C2B78[v20]);
        v20 = *(_BYTE *)(v21 + 8 * v24);
        v21 += 8 * v24;
        v25 = *(_BYTE *)(v21 + 1);
        v22 >>= v25;
        v23 -= v25;
        if ( v20 & 0x10 )
          goto LABEL_19;
      }
      v38 = *(_DWORD *)(a6 + 4) - v47;
      if ( v23 >> 3 < v38 )
        v38 = v23 >> 3;
      v39 = (int)&v6[-v38];
      *(_DWORD *)(a6 + 4) = v38 + v47;
      v40 = v39 - *(_DWORD *)a6;
      *(_DWORD *)a6 = v39;
      *(_DWORD *)(a6 + 8) += v40;
      v41 = a5;
      *(_DWORD *)(a5 + 1428) = v22;
      v42 = v23 - 8 * v38;
      goto LABEL_45;
    }
LABEL_19:
    for ( i = v20 & 0xF; v23 < (unsigned __int16)i; ++v49 )
    {
      --v47;
      v22 |= *v6 << v23;
      v6 = v49 + 1;
      v23 += 8;
    }
    v10 = v23 - i;
    v52 = *(_DWORD *)(v21 + 4) + (v22 & dword_100C2B78[i]);
    v27 = i;
    v28 = v53;
    v48 -= v53;
    v8 = v22 >> v27;
    v29 = *(_DWORD *)(a5 + 14104);
    if ( (unsigned int)&v9[-v29] < v52 )
    {
      v33 = v52 + v29 - (_DWORD)v9;
      v32 = (_BYTE *)(*(_DWORD *)(a5 + 14108) - v33);
      if ( v53 > v33 )
      {
        v54 = v53 - v33;
        do
        {
          *v9++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = *(_BYTE **)(a5 + 14104);
        v28 = v54;
      }
    }
    else
    {
      v30 = (int)&v9[-v52];
      v31 = v9 + 1;
      *(v31 - 1) = *(_BYTE *)v30;
      *v31 = *(_BYTE *)(v30 + 1);
      v9 = v31 + 1;
      v32 = (_BYTE *)(v30 + 2);
      v28 = v53 - 2;
    }
    do
    {
      *v9++ = *v32++;
      --v28;
    }
    while ( v28 );
    goto LABEL_30;
  }
  while ( !(v12 & 0x40) )
  {
    v15 = *(_DWORD *)(v13 + 4) + (v8 & dword_100C2B78[v12]);
    v12 = *(_BYTE *)(v13 + 8 * v15);
    v13 += 8 * v15;
    v14 = *(_BYTE *)(v13 + 1);
    v8 >>= v14;
    if ( !v12 )
      goto LABEL_29;
    v10 -= *(_BYTE *)(v13 + 1);
    if ( v12 & 0x10 )
      goto LABEL_13;
  }
  v43 = *(_DWORD *)(a6 + 4) - v47;
  if ( !(v12 & 0x20) )
  {
    if ( v10 >> 3 < v43 )
      v43 = v10 >> 3;
    v46 = (int)&v6[-v43];
    *(_DWORD *)(a6 + 4) = v43 + v47;
    *(_DWORD *)(a6 + 8) += v46 - *(_DWORD *)a6;
    *(_DWORD *)a6 = v46;
    v41 = a5;
    *(_DWORD *)(a5 + 1428) = v8;
    v42 = v10 - 8 * v43;
LABEL_45:
    *(_DWORD *)(v41 + 14116) = v9;
    *(_DWORD *)(v41 + 1424) = v42;
    return -3;
  }
  if ( v10 >> 3 < v43 )
    v43 = v10 >> 3;
  *(_DWORD *)(a6 + 4) = v43 + v47;
  v44 = (int)&v6[-v43];
  v45 = v44 - *(_DWORD *)a6;
  *(_DWORD *)a6 = v44;
  *(_DWORD *)(a6 + 8) += v45;
  *(_DWORD *)(a5 + 1428) = v8;
  *(_DWORD *)(a5 + 14116) = v9;
  *(_DWORD *)(a5 + 1424) = v10 - 8 * v43;
  return 1;
}
// 100C2B78: using guessed type int dword_100C2B78[];

//----- (100354C0) --------------------------------------------------------
int __usercall sub_100354C0@<eax>(int a1@<edi>, int a2@<esi>, int a3)
{
  const void *v3; // ebx@1
  unsigned int v4; // ebp@1
  size_t v5; // eax@3
  size_t v6; // ebp@3
  int (__cdecl *v7)(_DWORD, const void *, size_t); // eax@8
  int v8; // eax@9
  int v9; // eax@10
  int v10; // ebx@10
  const void *v11; // ebx@11
  size_t v12; // eax@13
  size_t v13; // ebp@13
  int (__cdecl *v14)(_DWORD, const void *, size_t); // eax@15
  int v15; // eax@16
  int result; // eax@18
  void *v17; // [sp+8h] [bp-4h]@1
  char *v18; // [sp+8h] [bp-4h]@10

  v3 = *(const void **)(a2 + 14112);
  v4 = *(_DWORD *)(a2 + 14116);
  v17 = *(void **)(a1 + 12);
  if ( (unsigned int)v3 > v4 )
    v4 = *(_DWORD *)(a2 + 14108);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = v4 - (_DWORD)v3;
  if ( v6 > v5 )
    v6 = *(_DWORD *)(a1 + 16);
  if ( v6 && a3 == -5 )
    a3 = 0;
  *(_DWORD *)(a1 + 20) += v6;
  *(_DWORD *)(a1 + 16) = v5 - v6;
  v7 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
  if ( v7 )
  {
    v8 = v7(*(_DWORD *)(a2 + 14124), v3, v6);
    *(_DWORD *)(a2 + 14124) = v8;
    *(_DWORD *)(a1 + 28) = v8;
  }
  memcpy(v17, v3, v6);
  v9 = *(_DWORD *)(a2 + 14108);
  v18 = (char *)v17 + v6;
  v10 = (int)v3 + v6;
  if ( v10 == v9 )
  {
    v11 = *(const void **)(a2 + 14104);
    if ( *(_DWORD *)(a2 + 14116) == v9 )
      *(_DWORD *)(a2 + 14116) = v11;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a2 + 14116) - (_DWORD)v11;
    if ( v13 > v12 )
      v13 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 20) += v13;
    *(_DWORD *)(a1 + 16) = v12 - v13;
    v14 = *(int (__cdecl **)(_DWORD, const void *, size_t))(a2 + 14120);
    if ( v14 )
    {
      v15 = v14(*(_DWORD *)(a2 + 14124), v11, v13);
      *(_DWORD *)(a2 + 14124) = v15;
      *(_DWORD *)(a1 + 28) = v15;
    }
    memcpy(v18, v11, v13);
    v18 += v13;
    v10 = (int)v11 + v13;
  }
  *(_DWORD *)(a1 + 12) = v18;
  result = a3;
  *(_DWORD *)(a2 + 14112) = v10;
  return result;
}

//----- (10035600) --------------------------------------------------------
signed int __usercall sub_10035600@<eax>(int a1@<edx>, unsigned int *a2@<esi>, _DWORD *a3, int *a4)
{
  signed int result; // eax@1
  int v5; // [sp+0h] [bp-50h]@1
  char v6; // [sp+4h] [bp-4Ch]@1

  v5 = 0;
  result = sub_10034C00(a2, a3, 0x13u, 19, 0, 0, a4, a1, (unsigned int *)&v5, (unsigned int *)&v6);
  if ( result == -5 || !*a2 )
    result = -3;
  return result;
}

//----- (10035650) --------------------------------------------------------
signed int __usercall sub_10035650@<eax>(unsigned int *a1@<eax>, int *a2@<ecx>, int a3@<ebx>, unsigned int a4@<esi>, unsigned int a5, _DWORD *a6, unsigned int *a7, unsigned int *a8, int *a9)
{
  unsigned int *v9; // edi@1
  signed int result; // eax@6
  int v11; // [sp+8h] [bp-4h]@1

  v9 = a1;
  v11 = 0;
  if ( sub_10034C00(a7, a6, a4, 257, (int)&unk_100C2C10, (int)&unk_100C2C90, a2, a3, (unsigned int *)&v11, a1)
    || !*a7
    || sub_10034C00(a8, &a6[a4], a5, 0, (int)&unk_100C2D10, (int)&unk_100C2D88, a9, a3, (unsigned int *)&v11, v9)
    || !*a8 && a4 > 0x101 )
  {
    result = -3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100356F0) --------------------------------------------------------
int __usercall sub_100356F0@<eax>(_DWORD *a1@<eax>, _DWORD *a2@<edx>, _DWORD *a3@<ecx>, _DWORD *a4)
{
  *a1 = 9;
  *a3 = 5;
  *a2 = &unk_100C2E00;
  *a4 = &unk_100C3E00;
  return 0;
}

//----- (10035710) --------------------------------------------------------
signed int __cdecl sub_10035710(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@12
  int v5; // esi@12
  int v6; // ecx@1
  signed int v7; // ebx@1
  signed int result; // eax@9

  v6 = a2;
  v7 = 0;
  if ( a2 < 0 )
  {
    v7 = 1;
    v6 = -a2;
  }
  if ( (1 << v6) + 14152 > a4 || a3 & 3 )
  {
    result = -4;
  }
  else
  {
    *(_DWORD *)(a1 + 24) = a3;
    *(_DWORD *)(a3 + 16) = v6;
    *(_DWORD *)(a3 + 12) = v7;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 20) = a3 + 24;
    *(_DWORD *)(a3 + 14128) = a3 + 14152;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14108) = (1 << v6) + *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14104);
    **(_BYTE **)(a3 + 20) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1428) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1424) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14124) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 1420) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14112) = 0;
    *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14116) = 0;
    if ( *(_DWORD *)(a3 + 12) )
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = 0;
    else
      *(_DWORD *)(*(_DWORD *)(a3 + 20) + 14120) = sub_10034AE0;
    sub_100350A0(0, *(_DWORD *)(a3 + 20), a1);
    if ( a1 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 20) = 0;
      v5 = *(_DWORD *)(v4 + 20);
      *(_BYTE *)v4 = *(_DWORD *)(v4 + 12) != 0 ? 7 : 0;
      sub_100350A0(0, v5, a1);
      result = 0;
    }
    else
    {
      result = -2;
    }
  }
  return result;
}

//----- (10035800) --------------------------------------------------------
void __cdecl sub_10035800(int a1)
{
  JUMPOUT(&loc_100355C0);
}

//----- (10035810) --------------------------------------------------------
int __usercall sub_10035810@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // edi@1
  _BYTE *v4; // ebx@1
  int v5; // esi@1
  _BYTE *v6; // edx@1
  unsigned int v7; // ebp@1
  unsigned int v8; // eax@1
  unsigned int v9; // eax@2
  unsigned int v10; // ecx@4
  int v11; // ecx@8
  signed int v12; // eax@8
  int v13; // ecx@8
  unsigned int v14; // eax@8
  int v15; // ecx@13
  int v16; // eax@16
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  int v20; // eax@27
  int v21; // eax@28
  int v22; // ecx@28
  int v23; // ecx@28
  int v24; // eax@31
  int v25; // eax@32
  int v26; // ecx@32
  int v27; // eax@32
  int v28; // eax@38
  int v29; // eax@39
  int v30; // ecx@39
  int v31; // ecx@40
  int v32; // eax@41
  unsigned int v33; // eax@46
  unsigned int v34; // ecx@46
  int v35; // eax@51
  unsigned int v36; // eax@51
  unsigned int v37; // ecx@55
  unsigned int v38; // eax@55
  bool v39; // zf@61
  unsigned int v40; // eax@67
  unsigned int v41; // ecx@67
  int v42; // eax@72
  unsigned int v43; // eax@72
  unsigned int v44; // ecx@76
  unsigned int v45; // eax@76
  int v47; // eax@91
  int v48; // ecx@93
  int v49; // eax@97
  int v50; // ecx@98
  int v51; // eax@101
  int v52; // [sp-4h] [bp-2Ch]@85
  unsigned int v53; // [sp+10h] [bp-18h]@1
  unsigned int v54; // [sp+14h] [bp-14h]@1
  unsigned int v55; // [sp+18h] [bp-10h]@4
  unsigned int v56; // [sp+18h] [bp-10h]@54
  unsigned int v57; // [sp+18h] [bp-10h]@75
  _BYTE *v58; // [sp+20h] [bp-8h]@43
  int v59; // [sp+2Ch] [bp+4h]@51

  v3 = a1;
  v4 = *(_BYTE **)a1;
  v5 = a2;
  v6 = *(_BYTE **)(a2 + 14116);
  v7 = *(_DWORD *)(a2 + 1424);
  v54 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(a2 + 14112);
  v53 = *(_DWORD *)(a2 + 1428);
  if ( (unsigned int)v6 >= v8 )
    v9 = *(_DWORD *)(a2 + 14108) - (_DWORD)v6;
  else
    v9 = v8 - (_DWORD)v6 - 1;
  v10 = *(_BYTE *)(a2 + 4);
  v55 = v9;
  while ( 2 )
  {
    switch ( v10 )
    {
      case 0u:
        if ( v9 >= 0x102 && v54 >= 0xA )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v11 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v11;
          *(_DWORD *)(v5 + 1428) = v53;
          *(_DWORD *)(v5 + 1424) = v7;
          *(_DWORD *)(v5 + 14116) = v6;
          v12 = sub_10035110(
                  *(_BYTE *)(v5 + 20),
                  *(_BYTE *)(v5 + 21),
                  *(_DWORD *)(v5 + 24),
                  *(_DWORD *)(v5 + 28),
                  v5,
                  v3);
          v4 = *(_BYTE **)v3;
          v7 = *(_DWORD *)(v5 + 1424);
          v13 = v12;
          v54 = *(_DWORD *)(v3 + 4);
          v6 = *(_BYTE **)(v5 + 14116);
          v53 = *(_DWORD *)(v5 + 1428);
          v14 = *(_DWORD *)(v5 + 14112);
          a3 = v13;
          v9 = (unsigned int)v6 >= v14 ? *(_DWORD *)(v5 + 14108) - (_DWORD)v6 : v14 - (_DWORD)v6 - 1;
          v55 = v9;
          if ( v13 )
          {
            *(_BYTE *)(v5 + 4) = 2 * (v13 != 1) + 7;
            goto LABEL_84;
          }
        }
        v15 = *(_DWORD *)(v5 + 24);
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 20);
        *(_DWORD *)(v5 + 12) = v15;
        *(_BYTE *)(v5 + 4) = 1;
        goto LABEL_14;
      case 1u:
LABEL_14:
        if ( v7 >= *(_WORD *)(v5 + 16) )
          goto LABEL_17;
        do
        {
          if ( !v54 )
            goto LABEL_91;
          --v54;
          v16 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v16;
        }
        while ( v7 < *(_WORD *)(v5 + 16) );
LABEL_17:
        v17 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100C2B78[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v17 + 1);
        v18 = v17;
        v7 -= *(_BYTE *)(v17 + 1);
        v19 = *(_BYTE *)v17;
        if ( v19 )
        {
          if ( v19 & 0x10 )
          {
            *(_DWORD *)(v5 + 12) = v19 & 0xF;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(v18 + 4);
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 2;
          }
          else if ( v19 & 0x40 )
          {
            if ( !(v19 & 0x20) )
              goto LABEL_92;
            v9 = v55;
            *(_BYTE *)(v5 + 4) = 7;
          }
          else
          {
            *(_DWORD *)(v5 + 16) = v19;
            v9 = v55;
            *(_DWORD *)(v5 + 12) = v18 + 8 * *(_DWORD *)(v18 + 4);
          }
        }
        else
        {
          v9 = v55;
          *(_DWORD *)(v5 + 12) = *(_DWORD *)(v18 + 4);
          *(_BYTE *)(v5 + 4) = 6;
        }
        goto LABEL_84;
      case 2u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_28;
        do
        {
          if ( !v54 )
            goto LABEL_93;
          --v54;
          v20 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v20;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_28:
        v21 = *(_DWORD *)(v5 + 12);
        v22 = v53 & dword_100C2B78[v21];
        *(_BYTE *)(v5 + 4) = 3;
        *(_DWORD *)(v5 + 8) += v22;
        v53 >>= v21;
        v23 = *(_DWORD *)(v5 + 28);
        v7 -= v21;
        *(_DWORD *)(v5 + 16) = *(_BYTE *)(v5 + 21);
        *(_DWORD *)(v5 + 12) = v23;
LABEL_29:
        if ( v7 < *(_WORD *)(v5 + 16) )
        {
          while ( v54 )
          {
            --v54;
            v24 = *v4 << v7;
            v7 += 8;
            ++v4;
            a3 = 0;
            v53 |= v24;
            if ( v7 >= *(_WORD *)(v5 + 16) )
              goto LABEL_32;
          }
LABEL_91:
          v47 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)(v3 + 4) = 0;
          *(_DWORD *)(v3 + 8) += v47;
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v5 + 14116) = v6;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = a3;
          goto LABEL_90;
        }
LABEL_32:
        v25 = *(_DWORD *)(v5 + 12) + 8 * (v53 & dword_100C2B78[*(_DWORD *)(v5 + 16)]);
        v53 >>= *(_BYTE *)(v25 + 1);
        v26 = v25;
        v7 -= *(_BYTE *)(v25 + 1);
        v27 = *(_BYTE *)v25;
        if ( v27 & 0x10 )
        {
          *(_DWORD *)(v5 + 12) = v27 & 0xF;
          v9 = v55;
          *(_DWORD *)(v5 + 16) = *(_DWORD *)(v26 + 4);
          *(_BYTE *)(v5 + 4) = 4;
        }
        else
        {
          if ( v27 & 0x40 )
          {
LABEL_92:
            *(_BYTE *)(v5 + 4) = 9;
            v52 = -3;
            goto LABEL_86;
          }
          *(_DWORD *)(v5 + 16) = v27;
          v9 = v55;
          *(_DWORD *)(v5 + 12) = v26 + 8 * *(_DWORD *)(v26 + 4);
        }
        goto LABEL_84;
      case 3u:
        goto LABEL_29;
      case 4u:
        if ( v7 >= *(_WORD *)(v5 + 12) )
          goto LABEL_39;
        do
        {
          if ( !v54 )
          {
LABEL_93:
            v48 = (int)&v4[-*(_DWORD *)v3];
            *(_DWORD *)(v3 + 4) = 0;
            *(_DWORD *)(v3 + 8) += v48;
            v52 = a3;
            goto LABEL_88;
          }
          --v54;
          v28 = *v4 << v7;
          v7 += 8;
          ++v4;
          a3 = 0;
          v53 |= v28;
        }
        while ( v7 < *(_WORD *)(v5 + 12) );
LABEL_39:
        v29 = *(_DWORD *)(v5 + 12);
        v30 = v53 & dword_100C2B78[v29];
        *(_BYTE *)(v5 + 4) = 5;
        *(_DWORD *)(v5 + 16) += v30;
        v53 >>= v29;
        v7 -= v29;
LABEL_40:
        v31 = *(_DWORD *)(v5 + 16);
        if ( (signed int)&v6[-*(_DWORD *)(v5 + 14104)] >= v31 )
          v32 = (int)&v6[-v31];
        else
          v32 = (int)&v6[*(_DWORD *)(v5 + 14108) - v31 - *(_DWORD *)(v5 + 14104)];
        v58 = (_BYTE *)v32;
        v9 = v55;
        if ( !*(_DWORD *)(v5 + 8) )
        {
LABEL_83:
          *(_BYTE *)(v5 + 4) = 0;
LABEL_84:
          v10 = *(_BYTE *)(v5 + 4);
          if ( v10 > 9 )
          {
LABEL_85:
            v52 = -2;
LABEL_86:
            *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
            goto LABEL_87;
          }
          continue;
        }
        while ( 1 )
        {
          if ( !v9 )
          {
            if ( v6 != *(_BYTE **)(v5 + 14108)
              || (v33 = *(_DWORD *)(v5 + 14112), v34 = *(_DWORD *)(v5 + 14104), v33 == v34)
              || ((v6 = *(_BYTE **)(v5 + 14104), v34 >= v33) ? (v9 = *(_DWORD *)(v5 + 14108) - v34) : (v9 = v33 - v34 - 1),
                  !v9) )
            {
              *(_DWORD *)(v5 + 14116) = v6;
              v35 = sub_100354C0(v3, v5, a3);
              v6 = *(_BYTE **)(v5 + 14116);
              v59 = v35;
              v36 = *(_DWORD *)(v5 + 14112);
              if ( (unsigned int)v6 >= v36 )
                v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
              else
                v9 = v36 - (_DWORD)v6 - 1;
              v56 = v9;
              if ( v6 == *(_BYTE **)(v5 + 14108) )
              {
                v37 = *(_DWORD *)(v5 + 14104);
                v38 = *(_DWORD *)(v5 + 14112);
                if ( v38 == v37 )
                {
                  v9 = v56;
                }
                else
                {
                  v6 = *(_BYTE **)(v5 + 14104);
                  if ( v37 >= v38 )
                    v9 = *(_DWORD *)(v5 + 14108) - v37;
                  else
                    v9 = v38 - v37 - 1;
                }
              }
              if ( !v9 )
                break;
            }
          }
          *v6 = *v58;
          --v9;
          ++v6;
          v39 = v58 + 1 == *(_BYTE **)(v5 + 14108);
          a3 = 0;
          v55 = v9;
          ++v58;
          if ( v39 )
            v58 = *(_BYTE **)(v5 + 14104);
          if ( !--*(_DWORD *)(v5 + 8) )
            goto LABEL_83;
        }
LABEL_94:
        *(_DWORD *)(v3 + 8) += &v4[-*(_DWORD *)v3];
        v52 = v59;
LABEL_87:
        *(_DWORD *)(v3 + 4) = v54;
LABEL_88:
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
LABEL_89:
        *(_DWORD *)(v5 + 14116) = v6;
LABEL_90:
        *(_DWORD *)(v5 + 1424) = v7;
        return sub_100354C0(v3, v5, v52);
      case 5u:
        goto LABEL_40;
      case 6u:
        if ( !v9 )
        {
          if ( v6 != *(_BYTE **)(v5 + 14108)
            || (v40 = *(_DWORD *)(v5 + 14112), v41 = *(_DWORD *)(v5 + 14104), v40 == v41)
            || ((v6 = *(_BYTE **)(v5 + 14104), v41 >= v40) ? (v9 = *(_DWORD *)(v5 + 14108) - v41) : (v9 = v40 - v41 - 1),
                !v9) )
          {
            *(_DWORD *)(v5 + 14116) = v6;
            v42 = sub_100354C0(v3, v5, a3);
            v6 = *(_BYTE **)(v5 + 14116);
            v59 = v42;
            v43 = *(_DWORD *)(v5 + 14112);
            if ( (unsigned int)v6 >= v43 )
              v9 = *(_DWORD *)(v5 + 14108) - (_DWORD)v6;
            else
              v9 = v43 - (_DWORD)v6 - 1;
            v57 = v9;
            if ( v6 == *(_BYTE **)(v5 + 14108) )
            {
              v44 = *(_DWORD *)(v5 + 14104);
              v45 = *(_DWORD *)(v5 + 14112);
              if ( v45 == v44 )
              {
                v9 = v57;
              }
              else
              {
                v6 = *(_BYTE **)(v5 + 14104);
                if ( v44 >= v45 )
                  v9 = *(_DWORD *)(v5 + 14108) - v44;
                else
                  v9 = v45 - v44 - 1;
              }
            }
            if ( !v9 )
              goto LABEL_94;
          }
        }
        *v6++ = *(_BYTE *)(v5 + 12);
        --v9;
        a3 = 0;
        v55 = v9;
        goto LABEL_83;
      case 7u:
        if ( v7 > 7 )
        {
          ++v54;
          v7 -= 8;
          --v4;
        }
        *(_DWORD *)(v5 + 14116) = v6;
        v49 = sub_100354C0(v3, v5, a3);
        v6 = *(_BYTE **)(v5 + 14116);
        if ( *(_BYTE **)(v5 + 14112) != v6 )
        {
          *(_DWORD *)(v3 + 4) = v54;
          v50 = (int)&v4[-*(_DWORD *)v3];
          *(_DWORD *)v3 = v4;
          *(_DWORD *)(v3 + 8) += v50;
          *(_DWORD *)(v5 + 1428) = v53;
          v52 = v49;
          goto LABEL_89;
        }
        *(_BYTE *)(v5 + 4) = 8;
LABEL_100:
        v52 = 1;
        goto LABEL_86;
      case 8u:
        goto LABEL_100;
      case 9u:
        v51 = (int)&v4[-*(_DWORD *)v3];
        *(_DWORD *)(v3 + 4) = v54;
        *(_DWORD *)(v3 + 8) += v51;
        *(_DWORD *)v3 = v4;
        *(_DWORD *)(v5 + 1428) = v53;
        v52 = -3;
        goto LABEL_89;
      default:
        goto LABEL_85;
    }
  }
}
// 100C2B78: using guessed type int dword_100C2B78[];

//----- (10035EB0) --------------------------------------------------------
int __usercall sub_10035EB0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  unsigned int v6; // esi@1
  int v7; // edi@1
  size_t v8; // ecx@1
  char *v9; // eax@1
  char *v10; // ecx@1
  int v11; // edx@2
  unsigned int v12; // edx@4
  int v13; // edx@8
  unsigned int v14; // eax@9
  int v15; // eax@10
  int v16; // ebx@14
  int v17; // ecx@14
  int v18; // edx@17
  char *v19; // edx@24
  unsigned int v20; // eax@25
  unsigned int v21; // ecx@25
  int v22; // eax@27
  int v23; // eax@30
  unsigned int v24; // ecx@30
  int v25; // edx@31
  char *v26; // esi@33
  unsigned int v27; // edx@34
  size_t v28; // esi@39
  bool v29; // zf@43
  int v30; // edx@47
  int v31; // ecx@48
  int v32; // edx@54
  unsigned int v33; // ecx@61
  int v34; // edx@63
  int v35; // edx@64
  int v36; // ecx@64
  unsigned int v37; // edx@64
  int v38; // edx@71
  unsigned int v39; // esi@72
  unsigned int v40; // ecx@72
  unsigned int *v41; // eax@77
  unsigned int v42; // esi@81
  int v43; // eax@81
  int v44; // edx@83
  char *v45; // ecx@84
  unsigned int v46; // eax@84
  int v47; // eax@85
  char *v48; // eax@91
  int v49; // ecx@92
  int v50; // ecx@94
  int v51; // edx@96
  int v52; // edx@97
  int v53; // edx@99
  int v55; // eax@102
  int v56; // edx@103
  int v57; // edx@106
  int v58; // [sp-4h] [bp-3Ch]@91
  size_t v59; // [sp+10h] [bp-28h]@1
  char *v60; // [sp+14h] [bp-24h]@1
  char *v61; // [sp+18h] [bp-20h]@1
  unsigned int v62; // [sp+1Ch] [bp-1Ch]@4
  int v63; // [sp+1Ch] [bp-1Ch]@69
  int v64; // [sp+1Ch] [bp-1Ch]@72
  unsigned int v65; // [sp+20h] [bp-18h]@1
  unsigned int v66; // [sp+24h] [bp-14h]@13
  unsigned int v67; // [sp+28h] [bp-10h]@13
  int v68; // [sp+2Ch] [bp-Ch]@13
  int v69; // [sp+30h] [bp-8h]@13
  unsigned int v70; // [sp+34h] [bp-4h]@69
  unsigned int v71; // [sp+3Ch] [bp+4h]@1

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 14112);
  v5 = *(_DWORD *)(a2 + 1424);
  v6 = *(_DWORD *)(a2 + 1428);
  v7 = a1;
  v8 = *(_DWORD *)(a1 + 4);
  v9 = *(char **)a1;
  v59 = v8;
  v10 = *(char **)(a2 + 14116);
  v61 = v9;
  v71 = *(_DWORD *)(a2 + 1428);
  v65 = v5;
  v60 = v10;
  if ( (unsigned int)v10 >= v4 )
    v11 = *(_DWORD *)(v3 + 14108) - (_DWORD)v10;
  else
    v11 = v4 - (_DWORD)v10 - 1;
  v62 = v11;
  v12 = *(_BYTE *)v3;
  while ( 2 )
  {
    switch ( v12 )
    {
      case 0u:
        for ( ; v5 < 3; v71 = v6 )
        {
          if ( !v59 )
            goto LABEL_91;
          --v59;
          a3 = 0;
          v13 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v13;
        }
        v14 = (v6 & 7) >> 1;
        *(_DWORD *)(v3 + 1420) = v6 & 1;
        if ( !v14 )
        {
          v16 = v5 - 3;
          v17 = v16 & 7;
          v5 = v16 - v17;
          v65 = v5;
          *(_BYTE *)v3 = 1;
          v71 = v6 >> 3 >> v17;
          goto LABEL_89;
        }
        v15 = v14 - 1;
        if ( !v15 )
        {
          sub_100356F0(&v67, &v69, &v66, &v68);
          sub_100350F0(v3 + 4, v67, v66, v69, v68);
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 6;
          goto LABEL_89;
        }
        if ( v15 == 1 )
        {
          v5 -= 3;
          v71 = v6 >> 3;
          v65 = v5;
          *(_BYTE *)v3 = 3;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 9;
        v49 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v49;
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v3 + 1428) = v71 >> 3;
        v5 -= 3;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      case 1u:
        if ( v5 >= 0x20 )
          goto LABEL_18;
        do
        {
          if ( !v59 )
          {
LABEL_91:
            v48 = v61;
            *(_DWORD *)(v7 + 4) = 0;
            *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
            v58 = a3;
            goto LABEL_110;
          }
          --v59;
          a3 = 0;
          v18 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          v61 = v9;
          v6 |= v18;
          v71 = v6;
        }
        while ( v5 < 0x20 );
LABEL_18:
        if ( ~v6 >> 16 != (unsigned __int16)v6 )
          goto LABEL_93;
        v5 = 0;
        *(_DWORD *)(v3 + 4) = (unsigned __int16)v6;
        v65 = 0;
        v71 = 0;
        if ( (_WORD)v6 )
          *(_BYTE *)v3 = 2;
        else
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
LABEL_89:
        v12 = *(_BYTE *)v3;
        if ( v12 <= 9 )
        {
          v10 = v60;
          v9 = v61;
          v6 = v71;
          continue;
        }
LABEL_107:
        v58 = -2;
        goto LABEL_108;
      case 2u:
        if ( !v59 )
          goto LABEL_94;
        if ( !v62 )
        {
          if ( (v19 = *(char **)(v3 + 14108), v60 != v19)
            || (v20 = *(_DWORD *)(v3 + 14112), v21 = *(_DWORD *)(v3 + 14104), v21 == v20)
            || ((v60 = *(char **)(v3 + 14104), v21 >= v20) ? (v22 = (int)&v19[-v21], v62 = (unsigned int)&v19[-v21]) : (v22 = v20 - v21 - 1, v62 = v22),
                !v22) )
          {
            *(_DWORD *)(v3 + 14116) = v60;
            v23 = sub_100354C0(v7, v3, a3);
            v24 = *(_DWORD *)(v3 + 14112);
            v60 = *(char **)(v3 + 14116);
            if ( *(_DWORD *)(v3 + 14116) >= v24 )
              v25 = *(_DWORD *)(v3 + 14108) - (_DWORD)v60;
            else
              v25 = v24 - (_DWORD)v60 - 1;
            v26 = *(char **)(v3 + 14108);
            v62 = v25;
            if ( v60 == v26 )
            {
              v27 = *(_DWORD *)(v3 + 14104);
              if ( v27 != v24 )
              {
                v60 = *(char **)(v3 + 14104);
                if ( v27 >= v24 )
                  v62 = (unsigned int)&v26[-v27];
                else
                  v62 = v24 - v27 - 1;
              }
            }
            if ( !v62 )
              goto LABEL_96;
          }
        }
        v28 = *(_DWORD *)(v3 + 4);
        a3 = 0;
        if ( v28 > v59 )
          v28 = v59;
        if ( v28 > v62 )
          v28 = v62;
        memcpy(v60, v61, v28);
        v61 += v28;
        v59 -= v28;
        v60 += v28;
        v62 -= v28;
        v29 = *(_DWORD *)(v3 + 4) == v28;
        *(_DWORD *)(v3 + 4) -= v28;
        if ( v29 )
          *(_BYTE *)v3 = *(_DWORD *)(v3 + 1420) != 0 ? 7 : 0;
        goto LABEL_89;
      case 3u:
        if ( v5 >= 0xE )
          goto LABEL_48;
        break;
      case 4u:
        goto LABEL_51;
      case 5u:
        goto LABEL_60;
      case 6u:
        goto LABEL_83;
      case 7u:
        goto LABEL_102;
      case 8u:
        goto LABEL_105;
      case 9u:
        v57 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)(v7 + 4) = v59;
        *(_DWORD *)(v7 + 8) += v57;
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = -3;
        goto LABEL_111;
      default:
        goto LABEL_107;
    }
    break;
  }
  do
  {
    if ( !v59 )
      goto LABEL_94;
    --v59;
    v30 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v30;
    v71 = v6;
    v61 = v9;
  }
  while ( v5 < 0xE );
LABEL_48:
  v31 = v6 & 0x3FFF;
  *(_DWORD *)(v3 + 4) = v31;
  if ( (v6 & 0x1F) > 0x1D || (v6 & 0x3E0) > 0x3A0 )
  {
LABEL_93:
    *(_BYTE *)v3 = 9;
    v58 = -3;
LABEL_108:
    *(_DWORD *)(v7 + 4) = v59;
LABEL_109:
    v48 = v61;
    *(_DWORD *)(v7 + 8) += &v61[-*(_DWORD *)v7];
    goto LABEL_110;
  }
  v6 >>= 14;
  v5 -= 14;
  v71 = v6;
  v65 = v5;
  *(_DWORD *)(v3 + 8) = 0;
  *(_BYTE *)v3 = 4;
LABEL_51:
  if ( *(_DWORD *)(v3 + 8) < (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
  {
    while ( v5 >= 3 )
    {
LABEL_55:
      *(_DWORD *)(v3 + 4 * dword_100C2BC0[(*(_DWORD *)(v3 + 8))++] + 12) = v6 & 7;
      v6 >>= 3;
      v5 -= 3;
      v71 = v6;
      v65 = v5;
      if ( *(_DWORD *)(v3 + 8) >= (unsigned int)((*(_DWORD *)(v3 + 4) >> 10) + 4) )
        goto LABEL_56;
    }
    while ( v59 )
    {
      --v59;
      v32 = (unsigned __int8)*v9++ << v5;
      v5 += 8;
      a3 = 0;
      v6 |= v32;
      v71 = v6;
      v61 = v9;
      if ( v5 >= 3 )
        goto LABEL_55;
    }
    goto LABEL_94;
  }
LABEL_56:
  while ( *(_DWORD *)(v3 + 8) < 0x13u )
    *(_DWORD *)(v3 + 4 * dword_100C2BC0[(*(_DWORD *)(v3 + 8))++] + 12) = 0;
  *(_DWORD *)(v3 + 1412) = 7;
  v23 = sub_10035600(v3 + 1432, (unsigned int *)(v3 + 1412), (_DWORD *)(v3 + 12), (int *)(v3 + 1416));
  if ( v23 )
  {
    *(_BYTE *)v3 = 9;
LABEL_96:
    *(_DWORD *)(v7 + 4) = v59;
    v51 = (int)&v61[-*(_DWORD *)v7];
    *(_DWORD *)v7 = v61;
    *(_DWORD *)(v7 + 8) += v51;
    *(_DWORD *)(v3 + 1428) = v71;
    *(_DWORD *)(v3 + 14116) = v60;
    v58 = v23;
    goto LABEL_111;
  }
  v6 = v71;
  *(_DWORD *)(v3 + 8) = 0;
  v9 = v61;
  *(_BYTE *)v3 = 5;
LABEL_60:
  if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
  {
LABEL_81:
    v42 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 1416) = 0;
    v67 = 9;
    v66 = 6;
    v43 = sub_10035650(
            (unsigned int *)(v3 + 12952),
            &v69,
            v3 + 1432,
            (v42 & 0x1F) + 257,
            ((v42 >> 5) & 0x1F) + 1,
            (_DWORD *)(v3 + 12),
            &v67,
            &v66,
            &v68);
    if ( v43 )
    {
      *(_BYTE *)v3 = 9;
      *(_DWORD *)(v7 + 4) = v59;
      v53 = (int)&v61[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v61;
      *(_DWORD *)(v7 + 8) += v53;
      *(_DWORD *)(v3 + 1428) = v71;
      *(_DWORD *)(v3 + 1424) = v65;
      *(_DWORD *)(v3 + 14116) = v60;
    }
    else
    {
      sub_100350F0(v3 + 4, v67, v66, v69, v68);
      v5 = v65;
      v10 = v60;
      v9 = v61;
      v6 = v71;
      *(_BYTE *)v3 = 6;
LABEL_83:
      *(_DWORD *)(v7 + 4) = v59;
      v44 = (int)&v9[-*(_DWORD *)v7];
      *(_DWORD *)v7 = v9;
      *(_DWORD *)(v7 + 8) += v44;
      *(_DWORD *)(v3 + 14116) = v10;
      *(_DWORD *)(v3 + 1428) = v6;
      *(_DWORD *)(v3 + 1424) = v5;
      v43 = sub_10035810(v7, v3, a3);
      if ( v43 == 1 )
      {
        v5 = *(_DWORD *)(v3 + 1424);
        v61 = *(char **)v7;
        v45 = *(char **)(v3 + 14116);
        v71 = *(_DWORD *)(v3 + 1428);
        v46 = *(_DWORD *)(v3 + 14112);
        a3 = 0;
        v59 = *(_DWORD *)(v7 + 4);
        v65 = *(_DWORD *)(v3 + 1424);
        v60 = v45;
        if ( (unsigned int)v45 >= v46 )
          v47 = *(_DWORD *)(v3 + 14108) - (_DWORD)v45;
        else
          v47 = v46 - (_DWORD)v45 - 1;
        v62 = v47;
        if ( !*(_DWORD *)(v3 + 1420) )
        {
          *(_BYTE *)v3 = 0;
          goto LABEL_89;
        }
        *(_BYTE *)v3 = 7;
LABEL_102:
        *(_DWORD *)(v3 + 14116) = v60;
        v55 = sub_100354C0(v7, v3, a3);
        v60 = *(char **)(v3 + 14116);
        if ( *(_DWORD *)(v3 + 14112) != *(_DWORD *)(v3 + 14116) )
        {
          *(_DWORD *)(v7 + 4) = v59;
          v56 = (int)&v61[-*(_DWORD *)v7];
          *(_DWORD *)v7 = v61;
          *(_DWORD *)(v7 + 8) += v56;
          *(_DWORD *)(v3 + 1428) = v71;
          *(_DWORD *)(v3 + 1424) = v5;
          *(_DWORD *)(v3 + 14116) = v60;
          return sub_100354C0(v7, v3, v55);
        }
        *(_BYTE *)v3 = 8;
LABEL_105:
        *(_DWORD *)(v7 + 4) = v59;
        v58 = 1;
        goto LABEL_109;
      }
    }
    return sub_100354C0(v7, v3, v43);
  }
  while ( 1 )
  {
    v33 = *(_WORD *)(v3 + 1412);
    v67 = *(_WORD *)(v3 + 1412);
    if ( v5 < v33 )
      break;
LABEL_64:
    v35 = *(_DWORD *)(v3 + 1416) + 8 * (v6 & dword_100C2B78[*(_DWORD *)(v3 + 1412)]);
    v36 = *(_BYTE *)(v35 + 1);
    v37 = *(_DWORD *)(v35 + 4);
    v66 = v37;
    if ( v37 >= 0x10 )
    {
      if ( v37 == 18 )
        v67 = 7;
      else
        v67 = v37 - 14;
      v63 = 8 * (v37 == 18) + 3;
      v70 = (unsigned __int16)(v36 + v67);
      if ( v5 < v70 )
      {
        while ( v59 )
        {
          --v59;
          v38 = (unsigned __int8)*v9++ << v5;
          v5 += 8;
          a3 = 0;
          v6 |= v38;
          v71 = v6;
          v61 = v9;
          if ( v5 >= v70 )
            goto LABEL_72;
        }
        v52 = (int)&v61[-*(_DWORD *)v7];
        *(_DWORD *)v7 = v61;
        *(_DWORD *)(v7 + 8) += v52;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v3 + 1428) = v71;
        *(_DWORD *)(v3 + 14116) = v60;
        v58 = a3;
        goto LABEL_111;
      }
LABEL_72:
      v39 = v6 >> v36;
      v64 = (v39 & dword_100C2B78[v67]) + v63;
      v6 = v39 >> v67;
      v5 -= v36 + v67;
      v40 = *(_DWORD *)(v3 + 8);
      v71 = v6;
      v65 = v5;
      if ( v40 + v64 > ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
        goto LABEL_98;
      if ( v66 == 16 )
      {
        if ( v40 < 1 )
        {
LABEL_98:
          *(_BYTE *)v3 = 9;
          *(_DWORD *)(v7 + 4) = v59;
          v58 = -3;
          goto LABEL_109;
        }
        v66 = *(_DWORD *)(v3 + 4 * v40 + 8);
      }
      else
      {
        v66 = 0;
      }
      v41 = (unsigned int *)(v3 + 4 * v40 + 12);
      do
      {
        *v41 = v66;
        ++v40;
        ++v41;
        --v64;
      }
      while ( v64 );
      v9 = v61;
      *(_DWORD *)(v3 + 8) = v40;
    }
    else
    {
      v6 >>= v36;
      v5 -= v36;
      *(_DWORD *)(v3 + 4 * (*(_DWORD *)(v3 + 8))++ + 12) = v37;
      v71 = v6;
      v65 = v5;
    }
    if ( *(_DWORD *)(v3 + 8) >= ((*(_DWORD *)(v3 + 4) >> 5) & 0x1F) + (*(_DWORD *)(v3 + 4) & 0x1Fu) + 258 )
      goto LABEL_81;
  }
  while ( v59 )
  {
    --v59;
    v34 = (unsigned __int8)*v9++ << v5;
    v5 += 8;
    a3 = 0;
    v6 |= v34;
    v71 = v6;
    v61 = v9;
    if ( v5 >= v67 )
      goto LABEL_64;
  }
LABEL_94:
  v48 = v61;
  v50 = (int)&v61[-*(_DWORD *)v7];
  *(_DWORD *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) += v50;
  v58 = a3;
LABEL_110:
  *(_DWORD *)v7 = v48;
  *(_DWORD *)(v3 + 14116) = v60;
  *(_DWORD *)(v3 + 1428) = v71;
LABEL_111:
  *(_DWORD *)(v3 + 1424) = v5;
  return sub_100354C0(v7, v3, v58);
}
// 100C2B78: using guessed type int dword_100C2B78[];
// 100C2BC0: using guessed type int dword_100C2BC0[];

//----- (10036890) --------------------------------------------------------
signed int __usercall sub_10036890@<eax>(int a1@<edi>, int a2)
{
  int v2; // ebp@3
  int v3; // ebx@3
  signed int v4; // esi@3
  unsigned int v5; // eax@3
  int v6; // eax@5
  _BYTE *v7; // ecx@6
  int v8; // eax@9
  int v9; // ecx@10
  int v10; // eax@13
  int v11; // eax@21
  int v12; // eax@23
  _BYTE *v13; // edx@24
  int v14; // eax@25
  _BYTE *v15; // ecx@26
  int v16; // eax@27
  signed int result; // eax@32
  int v18; // eax@34
  int v19; // eax@36
  _BYTE *v20; // edx@37
  int v21; // eax@38
  _BYTE *v22; // ecx@39
  int v23; // eax@40
  signed int v24; // [sp+8h] [bp+4h]@3

  if ( !a1 || !*(_DWORD *)a1 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  v3 = -5;
  v4 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v5 = *(_BYTE *)v2;
  v24 = a2 != 4 ? 0 : 0xFFFFFFFB;
  while ( 2 )
  {
    switch ( v5 )
    {
      case 0u:
        v6 = *(_DWORD *)(a1 + 4);
        if ( !v6 )
          goto LABEL_44;
        v7 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v6 - 1;
        *(_DWORD *)(v2 + 4) = *v7;
        ++*(_DWORD *)a1;
        v3 = v4;
        if ( (*(_DWORD *)(v2 + 4) & 0xF) != 8 || (unsigned int)((*(_DWORD *)(v2 + 4) >> 4) + 8) > *(_DWORD *)(v2 + 16) )
          goto LABEL_29;
        *(_BYTE *)v2 = 1;
        goto LABEL_9;
      case 1u:
LABEL_9:
        v8 = *(_DWORD *)(a1 + 4);
        if ( !v8 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v8 - 1;
        v9 = *(_BYTE *)(*(_DWORD *)a1)++;
        v3 = v4;
        if ( (v9 + (*(_DWORD *)(v2 + 4) << 8)) % 0x1Fu )
          goto LABEL_29;
        if ( !(v9 & 0x20) )
        {
          *(_BYTE *)v2 = 7;
LABEL_31:
          v5 = *(_BYTE *)v2;
          if ( v5 > 0xD )
            return -2;
          continue;
        }
        *(_BYTE *)v2 = 2;
LABEL_34:
        v18 = *(_DWORD *)(a1 + 4);
        if ( !v18 )
          goto LABEL_44;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v18 - 1;
        *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
        v3 = v4;
        *(_BYTE *)v2 = 3;
LABEL_36:
        v19 = *(_DWORD *)(a1 + 4);
        if ( !v19 )
          goto LABEL_44;
        v20 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v19 - 1;
        *(_DWORD *)(v2 + 8) += *v20 << 16;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 4;
LABEL_38:
        v21 = *(_DWORD *)(a1 + 4);
        if ( !v21 )
          goto LABEL_44;
        v22 = *(_BYTE **)a1;
        ++*(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 4) = v21 - 1;
        *(_DWORD *)(v2 + 8) += *v22 << 8;
        ++*(_DWORD *)a1;
        v3 = v4;
        *(_BYTE *)v2 = 5;
LABEL_40:
        v23 = *(_DWORD *)(a1 + 4);
        if ( v23 )
        {
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v23 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v2 + 8);
          *(_BYTE *)v2 = 6;
          result = 2;
        }
        else
        {
LABEL_44:
          result = v3;
        }
        return result;
      case 7u:
        v10 = sub_10035EB0(a1, *(_DWORD *)(v2 + 20), v3);
        v3 = v10;
        if ( v10 == -3 )
        {
          *(_DWORD *)(v2 + 4) = 0;
        }
        else
        {
          if ( !v10 )
            v3 = v4;
          if ( v3 != 1 )
            goto LABEL_44;
          v3 = v4;
          sub_100350A0((_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 20), a1);
          v4 = v24;
          if ( *(_DWORD *)(v2 + 12) )
          {
            *(_BYTE *)v2 = 12;
            goto LABEL_31;
          }
          *(_BYTE *)v2 = 8;
LABEL_21:
          v11 = *(_DWORD *)(a1 + 4);
          if ( !v11 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v11 - 1;
          *(_DWORD *)(v2 + 8) = *(_BYTE *)(*(_DWORD *)a1)++ << 24;
          v3 = v4;
          *(_BYTE *)v2 = 9;
LABEL_23:
          v12 = *(_DWORD *)(a1 + 4);
          if ( !v12 )
            goto LABEL_44;
          v13 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v12 - 1;
          *(_DWORD *)(v2 + 8) += *v13 << 16;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 10;
LABEL_25:
          v14 = *(_DWORD *)(a1 + 4);
          if ( !v14 )
            goto LABEL_44;
          v15 = *(_BYTE **)a1;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v14 - 1;
          *(_DWORD *)(v2 + 8) += *v15 << 8;
          ++*(_DWORD *)a1;
          v3 = v4;
          *(_BYTE *)v2 = 11;
LABEL_27:
          v16 = *(_DWORD *)(a1 + 4);
          if ( !v16 )
            goto LABEL_44;
          ++*(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = v16 - 1;
          *(_DWORD *)(v2 + 8) += *(_BYTE *)(*(_DWORD *)a1)++;
          v3 = v4;
          if ( *(_DWORD *)(v2 + 4) == *(_DWORD *)(v2 + 8) )
          {
            *(_BYTE *)v2 = 12;
            return 1;
          }
LABEL_29:
          *(_DWORD *)(v2 + 4) = 5;
        }
        *(_BYTE *)v2 = 13;
        goto LABEL_31;
      case 8u:
        goto LABEL_21;
      case 9u:
        goto LABEL_23;
      case 0xAu:
        goto LABEL_25;
      case 0xBu:
        goto LABEL_27;
      case 2u:
        goto LABEL_34;
      case 3u:
        goto LABEL_36;
      case 4u:
        goto LABEL_38;
      case 5u:
        goto LABEL_40;
      case 6u:
        *(_BYTE *)v2 = 13;
        *(_DWORD *)(v2 + 4) = 0;
        return -2;
      case 0xCu:
        return 1;
      case 0xDu:
        return -3;
      default:
        return -2;
    }
  }
}

//----- (10036BC0) --------------------------------------------------------
signed int __cdecl sub_10036BC0(int a1, int *a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // eax@1
  signed int result; // eax@1
  int v9; // [sp+4h] [bp-20h]@1
  int v10; // [sp+8h] [bp-1Ch]@1
  int v11; // [sp+10h] [bp-14h]@1
  int v12; // [sp+14h] [bp-10h]@1
  int v13; // [sp+18h] [bp-Ch]@3

  v10 = a4;
  v9 = a3;
  v7 = *a2;
  v11 = a1;
  v12 = v7;
  LOBYTE(result) = sub_10035710((int)&v9, a7, a5, a6);
  if ( (_BYTE)result )
  {
    *a2 = 0;
  }
  else
  {
    LOBYTE(result) = sub_10036890((int)&v9, 4);
    if ( (_BYTE)result == 1 )
    {
      *a2 = v13;
      return 1;
    }
  }
  return (char)result;
}

//----- (10036C40) --------------------------------------------------------
signed int __cdecl sub_10036C40(int a1, int a2)
{
  return sub_10036890(a1, a2);
}

//----- (10036C60) --------------------------------------------------------
char __cdecl sub_10036C60(char a1, _BYTE *a2, _BYTE *a3, char a4)
{
  _BYTE *v4; // eax@2

  if ( a1 == 1 )
  {
    v4 = a2;
    *v4 |= a4;
  }
  else
  {
    LOBYTE(v4) = a1 - 2;
    if ( a1 == 2 )
    {
      *a2 = a4;
      if ( a4 )
      {
        LOBYTE(v4) = *a3 == 0;
        *a2 = (_BYTE)v4;
      }
      else
      {
        LOBYTE(v4) = (_BYTE)a3;
        *a3 = 1;
      }
    }
  }
  return (unsigned int)v4;
}

//----- (10036CA0) --------------------------------------------------------
char __thiscall sub_10036CA0(void *this)
{
  char result; // al@2

  switch ( sub_1002C660(this) )
  {
    case 4:
    case 128:
      result = 1;
      break;
    case 2:
    case 16:
      result = 2;
      break;
    case 32:
      result = 3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (10036D60) --------------------------------------------------------
void __usercall sub_10036D60(unsigned __int16 a1@<bx>, unsigned __int16 *a2@<edi>, int a3, int a4, char a5, int a6)
{
  int v6; // esi@2
  int v7; // eax@3

  if ( a2 )
  {
    v6 = 0;
    if ( *a2 < a1 )
    {
      v7 = (int)a2;
      do
      {
        if ( *(_WORD *)(a6 + 2 * *(_WORD *)v7) < a1 )
          sub_10036C60(
            *(_BYTE *)(v7 + 2),
            (_BYTE *)(a3 + *(_WORD *)(a6 + 2 * *(_WORD *)v7)),
            (_BYTE *)(*(_WORD *)v7 + a4),
            a5);
        v7 = (int)&a2[2 * ++v6];
      }
      while ( a2[2 * v6] < a1 );
    }
  }
}

//----- (10036DC0) --------------------------------------------------------
char __cdecl sub_10036DC0(unsigned __int8 a1)
{
  void *v1; // ecx@0
  char result; // al@2
  bool v3; // zf@3
  void *v4; // [sp-2h] [bp-4h]@1

  v4 = v1;
  BYTE3(v4) = 1;
  if ( sub_1002C5E0(v1) == 2 )
  {
    result = 1;
  }
  else
  {
    v3 = sub_100299D0(a1, (_BYTE *)&v4 + 3) == 1;
    result = 1;
    if ( v3 )
      result = BYTE3(v4);
  }
  return result;
}

//----- (10036E00) --------------------------------------------------------
char __usercall sub_10036E00@<al>(void *a1@<ecx>, int a2@<esi>)
{
  char v2; // bl@1
  char v3; // al@1

  v2 = 0;
  v3 = sub_1002C5E0(a1);
  if ( v3 == 2 || v3 == 4 )
  {
    if ( j_HWM_pvg_read_reg(1) )
    {
      v2 = 1;
      memset((void *)a2, 0, 0x74u);
      *(_DWORD *)(a2 + 108) = 5;
      *(_DWORD *)(a2 + 112) = 15;
    }
  }
  return v2;
}
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10036E40) --------------------------------------------------------
char __cdecl sub_10036E40(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ebp@1
  int v6; // esi@1
  signed int v7; // edi@1
  void *v8; // eax@3
  __int16 v9; // cx@8
  __int16 v10; // cx@11
  __int16 v11; // cx@14
  __int16 v12; // cx@17
  int v13; // esi@23
  signed int v14; // edi@23
  void *v15; // eax@25
  __int16 v16; // cx@30
  __int16 v17; // cx@33
  __int16 v18; // cx@36
  __int16 v19; // cx@39
  void *v20; // ecx@45
  int v21; // eax@45
  char v22; // si@46
  signed int v23; // eax@46
  void *v24; // ecx@46
  int v25; // ST18_4@48
  int v26; // ST10_4@48
  unsigned __int16 *v27; // eax@48
  int v28; // ST18_4@48
  int v29; // ST10_4@48
  unsigned __int16 *v30; // eax@48
  int v31; // ecx@48
  int v32; // ST18_4@49
  int v33; // ST10_4@49
  unsigned __int16 *v34; // eax@49
  int v35; // ST18_4@51
  int v36; // ST10_4@51
  unsigned __int16 *v37; // eax@51
  unsigned __int8 v38; // al@52
  char v39; // bp@52
  signed int v40; // ecx@52
  char v41; // al@53
  int v42; // ST18_4@54
  int v43; // ST10_4@54
  int v44; // ST0C_4@54
  unsigned __int16 *v45; // eax@54
  char v46; // al@55
  int v47; // ST18_4@56
  int v48; // ST10_4@56
  int v49; // ST0C_4@56
  unsigned __int16 *v50; // eax@56
  signed int v51; // ebp@58
  char v52; // di@60
  unsigned __int8 v53; // al@60
  int v54; // ST18_4@60
  char v55; // ST14_1@60
  int v56; // ST10_4@60
  int v57; // ST0C_4@60
  unsigned __int16 *v58; // eax@60
  signed int v59; // edi@66
  void *v60; // ecx@66
  int i; // edi@67
  unsigned __int16 v62; // ax@68
  unsigned __int8 v63; // al@75
  char v64; // al@75
  int v65; // ST18_4@75
  char v66; // ST14_1@75
  int v67; // ST10_4@75
  unsigned __int16 *v68; // eax@75
  char result; // al@75
  char v70; // [sp+13h] [bp-49h]@62
  int v71; // [sp+14h] [bp-48h]@1
  int v72; // [sp+18h] [bp-44h]@1
  int v73; // [sp+1Ch] [bp-40h]@1
  int v74; // [sp+20h] [bp-3Ch]@1
  int v75; // [sp+24h] [bp-38h]@52
  unsigned __int16 v76; // [sp+28h] [bp-34h]@62
  int v77; // [sp+2Ch] [bp-30h]@1
  int v78; // [sp+30h] [bp-2Ch]@52
  int v79; // [sp+34h] [bp-28h]@45
  int v80; // [sp+38h] [bp-24h]@60
  int v81; // [sp+3Ch] [bp-20h]@1
  int v82; // [sp+40h] [bp-1Ch]@1
  int v83; // [sp+44h] [bp-18h]@1
  int v84; // [sp+48h] [bp-14h]@1
  int v85; // [sp+4Ch] [bp-10h]@1
  int v86; // [sp+50h] [bp-Ch]@1

  v5 = a3;
  v73 = a4;
  v74 = a3;
  v72 = a5;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  memset(word_10960718, 0, 0xFA0u);
  v6 = 0;
  v71 = -1;
  v77 = 0;
  v7 = 0;
  do
  {
    if ( sub_10060D80(v7 + 12000, (int)&unk_109616B8, 16004) )
    {
      v6 += 100;
    }
    else
    {
      v8 = &unk_10961742;
      do
      {
        if ( *((char *)v8 - 136) && *(_WORD *)v8 )
        {
          word_10960718[v6] = *(_WORD *)v8;
          v71 = v6;
        }
        if ( *((_BYTE *)v8 + 24) )
        {
          v9 = *((_WORD *)v8 + 80);
          if ( v9 )
          {
            word_1096071A[v6] = v9;
            v71 = v6 + 1;
          }
        }
        if ( *((_BYTE *)v8 + 184) )
        {
          v10 = *((_WORD *)v8 + 160);
          if ( v10 )
          {
            word_1096071C[v6] = v10;
            v71 = v6 + 2;
          }
        }
        if ( *((_BYTE *)v8 + 344) )
        {
          v11 = *((_WORD *)v8 + 240);
          if ( v11 )
          {
            word_1096071E[v6] = v11;
            v71 = v6 + 3;
          }
        }
        if ( *((_BYTE *)v8 + 504) )
        {
          v12 = *((_WORD *)v8 + 320);
          if ( v12 )
          {
            word_10960720[v6] = v12;
            v71 = v6 + 4;
          }
        }
        v8 = (char *)v8 + 800;
        v6 += 5;
      }
      while ( (signed int)v8 < (signed int)&unk_109655C2 );
    }
    ++v7;
  }
  while ( v7 < 10 );
  v13 = 0;
  v14 = 0;
  do
  {
    if ( sub_10060D80(v14 + 14000, (int)&unk_109616B8, 16004) )
    {
      v13 += 100;
    }
    else
    {
      v15 = &unk_10961742;
      do
      {
        if ( *((char *)v15 - 136) && *(_WORD *)v15 )
        {
          word_10960EE8[v13] = *(_WORD *)v15;
          v71 = v13 + 1000;
        }
        if ( *((_BYTE *)v15 + 24) )
        {
          v16 = *((_WORD *)v15 + 80);
          if ( v16 )
          {
            word_10960EEA[v13] = v16;
            v71 = v13 + 1001;
          }
        }
        if ( *((_BYTE *)v15 + 184) )
        {
          v17 = *((_WORD *)v15 + 160);
          if ( v17 )
          {
            word_10960EEC[v13] = v17;
            v71 = v13 + 1002;
          }
        }
        if ( *((_BYTE *)v15 + 344) )
        {
          v18 = *((_WORD *)v15 + 240);
          if ( v18 )
          {
            word_10960EEE[v13] = v18;
            v71 = v13 + 1003;
          }
        }
        if ( *((_BYTE *)v15 + 504) )
        {
          v19 = *((_WORD *)v15 + 320);
          if ( v19 )
          {
            word_10960EF0[v13] = v19;
            v71 = v13 + 1004;
          }
        }
        v15 = (char *)v15 + 800;
        v13 += 5;
      }
      while ( (signed int)v15 < (signed int)&unk_109655C2 );
    }
    ++v14;
  }
  while ( v14 < 10 );
  sub_10038790((int)&v77);
  v21 = sub_1002C660(v20);
  v77 |= v21;
  LOBYTE(v79) = 0;
  do
  {
    v22 = v79;
    v23 = sub_1002D710(v79);
    if ( v23 & v77 || sub_1002C5E0(v24) == 4 )
    {
      v25 = v72;
      v26 = v73;
      v27 = (unsigned __int16 *)sub_10051850(v22, a1);
      sub_10036D60(a2, v27, v5, v26, 1, v25);
      v28 = v72;
      v29 = v73;
      v30 = (unsigned __int16 *)sub_10051A30(*(_BYTE *)dword_10A09AC0, v22, a1);
      sub_10036D60(a2, v30, v5, v29, 1, v28);
      if ( (unsigned __int8)sub_10051C70(v31) )
      {
        v32 = v72;
        v33 = v73;
        v34 = (unsigned __int16 *)sub_100517D0(v22, a1);
        sub_10036D60(a2, v34, v5, v33, 1, v32);
      }
      if ( sub_10051C60() )
      {
        v35 = v72;
        v36 = v73;
        v37 = (unsigned __int16 *)sub_100518D0(v22, a1);
        sub_10036D60(a2, v37, v5, v36, 1, v35);
      }
      v38 = sub_1002D630(v22);
      LOBYTE(v75) = sub_10036DC0(v38);
      sub_100386C0(v22, (int)&v81);
      v39 = v75;
      v40 = 0;
      v78 = 0;
      do
      {
        v41 = *((_BYTE *)&v84 + 4 * v40);
        if ( v41 )
        {
          v42 = v72;
          v43 = v73;
          v44 = v74;
          v45 = (unsigned __int16 *)sub_10051B90(v22, v41, a1);
          sub_10036D60(a2, v45, v44, v43, v39, v42);
          v40 = v78;
        }
        v46 = *((_BYTE *)&v84 + 4 * v40 + 1);
        if ( v46 )
        {
          v47 = v72;
          v48 = v73;
          v49 = v74;
          v50 = (unsigned __int16 *)sub_10051B90(v22, v46, a1);
          sub_10036D60(a2, v50, v49, v48, v39, v47);
          v40 = v78;
        }
        v78 = ++v40;
      }
      while ( v40 <= 1 );
      v51 = 0;
      do
      {
        if ( *((_BYTE *)&v82 + 4 * v51 + 1) )
        {
          LOBYTE(v80) = *((_BYTE *)&v82 + 4 * v51 + 1);
          v52 = v80;
          v53 = sub_1002DB10(v80);
          LOBYTE(v75) = sub_10036DC0(v53);
          v54 = v72;
          v55 = v75;
          v56 = v73;
          v57 = v74;
          v58 = (unsigned __int16 *)sub_10051AF0(v22, v52, a1);
          sub_10036D60(a2, v58, v57, v56, v55, v54);
        }
        ++v51;
      }
      while ( v51 < 2 );
      if ( sub_10051430(HIWORD(v86), 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
        *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
      v59 = sub_1002D710(v22);
      if ( sub_1002C660(v60) == v59 )
      {
        for ( i = 0; i <= v71; ++i )
        {
          v62 = word_10960718[i];
          if ( v62 && sub_10051490(v62, 0, &v70, &v76) == 1 && v70 == a1 && v76 < a2 )
            *(_BYTE *)(*(_WORD *)(v72 + 2 * v76) + v74) = v75;
        }
      }
      v5 = v74;
    }
    v63 = sub_1002D630(v22);
    v64 = sub_10036DC0(v63);
    v65 = v72;
    LOBYTE(v75) = v64;
    v66 = v64;
    v67 = v73;
    v68 = (unsigned __int16 *)sub_10051950(v22, a1);
    sub_10036D60(a2, v68, v5, v67, v66, v65);
    result = v79 + 1;
    LOBYTE(v79) = v79 + 1;
  }
  while ( (unsigned __int8)v79 < 3u );
  return result;
}
// 10960718: using guessed type __int16 word_10960718[];
// 1096071A: using guessed type __int16 word_1096071A[];
// 1096071C: using guessed type __int16 word_1096071C[];
// 1096071E: using guessed type __int16 word_1096071E[];
// 10960720: using guessed type __int16 word_10960720[];
// 10960EE8: using guessed type __int16 word_10960EE8[];
// 10960EEA: using guessed type __int16 word_10960EEA[];
// 10960EEC: using guessed type __int16 word_10960EEC[];
// 10960EEE: using guessed type __int16 word_10960EEE[];
// 10960EF0: using guessed type __int16 word_10960EF0[];
// 10A09AC0: using guessed type int dword_10A09AC0;

//----- (100373C0) --------------------------------------------------------
void __cdecl sub_100373C0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // ST0C_1@2
  int *v6; // eax@2
  int v7; // [sp+0h] [bp-8h]@1
  int v8; // [sp+4h] [bp-4h]@1

  LOBYTE(v8) = sub_10036DC0(0x1Fu);
  sub_10038790((int)&v7);
  if ( v7 & 0x8000 )
  {
    v5 = v8;
    v6 = sub_10051F80(a1);
    sub_10036D60(a2, (unsigned __int16 *)v6, a3, a4, v5, a5);
  }
}

//----- (10037420) --------------------------------------------------------
void __cdecl sub_10037420(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@0
  char v6; // ST0C_1@2
  unsigned __int16 *v7; // eax@2

  if ( sub_100336A0(v5) )
  {
    v6 = sub_10036DC0(0x11u);
    v7 = (unsigned __int16 *)sub_10051CA0(a1);
    sub_10036D60(a2, v7, a3, a4, v6, a5);
  }
}

//----- (10037470) --------------------------------------------------------
void __cdecl sub_10037470(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  int v10; // [sp+0h] [bp-4h]@1

  v10 = v5;
  sub_10038790((int)&v10);
  if ( v10 & 0x1000000 || sub_1002C5E0(v6) == 4 )
  {
    v7 = sub_10036DC0(0x32u) && sub_10036DC0(0x3Eu);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_10051FE0(a1);
    sub_10036D60(a2, v9, a3, a4, v8, a5);
  }
}

//----- (100374F0) --------------------------------------------------------
char __cdecl sub_100374F0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  char v6; // bp@3
  signed int v7; // eax@3
  void *v8; // ecx@3
  unsigned __int8 v9; // al@6
  char v10; // ST18_1@6
  int v11; // ST14_4@6
  unsigned __int16 *v12; // eax@6
  int v13; // ecx@6
  char v14; // ST18_1@7
  int v15; // ST14_4@7
  unsigned __int16 *v16; // eax@7
  char v17; // ST18_1@7
  int v18; // ST14_4@7
  unsigned __int16 *v19; // eax@7
  int v20; // eax@8
  void *v21; // ecx@8
  char v22; // al@9
  char v23; // al@12
  char v24; // ST18_1@14
  int v25; // ST14_4@14
  unsigned __int16 *v26; // eax@14
  unsigned __int16 *v27; // eax@17
  char v28; // al@22
  char v29; // ST18_1@24
  int v30; // ST14_4@24
  unsigned __int16 *v31; // eax@24
  char v32; // ST18_1@25
  int v33; // ST14_4@25
  unsigned __int16 *v34; // eax@25
  signed int v35; // ecx@25
  unsigned __int8 v36; // al@26
  char v37; // ST18_1@27
  int v38; // ST14_4@27
  unsigned __int16 *v39; // eax@27
  signed int v40; // eax@29
  char v41; // ST18_1@31
  int v42; // ST14_4@31
  unsigned __int16 *v43; // eax@31
  unsigned __int16 *v44; // edi@33
  unsigned __int16 *v45; // edi@39
  __int16 *v46; // ecx@45
  char v47; // ST18_1@48
  int v48; // ST14_4@48
  unsigned __int16 *v49; // eax@48
  unsigned __int8 v50; // al@49
  char v51; // ST18_1@52
  int v52; // ST14_4@52
  unsigned __int16 *v53; // eax@52
  __int16 *v54; // eax@55
  int v55; // edi@55
  bool v56; // cf@55
  int v57; // eax@57
  _BYTE *v58; // esi@61
  unsigned __int8 v59; // di@62
  unsigned __int8 v60; // al@62
  char v61; // ST18_1@62
  int v62; // ST14_4@62
  int v63; // ST10_4@62
  unsigned __int16 *v64; // eax@62
  _BYTE *v65; // esi@63
  unsigned __int8 v66; // di@64
  unsigned __int8 v67; // al@64
  char v68; // ST18_1@64
  int v69; // ST14_4@64
  int v70; // ST10_4@64
  unsigned __int16 *v71; // eax@64
  unsigned __int8 v72; // di@65
  unsigned __int8 v73; // al@65
  char v74; // ST18_1@65
  int v75; // ST14_4@65
  int v76; // ST10_4@65
  unsigned __int16 *v77; // eax@65
  char *v78; // eax@67
  unsigned __int8 v79; // di@68
  unsigned __int8 v80; // al@68
  char v81; // al@68
  int v82; // esi@72
  char v83; // ST18_1@72
  int v84; // ST14_4@72
  int v85; // ST10_4@72
  unsigned __int16 *v86; // eax@72
  unsigned __int8 v87; // di@73
  unsigned __int8 v88; // al@73
  char v89; // al@73
  char v90; // ST18_1@77
  int v91; // ST14_4@77
  unsigned __int16 *v92; // eax@77
  char result; // al@79
  int v94; // [sp-10h] [bp-D8h]@17
  int v95; // [sp-Ch] [bp-D4h]@17
  char v96; // [sp-8h] [bp-D0h]@17
  int v97; // [sp-4h] [bp-CCh]@17
  char v98; // [sp+17h] [bp-B1h]@1
  int v99; // [sp+18h] [bp-B0h]@12
  int v100; // [sp+1Ch] [bp-ACh]@6
  int v101; // [sp+20h] [bp-A8h]@1
  int v102; // [sp+24h] [bp-A4h]@25
  __int16 *v103; // [sp+28h] [bp-A0h]@45
  int v104; // [sp+2Ch] [bp-9Ch]@1
  int v105; // [sp+30h] [bp-98h]@1
  unsigned int v106; // [sp+34h] [bp-94h]@68
  unsigned int v107; // [sp+38h] [bp-90h]@64
  unsigned __int8 *v108; // [sp+3Ch] [bp-8Ch]@1
  unsigned __int16 v109[2]; // [sp+40h] [bp-88h]@56
  int v110; // [sp+44h] [bp-84h]@1
  int v111; // [sp+48h] [bp-80h]@1
  unsigned int v112; // [sp+4Ch] [bp-7Ch]@62
  char v113; // [sp+50h] [bp-78h]@1
  unsigned int v114; // [sp+BCh] [bp-Ch]@16
  char v115; // [sp+C0h] [bp-8h]@10

  v5 = a3;
  v101 = a4;
  v104 = a3;
  v98 = 0;
  v111 = 0;
  v105 = 0;
  memset(&v113, 0, 0x74u);
  sub_10038790((int)&v111);
  LOBYTE(v110) = 0;
  v108 = (unsigned __int8 *)":#;<";
  while ( 1 )
  {
    v6 = v110;
    v7 = sub_10031B80(v110);
    if ( !(v7 & v111) )
    {
      if ( sub_1002C5E0(v8) != 4 )
        goto LABEL_79;
      v5 = v104;
    }
    v9 = sub_10031B40(v6);
    LOBYTE(v100) = sub_10036DC0(v9);
    memset(byte_1095FC78, 0, 0xAA0u);
    sub_100386E0(v6, (int)byte_1095FC78);
    v10 = v100;
    v11 = v101;
    v12 = (unsigned __int16 *)sub_10052740(v6, a1);
    sub_10036D60(a2, v12, v5, v11, v10, a5);
    if ( (unsigned __int8)sub_10051C70(v13) )
    {
      v14 = v100;
      v15 = v101;
      v16 = (unsigned __int16 *)sub_10052B50(v6, a1);
      sub_10036D60(a2, v16, v5, v15, v14, a5);
      v17 = v100;
      v18 = v101;
      v19 = (unsigned __int16 *)sub_10052B30(v6, a1);
      sub_10036D60(a2, v19, v5, v18, v17, a5);
    }
    LOBYTE(v20) = sub_10031BC0(v6);
    if ( sub_10031310(v20, &v113) || (v22 = sub_10036E00(v21, (int)&v113), v5 = v104, v22) )
    {
      if ( v115 & 1 )
      {
        if ( !(_BYTE)v100 || (v23 = sub_10036DC0(*(v108 - 1)), LOBYTE(v99) = 1, !v23) )
          LOBYTE(v99) = 0;
        v24 = v99;
        v25 = v101;
        v26 = (unsigned __int16 *)sub_10052620(v6, a1);
        sub_10036D60(a2, v26, v5, v25, v24, a5);
      }
      if ( v115 & 2 )
      {
        if ( v114 >= 3 )
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_10052A00(v6, a1);
        }
        else
        {
          v97 = a5;
          v96 = v100;
          v95 = v101;
          v94 = v5;
          v27 = (unsigned __int16 *)sub_100526B0(v6, a1);
        }
        sub_10036D60(a2, v27, v94, v95, v96, v97);
      }
      if ( v115 & 8 )
      {
        if ( !(_BYTE)v100 || (v28 = sub_10036DC0(*v108), LOBYTE(v99) = 1, !v28) )
          LOBYTE(v99) = 0;
        v29 = v99;
        v30 = v101;
        v31 = (unsigned __int16 *)sub_10052970(v6, a1);
        sub_10036D60(a2, v31, v5, v30, v29, a5);
      }
    }
    v32 = v100;
    v33 = v101;
    v34 = (unsigned __int16 *)sub_10052550(v6, byte_10960144, a1);
    sub_10036D60(a2, v34, v5, v33, v32, a5);
    v102 = 0;
    v35 = 0;
    do
    {
      v36 = byte_1095FC78[v35];
      if ( v36 )
      {
        v37 = v100;
        v38 = v101;
        v39 = (unsigned __int16 *)sub_10052110(v6, v102, v36, a1);
        sub_10036D60(a2, v39, v5, v38, v37, a5);
        v35 = v102;
      }
      v102 = ++v35;
    }
    while ( v35 < 10 );
    v40 = 0;
    v102 = 0;
    do
    {
      if ( byte_1095FC82[v40] == 1 )
      {
        v41 = v100;
        v42 = v101;
        v43 = (unsigned __int16 *)sub_100523B0(v6, v102, a1);
        sub_10036D60(a2, v43, v5, v42, v41, a5);
        v40 = v102;
      }
      v102 = ++v40;
    }
    while ( v40 < 11 );
    v44 = (unsigned __int16 *)&unk_1095FCBE;
    do
    {
      if ( sub_10051430(*v44, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v44 += 6;
    }
    while ( (signed int)v44 < (signed int)&unk_1095FEAA );
    v45 = (unsigned __int16 *)&unk_1095FEAA;
    do
    {
      if ( sub_10051490(*v45, v6, &v98, &v105) == 1 && v98 == a1 && (unsigned __int16)v105 < a2 )
        *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
      v45 += 2;
    }
    while ( (signed int)v45 < (signed int)&unk_1095FF52 );
    v46 = (__int16 *)&unk_1095FF98;
    v102 = 0;
    v103 = (__int16 *)&unk_1095FF98;
    do
    {
      if ( *(_BYTE *)v46 == 3 )
      {
        LOWORD(v102) = v46[1] | v102;
      }
      else
      {
        v47 = v100;
        v48 = v101;
        v49 = (unsigned __int16 *)sub_10052480(v6, *(_BYTE *)v46, a1);
        sub_10036D60(a2, v49, v5, v48, v47, a5);
        v46 = v103;
      }
      v50 = *((_BYTE *)v46 + 1);
      if ( v50 != *(_BYTE *)v46 )
      {
        if ( v50 == 3 )
        {
          LOWORD(v102) = v46[1] | v102;
        }
        else
        {
          v51 = v100;
          v52 = v101;
          v53 = (unsigned __int16 *)sub_10052480(v6, v50, a1);
          sub_10036D60(a2, v53, v5, v52, v51, a5);
          v46 = v103;
        }
      }
      v46 += 8;
      v103 = v46;
    }
    while ( (signed int)v46 < (signed int)&unk_1095FFB8 );
    if ( (_WORD)v102 )
    {
      v54 = (__int16 *)sub_10052480(v6, 3u, a1);
      v55 = 0;
      v56 = (unsigned __int16)*v54 < a2;
      v103 = v54;
      if ( v56 )
      {
        do
        {
          v105 = (unsigned __int16)*v54;
          if ( !sub_10052BD0(a1, *v54, v109)
            || (v57 = sub_1002CC90((_DWORD *)v109, 2u, (int)"<", 4, 12, 12), v57 >= 12)
            || ((unsigned __int16)v102 & (unsigned __int16)word_100C442E[2 * v57]) != 0 )
          {
            *(_BYTE *)(*(_WORD *)(a5 + 2 * (unsigned __int16)v105) + v5) = v100;
          }
          v54 = &v103[2 * ++v55];
        }
        while ( (unsigned __int16)v103[2 * v55] < a2 );
      }
    }
    v58 = &unk_1095FC91;
    do
    {
      LOBYTE(v112) = *v58;
      v59 = v112;
      v60 = sub_10031CD0(v112);
      LOBYTE(v99) = sub_10036DC0(v60);
      v61 = v99;
      v62 = v101;
      v63 = v104;
      v64 = (unsigned __int16 *)sub_10052040(v6, v59, a1);
      sub_10036D60(a2, v64, v63, v62, v61, a5);
      v58 += 4;
    }
    while ( (signed int)v58 <= (signed int)&unk_1095FCB9 );
    v65 = &unk_1095FF51;
    do
    {
      LOBYTE(v107) = *(v65 - 1);
      v66 = v107;
      v67 = sub_10031D00(v107);
      LOBYTE(v99) = sub_10036DC0(v67);
      v68 = v99;
      v69 = v101;
      v70 = v104;
      v71 = (unsigned __int16 *)sub_100527D0(v6, v66, a1);
      sub_10036D60(a2, v71, v70, v69, v68, a5);
      if ( (_BYTE)v107 != *v65 )
      {
        LOBYTE(v107) = *v65;
        v72 = v107;
        v73 = sub_10031D00(v107);
        LOBYTE(v99) = sub_10036DC0(v73);
        v74 = v99;
        v75 = v101;
        v76 = v104;
        v77 = (unsigned __int16 *)sub_100527D0(v6, v72, a1);
        sub_10036D60(a2, v77, v76, v75, v74, a5);
      }
      v65 += 4;
    }
    while ( (signed int)v65 < (signed int)&unk_1095FF71 );
    v78 = (char *)&unk_1095FF71;
    v103 = (__int16 *)&unk_1095FF71;
    do
    {
      LOBYTE(v106) = *(v78 - 1);
      v79 = v106;
      v80 = sub_10031D30(v106);
      v81 = sub_10036DC0(v80);
      LOBYTE(v99) = v81;
      if ( (_BYTE)v106 == 4 )
      {
        if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v81) )
          LOBYTE(v99) = 0;
      }
      v82 = v104;
      v83 = v99;
      v84 = v101;
      v85 = v104;
      v86 = (unsigned __int16 *)sub_100528A0(v6, v79, a1);
      sub_10036D60(a2, v86, v85, v84, v83, a5);
      if ( (_BYTE)v106 != *(_BYTE *)v103 )
      {
        LOBYTE(v106) = *(_BYTE *)v103;
        v87 = v106;
        v88 = sub_10031D30(v106);
        v89 = sub_10036DC0(v88);
        LOBYTE(v99) = v89;
        if ( (_BYTE)v106 == 4 )
        {
          if ( !(_BYTE)v100 || (LOBYTE(v99) = 1, !v89) )
            LOBYTE(v99) = 0;
        }
        v90 = v99;
        v91 = v101;
        v92 = (unsigned __int16 *)sub_100528A0(v6, v87, a1);
        sub_10036D60(a2, v92, v82, v91, v90, a5);
      }
      v78 = (char *)(v103 + 4);
      v103 += 4;
    }
    while ( (signed int)v103 < (signed int)&unk_1095FF99 );
LABEL_79:
    v108 += 2;
    result = v110 + 1;
    LOBYTE(v110) = v110 + 1;
    if ( (unsigned __int8)v110 >= 2u )
      return result;
    v5 = v104;
  }
}
// 100C442E: using guessed type __int16 word_100C442E[];
// 10960144: using guessed type char byte_10960144;

//----- (10037CA0) --------------------------------------------------------
void __cdecl sub_10037CA0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  void *v6; // ecx@2
  bool v7; // al@5
  char v8; // ST0C_1@7
  unsigned __int16 *v9; // eax@7
  bool v10; // al@12
  char v11; // ST0C_1@14
  unsigned __int16 *v12; // eax@14
  int v13; // [sp+10h] [bp-4h]@1

  sub_10038790((int)&v13);
  if ( v13 & 0x10000 || sub_1002C5E0(v5) == 4 )
  {
    v7 = sub_10036DC0(0x24u) && sub_10036DC0(0x3Cu);
    v8 = v7;
    v9 = (unsigned __int16 *)sub_10052C30(a1);
    sub_10036D60(a2, v9, a3, a4, v8, a5);
  }
  if ( v13 & 0x20000 || sub_1002C5E0(v6) == 4 )
  {
    v10 = sub_10036DC0(0x25u) && sub_10036DC0(0x3Du);
    v11 = v10;
    v12 = (unsigned __int16 *)sub_10052C30(a1);
    sub_10036D60(a2, v12, a3, a4, v11, a5);
  }
}

//----- (10037D80) --------------------------------------------------------
char __cdecl sub_10037D80(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // eax@2
  void *v6; // ecx@2
  unsigned __int8 v7; // al@4
  char v8; // ST10_1@4
  unsigned __int16 *v9; // eax@4
  char result; // al@5
  unsigned __int8 v11; // [sp+10h] [bp-8h]@1
  int v12; // [sp+14h] [bp-4h]@1

  sub_10038790((int)&v12);
  v11 = 0;
  do
  {
    v5 = sub_10052D10(v11);
    if ( v5 & v12 || sub_1002C5E0(v6) == 4 )
    {
      v7 = sub_10043F20(v11);
      v8 = sub_10036DC0(v7);
      v9 = (unsigned __int16 *)sub_10052C90(v11, a1);
      sub_10036D60(a2, v9, a3, a4, v8, a5);
    }
    result = v11++ + 1;
  }
  while ( v11 < 2u );
  return result;
}

//----- (10037E10) --------------------------------------------------------
char __cdecl sub_10037E10(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  char v5; // si@2
  signed int v6; // eax@2
  unsigned __int8 v7; // al@3
  char v8; // ST14_1@3
  unsigned __int16 *v9; // eax@3
  int v10; // ecx@3
  char v11; // ST14_1@4
  unsigned __int16 *v12; // eax@4
  unsigned __int16 *v13; // edi@5
  unsigned __int16 *v14; // eax@12
  unsigned __int16 *v15; // eax@14
  unsigned __int8 v16; // al@14
  unsigned __int16 *v17; // eax@15
  char result; // al@17
  char v19; // [sp+13h] [bp-1Dh]@6
  unsigned __int16 v20; // [sp+14h] [bp-1Ch]@6
  int v21; // [sp+18h] [bp-18h]@14
  unsigned __int8 *v22; // [sp+1Ch] [bp-14h]@11
  int v23; // [sp+20h] [bp-10h]@3
  int v24; // [sp+24h] [bp-Ch]@1
  int v25; // [sp+28h] [bp-8h]@1
  int v26; // [sp+2Ch] [bp-4h]@12

  sub_10038790((int)&v25);
  LOBYTE(v24) = 0;
  do
  {
    v5 = v24;
    v6 = sub_10031A50(v24);
    if ( v6 & v25 )
    {
      memset(&unk_10965540, 0, 0x890u);
      sub_10038760(v5, (int)&unk_10965540);
      v7 = sub_10031A10(v5);
      LOBYTE(v23) = sub_10036DC0(v7);
      v8 = v23;
      v9 = (unsigned __int16 *)sub_10052E00(v5, a1);
      sub_10036D60(a2, v9, a3, a4, v8, a5);
      if ( (unsigned __int8)sub_10051C70(v10) )
      {
        v11 = v23;
        v12 = (unsigned __int16 *)sub_10053000(v5, a1);
        sub_10036D60(a2, v12, a3, a4, v11, a5);
      }
      v13 = (unsigned __int16 *)&unk_109655E2;
      do
      {
        if ( sub_10051430(*v13, v5, &v19, &v20) == 1 && v19 == a1 && v20 < a2 )
          *(_BYTE *)(*(_WORD *)(a5 + 2 * v20) + a3) = v23;
        v13 += 8;
      }
      while ( (signed int)v13 < (signed int)&unk_109658B2 );
      v22 = (unsigned __int8 *)&unk_10965541;
      do
      {
        LOBYTE(v26) = *v22;
        v14 = (unsigned __int16 *)sub_10052D30(v5, v26, a1);
        sub_10036D60(a2, v14, a3, a4, 1, a5);
        v22 += 4;
      }
      while ( (signed int)v22 <= (signed int)&unk_109655DD );
      v22 = (unsigned __int8 *)&unk_109658B1;
      do
      {
        LOBYTE(v21) = *(v22 - 1);
        v15 = (unsigned __int16 *)sub_10052E90(v5, v21, a1);
        sub_10036D60(a2, v15, a3, a4, 1, a5);
        v16 = *v22;
        if ( (_BYTE)v21 != *v22 )
        {
          LOBYTE(v21) = *v22;
          v17 = (unsigned __int16 *)sub_10052E90(v5, v16, a1);
          sub_10036D60(a2, v17, a3, a4, 1, a5);
        }
        v22 += 8;
      }
      while ( (signed int)v22 < (signed int)&unk_10965931 );
    }
    result = v24 + 1;
    LOBYTE(v24) = v24 + 1;
  }
  while ( (unsigned __int8)v24 < 3u );
  return result;
}

//----- (10038020) --------------------------------------------------------
char __cdecl sub_10038020(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  void *v5; // ecx@1
  int v6; // eax@1
  void *v7; // ecx@1
  signed int v8; // eax@2
  void *v9; // ecx@2
  void *v10; // ecx@3
  unsigned __int8 v11; // al@4
  unsigned __int16 *v12; // eax@4
  char v13; // ST10_1@4
  unsigned __int16 *v14; // eax@4
  __int16 *v15; // eax@4
  int v16; // ecx@4
  unsigned __int16 *v17; // eax@5
  unsigned __int16 *v18; // eax@7
  int v19; // eax@9
  char v21; // [sp+13h] [bp-Dh]@1
  char v22; // [sp+14h] [bp-Ch]@1
  int v23; // [sp+18h] [bp-8h]@1
  int v24; // [sp+1Ch] [bp-4h]@4

  sub_10038790((int)&v23);
  v6 = sub_1002C660(v5);
  v23 |= v6;
  v21 = sub_1002C5E0(v7);
  v22 = 3;
  do
  {
    v8 = sub_1002D710(v22);
    if ( v8 & v23 || sub_1002C5E0(v9) == 4 )
    {
      v11 = sub_1002D630(v22);
      LOBYTE(v24) = sub_10036DC0(v11);
      v12 = (unsigned __int16 *)sub_10053080(a1);
      sub_10036D60(a2, v12, a3, a4, 1, a5);
      v13 = v24;
      v14 = (unsigned __int16 *)sub_10053140(v22, a1);
      sub_10036D60(a2, v14, a3, a4, v13, a5);
      v15 = sub_10051560(a1, a2);
      sub_10036D60(a2, (unsigned __int16 *)v15, a3, a4, 1, a5);
      if ( (unsigned __int8)sub_10051C70(v16) )
      {
        v17 = (unsigned __int16 *)sub_10053020(a1);
        sub_10036D60(a2, v17, a3, a4, 1, a5);
      }
      if ( sub_10051C60() )
      {
        v18 = (unsigned __int16 *)sub_100530E0(a1);
        sub_10036D60(a2, v18, a3, a4, 1, a5);
      }
    }
    ++v22;
  }
  while ( (unsigned __int8)v22 < 7u );
  LOBYTE(v19) = v21;
  if ( v21 == 2 || v21 == 8 )
  {
    LOBYTE(v19) = a1;
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        LOBYTE(v19) = sub_1002C660(v10);
        if ( v19 & 0xF0 )
        {
          *(_BYTE *)(*(_WORD *)(a5 + 492) + a3) = 1;
          *(_BYTE *)(*(_WORD *)(a5 + 496) + a3) = 1;
          v19 = *(_WORD *)(a5 + 494);
          *(_BYTE *)(v19 + a3) = 1;
        }
      }
    }
    else
    {
      *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = 1;
      *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = 1;
      v19 = *(_WORD *)(a5 + 1180);
      *(_BYTE *)(v19 + a3) = 1;
    }
  }
  else if ( !a1 )
  {
    *(_BYTE *)(*(_WORD *)(a5 + 980) + a3) = sub_10036DC0(0x28u);
    *(_BYTE *)(*(_WORD *)(a5 + 982) + a3) = sub_10036DC0(0x29u);
    *(_BYTE *)(*(_WORD *)(a5 + 1178) + a3) = sub_10036DC0(0x33u);
    LOBYTE(v19) = sub_10036DC0(0x34u);
    *(_BYTE *)(*(_WORD *)(a5 + 1180) + a3) = v19;
  }
  return v19;
}

//----- (10038240) --------------------------------------------------------
void __cdecl sub_10038240(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_10038790((int)&v9);
  if ( v9 & 0x4000 || sub_1002C5E0(v6) == 4 )
  {
    v7 = sub_10036DC0(0x20u);
    v8 = (unsigned __int16 *)sub_100531E0(a1);
    sub_10036D60(a2, v8, a3, a4, v7, a5);
  }
}

//----- (100382A0) --------------------------------------------------------
void __cdecl sub_100382A0(char a1, unsigned __int16 a2, int a3, int a4, int a5)
{
  int v5; // ecx@0
  void *v6; // ecx@1
  char v7; // ST0C_1@3
  unsigned __int16 *v8; // eax@3
  int v9; // [sp+0h] [bp-4h]@1

  v9 = v5;
  sub_10038790((int)&v9);
  if ( v9 & 0x400 || sub_1002C5E0(v6) == 4 )
  {
    v7 = sub_10036DC0(0x13u);
    v8 = (unsigned __int16 *)sub_10053240(a1);
    sub_10036D60(a2, v8, a3, a4, v7, a5);
  }
}

//----- (10038300) --------------------------------------------------------
char __cdecl sub_10038300(int a1, void *a2)
{
  int v2; // ecx@3
  char result; // al@4
  int v4; // ecx@5
  int v5; // eax@5
  bool v6; // zf@9

  if ( a1 && a2 )
  {
    v2 = *(_DWORD *)(a1 + 20);
    if ( v2 >= 0 )
    {
      memcpy_0(a2, (const void *)(*(_DWORD *)(a1 + 4) + v2 * *(_DWORD *)(a1 + 12)), *(_DWORD *)(a1 + 12));
      v4 = *(_DWORD *)(a1 + 8);
      v5 = *(_DWORD *)(a1 + 20) + 1;
      if ( v5 < v4 )
      {
        if ( v5 < 0 )
          v5 += v4;
      }
      else
      {
        v5 -= v4;
      }
      v6 = v5 == *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 20) = v5;
      if ( v6 )
        *(_DWORD *)(a1 + 20) = -1;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10038370) --------------------------------------------------------
int __cdecl sub_10038370(int a1)
{
  int result; // eax@2
  int v2; // edx@3
  int v3; // ecx@4

  if ( a1 && (v2 = *(_DWORD *)(a1 + 20), v2 >= 0) )
  {
    v3 = *(_DWORD *)(a1 + 16);
    if ( v3 <= v2 )
      result = v3 + *(_DWORD *)(a1 + 8) - v2;
    else
      result = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100383A0) --------------------------------------------------------
char __cdecl sub_100383A0(int a1, void *a2)
{
  int v2; // eax@3
  int v3; // edx@3
  int v4; // ecx@5
  int v5; // eax@5
  int v6; // ecx@12
  int v7; // eax@12
  char result; // al@13

  if ( a1 && a2 )
  {
    v2 = *(_DWORD *)(a1 + 20);
    v3 = *(_DWORD *)(a1 + 16);
    if ( v2 == v3 )
    {
      if ( !(*(_BYTE *)a1 & 1) )
        return 0;
      v4 = *(_DWORD *)(a1 + 8);
      v5 = v2 + 1;
      if ( v5 < v4 )
      {
        if ( v5 < 0 )
          v5 += v4;
      }
      else
      {
        v5 -= v4;
      }
      *(_DWORD *)(a1 + 20) = v5;
    }
    if ( *(_DWORD *)(a1 + 20) < 0 )
      *(_DWORD *)(a1 + 20) = v3;
    memcpy_0((void *)(*(_DWORD *)(a1 + 4) + v3 * *(_DWORD *)(a1 + 12)), a2, *(_DWORD *)(a1 + 12));
    v6 = *(_DWORD *)(a1 + 8);
    v7 = *(_DWORD *)(a1 + 16) + 1;
    if ( v7 < v6 )
    {
      if ( v7 < 0 )
        v7 += v6;
      *(_DWORD *)(a1 + 16) = v7;
      result = 1;
    }
    else
    {
      *(_DWORD *)(a1 + 16) = v7 - v6;
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10038430) --------------------------------------------------------
int __cdecl sub_10038430(__int16 a1, char a2, char a3, char a4)
{
  __int16 v5; // [sp+0h] [bp-10h]@1
  __int16 v6; // [sp+4h] [bp-Ch]@1
  char v7; // [sp+6h] [bp-Ah]@1
  char v8; // [sp+7h] [bp-9h]@1
  char v9; // [sp+8h] [bp-8h]@1

  v7 = a2;
  v6 = a1;
  v5 = -32768;
  v9 = a3;
  v8 = a4;
  return sub_10060AC0(7, (int)&v5, 20, 1);
}

//----- (10038470) --------------------------------------------------------
char __cdecl sub_10038470(char a1)
{
  char result; // al@2

  switch ( a1 )
  {
    case 0xC:
    case 0x3F:
      result = 0;
      break;
    case 0xD:
    case 0x40:
      result = 1;
      break;
    case 0xE:
    case 0x41:
      result = 2;
      break;
    case 0x2A:
    case 0x42:
      result = 3;
      break;
    default:
      sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_utl.c", 139, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10038510) --------------------------------------------------------
signed int __cdecl sub_10038510(char a1, char a2)
{
  _DWORD *v2; // esi@3
  int v3; // eax@5
  char *v5; // [sp-18h] [bp-20h]@3
  void *v6; // [sp-10h] [bp-18h]@3
  int v7; // [sp-8h] [bp-10h]@3

  if ( a2 == 11 )
  {
    v7 = 3;
    v2 = &unk_100C4F58;
    v6 = &unk_100C4F58;
    v5 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v7 = 7;
    v2 = &unk_100C4F70;
    v6 = &unk_100C4F70;
    v5 = &a1;
  }
  v3 = sub_1002CC90(v5, 1u, (int)v6, 8, v7, 7);
  if ( v3 < 7 )
    return v2[2 * v3 + 1];
  return 42066;
}

//----- (10038570) --------------------------------------------------------
int __cdecl sub_10038570(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1002CC90(&a1, 1u, (int)&unk_100C4FB8, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100C4FBC[2 * v1];
  return result;
}
// 100C4FBC: using guessed type int dword_100C4FBC[];

//----- (100385B0) --------------------------------------------------------
signed int __cdecl sub_100385B0(char a1, char a2, char a3)
{
  _DWORD *v3; // esi@3
  int v4; // eax@5
  signed int result; // eax@7
  char *v6; // [sp-18h] [bp-20h]@3
  void *v7; // [sp-10h] [bp-18h]@3

  if ( a2 == 11 )
  {
    v3 = &unk_100C4FC8;
    v7 = &unk_100C4FC8;
    v6 = &a1;
  }
  else
  {
    if ( a2 != 16 )
      return 42066;
    v3 = &unk_100C4FE0;
    v7 = &unk_100C4FE0;
    v6 = &a1;
  }
  v4 = sub_1002CC90(v6, 1u, (int)v7, 12, 2, 2);
  if ( v4 == 2 )
    return 42066;
  if ( a3 )
    result = v3[3 * v4 + 1];
  else
    result = v3[3 * v4 + 2];
  return result;
}

//----- (10038620) --------------------------------------------------------
int __cdecl sub_10038620(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1002CC90(&a1, 1u, (int)&unk_100C4FF8, 8, 3, 3);
  if ( v1 == 3 )
    result = 42066;
  else
    result = dword_100C4FFC[2 * v1];
  return result;
}
// 100C4FFC: using guessed type int dword_100C4FFC[];

//----- (10038660) --------------------------------------------------------
int __cdecl sub_10038660(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1002CC90(&a1, 1u, (int)&unk_100C5010, 8, 2, 2);
  if ( v1 == 2 )
    result = 42066;
  else
    result = dword_100C5014[2 * v1];
  return result;
}
// 100C5014: using guessed type int dword_100C5014[];

//----- (100386A0) --------------------------------------------------------
char __cdecl sub_100386A0(int a1, int a2)
{
  return sub_10060E00(a1 + 37000, a2, 284);
}

//----- (100386C0) --------------------------------------------------------
char __cdecl sub_100386C0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10038510(a1, 11);
  return sub_10060E00(v2, a2, 24);
}

//----- (100386E0) --------------------------------------------------------
char __cdecl sub_100386E0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10038570(a1);
  return sub_10060E00(v2, a2, 2720);
}

//----- (10038710) --------------------------------------------------------
char __cdecl sub_10038710(char a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1

  v2 = sub_100385B0(a1, 11, 1);
  sub_10060E00(v2, a2, 36);
  v3 = sub_100385B0(a1, 11, 0);
  return sub_10060E00(v3, a2 + 36, 32);
}

//----- (10038760) --------------------------------------------------------
char __cdecl sub_10038760(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10038620(a1);
  return sub_10060E00(v2, a2, 2192);
}

//----- (10038790) --------------------------------------------------------
char __cdecl sub_10038790(int a1)
{
  return sub_10060E00(6005, a1, 4);
}

//----- (100387B0) --------------------------------------------------------
char __cdecl sub_100387B0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10038660(a1);
  return sub_10060E00(v2, a2, 60);
}

//----- (100387D0) --------------------------------------------------------
char __cdecl sub_100387D0(int a1)
{
  return sub_10060E00(6453, a1, 5);
}

//----- (100387F0) --------------------------------------------------------
int __cdecl sub_100387F0(int a1, float a2)
{
  int result; // eax@1

  result = (signed int)(sub_100680D0(a2) * 683565248.0);
  *(_DWORD *)a1 = result;
  return result;
}

//----- (10038820) --------------------------------------------------------
char sub_10038820()
{
  char result; // al@2

  if ( sub_10030B40(4) || (result = sub_10030B10(50)) != 0 )
    result = 1;
  return result;
}

//----- (10038840) --------------------------------------------------------
bool __thiscall sub_10038840(void *this)
{
  return (sub_1002C5C0(this) & 0x4000) == 0x4000;
}

//----- (10038860) --------------------------------------------------------
char sub_10038860()
{
  char v1; // [sp+4h] [bp-100h]@1

  memset(&v1, 0, 0xFCu);
  if ( sub_10015AC0(1, 1309, &v1) )
    sub_1001C9B0((int)&v1);
  return 0;
}

//----- (10038900) --------------------------------------------------------
BOOL __cdecl sub_10038900(int a1, int a2)
{
  return sub_10060D80(6455, a2, 252) == 0;
}

//----- (10038920) --------------------------------------------------------
char __cdecl sub_10038920(int a1, char a2, int a3, int a4, int a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10038900(a1, a5);
  }
  else
  {
    result = sub_10038860();
  }
  return result;
}

//----- (10038960) --------------------------------------------------------
unsigned int __cdecl sub_10038960(unsigned int a1)
{
  unsigned int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = a1 & 0xFFFFFFFC;
  else
    result = 0;
  return result;
}

//----- (10038980) --------------------------------------------------------
int __cdecl sub_10038980(int a1)
{
  return a1 | 1;
}

//----- (10038990) --------------------------------------------------------
bool __cdecl sub_10038990(int a1)
{
  bool result; // al@1
  unsigned int v2; // eax@4
  _DWORD *v3; // edx@4
  _DWORD *v4; // esi@4
  int v5; // ecx@8
  int v6; // eax@9
  _BYTE *v7; // edx@9
  _BYTE *v8; // esi@9
  int v9; // eax@11
  _BYTE *v10; // edx@11
  _BYTE *v11; // esi@11
  _BYTE *v12; // edx@13
  _BYTE *v13; // esi@13
  int v14; // edx@14
  signed int v15; // eax@15

  result = *(_DWORD *)(a1 + 88) == ~*(_DWORD *)(a1 + 36);
  if ( *(_WORD *)(a1 + 30) != 99 || !result && *(_WORD *)(a1 + 684) != 2 )
    return result;
  v2 = 10;
  v3 = (_DWORD *)(a1 + 693);
  v4 = (_DWORD *)(a1 + 721);
  do
  {
    if ( *v4 != *v3 )
      goto LABEL_8;
    v2 -= 4;
    ++v3;
    ++v4;
  }
  while ( v2 >= 4 );
  if ( !v2 )
  {
LABEL_17:
    v15 = 0;
    return v15 == 0;
  }
LABEL_8:
  v5 = *(_BYTE *)v4 - *(_BYTE *)v3;
  if ( *(_BYTE *)v4 == *(_BYTE *)v3 )
  {
    v6 = v2 - 1;
    v7 = (char *)v3 + 1;
    v8 = (char *)v4 + 1;
    if ( !v6 )
      goto LABEL_17;
    v5 = *v8 - *v7;
    if ( *v8 == *v7 )
    {
      v9 = v6 - 1;
      v10 = v7 + 1;
      v11 = v8 + 1;
      if ( !v9 )
        goto LABEL_17;
      v5 = *v11 - *v10;
      if ( *v11 == *v10 )
      {
        v12 = v10 + 1;
        v13 = v11 + 1;
        if ( v9 == 1 )
          goto LABEL_17;
        v14 = *v12;
        v5 = *v13 - v14;
        if ( *v13 == v14 )
          goto LABEL_17;
      }
    }
  }
  v15 = 1;
  if ( v5 <= 0 )
    return 0;
  return v15 == 0;
}

//----- (10038A60) --------------------------------------------------------
int __cdecl sub_10038A60(int a1)
{
  return *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 32) + *(_WORD *)(a1 + 28) + 46;
}

//----- (10038A80) --------------------------------------------------------
int __cdecl sub_10038A80(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = *(_WORD *)(a2 + 28) + *(_WORD *)(a2 + 26) + 30;
  else
    result = -16 - *(_WORD *)(a1 + 52) + sub_10038A60(a1 + 20);
  return result;
}

//----- (10038AC0) --------------------------------------------------------
bool __cdecl sub_10038AC0(int a1)
{
  unsigned int v1; // esi@2
  unsigned int v2; // ecx@5
  bool result; // al@11

  result = a1
        && (v1 = *(_DWORD *)(a1 + 116), v1 < 0xFFFFFFC2)
        && v1
        && *(_DWORD *)a1 != -1
        && ((v2 = *(_DWORD *)(a1 + 120), *(_DWORD *)a1 + 22 <= v2)
         && *(_DWORD *)(a1 + 24) + *(_DWORD *)(a1 + 20) + 22 <= v2
         || !v2
         || *(_DWORD *)(a1 + 4) != v1)
        && *(_DWORD *)(a1 + 8) == 101010256
        && *(_WORD *)(a1 + 14) == *(_WORD *)(a1 + 12);
  return result;
}

//----- (10038B20) --------------------------------------------------------
signed int __cdecl sub_10038B20(int a1, void *a2, unsigned __int16 a3, __int16 a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // ebp@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 732);
  v6 = 0;
  result = -15;
  v8 = *(_WORD *)(a1 + 48) + *(_DWORD *)(a1 + 16) + 46;
  if ( *(_WORD *)(a1 + 50) >= 4u )
  {
    while ( (unsigned int)(v6 + v8) < *(_DWORD *)(v5 + 120) )
    {
      if ( sub_100611F0(*(_DWORD *)(v5 + 4), &a1, 4, v6 + v8, 0) != 4 )
        return -15;
      if ( (_WORD)a1 == a4 && (unsigned int)HIWORD(a1) + 4 <= a3 )
        return sub_100611F0(*(_DWORD *)(v5 + 4), a2, HIWORD(a1) + 4, v6 + v8, 0);
      v6 += HIWORD(a1) + 4;
      result = -15;
      if ( v6 + 4 > (unsigned int)*(_WORD *)(v4 + 50) )
        return result;
    }
  }
  return result;
}

//----- (10038BE0) --------------------------------------------------------
signed int __cdecl sub_10038BE0(int a1, int a2, int a3)
{
  int v3; // esi@3
  signed int result; // eax@9

  if ( sub_100611F0(*(_DWORD *)(a1 + 116), (void *)a3, 30, *(_DWORD *)(a2 + 42), 0) != 30 )
    goto LABEL_13;
  if ( *(_BYTE *)(a2 + 8) & 8 )
  {
    v3 = *(_DWORD *)(a2 + 42) + *(_DWORD *)(a2 + 20) + sub_10038A80(0, a3);
    sub_100611F0(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3, 0);
    if ( *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16) )
      sub_100611F0(*(_DWORD *)(a1 + 116), (void *)(a3 + 14), 12, v3 + 4, 0);
  }
  if ( *(_DWORD *)a3 != 67324752
    || *(_DWORD *)(a3 + 18) != *(_DWORD *)(a2 + 20)
    || *(_DWORD *)(a3 + 14) != *(_DWORD *)(a2 + 16)
    || *(_WORD *)(a3 + 26) != *(_WORD *)(a2 + 28) )
  {
LABEL_13:
    result = -15;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10038C90) --------------------------------------------------------
int __cdecl sub_10038C90(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (10038CB0) --------------------------------------------------------
signed int __cdecl sub_10038CB0(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebp@1
  _BYTE *v4; // edi@2
  _BYTE *v5; // ebx@2
  int v6; // esi@3
  signed int result; // eax@5
  int v8; // [sp+1Ch] [bp+Ch]@3

  v3 = a3;
  if ( a3 )
  {
    v4 = a2;
    v5 = a1;
    while ( 1 )
    {
      v6 = *v5;
      --v3;
      v8 = tolower(*v4++);
      ++v5;
      if ( tolower(v6) != v8 )
        break;
      if ( !v3 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10038D10) --------------------------------------------------------
int __usercall sub_10038D10@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebp@1
  int v4; // edi@2
  int v5; // ebx@2
  int v6; // ebp@5
  int v7; // eax@5
  int v8; // ST04_4@5
  int v10; // [sp+Ch] [bp-4h]@4
  int v11; // [sp+18h] [bp+8h]@4

  v3 = a2;
  if ( a3 )
  {
    v4 = a2;
    v3 = *(_DWORD *)(a1 + 116);
    v5 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 116);
    v5 = *(_DWORD *)(a1 + 120);
  }
  v11 = *(_DWORD *)(a1 + 24);
  sub_100612E0(v3);
  v10 = sub_10061120(v4, v5, v3, v11, *(_DWORD *)(a1 + 20));
  if ( !v10 )
  {
    *(_DWORD *)(a1 + 24) = v5;
    *(_DWORD *)(a1 + 4) = v4;
    *(_DWORD *)(a1 + 120) = v11;
    v6 = sub_10061310(v3, v11, 0);
    v7 = *(_DWORD *)(a1 + 24);
    v8 = v5 + *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = v7;
    v10 = sub_10061310(v4, v8, 0) | v6;
  }
  *(_DWORD *)(a1 + 120) = sub_100612E0(*(_DWORD *)(a1 + 116));
  return v10;
}

//----- (10038E20) --------------------------------------------------------
int __usercall sub_10038E20@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // eax@2
  int result; // eax@2
  int v4; // eax@3
  __int16 v5; // cx@3
  int v6; // edx@3

  sub_10056E90(a2 + 721, a1 + 64);
  if ( *(_DWORD *)(a2 + 44) )
  {
    v4 = *(_DWORD *)(a2 + 725);
    v5 = *(_WORD *)(a2 + 729);
    *(_DWORD *)(a2 + 693) = *(_DWORD *)(a2 + 721);
    v6 = *(_DWORD *)(a2 + 732);
    *(_DWORD *)(a2 + 697) = v4;
    *(_WORD *)(a2 + 701) = v5;
    result = j_FIL_vfs_write(*(_DWORD *)(v6 + 116), a2 + 721, 10);
    *(_DWORD *)(a2 + 136) += 10;
    *(_DWORD *)(a2 + 40) += 10;
  }
  else
  {
    v2 = sub_100612E0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116));
    result = sub_10061310(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), v2 - *(_WORD *)(a2 + 50) - *(_DWORD *)(a2 + 40), 0);
    *(_DWORD *)(a2 + 84) -= *(_WORD *)(a2 + 50);
    *(_DWORD *)(a2 + 136) = 0;
    *(_WORD *)(a2 + 28) &= 0xFFFEu;
    *(_DWORD *)(a2 + 40) = 0;
    *(_WORD *)(a2 + 50) = 0;
    *(_WORD *)(a2 + 30) = 0;
    *(_WORD *)(a2 + 80) = 0;
  }
  return result;
}
// 10061330: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10038ED0) --------------------------------------------------------
signed int __usercall sub_10038ED0@<eax>(int a1@<eax>, int a2@<esi>)
{
  int v2; // edi@1
  char v3; // ST30_1@2
  int v4; // ST28_4@2
  int v5; // eax@2
  __int64 v6; // rax@2
  int v7; // ebx@2
  char *v8; // ebp@2
  __int64 v9; // rax@3
  signed int result; // eax@4
  _WORD *v11; // edi@5
  _WORD *v12; // [sp+Ch] [bp-4h]@4

  v2 = a1;
  if ( *(_BYTE *)(a2 + 8) )
  {
    *(_WORD *)(a1 + 532) = -26367;
    *(_WORD *)(a1 + 534) = 7;
    *(_WORD *)(a1 + 536) = 1;
    *(_BYTE *)(a1 + 538) = 65;
    *(_BYTE *)(a1 + 539) = 69;
    v3 = *(_DWORD *)(a2 + 84);
    *(_DWORD *)(a2 + 76) = a1 + 532;
    v4 = a1 + 532;
    v5 = *(_DWORD *)(a2 + 732);
    *(_WORD *)(a2 + 50) = 11;
    *(_WORD *)(a2 + 80) = 11;
    sub_10061340(*(_DWORD *)(v5 + 116), v4, 11, v3);
    *(_DWORD *)(a2 + 84) += *(_WORD *)(a2 + 80);
    *(_BYTE *)(v2 + 540) = *(_BYTE *)(*(_DWORD *)(a2 + 732) + 112);
    v6 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v6) & 7) + (signed int)v6) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100572E0((void *)(v2 + 555), v7);
  }
  else
  {
    sub_10038B20(a2, (void *)(a1 + 532), 0xBu, -26367);
    v9 = ((*(_BYTE *)(a2 + 688) & 3) + 1) << 6;
    v7 = (((BYTE4(v9) & 7) + (signed int)v9) >> 3) / 2;
    v8 = (char *)(v2 + 555);
    sub_100611F0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 555), v7, *(_DWORD *)(a2 + 84), 0);
    sub_100611F0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 571), 2, v7 + *(_DWORD *)(a2 + 84), 0);
  }
  v12 = (_WORD *)(v2 + 543);
  result = sub_100571B0(*(_BYTE *)(v2 + 540), (void *)v2, strlen((const char *)v2), v8, (_WORD *)(v2 + 543), v2 + 64);
  if ( *(_BYTE *)(a2 + 8) )
  {
    sub_10061340(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v8, v7, *(_DWORD *)(a2 + 84));
    v11 = (_WORD *)(v2 + 571);
    *v11 = *v12;
    sub_10061340(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (int)v11, 2, v7 + *(_DWORD *)(a2 + 84));
    result = v7 + 2;
    *(_DWORD *)(a2 + 136) += v7 + 2;
    *(_DWORD *)(a2 + 40) += v7 + 2;
  }
  else
  {
    *(_DWORD *)(a2 + 92) += -12 - v7;
    *(_DWORD *)(a2 + 124) += v7 + 2;
  }
  return result;
}

//----- (100390A0) --------------------------------------------------------
char __usercall sub_100390A0@<al>(int a1@<eax>, char *a2@<edx>, unsigned int a3@<ecx>)
{
  return sub_10056E40(a2, a3, a1 + 212);
}

//----- (100390B0) --------------------------------------------------------
int __usercall sub_100390B0@<eax>(int result@<eax>)
{
  if ( *(_WORD *)(result + 30) == 99 )
    result = sub_10038E20(result + 148, result);
  return result;
}

//----- (100390D0) --------------------------------------------------------
char __usercall sub_100390D0@<al>(int a1@<eax>)
{
  int v1; // eax@1

  v1 = (*(_DWORD *)(a1 + 72) & 0xFFFD | 2) * ((*(_DWORD *)(a1 + 72) & 0xFFFD | 2) ^ 1);
  return BYTE1(v1);
}

//----- (100390F0) --------------------------------------------------------
int __usercall sub_100390F0@<eax>(int a1@<esi>, unsigned __int8 a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@1
  int result; // eax@1

  v2 = sub_10068360(a2, *(_DWORD *)(a1 + 64));
  v3 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 64) = v2;
  v4 = 134775813 * (*(_DWORD *)(a1 + 68) + (unsigned __int8)v2) + 1;
  *(_DWORD *)(a1 + 68) = v4;
  result = sub_10068360(BYTE3(v4), v3);
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

//----- (10039130) --------------------------------------------------------
int __cdecl sub_10039130(unsigned int a1)
{
  int i; // ebx@1
  int v2; // edi@1
  signed int v3; // eax@1
  signed int v4; // ebp@1
  int result; // eax@2
  int v6; // esi@7
  int v7; // ebx@9
  int v8; // eax@10
  unsigned int v9; // ecx@11
  int *v10; // edx@11
  char *v11; // esi@11
  int v12; // edi@15
  int v13; // ecx@16
  _BYTE *v14; // edx@16
  _BYTE *v15; // esi@16
  int v16; // ecx@18
  _BYTE *v17; // edx@18
  _BYTE *v18; // esi@18
  _BYTE *v19; // edx@20
  _BYTE *v20; // esi@20
  signed int v21; // ecx@22
  signed int v22; // [sp+Ch] [bp-9Ch]@1
  int v23; // [sp+10h] [bp-98h]@7
  signed int v24; // [sp+14h] [bp-94h]@1
  int v25; // [sp+18h] [bp-90h]@1
  int v26; // [sp+20h] [bp-88h]@1
  char v27[128]; // [sp+24h] [bp-84h]@9

  i = 65557;
  v2 = 0;
  v22 = 65557;
  v25 = 0;
  v26 = 101010256;
  v3 = sub_100612E0(a1);
  v4 = v3;
  v24 = v3;
  if ( v3 >= 0 )
  {
    if ( (unsigned int)v3 >= 0x10015 )
      goto LABEL_7;
    v22 = v3;
    if ( v3 > 0 )
    {
      for ( i = v3; ; i = v22 )
      {
LABEL_7:
        v6 = v2 + 128;
        v23 = v2 + 128;
        if ( v2 + 128 > i )
        {
          v6 = i;
          v23 = i;
        }
        v7 = v6 - v2;
        if ( sub_100611F0(a1, v27, v6 - v2, v4 - v6, 0) != v6 - v2 )
          break;
        v8 = v7 - 4;
        if ( v7 - 4 >= 0 )
        {
          while ( 1 )
          {
            v9 = 4;
            v10 = &v26;
            v11 = &v27[v8];
            do
            {
              if ( *(_DWORD *)v11 != *v10 )
                goto LABEL_15;
              v9 -= 4;
              ++v10;
              v11 += 4;
            }
            while ( v9 >= 4 );
            if ( !v9 )
            {
LABEL_24:
              v21 = 0;
              goto LABEL_25;
            }
LABEL_15:
            v12 = (unsigned __int8)*v11 - *(_BYTE *)v10;
            if ( (unsigned __int8)*v11 == *(_BYTE *)v10 )
            {
              v13 = v9 - 1;
              v14 = (char *)v10 + 1;
              v15 = v11 + 1;
              if ( !v13 )
                goto LABEL_24;
              v12 = *v15 - *v14;
              if ( *v15 == *v14 )
              {
                v16 = v13 - 1;
                v17 = v14 + 1;
                v18 = v15 + 1;
                if ( !v16 )
                  goto LABEL_24;
                v12 = *v18 - *v17;
                if ( *v18 == *v17 )
                {
                  v19 = v17 + 1;
                  v20 = v18 + 1;
                  if ( v16 == 1 )
                    goto LABEL_24;
                  v12 = *v20 - *v19;
                  if ( *v20 == *v19 )
                    goto LABEL_24;
                }
              }
            }
            v21 = 1;
            if ( v12 <= 0 )
              v21 = -1;
LABEL_25:
            if ( !v21 )
              return v24 + v8 - v23;
            if ( --v8 < 0 )
            {
              v4 = v24;
              v2 = v25;
              v6 = v23;
              break;
            }
          }
        }
        v2 = v2 + v7 - 3;
        v25 = v2;
        if ( v6 >= v22 )
          break;
      }
    }
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10039130: using guessed type char var_84[128];

//----- (100392E0) --------------------------------------------------------
int __fastcall sub_100392E0(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a2 + 30);
  if ( *(_WORD *)(a2 + 30) == 99 )
    result = *(_WORD *)(a2 + 689);
  return result;
}

//----- (10039300) --------------------------------------------------------
int __usercall sub_10039300@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_DWORD *)(a2 + 732) = result;
  ++*(_DWORD *)(result + 124);
  return result;
}

//----- (10039310) --------------------------------------------------------
int __usercall sub_10039310@<eax>(int a1@<esi>)
{
  int v1; // ST1C_4@1
  unsigned int v2; // ST18_4@1
  int v3; // eax@1
  int v4; // ST00_4@1

  v1 = *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24);
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v1;
  sub_100613E0(v2, v1, 0);
  j_FIL_vfs_write(*(_DWORD *)(a1 + 4), a1 + 8, 22);
  v3 = *(_DWORD *)a1 + 22;
  v4 = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a1 + 120) = v3;
  return sub_10061310(v4, v3, 0);
}
// 10061330: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10039350) --------------------------------------------------------
signed int __usercall sub_10039350@<eax>(int a1@<ecx>, int a2@<edi>, int a3, int a4, int a5, int a6)
{
  __int16 v6; // ax@1
  unsigned int *v7; // ecx@1
  int v8; // esi@1
  signed int v9; // eax@1
  unsigned int v10; // eax@1
  int v11; // ebx@1
  int v12; // ebx@1
  int v13; // eax@4
  int v14; // ecx@6
  int v15; // ebp@8
  unsigned int v16; // ebx@11
  __int64 v17; // rax@14
  unsigned int v18; // ecx@15
  unsigned int v19; // ebp@15
  int v21; // ebx@20
  signed int v22; // eax@23
  size_t v23; // ebp@29
  int v24; // ebx@33
  int v25; // [sp+Ch] [bp-8h]@1
  __int16 v26; // [sp+10h] [bp-4h]@1

  v6 = sub_100392E0(a1, a3);
  v7 = *(unsigned int **)(a2 + 16);
  v8 = a2 + 28;
  v26 = v6;
  *(_DWORD *)v8 = v7;
  v9 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v8 + 4) = v9;
  v25 = 0;
  v10 = sub_10068380(v7, v9, *(_DWORD *)a2);
  v11 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a2 = v10;
  v12 = v11 + 0xFFFFF;
  while ( 1 )
  {
    if ( !*(_DWORD *)(a2 + 32) )
    {
      if ( !a6 )
        goto LABEL_37;
      v13 = *(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 44) == v13 && v12 != v13 + 0xFFFFF )
        break;
    }
    v14 = *(_DWORD *)(a2 + 12);
    if ( !v14 )
      break;
    if ( !--v12 )
      break;
    v15 = *(_DWORD *)(a2 + 44);
    if ( !v15 || a6 && v15 != v14 )
    {
      v16 = *(_DWORD *)(a2 + 48);
      if ( v16
        && (v16 >= 0x28
         || *(_WORD *)(a3 + 30) != 99
         || (v17 = ((*(_BYTE *)(a3 + 688) & 3) + 1) << 6, v16 != (((BYTE4(v17) & 7) + (signed int)v17) >> 3) / 2 + 2)) )
      {
        v18 = v14 - v15;
        v19 = v18;
        if ( *(_BYTE *)(a3 + 28) & 1 )
          sub_100390A0(a3, *(char **)(a2 + 8), v18);
        if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v19) != v19 )
          return -16;
      }
      else
      {
        v19 = 0;
      }
      v21 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
      v12 = v21 + 0xFFFFF;
      v25 += v19;
      *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    }
    if ( v26 == 8 )
    {
      if ( a6 )
        v22 = sub_10059240(a2 + 28, 4);
      else
        v22 = sub_10059240(a2 + 28, 0);
      if ( v22 && v22 != 1 )
        return -15;
    }
    else
    {
      if ( v26 )
        return -15;
      v23 = *(_DWORD *)(a2 + 44);
      if ( *(_DWORD *)(a2 + 32) < v23 )
        v23 = *(_DWORD *)(a2 + 32);
      memcpy(*(void **)(a2 + 40), *(const void **)v8, v23);
      *(_DWORD *)(a2 + 32) -= v23;
      *(_DWORD *)(a2 + 44) -= v23;
      *(_DWORD *)v8 += v23;
      *(_DWORD *)(a2 + 40) += v23;
      *(_DWORD *)(a2 + 36) += v23;
      *(_DWORD *)(a2 + 48) += v23;
    }
  }
  if ( a6 )
  {
    v24 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44);
    if ( *(_BYTE *)(a3 + 28) & 1 )
      sub_100390A0(a3, *(char **)(a2 + 8), *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 44));
    if ( j_FIL_vfs_write(a4, *(_DWORD *)(a2 + 8), v24) != v24 )
      return -16;
    v25 += v24;
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 8);
  }
LABEL_37:
  *(_DWORD *)(a5 + 24) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a5 + 20) = *(_DWORD *)(a2 + 48);
  return v25;
}
// 10061330: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10039560) --------------------------------------------------------
int __cdecl sub_10039560(void *a1)
{
  unsigned int v1; // ecx@2
  unsigned int v2; // eax@4
  int v3; // edi@4
  int v4; // edi@7
  int result; // eax@8

  if ( a1 && (v1 = *((_DWORD *)a1 + 29), v1 < 0xFFFFFFC2) && v1 )
  {
    v2 = *((_DWORD *)a1 + 1);
    v3 = 0;
    if ( v1 != v2 && v2 < 0xFFFFFFC2 )
    {
      if ( v2 )
      {
        v4 = sub_10038D10((int)a1, v2, 0);
        v3 = sub_10039310((int)a1) | v4;
      }
    }
    sub_10061070(*((_DWORD *)a1 + 29));
    memset(a1, 0, 0x80u);
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100395C0) --------------------------------------------------------
int __cdecl sub_100395C0(int a1, int a2, void *a3, int a4)
{
  unsigned int v4; // eax@3
  signed int v5; // edi@5
  unsigned int v6; // eax@6
  int v8; // eax@11
  int v9; // eax@17

  memset(a3, 0, 0x80u);
  *((_DWORD *)a3 + 8) = -1;
  *((_DWORD *)a3 + 9) = -1;
  *((_BYTE *)a3 + 48) = 0;
  if ( a4 )
    sub_1002C120((int)a3 + 48, (_BYTE *)a4, 64);
  *((_BYTE *)a3 + 112) = 3;
  v4 = j_FIL_vfs_open(a1, a2, 0);
  *((_DWORD *)a3 + 29) = v4;
  if ( v4 >= 0xFFFFFFC2 || !v4 )
  {
    v5 = v4;
    if ( !v4 )
      return v5;
LABEL_6:
    v6 = *((_DWORD *)a3 + 29);
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_10061070(*((_DWORD *)a3 + 29));
    }
    memset(a3, 0, 0x80u);
    return v5;
  }
  *((_DWORD *)a3 + 1) = v4;
  v8 = sub_100612E0(v4);
  *((_DWORD *)a3 + 30) = v8;
  if ( v8 < 0 )
  {
LABEL_12:
    v5 = -15;
    goto LABEL_6;
  }
  if ( v8 || !(a2 & 2) )
  {
    v9 = sub_10039130(*((_DWORD *)a3 + 29));
    *(_DWORD *)a3 = v9;
    if ( v9 == -1 || (unsigned int)(v9 + 22) > *((_DWORD *)a3 + 30) )
      goto LABEL_12;
    sub_100611F0(*((_DWORD *)a3 + 1), (char *)a3 + 8, 22, v9, 0);
    if ( !sub_10038AC0((int)a3) )
    {
      v5 = -15;
      goto LABEL_6;
    }
  }
  else
  {
    *((_DWORD *)a3 + 2) = 101010256;
  }
  return 0;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100396C0) --------------------------------------------------------
signed int __cdecl sub_100396C0(int a1, unsigned __int64 a2)
{
  unsigned int v2; // eax@3
  signed int v3; // esi@3
  unsigned int v4; // ebp@4
  int v5; // edx@8
  void *v6; // eax@9
  unsigned __int16 v7; // si@10
  unsigned __int16 v8; // cx@10
  void *v9; // ecx@17
  unsigned __int16 v10; // ax@19
  signed int result; // eax@24
  int v12; // ecx@25
  int v13; // [sp+8h] [bp-4h]@4

  if ( sub_10038AC0(a1) && a2 < *(_WORD *)(a1 + 16) )
  {
    v2 = *(_DWORD *)(a1 + 32);
    v3 = -15;
    if ( (unsigned int)a2 < v2 )
    {
      v4 = *(_DWORD *)(a1 + 24);
      v13 = 0;
LABEL_5:
      while ( v4 < *(_DWORD *)(a1 + 120) )
      {
        v3 = sub_100611F0(*(_DWORD *)(a1 + 4), (void *)(HIDWORD(a2) + 4), 46, v4, 0);
        if ( v3 != 46 || *(_DWORD *)(HIDWORD(a2) + 4) != 33639248 )
        {
          v12 = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v12;
          v3 = -15;
          break;
        }
        v5 = a1;
        *(_DWORD *)(a1 + 32) = v13;
        *(_DWORD *)(a1 + 36) = v4;
        if ( v13 == (_DWORD)a2 )
        {
          v6 = *(void **)(HIDWORD(a2) + 52);
          v3 = 0;
          *(_DWORD *)HIDWORD(a2) = v4;
          *(_WORD *)(HIDWORD(a2) + 58) = -1;
          if ( v6 )
          {
            v7 = *(_WORD *)(HIDWORD(a2) + 56);
            v8 = *(_WORD *)(HIDWORD(a2) + 32);
            if ( v7 <= v8 )
            {
              sub_1002C120((int)v6, &byte_10080D49, v7);
              v5 = a1;
              v3 = -15;
            }
            else if ( sub_100611F0(*(_DWORD *)(a1 + 4), v6, v8, v4 + 46, 0) == *(_WORD *)(HIDWORD(a2) + 32) )
            {
              v5 = a1;
              *(_WORD *)(HIDWORD(a2) + 58) = *(_WORD *)(HIDWORD(a2) + 32);
              v3 = 0;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
            else
            {
              v5 = a1;
              v3 = -15;
              *(_BYTE *)(*(_WORD *)(HIDWORD(a2) + 32) + *(_DWORD *)(HIDWORD(a2) + 52)) = 0;
            }
          }
          else
          {
            *(_WORD *)(HIDWORD(a2) + 58) = -1;
          }
          v9 = *(void **)(HIDWORD(a2) + 60);
          *(_WORD *)(HIDWORD(a2) + 66) = -1;
          if ( v9 )
          {
            if ( !v3 )
            {
              v10 = *(_WORD *)(HIDWORD(a2) + 34);
              if ( *(_WORD *)(HIDWORD(a2) + 64) < v10
                || sub_100611F0(*(_DWORD *)(v5 + 4), v9, v10, *(_WORD *)(HIDWORD(a2) + 32) + v4 + 46, 0) != *(_WORD *)(HIDWORD(a2) + 34) )
              {
                v3 = -15;
              }
              else
              {
                v3 = 0;
                *(_WORD *)(HIDWORD(a2) + 66) = *(_WORD *)(HIDWORD(a2) + 34);
              }
            }
          }
        }
        v4 += sub_10038A60(HIDWORD(a2) + 4);
        if ( ++v13 > (unsigned int)a2 )
          return v3;
      }
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 36);
      v13 = *(_DWORD *)(a1 + 32);
      if ( v2 <= (unsigned int)a2 )
        goto LABEL_5;
    }
    result = v3;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (100398C0) --------------------------------------------------------
signed int __cdecl sub_100398C0(int a1, int a2)
{
  return sub_10038BE0(*(_DWORD *)(a1 + 732), a1 + 20, a2);
}

//----- (100398E0) --------------------------------------------------------
int __cdecl sub_100398E0(int a1)
{
  int v1; // ebx@1
  int v2; // esi@1
  unsigned int v3; // ebp@1
  bool v4; // zf@1
  int v5; // ecx@1
  __int16 v6; // cx@4
  __int16 v7; // ax@4
  __int16 v8; // dx@4
  __int16 v9; // cx@4
  unsigned int v10; // edx@4
  int v11; // eax@4
  unsigned int v12; // ecx@4
  int v13; // eax@4
  int result; // eax@5
  int v15; // eax@6
  unsigned __int16 v16; // ax@7
  int v17; // eax@11
  int v18; // edx@13
  int v19; // edi@13
  int v20; // eax@13
  unsigned __int16 v21; // cx@14
  int v22; // [sp+10h] [bp-28h]@4
  char v23; // [sp+14h] [bp-24h]@3
  int v24; // [sp+18h] [bp-20h]@1
  int v25; // [sp+1Ch] [bp-1Ch]@1
  int v26; // [sp+20h] [bp-18h]@1
  int v27; // [sp+24h] [bp-14h]@1
  __int64 v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+30h] [bp-8h]@1
  __int16 v30; // [sp+34h] [bp-4h]@1
  int v31; // [sp+3Ch] [bp+4h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 732);
  v31 = *(_DWORD *)(v2 + 116);
  sub_100390B0(v1);
  v3 = *(_DWORD *)(v2 + 4);
  v4 = *(_WORD *)(v1 + 32) == 0;
  v5 = ~*(_DWORD *)(v1 + 88);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0i64;
  v29 = 0;
  v30 = 0;
  *(_DWORD *)(v1 + 36) = v5;
  if ( v4 || !*(_WORD *)(v1 + 34) )
  {
    sub_10032600(&v23);
    sub_1002C9E0((unsigned int *)&v23, (_WORD *)(v1 + 34), (_WORD *)(v1 + 32));
  }
  v6 = *(_WORD *)(v1 + 24);
  v7 = *(_WORD *)(v1 + 30);
  HIWORD(v25) = *(_WORD *)(v1 + 28);
  v8 = *(_WORD *)(v1 + 34);
  LOWORD(v25) = v6;
  v9 = *(_WORD *)(v1 + 32);
  LOWORD(v27) = v8;
  v10 = *(_DWORD *)(v1 + 44);
  LOWORD(v26) = v7;
  v11 = *(_DWORD *)(v1 + 36);
  HIWORD(v26) = v9;
  v12 = *(_DWORD *)(v1 + 40);
  *(int *)((char *)&v27 + 2) = v11;
  LOWORD(v11) = *(_WORD *)(v1 + 48);
  *(__int64 *)((char *)&v28 + 2) = __PAIR__(v10, v12);
  LOWORD(v12) = *(_WORD *)(v1 + 50);
  v24 = 67324752;
  HIWORD(v29) = v11;
  v30 = v12;
  v22 = sub_10038A80(v1, (int)&v24);
  v13 = sub_100612E0(v31);
  if ( v3 == v31 )
  {
    result = sub_10061120(v31, v13, v31, *(_DWORD *)(v2 + 24), *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v15 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v1 + 62) = v15;
    *(_DWORD *)(v1 + 84) = v22 + v15;
  }
  sub_100613E0(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 62), 0);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), &v24, 30);
  j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72));
  v16 = *(_WORD *)(v1 + 80);
  if ( v16 )
    j_FIL_vfs_write(*(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 76), v16);
  if ( v3 == v31 )
  {
    result = sub_10061120(
               v31,
               *(_DWORD *)(v1 + 84),
               v31,
               v22 + *(_DWORD *)(v2 + 120),
               *(_DWORD *)(v1 + 40) + *(_DWORD *)(v2 + 20));
    if ( result )
      return result;
    v17 = *(_DWORD *)((char *)&v28 + 2) + v22 + *(_DWORD *)(v2 + 24);
  }
  else
  {
    v17 = 0;
  }
  v18 = v17 + *(_DWORD *)(v2 + 20);
  ++*(_WORD *)(v2 + 16);
  ++*(_WORD *)(v2 + 18);
  *(_DWORD *)(v2 + 8) = 101010256;
  *(_DWORD *)(v2 + 24) = v17;
  *(_WORD *)(v2 + 28) = 0;
  sub_100613E0(v3, v18, 0);
  *(_DWORD *)(v2 + 20) += sub_10038A60(v1 + 20);
  j_FIL_vfs_write(v3, v1 + 20, 46);
  v19 = j_FIL_vfs_write(v3, *(_DWORD *)(v1 + 68), *(_WORD *)(v1 + 72)) != *(_WORD *)(v1 + 72) ? 0xFFFFFFF1 : 0;
  v20 = *(_DWORD *)(v1 + 76);
  if ( v20 )
  {
    v21 = *(_WORD *)(v1 + 80);
    if ( v21 )
    {
      v19 |= j_FIL_vfs_write(v3, v20, v21);
      if ( v19 >= 0 )
        v19 = 0;
    }
  }
  *(_DWORD *)v2 = *(_DWORD *)(v2 + 20) + *(_DWORD *)(v2 + 24);
  if ( v3 == v31 )
    sub_10039310(v2);
  else
    *(_DWORD *)(v2 + 120) = sub_100612E0(v31);
  *(_DWORD *)(v2 + 36) = *(_DWORD *)(v2 + 24);
  *(_DWORD *)(v2 + 32) = 0;
  return v19;
}
// 10061330: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (10039B50) --------------------------------------------------------
int __cdecl sub_10039B50(void *a1, int a2, char a3)
{
  _BYTE *v3; // eax@1
  char *v4; // edi@3
  int result; // eax@4

  memset(a1, 0, 0x2E0u);
  *((_DWORD *)a1 + 17) = *(_DWORD *)(a2 + 4);
  *((_WORD *)a1 + 36) = *(_WORD *)(a2 + 8);
  *((_DWORD *)a1 + 19) = *(_DWORD *)(a2 + 16);
  *((_WORD *)a1 + 40) = *(_WORD *)(a2 + 20);
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *((_DWORD *)a1 + 24) = *(_DWORD *)(a2 + 24);
  *((_DWORD *)a1 + 25) = *(_DWORD *)(a2 + 28);
  *((_DWORD *)a1 + 26) = 0;
  *((_DWORD *)a1 + 27) = 0;
  sub_10038C90((int)a1 + 116);
  v3 = *(_BYTE **)(a2 + 12);
  if ( v3 )
    sub_1002C120((int)a1 + 148, v3, 64);
  v4 = (char *)a1 + 116;
  if ( a3 )
    result = sub_10059500(
               (int)v4,
               *(_BYTE *)(a2 + 44),
               8,
               -*(_DWORD *)(a2 + 40),
               *(_DWORD *)(a2 + 48),
               0,
               *(_DWORD *)(a2 + 32),
               *(_DWORD *)(a2 + 36));
  else
    result = sub_10035710((int)v4, -*(_DWORD *)(a2 + 40), *(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36));
  return result;
}

//----- (10039C20) --------------------------------------------------------
signed int __cdecl sub_10039C20(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ecx@7
  int v5; // eax@10

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    if ( *(_DWORD *)(a1 + 112) == *(_DWORD *)(a1 + 44) && !*(_DWORD *)(a1 + 124) )
      sub_100613E0(*(_DWORD *)(*(_DWORD *)(a1 + 732) + 116), *(_DWORD *)(a1 + 136) + *(_DWORD *)(a1 + 84), 0);
    v4 = *(_DWORD *)(a1 + 112) - a3;
    *(_DWORD *)(a1 + 104) = a2;
    *(_DWORD *)(a1 + 108) = a3;
    v5 = !v4 && *(_DWORD *)(a1 + 136) || !a2;
    result = sub_10039350(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 88,
               a1,
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               a1 + 20,
               v5);
    if ( result >= 0 )
    {
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);
      *(_DWORD *)(a1 + 112) -= a3;
    }
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10039CC0) --------------------------------------------------------
int __usercall sub_10039CC0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  char v2; // al@1
  unsigned __int8 *v3; // edx@1

  v1 = a1;
  v2 = sub_100390D0(a1);
  *v3 ^= v2;
  return sub_100390F0(v1, *v3);
}

//----- (10039CE0) --------------------------------------------------------
int __usercall sub_10039CE0@<eax>(int a1@<edi>, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = 0; i < a1; ++i )
    result = sub_10039CC0(a2);
  return result;
}

//----- (10039D10) --------------------------------------------------------
signed int __usercall sub_10039D10@<eax>(int a1@<eax>, int a2@<ebx>)
{
  int v2; // esi@1
  signed int v3; // edi@1
  signed int result; // eax@4

  v2 = a1;
  *(_DWORD *)(a1 + 64) = 305419896;
  *(_DWORD *)(a1 + 68) = 591751049;
  *(_DWORD *)(a1 + 72) = 878082192;
  v3 = 0;
  do
  {
    if ( !*(_BYTE *)(v3 + v2) )
      break;
    sub_100390F0(v2, *(_BYTE *)(v3++ + v2));
  }
  while ( v3 < 64 );
  result = sub_100611F0(*(_DWORD *)(*(_DWORD *)(a2 + 732) + 116), (void *)(v2 + 76), 12, *(_DWORD *)(a2 + 84), 0);
  *(_DWORD *)(a2 + 92) -= 12;
  *(_DWORD *)(a2 + 124) += 12;
  return result;
}

//----- (10039D80) --------------------------------------------------------
int __cdecl sub_10039D80(int a1, char *a2, int a3)
{
  char *v3; // edi@1
  int v4; // ebx@4
  int v5; // esi@6
  int result; // eax@11
  signed int v7; // [sp+8h] [bp-F4h]@6
  char v8; // [sp+Ch] [bp-F0h]@4
  char *v9; // [sp+40h] [bp-BCh]@4
  __int16 v10; // [sp+44h] [bp-B8h]@4
  unsigned __int16 v11; // [sp+46h] [bp-B6h]@8
  char v12; // [sp+50h] [bp-ACh]@4

  v3 = a2;
  if ( sub_10038AC0(a1) && a2 && *a2 )
  {
    memset(&v8, 0, 0x44u);
    v9 = &v12;
    v10 = 168;
    v4 = strlen(a2);
    strchr(a2, 92);
    if ( *a2 == 47 )
    {
      v3 = a2 + 1;
      --v4;
    }
    v5 = a3;
    v7 = -24;
    if ( a3 < (unsigned int)*(_WORD *)(a1 + 16) )
    {
      while ( sub_100396C0(a1, __PAIR__(&v8, v5)) || v4 != v11 || sub_10038CB0(v3, &v12, v4) )
      {
        if ( ++v5 >= (unsigned int)*(_WORD *)(a1 + 16) )
          return -24;
      }
      v7 = v5;
    }
    result = v7;
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (10039EF0) --------------------------------------------------------
signed int __cdecl sub_10039EF0(int a1)
{
  signed int result; // eax@5

  if ( a1 && *(_DWORD *)(a1 + 732) )
  {
    --*(_DWORD *)(*(_DWORD *)(a1 + 732) + 124);
    if ( *(_BYTE *)(a1 + 8) )
      exit_0(a1);
    sub_10034BE0(a1 + 116);
    result = 0;
    *(_DWORD *)a1 = -858993460;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (10039F50) --------------------------------------------------------
char __usercall sub_10039F50@<al>(char *a1@<edx>, size_t a2@<ecx>, int a3@<esi>)
{
  char result; // al@2

  if ( *(_WORD *)(a3 + 30) == 99 )
    result = sub_10056DF0(a1, a2, a3 + 212);
  else
    result = sub_10039CE0(a2, a3 + 148);
  return result;
}

//----- (10039F80) --------------------------------------------------------
signed int __usercall sub_10039F80@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  bool v2; // zf@1
  int v3; // eax@1
  signed int result; // eax@2

  v1 = a1;
  v2 = *(_WORD *)(a1 + 30) == 99;
  v3 = a1 + 148;
  if ( v2 )
    result = sub_10038ED0(v3, v1);
  else
    result = sub_10039D10(v3, v1);
  return result;
}

//----- (10039FB0) --------------------------------------------------------
BOOL __usercall sub_10039FB0@<eax>(int a1@<ebx>, int a2)
{
  int v2; // ebp@1
  unsigned int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+10h] [bp+4h]@2

  v2 = a2;
  v3 = 0;
  v4 = a2 + 148;
  do
  {
    v6 = *(_BYTE *)(a1 + v3 + 76);
    sub_10039CC0(v4);
    ++v3;
  }
  while ( v3 < 0xC );
  return *(_BYTE *)(v2 + 39) == v6;
}

//----- (10039FF0) --------------------------------------------------------
signed int __cdecl sub_10039FF0(unsigned int a1)
{
  signed int result; // eax@3
  int v2; // eax@4
  int v3; // ecx@4
  int v4; // edx@4

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    sub_10038C90(a1 + 116);
    v2 = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 88) = -1;
    *(_DWORD *)(a1 + 92) = v2;
    *(_DWORD *)(a1 + 112) = v3;
    sub_10035800(v4);
    if ( *(_BYTE *)(a1 + 28) & 1 )
      sub_10039F80(a1);
    result = 0;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1003A040) --------------------------------------------------------
signed int __cdecl sub_1003A040(int a1, int a2)
{
  int v2; // ebp@1
  int v3; // edi@1
  unsigned int v4; // eax@1
  unsigned int v5; // ecx@1
  signed int v6; // eax@4
  size_t v8; // eax@9
  size_t v9; // ebx@10
  int v10; // esi@13
  int v11; // edx@18
  __int16 v12; // ax@20
  size_t v13; // esi@21
  int v14; // ST30_4@25
  unsigned int *v15; // ST34_4@25
  int v16; // ebx@25
  int v17; // [sp+10h] [bp-Ch]@1
  int v18; // [sp+24h] [bp+8h]@7

  v2 = a2;
  v3 = a2 + 28;
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 16);
  v4 = *(_DWORD *)(a2 + 20);
  v5 = *(_DWORD *)(a2 + 24);
  v17 = 0;
  if ( v4 <= v5 )
    *(_DWORD *)(a2 + 44) = v4;
  else
    *(_DWORD *)(a2 + 44) = v5;
  v6 = 0xFFFFF;
  if ( *(_DWORD *)(a2 + 44) )
  {
    while ( 1 )
    {
      v18 = v6 - 1;
      if ( v6 - 1 <= 0 )
        break;
      if ( *(_DWORD *)(v3 + 4) || (v8 = *(_DWORD *)(v2 + 4)) == 0 )
      {
        v10 = a1;
      }
      else
      {
        v9 = *(_DWORD *)(v2 + 12);
        if ( v8 < v9 )
          v9 = *(_DWORD *)(v2 + 4);
        if ( !v9 )
          return v17;
        v10 = a1;
        if ( sub_100611F0(
               *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
               *(void **)(v2 + 8),
               v9,
               *(_DWORD *)(a1 + 84) + *(_DWORD *)(v3 + 8),
               0) != v9 )
          return -15;
        if ( *(_BYTE *)(a1 + 28) & 1 )
        {
          sub_10039F50(*(char **)(v2 + 8), v9, a1);
          if ( *(_DWORD *)(v2 + 4) == v9 && *(_WORD *)(a1 + 30) == 99 )
          {
            sub_100611F0(
              *(_DWORD *)(*(_DWORD *)(a1 + 732) + 116),
              (void *)(a1 + 721),
              10,
              *(_DWORD *)(a1 + 84) + v9 + *(_DWORD *)(v3 + 4) + *(_DWORD *)(v3 + 8),
              0);
            sub_10056E90(a1 + 693, a1 + 212);
            v10 = a1;
          }
        }
        v11 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 4) -= v9;
        v18 = 0xFFFFF;
        *(_DWORD *)v3 = v11;
        *(_DWORD *)(v3 + 4) = v9;
      }
      v12 = sub_100392E0(v5, v10);
      if ( v12 )
      {
        if ( v12 != 8 )
          return -15;
        v14 = *(_DWORD *)(v3 + 20);
        v15 = *(unsigned int **)(v3 + 12);
        v16 = (char)sub_10036C40(v3, 2);
        v17 += *(_DWORD *)(v3 + 20) - v14;
        *(_DWORD *)v2 = sub_10068380(v15, *(_DWORD *)(v3 + 20) - v14, *(_DWORD *)v2);
        if ( v16 == 1 )
          return v17;
        if ( v16 < 0 )
          return -14;
      }
      else
      {
        v13 = *(_DWORD *)(v3 + 4);
        if ( *(_DWORD *)(v3 + 16) < v13 )
          v13 = *(_DWORD *)(v3 + 16);
        memcpy(*(void **)(v3 + 12), *(const void **)v3, v13);
        *(_DWORD *)v2 = sub_10068380(*(unsigned int **)(v3 + 12), v13, *(_DWORD *)v2);
        *(_DWORD *)(v3 + 4) -= v13;
        *(_DWORD *)(v3 + 16) -= v13;
        *(_DWORD *)(v3 + 12) += v13;
        *(_DWORD *)v3 += v13;
        *(_DWORD *)(v3 + 20) += v13;
        *(_DWORD *)(v3 + 8) += v13;
        v17 += v13;
      }
      if ( !*(_DWORD *)(v3 + 16) )
        return v17;
      v6 = v18;
    }
  }
  return v17;
}

//----- (1003A230) --------------------------------------------------------
bool __usercall sub_1003A230@<al>(int a1@<eax>)
{
  int v1; // ecx@4
  int v2; // edx@4
  int v3; // eax@4
  signed int v4; // ecx@6
  int v5; // eax@2

  if ( *(_WORD *)(a1 + 30) != 99 )
    return sub_10039FB0(a1 + 148, a1);
  v5 = a1 + 148;
  v1 = v5 + 543;
  v2 = v5 + 571;
  v3 = *(_BYTE *)(v5 + 571) - *(_BYTE *)(v5 + 543);
  if ( v3 || (v3 = *(_BYTE *)(v2 + 1) - *(_BYTE *)(v1 + 1), *(_BYTE *)(v2 + 1) != *(_BYTE *)(v1 + 1)) )
  {
    v4 = 1;
    if ( v3 <= 0 )
      return 0;
  }
  else
  {
    v4 = 0;
  }
  return v4 == 0;
}

//----- (1003A260) --------------------------------------------------------
int __cdecl sub_1003A260(int a1, int a2, char a3, void *a4, int a5)
{
  int result; // eax@6
  unsigned __int64 v6; // ST04_8@7
  char v7; // [sp+8h] [bp-54h]@8
  int v8; // [sp+28h] [bp-34h]@4
  int v9; // [sp+34h] [bp-28h]@4

  if ( !sub_10038AC0(a1) || !a4 || a3 & 2 )
    return -15;
  qmemcpy(&v8, (const void *)a5, 0x34u);
  if ( !v9 )
    v9 = a1 + 48;
  result = sub_10039B50(a4, (int)&v8, 0);
  if ( !result )
  {
    HIDWORD(v6) = (char *)a4 + 16;
    LODWORD(v6) = a2;
    if ( sub_100396C0(a1, v6) )
      return -15;
    sub_10039300(a1, (int)a4);
    if ( sub_100398C0((int)a4, (int)&v7) )
    {
      sub_1005A230((unsigned int)a4);
      return -15;
    }
    *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10038A80((int)a4, (int)&v7);
    *((_DWORD *)a4 + 3) = a2;
    sub_10039FF0((unsigned int)a4);
    if ( !(*((_BYTE *)a4 + 28) & 1) || sub_1003A230((int)a4) )
    {
      result = sub_10038980((int)a4);
    }
    else
    {
      sub_10039EF0((int)a4);
      result = -34;
    }
  }
  return result;
}

//----- (1003A370) --------------------------------------------------------
signed int __cdecl sub_1003A370(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  int v4; // ST04_4@4
  signed int v5; // eax@4
  signed int v6; // ebx@4
  bool v7; // zf@5

  if ( a1 < 0xFFFFFFC2 && a1 )
  {
    v4 = a1 + 88;
    *(_DWORD *)(v4 + 16) = a2;
    *(_DWORD *)(v4 + 20) = a3;
    v5 = sub_1003A040(a1, a1 + 88);
    v6 = v5;
    if ( v5 > 0 )
    {
      v7 = *(_DWORD *)(a1 + 112) == v5;
      *(_DWORD *)(a1 + 112) -= v5;
      if ( v7 && !(*(_BYTE *)a1 & 1) && !sub_10038990(a1) )
        v6 = -14;
    }
    result = v6;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1003A3D0) --------------------------------------------------------
signed int __cdecl sub_1003A3D0(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@3
  unsigned int v4; // edx@4
  int v5; // ebx@4
  int v6; // esi@16
  int v7; // eax@17
  char v8; // [sp+4h] [bp-204h]@19

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    return -6;
  v4 = *(_DWORD *)(a1 + 44);
  result = *(_DWORD *)(a1 + 44) - *(_DWORD *)(a1 + 112);
  v5 = a2;
  if ( a3 == 1 )
  {
    v5 = result + a2;
  }
  else if ( a3 == 2 )
  {
    v5 = v4 + a2;
  }
  if ( v5 > v4 || v5 < 0 )
    return -15;
  if ( result == v5 )
    return result;
  if ( !v5 )
  {
    sub_10039FF0(a1);
    return 0;
  }
  if ( !*(_WORD *)(a1 + 30) && *(_BYTE *)a1 & 3 )
  {
    sub_10038C90(a1 + 116);
    *(_DWORD *)(a1 + 124) = v5;
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 44) - v5;
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 40) - v5;
    return v5;
  }
  if ( result > v5 )
  {
    sub_10039FF0(a1);
    result = 0;
  }
  v6 = v5 - result;
  if ( v5 - result <= 0 )
    return v5;
  while ( 1 )
  {
    v7 = 512;
    if ( (unsigned int)v6 < 0x200 )
      v7 = v6;
    result = sub_1003A370(a1, (int)&v8, v7);
    if ( result <= 0 )
      break;
    v6 -= result;
    if ( v6 <= 0 )
      return v5;
  }
  return result;
}

//----- (1003A560) --------------------------------------------------------
int __cdecl sub_1003A560(int a1, char *a2, int a3, void *a4, int a5)
{
  int result; // eax@10
  bool v6; // zf@11
  int v7; // ST0C_4@16
  int v8; // eax@16
  int v9; // [sp+Ch] [bp-34h]@5
  int v10; // [sp+18h] [bp-28h]@5
  char v11; // [sp+38h] [bp-8h]@11

  if ( sub_10038AC0(a1) && a2 && a4 && a5 )
  {
    qmemcpy(&v9, (const void *)a5, 0x34u);
    if ( !v10 )
      v10 = a1 + 48;
    *((_DWORD *)a4 + 1) = a3;
    if ( a3 & 8 )
    {
      if ( *(_WORD *)(a1 + 16) >= 0xFFFFu || *(_WORD *)(a1 + 18) >= 0xFFFFu )
      {
        result = -22;
      }
      else
      {
        result = sub_10039B50(a4, (int)&v9, 1);
        if ( !result )
        {
          *((_DWORD *)a4 + 1) = a3;
          *((_BYTE *)a4 + 8) = 1;
          *((_DWORD *)a4 + 183) = a1;
          *((_DWORD *)a4 + 3) = *(_WORD *)(a1 + 16);
          *((_DWORD *)a4 + 22) = -1;
          *((_WORD *)a4 + 12) = 20;
          *((_WORD *)a4 + 13) = 20;
          *((_DWORD *)a4 + 5) = 33639248;
          *((_WORD *)a4 + 14) = 0;
          *((_WORD *)a4 + 16) = 0;
          *((_WORD *)a4 + 17) = 0;
          *((_DWORD *)a4 + 9) = 0;
          *((_DWORD *)a4 + 10) = 0;
          *((_DWORD *)a4 + 11) = 0;
          v6 = v11 == 0;
          *((_WORD *)a4 + 24) = strlen(a2);
          *((_WORD *)a4 + 25) = 0;
          *((_WORD *)a4 + 26) = 0;
          *((_WORD *)a4 + 27) = 0;
          *((_WORD *)a4 + 28) = 0;
          *(_DWORD *)((char *)a4 + 58) = 0;
          if ( v6 )
            *((_WORD *)a4 + 15) = 0;
          else
            *((_WORD *)a4 + 15) = 8;
          if ( *(_BYTE *)a4 & 4 )
          {
            *(_WORD *)((char *)a4 + 689) = *((_WORD *)a4 + 15);
            *((_WORD *)a4 + 15) = 99;
            *((_WORD *)a4 + 14) = 1;
          }
          *(_DWORD *)((char *)a4 + 62) = *(_DWORD *)(a1 + 120);
          *((_DWORD *)a4 + 21) = *(_DWORD *)((char *)a4 + 62) + sub_10038A80((int)a4, 0);
          sub_10039300(a1, (int)a4);
          v7 = *(_DWORD *)((char *)a4 + 62);
          v8 = sub_10038A80((int)a4, 0);
          sub_10061340(*(_DWORD *)(a1 + 116), *((_DWORD *)a4 + 24), v8, v7);
          if ( *((_BYTE *)a4 + 28) & 1 )
            sub_10039F80((int)a4);
          result = sub_10038980((int)a4);
        }
      }
    }
    else
    {
      *((_BYTE *)a4 + 8) = 0;
      result = sub_10039D80(a1, a2, 0);
      if ( result >= 0 )
        result = sub_1003A260(a1, result, a3, a4, (int)&v9);
    }
  }
  else
  {
    result = -15;
  }
  return result;
}

//----- (1003A750) --------------------------------------------------------
int __cdecl sub_1003A750(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 0x7Fu, 0, 0);
}

//----- (1003A770) --------------------------------------------------------
int __cdecl sub_1003A770(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10033B00(a1, 0, 0x7Fu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (1003A7A0) --------------------------------------------------------
int __cdecl sub_1003A7A0(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 3u, 0, 0);
}

//----- (1003A7C0) --------------------------------------------------------
int __cdecl sub_1003A7C0(_BYTE *a1)
{
  return sub_10033B50(a1, 0, 0x2710u, 5000, 0);
}

//----- (1003A7E0) --------------------------------------------------------
int __cdecl sub_1003A7E0(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 5u, 5u, 0);
}

//----- (1003A800) --------------------------------------------------------
int __cdecl sub_1003A800(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 6u, 0, 0);
}

//----- (1003A820) --------------------------------------------------------
int __cdecl sub_1003A820(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 0xEu, 1u, 0);
}

//----- (1003A840) --------------------------------------------------------
int __cdecl sub_1003A840(unsigned __int8 *a1)
{
  return sub_10033B00(a1, 0, 1u, 0, 0);
}

//----- (1003A870) --------------------------------------------------------
int __cdecl sub_1003A870(int a1)
{
  int result; // eax@1

  result = sub_1003A7E0((unsigned __int8 *)a1);
  if ( !result )
  {
    result = sub_1003A860(a1 + 12);
    if ( !result )
    {
      result = sub_1003A840((unsigned __int8 *)(a1 + 1));
      if ( !result )
        result = sub_1003A820((unsigned __int8 *)(a1 + 2));
    }
  }
  return result;
}
// 1003A860: using guessed type _DWORD __cdecl sub_1003A860(_DWORD);

//----- (1003A8B0) --------------------------------------------------------
int __cdecl sub_1003A8B0(int a1)
{
  int result; // eax@1

  result = sub_10031170((void *)(a1 + 28));
  if ( !result )
    result = sub_1003A870(a1);
  return result;
}

//----- (1003A8D0) --------------------------------------------------------
signed int __cdecl sub_1003A8D0(int a1, int a2)
{
  signed int result; // eax@1

  result = 4;
  if ( a1 == 2 )
  {
    byte_10965DD3 = 1;
    byte_10965DD2 = 0;
  }
  else
  {
    if ( a1 == 8 )
    {
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10965DD2 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    else
    {
      if ( a1 != 9 )
        return result;
      if ( *(_DWORD *)a2 == 1 )
      {
        byte_10965DD3 = *(_BYTE *)(a2 + 4);
        return 0;
      }
    }
    result = 9;
  }
  return result;
}
// 10965DD2: using guessed type char byte_10965DD2;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003A930) --------------------------------------------------------
bool __cdecl sub_1003A930(signed int a1)
{
  if ( a1 > 1 )
  {
    sub_10049C50(13, (int)"..\\lib\\utf\\utf_validate.c", (int)&unk_100DF828, (int)"failing_subroutine( depth-1 )");
    sub_1003A930(a1 - 1);
    exit_1(14);
  }
  return sub_1004F110(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"583",
           (int)"Check FAIL macro",
           "UTF_verify_fail: forced fail",
           "UTF_verify_fail: fail forced",
           (int)"This test is expected to fail");
}

//----- (1003A9A0) --------------------------------------------------------
int sub_1003A9A0()
{
  const char *v0; // eax@1

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"All Fail Miscellaneous Test Group");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"610", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"610",
    (int)"Verify miscellaneous macros");
  if ( byte_10965DD2 )
  {
    sub_1004F110(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"620",
      (int)"Check FAIL macro",
      "UTF_verify_fail: forced fail",
      "UTF_verify_fail: fail forced",
      (int)"This test is expected to fail");
    sub_10049C50(13, (int)"..\\lib\\utf\\utf_validate.c", (int)"621", (int)"failing_subroutine( 1 )");
    sub_1003A930(1);
    exit_1(14);
  }
  return sub_10049C80(
           3,
           (int)"**MSG**",
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"616",
           (int)"Failing tests currently disabled. Use FAIL ON command to enable");
}
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003ACC0) --------------------------------------------------------
char sub_1003ACC0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"All Fail Test Group For Type 'bitmap'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"700", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"700",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10965DD2 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100C889C + v2) )
      {
        sub_1004A440((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100C88A4[v2], 0x100u, &v11);
        sub_1004A440((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100C889C + v2), 0x100u, &v12);
        sub_1005A480(&v12, &v11);
      }
      if ( byte_100C8898[v2] )
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"725", 2, 2);
        v3 = off_100C88A0[v2 / 4];
        v4 = *(char **)&off_100C88A4[v2];
        v5 = sub_1004A6E0(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100C88A4[v2],
               off_100C88A0[v2 / 4]);
        v6 = sub_1004ED60(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"730",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1004AA40(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"731",
                   (int)"Return value from previous UTF_verify_eq_bitmap() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"735", 2, 2);
        v7 = off_100C88A0[v2 / 4];
        v8 = *(char **)&off_100C88A4[v2];
        v9 = sub_1004A6E0(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100C88A4[v2],
               off_100C88A0[v2 / 4]);
        v10 = sub_1004ED60(
                0,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"740",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1004AA40(
                   0,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"741",
                   (int)"Return value from previous UTF_verify_ne_bitmap() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"704",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100C889C: using guessed type void *off_100C889C;
// 100C88A0: using guessed type char *off_100C88A0[2];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003AEE0) --------------------------------------------------------
char sub_1003AEE0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"768", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"768",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10965DD2 )
  {
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"776", 2, 2);
    v2 = sub_1004AA40(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"777",
           (int)"UTF_verify_eq_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"778",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"780", 2, 2);
    v3 = sub_1004AA40(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"781",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"782",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"784", 2, 2);
    v4 = sub_1004AA40(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"785",
           (int)"UTF_verify_ne_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"786",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"788", 2, 2);
    v5 = sub_1004AA40(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"789",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1004AA40(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"790",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"772",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003B0E0) --------------------------------------------------------
char sub_1003B0E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"830", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"830",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C892C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"830", 2, 2);
        v3 = byte_100C8929[v2 * 4];
        v4 = byte_100C8928[v2 * 4];
        v5 = sub_1004A6E0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + dword_100C892C[v2])],
               (&off_100C8930)[v2 * 4]);
        v6 = sub_1004AB80(
               0,
               *(&dword_100C887C + dword_100C892C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"830",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1004A6E0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100C892C[v2]],
               (&off_100C8930)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"830",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"830",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C892C: using guessed type int dword_100C892C[];
// 100C8930: using guessed type char *off_100C8930;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003B260) --------------------------------------------------------
char sub_1003B260()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"864", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"864",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C8BB0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100C8BA8[v2 / 8];
        v4 = dbl_100C8BA0[v2 / 8];
        v5 = dbl_100C8B98[v2 / 8];
        v6 = sub_1004A6E0(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100C8BB4[v2]);
        v7 = sub_1004AF30(
               0,
               *(&dword_100C887C + dword_100C8BB0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"864",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100C8BB0[v2 / 4]],
               *(_DWORD *)&off_100C8BB4[v2]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"864",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"864",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C8B98: using guessed type double dbl_100C8B98[];
// 100C8BA0: using guessed type double dbl_100C8BA0[];
// 100C8BA8: using guessed type double dbl_100C8BA8[];
// 100C8BB0: using guessed type int dword_100C8BB0[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003B3E0) --------------------------------------------------------
char sub_1003B3E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"900", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"900",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C97C4[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100C97C0[v2];
        v4 = flt_100C97BC[v2];
        v5 = flt_100C97B8[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100C97C8[v2 * 4]);
        v7 = sub_1004B380(
               0,
               *(&dword_100C887C + dword_100C97C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"900",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100C97C4[v2]],
               *(_DWORD *)&off_100C97C8[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"900",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"900",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C97B8: using guessed type float flt_100C97B8[];
// 100C97BC: using guessed type float flt_100C97BC[];
// 100C97C0: using guessed type float flt_100C97C0[];
// 100C97C4: using guessed type int dword_100C97C4[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003B550) --------------------------------------------------------
char sub_1003B550()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"922", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"922",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10965DD2 )
  {
    sub_1004F060(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"930",
      (int)"Check ptr for equality",
      (int)sub_1003B550,
      (int)sub_1003B550,
      (int)"This test is expected to fail");
    sub_1004F060(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"931",
      (int)"Check ptr for inequality",
      (int)sub_1003B550,
      0,
      (int)"This test is expected to fail");
    result = sub_1004F060(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"932",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1003B550,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"926",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003B650) --------------------------------------------------------
char sub_1003B650()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"959", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"959",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100C9F6C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100C9F68[v2];
        v4 = dword_100C9F64[v2];
        v5 = dword_100C9F60[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100C9F70)[v2 * 4]);
        v7 = sub_1004B840(
               0,
               *(&dword_100C887C + dword_100C9F6C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"959",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100C9F6C[v2]],
               (&off_100C9F70)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"959",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"959",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100C9F60: using guessed type int dword_100C9F60[];
// 100C9F64: using guessed type int dword_100C9F64[];
// 100C9F68: using guessed type int dword_100C9F68[];
// 100C9F6C: using guessed type int dword_100C9F6C[];
// 100C9F70: using guessed type char *off_100C9F70;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003B7B0) --------------------------------------------------------
char sub_1003B7B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"985", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"985",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CA700[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100CA6FC[v2 / 2];
        v4 = word_100CA6FA[v2 / 2];
        v5 = word_100CA6F8[v2 / 2];
        v6 = sub_1004A6E0(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100CA704)[v2]);
        v7 = sub_1004BC00(
               0,
               *(&dword_100C887C + dword_100CA700[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"985",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CA700[v2 / 4]],
               (&off_100CA704)[v2]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"985",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"985",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CA6F8: using guessed type __int16 word_100CA6F8[];
// 100CA6FA: using guessed type __int16 word_100CA6FA[];
// 100CA6FC: using guessed type __int16 word_100CA6FC[];
// 100CA700: using guessed type int dword_100CA700[];
// 100CA704: using guessed type char *off_100CA704;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003B910) --------------------------------------------------------
char sub_1003B910()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1011", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1011",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CAD14[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100CAD10[v2];
        v4 = dword_100CAD0C[v2];
        v5 = dword_100CAD08[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100CAD18[v2 * 4]);
        v7 = sub_1004C000(
               0,
               *(&dword_100C887C + dword_100CAD14[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1011",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CAD14[v2]],
               *(_DWORD *)&off_100CAD18[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1011",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1011",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CAD08: using guessed type int dword_100CAD08[];
// 100CAD0C: using guessed type int dword_100CAD0C[];
// 100CAD10: using guessed type int dword_100CAD10[];
// 100CAD14: using guessed type int dword_100CAD14[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003BA70) --------------------------------------------------------
char sub_1003BA70()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1037", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1037",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CB4B8[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100CB4B4[v2];
        LODWORD(v3) = dword_100CB4B0[v2];
        HIDWORD(v4) = dword_100CB4AC[v2];
        LODWORD(v4) = dword_100CB4A8[v2];
        HIDWORD(v5) = dword_100CB4A4[v2];
        LODWORD(v5) = dword_100CB4A0[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100CB4BC[v2 * 4]);
        v7 = sub_1004C3C0(
               0,
               *(&dword_100C887C + dword_100CB4B8[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1037",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CB4B8[v2]],
               *(_DWORD *)&off_100CB4BC[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1037",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1037",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CB4A0: using guessed type int dword_100CB4A0[];
// 100CB4A4: using guessed type int dword_100CB4A4[];
// 100CB4A8: using guessed type int dword_100CB4A8[];
// 100CB4AC: using guessed type int dword_100CB4AC[];
// 100CB4B0: using guessed type int dword_100CB4B0[];
// 100CB4B4: using guessed type int dword_100CB4B4[];
// 100CB4B8: using guessed type int dword_100CB4B8[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003BBE0) --------------------------------------------------------
char sub_1003BBE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1063", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1063",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CC0C4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100CC0C2[v2 * 4];
        v4 = byte_100CC0C1[v2 * 4];
        v5 = byte_100CC0C0[v2 * 4];
        v6 = sub_1004A6E0(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100CC0C8)[v2 * 4]);
        v7 = sub_1004C900(
               0,
               *(&dword_100C887C + dword_100CC0C4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1063",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CC0C4[v2]],
               (&off_100CC0C8)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1063",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1063",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CC0C4: using guessed type int dword_100CC0C4[];
// 100CC0C8: using guessed type char *off_100CC0C8;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003BD40) --------------------------------------------------------
char sub_1003BD40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1089", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1089",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CC55C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100CC558[v2];
        v4 = dword_100CC554[v2];
        v5 = dword_100CC550[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100CC560)[v2 * 4]);
        v7 = sub_1004CCE0(
               0,
               *(&dword_100C887C + dword_100CC55C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1089",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CC55C[v2]],
               (&off_100CC560)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1089",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1089",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CC550: using guessed type int dword_100CC550[];
// 100CC554: using guessed type int dword_100CC554[];
// 100CC558: using guessed type int dword_100CC558[];
// 100CC55C: using guessed type int dword_100CC55C[];
// 100CC560: using guessed type char *off_100CC560;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003BEA0) --------------------------------------------------------
char sub_1003BEA0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1113", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1113",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10965DD2 )
  {
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1121", 2, 2);
    v2 = sub_1004F110(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1122",
           (int)"UTF_verify_eq_str( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_10080D49,
           (int)"This test is expected to fail");
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1123",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1125", 2, 2);
    v3 = sub_1004F110(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1126",
           (int)"UTF_verify_eq_str( *, \"\", \"a\" ) data comparison",
           &byte_10080D49,
           "a",
           (int)"This test is expected to fail");
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1127",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1129", 2, 2);
    v4 = sub_1004F110(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1130",
           (int)"UTF_verify_ne_str( *, \"\", \"\" ) data comparison",
           &byte_10080D49,
           &byte_10080D49,
           (int)"This test is expected to fail");
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1131",
      (int)"Return value from previous UTF_verify_ne_str() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1133", 2, 2);
    v5 = sub_1004F110(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1134",
           (int)"UTF_verify_ne_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           (int)"This test is expected to fail");
    result = sub_1004AA40(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1135",
               (int)"Return value from previous UTF_verify_ne_str() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1117",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003C0C0) --------------------------------------------------------
char sub_1003C0C0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1162", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1162",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CCCF4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100CCCF0[v2];
        v4 = dword_100CCCEC[v2];
        v5 = dword_100CCCE8[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100CCCF8[v2 * 4]);
        v7 = sub_1004D0A0(
               0,
               *(&dword_100C887C + dword_100CCCF4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1162",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CCCF4[v2]],
               *(_DWORD *)&off_100CCCF8[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1162",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1162",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CCCE8: using guessed type int dword_100CCCE8[];
// 100CCCEC: using guessed type int dword_100CCCEC[];
// 100CCCF0: using guessed type int dword_100CCCF0[];
// 100CCCF4: using guessed type int dword_100CCCF4[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003C220) --------------------------------------------------------
char sub_1003C220()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1188", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1188",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CD060[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100CD05C[v2 / 2];
        v4 = word_100CD05A[v2 / 2];
        v5 = word_100CD058[v2 / 2];
        v6 = sub_1004A6E0(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100CD064)[v2]);
        v7 = sub_1004D440(
               0,
               *(&dword_100C887C + dword_100CD060[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1188",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CD060[v2 / 4]],
               (&off_100CD064)[v2]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1188",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1188",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CD058: using guessed type __int16 word_100CD058[];
// 100CD05A: using guessed type __int16 word_100CD05A[];
// 100CD05C: using guessed type __int16 word_100CD05C[];
// 100CD060: using guessed type int dword_100CD060[];
// 100CD064: using guessed type char *off_100CD064;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003C380) --------------------------------------------------------
char sub_1003C380()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1214", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1214",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CD324[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100CD320[v2];
        v4 = dword_100CD31C[v2];
        v5 = dword_100CD318[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100CD328[v2 * 4]);
        v7 = sub_1004D840(
               0,
               *(&dword_100C887C + dword_100CD324[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1214",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CD324[v2]],
               *(_DWORD *)&off_100CD328[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1214",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1214",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CD318: using guessed type int dword_100CD318[];
// 100CD31C: using guessed type int dword_100CD31C[];
// 100CD320: using guessed type int dword_100CD320[];
// 100CD324: using guessed type int dword_100CD324[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003C4E0) --------------------------------------------------------
char sub_1003C4E0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1240", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1240",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CD6A0[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100CD69C[v2];
        LODWORD(v3) = dword_100CD698[v2];
        HIDWORD(v4) = dword_100CD694[v2];
        LODWORD(v4) = dword_100CD690[v2];
        HIDWORD(v5) = dword_100CD68C[v2];
        LODWORD(v5) = dword_100CD688[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100CD6A4)[v2 * 4]);
        v7 = sub_1004DBE0(
               0,
               *(&dword_100C887C + dword_100CD6A0[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1240",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CD6A0[v2]],
               (&off_100CD6A4)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1240",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1240",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CD688: using guessed type int dword_100CD688[];
// 100CD68C: using guessed type int dword_100CD68C[];
// 100CD690: using guessed type int dword_100CD690[];
// 100CD694: using guessed type int dword_100CD694[];
// 100CD698: using guessed type int dword_100CD698[];
// 100CD69C: using guessed type int dword_100CD69C[];
// 100CD6A0: using guessed type int dword_100CD6A0[];
// 100CD6A4: using guessed type char *off_100CD6A4;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003C650) --------------------------------------------------------
char sub_1003C650()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1266", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1266",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CDC0C[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100CDC0A[v2 * 4];
        v4 = byte_100CDC09[v2 * 4];
        v5 = byte_100CDC08[v2 * 4];
        v6 = sub_1004A6E0(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100CDC10)[v2 * 4]);
        v7 = sub_1004E1C0(
               0,
               *(&dword_100C887C + dword_100CDC0C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1266",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CDC0C[v2]],
               (&off_100CDC10)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1266",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1266",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CDC0C: using guessed type int dword_100CDC0C[];
// 100CDC10: using guessed type char *off_100CDC10;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003C7B0) --------------------------------------------------------
char sub_1003C7B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1292", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1292",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CDE24[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100CDE20[v2];
        v4 = dword_100CDE1C[v2];
        v5 = dword_100CDE18[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100CDE28[v2 * 4]);
        v7 = sub_1004E5B0(
               0,
               *(&dword_100C887C + dword_100CDE24[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1292",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CDE24[v2]],
               *(_DWORD *)&off_100CDE28[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       0,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1292",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1292",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CDE18: using guessed type int dword_100CDE18[];
// 100CDE1C: using guessed type int dword_100CDE1C[];
// 100CDE20: using guessed type int dword_100CDE20[];
// 100CDE24: using guessed type int dword_100CDE24[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003C910) --------------------------------------------------------
char sub_1003C910()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  char *v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  unsigned __int8 v6; // ST14_1@7
  char *v7; // ST38_4@8
  char *v8; // ST34_4@8
  char *v9; // eax@8
  unsigned __int8 v10; // ST14_1@8
  char v11; // [sp+4h] [bp-204h]@5
  char v12; // [sp+104h] [bp-104h]@5

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"All Fail Robustness Test Group For Type 'bitmap'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1337", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1337",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10965DD2 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100CE18C + v2) )
      {
        sub_1004A440((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100CE194[v2], 0x100u, &v11);
        sub_1004A440((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100CE18C + v2), 0x100u, &v12);
        sub_1005A480(&v12, &v11);
      }
      if ( byte_100CE188[v2] )
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1362", 2, 2);
        v3 = off_100CE190[v2 / 4];
        v4 = *(char **)&off_100CE194[v2];
        v5 = sub_1004A6E0(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100CE194[v2],
               off_100CE190[v2 / 4]);
        v6 = sub_1004ED60(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1367",
               (int)v5,
               (int)v4,
               (int)v3,
               0xFEFEu,
               (int)"This test is expected to fail");
        result = sub_1004AA40(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1369",
                   (int)"Return value from previous UTF_verify_eq_bitmap_rt() call",
                   v6,
                   1u,
                   (int)"This test is expected to fail");
      }
      else
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1373", 2, 2);
        v7 = off_100CE190[v2 / 4];
        v8 = *(char **)&off_100CE194[v2];
        v9 = sub_1004A6E0(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100CE194[v2],
               off_100CE190[v2 / 4]);
        v10 = sub_1004ED60(
                1,
                1,
                (int)"..\\lib\\utf\\utf_validate.c",
                (int)"1378",
                (int)v9,
                (int)v8,
                (int)v7,
                0xFEFEu,
                (int)"This test is expected to fail");
        result = sub_1004AA40(
                   1,
                   0,
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1380",
                   (int)"Return value from previous UTF_verify_ne_bitmap_rt() call",
                   v10,
                   1u,
                   (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x90 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1341",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 100CE18C: using guessed type void *off_100CE18C;
// 100CE190: using guessed type char *off_100CE190[2];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003CB30) --------------------------------------------------------
char sub_1003CB30()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"All Fail Test Group For Type 'boolean'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1407", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1407",
    (int)"Verify relationship between boolean values using the UTF_verify_bool_rt() function");
  if ( byte_10965DD2 )
  {
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1415", 2, 2);
    v2 = sub_1004AA40(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1416",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           (int)"This test is expected to fail");
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1417",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      (int)"This test is expected to fail");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1419", 2, 2);
    v3 = sub_1004AA40(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1420",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           (int)"This test is expected to fail");
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1421",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      (int)"This test is expected to fail");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1423", 2, 2);
    v4 = sub_1004AA40(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1424",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           (int)"This test is expected to fail");
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1425",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      (int)"This test is expected to fail");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1427", 2, 2);
    v5 = sub_1004AA40(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1428",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           (int)"This test is expected to fail");
    result = sub_1004AA40(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1429",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               (int)"This test is expected to fail");
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1411",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003CD30) --------------------------------------------------------
char sub_1003CD30()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1469", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1469",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CE21C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1469", 2, 2);
        v3 = byte_100CE219[v2 * 4];
        v4 = byte_100CE218[v2 * 4];
        v5 = sub_1004A6E0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + dword_100CE21C[v2])],
               (&off_100CE220)[v2 * 4]);
        v6 = sub_1004AB80(
               1,
               *(&dword_100C887C + dword_100CE21C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1469",
               (int)v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v7 = sub_1004A6E0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CE21C[v2]],
               (&off_100CE220)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1469",
                       (int)v7,
                       v6,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1469",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CE21C: using guessed type int dword_100CE21C[];
// 100CE220: using guessed type char *off_100CE220;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003CEB0) --------------------------------------------------------
char sub_1003CEB0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@5
  double v4; // ST2C_8@5
  double v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"All Fail Test Group For Type 'double'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1503", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1503",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CE4A0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = dbl_100CE498[v2 / 8];
        v4 = dbl_100CE490[v2 / 8];
        v5 = dbl_100CE488[v2 / 8];
        v6 = sub_1004A6E0(
               "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100CE4A4)[v2]);
        v7 = sub_1004AF30(
               1,
               *(&dword_100C887C + dword_100CE4A0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1503",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CE4A0[v2 / 4]],
               (&off_100CE4A4)[v2]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1503",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 32;
    }
    while ( v2 < 0xC20 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1503",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CE488: using guessed type double dbl_100CE488[];
// 100CE490: using guessed type double dbl_100CE490[];
// 100CE498: using guessed type double dbl_100CE498[];
// 100CE4A0: using guessed type int dword_100CE4A0[];
// 100CE4A4: using guessed type char *off_100CE4A4;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003D030) --------------------------------------------------------
char sub_1003D030()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@5
  float v4; // ST34_4@5
  float v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"All Fail Test Group For Type 'float'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1539", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1539",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CF0B4[v2];
      if ( v0 != 6 )
      {
        v3 = flt_100CF0B0[v2];
        v4 = flt_100CF0AC[v2];
        v5 = flt_100CF0A8[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100CF0B8[v2 * 4]);
        v7 = sub_1004B380(
               1,
               *(&dword_100C887C + dword_100CF0B4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1539",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CF0B4[v2]],
               *(_DWORD *)&off_100CF0B8[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1539",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1539",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CF0A8: using guessed type float flt_100CF0A8[];
// 100CF0AC: using guessed type float flt_100CF0AC[];
// 100CF0B0: using guessed type float flt_100CF0B0[];
// 100CF0B4: using guessed type int dword_100CF0B4[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003D1A0) --------------------------------------------------------
char sub_1003D1A0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1561", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1561",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10965DD2 )
  {
    sub_1004F060(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1569",
      (int)"Check ptr for equality",
      (int)sub_1003D1A0,
      (int)sub_1003D1A0,
      0);
    sub_1004F060(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1570",
      (int)"Check ptr for inequality",
      (int)sub_1003D1A0,
      0,
      0);
    result = sub_1004F060(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1571",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1003D1A0,
               0);
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1565",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003D290) --------------------------------------------------------
char sub_1003D290()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"All Fail Test Group For Type 'signed int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1598", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1598",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CF84C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100CF848[v2];
        v4 = dword_100CF844[v2];
        v5 = dword_100CF840[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100CF850)[v2 * 4]);
        v7 = sub_1004B840(
               1,
               *(&dword_100C887C + dword_100CF84C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1598",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CF84C[v2]],
               (&off_100CF850)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1598",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1598",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CF840: using guessed type int dword_100CF840[];
// 100CF844: using guessed type int dword_100CF844[];
// 100CF848: using guessed type int dword_100CF848[];
// 100CF84C: using guessed type int dword_100CF84C[];
// 100CF850: using guessed type char *off_100CF850;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003D3F0) --------------------------------------------------------
char sub_1003D3F0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@5
  __int16 v4; // ST34_2@5
  __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"All Fail Test Group For Type 'sint16'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1624", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1624",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100CFFE0[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100CFFDC[v2 / 2];
        v4 = word_100CFFDA[v2 / 2];
        v5 = word_100CFFD8[v2 / 2];
        v6 = sub_1004A6E0(
               "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100CFFE4)[v2]);
        v7 = sub_1004BC00(
               1,
               *(&dword_100C887C + dword_100CFFE0[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1624",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100CFFE0[v2 / 4]],
               (&off_100CFFE4)[v2]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1624",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1624",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100CFFD8: using guessed type __int16 word_100CFFD8[];
// 100CFFDA: using guessed type __int16 word_100CFFDA[];
// 100CFFDC: using guessed type __int16 word_100CFFDC[];
// 100CFFE0: using guessed type int dword_100CFFE0[];
// 100CFFE4: using guessed type char *off_100CFFE4;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003D550) --------------------------------------------------------
char sub_1003D550()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"All Fail Test Group For Type 'sint32'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1650", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1650",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D05F4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100D05F0[v2];
        v4 = dword_100D05EC[v2];
        v5 = dword_100D05E8[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100D05F8[v2 * 4]);
        v7 = sub_1004C000(
               1,
               *(&dword_100C887C + dword_100D05F4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1650",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D05F4[v2]],
               *(_DWORD *)&off_100D05F8[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1650",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1650",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D05E8: using guessed type int dword_100D05E8[];
// 100D05EC: using guessed type int dword_100D05EC[];
// 100D05F0: using guessed type int dword_100D05F0[];
// 100D05F4: using guessed type int dword_100D05F4[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003D6B0) --------------------------------------------------------
char sub_1003D6B0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@5
  __int64 v4; // ST2C_8@5
  __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"All Fail Test Group For Type 'sint64'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1676", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1676",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D0D98[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100D0D94[v2];
        LODWORD(v3) = dword_100D0D90[v2];
        HIDWORD(v4) = dword_100D0D8C[v2];
        LODWORD(v4) = dword_100D0D88[v2];
        HIDWORD(v5) = dword_100D0D84[v2];
        LODWORD(v5) = dword_100D0D80[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100D0D9C[v2 * 4]);
        v7 = sub_1004C3C0(
               1,
               *(&dword_100C887C + dword_100D0D98[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1676",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D0D98[v2]],
               *(_DWORD *)&off_100D0D9C[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1676",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1676",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D0D80: using guessed type int dword_100D0D80[];
// 100D0D84: using guessed type int dword_100D0D84[];
// 100D0D88: using guessed type int dword_100D0D88[];
// 100D0D8C: using guessed type int dword_100D0D8C[];
// 100D0D90: using guessed type int dword_100D0D90[];
// 100D0D94: using guessed type int dword_100D0D94[];
// 100D0D98: using guessed type int dword_100D0D98[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003D820) --------------------------------------------------------
char sub_1003D820()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@5
  char v4; // ST34_1@5
  char v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"All Fail Test Group For Type 'sint8'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1702", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1702",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D19A4[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100D19A2[v2 * 4];
        v4 = byte_100D19A1[v2 * 4];
        v5 = byte_100D19A0[v2 * 4];
        v6 = sub_1004A6E0(
               "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100D19A8)[v2 * 4]);
        v7 = sub_1004C900(
               1,
               *(&dword_100C887C + dword_100D19A4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1702",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D19A4[v2]],
               (&off_100D19A8)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1702",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1702",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D19A4: using guessed type int dword_100D19A4[];
// 100D19A8: using guessed type char *off_100D19A8;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003D980) --------------------------------------------------------
char sub_1003D980()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@5
  int v4; // ST34_4@5
  int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"All Fail Test Group For Type 'signed long int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1728", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1728",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D1E3C[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100D1E38[v2];
        v4 = dword_100D1E34[v2];
        v5 = dword_100D1E30[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100D1E40)[v2 * 4]);
        v7 = sub_1004CCE0(
               1,
               *(&dword_100C887C + dword_100D1E3C[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1728",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D1E3C[v2]],
               (&off_100D1E40)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1728",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1728",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D1E30: using guessed type int dword_100D1E30[];
// 100D1E34: using guessed type int dword_100D1E34[];
// 100D1E38: using guessed type int dword_100D1E38[];
// 100D1E3C: using guessed type int dword_100D1E3C[];
// 100D1E40: using guessed type char *off_100D1E40;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003DAE0) --------------------------------------------------------
char sub_1003DAE0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"All Fail Test Group For Type 'string'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1752", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1752",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10965DD2 )
  {
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1760", 2, 2);
    v2 = sub_1004F110(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1761",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_10080D49,
           0);
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1762",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1764", 2, 2);
    v3 = sub_1004F110(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1765",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"a\" ) data comparison",
           &byte_10080D49,
           "a",
           0);
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1766",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1768", 2, 2);
    v4 = sub_1004F110(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1769",
           (int)"UTF_verify_ne_str_rt( *, \"\", \"\" ) data comparison",
           &byte_10080D49,
           &byte_10080D49,
           0);
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1770",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1772", 2, 2);
    v5 = sub_1004F110(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"1773",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    result = sub_1004AA40(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1774",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1756",
               (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return result;
}
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003DCE0) --------------------------------------------------------
char sub_1003DCE0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"All Fail Test Group For Type 'unsigned int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1801", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1801",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D25D4[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100D25D0[v2];
        v4 = dword_100D25CC[v2];
        v5 = dword_100D25C8[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100D25D8[v2 * 4]);
        v7 = sub_1004D0A0(
               1,
               *(&dword_100C887C + dword_100D25D4[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1801",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D25D4[v2]],
               *(_DWORD *)&off_100D25D8[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1801",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1801",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D25C8: using guessed type int dword_100D25C8[];
// 100D25CC: using guessed type int dword_100D25CC[];
// 100D25D0: using guessed type int dword_100D25D0[];
// 100D25D4: using guessed type int dword_100D25D4[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003DE40) --------------------------------------------------------
char sub_1003DE40()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@5
  unsigned __int16 v4; // ST34_2@5
  unsigned __int16 v5; // ST30_2@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"All Fail Test Group For Type 'uint16'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1827", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1827",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D2940[v2 / 4];
      if ( v0 != 6 )
      {
        v3 = word_100D293C[v2 / 2];
        v4 = word_100D293A[v2 / 2];
        v5 = word_100D2938[v2 / 2];
        v6 = sub_1004A6E0(
               "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100D2944)[v2]);
        v7 = sub_1004D440(
               1,
               *(&dword_100C887C + dword_100D2940[v2 / 4]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1827",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D2940[v2 / 4]],
               (&off_100D2944)[v2]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1827",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1827",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D2938: using guessed type __int16 word_100D2938[];
// 100D293A: using guessed type __int16 word_100D293A[];
// 100D293C: using guessed type __int16 word_100D293C[];
// 100D2940: using guessed type int dword_100D2940[];
// 100D2944: using guessed type char *off_100D2944;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003DFA0) --------------------------------------------------------
char sub_1003DFA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"All Fail Test Group For Type 'uint32'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1853", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1853",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D2C04[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100D2C00[v2];
        v4 = dword_100D2BFC[v2];
        v5 = dword_100D2BF8[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100D2C08[v2 * 4]);
        v7 = sub_1004D840(
               1,
               *(&dword_100C887C + dword_100D2C04[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1853",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D2C04[v2]],
               *(_DWORD *)&off_100D2C08[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1853",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1853",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D2BF8: using guessed type int dword_100D2BF8[];
// 100D2BFC: using guessed type int dword_100D2BFC[];
// 100D2C00: using guessed type int dword_100D2C00[];
// 100D2C04: using guessed type int dword_100D2C04[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003E100) --------------------------------------------------------
char sub_1003E100()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@5
  unsigned __int64 v4; // ST2C_8@5
  unsigned __int64 v5; // ST24_8@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"All Fail Test Group For Type 'uint64'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1879", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1879",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D2F80[v2];
      if ( v0 != 6 )
      {
        HIDWORD(v3) = dword_100D2F7C[v2];
        LODWORD(v3) = dword_100D2F78[v2];
        HIDWORD(v4) = dword_100D2F74[v2];
        LODWORD(v4) = dword_100D2F70[v2];
        HIDWORD(v5) = dword_100D2F6C[v2];
        LODWORD(v5) = dword_100D2F68[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100D2F84)[v2 * 4]);
        v7 = sub_1004DBE0(
               1,
               *(&dword_100C887C + dword_100D2F80[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1879",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D2F80[v2]],
               (&off_100D2F84)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1879",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1879",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D2F68: using guessed type int dword_100D2F68[];
// 100D2F6C: using guessed type int dword_100D2F6C[];
// 100D2F70: using guessed type int dword_100D2F70[];
// 100D2F74: using guessed type int dword_100D2F74[];
// 100D2F78: using guessed type int dword_100D2F78[];
// 100D2F7C: using guessed type int dword_100D2F7C[];
// 100D2F80: using guessed type int dword_100D2F80[];
// 100D2F84: using guessed type char *off_100D2F84;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003E270) --------------------------------------------------------
char sub_1003E270()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@5
  unsigned __int8 v4; // ST34_1@5
  unsigned __int8 v5; // ST30_1@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"All Fail Test Group For Type 'uint8'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1905", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1905",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D34EC[v2];
      if ( v0 != 6 )
      {
        v3 = byte_100D34EA[v2 * 4];
        v4 = byte_100D34E9[v2 * 4];
        v5 = byte_100D34E8[v2 * 4];
        v6 = sub_1004A6E0(
               "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               (&off_100D34F0)[v2 * 4]);
        v7 = sub_1004E1C0(
               1,
               *(&dword_100C887C + dword_100D34EC[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1905",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D34EC[v2]],
               (&off_100D34F0)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1905",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1905",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D34EC: using guessed type int dword_100D34EC[];
// 100D34F0: using guessed type char *off_100D34F0;
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003E3D0) --------------------------------------------------------
char sub_1003E3D0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@5
  unsigned int v4; // ST34_4@5
  unsigned int v5; // ST30_4@5
  char *v6; // eax@5
  bool v7; // ST34_1@5
  char *v8; // eax@5

  if ( byte_10965DD2 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"All Fail Test Group For Type 'unsigned long int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1931", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1931",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D3704[v2];
      if ( v0 != 6 )
      {
        v3 = dword_100D3700[v2];
        v4 = dword_100D36FC[v2];
        v5 = dword_100D36F8[v2];
        v6 = sub_1004A6E0(
               "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * *(&dword_100C887C + v0)],
               *(_DWORD *)&off_100D3708[v2 * 4]);
        v7 = sub_1004E5B0(
               1,
               *(&dword_100C887C + dword_100D3704[v2]),
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1931",
               (int)v6,
               v5,
               v4,
               v3,
               (int)"This test is expected to fail");
        v8 = sub_1004A6E0(
               "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D3704[v2]],
               *(_DWORD *)&off_100D3708[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(
                       1,
                       0,
                       (int)"..\\lib\\utf\\utf_validate.c",
                       (int)"1931",
                       (int)v8,
                       v7,
                       1u,
                       (int)"This test is expected to fail");
      }
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"1931",
                   (int)"Failing tests currently disabled. Use FAIL ON command to enable");
  }
  return v0;
}
// 100D36F8: using guessed type int dword_100D36F8[];
// 100D36FC: using guessed type int dword_100D36FC[];
// 100D3700: using guessed type int dword_100D3700[];
// 100D3704: using guessed type int dword_100D3704[];
// 10965DD2: using guessed type char byte_10965DD2;

//----- (1003E530) --------------------------------------------------------
char sub_1003E530()
{
  const char *v0; // eax@1
  int v1; // esi@1
  char result; // al@2
  char v3; // al@5

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"All Pass Miscellaneous Test Group");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1968", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"1968",
    (int)"Verify miscellaneous macros");
  v1 = 5;
  if ( byte_10965DD3 )
  {
    sub_1004F110(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"1978",
      (int)"Check PASS macro",
      "UTF_verify_pass unconditional pass",
      "UTF_verify_pass unconditional pass",
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1987", 0, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1988", (int)"Sub-group A, msg 1");
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1989", (int)"Sub-group A, msg 2");
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1990", (int)"Sub-group A, msg 3");
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1991", (int)"Sub-group A, msg 4");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1993", 0, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1994", (int)"Sub-group B, msg 1");
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1995", (int)"Sub-group B, msg 2");
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"1996", (int)"Sub-group B, msg 3");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"1998", 1, 2);
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"1999", (int)"Sub-group C verify 1", 1, 1, 0, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2000", (int)"Sub-group C, msg 1");
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2001", (int)"Sub-group C, msg 2");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2003", 2, 2);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2004", (int)"Sub-group D, msg 1");
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2005", (int)"Sub-group D verify 1", 1, 1, 0, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2006", (int)"Sub-group D, msg 2");
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2007", (int)"Sub-group D verify 2", 2, 2, 0, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2009", (int)"non sub-group msg 1");
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2010", (int)"non sub-group msg 2");
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2011", (int)"non sub-group verify 1", 1, 1, 0, 0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2013", 3, 4);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2014", (int)"Sub-group E, msg 1");
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2015", (int)"Sub-group E verify 1", 1, 1, 0, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2016", (int)"Sub-group E, msg 2");
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2017", (int)"Sub-group E verify 2", 2, 2, 0, 0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2019", 3, 4);
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2020", (int)"Sub-group F verify 1", 1, 1, 0, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2021", (int)"Sub-group F, msg 1");
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2022", (int)"Sub-group F verify 2", 2, 2, 0, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2023", (int)"Sub-group F, msg 2");
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2025", 4, 0);
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2026", (int)"Sub-group G verify 1", 1, 1, 0, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2027", (int)"Sub-group G, msg 1");
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2028", (int)"Sub-group G, msg 2");
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2029", (int)"Sub-group G verify 2", 2, 2, 0, 0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2030", 5, 0);
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2032", (int)"non sub-group msg 3");
    sub_10049C80(3, (int)"**MSG**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2033", (int)"non sub-group msg 4");
    sub_1004B840(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2034", (int)"non sub-group verify 2", 2, 2, 0, 0);
    if ( !sub_100486E0() )
      v1 = 3;
    sub_1004B840(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2037",
      (int)"Verify x is 3 using UTF_CALL_UNIT",
      v1,
      3,
      0,
      0);
    v3 = sub_100486E0();
    sub_1004B840(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2040",
      (int)"Verify x is 4 using UTF_CALL_UNIT2",
      v3 != 0 ? 6 : 4,
      4,
      0,
      0);
    sub_10049C80(
      3,
      (int)"**MSG**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2042",
      (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceeds the int"
           "ernal UTF buffer size, can be written to the output without the system crashing or otherwise demonstrating ha"
           "rmful side-effects. If the system does crash while writing this message, it is a sign that possibly the UTF h"
           "as some buffer overlow issues that should be examined and corrected. If the system runs successfully, it does"
           " not prove the UTF is defect free in this regard, only that this particular scenario is succesfully handled u"
           "nder the current conditions. Other invocations of UTF interfaces with large messages may be problematic, but "
           "at least on the surface, things seem to be OK for now.");
    result = sub_1004B840(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2043",
               (int)"This message is intended to demonstrate that a very long message, one so long in fact that it exceed"
                    "s the internal UTF buffer size, can be written to the output without the system crashing or otherwis"
                    "e demonstrating harmful side-effects. If the system does crash while writing this message, it is a s"
                    "ign that possibly the UTF has some buffer overlow issues that should be examined and corrected. If t"
                    "he system runs successfully, it does not prove the UTF is defect free in this regard, only that this"
                    " particular scenario is succesfully handled under the current conditions. Other invocations of UTF i"
                    "nterfaces with large messages may be problematic, but at least on the surface, things seem to be OK for now.",
               4,
               4,
               0,
               0);
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"1974",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003EAD0) --------------------------------------------------------
char sub_1003EAD0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"All Pass Test Group For Type 'bitmap'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2085", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2085",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10965DD3 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100D3A6C + v2) )
      {
        sub_1004A440((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100D3A74[v2], 0x100u, &v13);
        sub_1004A440((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100D3A6C + v2), 0x100u, &v14);
        sub_1005A480(&v14, &v13);
      }
      if ( byte_100D3A68[v2] )
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2110", 2, 2);
        v3 = *(int *)((char *)&off_100D3A70 + v2);
        v4 = *(char **)&off_100D3A74[v2];
        v5 = sub_1004A6E0(
               "UTF_verify_eq_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100D3A74[v2],
               *(void **)((char *)&off_100D3A70 + v2));
        v12 = 1;
        v11 = sub_1004ED60(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2114", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap() call";
        v9 = "2115";
      }
      else
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2119", 2, 2);
        v6 = *(int *)((char *)&off_100D3A70 + v2);
        v7 = *(char **)&off_100D3A74[v2];
        v8 = sub_1004A6E0(
               "UTF_verify_ne_bitmap( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100D3A74[v2],
               *(void **)((char *)&off_100D3A70 + v2));
        v12 = 1;
        v11 = sub_1004ED60(0, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2123", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap() call";
        v9 = "2124";
      }
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2089",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D3A6C: using guessed type void *off_100D3A6C;
// 100D3A70: using guessed type void *off_100D3A70;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003ECE0) --------------------------------------------------------
char sub_1003ECE0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2151", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2151",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10965DD3 )
  {
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2159", 2, 2);
    v2 = sub_1004AA40(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2160",
           (int)"UTF_verify_eq_bool( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2161",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v2,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2163", 2, 2);
    v3 = sub_1004AA40(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2164",
           (int)"UTF_verify_eq_bool( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2165",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v3,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2167", 2, 2);
    v4 = sub_1004AA40(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2168",
           (int)"UTF_verify_ne_bool( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2169",
      (int)"Return value from previous UTF_verify_eq_bool() call",
      v4,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2171", 2, 2);
    v5 = sub_1004AA40(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2172",
           (int)"UTF_verify_eq_bool( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1004AA40(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2173",
               (int)"Return value from previous UTF_verify_eq_bool() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2155",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003EED0) --------------------------------------------------------
char sub_1003EED0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2213",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D3ABC[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2213", 2, 2);
        v3 = byte_100D3AB9[v2 * 4];
        v4 = byte_100D3AB8[v2 * 4];
        v5 = sub_1004A6E0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * dword_100D3ABC[v2]],
               (&off_100D3AC0)[v2 * 4]);
        v6 = sub_1004AB80(0, dword_100D3ABC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v5, v4, v3, 0);
        v7 = sub_1004A6E0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D3ABC[v2]],
               (&off_100D3AC0)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2213", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2213",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100D3ABC: using guessed type int dword_100D3ABC[];
// 100D3AC0: using guessed type char *off_100D3AC0;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003F040) --------------------------------------------------------
char sub_1003F040()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2247",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2247", 2, 2);
      v3 = dbl_100D3D38[v2 / 2];
      v4 = dbl_100D3D30[v2 / 2];
      v5 = dbl_100D3D28[v2 / 2];
      v6 = sub_1004A6E0(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D3D40[v2]],
             (&off_100D3D44)[v2 * 4]);
      v7 = sub_1004AF30(0, dword_100D3D40[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D3D40[v2]],
             (&off_100D3D44)[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2247", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2247",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D3D28: using guessed type double dbl_100D3D28[];
// 100D3D30: using guessed type double dbl_100D3D30[];
// 100D3D38: using guessed type double dbl_100D3D38[];
// 100D3D40: using guessed type int dword_100D3D40[];
// 100D3D44: using guessed type char *off_100D3D44;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003F1B0) --------------------------------------------------------
char sub_1003F1B0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2283",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2283", 2, 2);
      v3 = flt_100D4950[v2];
      v4 = flt_100D494C[v2];
      v5 = flt_100D4948[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D4954[v2]],
             *(_DWORD *)&off_100D4958[v2 * 4]);
      v7 = sub_1004B380(0, dword_100D4954[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D4954[v2]],
             *(_DWORD *)&off_100D4958[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2283", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2283",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D4948: using guessed type float flt_100D4948[];
// 100D494C: using guessed type float flt_100D494C[];
// 100D4950: using guessed type float flt_100D4950[];
// 100D4954: using guessed type int dword_100D4954[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003F310) --------------------------------------------------------
char sub_1003F310()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2305", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2305",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10965DD3 )
  {
    sub_1004F060(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2313",
      (int)"Check ptr for equality",
      (int)sub_1003F310,
      (int)sub_1003F310,
      0);
    sub_1004F060(
      0,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2314",
      (int)"Check ptr for inequality",
      (int)sub_1003F310,
      0,
      0);
    result = sub_1004F060(
               0,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2315",
               (int)"Check ptr for inequality",
               0,
               (int)sub_1003F310,
               0);
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2309",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003F400) --------------------------------------------------------
char sub_1003F400()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2342",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2342", 2, 2);
      v3 = dword_100D50E8[v2];
      v4 = dword_100D50E4[v2];
      v5 = dword_100D50E0[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D50EC[v2]],
             (&off_100D50F0)[v2 * 4]);
      v7 = sub_1004B840(0, dword_100D50EC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D50EC[v2]],
             (&off_100D50F0)[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2342", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2342",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D50E0: using guessed type int dword_100D50E0[];
// 100D50E4: using guessed type int dword_100D50E4[];
// 100D50E8: using guessed type int dword_100D50E8[];
// 100D50EC: using guessed type int dword_100D50EC[];
// 100D50F0: using guessed type char *off_100D50F0;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003F560) --------------------------------------------------------
char sub_1003F560()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2368",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2368", 2, 2);
      v3 = word_100D587C[v2 / 2];
      v4 = word_100D587A[v2 / 2];
      v5 = word_100D5878[v2 / 2];
      v6 = sub_1004A6E0(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D5880[v2 / 4]],
             (&off_100D5884)[v2]);
      v7 = sub_1004BC00(
             0,
             dword_100D5880[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2368",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D5880[v2 / 4]],
             (&off_100D5884)[v2]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2368", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2368",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D5878: using guessed type __int16 word_100D5878[];
// 100D587A: using guessed type __int16 word_100D587A[];
// 100D587C: using guessed type __int16 word_100D587C[];
// 100D5880: using guessed type int dword_100D5880[];
// 100D5884: using guessed type char *off_100D5884;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003F6C0) --------------------------------------------------------
char sub_1003F6C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2394",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2394", 2, 2);
      v3 = dword_100D5E90[v2];
      v4 = dword_100D5E8C[v2];
      v5 = dword_100D5E88[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D5E94[v2]],
             *(_DWORD *)&off_100D5E98[v2 * 4]);
      v7 = sub_1004C000(0, dword_100D5E94[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D5E94[v2]],
             *(_DWORD *)&off_100D5E98[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2394", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2394",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D5E88: using guessed type int dword_100D5E88[];
// 100D5E8C: using guessed type int dword_100D5E8C[];
// 100D5E90: using guessed type int dword_100D5E90[];
// 100D5E94: using guessed type int dword_100D5E94[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003F820) --------------------------------------------------------
char sub_1003F820()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2420",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2420", 2, 2);
      HIDWORD(v3) = dword_100D6634[v2];
      LODWORD(v3) = dword_100D6630[v2];
      HIDWORD(v4) = dword_100D662C[v2];
      LODWORD(v4) = dword_100D6628[v2];
      HIDWORD(v5) = dword_100D6624[v2];
      LODWORD(v5) = dword_100D6620[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D6638[v2]],
             *(_DWORD *)&off_100D663C[v2 * 4]);
      v7 = sub_1004C3C0(0, dword_100D6638[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D6638[v2]],
             *(_DWORD *)&off_100D663C[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2420", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2420",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D6620: using guessed type int dword_100D6620[];
// 100D6624: using guessed type int dword_100D6624[];
// 100D6628: using guessed type int dword_100D6628[];
// 100D662C: using guessed type int dword_100D662C[];
// 100D6630: using guessed type int dword_100D6630[];
// 100D6634: using guessed type int dword_100D6634[];
// 100D6638: using guessed type int dword_100D6638[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003F990) --------------------------------------------------------
char sub_1003F990()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2446",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2446", 2, 2);
      v3 = byte_100D7242[v2 * 4];
      v4 = byte_100D7241[v2 * 4];
      v5 = byte_100D7240[v2 * 4];
      v6 = sub_1004A6E0(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D7244[v2]],
             (&off_100D7248)[v2 * 4]);
      v7 = sub_1004C900(0, dword_100D7244[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D7244[v2]],
             (&off_100D7248)[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2446", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2446",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D7244: using guessed type int dword_100D7244[];
// 100D7248: using guessed type char *off_100D7248;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003FAF0) --------------------------------------------------------
char sub_1003FAF0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2472",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2472", 2, 2);
      v3 = dword_100D76D8[v2];
      v4 = dword_100D76D4[v2];
      v5 = dword_100D76D0[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D76DC[v2]],
             (&off_100D76E0)[v2 * 4]);
      v7 = sub_1004CCE0(0, dword_100D76DC[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D76DC[v2]],
             (&off_100D76E0)[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2472", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2472",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D76D0: using guessed type int dword_100D76D0[];
// 100D76D4: using guessed type int dword_100D76D4[];
// 100D76D8: using guessed type int dword_100D76D8[];
// 100D76DC: using guessed type int dword_100D76DC[];
// 100D76E0: using guessed type char *off_100D76E0;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003FC50) --------------------------------------------------------
char sub_1003FC50()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2496", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2496",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10965DD3 )
  {
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2504", 2, 2);
    v2 = sub_1004F110(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2505",
           (int)"UTF_verify_eq_str( *, \"\", \"\" ) data comparison",
           &byte_10080D49,
           &byte_10080D49,
           0);
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2506",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v2,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2508", 2, 2);
    v3 = sub_1004F110(
           0,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2509",
           (int)"UTF_verify_eq_str( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2510",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v3,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2512", 2, 2);
    v4 = sub_1004F110(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2513",
           (int)"UTF_verify_ne_str( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_10080D49,
           0);
    sub_1004AA40(
      0,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2514",
      (int)"Return value from previous UTF_verify_eq_str() call",
      v4,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2516", 2, 2);
    v5 = sub_1004F110(
           0,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2517",
           (int)"UTF_verify_ne_str( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1004AA40(
               0,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2518",
               (int)"Return value from previous UTF_verify_eq_str() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2500",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003FE50) --------------------------------------------------------
char sub_1003FE50()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2545",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2545", 2, 2);
      v3 = dword_100D7E70[v2];
      v4 = dword_100D7E6C[v2];
      v5 = dword_100D7E68[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D7E74[v2]],
             *(_DWORD *)&off_100D7E78[v2 * 4]);
      v7 = sub_1004D0A0(0, dword_100D7E74[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D7E74[v2]],
             *(_DWORD *)&off_100D7E78[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2545", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2545",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D7E68: using guessed type int dword_100D7E68[];
// 100D7E6C: using guessed type int dword_100D7E6C[];
// 100D7E70: using guessed type int dword_100D7E70[];
// 100D7E74: using guessed type int dword_100D7E74[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (1003FFB0) --------------------------------------------------------
char sub_1003FFB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2571",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2571", 2, 2);
      v3 = word_100D81DC[v2 / 2];
      v4 = word_100D81DA[v2 / 2];
      v5 = word_100D81D8[v2 / 2];
      v6 = sub_1004A6E0(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D81E0[v2 / 4]],
             (&off_100D81E4)[v2]);
      v7 = sub_1004D440(
             0,
             dword_100D81E0[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2571",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D81E0[v2 / 4]],
             (&off_100D81E4)[v2]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2571", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2571",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D81D8: using guessed type __int16 word_100D81D8[];
// 100D81DA: using guessed type __int16 word_100D81DA[];
// 100D81DC: using guessed type __int16 word_100D81DC[];
// 100D81E0: using guessed type int dword_100D81E0[];
// 100D81E4: using guessed type char *off_100D81E4;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10040110) --------------------------------------------------------
char sub_10040110()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2597",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2597", 2, 2);
      v3 = dword_100D84A0[v2];
      v4 = dword_100D849C[v2];
      v5 = dword_100D8498[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D84A4[v2]],
             *(_DWORD *)&off_100D84A8[v2 * 4]);
      v7 = sub_1004D840(0, dword_100D84A4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D84A4[v2]],
             *(_DWORD *)&off_100D84A8[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2597", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2597",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D8498: using guessed type int dword_100D8498[];
// 100D849C: using guessed type int dword_100D849C[];
// 100D84A0: using guessed type int dword_100D84A0[];
// 100D84A4: using guessed type int dword_100D84A4[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10040270) --------------------------------------------------------
char sub_10040270()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2623",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2623", 2, 2);
      HIDWORD(v3) = dword_100D881C[v2];
      LODWORD(v3) = dword_100D8818[v2];
      HIDWORD(v4) = dword_100D8814[v2];
      LODWORD(v4) = dword_100D8810[v2];
      HIDWORD(v5) = dword_100D880C[v2];
      LODWORD(v5) = dword_100D8808[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D8820[v2]],
             (&off_100D8824)[v2 * 4]);
      v7 = sub_1004DBE0(0, dword_100D8820[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D8820[v2]],
             (&off_100D8824)[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2623", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2623",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D8808: using guessed type int dword_100D8808[];
// 100D880C: using guessed type int dword_100D880C[];
// 100D8810: using guessed type int dword_100D8810[];
// 100D8814: using guessed type int dword_100D8814[];
// 100D8818: using guessed type int dword_100D8818[];
// 100D881C: using guessed type int dword_100D881C[];
// 100D8820: using guessed type int dword_100D8820[];
// 100D8824: using guessed type char *off_100D8824;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (100403E0) --------------------------------------------------------
char sub_100403E0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2649",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2649", 2, 2);
      v3 = byte_100D8D8A[v2 * 4];
      v4 = byte_100D8D89[v2 * 4];
      v5 = byte_100D8D88[v2 * 4];
      v6 = sub_1004A6E0(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D8D8C[v2]],
             (&off_100D8D90)[v2 * 4]);
      v7 = sub_1004E1C0(0, dword_100D8D8C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D8D8C[v2]],
             (&off_100D8D90)[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2649", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2649",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D8D8C: using guessed type int dword_100D8D8C[];
// 100D8D90: using guessed type char *off_100D8D90;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10040540) --------------------------------------------------------
char sub_10040540()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2675",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2675", 2, 2);
      v3 = dword_100D8FA0[v2];
      v4 = dword_100D8F9C[v2];
      v5 = dword_100D8F98[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D8FA4[v2]],
             *(_DWORD *)&off_100D8FA8[v2 * 4]);
      v7 = sub_1004E5B0(0, dword_100D8FA4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D8FA4[v2]],
             *(_DWORD *)&off_100D8FA8[v2 * 4]);
      result = sub_1004AA40(0, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2675", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2675",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D8F98: using guessed type int dword_100D8F98[];
// 100D8F9C: using guessed type int dword_100D8F9C[];
// 100D8FA0: using guessed type int dword_100D8FA0[];
// 100D8FA4: using guessed type int dword_100D8FA4[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (100406A0) --------------------------------------------------------
char sub_100406A0()
{
  const char *v0; // eax@1
  char result; // al@2
  unsigned int v2; // esi@3
  int v3; // ST38_4@7
  char *v4; // ST34_4@7
  char *v5; // eax@7
  int v6; // ST38_4@8
  char *v7; // ST34_4@8
  char *v8; // eax@8
  const char *v9; // [sp-3Ch] [bp-244h]@7
  const char *v10; // [sp-38h] [bp-240h]@7
  unsigned __int8 v11; // [sp-34h] [bp-23Ch]@7
  unsigned __int8 v12; // [sp-30h] [bp-238h]@7
  char v13; // [sp+4h] [bp-204h]@5
  char v14; // [sp+104h] [bp-104h]@5

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"All Pass Robustness Test Group For Type 'bitmap'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2716", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2716",
    (int)"Verify relationship between bitmap files using the UTF_verify_bitmap() function");
  if ( byte_10965DD3 )
  {
    v2 = 0;
    do
    {
      if ( *(void **)((char *)&off_100D930C + v2) )
      {
        sub_1004A440((int)"..\\lib\\utf\\utf_validate.c", 1, *(_DWORD *)&off_100D9314[v2], 0x100u, &v13);
        sub_1004A440((int)"..\\lib\\utf\\utf_validate.c", 2, *(int *)((char *)&off_100D930C + v2), 0x100u, &v14);
        sub_1005A480(&v14, &v13);
      }
      if ( byte_100D9308[v2] )
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2741", 2, 2);
        v3 = *(int *)((char *)&off_100D9310 + v2);
        v4 = *(char **)&off_100D9314[v2];
        v5 = sub_1004A6E0(
               "UTF_verify_eq_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100D9314[v2],
               *(void **)((char *)&off_100D9310 + v2));
        v12 = 1;
        v11 = sub_1004ED60(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2745", (int)v5, (int)v4, v3, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_eq_bitmap_rt() call";
        v9 = "2746";
      }
      else
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2750", 2, 2);
        v6 = *(int *)((char *)&off_100D9310 + v2);
        v7 = *(char **)&off_100D9314[v2];
        v8 = sub_1004A6E0(
               "UTF_verify_ne_bitmap_rt( *, \"%s\", \"%s\" ) data comparison",
               *(_DWORD *)&off_100D9314[v2],
               *(void **)((char *)&off_100D9310 + v2));
        v12 = 1;
        v11 = sub_1004ED60(1, 1, (int)"..\\lib\\utf\\utf_validate.c", (int)"2754", (int)v8, (int)v7, v6, 0xFEFEu, 0);
        v10 = "Return value from previous UTF_verify_ne_bitmap_rt() call";
        v9 = "2755";
      }
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)v9, (int)v10, v11, v12, 0);
      v2 += 16;
    }
    while ( v2 < 0x50 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2720",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D930C: using guessed type void *off_100D930C;
// 100D9310: using guessed type void *off_100D9310;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (100408B0) --------------------------------------------------------
char sub_100408B0()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"All Pass Test Group For Type 'boolean'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2782", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2782",
    (int)"Verify relationship between boolean values using the UTF_verify_bool() function");
  if ( byte_10965DD3 )
  {
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2790", 2, 2);
    v2 = sub_1004AA40(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2791",
           (int)"UTF_verify_eq_bool_rt( *, FALSE, FALSE ) data comparison",
           0,
           0,
           0);
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2792",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v2,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2794", 2, 2);
    v3 = sub_1004AA40(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2795",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, TRUE ) data comparison",
           1u,
           1u,
           0);
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2796",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v3,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2798", 2, 2);
    v4 = sub_1004AA40(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2799",
           (int)"UTF_verify_ne_bool_rt( *, FALSE, TRUE ) data comparison",
           0,
           1u,
           0);
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2800",
      (int)"Return value from previous UTF_verify_eq_bool_rt() call",
      v4,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2802", 2, 2);
    v5 = sub_1004AA40(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"2803",
           (int)"UTF_verify_eq_bool_rt( *, TRUE, FALSE ) data comparison",
           1u,
           0,
           0);
    result = sub_1004AA40(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2804",
               (int)"Return value from previous UTF_verify_eq_bool_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2786",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10040AA0) --------------------------------------------------------
char sub_10040AA0()
{
  int v0; // eax@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@6
  unsigned __int8 v4; // ST34_1@6
  char *v5; // eax@6
  bool v6; // ST34_1@6
  char *v7; // eax@6

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"All Pass Test Group For Type 'char'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2844",
      (int)"Verify relationship between char values using the UTF_verify_char() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      v0 = dword_100D935C[v2];
      if ( !v0 || v0 == 1 )
      {
        sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2844", 2, 2);
        v3 = byte_100D9359[v2 * 4];
        v4 = byte_100D9358[v2 * 4];
        v5 = sub_1004A6E0(
               "UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
               *(_DWORD *)&off_100C8860[4 * dword_100D935C[v2]],
               (&off_100D9360)[v2 * 4]);
        v6 = sub_1004AB80(1, dword_100D935C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v5, v4, v3, 0);
        v7 = sub_1004A6E0(
               "Return value from previous UTF_verify_char( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
               *(_DWORD *)&off_100C8860[4 * dword_100D935C[v2]],
               (&off_100D9360)[v2 * 4]);
        LOBYTE(v0) = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2844", (int)v7, v6, 1u, 0);
      }
      v2 += 3;
    }
    while ( v2 < 156 );
  }
  else
  {
    LOBYTE(v0) = sub_10049C80(
                   3,
                   (int)"**MSG**",
                   (int)"..\\lib\\utf\\utf_validate.c",
                   (int)"2844",
                   (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return v0;
}
// 100D935C: using guessed type int dword_100D935C[];
// 100D9360: using guessed type char *off_100D9360;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10040C10) --------------------------------------------------------
char sub_10040C10()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  double v3; // ST34_8@4
  double v4; // ST2C_8@4
  double v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"All Pass Test Group For Type 'double'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2878",
      (int)"Verify relationship between double values using the UTF_verify_double() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2878", 2, 2);
      v3 = dbl_100D95D8[v2 / 2];
      v4 = dbl_100D95D0[v2 / 2];
      v5 = dbl_100D95C8[v2 / 2];
      v6 = sub_1004A6E0(
             "UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100D95E0[v2]],
             (&off_100D95E4)[v2 * 4]);
      v7 = sub_1004AF30(1, dword_100D95E0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_double( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100D95E0[v2]],
             (&off_100D95E4)[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2878", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2878",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100D95C8: using guessed type double dbl_100D95C8[];
// 100D95D0: using guessed type double dbl_100D95D0[];
// 100D95D8: using guessed type double dbl_100D95D8[];
// 100D95E0: using guessed type int dword_100D95E0[];
// 100D95E4: using guessed type char *off_100D95E4;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10040D80) --------------------------------------------------------
char sub_10040D80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  float v3; // ST38_4@4
  float v4; // ST34_4@4
  float v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"All Pass Test Group For Type 'float'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2914",
      (int)"Verify relationship between float values using the UTF_verify_float() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2914", 2, 2);
      v3 = flt_100DA1F0[v2];
      v4 = flt_100DA1EC[v2];
      v5 = flt_100DA1E8[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DA1F4[v2]],
             *(_DWORD *)&off_100DA1F8[v2 * 4]);
      v7 = sub_1004B380(1, dword_100DA1F4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_float( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DA1F4[v2]],
             *(_DWORD *)&off_100DA1F8[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2914", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2914",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DA1E8: using guessed type float flt_100DA1E8[];
// 100DA1EC: using guessed type float flt_100DA1EC[];
// 100DA1F0: using guessed type float flt_100DA1F0[];
// 100DA1F4: using guessed type int dword_100DA1F4[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10040EE0) --------------------------------------------------------
char sub_10040EE0()
{
  const char *v0; // eax@1
  char result; // al@2

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"All Pass Test Group For Type 'void *'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2936", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"2936",
    (int)"Verify relationship between pointer values using the UTF_verify_ptr() function");
  if ( byte_10965DD3 )
  {
    sub_1004F060(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2944",
      (int)"Check ptr for equality",
      (int)sub_10040EE0,
      (int)sub_10040EE0,
      0);
    sub_1004F060(
      1,
      1,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2945",
      (int)"Check ptr for inequality",
      (int)sub_10040EE0,
      0,
      0);
    result = sub_1004F060(
               1,
               1,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2946",
               (int)"Check ptr for inequality",
               0,
               (int)sub_10040EE0,
               0);
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2940",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10040FD0) --------------------------------------------------------
char sub_10040FD0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"All Pass Test Group For Type 'signed int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2973",
      (int)"Verify relationship between signed int values using the UTF_verify_signed int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2973", 2, 2);
      v3 = dword_100DA988[v2];
      v4 = dword_100DA984[v2];
      v5 = dword_100DA980[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DA98C[v2]],
             (&off_100DA990)[v2 * 4]);
      v7 = sub_1004B840(1, dword_100DA98C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DA98C[v2]],
             (&off_100DA990)[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2973", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2973",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DA980: using guessed type int dword_100DA980[];
// 100DA984: using guessed type int dword_100DA984[];
// 100DA988: using guessed type int dword_100DA988[];
// 100DA98C: using guessed type int dword_100DA98C[];
// 100DA990: using guessed type char *off_100DA990;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10041130) --------------------------------------------------------
char sub_10041130()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int16 v3; // ST38_2@4
  __int16 v4; // ST34_2@4
  __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"All Pass Test Group For Type 'sint16'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"2999",
      (int)"Verify relationship between sint16 values using the UTF_verify_sint16() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"2999", 2, 2);
      v3 = word_100DB11C[v2 / 2];
      v4 = word_100DB11A[v2 / 2];
      v5 = word_100DB118[v2 / 2];
      v6 = sub_1004A6E0(
             "UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DB120[v2 / 4]],
             (&off_100DB124)[v2]);
      v7 = sub_1004BC00(
             1,
             dword_100DB120[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"2999",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DB120[v2 / 4]],
             (&off_100DB124)[v2]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"2999", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x610 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"2999",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DB118: using guessed type __int16 word_100DB118[];
// 100DB11A: using guessed type __int16 word_100DB11A[];
// 100DB11C: using guessed type __int16 word_100DB11C[];
// 100DB120: using guessed type int dword_100DB120[];
// 100DB124: using guessed type char *off_100DB124;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10041290) --------------------------------------------------------
char sub_10041290()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"All Pass Test Group For Type 'sint32'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3025",
      (int)"Verify relationship between sint32 values using the UTF_verify_sint32() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3025", 2, 2);
      v3 = dword_100DB730[v2];
      v4 = dword_100DB72C[v2];
      v5 = dword_100DB728[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DB734[v2]],
             *(_DWORD *)&off_100DB738[v2 * 4]);
      v7 = sub_1004C000(1, dword_100DB734[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DB734[v2]],
             *(_DWORD *)&off_100DB738[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3025", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3025",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DB728: using guessed type int dword_100DB728[];
// 100DB72C: using guessed type int dword_100DB72C[];
// 100DB730: using guessed type int dword_100DB730[];
// 100DB734: using guessed type int dword_100DB734[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (100413F0) --------------------------------------------------------
char sub_100413F0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  __int64 v3; // ST34_8@4
  __int64 v4; // ST2C_8@4
  __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"All Pass Test Group For Type 'sint64'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3051",
      (int)"Verify relationship between sint64 values using the UTF_verify_sint64() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3051", 2, 2);
      HIDWORD(v3) = dword_100DBED4[v2];
      LODWORD(v3) = dword_100DBED0[v2];
      HIDWORD(v4) = dword_100DBECC[v2];
      LODWORD(v4) = dword_100DBEC8[v2];
      HIDWORD(v5) = dword_100DBEC4[v2];
      LODWORD(v5) = dword_100DBEC0[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DBED8[v2]],
             *(_DWORD *)&off_100DBEDC[v2 * 4]);
      v7 = sub_1004C3C0(1, dword_100DBED8[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DBED8[v2]],
             *(_DWORD *)&off_100DBEDC[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3051", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 776 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3051",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DBEC0: using guessed type int dword_100DBEC0[];
// 100DBEC4: using guessed type int dword_100DBEC4[];
// 100DBEC8: using guessed type int dword_100DBEC8[];
// 100DBECC: using guessed type int dword_100DBECC[];
// 100DBED0: using guessed type int dword_100DBED0[];
// 100DBED4: using guessed type int dword_100DBED4[];
// 100DBED8: using guessed type int dword_100DBED8[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10041560) --------------------------------------------------------
char sub_10041560()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  char v3; // ST38_1@4
  char v4; // ST34_1@4
  char v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"All Pass Test Group For Type 'sint8'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3077",
      (int)"Verify relationship between sint8 values using the UTF_verify_sint8() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3077", 2, 2);
      v3 = byte_100DCAE2[v2 * 4];
      v4 = byte_100DCAE1[v2 * 4];
      v5 = byte_100DCAE0[v2 * 4];
      v6 = sub_1004A6E0(
             "UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DCAE4[v2]],
             (&off_100DCAE8)[v2 * 4]);
      v7 = sub_1004C900(1, dword_100DCAE4[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_sint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DCAE4[v2]],
             (&off_100DCAE8)[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3077", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 291 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3077",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DCAE4: using guessed type int dword_100DCAE4[];
// 100DCAE8: using guessed type char *off_100DCAE8;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (100416C0) --------------------------------------------------------
char sub_100416C0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  signed int v3; // ST38_4@4
  int v4; // ST34_4@4
  int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"All Pass Test Group For Type 'signed long int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3103",
      (int)"Verify relationship between signed long int values using the UTF_verify_signed long int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3103", 2, 2);
      v3 = dword_100DCF78[v2];
      v4 = dword_100DCF74[v2];
      v5 = dword_100DCF70[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DCF7C[v2]],
             (&off_100DCF80)[v2 * 4]);
      v7 = sub_1004CCE0(1, dword_100DCF7C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_slong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DCF7C[v2]],
             (&off_100DCF80)[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3103", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 485 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3103",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DCF70: using guessed type int dword_100DCF70[];
// 100DCF74: using guessed type int dword_100DCF74[];
// 100DCF78: using guessed type int dword_100DCF78[];
// 100DCF7C: using guessed type int dword_100DCF7C[];
// 100DCF80: using guessed type char *off_100DCF80;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10041820) --------------------------------------------------------
char sub_10041820()
{
  const char *v0; // eax@1
  char result; // al@2
  bool v2; // al@3
  bool v3; // al@3
  bool v4; // al@3
  bool v5; // ST50_1@3

  sub_10049C80(
    3,
    (int)"**TITLE**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"All Pass Test Group For Type 'string'");
  v0 = sub_1004A5D0(0);
  sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3127", (int)v0);
  sub_10049C80(
    3,
    (int)"**METHOD**",
    (int)"..\\lib\\utf\\utf_validate.c",
    (int)"3127",
    (int)"Verify relationship between string values using the UTF_verify_str() function");
  if ( byte_10965DD3 )
  {
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3135", 2, 2);
    v2 = sub_1004F110(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3136",
           (int)"UTF_verify_eq_str_rt( *, \"\", \"\" ) data comparison",
           &byte_10080D49,
           &byte_10080D49,
           0);
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3137",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v2,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3139", 2, 2);
    v3 = sub_1004F110(
           1,
           0,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3140",
           (int)"UTF_verify_eq_str_rt( *, \"a\", \"a\" ) data comparison",
           "a",
           "a",
           0);
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3141",
      (int)"Return value from previous UTF_verify_eq_str_rt() call",
      v3,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3143", 2, 2);
    v4 = sub_1004F110(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3144",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"\" ) data comparison",
           "a",
           &byte_10080D49,
           0);
    sub_1004AA40(
      1,
      0,
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3145",
      (int)"Return value from previous UTF_verify_ne_str_rt() call",
      v4,
      1u,
      0);
    sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3147", 2, 2);
    v5 = sub_1004F110(
           1,
           1,
           (int)"..\\lib\\utf\\utf_validate.c",
           (int)"3148",
           (int)"UTF_verify_ne_str_rt( *, \"a\", \"b\" ) data comparison",
           "a",
           "b",
           0);
    result = sub_1004AA40(
               1,
               0,
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3149",
               (int)"Return value from previous UTF_verify_ne_str_rt() call",
               v5,
               1u,
               0);
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3131",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10041A20) --------------------------------------------------------
char sub_10041A20()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"All Pass Test Group For Type 'unsigned int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3176",
      (int)"Verify relationship between unsigned int values using the UTF_verify_unsigned int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3176", 2, 2);
      v3 = dword_100DD710[v2];
      v4 = dword_100DD70C[v2];
      v5 = dword_100DD708[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DD714[v2]],
             *(_DWORD *)&off_100DD718[v2 * 4]);
      v7 = sub_1004D0A0(1, dword_100DD714[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DD714[v2]],
             *(_DWORD *)&off_100DD718[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3176", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3176",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DD708: using guessed type int dword_100DD708[];
// 100DD70C: using guessed type int dword_100DD70C[];
// 100DD710: using guessed type int dword_100DD710[];
// 100DD714: using guessed type int dword_100DD714[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10041B80) --------------------------------------------------------
char sub_10041B80()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int16 v3; // ST38_2@4
  unsigned __int16 v4; // ST34_2@4
  unsigned __int16 v5; // ST30_2@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"All Pass Test Group For Type 'uint16'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3202",
      (int)"Verify relationship between uint16 values using the UTF_verify_uint16() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3202", 2, 2);
      v3 = word_100DDA7C[v2 / 2];
      v4 = word_100DDA7A[v2 / 2];
      v5 = word_100DDA78[v2 / 2];
      v6 = sub_1004A6E0(
             "UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DDA80[v2 / 4]],
             (&off_100DDA84)[v2]);
      v7 = sub_1004D440(
             1,
             dword_100DDA80[v2 / 4],
             (int)"..\\lib\\utf\\utf_validate.c",
             (int)"3202",
             (int)v6,
             v5,
             v4,
             v3,
             0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint16( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DDA80[v2 / 4]],
             (&off_100DDA84)[v2]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3202", (int)v8, v7, 1u, 0);
      v2 += 16;
    }
    while ( v2 < 0x2C0 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3202",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DDA78: using guessed type __int16 word_100DDA78[];
// 100DDA7A: using guessed type __int16 word_100DDA7A[];
// 100DDA7C: using guessed type __int16 word_100DDA7C[];
// 100DDA80: using guessed type int dword_100DDA80[];
// 100DDA84: using guessed type char *off_100DDA84;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10041CE0) --------------------------------------------------------
char sub_10041CE0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"All Pass Test Group For Type 'uint32'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3228",
      (int)"Verify relationship between uint32 values using the UTF_verify_uint32() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3228", 2, 2);
      v3 = dword_100DDD40[v2];
      v4 = dword_100DDD3C[v2];
      v5 = dword_100DDD38[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DDD44[v2]],
             *(_DWORD *)&off_100DDD48[v2 * 4]);
      v7 = sub_1004D840(1, dword_100DDD44[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint32( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DDD44[v2]],
             *(_DWORD *)&off_100DDD48[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3228", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3228",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DDD38: using guessed type int dword_100DDD38[];
// 100DDD3C: using guessed type int dword_100DDD3C[];
// 100DDD40: using guessed type int dword_100DDD40[];
// 100DDD44: using guessed type int dword_100DDD44[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10041E40) --------------------------------------------------------
char sub_10041E40()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int64 v3; // ST34_8@4
  unsigned __int64 v4; // ST2C_8@4
  unsigned __int64 v5; // ST24_8@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"All Pass Test Group For Type 'uint64'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3254",
      (int)"Verify relationship between uint64 values using the UTF_verify_uint64() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3254", 2, 2);
      HIDWORD(v3) = dword_100DE0BC[v2];
      LODWORD(v3) = dword_100DE0B8[v2];
      HIDWORD(v4) = dword_100DE0B4[v2];
      LODWORD(v4) = dword_100DE0B0[v2];
      HIDWORD(v5) = dword_100DE0AC[v2];
      LODWORD(v5) = dword_100DE0A8[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DE0C0[v2]],
             (&off_100DE0C4)[v2 * 4]);
      v7 = sub_1004DBE0(1, dword_100DE0C0[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint64( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DE0C0[v2]],
             (&off_100DE0C4)[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3254", (int)v8, v7, 1u, 0);
      v2 += 8;
    }
    while ( v2 < 352 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3254",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DE0A8: using guessed type int dword_100DE0A8[];
// 100DE0AC: using guessed type int dword_100DE0AC[];
// 100DE0B0: using guessed type int dword_100DE0B0[];
// 100DE0B4: using guessed type int dword_100DE0B4[];
// 100DE0B8: using guessed type int dword_100DE0B8[];
// 100DE0BC: using guessed type int dword_100DE0BC[];
// 100DE0C0: using guessed type int dword_100DE0C0[];
// 100DE0C4: using guessed type char *off_100DE0C4;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10041FB0) --------------------------------------------------------
char sub_10041FB0()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned __int8 v3; // ST38_1@4
  unsigned __int8 v4; // ST34_1@4
  unsigned __int8 v5; // ST30_1@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"All Pass Test Group For Type 'uint8'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3280",
      (int)"Verify relationship between uint8 values using the UTF_verify_uint8() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3280", 2, 2);
      v3 = byte_100DE62A[v2 * 4];
      v4 = byte_100DE629[v2 * 4];
      v5 = byte_100DE628[v2 * 4];
      v6 = sub_1004A6E0(
             "UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DE62C[v2]],
             (&off_100DE630)[v2 * 4]);
      v7 = sub_1004E1C0(1, dword_100DE62C[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_uint8( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DE62C[v2]],
             (&off_100DE630)[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3280", (int)v8, v7, 1u, 0);
      v2 += 3;
    }
    while ( v2 < 132 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3280",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DE62C: using guessed type int dword_100DE62C[];
// 100DE630: using guessed type char *off_100DE630;
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10042110) --------------------------------------------------------
char sub_10042110()
{
  char result; // al@2
  const char *v1; // eax@3
  unsigned int v2; // esi@3
  unsigned int v3; // ST38_4@4
  unsigned int v4; // ST34_4@4
  unsigned int v5; // ST30_4@4
  char *v6; // eax@4
  bool v7; // ST34_1@4
  char *v8; // eax@4

  if ( byte_10965DD3 )
  {
    sub_10049C80(
      3,
      (int)"**TITLE**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"All Pass Test Group For Type 'unsigned long int'");
    v1 = sub_1004A5D0(0);
    sub_10049C80(3, (int)"**TYPE**", (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v1);
    sub_10049C80(
      3,
      (int)"**METHOD**",
      (int)"..\\lib\\utf\\utf_validate.c",
      (int)"3306",
      (int)"Verify relationship between unsigned long int values using the UTF_verify_unsigned long int() function");
    sub_1004A6C0(0);
    v2 = 0;
    do
    {
      sub_1004A5F0((int)"..\\lib\\utf\\utf_validate.c", (int)"3306", 2, 2);
      v3 = dword_100DE840[v2];
      v4 = dword_100DE83C[v2];
      v5 = dword_100DE838[v2];
      v6 = sub_1004A6E0(
             "UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s )",
             *(_DWORD *)&off_100C8860[4 * dword_100DE844[v2]],
             *(_DWORD *)&off_100DE848[v2 * 4]);
      v7 = sub_1004E5B0(1, dword_100DE844[v2], (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v6, v5, v4, v3, 0);
      v8 = sub_1004A6E0(
             "Return value from previous UTF_verify_ulong( *, UTF_CMP_%s, UTF_file, UTF_line, %s ) call",
             *(_DWORD *)&off_100C8860[4 * dword_100DE844[v2]],
             *(_DWORD *)&off_100DE848[v2 * 4]);
      result = sub_1004AA40(1, 0, (int)"..\\lib\\utf\\utf_validate.c", (int)"3306", (int)v8, v7, 1u, 0);
      v2 += 5;
    }
    while ( v2 < 220 );
  }
  else
  {
    result = sub_10049C80(
               3,
               (int)"**MSG**",
               (int)"..\\lib\\utf\\utf_validate.c",
               (int)"3306",
               (int)"Passing tests currently disabled. Use PASS ON command to enable");
  }
  return result;
}
// 100DE838: using guessed type int dword_100DE838[];
// 100DE83C: using guessed type int dword_100DE83C[];
// 100DE840: using guessed type int dword_100DE840[];
// 100DE844: using guessed type int dword_100DE844[];
// 10965DD3: using guessed type char byte_10965DD3;

//----- (10042270) --------------------------------------------------------
char **sub_10042270()
{
  return off_100C9F4C;
}
// 100C9F4C: using guessed type char *off_100C9F4C[3];

//----- (10042290) --------------------------------------------------------
bool sub_10042290()
{
  return sub_10060A00(99) == 0;
}

//----- (100422A0) --------------------------------------------------------
bool sub_100422A0()
{
  return sub_10060A60(99, 10000) == 0;
}

//----- (100422C0) --------------------------------------------------------
int __cdecl sub_100422C0(_BYTE *a1)
{
  int result; // eax@1

  result = (int)a1;
  *a1 = 0;
  if ( !byte_10A09A94 )
    result = (*(int (__cdecl **)(signed int, signed int, _BYTE *))dword_10A09214)(146, 1, a1);
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09A94: using guessed type char byte_10A09A94;

//----- (100422F0) --------------------------------------------------------
char __cdecl sub_100422F0(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  char v3; // [sp+8h] [bp-14h]@2
  unsigned __int8 v4; // [sp+9h] [bp-13h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_10A09A94 )
  {
    (*(void (__cdecl **)(int, signed int, char *))dword_10A09214)(dword_10A09564, 18, &v3);
    result = v4 & 0xF;
    *a2 = v4 >> 4;
    *a1 = result;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09564: using guessed type int dword_10A09564;
// 10A09A94: using guessed type char byte_10A09A94;

//----- (10042340) --------------------------------------------------------
char __cdecl sub_10042340(_BYTE *a1, _BYTE *a2)
{
  char result; // al@2
  unsigned __int8 v3; // [sp+8h] [bp-14h]@2

  *a2 = 0;
  *a1 = 0;
  if ( !byte_10A09A94 )
  {
    (*(void (__cdecl **)(int, signed int, unsigned __int8 *))dword_10A09214)(dword_10A09564, 18, &v3);
    result = v3 & 0xF;
    *a2 = v3 >> 4;
    *a1 = result;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09564: using guessed type int dword_10A09564;
// 10A09A94: using guessed type char byte_10A09A94;

//----- (10042390) --------------------------------------------------------
int sub_10042390()
{
  int result; // eax@1
  unsigned int v1; // ecx@1
  int v2; // edi@4
  int *v3; // esi@5
  int v4; // ebx@5
  int v5; // edx@6
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  unsigned int v8; // [sp+Ch] [bp-4h]@4

  memset(dword_10A09240, 0, 0x708u);
  result = (*(int (__cdecl **)(signed int, int *))dword_10A09204)(512, &v6);
  v1 = 0;
  do
  {
    word_10A09244[v1 / 2] = 0;
    dword_10A09248[v1 / 4] = 0;
    dword_10A09240[v1 / 4] = 0;
    v1 += 12;
  }
  while ( v1 < 0x708 );
  if ( (_BYTE)result )
  {
    dword_10A0924C = v6;
    result = v8;
    v2 = (unsigned __int16)v7 + 512;
    dword_10A09250 = v7;
    dword_10A09254 = v8;
    if ( v8 >= 2 )
    {
      v3 = &dword_10A09258;
      v4 = v8 - 1;
      do
      {
        (*(void (__cdecl **)(int, int *))dword_10A09204)(v2, &v6);
        v5 = v7;
        result = v8;
        *v3 = v6;
        v3[1] = v5;
        v3[2] = result;
        v2 += (unsigned __int16)dword_10A09250;
        v3 += 3;
        --v4;
      }
      while ( v4 );
    }
  }
  return result;
}
// 10A09204: using guessed type int dword_10A09204;
// 10A09240: using guessed type int dword_10A09240[];
// 10A09244: using guessed type __int16 word_10A09244[];
// 10A09248: using guessed type int dword_10A09248[];
// 10A0924C: using guessed type int dword_10A0924C;
// 10A09250: using guessed type int dword_10A09250;
// 10A09254: using guessed type int dword_10A09254;
// 10A09258: using guessed type int dword_10A09258;

//----- (10042460) --------------------------------------------------------
__int16 sub_10042460()
{
  __int16 result; // ax@1
  unsigned int v1; // ebx@1
  unsigned int v2; // esi@1
  int v3; // edi@1
  int v4; // ebp@2
  __int16 v5; // [sp+Ch] [bp-4h]@3

  result = word_10A0925C;
  v1 = dword_10A09260;
  v2 = 1;
  v3 = dword_10A09258;
  if ( (unsigned int)dword_10A09260 >= 1 )
  {
    v4 = (unsigned __int16)word_10A0925C;
    do
    {
      (*(void (__cdecl **)(int, signed int, __int16 *))dword_10A09214)(v3, 2, &v5);
      result = v5;
      word_10A09960[v2++] = v5;
      v3 += v4;
    }
    while ( v2 <= v1 );
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;
// 10A09258: using guessed type int dword_10A09258;
// 10A0925C: using guessed type __int16 word_10A0925C;
// 10A09260: using guessed type int dword_10A09260;
// 10A09960: using guessed type __int16 word_10A09960[];

//----- (100424C0) --------------------------------------------------------
int __usercall sub_100424C0@<eax>(int result@<eax>, _BYTE *a2, signed int a3, int a4)
{
  signed int v4; // edx@1
  _BYTE *v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned __int16 v7; // ax@7

  v4 = 0;
  if ( a3 > 0 )
  {
    v5 = a2;
    v6 = a3;
    do
    {
      if ( v4 & 3 )
      {
        if ( (v4 & 3) == 1 )
        {
          result = v6 >> 4;
        }
        else
        {
          --v5;
          result = (v4 & 3) - 2;
          if ( (v4 & 3) == 2 )
          {
            HIBYTE(v7) = v5[1];
            LOBYTE(v7) = *v5;
            v6 = v7;
            result = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(result) = v6;
          }
        }
      }
      else
      {
        HIWORD(result) = 0;
        BYTE1(result) = *v5--;
        LOBYTE(result) = *v5;
        v6 = (unsigned __int16)result;
        LOWORD(result) = (unsigned __int16)result >> 10;
      }
      LOBYTE(result) = (result & 0x3F) + 32;
      *(_BYTE *)(v4++ + a4) = result;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (10042540) --------------------------------------------------------
signed int __cdecl sub_10042540(int a1)
{
  signed int result; // eax@1
  char v2; // [sp+8h] [bp-10h]@3
  char v3; // [sp+13h] [bp-5h]@3

  result = 538976288;
  *(_DWORD *)a1 = 538976288;
  *(_DWORD *)(a1 + 4) = 538976288;
  *(_DWORD *)(a1 + 8) = 538976288;
  *(_DWORD *)(a1 + 12) = 538976288;
  if ( byte_10A09A94 )
  {
    LOBYTE(dword_10965DD4) = 0;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else if ( (_BYTE)dword_10965DD4 )
  {
    *(_DWORD *)a1 = dword_10965DD4;
    *(_DWORD *)(a1 + 4) = dword_10965DD8;
    *(_DWORD *)(a1 + 8) = dword_10965DDC;
    result = dword_10965DE0;
    *(_DWORD *)(a1 + 12) = dword_10965DE0;
    *(_BYTE *)(a1 + 16) = 0;
  }
  else
  {
    (*(void (__cdecl **)(signed int, signed int, char *))dword_10A09214)(147, 12, &v2);
    sub_100424C0((int)&v3, &v3, 16, a1);
    dword_10965DD4 = *(_DWORD *)a1;
    dword_10965DD8 = *(_DWORD *)(a1 + 4);
    result = *(_DWORD *)(a1 + 8);
    dword_10965DDC = *(_DWORD *)(a1 + 8);
    dword_10965DE0 = *(_DWORD *)(a1 + 12);
    byte_10965DE4 = *(_BYTE *)(a1 + 16);
    *(_BYTE *)(a1 + 16) = 0;
  }
  return result;
}
// 10965DD4: using guessed type int dword_10965DD4;
// 10965DD8: using guessed type int dword_10965DD8;
// 10965DDC: using guessed type int dword_10965DDC;
// 10965DE0: using guessed type int dword_10965DE0;
// 10965DE4: using guessed type char byte_10965DE4;
// 10A09214: using guessed type int dword_10A09214;
// 10A09A94: using guessed type char byte_10A09A94;

//----- (10042630) --------------------------------------------------------
unsigned __int8 sub_10042630()
{
  unsigned __int8 result; // al@1
  unsigned int v1; // edx@2
  char *v2; // ecx@2
  char *v3; // esi@2
  int v4; // edi@6
  int v5; // edx@7
  _BYTE *v6; // ecx@7
  _BYTE *v7; // esi@7
  int v8; // edx@9
  _BYTE *v9; // ecx@9
  _BYTE *v10; // esi@9
  _BYTE *v11; // ecx@11
  _BYTE *v12; // esi@11
  signed int v13; // ecx@13
  char v14; // [sp+0h] [bp-18h]@1

  sub_10042540((int)&v14);
  result = 0;
  do
  {
    v1 = 10;
    v2 = &a006D0170[11 * result];
    v3 = &v14;
    do
    {
      if ( *(_DWORD *)v3 != *(_DWORD *)v2 )
        goto LABEL_6;
      v1 -= 4;
      v2 += 4;
      v3 += 4;
    }
    while ( v1 >= 4 );
    if ( !v1 )
    {
LABEL_15:
      v13 = 0;
      goto LABEL_16;
    }
LABEL_6:
    v4 = (unsigned __int8)*v3 - (unsigned __int8)*v2;
    if ( (unsigned __int8)*v3 == (unsigned __int8)*v2 )
    {
      v5 = v1 - 1;
      v6 = v2 + 1;
      v7 = v3 + 1;
      if ( !v5 )
        goto LABEL_15;
      v4 = *v7 - *v6;
      if ( *v7 == *v6 )
      {
        v8 = v5 - 1;
        v9 = v6 + 1;
        v10 = v7 + 1;
        if ( !v8 )
          goto LABEL_15;
        v4 = *v10 - *v9;
        if ( *v10 == *v9 )
        {
          v11 = v9 + 1;
          v12 = v10 + 1;
          if ( v8 == 1 )
            goto LABEL_15;
          v4 = *v12 - *v11;
          if ( *v12 == *v11 )
            goto LABEL_15;
        }
      }
    }
    v13 = 1;
    if ( v4 <= 0 )
      v13 = -1;
LABEL_16:
    if ( !v13 )
      break;
    ++result;
  }
  while ( result < 3u );
  return result;
}

//----- (10042700) --------------------------------------------------------
char sub_10042700()
{
  char v0; // al@1
  unsigned __int8 v1; // bl@2
  unsigned int v2; // ecx@3
  char *v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // ecx@8
  _BYTE *v7; // eax@8
  _BYTE *v8; // edx@8
  int v9; // ecx@10
  _BYTE *v10; // eax@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // eax@12
  _BYTE *v13; // edx@12
  signed int v14; // eax@14
  char result; // al@24
  char v16; // [sp+Fh] [bp-25h]@20
  char v17; // [sp+10h] [bp-24h]@1
  char v18; // [sp+1Bh] [bp-19h]@2
  char v19; // [sp+1Ch] [bp-18h]@2

  byte_10A09A94 = 1;
  v0 = (*(int (__cdecl **)(signed int, signed int, char *))dword_10A09214)(147, 12, &v17);
  byte_10A09A94 = 1;
  dword_10965DD4 = 0;
  dword_10965DD8 = 0;
  dword_10965DDC = 0;
  dword_10965DE0 = 0;
  byte_10965DE4 = 0;
  if ( !v0 )
    return (unsigned int)memset(dword_10A09240, 0, 0x708u);
  sub_100424C0((int)&v19, &v18, 16, (int)&v19);
  v1 = 0;
  while ( 1 )
  {
    v2 = 10;
    v3 = &a006D0170[11 * v1];
    v4 = &v19;
    do
    {
      if ( *(_DWORD *)v4 != *(_DWORD *)v3 )
        goto LABEL_7;
      v2 -= 4;
      v3 += 4;
      v4 += 4;
    }
    while ( v2 >= 4 );
    if ( !v2 )
    {
LABEL_16:
      v14 = 0;
      goto LABEL_17;
    }
LABEL_7:
    v5 = (unsigned __int8)*v4 - (unsigned __int8)*v3;
    if ( (unsigned __int8)*v4 == (unsigned __int8)*v3 )
    {
      v6 = v2 - 1;
      v7 = v3 + 1;
      v8 = v4 + 1;
      if ( !v6 )
        goto LABEL_16;
      v5 = *v8 - *v7;
      if ( *v8 == *v7 )
      {
        v9 = v6 - 1;
        v10 = v7 + 1;
        v11 = v8 + 1;
        if ( !v9 )
          goto LABEL_16;
        v5 = *v11 - *v10;
        if ( *v11 == *v10 )
        {
          v12 = v10 + 1;
          v13 = v11 + 1;
          if ( v9 == 1 )
            goto LABEL_16;
          v5 = *v13 - *v12;
          if ( *v13 == *v12 )
            goto LABEL_16;
        }
      }
    }
    v14 = 1;
    if ( v5 <= 0 )
      v14 = -1;
LABEL_17:
    if ( !v14 )
      break;
    if ( ++v1 >= 3u )
      return (unsigned int)memset(dword_10A09240, 0, 0x708u);
  }
  byte_10A09A94 = 0;
  sub_100422C0(&v16);
  if ( v16 != 101 )
  {
    byte_10A09A94 = 2;
    return (unsigned int)memset(dword_10A09240, 0, 0x708u);
  }
  if ( byte_10A09A94 )
    return (unsigned int)memset(dword_10A09240, 0, 0x708u);
  sub_10042340(&unk_10A09948, &byte_10A09A8D);
  byte_10A09A8C = byte_10A09A8D - 1;
  if ( byte_10A09A94 )
    return (unsigned int)memset(dword_10A09240, 0, 0x708u);
  result = sub_100422F0(&unk_10A09949, &unk_10A0994A);
  byte_10A0922D = 0;
  if ( byte_10A09A94 )
    return (unsigned int)memset(dword_10A09240, 0, 0x708u);
  return result;
}
// 10965DD4: using guessed type int dword_10965DD4;
// 10965DD8: using guessed type int dword_10965DD8;
// 10965DDC: using guessed type int dword_10965DDC;
// 10965DE0: using guessed type int dword_10965DE0;
// 10965DE4: using guessed type char byte_10965DE4;
// 10A09214: using guessed type int dword_10A09214;
// 10A0922D: using guessed type char byte_10A0922D;
// 10A09240: using guessed type int dword_10A09240[];
// 10A09A8C: using guessed type char byte_10A09A8C;
// 10A09A8D: using guessed type char byte_10A09A8D;
// 10A09A94: using guessed type char byte_10A09A94;

//----- (100428C0) --------------------------------------------------------
int (__cdecl *(*sub_100428C0())[2])(int, int)
{
  int (__cdecl *(*result)[2])(int, int); // eax@1
  unsigned int v1; // edi@2
  char *v2; // ecx@3
  unsigned int v3; // eax@3
  char *v4; // edx@3
  int v5; // esi@7
  int v6; // eax@8
  _BYTE *v7; // ecx@8
  _BYTE *v8; // edx@8
  int v9; // eax@10
  _BYTE *v10; // ecx@10
  _BYTE *v11; // edx@10
  _BYTE *v12; // ecx@12
  _BYTE *v13; // edx@12
  char v14; // [sp+0h] [bp-24h]@1
  char v15; // [sp+Bh] [bp-19h]@2
  char v16; // [sp+Ch] [bp-18h]@2

  dword_10A09204 = (int)off_1011C11C;
  result = (int (__cdecl *(*)[2])(int, int))(*(int (__cdecl **)(signed int, signed int, char *))dword_10A09214)(
                                              147,
                                              12,
                                              &v14);
  if ( (_BYTE)result )
  {
    sub_100424C0((int)&v16, &v15, 16, (int)&v16);
    v1 = 0;
    do
    {
      v2 = (&off_100E2AE4)[8 * v1];
      v3 = strlen((&off_100E2AE4)[8 * v1]);
      v4 = &v16;
      if ( v3 < 4 )
      {
LABEL_6:
        if ( !v3 )
          goto LABEL_16;
      }
      else
      {
        while ( *(_DWORD *)v4 == *(_DWORD *)v2 )
        {
          v3 -= 4;
          v2 += 4;
          v4 += 4;
          if ( v3 < 4 )
            goto LABEL_6;
        }
      }
      v5 = (unsigned __int8)*v4 - (unsigned __int8)*v2;
      if ( (unsigned __int8)*v4 == (unsigned __int8)*v2 )
      {
        v6 = v3 - 1;
        v7 = v2 + 1;
        v8 = v4 + 1;
        if ( !v6
          || (v5 = *v8 - *v7, *v8 == *v7)
          && ((v9 = v6 - 1, v10 = v7 + 1, v11 = v8 + 1, !v9)
           || (v5 = *v11 - *v10, *v11 == *v10)
           && ((v12 = v10 + 1, v13 = v11 + 1, v9 == 1) || (v5 = *v13 - *v12, *v13 == *v12))) )
        {
LABEL_16:
          result = 0;
          goto LABEL_17;
        }
      }
      result = (int (__cdecl *(*)[2])(int, int))1;
      if ( v5 <= 0 )
        result = (int (__cdecl *(*)[2])(int, int))-1;
LABEL_17:
      if ( !result )
      {
        result = (&off_100E2AE8)[v1];
        dword_10A09204 = (int)(&off_100E2AE8)[v1];
        return result;
      }
      ++v1;
    }
    while ( v1 < 3 );
  }
  return result;
}
// 100E2AE4: using guessed type char *off_100E2AE4;
// 100E2AE8: using guessed type int (__cdecl *(*off_100E2AE8)[2])(int, int);
// 1011C11C: using guessed type int (__cdecl *off_1011C11C[2])(int, int);
// 10A09204: using guessed type int dword_10A09204;
// 10A09214: using guessed type int dword_10A09214;

//----- (100429F0) --------------------------------------------------------
signed int __cdecl sub_100429F0(_BYTE *a1, _BYTE *a2, int a3)
{
  int v3; // ebx@1
  signed int result; // eax@1
  _BYTE *v5; // esi@2
  _BYTE *v6; // edi@2

  v3 = a3;
  result = 0;
  if ( a3 > 0 )
  {
    v5 = a1;
    v6 = a2;
    while ( 1 )
    {
      if ( *v5 < *v6 )
        return -1;
      if ( *v5 > *v6 )
        break;
      --v3;
      --v5;
      --v6;
      if ( v3 <= 0 )
        return result;
    }
    result = 1;
  }
  return result;
}

//----- (10042A30) --------------------------------------------------------
signed int __cdecl sub_10042A30(int a1)
{
  signed int result; // eax@1

  result = 0x3FFFF;
  if ( a1 )
  {
    if ( *(_BYTE *)a1 < 0x17u )
      result = *(_DWORD *)(a1 + 36);
  }
  return result;
}

//----- (10042A50) --------------------------------------------------------
unsigned __int8 __cdecl sub_10042A50(const char *a1, int a2)
{
  int v2; // eax@3
  char v3; // cl@4
  _BYTE *v4; // esi@5
  signed int v5; // edi@5
  char v6; // cl@6
  unsigned __int8 result; // al@8
  char v8; // dl@17
  char v9; // dl@17
  char v10; // cl@18
  char v11[8]; // [sp+8h] [bp-Ch]@2

  if ( strlen(a1) > 6 )
  {
    v2 = 0;
    do
    {
      v3 = a______[v2];
      v11[v2++] = v3;
    }
    while ( v3 );
  }
  else
  {
    strcpy(v11, a1);
    sub_1002C0D0(v11, 6u, 32);
  }
  *(_DWORD *)a2 = 0;
  v4 = (_BYTE *)(a2 + 4);
  *(_BYTE *)(a2 + 4) = 0;
  v5 = 0;
  do
  {
    v6 = v11[v5];
    if ( (unsigned __int8)v6 < 0x41u || (unsigned __int8)v6 > 0x5Au )
    {
      if ( (unsigned __int8)v6 < 0x30u || (unsigned __int8)v6 > 0x39u )
        result = v6 == 32 ? 0 : v6;
      else
        result = v6 - 16;
    }
    else
    {
      result = v6 - 64;
    }
    if ( v5 & 3 )
    {
      if ( (v5 & 3) == 1 )
      {
        *v4 = (result >> 4) | *v4 & 0xFC;
        v10 = *(v4-- - 1);
        result *= 16;
        *v4 = result | v10 & 0xF;
        goto LABEL_21;
      }
      if ( (v5 & 3) != 2 )
      {
        *v4 = result | *v4 & 0xC0;
        --v4;
        goto LABEL_21;
      }
      *v4 = (result >> 2) | *v4 & 0xF0;
      v8 = *(v4-- - 1);
      v9 = v8 & 0x3F;
      result <<= 6;
    }
    else
    {
      v9 = *v4 & 3;
      result *= 4;
    }
    *v4 = result | v9;
LABEL_21:
    ++v5;
  }
  while ( v5 < 6 );
  return result;
}
// 10042A50: using guessed type char var_C[8];

//----- (10042B90) --------------------------------------------------------
double __cdecl sub_10042B90(signed int a1, char a2)
{
  return (double)(a1 >> (31 - a2)) / (double)(1 << a2) * 3.1415926535898;
}

//----- (10042BD0) --------------------------------------------------------
void __cdecl sub_10042BD0(_BYTE *a1, signed int a2, int a3)
{
  signed int v3; // esi@1
  _BYTE *v4; // ecx@2
  unsigned int v5; // edx@2
  unsigned int v6; // eax@6
  unsigned __int16 v7; // ax@7
  char v8; // al@10

  v3 = 0;
  if ( a2 > 0 )
  {
    v4 = a1;
    v5 = a2;
    do
    {
      if ( v3 & 3 )
      {
        if ( (v3 & 3) == 1 )
        {
          v6 = v5 >> 4;
        }
        else
        {
          --v4;
          if ( (v3 & 3) == 2 )
          {
            HIBYTE(v7) = v4[1];
            LOBYTE(v7) = *v4;
            v5 = v7;
            v6 = (unsigned int)v7 >> 6;
          }
          else
          {
            LOBYTE(v6) = v5;
          }
        }
      }
      else
      {
        BYTE1(v5) = *v4--;
        LOBYTE(v5) = *v4;
        v5 = (unsigned __int16)v5;
        LOWORD(v6) = (unsigned __int16)v5 >> 10;
      }
      v8 = v6 & 0x3F;
      if ( v8 )
      {
        if ( (unsigned __int8)(v8 - 1) > 0x19u )
        {
          if ( (unsigned __int8)(v8 - 32) <= 9u )
            v8 += 16;
        }
        else
        {
          v8 += 64;
        }
        *(_BYTE *)(v3 + a3) = v8;
      }
      else
      {
        *(_BYTE *)(v3 + a3) = 32;
      }
      ++v3;
    }
    while ( v3 < a2 );
  }
}

//----- (10042C70) --------------------------------------------------------
bool __cdecl sub_10042C70(unsigned int a1, unsigned __int16 a2)
{
  unsigned int v2; // eax@2
  bool result; // al@5

  result = 0;
  if ( a2 < 0x96u )
  {
    v2 = 12 * a2;
    if ( a1 < dword_10A09248[v2 / 4] && word_10A09244[v2 / 2] && dword_10A09240[v2 / 4] )
      result = 1;
  }
  return result;
}
// 10A09240: using guessed type int dword_10A09240[];
// 10A09244: using guessed type __int16 word_10A09244[];
// 10A09248: using guessed type int dword_10A09248[];

//----- (10042CB0) --------------------------------------------------------
int __cdecl sub_10042CB0(unsigned __int16 a1)
{
  unsigned __int16 v1; // dx@1
  int result; // eax@2

  if ( sub_10042C70(0, a1) )
    result = dword_10A09248[3 * v1];
  else
    result = 0;
  return result;
}
// 10A09248: using guessed type int dword_10A09248[];

//----- (10042CE0) --------------------------------------------------------
double sub_10042CE0()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_10060E40(10043, &v2, 4, &v1);
  return v2;
}

//----- (10042D10) --------------------------------------------------------
double sub_10042D10()
{
  float v1; // [sp+0h] [bp-8h]@1
  float v2; // [sp+4h] [bp-4h]@1

  v1 = 9.8999998e24;
  sub_10060E40(10002, &v2, 4, &v1);
  return v2;
}

//----- (10042D40) --------------------------------------------------------
void __usercall sub_10042D40(int a1@<esi>, int a2, float a3)
{
  signed int v3; // ebx@1
  int v4; // ecx@1
  int v5; // edx@1
  double v6; // st7@3
  double v7; // st6@4
  double v8; // st6@5
  double v9; // st7@5
  double v10; // st6@8
  double v11; // st7@8
  int v12; // edi@10
  signed int v13; // ecx@10
  int v14; // ebx@11
  signed int v15; // edx@11
  int v16; // ebp@13
  float *v17; // eax@19
  int v18; // [sp+4h] [bp-4h]@13
  float *v19; // [sp+10h] [bp+8h]@11
  float v20; // [sp+10h] [bp+8h]@19

  v3 = *(_BYTE *)(a1 + 320);
  v4 = v3 - 1;
  v5 = 0;
  if ( *(float *)(a1 + 8 * v3 - 4) < (double)*(float *)(a1 + 4) )
  {
    v5 = v3 - 1;
    v4 = 0;
  }
  v6 = a3;
  if ( *(float *)(a1 + 8 * v4 + 4) < (double)a3 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v8 = *(float *)(a1 + 8 * v4) / v6;
      v9 = 0.0;
      *(float *)a2 = v8;
      *(float *)(a2 + 4) = *(float *)&v9;
      return;
    }
LABEL_9:
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v7;
    return;
  }
  if ( *(float *)(a1 + 8 * v5 + 4) > v6 )
  {
    v7 = 0.0;
    if ( 0.0 != v6 )
    {
      v10 = *(float *)(a1 + 8 * v5) / v6;
      v11 = 0.0;
      *(float *)a2 = v10;
      *(float *)(a2 + 4) = *(float *)&v11;
      return;
    }
    goto LABEL_9;
  }
  v12 = 0;
  v13 = 1;
  if ( v3 <= 1 )
  {
LABEL_18:
    *(float *)a2 = 0.0;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12);
  }
  else
  {
    v14 = 0;
    v15 = 8;
    v19 = (float *)(a1 + 12);
    while ( 1 )
    {
      if ( *(float *)(v14 + a1 + 4) >= (double)*v19 )
      {
        v12 = v13 - 1;
        v14 = v15 - 8;
        v16 = v13;
        v18 = v15;
      }
      else
      {
        v12 = v13;
        v14 = v15;
        v16 = v13 - 1;
        v18 = v15 - 8;
      }
      if ( *(float *)(v14 + a1 + 4) > v6 && *(float *)(v18 + a1 + 4) <= v6 )
        break;
      v19 += 2;
      ++v13;
      v15 += 8;
      if ( v13 >= *(_BYTE *)(a1 + 320) )
        goto LABEL_18;
    }
    v17 = (float *)(a1 + 8 * v12 + 4);
    v20 = (*(float *)(a1 + 8 * v12) - *(float *)(a1 + 8 * v16)) / (*v17 - *(float *)(a1 + 8 * v16 + 4));
    *(float *)a2 = v20;
    *(float *)(a2 + 4) = *(float *)(a1 + 8 * v12) - v20 * *v17;
  }
}

//----- (10042EA0) --------------------------------------------------------
char __usercall sub_10042EA0@<al>(float *a1@<edi>, unsigned __int16 a2@<si>, unsigned __int8 a3)
{
  double v3; // st7@8
  char result; // al@10
  char v5; // [sp+7h] [bp-29h]@3
  float v6; // [sp+8h] [bp-28h]@1
  float v7; // [sp+Ch] [bp-24h]@3
  int v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  float v12[4]; // [sp+20h] [bp-10h]@1

  v6 = 0.0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  if ( sub_10060E40(6117, v12, 16, &v8) )
    sub_10028BC0("..\\lib\\adl\\iop_eis_intf.c", 2716, 0, 0);
  sub_10015140(1, 0x50u, &v5);
  if ( sub_10060E80(6354, (int)&v7, 4) )
    sub_10028BC0("..\\lib\\adl\\iop_eis_intf.c", 2735, 0, 0);
  if ( (sub_10044F70(a2) || v5) && sub_10046830(a2, &v6) )
  {
    v6 = v12[2 * a3] * v6;
    v3 = v6;
    *a1 = v6;
    if ( v7 > v3 )
      *a1 = 0.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10042EA0: using guessed type float var_10[4];

//----- (10042F90) --------------------------------------------------------
char __usercall sub_10042F90@<al>(unsigned __int16 *a1@<eax>, int a2, float *a3, unsigned __int8 a4)
{
  int v4; // ecx@1
  unsigned __int16 *v5; // esi@1
  char v6; // al@1
  double v7; // st7@1
  int v8; // ebp@1
  unsigned __int8 v9; // bl@4
  char result; // al@7
  int v11; // eax@9
  unsigned __int16 *v12; // edi@9
  int v13; // eax@11
  int v14; // eax@14
  int v15; // eax@17
  double v16; // st7@22
  double v17; // st7@24
  int v18; // edi@31
  int v19; // [sp-8h] [bp-A0h]@12
  int v20; // [sp-4h] [bp-9Ch]@12
  float v21; // [sp+0h] [bp-98h]@12
  float v22; // [sp+14h] [bp-84h]@1
  float v23; // [sp+18h] [bp-80h]@1
  int v24; // [sp+1Ch] [bp-7Ch]@1
  int v25; // [sp+20h] [bp-78h]@5
  float v26; // [sp+24h] [bp-74h]@6
  float v27; // [sp+28h] [bp-70h]@9
  float v28; // [sp+2Ch] [bp-6Ch]@9
  float v29; // [sp+38h] [bp-60h]@10
  float v30; // [sp+3Ch] [bp-5Ch]@11
  float v31; // [sp+48h] [bp-50h]@13
  float v32; // [sp+4Ch] [bp-4Ch]@14
  float v33; // [sp+70h] [bp-28h]@16
  float v34; // [sp+74h] [bp-24h]@17

  v4 = a2;
  v5 = a1;
  *a3 = -1.0;
  v6 = *(_BYTE *)(a2 + 320);
  v7 = 0.0;
  v8 = 0;
  v22 = 0.0;
  v23 = 0.0;
  v24 = 0;
  if ( !v6 || v6 == 1 && 0.0 == *(float *)a2 )
  {
    if ( a4 )
    {
      v18 = a4;
      do
      {
        if ( sub_10044F70(*v5) )
        {
          ++v8;
          if ( sub_100469B0((int)v5, *v5, &v22) )
          {
            ++v24;
            v23 = v23 + v22;
          }
        }
        ++v5;
        --v18;
      }
      while ( v18 );
      if ( v8 != v24 )
        goto LABEL_42;
    }
    *a3 = v23;
    if ( v8 <= 0 )
LABEL_42:
      result = 0;
    else
      result = 1;
    return result;
  }
  v9 = 0;
  if ( !a4 )
    goto LABEL_5;
  while ( 2 )
  {
    v28 = v7;
    v11 = v5[v9];
    v27 = v7;
    v12 = &v5[v9];
    switch ( v11 )
    {
      case 58:
      case 59:
        if ( !sub_10060D80(6091, (int)&v29, 16) )
        {
          v13 = 8 * *v12 - 464;
          v28 = *(float *)((char *)&v29 + v13);
          v27 = *(float *)((char *)&v30 + v13);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2889;
        goto LABEL_19;
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
        if ( !sub_10060D80(6090, (int)&v31, 40) )
        {
          v14 = 8 * *v12 - 480;
          v28 = *(float *)((char *)&v31 + v14);
          v27 = *(float *)((char *)&v32 + v14);
          goto LABEL_20;
        }
        v21 = 0.0;
        v20 = 0;
        v19 = 2921;
        goto LABEL_19;
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
        if ( sub_10060D80(6092, (int)&v33, 40) )
        {
          v21 = 0.0;
          v20 = 0;
          v19 = 2953;
LABEL_19:
          sub_10028BC0("..\\lib\\adl\\iop_eis_intf.c", v19, v20, (char *)LODWORD(v21));
        }
        else
        {
          v15 = 8 * *v12 - 520;
          v28 = *(float *)((char *)&v33 + v15);
          v27 = *(float *)((char *)&v34 + v15);
        }
LABEL_20:
        if ( sub_10044F70(*v12) )
        {
          ++v8;
          if ( sub_10046830(*v12, &v22) )
          {
            v16 = v22;
            if ( v27 >= (double)v22 )
              v16 = v27;
            v22 = v16;
            v17 = v22;
            if ( v28 <= (double)v22 )
              v17 = v28;
            ++v24;
            v22 = v17;
            v23 = v22 + v23;
          }
        }
        if ( ++v9 < a4 )
        {
          v7 = 0.0;
          continue;
        }
        v4 = a2;
LABEL_5:
        sub_10042D40(v4, (int)&v25, v23);
        if ( v8 != v24 || (*a3 = *(float *)&v25 * v23 + v26, v8 <= 0) )
LABEL_29:
          result = 0;
        else
          result = 1;
        return result;
      default:
        goto LABEL_29;
    }
  }
}

//----- (10043270) --------------------------------------------------------
char __cdecl sub_10043270(float *a1)
{
  char v2; // [sp+0h] [bp-144h]@1
  char v3; // [sp+140h] [bp-4h]@1

  v3 = 0;
  return sub_10042F90((unsigned __int16 *)&unk_100E3894, (int)&v2, a1, 1u);
}

//----- (100432A0) --------------------------------------------------------
char __cdecl sub_100432A0(float *a1)
{
  char v2; // [sp+0h] [bp-144h]@1
  char v3; // [sp+140h] [bp-4h]@1

  v3 = 0;
  return sub_10042F90((unsigned __int16 *)&unk_100E39E0, (int)&v2, a1, 1u);
}

//----- (100432D0) --------------------------------------------------------
char __cdecl sub_100432D0(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_10060D80(6266, (int)&v2, 324) )
  {
    sub_10028BC0("..\\lib\\adl\\iop_eis_intf.c", 590, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10042F90((unsigned __int16 *)&unk_100E39E4, (int)&v2, a1, 2u);
  }
  return result;
}

//----- (10043340) --------------------------------------------------------
char __cdecl sub_10043340(float *a1)
{
  return sub_10042EA0(a1, 0x14u, 0);
}

//----- (10043360) --------------------------------------------------------
char __cdecl sub_10043360(float *a1)
{
  return sub_10042EA0(a1, 0x2Du, 1u);
}

//----- (10043380) --------------------------------------------------------
char __cdecl sub_10043380(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10043340(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10043360(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else if ( v1 )
  {
    result = v1;
    *a1 = v4;
  }
  else
  {
    *a1 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (10043410) --------------------------------------------------------
char __cdecl sub_10043410(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_10060D80(6265, (int)&v2, 324) )
  {
    sub_10028BC0("..\\lib\\adl\\iop_eis_intf.c", 1606, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10042F90(L"<=>?@", (int)&v2, a1, 5u);
  }
  return result;
}
// 100E39F0: using guessed type wchar_t a__[6];

//----- (10043480) --------------------------------------------------------
char __cdecl sub_10043480(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_10060D80(6266, (int)&v8, 324) )
  {
    sub_10028BC0("..\\lib\\adl\\iop_eis_intf.c", 1847, 0, "Center cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L":;<=>?@";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10052B70(v4, v5, &v6);
      if ( v1 )
        v1 = sub_10015AC0(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000" )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_10042F90((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100E39FC: using guessed type wchar_t a___0[8];

//----- (10043550) --------------------------------------------------------
char __cdecl sub_10043550(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_10060D80(6265, (int)&v8, 324) )
  {
    sub_10028BC0("..\\lib\\adl\\iop_eis_intf.c", 1946, 0, "Left cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"\u3b00\u3c00\u3d00\u3e00\u3f00\u4000";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10052B70(v4, v5, &v6);
      if ( v1 )
        v1 = sub_10015AC0(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&a___0[7] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_10042F90((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100E39FC: using guessed type wchar_t a___0[8];

//----- (10043620) --------------------------------------------------------
char __cdecl sub_10043620(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  const wchar_t *v3; // esi@3
  int v4; // [sp+4h] [bp-154h]@5
  char v5[4]; // [sp+8h] [bp-150h]@5
  int v6; // [sp+Ch] [bp-14Ch]@5
  char v7; // [sp+10h] [bp-148h]@6
  char v8; // [sp+14h] [bp-144h]@1

  v1 = 0;
  if ( sub_10060D80(6267, (int)&v8, 324) )
  {
    sub_10028BC0("..\\lib\\adl\\iop_eis_intf.c", 2045, 0, "Right cal points undefined");
    result = 0;
  }
  else
  {
    v3 = L"ABCDE";
    while ( !v1 )
    {
      LOWORD(v4) = *v3;
      v1 = sub_10052B70(v4, v5, &v6);
      if ( v1 )
        v1 = sub_10015AC0(v5[0], v6, &v7);
      ++v3;
      if ( (signed int)v3 >= (signed int)&aAbcde_0[5] )
      {
        if ( !v1 )
          goto LABEL_10;
        break;
      }
    }
    v1 = sub_10042F90((unsigned __int16 *)&v4, (int)&v8, a1, 1u);
LABEL_10:
    result = v1;
  }
  return result;
}
// 100E3A0C: using guessed type wchar_t aAbcde_0[6];

//----- (100436F0) --------------------------------------------------------
char __cdecl sub_100436F0(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10043480(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_10043550(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_10043620(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10043790) --------------------------------------------------------
char __cdecl sub_10043790(float *a1)
{
  char result; // al@2
  char v2; // [sp+0h] [bp-144h]@1

  if ( sub_10060D80(6267, (int)&v2, 324) )
  {
    sub_10028BC0("..\\lib\\adl\\iop_eis_intf.c", 2199, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10042F90(L"ABCDE", (int)&v2, a1, 5u);
  }
  return result;
}
// 100E3A18: using guessed type wchar_t aAbcde[6];

//----- (10043800) --------------------------------------------------------
double sub_10043800()
{
  int v0; // eax@1
  double result; // st7@1
  float v2; // [sp+0h] [bp-10h]@1
  float v3; // [sp+4h] [bp-Ch]@1
  double v4; // [sp+8h] [bp-8h]@2

  v3 = 9.8999998e24;
  v0 = sub_10060E40(10009, &v2, 4, &v3);
  result = v2;
  if ( !v0 )
  {
    v4 = v2;
    v2 = v4 - sub_10042D10();
    if ( v2 >= 0.0 )
    {
      result = v2;
    }
    else
    {
      v2 = 0.0;
      result = (float)0.0;
    }
  }
  return result;
}

//----- (10043860) --------------------------------------------------------
char __cdecl sub_10043860(float *a1)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10043270(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_100432A0(&v3) )
  {
    result = 1;
    v4 = v4 + v3;
    *a1 = v4;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (100438E0) --------------------------------------------------------
char __cdecl sub_100438E0(float *a1)
{
  char v1; // bl@1
  char result; // al@6
  float v3; // [sp+4h] [bp-8h]@1
  float v4; // [sp+8h] [bp-4h]@1

  v3 = 0.0;
  v4 = 0.0;
  v1 = 0;
  if ( sub_10043410(&v3) )
  {
    v1 = 1;
    v4 = v3 + 0.0;
  }
  if ( sub_100432D0(&v3) )
  {
    v1 = 1;
    v4 = v4 + v3;
  }
  if ( sub_10043790(&v3) )
  {
    v4 = v4 + v3;
    *a1 = v4;
    result = 1;
  }
  else
  {
    if ( v1 )
      *a1 = v4;
    result = v1;
  }
  return result;
}

//----- (10043980) --------------------------------------------------------
char __cdecl sub_10043980(float *a1)
{
  void *v1; // ecx@0
  char result; // al@2

  if ( sub_1002C4F0(v1) )
    result = sub_10043860(a1);
  else
    result = sub_100438E0(a1);
  return result;
}

//----- (100439A0) --------------------------------------------------------
char __thiscall sub_100439A0(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  sub_10060E80(3190, (int)&v2 + 3, 1);
  return BYTE3(v2);
}

//----- (100439C0) --------------------------------------------------------
double __cdecl sub_100439C0(char a1)
{
  void *v1; // ecx@0
  char v2; // bl@1
  void *v3; // ecx@1
  char v5; // [sp+4h] [bp-Ch]@2
  float v6; // [sp+8h] [bp-8h]@2

  v2 = sub_10043C20(v1);
  if ( sub_100439A0(v3) )
    goto LABEL_2;
  if ( a1 )
  {
    if ( v2 )
    {
      sub_10060E80(2015, (int)&v5, 12);
      return v6;
    }
    sub_10060E80(2101, (int)&v5, 12);
  }
  else
  {
    if ( !v2 )
    {
LABEL_2:
      sub_10060E80(2015, (int)&v5, 12);
      return v6;
    }
    sub_10060E80(2101, (int)&v5, 12);
  }
  return v6;
}

//----- (10043A40) --------------------------------------------------------
void sub_10043A40()
{
  sub_100439C0(0);
}

//----- (10043A50) --------------------------------------------------------
int __cdecl sub_10043A50(int a1)
{
  double v1; // ST0C_8@2
  double v2; // st6@4
  double v3; // st7@4
  double v4; // ST0C_8@7
  double v5; // rt2@8
  double v6; // st6@8
  double v7; // st7@8
  double v8; // st7@14
  double v9; // st7@18
  int result; // eax@18

  if ( a1 )
  {
    v1 = *(double *)a1;
    if ( (HIDWORD(v1) & 0x7FF00000) == 2146435072 || *(double *)a1 > 6.2831853071796 )
    {
      *(double *)a1 = 6.2831853071796;
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
    }
    else
    {
      v2 = -6.2831853071796;
      v3 = 6.2831853071796;
      if ( *(double *)a1 < -6.2831853071796 )
        *(double *)a1 = -6.2831853071796;
    }
    v4 = *(double *)(a1 + 8);
    if ( (HIDWORD(v4) & 0x7FF00000) == 2146435072 )
    {
      *(double *)(a1 + 8) = v3;
    }
    else
    {
      v5 = v2;
      v6 = v3;
      v7 = v5;
      if ( v6 < *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v6;
      }
      else if ( v7 > *(double *)(a1 + 8) )
      {
        *(double *)(a1 + 8) = v7;
      }
    }
    if ( *(double *)a1 <= 1.5707963267949 )
    {
      if ( *(double *)a1 >= -1.5707963267949 )
      {
LABEL_18:
        v9 = *(double *)(a1 + 8);
        result = sub_100680B0(v9);
        *(double *)(a1 + 8) = v9;
        return result;
      }
      *(double *)a1 = -3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    else
    {
      *(double *)a1 = 3.1415926535898 - *(double *)a1;
      v8 = *(double *)(a1 + 8) + 3.1415926535898;
    }
    *(double *)(a1 + 8) = v8;
    goto LABEL_18;
  }
  return result;
}

//----- (10043B50) --------------------------------------------------------
signed int __cdecl sub_10043B50(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    if ( (COERCE_UNSIGNED_INT(*(float *)a1) & 0x7F800000) == 2139095040
      || (COERCE_UNSIGNED_INT(*(float *)(a1 + 4)) & 0x7F800000) == 2139095040
      || *(float *)a1 >= 1.570796370506287
      || *(float *)a1 < -1.570796370506287
      || *(float *)(a1 + 4) >= 3.141592741012573
      || *(float *)(a1 + 4) < -3.141592741012573 )
    {
      if ( a2 )
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
      }
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10043BF0) --------------------------------------------------------
char __cdecl sub_10043BF0(char a1)
{
  char result; // al@1

  result = sub_1005A9B0();
  if ( result == 2 )
    result = byte_100E4EAC[8 * sub_1002CC90(&a1, 4u, (int)&unk_100E4EA8, 8, 7, 7)];
  return result;
}

//----- (10043C20) --------------------------------------------------------
char __thiscall sub_10043C20(void *this)
{
  char v1; // al@1

  v1 = sub_1002C660(this);
  return sub_10043BF0(v1);
}

//----- (10043C30) --------------------------------------------------------
char __cdecl sub_10043C30(char a1, void *a2)
{
  int v2; // eax@2
  char result; // al@11
  char *v4; // eax@12
  signed int v5; // ecx@12

  switch ( a1 )
  {
    case 0:
      v2 = 247;
      break;
    case 2:
      v2 = 248;
      break;
    case 3:
      v2 = 1732;
      break;
    case 4:
      v2 = 1733;
      break;
    case 5:
      v2 = 2279;
      break;
    case 6:
      v2 = 2280;
      break;
    default:
      v2 = 246;
      break;
  }
  if ( !sub_10015AC0(1, v2, a2) || sub_1001C3E0((int)a2) )
  {
    memset(a2, 0, 0xCCCu);
    v4 = (char *)a2 + 26;
    v5 = 14;
    do
    {
      *v4 = 15;
      v4 += 232;
      --v5;
    }
    while ( v5 );
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10043CE0) --------------------------------------------------------
char __cdecl sub_10043CE0(char a1)
{
  bool v1; // zf@1
  char result; // al@1
  char v3; // [sp+4h] [bp-CD0h]@1
  char v4; // [sp+11h] [bp-CC3h]@1

  memset(&v3, 0, 0xCCCu);
  v1 = sub_10043C30(a1, &v3) == 0;
  result = v4;
  if ( v1 )
    result = 3;
  return result;
}

//----- (10043D40) --------------------------------------------------------
char sub_10043D40()
{
  unsigned __int16 v0; // dx@1
  int v1; // ecx@2
  unsigned __int16 v2; // ax@9
  int v4[7]; // [sp+8h] [bp-1Ch]@1

  sub_10060E80(6465, (int)v4, 28);
  v0 = 0;
LABEL_2:
  v1 = v4[v0];
  if ( v1 == 1 || v1 == 2 || v1 == 4 || v1 == 64 || v1 == 128 || v1 == 16 || v1 == 32 )
  {
    v2 = 0;
    while ( v2 == v0 || v4[v2] != v1 )
    {
      if ( ++v2 >= 7u )
      {
        if ( ++v0 < 7u )
          goto LABEL_2;
        return 1;
      }
    }
  }
  return 0;
}
// 10043D40: using guessed type int var_1C[7];

//----- (10043DC0) --------------------------------------------------------
int __cdecl sub_10043DC0(char a1)
{
  return 9190 - (a1 != 1);
}

//----- (10043DD0) --------------------------------------------------------
int __usercall sub_10043DD0@<eax>(char *a1@<eax>, char a2@<cl>)
{
  return sub_1005A9C0(a2, a1);
}

//----- (10043DE0) --------------------------------------------------------
char __usercall sub_10043DE0@<al>(char a1@<bl>, char a2)
{
  int v2; // eax@1
  char result; // al@2
  char *v4; // ecx@3
  unsigned __int8 v5; // [sp+4h] [bp-8Ch]@1
  char v6; // [sp+5h] [bp-8Bh]@2
  char v7[68]; // [sp+48h] [bp-48h]@1

  memset(&v5, 0, 0x43u);
  memset(v7, 0, 0x43u);
  sub_10043DD0((char *)&v5, a2);
  v2 = sub_10043DC0(a1);
  if ( sub_10060D80(v2, (int)v7, 67) )
  {
    result = a1 == 1;
  }
  else
  {
    result = v7[v5];
    if ( v6 != 67 )
    {
      v4 = &v6;
      do
        ++v4;
      while ( *v4 != 67 );
    }
  }
  return result;
}
// 10043DE0: using guessed type char var_48[68];

//----- (10043EA0) --------------------------------------------------------
char __cdecl sub_10043EA0(char a1, char a2)
{
  return sub_10043DE0(a1, a2);
}

//----- (10043EC0) --------------------------------------------------------
int __cdecl sub_10043EC0(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1002CC90(&a1, 1u, (int)&unk_100FB2F8, 8, 53, 67);
  if ( v1 == 67 )
    result = 0;
  else
    result = (int)*(&off_100FB2FC + 2 * v1);
  return result;
}
// 100FB2FC: using guessed type void *off_100FB2FC;

//----- (10043F00) --------------------------------------------------------
int __cdecl sub_10043F00(char a1)
{
  return sub_1002CC90(&a1, 1u, (int)byte_100FB4A0, 8, 2, 2);
}

//----- (10043F20) --------------------------------------------------------
char __cdecl sub_10043F20(unsigned __int8 a1)
{
  char result; // al@1

  result = 67;
  if ( a1 < 2u )
    result = byte_100FB4A0[8 * a1];
  return result;
}

//----- (10043F40) --------------------------------------------------------
BOOL __cdecl sub_10043F40(int a1, void *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-18h]@2
  int v5; // [sp+18h] [bp-4h]@3

  v2 = sub_100296B0(a1);
  return sub_10015AC0(0, 604, a2) && sub_10015400(0, 0x25Cu, (int)&v4) && (v2 & v5) == v2;
}

//----- (10043FA0) --------------------------------------------------------
int __usercall sub_10043FA0@<eax>(char a1@<al>)
{
  unsigned __int8 v1; // al@1
  int result; // eax@2

  v1 = sub_10043F00(a1);
  if ( v1 >= 2u )
    result = 42066;
  else
    result = dword_100FB4A4[2 * v1];
  return result;
}
// 100FB4A4: using guessed type int dword_100FB4A4[];

//----- (10043FD0) --------------------------------------------------------
BOOL __cdecl sub_10043FD0(char a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10043FA0(a1);
  return sub_10060D80(v2, a2, 16) == 0;
}

//----- (10044000) --------------------------------------------------------
int __cdecl sub_10044000(int a1, char a2, int a3, int a4, void *a5)
{
  int result; // eax@2

  if ( a2 )
    result = sub_10043FD0(a1, (int)a5);
  else
    result = sub_10043F40(a1, a5);
  return result;
}

//----- (10044030) --------------------------------------------------------
char __cdecl sub_10044030(void *a1)
{
  int v1; // ecx@0
  int v3; // [sp+0h] [bp-4h]@1

  v3 = v1;
  return sub_10015AF0(1, 1947, a1, (int)&v3);
}

//----- (10044050) --------------------------------------------------------
BOOL __cdecl sub_10044050(int a1)
{
  return sub_10060D80(6792, a1, 284) == 0;
}

//----- (10044070) --------------------------------------------------------
char __cdecl sub_10044070(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2

  if ( a2 )
    result = sub_10044050((int)a5);
  else
    result = sub_10044030(a5);
  return result;
}

//----- (100440A0) --------------------------------------------------------
bool __cdecl sub_100440A0(unsigned __int8 a1, char a2, unsigned int a3)
{
  int v3; // eax@1
  bool result; // al@5

  v3 = sub_1002CC90(&a2, 4u, (int)&dword_100FC318, 12, 3, 3);
  if ( a3 < 0xFFFFFFC2 && a3 && v3 < 3 && a1 < 2u )
  {
    result = sub_10060D80((unsigned __int16)word_100FC31C[a1 + 6 * v3], a3, (unsigned __int16)word_100FC320[6 * v3]) == 0;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gtx\\iop_gtx_intf.c", 254, 0, 0);
    result = 0;
  }
  return result;
}
// 100FC318: using guessed type int dword_100FC318;
// 100FC31C: using guessed type __int16 word_100FC31C[];
// 100FC320: using guessed type __int16 word_100FC320[];

//----- (10044130) --------------------------------------------------------
bool __cdecl sub_10044130(char a1, char a2, void *a3)
{
  int v3; // eax@1
  int v4; // esi@3
  void *v5; // edi@3
  int (__cdecl *v6)(void *, _DWORD); // esi@4
  bool result; // al@6

  v3 = sub_1002CC90(&a1, 1u, (int)&unk_100FC354, 8, 2, 2);
  if ( v3 >= 2 || (unsigned __int8)a2 >= 3u )
  {
    result = 0;
  }
  else
  {
    v4 = (unsigned __int8)a2;
    v5 = a3;
    result = 0;
    if ( sub_10015AC0(0, (unsigned __int16)word_100FC356[(unsigned __int8)a2 + 4 * v3], a3) )
    {
      v6 = (int (__cdecl *)(void *, _DWORD))dword_100FC364[v4];
      if ( !v6 || !v6(v5, 0) )
        result = 1;
    }
  }
  return result;
}
// 100FC356: using guessed type __int16 word_100FC356[];
// 100FC364: using guessed type int dword_100FC364[];

//----- (100441B0) --------------------------------------------------------
bool __cdecl sub_100441B0(char a1, char a2, char a3, int a4, unsigned int a5, unsigned int a6)
{
  int v6; // eax@1
  int v7; // eax@7
  unsigned int v8; // edx@7
  int v9; // eax@7
  bool result; // al@9
  unsigned __int8 v11; // [sp+4h] [bp-4h]@1

  v11 = sub_100341C0(a1);
  v6 = sub_1002CC90(&a3, 1u, (int)&unk_100FC33C, 8, 3, 3);
  if ( v6 < 3 )
    v6 = sub_1002CC90(&dword_100FC340[2 * v6], 4u, (int)&dword_100FC318, 12, 3, 3);
  if ( a5 < 0xFFFFFFC2
    && a5
    && v6 < 3
    && v11 < 2u
    && (v7 = 6 * v6, v8 = (unsigned __int16)word_100FC320[v7], v9 = 2 * v7, a6 >= v8)
    && a2 == 1 )
  {
    result = sub_100440A0(v11, *(int *)((char *)&dword_100FC318 + v9), a5);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100FC318: using guessed type int dword_100FC318;
// 100FC320: using guessed type __int16 word_100FC320[];

//----- (10044250) --------------------------------------------------------
bool __cdecl sub_10044250(char a1, void *a2)
{
  memset(a2, 0, 0x2890u);
  return sub_10060D80((a1 != 36) + 6534, (int)a2, 10384) == 0;
}

//----- (10044290) --------------------------------------------------------
signed int __usercall sub_10044290@<eax>(char a1@<al>)
{
  return a1 != 36 ? 0x20000 : 0x10000;
}

//----- (100442B0) --------------------------------------------------------
bool __cdecl sub_100442B0(char a1, void *a2)
{
  int v2; // esi@1
  int v3; // ecx@1
  bool result; // al@5
  void *v5; // ecx@6
  int v6; // [sp+Ch] [bp-28h]@4
  char v7; // [sp+10h] [bp-24h]@2
  int v8; // [sp+24h] [bp-10h]@3
  __int16 v9; // [sp+28h] [bp-Ch]@8
  int v10; // [sp+2Ch] [bp-8h]@8

  v2 = sub_10044290(a1);
  if ( (v2 & j_HWM_pvg_hsdb_get_lrus_online(v3)) == v2
    && sub_10015400(1, 0x6ACu, (int)&v7)
    && v8 == v2
    && sub_10015AF0(1, 1708, a2, (int)&v6) )
  {
    result = 1;
  }
  else if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    result = sub_10044250(a1, a2);
  }
  else
  {
    v10 = sub_1002C660(v5);
    v9 = 1708;
    sub_10015560(1, 0, &v9, 0, 8, 1);
    sub_10015710(1, 0, v2);
    result = 0;
  }
  return result;
}
// 10061620: using guessed type int __thiscall j_HWM_pvg_hsdb_get_lrus_online(_DWORD);
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (100443A0) --------------------------------------------------------
bool __cdecl sub_100443A0(char a1, char a2, int a3, int a4, void *a5)
{
  bool result; // al@2

  if ( a2 )
    result = sub_10044250(a1, a5);
  else
    result = sub_100442B0(a1, a5);
  return result;
}

//----- (100443D0) --------------------------------------------------------
BOOL __cdecl sub_100443D0(unsigned __int8 a1)
{
  return a1 <= 1u;
}

//----- (100443E0) --------------------------------------------------------
BOOL __usercall sub_100443E0@<eax>(unsigned __int8 a1@<al>, char a2)
{
  _BYTE *v2; // ecx@1

  return (unsigned __int8)sub_100443D0(a1) && *v2 < 3u && a2 == 24;
}

//----- (10044410) --------------------------------------------------------
bool __cdecl sub_10044410(char a1, char a2, unsigned __int8 a3, int a4)
{
  bool v4; // bl@1
  unsigned __int8 v5; // cl@2
  int v6; // esi@3
  char v8; // al@16
  char v9; // cl@16
  char v10; // dl@16
  int v11; // ecx@18
  int v12; // edx@18
  int v13; // eax@18
  char v14; // [sp+Bh] [bp-29h]@3
  int v15; // [sp+Ch] [bp-28h]@9
  struct tm Tm; // [sp+10h] [bp-24h]@5

  v4 = 0;
  if ( a3 < 3u )
  {
    if ( (unsigned __int8)sub_100443D0(a1) )
    {
      v6 = 10 * v5;
      if ( sub_100313D0((unsigned __int8)byte_100FD758[20 * v5], (bool *)&v14) )
      {
        if ( v14 )
        {
          if ( !sub_10015AC0(1, (unsigned __int16)word_100FD750[v6], &Tm.tm_mon) || sub_1001C4A0((int)&Tm.tm_mon) )
            return 0;
          v4 = 1;
        }
        else
        {
          if ( !(unsigned __int8)sub_1005A960(a1, &v15) || v15 != dword_100FD770[2 * a3] || a2 == 11 )
            return v4;
          Tm.tm_sec = 0;
          Tm.tm_min = 0;
          Tm.tm_hour = 0;
          LOBYTE(Tm.tm_mday) = 0;
          v4 = sub_10015AC0(1, (unsigned __int16)word_100FD754[v6], &Tm) && !_mkgmtime(&Tm);
          v8 = BYTE1(Tm.tm_hour);
          v9 = BYTE2(Tm.tm_min);
          *((_BYTE *)&Tm.tm_mon + 4 * a3) = Tm.tm_min;
          v10 = BYTE2(Tm.tm_hour);
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 2) = v8;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 1) = v9;
          *((_BYTE *)&Tm.tm_mon + 4 * a3 + 3) = v10;
          if ( !v4 )
            return v4;
        }
        if ( a2 == 11 )
        {
          v11 = Tm.tm_year;
          v12 = Tm.tm_wday;
          *(_DWORD *)a4 = Tm.tm_mon;
          v13 = Tm.tm_yday;
          *(_DWORD *)(a4 + 4) = v11;
          *(_DWORD *)(a4 + 8) = v12;
          *(_DWORD *)(a4 + 12) = v13;
          return v4;
        }
        *(_DWORD *)a4 = *(&Tm.tm_mon + a3);
      }
    }
  }
  return v4;
}
// 100FD750: using guessed type __int16 word_100FD750[];
// 100FD754: using guessed type __int16 word_100FD754[];
// 100FD770: using guessed type int dword_100FD770[];

//----- (100445C0) --------------------------------------------------------
bool __cdecl sub_100445C0(unsigned __int8 a1, int a2)
{
  bool v2; // dl@1
  unsigned __int8 v3; // cl@1
  bool result; // al@2

  if ( (unsigned __int8)sub_100443D0(a1) )
    result = sub_10060D80((unsigned __int16)word_100FD75A[10 * v3], a2, 32) == 0;
  else
    result = v2;
  return result;
}
// 100FD75A: using guessed type __int16 word_100FD75A[];

//----- (10044600) --------------------------------------------------------
bool __cdecl sub_10044600(char a1, char a2, char a3, unsigned __int8 *a4, _DWORD *a5, int a6)
{
  unsigned __int8 v6; // dl@1
  bool result; // al@4
  char v8; // [sp+13h] [bp-29h]@5
  unsigned int v9; // [sp+14h] [bp-28h]@1
  char v10; // [sp+18h] [bp-24h]@7
  int v11[7]; // [sp+1Ch] [bp-20h]@8

  LOBYTE(v9) = sub_1005A8B0(a1);
  if ( !(unsigned __int8)sub_100443E0(v9, a3) || a6 != 4 )
    goto LABEL_12;
  if ( !a2 )
    return sub_10044410(v9, a3, *a4, (int)a5);
  if ( sub_100313D0((unsigned __int8)byte_100FD758[20 * v6], (bool *)&v8) && v8 && sub_100445C0(v9, (int)&v10) )
  {
    *a5 = v11[*a4];
    result = 1;
  }
  else
  {
LABEL_12:
    result = 0;
  }
  return result;
}
// 10044600: using guessed type int var_20[7];

//----- (100446F0) --------------------------------------------------------
char __cdecl sub_100446F0(char a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@3
  char v4; // dl@3

  memset(byte_109C83C0, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 215, 0, 0);
  }
  else
  {
    sub_10038760(a1, (int)byte_109C83C0);
    v3 = 4 * a2 - 64;
    v4 = byte_109C83C1[v3];
    *(_BYTE *)(a3 + 1) = v4;
    *(_BYTE *)a3 = byte_109C83C0[v3];
    if ( (unsigned __int8)v4 < 0x23u
      || (unsigned __int8)v4 >= 0x64u && (unsigned __int8)v4 <= 0x81u
      || (unsigned __int8)v4 >= 0x96u && (unsigned __int8)v4 <= 0x9Bu )
    {
      return 1;
    }
  }
  return 0;
}

//----- (10044790) --------------------------------------------------------
bool __cdecl sub_10044790(char a1, unsigned __int8 a2, int a3)
{
  char *v3; // eax@3
  bool result; // al@3

  memset(byte_109C83C0, 0, 0x890u);
  if ( (unsigned __int8)a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 340, 0, 0);
    result = 0;
  }
  else
  {
    sub_10038760(a1, (int)byte_109C83C0);
    v3 = (char *)&unk_109C8460 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v3;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v3 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v3 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v3 + 3);
    result = *(_WORD *)(a3 + 2) < 0x319u;
  }
  return result;
}

//----- (10044810) --------------------------------------------------------
char __cdecl sub_10044810(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_109C83C0, 0, 0x890u);
  sub_10038760(a1, (int)byte_109C83C0);
  if ( a2 > 0x10u )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 512, 0, 0);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = dword_109C8730[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_109C8734[2 * a2];
    result = 1;
  }
  return result;
}
// 109C8730: using guessed type int dword_109C8730[];
// 109C8734: using guessed type int dword_109C8734[];

//----- (10044880) --------------------------------------------------------
char __cdecl sub_10044880(char a1, void *a2)
{
  char result; // al@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = sub_10015AC0(0, 227, a2);
    }
    else if ( a1 == 2 )
    {
      result = sub_10015AC0(0, 572, a2);
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 991, 0, 0);
      result = 0;
    }
  }
  else
  {
    result = sub_10015AC0(0, 226, a2);
  }
  return result;
}

//----- (10044900) --------------------------------------------------------
char __cdecl sub_10044900(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  int v4; // ecx@3

  memset(byte_109C83C0, 0, 0x890u);
  if ( a1 >= 3u || (unsigned __int8)(a2 - 16) > 0x27u )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 153, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10044880(a1, byte_109C83C0);
    v4 = 4 * a2 - 64;
    *(_BYTE *)(a3 + 1) = byte_109C83C1[v4];
    *(_BYTE *)a3 = byte_109C83C0[v4];
  }
  return result;
}

//----- (10044980) --------------------------------------------------------
char __cdecl sub_10044980(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  char result; // al@3
  char *v4; // ecx@3

  memset(byte_109C83C0, 0, 0x890u);
  if ( a1 >= 3u || a2 >= 0x2Du )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 280, 0, 0);
    result = 0;
  }
  else
  {
    result = sub_10044880(a1, byte_109C83C0);
    v4 = (char *)&unk_109C8460 + 16 * a2;
    *(_DWORD *)a3 = *(_DWORD *)v4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)v4 + 1);
    *(_DWORD *)(a3 + 8) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a3 + 12) = *((_DWORD *)v4 + 3);
  }
  return result;
}

//----- (10044A00) --------------------------------------------------------
char __cdecl sub_10044A00(char a1, unsigned __int8 a2, int a3)
{
  char result; // al@2

  memset(byte_109C83C0, 0, 0x890u);
  if ( a2 <= 0x10u )
  {
    result = sub_10044880(a1, byte_109C83C0);
    *(_DWORD *)a3 = dword_109C8730[2 * a2];
    *(_DWORD *)(a3 + 4) = dword_109C8734[2 * a2];
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 445, 0, 0);
    result = 0;
  }
  return result;
}
// 109C8730: using guessed type int dword_109C8730[];
// 109C8734: using guessed type int dword_109C8734[];

//----- (10044A70) --------------------------------------------------------
char __cdecl sub_10044A70(char a1, char a2, char a3, unsigned __int8 *a4, int a5)
{
  char result; // al@6
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100319D0(a1);
  if ( v6 == 3 )
    return 0;
  if ( a3 == 1 )
  {
    if ( a2 )
      result = sub_10044810(v6, *a4, a5);
    else
      result = sub_10044A00(v6, *a4, a5);
  }
  else if ( a3 == 2 )
  {
    if ( a2 )
      result = sub_100446F0(v6, *a4, a5);
    else
      result = sub_10044900(v6, *a4, a5);
  }
  else
  {
    if ( a3 != 3 )
    {
      sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_cnfg_intf.c", 915, 0, 0);
      return 0;
    }
    if ( a2 )
      result = sub_10044790(v6, *a4, a5);
    else
      result = sub_10044980(v6, *a4, a5);
  }
  return result;
}

//----- (10044B80) --------------------------------------------------------
char __cdecl sub_10044B80(char a1, void *a2)
{
  return sub_10015AC0(6, (unsigned __int16)word_100FE29A[8 * (unsigned __int8)a1], a2);
}
// 100FE29A: using guessed type __int16 word_100FE29A[];

//----- (10044BA0) --------------------------------------------------------
bool __cdecl sub_10044BA0(unsigned __int8 a1, char *a2)
{
  int v2; // eax@1
  char v4; // [sp+8h] [bp-30h]@1

  v2 = sub_10060D80(dword_100FE2A0[4 * a1], (int)&v4, 48);
  qmemcpy(a2, &v4, 0x2Cu);
  return v2 == 0;
}
// 100FE2A0: using guessed type int dword_100FE2A0[];

//----- (10044BE0) --------------------------------------------------------
char __cdecl sub_10044BE0(int a1, char a2, int a3, int a4, void *a5)
{
  char result; // al@2
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_100532A0(a1);
  if ( a2 )
    result = sub_10044BA0(v6, (char *)a5);
  else
    result = sub_10044B80(v6, a5);
  return result;
}

//----- (10044C20) --------------------------------------------------------
BOOL sub_10044C20()
{
  char v1; // [sp+0h] [bp-78h]@1

  return sub_10031310(69, &v1) && !strncmp(&v1, "006-B0756-", 0xAu);
}

//----- (10044C80) --------------------------------------------------------
char __cdecl sub_10044C80(int a1, char *a2)
{
  char result; // al@5
  char v3; // [sp+13h] [bp-7Dh]@1
  char v4; // [sp+14h] [bp-7Ch]@1
  char v5; // [sp+15h] [bp-7Bh]@2
  int v6; // [sp+30h] [bp-60h]@2
  int v7; // [sp+34h] [bp-5Ch]@2
  int v8; // [sp+38h] [bp-58h]@2
  int v9; // [sp+3Ch] [bp-54h]@2
  int v10; // [sp+40h] [bp-50h]@2
  __int16 v11; // [sp+44h] [bp-4Ch]@2
  char v12; // [sp+46h] [bp-4Ah]@2
  char v13; // [sp+47h] [bp-49h]@2
  float v14; // [sp+48h] [bp-48h]@2
  char v15; // [sp+4Ch] [bp-44h]@2
  char v16; // [sp+4Dh] [bp-43h]@2
  char v17; // [sp+4Eh] [bp-42h]@2
  char v18; // [sp+50h] [bp-40h]@1

  memset(&v18, 0, 0x3Cu);
  v3 = sub_10015AC0(1, 292, &v18);
  qmemcpy(&v4, &v18, 0x3Cu);
  if ( !(unsigned __int8)sub_10044C20() )
  {
    v6 = -1;
    v14 = 77.166664;
    v7 = -1;
    v8 = -1;
    v9 = -1;
    v5 = 1;
    v12 = 0;
    v13 = 1;
    v4 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v11 = 0;
  }
  if ( !v3 || sub_1001BF60((int)&v4) )
  {
    result = 0;
  }
  else
  {
    result = 1;
    qmemcpy(a2, &v18, 0x3Cu);
  }
  return result;
}

//----- (10044D70) --------------------------------------------------------
BOOL __cdecl sub_10044D70(int a1, int a2)
{
  return sub_10060D80(6200, a2, 60) == 0;
}

//----- (10044D90) --------------------------------------------------------
char __cdecl sub_10044D90(int a1, char a2, int a3, int a4, char *a5)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    if ( a2 == 1 )
      result = sub_10044D70(a1, (int)a5);
  }
  else
  {
    result = sub_10044C80(a1, a5);
  }
  return result;
}

//----- (10044DD0) --------------------------------------------------------
char __cdecl sub_10044DD0(char a1)
{
  char result; // al@3

  if ( a1 == 15 )
  {
    result = 0;
  }
  else if ( a1 == 16 )
  {
    result = 1;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\iop_adc_intf.c", 178, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10044E10) --------------------------------------------------------
__int16 __usercall sub_10044E10@<ax>(unsigned __int8 a1@<al>)
{
  return word_100FF150[a1];
}
// 100FF150: using guessed type __int16 word_100FF150[];

//----- (10044E20) --------------------------------------------------------
char __cdecl sub_10044E20(unsigned __int8 a1, char *a2)
{
  int v2; // eax@2
  char result; // al@5
  int v4; // [sp+4h] [bp-150h]@2
  char v5; // [sp+8h] [bp-14Ch]@1
  char v6; // [sp+9h] [bp-14Bh]@3
  char v7; // [sp+Ch] [bp-148h]@5

  memset(&v5, 0, 0x148u);
  if ( a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    LOWORD(v2) = sub_10044E10(a1);
    if ( sub_10015AF0(0, v2, &v5, (int)&v4) && v6 == 3 && (unsigned int)(unsigned __int16)v4 - 4 >= 0xA0 )
    {
      qmemcpy(a2, &v7, 0xA0u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10044EF0) --------------------------------------------------------
char __cdecl sub_10044EF0(char a1, char a2, char a3, int a4, char *a5, unsigned int a6)
{
  char result; // al@3
  unsigned __int8 v7; // [sp+4h] [bp-4h]@1

  v7 = sub_10044DD0(a1);
  if ( a3 != 11 )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\iop_adc_intf.c", 564, 0, 0);
    return 0;
  }
  if ( a6 >= 0xA0 )
  {
    if ( a2 )
      return 0;
    result = sub_10044E20(v7, a5);
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\iop_adc_intf.c", 551, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10044F70) --------------------------------------------------------
char __cdecl sub_10044F70(unsigned __int16 a1)
{
  char v1; // bl@1
  char result; // al@5
  char v3; // [sp+Bh] [bp-411h]@2
  int v4; // [sp+Ch] [bp-410h]@1
  int v5; // [sp+10h] [bp-40Ch]@1
  char v6[1028]; // [sp+14h] [bp-408h]@5

  v1 = 0;
  if ( sub_10052B70(a1, &v5, &v4) && sub_10015140(v5, v4, &v3) && (v1 = v3) != 0
    || a1 >= 0x1D8u
    || (sub_10060E80(6943, (int)v6, 1028), result = 1, !v6[a1]) )
  {
    result = v1;
  }
  return result;
}
// 10044F70: using guessed type char var_408[1028];

//----- (10045010) --------------------------------------------------------
char __cdecl sub_10045010(char a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@3
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10038470(a1);
  switch ( a3 )
  {
    case 5:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1005AB90(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 4:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1005AC10(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 0xA:
      if ( a2 != 1 )
        goto LABEL_10;
      sub_1005AC90(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      result = 1;
      break;
    case 3:
      if ( a2 != 1 )
        goto LABEL_10;
      result = sub_1005AD10(v6, *(_BYTE *)a4, *(_BYTE *)(a4 + 1), *(_BYTE *)(a4 + 2), a5);
      break;
    default:
LABEL_10:
      result = 0;
      break;
  }
  return result;
}

//----- (10045120) --------------------------------------------------------
int __cdecl sub_10045120(char a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1002CC90(&a1, 1u, (int)&unk_100FF988, 8, 4, 4);
  if ( v1 == 4 )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_cnfg_intf.c", 437, 0, 0);
    result = 42066;
  }
  else
  {
    result = dword_100FF98C[2 * v1];
  }
  return result;
}
// 100FF98C: using guessed type int dword_100FF98C[];

//----- (10045170) --------------------------------------------------------
char __cdecl sub_10045170(char a1, int a2)
{
  char v2; // cl@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@1
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // eax@1
  int v10; // ecx@1
  bool v11; // zf@1
  int v12; // eax@3
  int v13; // ecx@3
  char v14; // dl@3
  __int16 v15; // ax@5
  char v16; // dl@5
  int v18; // [sp+4h] [bp-58h]@1
  char v19; // [sp+8h] [bp-54h]@1
  __int64 v20; // [sp+Ch] [bp-50h]@1
  int v21; // [sp+14h] [bp-48h]@1
  int v22; // [sp+18h] [bp-44h]@1
  char v23; // [sp+1Ch] [bp-40h]@1
  __int16 v24; // [sp+1Eh] [bp-3Eh]@1
  int v25; // [sp+20h] [bp-3Ch]@4
  int v26; // [sp+24h] [bp-38h]@4
  char v27; // [sp+28h] [bp-34h]@4
  char v28; // [sp+2Ah] [bp-32h]@1
  char v29; // [sp+2Bh] [bp-31h]@1
  int v30; // [sp+2Ch] [bp-30h]@1
  int v31; // [sp+30h] [bp-2Ch]@1
  int v32; // [sp+34h] [bp-28h]@1
  int v33; // [sp+38h] [bp-24h]@1
  int v34; // [sp+3Ch] [bp-20h]@1
  int v35; // [sp+40h] [bp-1Ch]@1
  int v36; // [sp+44h] [bp-18h]@1
  int v37; // [sp+48h] [bp-14h]@1
  int v38; // [sp+4Ch] [bp-10h]@1
  int v39; // [sp+50h] [bp-Ch]@1
  int v40; // [sp+54h] [bp-8h]@1

  memset(&v23, 0, 0x3Cu);
  v20 = 0i64;
  v21 = 0;
  v22 = 0;
  v18 = 0;
  v19 = 0;
  sub_100387B0(a1, (int)&v23);
  v2 = v28;
  v3 = v29;
  *(_WORD *)a2 = v24;
  *(_DWORD *)(a2 + 28) = v33;
  v4 = v36;
  *(_BYTE *)(a2 + 12) = v2;
  *(_DWORD *)(a2 + 32) = v34;
  v5 = v37;
  *(_BYTE *)(a2 + 13) = v3;
  *(_DWORD *)(a2 + 36) = v35;
  v6 = v38;
  *(_DWORD *)(a2 + 40) = v4;
  v7 = v30;
  *(_DWORD *)(a2 + 44) = v5;
  v8 = v31;
  *(_DWORD *)(a2 + 16) = v7;
  v9 = v39;
  *(_DWORD *)(a2 + 20) = v8;
  v10 = v40;
  *(_DWORD *)(a2 + 48) = v6;
  v11 = BYTE3(v30) == 1;
  *(_DWORD *)(a2 + 24) = v32;
  *(_DWORD *)(a2 + 52) = v9;
  *(_DWORD *)(a2 + 56) = v10;
  if ( !v11 || sub_10060D80(2105, (int)&v20, 16) )
  {
    v12 = v25;
    v13 = v26;
    v14 = v27;
  }
  else
  {
    v13 = *(_DWORD *)((char *)&v20 + 6);
    v12 = *(_DWORD *)((char *)&v20 + 2);
    v14 = BYTE2(v21);
  }
  *(_DWORD *)(a2 + 2) = v12;
  *(_DWORD *)(a2 + 6) = v13;
  *(_BYTE *)(a2 + 10) = v14;
  sub_100387D0((int)&v18);
  LOBYTE(v15) = v19;
  v16 = v18;
  v11 = (v19 & 1) == 0;
  *(_BYTE *)(a2 + 63) = BYTE3(v18);
  *(_BYTE *)(a2 + 60) = v16;
  *(_BYTE *)(a2 + 64) = 0;
  if ( !v11 )
    *(_BYTE *)(a2 + 64) = 1;
  *(_BYTE *)(a2 + 65) = 0;
  if ( v15 & 4 )
    *(_BYTE *)(a2 + 65) = 1;
  *(_BYTE *)(a2 + 66) = 0;
  if ( v15 & 2 )
  {
    v15 = *(_WORD *)((char *)&v18 + 1);
    *(_BYTE *)(a2 + 66) = 1;
    *(_WORD *)(a2 + 61) = v15;
  }
  else
  {
    *(_WORD *)(a2 + 61) = *(_WORD *)((char *)&v18 + 1);
  }
  return v15;
}

//----- (100452E0) --------------------------------------------------------
int __usercall sub_100452E0@<eax>(char a1@<cl>, int *a2@<esi>, unsigned __int16 a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@1
  int v5[10]; // [sp+1Ch] [bp-2Ch]@1

  sub_10045170(a1, (int)&v4);
  result = v5[a3];
  *a2 = result;
  return result;
}
// 100452E0: using guessed type int var_2C[10];

//----- (10045320) --------------------------------------------------------
int __usercall sub_10045320@<eax>(unsigned __int8 a1@<bl>, int *a2@<esi>, int a3)
{
  int result; // eax@1
  char v4; // [sp+0h] [bp-48h]@3
  int v5[4]; // [sp+34h] [bp-14h]@3

  result = a3;
  if ( (unsigned __int8)a3 < 2u && a1 < 2u )
  {
    sub_10045170(a3, (int)&v4);
    result = v5[a1];
    *a2 = result;
  }
  return result;
}
// 10045320: using guessed type int var_14[4];

//----- (10045360) --------------------------------------------------------
signed int sub_10045360()
{
  return sub_10061AA0((int)&off_10100838);
}
// 10100838: using guessed type char *off_10100838;

//----- (10045370) --------------------------------------------------------
char __cdecl sub_10045370(unsigned __int8 a1, unsigned __int16 a2, int a3)
{
  int v3; // esi@2
  char result; // al@2

  if ( (unsigned __int8)sub_10045360() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10A09A98 + 4 * v3 + 29);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10A09A98 + 4 * v3 + 28);
    result = *(_BYTE *)(a2 + 2 * (3 * a1 + 72) + dword_10A09A98);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10A09A98: using guessed type int dword_10A09A98;

//----- (100453D0) --------------------------------------------------------
char __cdecl sub_100453D0(char a1, void *a2)
{
  int v2; // edx@4
  char result; // al@20

  if ( (unsigned __int8)sub_10045360() )
  {
    if ( (sub_100343B0(a1)
       || *(_BYTE *)(dword_10A09A98 + 2 * (3 * (unsigned __int8)a1 + 72))
       && (v2 = dword_10A09A98 + 6 * (unsigned __int8)a1, *(_BYTE *)(dword_10A09A98 + 6 * (unsigned __int8)a1 + 145))
       && *(_BYTE *)(v2 + 146)
       && *(_BYTE *)(v2 + 147)
       && *(_BYTE *)(v2 + 148)
       && *(_BYTE *)(v2 + 149)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10A09A98 + 142)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10A09A98 + 170)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10A09A98 + 168)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10A09A98 + 166)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10A09A98 + 172)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10A09A98 + 174)
       && *(_BYTE *)((unsigned __int8)a1 + dword_10A09A98 + 176))
      && *(_BYTE *)(dword_10A09A98 + 2 * (unsigned __int8)a1 + 158)
      && *(_BYTE *)(dword_10A09A98 + 2 * (unsigned __int8)a1 + 159)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10A09A98 + 156)
      && *(_BYTE *)((unsigned __int8)a1 + dword_10A09A98 + 162) )
    {
      qmemcpy(a2, (const void *)(dword_10A09A98 + 68 * (unsigned __int8)a1), 0x44u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10A09A98: using guessed type int dword_10A09A98;

//----- (100454F0) --------------------------------------------------------
char __cdecl sub_100454F0(unsigned __int8 a1, unsigned __int8 a2, int a3)
{
  int v3; // eax@2
  char result; // al@2

  if ( (unsigned __int8)sub_10045360() )
  {
    v3 = a1 + a2 + 16 * a1;
    *(_BYTE *)(a3 + 2) = *(_BYTE *)(dword_10A09A98 + 4 * v3 + 54);
    *(_BYTE *)a3 = *(_BYTE *)(dword_10A09A98 + 4 * v3 + 52);
    *(_BYTE *)(a3 + 1) = *(_BYTE *)(dword_10A09A98 + 4 * v3 + 53);
    *(_BYTE *)(a3 + 3) = *(_BYTE *)(dword_10A09A98 + 4 * v3 + 55);
    result = *(_BYTE *)(a2 + 2 * a1 + 158 + dword_10A09A98);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10A09A98: using guessed type int dword_10A09A98;

//----- (10045570) --------------------------------------------------------
char __cdecl sub_10045570(int a1, char a2, char a3, unsigned __int8 *a4, int *a5, unsigned int a6)
{
  char v6; // cl@2
  char result; // al@7
  unsigned __int16 v8; // ax@13

  if ( (_BYTE)a1 == 10 )
  {
    v6 = 0;
  }
  else
  {
    if ( (_BYTE)a1 != 11 )
    {
      sub_10028BC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 703, 0, 0);
      return 0;
    }
    v6 = 1;
  }
  LOBYTE(a1) = v6;
  switch ( a3 )
  {
    case 0:
      if ( a6 >= 4 )
      {
        if ( a2 )
        {
          sub_10045320(*a4, a5, a1);
          result = 1;
        }
        else
        {
          result = sub_100454F0(v6, *a4, (int)a5);
        }
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 718, 0, 0);
        result = 0;
      }
      break;
    case 2:
      if ( a6 >= 4 )
      {
        v8 = *a4;
        if ( a2 )
        {
          sub_100452E0(v6, a5, v8);
          result = 1;
        }
        else
        {
          result = sub_10045370(v6, v8, (int)a5);
        }
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 750, 0, 0);
        result = 0;
      }
      break;
    case 0xB:
    case 0x12:
    case 0x1C:
      if ( a6 >= 0x44 )
      {
        if ( a2 )
        {
          sub_10045170(v6, (int)a5);
          result = 1;
        }
        else
        {
          result = sub_100453D0(v6, a5);
        }
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 784, 0, 0);
        result = 0;
      }
      break;
    default:
      sub_10028BC0("..\\lib\\acl\\iop\\iop_xpdr_cnfg_intf.c", 809, 0, 0);
      result = 0;
      break;
  }
  return result;
}

//----- (10045720) --------------------------------------------------------
char __cdecl sub_10045720(unsigned __int16 a1, char *a2, char a3)
{
  char result; // al@4
  char v4; // al@5
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( (_BYTE)a1 )
  {
    if ( (unsigned __int8)a1 != 1 )
    {
      sub_10028BC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 188, 0, 0);
      return 0;
    }
    v4 = sub_10015AF0(1, 555, &v5, (int)&a1);
  }
  else
  {
    v4 = sub_10015AF0(1, 550, &v5, (int)&a1);
  }
  if ( !v4 )
    return 0;
  if ( sub_1001CD60((int)&v5) )
    return 0;
  result = 1;
  if ( !BYTE1(v14) || (unsigned int)a1 - 4 < 0x20 )
    return 0;
  if ( a3 )
  {
    if ( BYTE1(v5) == 26 )
    {
      qmemcpy(a2, (char *)&v6 + 1, 0x20u);
      qmemcpy(&unk_109C8C58, (char *)&v6 + 1, 0x20u);
      byte_109C8C50 = 1;
      byte_109C8C51 = 0;
      return result;
    }
  }
  else if ( BYTE1(v5) == 12 )
  {
    qmemcpy(a2, (char *)&v6 + 1, 0x20u);
    qmemcpy(&unk_109C8C78, (char *)&v6 + 1, 0x20u);
    byte_109C8C51 = 1;
    byte_109C8C52 = 1;
    return result;
  }
  return 0;
}
// 109C8C50: using guessed type char byte_109C8C50;
// 109C8C51: using guessed type char byte_109C8C51;
// 109C8C52: using guessed type char byte_109C8C52;

//----- (10045850) --------------------------------------------------------
char __cdecl sub_10045850(char a1, int a2)
{
  char result; // al@3
  char v3; // [sp+4h] [bp-44h]@1
  char v4; // [sp+8h] [bp-40h]@3
  char v5; // [sp+28h] [bp-20h]@3

  memset(&v3, 0, 0x44u);
  if ( (unsigned __int8)a1 < 2u && a2 )
  {
    result = sub_10038710(a1, (int)&v3);
    qmemcpy((void *)a2, &v4, 0x20u);
    qmemcpy((void *)(a2 + 32), &v5, 0x20u);
  }
  else
  {
    result = sub_10028BC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 570, 0, 0);
  }
  return result;
}

//----- (100458D0) --------------------------------------------------------
bool __cdecl sub_100458D0(void *a1)
{
  bool v1; // zf@2
  bool result; // al@4

  if ( a1 )
  {
    v1 = byte_109C8C50 == 0;
    qmemcpy(a1, &unk_109C8C58, 0x40u);
    result = !v1 && byte_109C8C52;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 617, 0, 0);
    result = 0;
  }
  return result;
}
// 109C8C50: using guessed type char byte_109C8C50;
// 109C8C52: using guessed type char byte_109C8C52;

//----- (10045920) --------------------------------------------------------
char __cdecl sub_10045920(char a1, int a2)
{
  char result; // al@4
  int v3; // edx@5
  const void *v4; // esi@8
  int v5; // [sp+0h] [bp-28h]@1
  int v6; // [sp+4h] [bp-24h]@1
  int v7; // [sp+8h] [bp-20h]@1
  int v8; // [sp+Ch] [bp-1Ch]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  int v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-Ch]@1
  int v13; // [sp+20h] [bp-8h]@1
  int v14; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  if ( j_HWM_pvg_read_reg(1) != 1 )
    sub_10028BC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 857, 1, 0);
  if ( a1 )
  {
    result = a1 - 1;
    if ( a1 != 1 )
      return result;
    result = sub_10030B40(15);
    v3 = 555;
  }
  else
  {
    result = sub_10030B40(8);
    v3 = 550;
  }
  if ( result )
  {
    v4 = (const void *)a2;
    LOBYTE(v5) = 12;
    BYTE1(v14) = 1;
    LOBYTE(v6) = 32;
    HIWORD(v5) = 34;
    if ( byte_109C8C51 )
    {
      BYTE1(v5) = 26;
    }
    else
    {
      BYTE1(v5) = 12;
      v4 = (const void *)(a2 + 32);
    }
    qmemcpy((char *)&v6 + 1, v4, 0x20u);
    result = sub_10015560(1, v3, &v5, 1, 38, 1);
  }
  return result;
}
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 109C8C51: using guessed type char byte_109C8C51;

//----- (10045A00) --------------------------------------------------------
__int16 __usercall sub_10045A00@<ax>(unsigned __int8 a1@<al>)
{
  return word_10100958[a1];
}
// 10100958: using guessed type __int16 word_10100958[];

//----- (10045A10) --------------------------------------------------------
char __cdecl sub_10045A10(unsigned __int8 a1, int *a2, const void *a3)
{
  int v3; // ebx@1
  unsigned int v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int v7; // [sp+14h] [bp-20h]@1
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+28h] [bp-Ch]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  int v14; // [sp+30h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v3 = (unsigned __int16)sub_10045A00(a1);
  v5 = *a2;
  qmemcpy(&v6, a3, 0x24u);
  sub_10015560(1, v3, &v5, 1, (v5 >> 16) + 4, 1);
  return sub_10015710(1, v3, 0xFFFFFFF);
}

//----- (10045AA0) --------------------------------------------------------
char __cdecl sub_10045AA0(unsigned __int8 a1, char a2)
{
  int v3; // [sp+4h] [bp-28h]@1
  int v4; // [sp+8h] [bp-24h]@1
  int v5; // [sp+Ch] [bp-20h]@1
  int v6; // [sp+10h] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@1
  int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+20h] [bp-Ch]@1
  int v11; // [sp+24h] [bp-8h]@1
  int v12; // [sp+28h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = 0;
  if ( a1 >= 2u )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\gma\\iop_gma_cnfg_intf.c", 736, 0, 0);
  }
  else
  {
    HIWORD(v3) = 0;
    LOBYTE(v3) = 12;
    if ( a2 == 11 )
    {
      BYTE1(v3) = byte_109C8C51 != 0 ? 25 : 11;
      sub_10045A10(a1, &v3, &v4);
      return 1;
    }
    if ( a2 == 17 )
    {
      LOWORD(v3) = 10042;
      sub_10045A10(a1, &v3, &v4);
      return 1;
    }
  }
  return 0;
}
// 109C8C51: using guessed type char byte_109C8C51;

//----- (10045B60) --------------------------------------------------------
bool __cdecl sub_10045B60(__int16 a1, char a2, int a3, int a4, void *a5)
{
  char v6; // [sp+4h] [bp-40h]@8
  char v7; // [sp+24h] [bp-20h]@11

  if ( (unsigned __int8)a1 == 8 )
  {
    LOBYTE(a1) = 0;
  }
  else
  {
    if ( (unsigned __int8)a1 != 9 )
      return 0;
    LOBYTE(a1) = 1;
  }
  if ( a2 == 1 )
  {
    sub_10045850(a1, (int)a5);
    return 1;
  }
  if ( byte_109C8C51 )
  {
    if ( sub_10045720(a1, &v6, 1) )
    {
LABEL_14:
      byte_109C8C53 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int8)++byte_109C8C53 >= 5u )
    {
      byte_109C8C50 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    if ( sub_10045720(a1, &v7, 0) )
      goto LABEL_14;
    if ( (unsigned __int8)++byte_109C8C53 >= 5u )
    {
      byte_109C8C52 = 0;
      goto LABEL_14;
    }
  }
LABEL_15:
  if ( j_HWM_pvg_read_reg(1) == 1 )
  {
    sub_10045850(a1, (int)&v6);
    sub_10045920(a1, (int)&v6);
  }
  sub_10045AA0(a1, 11);
  return sub_100458D0(a5);
}
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 109C8C50: using guessed type char byte_109C8C50;
// 109C8C51: using guessed type char byte_109C8C51;
// 109C8C52: using guessed type char byte_109C8C52;
// 109C8C53: using guessed type char byte_109C8C53;

//----- (10045C60) --------------------------------------------------------
char __thiscall sub_10045C60(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  char result; // al@2
  char v4; // [sp+8h] [bp-4h]@1

  dword_109C8C98 = sub_1002C5E0(this) != 2 ? 1379255385 : 1916032632;
  memset(&unk_109C8CA0, 0, 0xAA0u);
  v1 = 0;
  v4 = 0;
  v2 = &unk_109C8CA0;
  do
  {
    result = sub_100386E0(v4, (int)v2);
    ++v1;
    v2 = (char *)v2 + 2720;
    v4 = v1;
  }
  while ( (unsigned __int8)v1 < 2u );
  return result;
}
// 109C8C98: using guessed type int dword_109C8C98;

//----- (10045CD0) --------------------------------------------------------
char __usercall sub_10045CD0@<al>(__int16 a1@<bx>, __int16 a2@<di>, void *a3@<esi>, char a4)
{
  char result; // al@1

  memset(a3, 0, (unsigned __int16)a2);
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
      result = sub_10015A90(6, 8, a1, a2, a3);
  }
  else
  {
    result = sub_10015A90(6, 5, a1, a2, a3);
  }
  return result;
}

//----- (10045D10) --------------------------------------------------------
void *__usercall sub_10045D10@<eax>(char a1@<bl>, __int16 a2, __int16 a3, void *a4)
{
  int v4; // edi@1
  void *result; // eax@4

  v4 = 0;
  if ( dword_109C8C98 == 1379255385 )
    goto LABEL_4;
  v4 = sub_10060C90(86, 10);
  if ( !v4 )
  {
    memset((char *)&unk_109C8CA0 + 2720 * (unsigned __int8)a1, 0, 0xAA0u);
    sub_100386E0(a1, (int)&unk_109C8CA0 + 2720 * (unsigned __int8)a1);
LABEL_4:
    result = memcpy(a4, (char *)&unk_109C8CA0 + 2720 * (unsigned __int8)a1 + (unsigned __int16)a2, (unsigned __int16)a3);
    goto LABEL_6;
  }
  result = memset(a4, 0, (unsigned __int16)a3);
LABEL_6:
  if ( dword_109C8C98 != 1379255385 )
    result = (void *)sub_10060C60(v4, 86);
  return result;
}
// 109C8C98: using guessed type int dword_109C8C98;

//----- (10045DB0) --------------------------------------------------------
char __cdecl sub_10045DB0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 <= 0xAu )
    result = sub_10045CD0(4 * (a2 + 6), 4, a3, a1);
  return result;
}

//----- (10045DF0) --------------------------------------------------------
bool __cdecl sub_10045DF0(char a1, char a2, void *a3)
{
  bool result; // al@1
  unsigned __int8 v4; // al@3

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 <= 0xAu )
  {
    sub_10045D10(a1, 4 * ((unsigned __int8)a2 + 6), 4, a3);
    v4 = *((_BYTE *)a3 + 1);
    result = v4 < 0x33u || v4 >= 0x64u && v4 <= 0x81u || v4 >= 0x96u && v4 <= 0x9Eu;
  }
  return result;
}

//----- (10045E50) --------------------------------------------------------
char __cdecl sub_10045E50(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xAu )
    result = sub_10045CD0(a2, 1, a3, a1);
  return result;
}

//----- (10045E90) --------------------------------------------------------
char __cdecl sub_10045E90(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xAu )
  {
    sub_10045D10(a1, (unsigned __int8)a2, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10045EC0) --------------------------------------------------------
char __cdecl sub_10045EC0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0xBu )
    result = sub_10045CD0(a2 + 10, 1, a3, a1);
  return result;
}

//----- (10045F00) --------------------------------------------------------
char __cdecl sub_10045F00(char a1, char a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0xBu )
  {
    sub_10045D10(a1, (unsigned __int8)a2 + 10, 1, a3);
    result = 1;
  }
  return result;
}

//----- (10045F40) --------------------------------------------------------
char __cdecl sub_10045F40(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 2u )
    result = sub_10045CD0(16 * (a2 + 50), 16, a3, a1);
  return result;
}

//----- (10045F80) --------------------------------------------------------
bool __cdecl sub_10045F80(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 2u )
  {
    sub_10045D10(a1, 16 * ((unsigned __int8)a2 + 50), 16, a3);
    result = *(_BYTE *)a3 < 8u && *((_BYTE *)a3 + 1) < 8u;
  }
  return result;
}

//----- (10045FD0) --------------------------------------------------------
char __cdecl sub_10045FD0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x29u )
    result = sub_10045CD0(12 * a2 + 68, 12, a3, a1);
  return result;
}

//----- (10046010) --------------------------------------------------------
bool __cdecl sub_10046010(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x29u )
  {
    sub_10045D10(a1, 12 * (unsigned __int8)a2 + 68, 12, a3);
    result = *((_WORD *)a3 + 1) < 0x319u;
  }
  return result;
}

//----- (10046050) --------------------------------------------------------
char __cdecl sub_10046050(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && a2 < 0x2Au )
    result = sub_10045CD0(4 * (a2 + 140), 4, a3, a1);
  return result;
}

//----- (10046090) --------------------------------------------------------
bool __cdecl sub_10046090(char a1, char a2, void *a3)
{
  bool result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u && (unsigned __int8)a2 < 0x2Au )
  {
    sub_10045D10(a1, 4 * ((unsigned __int8)a2 + 140), 4, a3);
    result = *((_WORD *)a3 + 1) < 0x145u;
  }
  return result;
}

//----- (100460D0) --------------------------------------------------------
char __cdecl sub_100460D0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10045CD0(1229, 1, a2, a1);
  return result;
}

//----- (10046100) --------------------------------------------------------
char __cdecl sub_10046100(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10045D10(a1, 1229, 1, a2);
    result = 1;
  }
  return result;
}

//----- (10046130) --------------------------------------------------------
char __cdecl sub_10046130(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10045CD0(1212, 16, a2, a1);
  return result;
}

//----- (10046160) --------------------------------------------------------
char __cdecl sub_10046160(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10045D10(a1, 1212, 16, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10046190) --------------------------------------------------------
char __cdecl sub_10046190(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10045CD0(2400, 65, a2, a1);
  return result;
}

//----- (100461C0) --------------------------------------------------------
char __cdecl sub_100461C0(char a1, void *a2)
{
  char result; // al@2

  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10045D10(a1, 2400, 65, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100461F0) --------------------------------------------------------
char __cdecl sub_100461F0(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 < 8u && (unsigned __int8)a1 < 2u )
    result = sub_10045CD0(4 * (a2 + 182), 4, a3, a1);
  return result;
}

//----- (10046230) --------------------------------------------------------
char __cdecl sub_10046230(char a1, char a2, void *a3)
{
  char result; // al@2

  if ( (unsigned __int8)a2 > 7u )
    result = sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 1428, 0, 0);
  else
    result = (unsigned int)sub_10045D10(a1, 4 * ((unsigned __int8)a2 + 182), 4, a3);
  return result;
}

//----- (10046280) --------------------------------------------------------
char __cdecl sub_10046280(char a1, unsigned __int8 a2, void *a3)
{
  char result; // al@1

  result = 0;
  if ( a2 <= 4u )
    result = sub_10045CD0(8 * (a2 + 95), 8, a3, a1);
  return result;
}

//----- (100462C0) --------------------------------------------------------
char __cdecl sub_100462C0(char a1, char a2, void *a3)
{
  char result; // al@1

  result = a2;
  if ( (unsigned __int8)a2 <= 4u )
    result = (unsigned int)sub_10045D10(a1, 8 * ((unsigned __int8)a2 + 95), 8, a3);
  return result;
}

//----- (100462F0) --------------------------------------------------------
char __cdecl sub_100462F0(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10045CD0(22, 1, a2, a1);
  return result;
}

//----- (10046320) --------------------------------------------------------
char __cdecl sub_10046320(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
    result = sub_10045CD0(832, 4, a2, a1);
  return result;
}

//----- (10046350) --------------------------------------------------------
char __cdecl sub_10046350(char a1, void *a2)
{
  char result; // al@1

  result = 0;
  if ( (unsigned __int8)a1 < 2u )
  {
    sub_10045D10(a1, 832, 4, a2);
    result = 1;
  }
  return result;
}

//----- (10046380) --------------------------------------------------------
char __cdecl sub_10046380(int a1, char a2, char a3, int a4, void *a5)
{
  char result; // al@4
  char v6; // [sp+0h] [bp-4h]@1

  v6 = sub_10031AC0(a1);
  if ( v6 == 2 )
  {
LABEL_44:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 0:
        if ( a2 )
        {
          sub_10046230(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_100461F0(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 1:
        if ( a2 )
        {
          sub_100462C0(v6, *(_BYTE *)a4, a5);
          result = 1;
        }
        else
        {
          result = sub_10046280(v6, *(_BYTE *)a4, a5);
        }
        break;
      case 2:
        if ( a2 )
          result = sub_10045DF0(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10045DB0(v6, *(_BYTE *)a4, a5);
        break;
      case 3:
        if ( a2 )
          result = sub_10046010(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10045FD0(v6, *(_BYTE *)a4, a5);
        break;
      case 4:
        if ( a2 )
          result = sub_10046090(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10046050(v6, *(_BYTE *)a4, a5);
        break;
      case 5:
        if ( a2 )
          result = sub_10045E90(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10045E50(v6, *(_BYTE *)a4, a5);
        break;
      case 6:
        if ( a2 )
          result = sub_10045F00(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10045EC0(v6, *(_BYTE *)a4, a5);
        break;
      case 7:
        result = sub_100462F0(v6, a5);
        break;
      case 8:
        if ( a2 )
          result = sub_10046160(v6, a5);
        else
          result = sub_10046130(v6, a5);
        break;
      case 9:
        if ( a2 )
          result = sub_10045F80(v6, *(_BYTE *)a4, a5);
        else
          result = sub_10045F40(v6, *(_BYTE *)a4, a5);
        break;
      case 0x1D:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_100461C0(v6, a5);
        else
          result = sub_10046190(v6, a5);
        break;
      case 0x21:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10046100(v6, a5);
        else
          result = sub_100460D0(v6, a5);
        break;
      case 0x1B:
        if ( a2 || j_HWM_pvg_read_reg(1) )
          result = sub_10046350(v6, a5);
        else
          result = sub_10046320(v6, a5);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_cnfg_intf.c", 2329, 0, 0);
        goto LABEL_44;
    }
  }
  return result;
}
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10046720) --------------------------------------------------------
double __cdecl sub_10046720(int a1)
{
  double v1; // st6@1

  v1 = (double)(unsigned int)((*(int (**)(void))(dword_10A09228 + 8))() - a1);
  return (float)(1.0 / (double)(*(int (**)(void))(dword_10A09228 + 12))() * v1);
}
// 10A09228: using guessed type int dword_10A09228;

//----- (10046770) --------------------------------------------------------
int __cdecl sub_10046770(int a1)
{
  int result; // eax@1

  result = a1;
  dword_109CA1E0 = *(_DWORD *)a1;
  dword_109CA1E4 = *(_DWORD *)(a1 + 4);
  dword_109CA1E8 = *(_DWORD *)(a1 + 8);
  dword_109CA1EC = *(_DWORD *)(a1 + 12);
  dword_10A09228 = (int)&dword_109CA1E0;
  return result;
}
// 109CA1E0: using guessed type int dword_109CA1E0;
// 109CA1E4: using guessed type int dword_109CA1E4;
// 109CA1E8: using guessed type int dword_109CA1E8;
// 109CA1EC: using guessed type int dword_109CA1EC;
// 10A09228: using guessed type int dword_10A09228;

//----- (100467B0) --------------------------------------------------------
double __cdecl sub_100467B0(float a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@2
  double result; // st7@4
  float v5; // [sp+8h] [bp+4h]@4
  float v6; // [sp+8h] [bp+4h]@5
  float v7; // [sp+8h] [bp+4h]@6
  float v8; // [sp+8h] [bp+4h]@7

  v2 = (unsigned __int8)sub_1002C3A0(v1);
  if ( (_BYTE)v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        v6 = (float)778.90802 * a1;
        result = v6;
      }
      else
      {
        v5 = (float)850.76703 * a1;
        result = v5;
      }
    }
    else
    {
      v7 = (float)804.0722 * a1;
      result = v7;
    }
  }
  else
  {
    v8 = (float)718.95856 * a1;
    result = v8;
  }
  return result;
}

//----- (10046830) --------------------------------------------------------
char __cdecl sub_10046830(unsigned __int16 a1, float *a2)
{
  unsigned __int16 v2; // ax@2
  char result; // al@5
  char v4[4]; // [sp+1Ch] [bp-74h]@1
  int v5; // [sp+20h] [bp-70h]@3
  int v6; // [sp+24h] [bp-6Ch]@1
  char v7; // [sp+28h] [bp-68h]@1

  memset(&v7, 0, 0x64u);
  v6 = 0;
  if ( sub_10052B70(a1, v4, &v6) == 1 )
  {
    v2 = sub_10014DC0(v4[0]);
    if ( (unsigned __int16)v6 >= v2 )
    {
      if ( a1 )
      {
        sprintf(&v7, "NO PKT FOR TYPE %d\n", a1);
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 593, 0, &v7);
      }
    }
    else if ( sub_10015AC0(v4[0], v6, &v5) && !sub_100338A0((int)&v5, -9.9999996e24, 9.9999996e24, COERCE_INT(0.0), 0) )
    {
      result = 1;
      *a2 = *(float *)&v5;
      return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10046950) --------------------------------------------------------
double __cdecl sub_10046950(float a1)
{
  int v1; // ecx@0
  double result; // st7@1
  float v3; // [sp+0h] [bp-4h]@1
  float v4; // [sp+8h] [bp+4h]@1
  float v5; // [sp+8h] [bp+4h]@3

  v4 = *(float *)v1 * a1 + *(float *)(v1 + 4);
  v3 = *(float *)(v1 + 8);
  result = v4;
  if ( v3 >= (double)v4 )
    result = v3;
  v5 = *(float *)(v1 + 12);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (100469B0) --------------------------------------------------------
char __usercall sub_100469B0@<al>(int a1@<esi>, unsigned __int16 a2, float *a3)
{
  char v3; // dl@39
  char result; // al@39
  float v5; // [sp+0h] [bp-280h]@11
  float v6[19]; // [sp+4h] [bp-27Ch]@11
  float v7; // [sp+50h] [bp-230h]@11
  float v8[76]; // [sp+54h] [bp-22Ch]@11
  int v9; // [sp+17Ch] [bp-104h]@29
  int v10; // [sp+180h] [bp-100h]@29
  float v11; // [sp+184h] [bp-FCh]@29
  char v12; // [sp+197h] [bp-E9h]@1
  float v13; // [sp+198h] [bp-E8h]@1
  float v14; // [sp+19Ch] [bp-E4h]@1
  float v15; // [sp+1A0h] [bp-E0h]@1
  float v16; // [sp+1A4h] [bp-DCh]@1
  float v17; // [sp+1A8h] [bp-D8h]@1
  float v18; // [sp+1ACh] [bp-D4h]@1
  float v19; // [sp+1B0h] [bp-D0h]@17
  float v20; // [sp+1B4h] [bp-CCh]@37
  float v21; // [sp+1B8h] [bp-C8h]@22
  float v22; // [sp+1BCh] [bp-C4h]@17
  int v23; // [sp+1C0h] [bp-C0h]@1
  int v24[3]; // [sp+1C4h] [bp-BCh]@1
  int v25; // [sp+1D0h] [bp-B0h]@1
  int v26[3]; // [sp+1D4h] [bp-ACh]@1
  int v27; // [sp+1E0h] [bp-A0h]@1
  int v28; // [sp+1E4h] [bp-9Ch]@1
  int v29; // [sp+208h] [bp-78h]@1
  int v30; // [sp+20Ch] [bp-74h]@1
  int v31; // [sp+230h] [bp-50h]@1
  int v32; // [sp+234h] [bp-4Ch]@1
  int v33; // [sp+258h] [bp-28h]@1
  int v34; // [sp+25Ch] [bp-24h]@1

  v12 = 0;
  v25 = 0;
  v26[0] = 0;
  v23 = 0;
  v24[0] = 0;
  v27 = 0;
  v28 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0;
  v30 = 0;
  v13 = 0.0;
  v14 = 0.0;
  v15 = 0.0;
  v16 = 0.0;
  v17 = 0.0;
  v18 = 0.0;
  switch ( a2 )
  {
    case 0x3Au:
    case 0x3Bu:
      if ( sub_10060D80(6091, (int)&v23, 16) )
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 192, 0, 0);
      if ( sub_10060D80(6115, (int)&v25, 16) )
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 193, 0, 0);
      v16 = *((float *)&v23 + 2 * a1);
      v15 = *(float *)&v24[2 * a1];
      v13 = *((float *)&v25 + 2 * a1);
      v14 = *(float *)&v26[2 * a1];
      goto LABEL_37;
    case 0x3Cu:
    case 0x3Du:
    case 0x3Eu:
    case 0x3Fu:
    case 0x40u:
      if ( sub_10060D80(6090, (int)&v31, 40) )
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 205, 0, 0);
      if ( sub_10060D80(6114, (int)&v27, 40) )
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 206, 0, 0);
      v16 = *(&v7 + 2 * a2);
      v15 = v8[2 * a2];
      v13 = *(&v5 + 2 * a2);
      v14 = v6[2 * a2];
      goto LABEL_37;
    case 0x41u:
    case 0x42u:
    case 0x43u:
    case 0x44u:
    case 0x45u:
      if ( sub_10060D80(6092, (int)&v29, 40) )
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 218, 0, 0);
      if ( sub_10060D80(6116, (int)&v33, 40) )
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 219, 0, 0);
      v16 = *(&v5 + 2 * a2);
      v15 = v6[2 * a2];
      v13 = *(&v7 + 2 * a2);
      v14 = v8[2 * a2];
      goto LABEL_37;
    case 0x4Eu:
      v19 = 9.8999998e24;
      if ( sub_10060E40(6355, &v22, 4, &v19) )
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 228, 0, 0);
      sub_10061C40(14, &v12);
      if ( v12 == 10 )
        v22 = v22 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v22;
      v13 = 1.0;
      goto LABEL_37;
    case 0x4Fu:
      v19 = 9.8999998e24;
      if ( sub_10060E40(6356, &v21, 4, &v19) )
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", 250, 0, 0);
      sub_10061C40(14, &v12);
      if ( v12 == 10 )
        v21 = v21 * 0.5555555820465088;
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v17 = -9.9999996e24;
      v18 = 9.9999996e24;
      v14 = v21;
      v13 = 1.0;
      goto LABEL_37;
    case 0x98u:
    case 0x99u:
      v16 = 9.9999996e24;
      v15 = -9.9999996e24;
      v13 = 1.0;
      v14 = 0.0;
      goto LABEL_37;
    case 0x67u:
      if ( !sub_10060D80(6162, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 282;
      goto LABEL_36;
    case 0x68u:
    case 0xC0u:
      if ( !sub_10060D80(6161, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 287;
      goto LABEL_36;
    case 0x69u:
      if ( !sub_10060D80(6160, (int)&v13, 24) )
        goto LABEL_37;
      v11 = 0.0;
      v10 = 0;
      v9 = 291;
      goto LABEL_36;
    case 0x70u:
      if ( sub_10060D80(6235, (int)&v13, 24) )
      {
        v11 = 0.0;
        v10 = 0;
        v9 = 295;
LABEL_36:
        sub_10028BC0("..\\lib\\acl\\iop\\gea\\iop_gea_intf.c", v9, v10, (char *)LODWORD(v11));
      }
LABEL_37:
      if ( sub_10046830(a2, &v20) && (LODWORD(v20) & 0x7F800000) != 2139095040 )
      {
        *a3 = sub_10046950(v20);
        result = v3;
      }
      else
      {
        result = 0;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 100469B0: using guessed type int var_AC[3];
// 100469B0: using guessed type int var_BC[3];
// 100469B0: using guessed type float var_22C[76];
// 100469B0: using guessed type float var_27C[19];

//----- (10046EF0) --------------------------------------------------------
char __cdecl sub_10046EF0(int a1, float *a2)
{
  char v2; // bl@1
  char result; // al@8

  v2 = 1;
  if ( *(float *)(a1 + 4) > (double)*a2 )
  {
    if ( *(_BYTE *)(a1 + 19) )
    {
      if ( *(_BYTE *)(a1 + 19) == 1 )
        *a2 = *(float *)(a1 + 4);
    }
    else
    {
      v2 = 0;
    }
  }
  if ( *(float *)a1 >= (double)*a2 )
  {
    result = v2;
  }
  else if ( *(_BYTE *)(a1 + 20) )
  {
    result = v2;
    if ( *(_BYTE *)(a1 + 20) == 1 )
      *a2 = *(float *)a1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10046F50) --------------------------------------------------------
char __usercall sub_10046F50@<al>(unsigned __int16 a1@<ax>, int a2@<esi>, float a3, char a4, char a5)
{
  unsigned __int8 v5; // cl@1
  char v6; // dl@2
  char v7; // bl@4
  double v8; // st7@6
  int v9; // edi@6
  int v10; // ecx@6
  bool v11; // zf@10
  unsigned int v12; // eax@18
  char v14; // [sp+3h] [bp-5h]@1
  char v15; // [sp+4h] [bp-4h]@2
  char v16; // [sp+10h] [bp+8h]@10
  char v17; // [sp+14h] [bp+Ch]@10

  v5 = *(_BYTE *)(a2 + 10 * a1 + 22535);
  v14 = 10;
  if ( (unsigned __int8)a4 >= 9u )
  {
    v15 = 9;
    v6 = 9;
  }
  else
  {
    v6 = a4;
    v15 = a4;
  }
  v7 = a5;
  if ( (unsigned __int8)a5 >= 9u )
    v7 = 9;
  v8 = a3;
  v9 = v5;
  v10 = 10 * v5;
  if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v6) + 53416) >= (double)a3 )
  {
    if ( *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7) + 53416) <= v8 )
    {
      v11 = v7 == v6;
      v16 = 1;
      v17 = 0;
      if ( (unsigned __int8)v7 > (unsigned __int8)v6 )
      {
        v16 = -1;
        v17 = -1;
        v11 = v7 == v6;
      }
      if ( !v11 )
      {
        while ( *(float *)(a2 + 4 * ((unsigned __int8)v7 + v10) + 53416) > v8
             || *(float *)(a2 + 4 * (v10 + (unsigned __int8)v7 + v16) + 53416) < v8 )
        {
          v7 += v16;
          if ( v7 == v15 )
            goto LABEL_18;
        }
        v14 = v7 + v17;
      }
    }
    else
    {
      v14 = v7;
    }
  }
  else
  {
    v14 = v6;
  }
LABEL_18:
  v12 = *(_BYTE *)(44 * v9 + a2 + 52576) - 2;
  if ( (unsigned __int8)v14 < v12 )
    LOBYTE(v12) = v14;
  return v12;
}

//----- (10047060) --------------------------------------------------------
double __usercall sub_10047060@<st0>(int a1@<eax>, _BYTE *a2@<ebx>, int a3, float a4)
{
  int v4; // esi@1
  unsigned __int8 v5; // al@1
  int v6; // edi@2
  unsigned __int8 v7; // al@2
  char v8; // al@6
  double v9; // st7@7
  double result; // st7@7
  char v11; // [sp+14h] [bp-8h]@4
  char v12; // [sp+18h] [bp-4h]@4
  float v13; // [sp+24h] [bp+8h]@7

  v4 = a1;
  v5 = *(_BYTE *)(a1 + 10 * (unsigned __int16)a3 + 22535);
  if ( v5 >= 0x14u )
  {
    *a2 = 1;
    result = a4;
  }
  else
  {
    v6 = v5;
    v7 = *(_BYTE *)(44 * v5 + v4 + 52576);
    if ( v7 <= 1u || v7 > 0xAu )
      goto LABEL_12;
    v11 = 0;
    v12 = v7 - 1;
    if ( *(float *)(v4 + 4 * (10 * v6 + (unsigned __int8)(v7 - 1)) + 53416) < (double)*(float *)(v4 + 40 * v6 + 53416) )
    {
      v11 = v7 - 1;
      v12 = 0;
    }
    v8 = sub_10046F50(a3, v4, a4, v12, v11);
    if ( (unsigned __int8)v8 >= 9u )
    {
LABEL_12:
      *a2 = 1;
      result = a4;
    }
    else
    {
      v9 = *(float *)(v4 + 4 * ((unsigned __int8)v8 + 2 * (9 * v6 + 6777))) * a4
         + *(float *)(v4 + 4 * ((unsigned __int8)v8 + 18 * v6) + 54252);
      *a2 = 1;
      v13 = v9;
      result = v13;
    }
  }
  return result;
}

//----- (10047160) --------------------------------------------------------
unsigned __int8 __cdecl sub_10047160(int a1, int a2, char a3, void *a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  unsigned __int8 result; // al@1
  int v7; // edi@1
  int v8; // esi@4
  char v9; // bl@7
  int v10; // edi@7
  char v11; // al@7
  int v12; // edx@7
  char v13; // al@8
  char v14; // dl@8
  unsigned __int8 v15; // [sp+16h] [bp-156h]@1
  char v16; // [sp+17h] [bp-155h]@7
  int v17; // [sp+18h] [bp-154h]@1
  int v18; // [sp+1Ch] [bp-150h]@1
  int v19; // [sp+20h] [bp-14Ch]@1
  char v20[12]; // [sp+24h] [bp-148h]@7
  float v21[78]; // [sp+30h] [bp-13Ch]@8

  *(float *)a4 = 9.8999998e24;
  v4 = a2;
  v5 = *(_WORD *)(a2 + 16);
  result = 0;
  v7 = a1;
  v17 = a1;
  v19 = a2;
  v15 = 0;
  v18 = v5;
  while ( v15 < *(_BYTE *)(v4 + 18) )
  {
    v5 = (unsigned __int16)v5;
    v8 = v7 + 10 * (unsigned __int16)v5 + 22534;
    switch ( *(_BYTE *)v8 )
    {
      case 1:
        result = sub_10030F60(
                   *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22538),
                   *(_WORD *)(v7 + 2 * (5 * v5 + 11270)),
                   *(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22542),
                   4,
                   a4);
        break;
      case 3:
        result = sub_1005D120(COERCE_FLOAT(*(_WORD *)(v7 + 10 * (unsigned __int16)v5 + 22538)), a4);
        break;
      case 4:
        v9 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v10 = *(_BYTE *)(v7 + 10 * (unsigned __int16)v5 + 22539);
        v11 = sub_10067EF0((unsigned int)*(_BYTE *)(v8 + 5) >> 3, 1);
        v12 = *(_BYTE *)(v8 + 4);
        v16 = v11;
        result = sub_10030F60(6, (unsigned __int16)word_10102714[v12], 0, 324, v20);
        if ( result )
        {
          v13 = v16;
          v14 = v16;
          *(float *)a4 = v21[v10];
          result = ((unsigned __int8)v20[(unsigned __int8)v13] >> (v9 - 8 * v14)) & 1;
        }
        v7 = v17;
        break;
    }
    ++v15;
    v5 = v18++ + 1;
    if ( result )
    {
      v15 = result;
      goto LABEL_15;
    }
    v4 = v19;
  }
  v15 = result;
  if ( !result )
    return result;
LABEL_15:
  if ( a3 )
  {
    *(float *)a4 = sub_10047060(v7, &v15, v5 - 1, *(float *)a4);
    result = v15;
  }
  return result;
}
// 10102714: using guessed type __int16 word_10102714[];
// 10047160: using guessed type char var_148[12];
// 10047160: using guessed type float var_13C[78];

//----- (100472F0) --------------------------------------------------------
char __cdecl sub_100472F0(unsigned __int16 a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(float *)a2 = 9.8999998e24;
  v2 = sub_10047680(a1);
  v3 = sub_10030F80();
  if ( v2 && v3 && *(_WORD *)(v2 + 12) == 6 )
  {
    result = sub_10047160(v3, v2, 1, a2);
    if ( result )
      result = sub_10046EF0(v2, (float *)a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047350) --------------------------------------------------------
char __cdecl sub_10047350(int a1, int a2, void *a3)
{
  char v3; // bl@1
  int v4; // eax@1
  unsigned __int16 v5; // bp@1
  int v6; // esi@4
  int v7; // eax@6
  char v8; // al@7
  unsigned __int8 v9; // dl@10
  __int16 v10; // cx@10
  char v11; // dl@12
  char v12; // ST2C_1@13
  char v13; // bl@14
  float v14; // ST30_4@16
  double v15; // st7@16
  char v16; // ST2C_1@16
  char v18; // [sp+18h] [bp-5Ch]@10
  char v19; // [sp+18h] [bp-5Ch]@14
  unsigned __int8 v20; // [sp+1Bh] [bp-59h]@1
  unsigned __int16 v21; // [sp+1Ch] [bp-58h]@14
  unsigned int v22; // [sp+20h] [bp-54h]@12
  int v23; // [sp+24h] [bp-50h]@1
  int v24; // [sp+28h] [bp-4Ch]@1
  unsigned __int64 v25; // [sp+2Ch] [bp-48h]@13
  char v26[8]; // [sp+34h] [bp-40h]@14
  char v27[8]; // [sp+3Ch] [bp-38h]@15
  char v28[44]; // [sp+44h] [bp-30h]@7

  v3 = 0;
  v24 = a1;
  v4 = a2;
  *(_BYTE *)a3 = 0;
  v5 = *(_WORD *)(a2 + 16);
  v23 = a2;
  v20 = 0;
  while ( v20 < *(_BYTE *)(v4 + 18) )
  {
    v6 = v24 + 10 * v5 + 22534;
    if ( *(_BYTE *)v6 == 1 )
    {
      v14 = (double)*(_WORD *)(v24 + 10 * v5 + 22542) * 0.125;
      v15 = sub_10067F30(v14, 1.0);
      v16 = *(_WORD *)(v6 + 8) % 8;
      v3 = sub_10030F60(*(_BYTE *)(v6 + 4), *(_WORD *)(v6 + 6), (signed int)v15, 1, a3);
      v11 = ((unsigned __int8)(1 << v16) & *(_BYTE *)a3) != 0;
LABEL_17:
      *(_BYTE *)a3 = v11;
    }
    else if ( *(_BYTE *)v6 == 2 )
    {
      v7 = *(_BYTE *)(v24 + 10 * v5 + 22538);
      switch ( v7 )
      {
        case 0:
        case 1:
          v3 = sub_10030F60(6, (unsigned __int16)word_10102760[v7], 0, 44, v28);
          v8 = v28[*(_BYTE *)(v6 + 5)];
          *(_BYTE *)a3 = v8 == 1;
          if ( !v8 || v8 == 3 )
            v3 = 0;
          break;
        case 2:
        case 3:
        case 4:
          v9 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          v10 = 0;
          v18 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          if ( v9 >= 0x18u )
          {
            v10 = 4;
            v18 = v9 - 24;
          }
          v3 = sub_10030F60(0, (unsigned __int16)word_10102760[v7], v10, 4, &v22);
          v11 = (v22 >> v18) & 1;
          goto LABEL_17;
        case 5:
        case 6:
        case 7:
        case 8:
          v12 = *(_BYTE *)(v24 + 10 * v5 + 22539) - 79;
          v3 = sub_10030F60(0, (unsigned __int16)word_10102760[v7], 0, 8, &v25);
          *(_BYTE *)a3 = (v25 >> v12) & 1;
          break;
        case 9:
        case 10:
        case 11:
        case 12:
          v13 = *(_BYTE *)(v24 + 10 * v5 + 22539);
          v21 = sub_10067EF0((unsigned int)*(_BYTE *)(v24 + 10 * v5 + 22539) >> 3, 1);
          v19 = v13 - 8 * v21;
          v3 = sub_10030F60(6, (unsigned __int16)word_10102760[*(_BYTE *)(v6 + 4)], 0, 16, v26);
          if ( !v3 )
            break;
          v3 = ((unsigned __int8)v26[v21] >> v19) & 1;
          v11 = ((unsigned __int8)v27[v21] >> v19) & 1;
          goto LABEL_17;
        default:
          break;
      }
    }
    ++v20;
    ++v5;
    if ( v3 )
      break;
    v4 = v23;
  }
  return v3;
}
// 10102760: using guessed type __int16 word_10102760[];
// 10047350: using guessed type char var_30[44];
// 10047350: using guessed type char var_40[8];
// 10047350: using guessed type char var_38[8];

//----- (100475F0) --------------------------------------------------------
char __cdecl sub_100475F0(unsigned __int16 a1, void *a2)
{
  int v2; // esi@1
  int v3; // eax@1
  char result; // al@4

  *(_BYTE *)a2 = 0;
  v2 = sub_10047680(a1);
  v3 = sub_10030F80();
  if ( v2 && v3 && !*(_WORD *)(v2 + 12) )
    result = sub_10047350(v3, v2, a2);
  else
    result = 0;
  return result;
}

//----- (10047640) --------------------------------------------------------
int __usercall sub_10047640@<eax>(unsigned __int16 a1@<di>)
{
  int v1; // eax@1
  unsigned __int16 v2; // cx@3
  int result; // eax@4

  v1 = sub_10030F80();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 14400), v2 < 0x3840u) )
    result = v1 + 24 * v2;
  else
    result = 0;
  return result;
}

//----- (10047680) --------------------------------------------------------
int __cdecl sub_10047680(unsigned __int16 a1)
{
  int result; // eax@1
  int v2; // esi@1

  result = sub_10047640(a1);
  v2 = result;
  if ( !result )
  {
    sub_10028BC0("..\\lib\\acl\\dat\\dat_intf.c", 100, 0, 0);
    result = v2;
  }
  return result;
}

//----- (100476B0) --------------------------------------------------------
BOOL __cdecl sub_100476B0(unsigned __int16 a1)
{
  return sub_10047640(a1) != 0;
}

//----- (100476D0) --------------------------------------------------------
int __cdecl sub_100476D0(unsigned __int8 *a1, int a2)
{
  int result; // eax@1

  result = sub_10033B00(a1, 0, 0x1Eu, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10047700) --------------------------------------------------------
int __cdecl sub_10047700(_BYTE *a1, int a2)
{
  int result; // eax@1

  result = sub_10033B50(a1, 0, 0x80u, 0, a2);
  if ( result != 1 && !result )
    result = 0;
  return result;
}

//----- (10047730) --------------------------------------------------------
char *__cdecl sub_10047730(char **a1)
{
  char *v1; // edx@1
  int v2; // edi@1
  char *result; // eax@1
  char *v4; // eax@3
  char v5; // cl@4
  int v6; // eax@5
  char v7; // cl@7

  v1 = *a1;
  v2 = 0;
  result = &byte_10080D49;
  if ( *a1 && *v1 )
  {
    v4 = *a1;
    do
      v5 = *v4++;
    while ( v5 );
    v6 = v4 - (v1 + 1) - 1;
    do
    {
      if ( v6 < 0 )
        break;
      v7 = v1[v6];
      if ( v7 == 47 || v7 == 92 )
        v2 = v6 + 1;
      --v6;
    }
    while ( !v2 );
    result = &v1[v2];
  }
  return result;
}

//----- (10047780) --------------------------------------------------------
int sub_10047780()
{
  int v0; // esi@1
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v0 = 0;
  v1 = sub_10060830();
  result = 0;
  while ( 1 )
  {
    v3 = dword_109CA20C[result];
    if ( v3 == v1 )
      break;
    if ( !v0 && v3 == -1 )
      v0 = result;
    if ( (unsigned int)++result >= 5 )
    {
      dword_109CA20C[v0] = v1;
      return v0;
    }
  }
  return result;
}
// 109CA20C: using guessed type int dword_109CA20C[];

//----- (100477C0) --------------------------------------------------------
int __cdecl sub_100477C0(_BYTE *a1, int a2)
{
  int result; // eax@3
  int v3; // esi@3
  _BYTE *v4; // ecx@4
  char v5; // dl@5

  if ( a1 )
  {
    if ( a2 )
    {
      result = 0;
      v3 = 0;
      if ( *a1 )
      {
        v4 = a1;
        do
        {
          v5 = v4[a2 - (_DWORD)a1];
          if ( !v5 )
            break;
          if ( *v4 != v5 )
          {
            result = a1[v3] - *(_BYTE *)(v3 + a2);
            if ( a1[v3] != *(_BYTE *)(v3 + a2) )
              return result;
            break;
          }
          ++v4;
          ++v3;
        }
        while ( *v4 );
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(v3 + a2) )
      {
        result = -1;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10047830) --------------------------------------------------------
signed int __cdecl sub_10047830(_BYTE *a1, int a2)
{
  _BYTE *v2; // esi@1
  int v3; // ebp@1
  int v4; // ebx@4
  int v5; // edi@6
  int v6; // eax@6
  signed int result; // eax@11
  int v8; // [sp+8h] [bp-4h]@3

  v2 = a1;
  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = 0;
      if ( *a1 )
      {
        v4 = a2 - (_DWORD)a1;
        while ( v2[v4] )
        {
          v5 = tolower(*v2);
          v6 = tolower(v2[v4]);
          if ( v5 != v6 )
          {
            v8 = v5 - v6;
            if ( v5 != v6 )
              goto LABEL_16;
            break;
          }
          ++v2;
          ++v3;
          if ( !*v2 )
            break;
        }
      }
      if ( a1[v3] )
      {
        result = 1;
      }
      else if ( *(_BYTE *)(a2 + v3) )
      {
        result = -1;
      }
      else
      {
LABEL_16:
        result = v8;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100478D0) --------------------------------------------------------
int __usercall sub_100478D0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ecx>)
{
  int result; // eax@5

  if ( a1 && *a1 )
  {
    if ( a2 && *a2 )
      result = 3 - (sub_10047830(a2, (int)a1) != 0);
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047900) --------------------------------------------------------
signed int __usercall sub_10047900@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, int a3@<esi>, int a4, char *a5)
{
  int v5; // ebp@1
  int v6; // edi@1
  signed int result; // eax@2
  const char *v8; // [sp-8h] [bp-18h]@11
  int v9; // [sp-4h] [bp-14h]@11
  int v10; // [sp+8h] [bp-8h]@14
  int v11; // [sp+Ch] [bp-4h]@17
  signed int v12; // [sp+14h] [bp+4h]@3

  v5 = a4;
  v6 = 0;
  *(_DWORD *)a4 = a1;
  switch ( a1 )
  {
    case 0:
      sprintf(a5, "Too many arguments for command");
      result = 8;
      break;
    case 1:
      v12 = 9;
      while ( sub_10047830((_BYTE *)a3, (int)(&off_10103268)[8 * v6]) )
      {
        if ( (unsigned int)++v6 >= 0xD )
        {
          sprintf(a5, "Error converting '%s' to a boolean", a3);
          goto LABEL_25;
        }
      }
      ++*a2;
      result = 0;
      *(_BYTE *)(v5 + 4) = byte_1010326C[8 * v6];
      break;
    case 2:
      if ( !*(_BYTE *)a3 || *(_BYTE *)(a3 + 1) )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a char";
        goto LABEL_12;
      }
      *(_BYTE *)(a4 + 4) = *(_BYTE *)a3;
      result = 0;
      break;
    case 3:
      if ( sub_1006AAB7(a3, (int)&unk_100AC4D0, (unsigned int)&v10) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a sint32";
        goto LABEL_12;
      }
      *(_DWORD *)(a4 + 4) = v10;
      ++*a2;
      result = 0;
      break;
    case 4:
      if ( sub_1006AAB7(a3, (int)&unk_1007F988, (unsigned int)&v11) != 1 )
      {
        v9 = a3;
        v8 = "Error converting '%s' to a uint32";
LABEL_12:
        sprintf(a5, v8, v9);
        goto LABEL_13;
      }
      *(_DWORD *)(a4 + 4) = v11;
      ++*a2;
      result = 0;
      break;
    case 6:
      if ( sub_1006AAB7(a3, (int)"%f", a4 + 4) == 1 )
        goto LABEL_23;
      sprintf(a5, "Error converting '%s' to a float", a3);
LABEL_13:
      result = 9;
      break;
    case 5:
      strncpy((char *)(a4 + 4), (const char *)a3, 0x50u);
LABEL_23:
      ++*a2;
      result = 0;
      break;
    default:
      v12 = 9;
      *(_DWORD *)v5 = 0;
      sprintf(a5, "Command definition error: Unsupported argument type (%d)", a1);
LABEL_25:
      result = v12;
      break;
  }
  return result;
}
// 10103268: using guessed type char *off_10103268;

//----- (10047AD0) --------------------------------------------------------
char *__usercall sub_10047AD0@<eax>(char *result@<eax>, const char *a2@<edi>, int a3@<esi>)
{
  if ( a2 )
  {
    if ( (_BYTE)result && *(_BYTE *)a3 )
    {
      if ( *a2 )
      {
        strncat((char *)a3, " ", 0x100u);
        result = strncat((char *)a3, a2, 0x100u);
        *(_BYTE *)(a3 + 255) = 0;
        return result;
      }
    }
    else
    {
      result = strncpy((char *)a3, a2, 0x100u);
    }
    *(_BYTE *)(a3 + 255) = 0;
  }
  else if ( !(_BYTE)result )
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

//----- (10047B30) --------------------------------------------------------
int __usercall sub_10047B30@<eax>(int a1@<esi>, int a2, _DWORD *a3)
{
  unsigned int v3; // edi@4
  int v4; // ebx@5
  int v5; // eax@6
  int result; // eax@9
  int v7; // ecx@10

  if ( a1 && *(_DWORD *)(a1 + 8) && *(_BYTE *)(80 * *a3 + a2) )
  {
    v3 = 0;
    if ( *(_DWORD *)(a1 + 12) <= 0u )
    {
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = v4 + *(_DWORD *)(a1 + 8);
        if ( *(_DWORD *)(v5 + 12) < 2u && !sub_10047830((_BYTE *)(a2 + 80 * *a3), *(_DWORD *)v5) )
          break;
        ++v3;
        v4 += 40;
        if ( v3 >= *(_DWORD *)(a1 + 12) )
          return 0;
      }
      v7 = *(_DWORD *)(a1 + 8);
      ++*a3;
      result = v7 + 40 * v3;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047BC0) --------------------------------------------------------
int __usercall sub_10047BC0@<eax>(int a1@<eax>, _DWORD *a2@<ebx>, unsigned int a3, int a4)
{
  int v4; // edi@1
  unsigned int v5; // ebp@1
  int v6; // esi@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  do
  {
    if ( v5 >= a3 )
      break;
    if ( *(_DWORD *)(v6 + 12) >= 2u && sub_100478D0(*(_BYTE **)v6, (_BYTE *)(a4 + 80 * *a2)) == 3 )
    {
      ++*a2;
      v4 = v6;
    }
    ++v5;
    v6 += 40;
  }
  while ( !v4 );
  return v4;
}

//----- (10047C10) --------------------------------------------------------
char **__usercall sub_10047C10@<eax>(int (**a1)(void)@<ebx>, int a2, _DWORD *a3)
{
  char **result; // eax@1
  int v4; // edi@1
  int (**v5)(void); // eax@2
  char **v6; // eax@3
  char **v7; // esi@3
  char *v8; // eax@3

  result = 0;
  v4 = 0;
  if ( *a1 )
  {
    v5 = a1;
    while ( 1 )
    {
      v6 = (char **)(*v5)();
      v7 = v6;
      v8 = sub_10047730(v6);
      if ( !sub_10047830((_BYTE *)(a2 + 80 * *a3), (int)v8) )
        break;
      v5 = &a1[++v4];
      if ( !a1[v4] )
        return 0;
    }
    ++*a3;
    result = v7;
  }
  return result;
}

//----- (10047C70) --------------------------------------------------------
const char *__usercall sub_10047C70@<eax>(int a1@<eax>)
{
  const char *result; // eax@3

  if ( a1 )
  {
    if ( a1 == 1 )
      result = "Group";
    else
      result = "Command";
  }
  else
  {
    result = "Case";
  }
  return result;
}

//----- (10047C90) --------------------------------------------------------
int __usercall sub_10047C90@<eax>(unsigned int a1@<ebx>)
{
  int (**v1)(void); // esi@1
  unsigned int v2; // edi@1
  int result; // eax@4

  v1 = (int (**)(void))dword_109CA1F8[sub_10047780()];
  v2 = 0;
  if ( a1 )
  {
    while ( v1 && *v1 )
    {
      result = (*v1)();
      ++v2;
      ++v1;
      if ( v2 >= a1 )
        return result;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 109CA1F8: using guessed type int dword_109CA1F8[];

//----- (10047CD0) --------------------------------------------------------
int __usercall sub_10047CD0@<eax>(signed int *a1@<eax>, _DWORD *a2@<ecx>, int a3, int a4, char *a5)
{
  signed int *v5; // ebx@1
  int result; // eax@1
  _DWORD *v7; // edi@2
  int *v8; // ebp@2
  _BYTE *v9; // esi@4
  signed int v10; // ebx@9
  signed int v11; // [sp+8h] [bp-4h]@2

  v5 = a1;
  result = 0;
  if ( a3 )
  {
    v7 = a2;
    v8 = (int *)(a3 + 16);
    v11 = 5;
    do
    {
      if ( result || (v9 = (_BYTE *)(80 * *v5 + a4), !*v9) )
        *v7 = 0;
      else
        result = sub_10047900(*v8, v5, (int)v9, (int)v7, a5);
      ++v8;
      v7 += 21;
      --v11;
    }
    while ( v11 );
    if ( !result )
    {
      v10 = *v5;
      if ( v10 < 5 )
      {
        if ( *(_DWORD *)(a3 + 4 * v10 + 16) )
        {
          sprintf(a5, "Missing required command argument");
          result = 7;
        }
      }
    }
  }
  return result;
}

//----- (10047D60) --------------------------------------------------------
int __usercall sub_10047D60@<eax>(_BYTE *a1@<eax>, _DWORD *a2@<esi>, int a3, char *a4)
{
  int v4; // ebx@1
  signed int v5; // edx@1
  _BYTE *v6; // edi@1
  signed int v7; // ebp@1
  signed int v8; // ecx@1
  int v9; // ecx@3
  char v10; // al@4
  signed int v11; // edi@21
  int result; // eax@27
  char v13; // [sp+Fh] [bp-9h]@1
  signed int v14; // [sp+10h] [bp-8h]@1
  int v15; // [sp+14h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v6 = a1;
  v14 = 3;
  v15 = 0;
  v7 = 0;
  v13 = 0;
  *a2 = 0;
  v8 = 9;
  do
  {
    *a1 = 0;
    a1 += 80;
    --v8;
  }
  while ( v8 );
  v9 = a3;
  if ( !*(_BYTE *)a3 )
    return 3;
  while ( 1 )
  {
    v10 = *(_BYTE *)(v4 + v9);
    if ( v13 )
    {
      if ( v13 != v10 )
        goto LABEL_15;
      v13 = 0;
LABEL_18:
      v9 = a3;
      goto LABEL_19;
    }
    if ( v10 != 34 && v10 != 39 )
      break;
    v13 = *(_BYTE *)(v4 + v9);
LABEL_19:
    if ( !*(_BYTE *)(++v4 + v9) )
      goto LABEL_23;
  }
  if ( v10 == 32 || v10 == 9 )
  {
    if ( v7 )
    {
      ++*a2;
      v7 = 0;
      v5 = 0;
    }
    v15 = v4;
    goto LABEL_19;
  }
LABEL_15:
  if ( *a2 >= 8 )
  {
    v11 = 5;
    sprintf(a4, "Too many parameters. Maximum of %d parameters supported.", 8);
    goto LABEL_24;
  }
  if ( v5 < 80 )
  {
    *(&v6[80 * *a2] + v5) = v10;
    v7 = 1;
    ++v5;
    v14 = 0;
    *(&v6[80 * *a2] + v5) = 0;
    goto LABEL_18;
  }
  v14 = 6;
  sprintf(a4, "Parameter too long (starting at %s). Maximum parameter length supported is %d.", v15 + a3 + 1, 80);
LABEL_23:
  v11 = v14;
LABEL_24:
  if ( v7 )
  {
    if ( !v13 )
    {
      ++*a2;
      goto LABEL_27;
    }
    sprintf(a4, "Parameter %d missing closing quote", *a2);
    result = 6;
  }
  else
  {
LABEL_27:
    result = v11;
  }
  return result;
}

//----- (10047EB0) --------------------------------------------------------
int __usercall sub_10047EB0@<eax>(_DWORD *a1@<eax>, void (__cdecl *a2)(signed int, void *)@<ebx>, int a3@<esi>)
{
  _DWORD *v3; // edi@1
  int result; // eax@1
  int v5; // ecx@2
  int v6; // eax@4
  int v7; // edi@4
  int v8; // edi@7

  v3 = a1;
  result = 0;
  if ( a3 )
  {
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        sub_10049C00(5, *(_DWORD *)a3);
        v6 = (*(int (**)(void))(a3 + 8))();
        sub_10048790(v3, v6, 0);
        v7 = -*v3;
        sub_10049C00(9, *(_DWORD *)a3);
        result = v7;
      }
    }
    else
    {
      sub_10049C00(6, *(_DWORD *)a3);
      if ( a2 )
        a2(5, &unk_10102F20);
      sub_1005D9D0(a3);
      v8 = -*v3;
      if ( a2 )
        a2(6, &unk_10102F20);
      sub_10049C00(8, *(_DWORD *)a3);
      result = v8;
    }
  }
  return result;
}

//----- (10047F50) --------------------------------------------------------
int __usercall sub_10047F50@<eax>(int result@<eax>)
{
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 28) = 0;
  *(_BYTE *)(result + 33) = 0;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 24) = 1;
  *(_BYTE *)(result + 32) = 1;
  *(_DWORD *)(result + 36) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 52) = 0;
  return result;
}

//----- (10047F90) --------------------------------------------------------
char *__cdecl sub_10047F90(int a1, char *a2, int a3, const char *a4)
{
  const char *v4; // ecx@0
  const char *v5; // ebx@1
  char *v6; // eax@1
  char *v7; // ecx@1
  char *result; // eax@3
  char *v9; // eax@5
  const char *v10; // edi@5
  const char **v11; // ebx@8
  char *v12; // eax@10
  const char *v13; // edi@10
  char **v14; // ebp@10
  const char *v15; // edi@12
  char *v16; // [sp+10h] [bp-624h]@8
  signed int v17; // [sp+14h] [bp-620h]@10
  int v18[6]; // [sp+18h] [bp-61Ch]@2
  char v19; // [sp+30h] [bp-604h]@1
  char v20; // [sp+130h] [bp-504h]@5
  char v21; // [sp+230h] [bp-404h]@7
  char v22; // [sp+330h] [bp-304h]@10
  char v23; // [sp+430h] [bp-204h]@10
  char v24; // [sp+530h] [bp-104h]@10

  v5 = v4;
  v6 = 0;
  v7 = &v19;
  do
  {
    v18[(signed int)v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( (unsigned int)v6 < 6 );
  LOBYTE(v6) = 0;
  result = sub_10047AD0(v6, "command", (int)&v19);
  if ( a3 )
  {
    LOBYTE(result) = 0;
    if ( a4 )
    {
      v9 = sub_10047AD0(result, a4, (int)&v20);
      v10 = v5;
    }
    else
    {
      v9 = sub_10047AD0(result, v5, (int)&v20);
      v10 = &byte_10080D49;
    }
    LOBYTE(v9) = 0;
    sub_10047AD0(v9, v10, (int)&v21);
    result = a2;
    if ( a2 )
    {
      v11 = (const char **)(a1 + 36);
      v16 = a2;
      do
      {
        if ( (unsigned int)*(v11 - 6) >= 2 )
        {
          LOBYTE(result) = 0;
          v12 = sub_10047AD0(result, *v11, (int)&v24);
          v13 = *(v11 - 9);
          LOBYTE(v12) = 1;
          v22 = 0;
          sub_10047AD0(v12, v13, (int)&v22);
          v23 = 0;
          v14 = (char **)(v11 - 5);
          v17 = 5;
          do
          {
            switch ( *v14 )
            {
              case 1u:
                v15 = "<bool>";
                goto LABEL_19;
              case 2u:
                v15 = "<char>";
                goto LABEL_19;
              case 3u:
                v15 = "<sint32>";
                goto LABEL_19;
              case 4u:
                v15 = "<uint32>";
                goto LABEL_19;
              case 6u:
                v15 = "<float>";
                goto LABEL_19;
              case 5u:
                v15 = "<str>";
                goto LABEL_19;
              case 0u:
                break;
              default:
                v15 = "<*?*>";
LABEL_19:
                sub_10047AD0(*v14, v15, (int)&v23);
                break;
            }
            ++v14;
            --v17;
          }
          while ( v17 );
          result = (char *)sub_10049B90(2, (int)v18, 6);
        }
        v11 += 10;
        --v16;
      }
      while ( v16 );
    }
  }
  return result;
}
// 10047F90: using guessed type int var_61C[6];

//----- (10048140) --------------------------------------------------------
int __usercall sub_10048140@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  int v2; // ST08_4@1
  char *v3; // eax@1
  int result; // eax@1
  int (__cdecl *v5)(signed int, void *); // esi@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = sub_10047730((char **)a1);
  result = sub_10049C20(4, (int)v3, v2);
  v5 = *(int (__cdecl **)(signed int, void *))(v1 + 16);
  if ( v5 )
    result = v5(4, &unk_10102F20);
  return result;
}

//----- (10048170) --------------------------------------------------------
int __usercall sub_10048170@<eax>(int a1@<esi>)
{
  void (__cdecl *v1)(signed int, void *); // eax@1
  char v2; // al@3

  v1 = *(void (__cdecl **)(signed int, void *))(a1 + 16);
  if ( v1 )
    v1(7, &unk_10102F20);
  v2 = (unsigned int)sub_10047730((char **)a1);
  return sub_10049C00(10, v2);
}

//----- (100481A0) --------------------------------------------------------
void __cdecl sub_100481A0(int (**a1)(void), char **a2, _DWORD *a3)
{
  int v3; // esi@3
  int (**v4)(void); // ebx@4
  char **v5; // eax@6
  char *v6; // ST1C_4@6
  char *v7; // eax@6
  char *v8; // eax@7
  char *v9; // eax@9
  char *v10; // eax@10
  int v11; // ebp@12
  signed int v12; // ebx@12
  const char *v13; // eax@14
  char *v14; // ST18_4@14
  int v15; // ST14_4@14
  char *v16; // eax@14
  int v17; // ecx@18
  unsigned int v18; // eax@18
  int v19; // eax@20
  int v20; // ecx@20
  char v21; // dl@20
  int v22; // ST14_4@30
  char *v23; // ST10_4@30
  const char *v24; // eax@31
  char *v25; // ST18_4@31
  int v26; // ST14_4@31
  char *v27; // ST10_4@31
  int v28; // edx@34
  int v29; // ecx@34
  int v30; // eax@34
  int v31; // ST14_4@37
  char *v32; // eax@37
  int v33; // eax@38
  int v34; // ST14_4@39
  char *v35; // ST10_4@39
  int v36; // ST14_4@41
  char *v37; // eax@41
  int v38; // eax@42
  int v39; // ST14_4@43
  char *v40; // eax@43
  int v41; // ST14_4@45
  char *v42; // eax@45
  int v43; // ST14_4@48
  char *v44; // eax@48
  int v45; // edx@49
  int v46; // ST14_4@50
  char *v47; // ST10_4@50
  char *v48; // eax@54
  unsigned int v49; // [sp+4h] [bp-8h]@12
  unsigned int v50; // [sp+8h] [bp-4h]@15
  int v51; // [sp+10h] [bp+4h]@16

  if ( a1 )
  {
    if ( *a1 )
    {
      v3 = (*a1)();
      if ( !a2 )
      {
        v4 = a1 + 1;
        if ( a1 != (int (**)(void))-4 )
        {
          do
          {
            if ( !*v4 )
              break;
            v5 = (char **)(*v4)();
            v6 = sub_10047730(v5);
            v7 = sub_10047730((char **)v3);
            if ( !sub_100477C0(v7, (int)v6) )
            {
              v8 = sub_10047730((char **)v3);
              sub_10049CC0(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"2872",
                (int)v8,
                (int)"Suite name has been used more than once");
              *a3 = 12;
            }
            ++v4;
          }
          while ( v4 );
        }
      }
      v9 = sub_10047730((char **)v3);
      if ( strchr(v9, 32) )
      {
        v10 = sub_10047730((char **)v3);
        sub_10049CC0(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"2903",
          (int)v10,
          (int)"Suite name includes spaces so it must be quoted");
        *a3 = 10;
      }
      if ( *(_DWORD *)(v3 + 12) )
      {
        v11 = 0;
        v49 = 1;
        v12 = 20;
        while ( 1 )
        {
          if ( strchr(*(const char **)(*(_DWORD *)(v3 + 8) + v11), 32) )
          {
            v13 = sub_10047C70(*(_DWORD *)(*(_DWORD *)(v3 + 8) + v11 + 12));
            v14 = sub_1004A6E0("%s name includes spaces so it must be quoted", v13);
            v15 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
            v16 = sub_10047730((char **)v3);
            sub_10049D00(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_runner.c", (int)"2915", (int)v16, v15, (int)v14);
            *a3 = 10;
          }
          v50 = v49;
          if ( v49 < *(_DWORD *)(v3 + 12) )
          {
            v51 = v11 + 40;
            do
            {
              if ( !sub_100477C0(*(_BYTE **)(*(_DWORD *)(v3 + 8) + v11), *(_DWORD *)(v51 + *(_DWORD *)(v3 + 8))) )
              {
                v17 = *(_DWORD *)(v3 + 8);
                v18 = *(_DWORD *)(v17 + v11 + 12);
                if ( v18 < 2 || *(_DWORD *)(v51 + v17 + 12) < 2u )
                {
                  v24 = sub_10047C70(v18);
                  v25 = sub_1004A6E0("%s name has been used more than once", v24);
                  v26 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
                  v27 = sub_10047730((char **)v3);
                  sub_10049D00(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2958",
                    (int)v27,
                    v26,
                    (int)v25);
                }
                else
                {
                  v19 = *(_DWORD *)(v3 + 8);
                  v20 = *(_DWORD *)(v51 + v17 + 16);
                  v21 = 0;
                  if ( *(_DWORD *)(v12 + v19 - 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 4) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 8) != v20 )
                    v21 = 1;
                  if ( *(_DWORD *)(v12 + v19 + 12) != v20 || v21 )
                    goto LABEL_33;
                  v22 = *(_DWORD *)(v19 + v11);
                  v23 = sub_10047730((char **)v3);
                  sub_10049D00(
                    3,
                    (int)"**Error**",
                    (int)"..\\lib\\utf\\utf_runner.c",
                    (int)"2946",
                    (int)v23,
                    v22,
                    (int)"Command name has been used more than once");
                }
                *a3 = 12;
              }
LABEL_33:
              v51 += 40;
              ++v50;
            }
            while ( v50 < *(_DWORD *)(v3 + 12) );
          }
          v28 = *(_DWORD *)(v3 + 8);
          v29 = *(_DWORD *)(v28 + v11 + 12);
          v30 = v28 + v11;
          if ( !v29 )
            break;
          if ( v29 == 1 )
          {
            if ( !*(_DWORD *)(v30 + 8) )
            {
              v36 = *(_DWORD *)v30;
              v37 = sub_10047730((char **)v3);
              sub_10049D00(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3047",
                (int)v37,
                v36,
                (int)"Test group has a NULL function pointer or a command uses a reserved ID");
              *a3 = 12;
            }
            v38 = *(_DWORD *)(v3 + 8) + v11;
            if ( *(_DWORD *)(v38 + 4) )
            {
              v39 = *(_DWORD *)v38;
              v40 = sub_10047730((char **)v3);
              sub_10049D00(
                3,
                (int)"**Warning**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3058",
                (int)v40,
                v39,
                (int)"Test group has a non-NULL test case function pointer");
              *a3 = 10;
            }
            if ( a2 )
            {
              v41 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + v11);
              v42 = sub_10047730((char **)v3);
              sub_10049D00(
                3,
                (int)"**Error**",
                (int)"..\\lib\\utf\\utf_runner.c",
                (int)"3070",
                (int)v42,
                v41,
                (int)"Test group contains a test group");
              *a3 = 12;
            }
            else
            {
              sub_100481A0(*(_DWORD *)(v3 + 8) + v11 + 8, v3, a3);
            }
            goto LABEL_52;
          }
          if ( *(_DWORD *)(v30 + 4) )
          {
            v31 = *(_DWORD *)v30;
            v32 = sub_10047730((char **)v3);
            sub_10049D00(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3088",
              (int)v32,
              v31,
              (int)"Command include a non-NULL test case function pointer");
            *a3 = 10;
          }
          v33 = *(_DWORD *)(v3 + 8) + v11;
          if ( *(_DWORD *)(v33 + 8) )
          {
            v34 = *(_DWORD *)v33;
            v35 = sub_10047730((char **)v3);
            sub_10049D00(
              3,
              (int)"**Warning**",
              (int)"..\\lib\\utf\\utf_runner.c",
              (int)"3099",
              (int)v35,
              v34,
              (int)"Command include a non-NULL test group function pointer");
LABEL_51:
            *a3 = 10;
          }
LABEL_52:
          ++v49;
          v12 += 40;
          v11 += 40;
          if ( v49 - 1 >= *(_DWORD *)(v3 + 12) )
            return;
        }
        if ( !*(_DWORD *)(v30 + 4) )
        {
          v43 = *(_DWORD *)v30;
          v44 = sub_10047730((char **)v3);
          sub_10049D00(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"3022",
            (int)v44,
            v43,
            (int)"Test case has a NULL function pointer or a command uses a reserved ID");
          *a3 = 12;
        }
        v45 = *(_DWORD *)(v3 + 8);
        if ( !*(_DWORD *)(v45 + v11 + 8) )
          goto LABEL_52;
        v46 = *(_DWORD *)(v45 + v11);
        v47 = sub_10047730((char **)v3);
        sub_10049D00(
          3,
          (int)"**Warning**",
          (int)"..\\lib\\utf\\utf_runner.c",
          (int)"3033",
          (int)v47,
          v46,
          (int)"Test case has a non-NULL group function pointer");
        goto LABEL_51;
      }
    }
    else
    {
      v48 = sub_10047730(a2);
      sub_10049CC0(
        3,
        (int)"**Error**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"3114",
        (int)v48,
        (int)"Test suite has a NULL function pointer or a command uses a reserved ID");
      *a3 = 12;
    }
  }
}

//----- (10048610) --------------------------------------------------------
int sub_10048610()
{
  int (**i)(void); // esi@1
  int v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  for ( i = (int (**)(void))dword_109CA1F8[sub_10047780()]; i; ++i )
  {
    if ( !*i )
      break;
    sub_100481A0(i, 0, &v2);
  }
  return v2;
}
// 109CA1F8: using guessed type int dword_109CA1F8[];

//----- (10048660) --------------------------------------------------------
void *sub_10048660()
{
  void *result; // eax@1
  signed int v1; // esi@1

  dword_109CA1F8[0] = 0;
  dword_109CA1FC = 0;
  dword_109CA200 = 0;
  dword_109CA204 = 0;
  dword_109CA208 = 0;
  result = &unk_109CA220;
  dword_109CA20C[0] = -1;
  dword_109CA210 = -1;
  dword_109CA214 = -1;
  dword_109CA218 = -1;
  dword_109CA21C = -1;
  v1 = 5;
  do
  {
    result = (void *)(sub_10047F50((int)result) + 56);
    --v1;
  }
  while ( v1 );
  return result;
}
// 109CA1F8: using guessed type int dword_109CA1F8[];
// 109CA1FC: using guessed type int dword_109CA1FC;
// 109CA200: using guessed type int dword_109CA200;
// 109CA204: using guessed type int dword_109CA204;
// 109CA208: using guessed type int dword_109CA208;
// 109CA20C: using guessed type int dword_109CA20C[];
// 109CA210: using guessed type int dword_109CA210;
// 109CA214: using guessed type int dword_109CA214;
// 109CA218: using guessed type int dword_109CA218;
// 109CA21C: using guessed type int dword_109CA21C;

//----- (100486C0) --------------------------------------------------------
char *sub_100486C0()
{
  return (char *)&unk_109CA220 + 56 * sub_10047780();
}

//----- (100486E0) --------------------------------------------------------
char sub_100486E0()
{
  return sub_100486C0()[33];
}

//----- (100486F0) --------------------------------------------------------
char __cdecl sub_100486F0(int a1, int a2, unsigned int a3)
{
  char *v3; // esi@1
  char result; // al@1

  v3 = sub_100486C0();
  result = a1 - 6;
  if ( a1 == 6 )
  {
    *(_DWORD *)v3 = 0;
  }
  else
  {
    result = a1 - 7;
    if ( a1 == 7 )
    {
      result = sub_10049780(a2, a3);
      if ( result )
        ++*(_DWORD *)v3;
    }
  }
  return result;
}

//----- (10048730) --------------------------------------------------------
int *__usercall sub_10048730@<eax>(_DWORD *a1@<ebx>, int a2)
{
  int *v2; // edi@1
  unsigned int v3; // ebp@1
  int **v4; // esi@1

  v2 = 0;
  v3 = 0;
  v4 = (int **)(sub_100486C0() + 36);
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 && !sub_10047830((_BYTE *)(a2 + 80 * *a1), **v4) )
    {
      v2 = *v4;
      ++*a1;
    }
    ++v3;
    ++v4;
  }
  while ( !v2 );
  return v2;
}

//----- (10048780) --------------------------------------------------------
char **sub_10048780()
{
  return &off_101032D0;
}
// 101032D0: using guessed type char *off_101032D0;

//----- (10048790) --------------------------------------------------------
int __cdecl sub_10048790(_DWORD *a1, int a2, int a3)
{
  char *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // ebp@7
  int v6; // [sp+8h] [bp-8h]@0
  int v7; // [sp+8h] [bp-8h]@7
  int v8; // [sp+Ch] [bp-4h]@8

  sub_1004E950();
  v3 = sub_100486C0();
  if ( v3[34] )
  {
    result = v6;
  }
  else
  {
    result = sub_10048610();
    if ( result != 12 )
      v3[34] = 1;
  }
  if ( v3[34] )
  {
    sub_10048140(a2);
    if ( a3 )
    {
      v7 = sub_10047EB0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), a3);
    }
    else
    {
      v5 = 0;
      v7 = 0;
      if ( *(_DWORD *)(a2 + 12) )
      {
        v8 = 0;
        do
        {
          v7 += sub_10047EB0(a1, *(void (__cdecl **)(signed int, void *))(a2 + 16), v8 + *(_DWORD *)(a2 + 8));
          v8 += 40;
          ++v5;
        }
        while ( v5 < *(_DWORD *)(a2 + 12) );
        sub_10048170(a2);
        return v7;
      }
    }
    sub_10048170(a2);
    result = v7;
  }
  return result;
}

//----- (10048840) --------------------------------------------------------
int __cdecl sub_10048840(int a1, int a2, int a3, const char *a4, const char *a5)
{
  int v5; // ebp@1
  unsigned int v6; // eax@1
  char *v7; // ecx@1
  int result; // eax@3
  int v9; // eax@5
  char *v10; // eax@7
  char *v11; // eax@7
  char *v12; // eax@7
  char *v13; // eax@7
  char *v14; // eax@7
  char **v15; // eax@7
  char **v16; // esi@7
  char *v17; // eax@7
  char *v18; // eax@7
  char *v19; // eax@7
  char *v20; // eax@7
  char *v21; // eax@8
  char *v22; // eax@9
  const char *v23; // edi@9
  char *v24; // eax@11
  int v25; // [sp+8h] [bp-41Ch]@4
  int v26[4]; // [sp+10h] [bp-414h]@2
  char v27; // [sp+20h] [bp-404h]@1
  char v28; // [sp+120h] [bp-304h]@7
  char v29; // [sp+220h] [bp-204h]@7
  char v30; // [sp+320h] [bp-104h]@11

  v5 = a1;
  v6 = 0;
  v7 = &v27;
  do
  {
    v26[v6] = (int)v7;
    *v7 = 0;
    ++v6;
    v7 += 256;
  }
  while ( v6 < 4 );
  result = a2;
  if ( a2 )
  {
    v25 = a2;
    do
    {
      v9 = *(_DWORD *)(v5 + 12);
      if ( v9 )
      {
        result = v9 - 1;
        if ( !result )
        {
          v10 = sub_10047AD0(0, "group", (int)&v27);
          LOBYTE(v10) = 0;
          v11 = sub_10047AD0(v10, a4, (int)&v28);
          LOBYTE(v11) = 0;
          sub_10047AD0(v11, *(const char **)v5, (int)&v29);
          v12 = (char *)sub_10049B90(2, (int)v26, 3);
          LOBYTE(v12) = 0;
          v13 = sub_10047AD0(v12, "group", (int)&v27);
          LOBYTE(v13) = 0;
          v14 = sub_10047AD0(v13, a4, (int)&v28);
          LOBYTE(v14) = 0;
          sub_10047AD0(v14, "group-begin", (int)&v29);
          sub_10049B90(2, (int)v26, 3);
          v15 = (char **)(*(int (**)(void))(v5 + 8))();
          v16 = v15;
          v17 = sub_10047730(v15);
          sub_10048840(v16[2], v16[3], v16[4], v17, a4);
          sub_10047730(v16);
          v18 = sub_10047F90((int)v16[2], v16[3], (int)v16[4], a4);
          LOBYTE(v18) = 0;
          v19 = sub_10047AD0(v18, "group", (int)&v27);
          LOBYTE(v19) = 0;
          v20 = sub_10047AD0(v19, a4, (int)&v28);
          LOBYTE(v20) = 0;
          sub_10047AD0(v20, "group-end", (int)&v29);
          result = sub_10049B90(2, (int)v26, 3);
        }
      }
      else
      {
        v21 = sub_10047AD0(0, "case", (int)&v27);
        LOBYTE(v21) = 0;
        if ( a5 )
        {
          v22 = sub_10047AD0(v21, a5, (int)&v28);
          v23 = a4;
        }
        else
        {
          v22 = sub_10047AD0(v21, a4, (int)&v28);
          v23 = &byte_10080D49;
        }
        LOBYTE(v22) = 0;
        v24 = sub_10047AD0(v22, v23, (int)&v29);
        LOBYTE(v24) = 0;
        sub_10047AD0(v24, *(const char **)v5, (int)&v30);
        result = sub_10049B90(2, (int)v26, 4);
      }
      v5 += 40;
      --v25;
    }
    while ( v25 );
  }
  return result;
}
// 10048840: using guessed type int var_414[4];

//----- (10048A50) --------------------------------------------------------
char *__usercall sub_10048A50@<eax>(const char *a1@<ecx>, const char *a2@<ebx>, int a3, char *a4, int a5, char a6)
{
  const char *v6; // edi@1
  char *v7; // eax@1
  char *v8; // ecx@1
  char *v9; // eax@3
  char *result; // eax@3
  int v11[2]; // [sp+Ch] [bp-20Ch]@2
  char v12; // [sp+14h] [bp-204h]@1
  char v13; // [sp+114h] [bp-104h]@3

  v6 = a1;
  v7 = 0;
  v8 = &v12;
  do
  {
    v11[(signed int)v7] = (int)v8;
    *v8 = 0;
    ++v7;
    v8 += 256;
  }
  while ( (unsigned int)v7 < 2 );
  LOBYTE(v7) = 0;
  v9 = sub_10047AD0(v7, v6, (int)&v12);
  LOBYTE(v9) = 0;
  result = sub_10047AD0(v9, a2, (int)&v13);
  if ( v13 )
    result = (char *)sub_10049B90(2, (int)v11, 2);
  if ( a6 )
  {
    sub_10048840(a3, (int)a4, a5, a2, 0);
    result = sub_10047F90(a3, a4, a5, 0);
  }
  return result;
}
// 10048A50: using guessed type int var_20C[2];

//----- (10048B10) --------------------------------------------------------
char *__cdecl sub_10048B10(char a1)
{
  int (**i)(void); // edi@1
  int v2; // esi@3
  char *v3; // ebx@3
  char **v4; // esi@4
  signed int v5; // edi@4
  char *result; // eax@5

  for ( i = (int (**)(void))dword_109CA1F8[sub_10047780()]; i; ++i )
  {
    if ( !*i )
      break;
    v2 = (*i)();
    v3 = sub_10047730((char **)v2);
    sub_10048A50("suite", v3, *(_DWORD *)(v2 + 8), *(char **)(v2 + 12), *(_DWORD *)(v2 + 16), a1);
  }
  v4 = (char **)(sub_100486C0() + 36);
  v5 = 5;
  do
  {
    result = *v4;
    if ( *v4 )
    {
      if ( *((_DWORD *)result + 2) )
        result = sub_10048A50(
                   "listener",
                   *(const char **)result,
                   *((_DWORD *)result + 3),
                   *((char **)result + 4),
                   *((_DWORD *)result + 2),
                   a1);
    }
    ++v4;
    --v5;
  }
  while ( v5 );
  return result;
}
// 109CA1F8: using guessed type int dword_109CA1F8[];

//----- (10048BB0) --------------------------------------------------------
int *__cdecl sub_10048BB0(_BYTE *a1)
{
  int (**v1)(void); // edi@1
  char **v2; // eax@3
  char **v3; // esi@3
  char *v4; // eax@3
  char *v5; // eax@6
  char *v6; // ebx@7
  unsigned int v7; // esi@7
  int **v8; // edi@7
  int *result; // eax@8

  v1 = (int (**)(void))dword_109CA1F8[sub_10047780()];
  if ( v1 )
  {
    while ( *v1 )
    {
      v2 = (char **)(*v1)();
      v3 = v2;
      v4 = sub_10047730(v2);
      if ( !sub_10047830(a1, (int)v4) )
      {
        v5 = sub_10047730(v3);
        sub_10048A50("suite", v5, (int)v3[2], v3[3], (int)v3[4], 1);
        break;
      }
      ++v1;
      if ( !v1 )
        break;
    }
  }
  v6 = sub_100486C0();
  v7 = 0;
  v8 = (int **)(v6 + 36);
  while ( 1 )
  {
    result = *v8;
    if ( *v8 )
    {
      result = (int *)sub_10047830(a1, *result);
      if ( !result )
        break;
    }
    ++v7;
    ++v8;
    if ( v7 >= 5 )
      return result;
  }
  return (int *)sub_10048A50(
                  "listener",
                  **(const char ***)&v6[4 * v7 + 36],
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 12),
                  *(char **)(*(_DWORD *)&v6[4 * v7 + 36] + 16),
                  *(_DWORD *)(*(_DWORD *)&v6[4 * v7 + 36] + 8),
                  1);
}
// 109CA1F8: using guessed type int dword_109CA1F8[];

//----- (10048C70) --------------------------------------------------------
int __usercall sub_10048C70@<eax>(int a1@<eax>)
{
  int v1; // edi@1
  bool v2; // zf@1
  int result; // eax@1
  signed int v4; // ebp@3
  int v5; // eax@5
  int v6; // eax@8
  int v7; // ecx@14
  int v8; // esi@18
  unsigned int v9; // eax@18
  int v10; // eax@19
  int v11; // edi@25

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 20) == 0;
  result = 12;
  if ( !v2 && !*(_BYTE *)(v1 + 24) )
  {
    v4 = 2;
    if ( !*(_DWORD *)(v1 + 16) )
    {
      *(_DWORD *)(v1 + 16) = sub_10047C90(++*(_DWORD *)(v1 + 12));
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 4) = 0;
    }
    v5 = *(_DWORD *)(v1 + 16);
    if ( v5 )
    {
      if ( *(_DWORD *)(v1 + 20) == 1 )
      {
        sub_10048790((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        v6 = sub_10047C90(++*(_DWORD *)(v1 + 12));
        v2 = *(_DWORD *)(v1 + 28) == 0;
        *(_DWORD *)(v1 + 16) = v6;
        *(_DWORD *)(v1 + 8) = 0;
        if ( !v2 || !v6 )
          *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 28) == 2 )
      {
        sub_10048790((_DWORD *)v1, v5, *(_DWORD *)(v1 + 8));
        *(_BYTE *)(v1 + 24) = 1;
      }
      else if ( *(_DWORD *)(v1 + 8)
             || (*(_DWORD *)(v1 + 4) = 0, v7 = *(_DWORD *)(v5 + 8), (*(_DWORD *)(v1 + 8) = v7) != 0) )
      {
        if ( !*(_DWORD *)(v1 + 4) )
          sub_10048140(v5);
        sub_10047EB0(
          (_DWORD *)v1,
          *(void (__cdecl **)(signed int, void *))(*(_DWORD *)(v1 + 16) + 16),
          *(_DWORD *)(v1 + 8));
        v8 = *(_DWORD *)(v1 + 16);
        v9 = ++*(_DWORD *)(v1 + 4);
        if ( *(_DWORD *)(v8 + 12) > v9 )
        {
          *(_DWORD *)(v1 + 8) = *(_DWORD *)(v8 + 8) + 40 * v9;
        }
        else
        {
          sub_10048170(v8);
          v10 = sub_10047C90(++*(_DWORD *)(v1 + 12));
          *(_DWORD *)(v1 + 16) = v10;
          *(_DWORD *)(v1 + 4) = 0;
          *(_DWORD *)(v1 + 8) = 0;
          if ( !v10 || *(_DWORD *)(v1 + 28) )
            *(_BYTE *)(v1 + 24) = 1;
        }
      }
      else
      {
        *(_BYTE *)(v1 + 24) = 1;
        v4 = 12;
      }
    }
    else
    {
      *(_BYTE *)(v1 + 24) = 1;
      v4 = 12;
    }
    if ( *(_BYTE *)(v1 + 24) && v4 == 2 )
    {
      v11 = *(_DWORD *)v1;
      if ( v11 )
        result = v11 + 12;
      else
        result = 0;
    }
    else
    {
      result = v4;
    }
  }
  return result;
}

//----- (10048DD0) --------------------------------------------------------
signed int __usercall sub_10048DD0@<eax>(int a1@<esi>)
{
  signed int v1; // ebp@1
  int (**i)(void); // edi@2
  int v3; // eax@4
  signed int result; // eax@5

  v1 = 0;
  if ( *(_DWORD *)(a1 + 20) )
  {
    if ( *(_BYTE *)(a1 + 24) )
    {
      *(_DWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)(a1 + 28) = 0;
      *(_BYTE *)(a1 + 24) = 0;
      result = 1;
    }
    else
    {
      result = 12;
    }
  }
  else
  {
    for ( i = (int (**)(void))dword_109CA1F8[sub_10047780()]; i; ++i )
    {
      if ( !*i )
        break;
      v3 = (*i)();
      v1 += sub_10048790((_DWORD *)a1, v3, 0);
    }
    result = v1;
  }
  return result;
}
// 109CA1F8: using guessed type int dword_109CA1F8[];

//----- (10048E40) --------------------------------------------------------
int __cdecl sub_10048E40(int a1, int a2)
{
  int v2; // ebx@1
  char *v3; // esi@1
  int v4; // ebx@3
  int result; // eax@3
  _BYTE *v6; // esi@5
  int v7; // ebx@6
  int v8; // ebx@8
  int v9; // ebx@9
  int (**i)(void); // edi@11
  int v11; // eax@13
  int (__cdecl *v12)(int, int); // eax@14
  int (**v13)(void); // esi@19
  int v14; // eax@21
  int (__cdecl *v15)(int, int); // eax@22

  v2 = 0;
  v3 = sub_100486C0();
  switch ( a1 )
  {
    case 9:
      sub_10049C00(2, (unsigned int)"begin");
      if ( *(_DWORD *)a2 )
      {
        if ( *(_DWORD *)a2 == 5 )
        {
          v6 = (_BYTE *)(a2 + 4);
          if ( sub_10047830((_BYTE *)(a2 + 4), (int)"-v") )
          {
            if ( sub_10047830(v6, (int)"-q") )
            {
              sub_10048BB0(v6);
              v9 = sub_10048610();
              sub_10049C00(2, (unsigned int)"end");
              result = v9;
            }
            else
            {
              sub_10048B10(0);
              v8 = sub_10048610();
              sub_10049C00(2, (unsigned int)"end");
              result = v8;
            }
          }
          else
          {
            sub_10048B10(1);
            v7 = sub_10048610();
            sub_10049C00(2, (unsigned int)"end");
            result = v7;
          }
        }
        else
        {
          sub_10049C80(
            3,
            (int)"**Error**",
            (int)"..\\lib\\utf\\utf_runner.c",
            (int)"1719",
            (int)"Unsupported argument type for help command (internal error)");
          sub_10049C00(2, (unsigned int)"end");
          result = 4;
        }
      }
      else
      {
        sub_10048B10(0);
        v4 = sub_10048610();
        sub_10049C00(2, (unsigned int)"end");
        result = v4;
      }
      return result;
    case 2:
      sub_10049C00(0, (unsigned int)"Global reset command");
      for ( i = (int (**)(void))dword_109CA1F8[sub_10047780()]; i; ++i )
      {
        if ( !*i )
          break;
        v11 = (*i)();
        if ( v11 )
        {
          v12 = *(int (__cdecl **)(int, int))(v11 + 16);
          if ( v12 )
          {
            if ( v12 != sub_10048E40 )
              v12(2, (int)&unk_10102F20);
          }
        }
      }
      sub_1004E950();
      v3[34] = 0;
      return 0;
    case 3:
      sub_10049C00(1, (unsigned int)"Global clear command");
      v13 = (int (**)(void))dword_109CA1F8[sub_10047780()];
      if ( !v13 )
        return v2;
      break;
    case 10:
      if ( !*((_DWORD *)v3 + 5) )
      {
        sub_10049C80(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1764", (int)"Step mode not enabled");
        goto LABEL_29;
      }
      return sub_10048C70((int)v3);
    case 11:
      if ( v3[24] )
      {
        *((_DWORD *)v3 + 5) = 0;
        v3[24] = 0;
        result = 0;
      }
      else
      {
        sub_10049C80(3, (int)"**Error**", (int)"..\\lib\\utf\\utf_runner.c", (int)"1783", (int)"Step mode is busy");
LABEL_29:
        result = 12;
      }
      return result;
    case 12:
      *((_DWORD *)v3 + 5) = 1;
      return 0;
    case 13:
      *((_DWORD *)v3 + 5) = 2;
      return 0;
    case 8:
      return sub_10048DD0((int)v3);
    case 14:
      exit_1(12);
      return result;
    case 4:
    case 5:
    case 6:
    case 7:
      return v2;
    default:
      sub_10049C80(
        3,
        (int)"**Warning**",
        (int)"..\\lib\\utf\\utf_runner.c",
        (int)"1820",
        (int)"Unknown/unsupported command (internal error)");
      return 4;
  }
  while ( *v13 )
  {
    v14 = (*v13)();
    if ( v14 )
    {
      v15 = *(int (__cdecl **)(int, int))(v14 + 16);
      if ( v15 )
      {
        if ( v15 != sub_10048E40 )
          v15(3, (int)&unk_10102F20);
      }
    }
    ++v13;
    if ( !v13 )
      return 0;
  }
  return v2;
}
// 10048E40: using guessed type int __cdecl sub_10048E40(int, int);
// 109CA1F8: using guessed type int dword_109CA1F8[];

//----- (10049120) --------------------------------------------------------
char **sub_10049120()
{
  return off_101030C4;
}
// 101030C4: using guessed type char *off_101030C4[3];

//----- (10049130) --------------------------------------------------------
int __usercall sub_10049130@<eax>(unsigned int a1@<edx>, int (__cdecl *a2)(_DWORD, char *)@<ecx>, int a3@<esi>, int a4, signed int *a5, char *a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  char **v9; // eax@6
  signed int v10; // ebx@6
  int v11; // [sp+0h] [bp-1C0h]@0
  int (__cdecl *v12)(_DWORD, char *); // [sp+14h] [bp-1ACh]@1
  char v13; // [sp+18h] [bp-1A8h]@2

  v12 = a2;
  v6 = sub_10047BC0(a4, a5, a1, v11);
  v7 = v6;
  if ( v6 )
  {
    result = sub_10047CD0(a5, &v13, v6, a3, a6);
    if ( !result )
    {
      if ( v12 )
      {
        result = v12(*(_DWORD *)(v7 + 12), &v13);
      }
      else
      {
        sprintf(a6, "'%s' does not support commands", a3);
        result = 11;
      }
    }
  }
  else
  {
    v9 = sub_10049120();
    v10 = *a5;
    if ( (char *)a4 == v9[2] )
      sprintf(a6, "Invalid or missing test suite, listener, or command: '%s'", a3 + 80 * v10);
    else
      sprintf(a6, "Invalid or mising test case or command: '%s'", a3 + 80 * v10);
    result = 10;
  }
  return result;
}

//----- (10049220) --------------------------------------------------------
int __cdecl sub_10049220(char *a1)
{
  int v1; // ecx@0
  int v2; // ebx@1
  char *v3; // edi@1
  char *v4; // eax@1
  int result; // eax@1
  int v6; // eax@4
  char **v7; // ebx@4
  int v8; // eax@5
  int *v9; // eax@20
  char **v10; // eax@22
  int v11; // [sp+10h] [bp-2DCh]@4
  int v12; // [sp+14h] [bp-2D8h]@1
  char v13[720]; // [sp+18h] [bp-2D4h]@1

  v2 = v1;
  v3 = sub_100486C0();
  *a1 = 0;
  v4 = sub_1004A6E0("Processing command '%s'", v2);
  sub_10049C80(3, (int)&unk_10103A58, (int)"..\\lib\\utf\\utf_runner.c", (int)"1215", (int)v4);
  result = sub_10047D60(v13, &v12, v2, a1);
  if ( result )
  {
    if ( result == 3 )
    {
      if ( *((_DWORD *)v3 + 5) && !v3[24] )
        result = sub_10048C70((int)v3);
    }
    else
    {
      sprintf(a1, "Invalid command: '%s'", v2);
      result = 10;
    }
  }
  else
  {
    if ( !v12 )
      return sub_10048DD0((int)v3);
    v11 = 0;
    v6 = sub_10047780();
    v7 = sub_10047C10((int (**)(void))dword_109CA1F8[v6], (int)v13, &v11);
    if ( v7 )
    {
      v8 = sub_10047B30((int)v7, (int)v13, &v11);
      if ( !v8 )
        goto LABEL_30;
      if ( *(_DWORD *)(v8 + 12) == 1 )
      {
        v7 = (char **)(*(int (**)(void))(v8 + 8))();
        v8 = sub_10047B30((int)v7, (int)v13, &v11);
      }
      if ( v8 )
      {
        if ( v11 >= v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10048790(v3, (int)v7, v8);
          *((_DWORD *)v3 + 2) = v8;
          *((_DWORD *)v3 + 4) = v7;
          *((_DWORD *)v3 + 3) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_DWORD *)v3 + 7) = 2;
          v3[24] = 0;
          result = 1;
        }
        else
        {
          sprintf(a1, "Unsupported argument to test case: '%s'", &v13[80 * v11]);
          result = 9;
        }
      }
      else
      {
LABEL_30:
        if ( v11 == v12 )
        {
          if ( !*((_DWORD *)v3 + 5) )
            return sub_10048790(v3, (int)v7, v8);
          if ( v3[24] )
          {
            *((_DWORD *)v3 + 2) = v8;
            result = 1;
            *((_DWORD *)v3 + 4) = v7;
            *((_DWORD *)v3 + 3) = 0;
            *((_DWORD *)v3 + 1) = 0;
            *((_DWORD *)v3 + 7) = 1;
            v3[24] = 0;
          }
          else
          {
            result = 12;
          }
        }
        else
        {
          result = sub_10049130(
                     (unsigned int)v7[3],
                     (int (__cdecl *)(_DWORD, char *))v7[4],
                     (int)v13,
                     (int)v7[2],
                     &v11,
                     a1);
        }
      }
    }
    else
    {
      v9 = sub_10048730(&v11, (int)v13);
      if ( v9 )
      {
        result = sub_10049130(v9[4], (int (__cdecl *)(_DWORD, char *))v9[2], (int)v13, v9[3], &v11, a1);
      }
      else
      {
        v10 = sub_10049120();
        result = sub_10049130(
                   (unsigned int)v10[3],
                   (int (__cdecl *)(_DWORD, char *))v10[4],
                   (int)v13,
                   (int)v10[2],
                   &v11,
                   a1);
      }
    }
  }
  return result;
}
// 109CA1F8: using guessed type int dword_109CA1F8[];
// 10049220: using guessed type char var_2D4[720];

//----- (10049460) --------------------------------------------------------
int sub_10049460()
{
  int v0; // esi@1
  char *v1; // eax@4
  int result; // eax@4
  char *v3; // eax@5
  char v4; // [sp+4h] [bp-104h]@1

  v4 = 0;
  v0 = sub_10049220(&v4);
  if ( !sub_100486C0()[32] )
    sub_10049C00(11, (unsigned int)"Non-interactive command complete");
  if ( v4 )
  {
    v3 = sub_1004A6E0("%s %i, %s", "Command status:", v0, &v4);
    sub_10049C80(3, (int)&unk_10103A58, (int)"..\\lib\\utf\\utf_runner.c", (int)"773", (int)v3);
    result = v0;
  }
  else
  {
    v1 = sub_1004A6E0("%s %i", "Command status:", v0);
    sub_10049C80(3, (int)&unk_10103A58, (int)"..\\lib\\utf\\utf_runner.c", (int)"767", (int)v1);
    result = v0;
  }
  return result;
}

//----- (10049540) --------------------------------------------------------
int __cdecl sub_10049540(int a1, int a2, char a3)
{
  char **v3; // eax@1

  dword_109CA1F8[sub_10047780()] = a1;
  sub_100486C0()[32] = a3;
  sub_1004E950();
  sub_1005DBE0(a2);
  v3 = sub_10048780();
  sub_10049670(v3);
  return sub_10049460();
}
// 109CA1F8: using guessed type int dword_109CA1F8[];

//----- (10049590) --------------------------------------------------------
int __cdecl sub_10049590(int a1)
{
  return a1 + 9;
}

//----- (100495A0) --------------------------------------------------------
int __cdecl sub_100495A0(void *a1)
{
  int v1; // edi@1
  __int16 v2; // ax@1
  _WORD *v3; // ecx@1

  v1 = sub_10060830();
  memset(a1, 0, 0xDCu);
  sub_1002C2B0((char *)a1 + 204, 0xFu, "test sk %i", v1);
  v2 = sub_10049590(v1);
  *v3 = v2;
  *((_DWORD *)a1 + 10) = (char *)a1 + 204;
  *((_DWORD *)a1 + 11) = (char *)a1 + 76;
  *((_WORD *)a1 + 24) = 128;
  *((_BYTE *)a1 + 50) = 22;
  *((_DWORD *)a1 + 13) = 0;
  *((_DWORD *)a1 + 14) = 300;
  *((_DWORD *)a1 + 15) = 0;
  *((_DWORD *)a1 + 16) = 500;
  *((_DWORD *)a1 + 17) = 0;
  return sub_1005DD70((int)a1, (int)v3);
}

//----- (10049620) --------------------------------------------------------
int __cdecl sub_10049620(int a1, int a2)
{
  int v2; // esi@1
  _DWORD *v3; // ST00_4@1
  int result; // eax@2

  v2 = a1;
  v3 = (_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = a2;
  sub_1005DF80(v3, (char *)&a1);
  if ( (_BYTE)a1 )
    result = v2 + 76;
  else
    result = 0;
  return result;
}

//----- (10049650) --------------------------------------------------------
signed int __cdecl sub_10049650(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // esi@2
  __int16 v5; // ax@4
  int v6; // eax@6
  int v7; // ebx@6

  result = 0;
  if ( a3 )
  {
    v4 = *(_DWORD *)a1;
    if ( !*(_DWORD *)a1 )
      return -59;
    v5 = 0;
    if ( *(_BYTE *)(v4 + 14) & 0x10 )
      v5 = 2;
    v6 = sub_10062000(*(_DWORD *)(a1 + 4), a2, a3, v5, *(_DWORD *)(v4 + 28));
    v7 = v6;
    if ( v6 >= 0 )
    {
      *(_DWORD *)(a1 + 32) = sub_10060900();
    }
    else if ( v6 != -57 || (unsigned int)(sub_10060900() - *(_DWORD *)(a1 + 32)) >= *(_DWORD *)(v4 + 32) )
    {
      sub_1005DD70(a1, v4);
      return v7;
    }
    result = v7;
  }
  return result;
}

//----- (10049670) --------------------------------------------------------
char __cdecl sub_10049670(_DWORD *a1)
{
  char v1; // bl@1
  unsigned int v2; // ebp@1
  char *v3; // edi@1
  char *v4; // eax@4
  char *v5; // eax@7
  char v7; // [sp+13h] [bp-105h]@1
  char v8; // [sp+14h] [bp-104h]@5
  char v9; // [sp+113h] [bp-5h]@5

  v1 = 0;
  v7 = 0;
  v2 = 0;
  v3 = sub_100486C0() + 36;
  do
  {
    if ( v2 >= 5 )
      break;
    if ( !*(_DWORD *)v3 )
    {
      v1 = 1;
      v7 = 1;
      *(_DWORD *)v3 = a1;
      v4 = sub_1005DA20("CFG_OutputFile", 0);
      if ( v4 )
      {
        _snprintf(&v8, 0x100u, "'%s' file '%s'", *a1, v4);
        v9 = 0;
        if ( sub_10049460() )
          v7 = 0;
      }
      v5 = sub_1005DA20("CFG_OutputPath", 0);
      if ( v5 )
      {
        _snprintf(&v8, 0x100u, "'%s' path '%s'", *a1, v5);
        v9 = 0;
        if ( sub_10049460() )
          v7 = 0;
      }
    }
    ++v2;
    v3 += 4;
  }
  while ( !v1 );
  return v7;
}

//----- (10049780) --------------------------------------------------------
char __cdecl sub_10049780(int a1, unsigned int a2)
{
  char result; // al@1

  result = 1;
  if ( a2 > 4 && !memcmp(*(const void **)(a1 + 16), "PASS", 5u) )
    result = 0;
  return result;
}

//----- (100497B0) --------------------------------------------------------
bool __cdecl sub_100497B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "begin", 6u);
}

//----- (100497E0) --------------------------------------------------------
bool __cdecl sub_100497E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "case", 5u);
}

//----- (10049810) --------------------------------------------------------
bool __cdecl sub_10049810(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "command", 8u);
}

//----- (10049840) --------------------------------------------------------
bool __cdecl sub_10049840(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "end", 4u);
}

//----- (10049870) --------------------------------------------------------
bool __cdecl sub_10049870(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "group", 6u);
}

//----- (100498A0) --------------------------------------------------------
bool __cdecl sub_100498A0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-begin", 0xCu);
}

//----- (100498E0) --------------------------------------------------------
bool __cdecl sub_100498E0(int a1, int a2)
{
  return a2 && !memcmp(*(const void **)a1, "group", 6u) && !memcmp(*(const void **)(a1 + 8), "group-end", 0xAu);
}

//----- (10049920) --------------------------------------------------------
bool __cdecl sub_10049920(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "listener", 9u);
}

//----- (10049950) --------------------------------------------------------
bool __cdecl sub_10049950(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "suite", 6u);
}

//----- (10049980) --------------------------------------------------------
char __cdecl sub_10049980(int a1, unsigned int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 > 5 && !memcmp(*(const void **)(a1 + 20), "robust", 7u) )
    result = 1;
  return result;
}

//----- (100499B0) --------------------------------------------------------
bool __cdecl sub_100499B0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Error**", 0xAu);
}

//----- (100499E0) --------------------------------------------------------
bool __cdecl sub_100499E0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**MSG**", 8u);
}

//----- (10049A10) --------------------------------------------------------
bool __cdecl sub_10049A10(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**METHOD**", 0xBu);
}

//----- (10049A40) --------------------------------------------------------
bool __cdecl sub_10049A40(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**RESULT**", 0xBu);
}

//----- (10049A70) --------------------------------------------------------
bool __cdecl sub_10049A70(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, &unk_10103A58, 9u);
}

//----- (10049AA0) --------------------------------------------------------
bool __cdecl sub_10049AA0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**SUBGROUP**", 0xDu);
}

//----- (10049AD0) --------------------------------------------------------
bool __cdecl sub_10049AD0(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TITLE**", 0xAu);
}

//----- (10049B00) --------------------------------------------------------
bool __cdecl sub_10049B00(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "Tested Requirement:", 0x14u);
}

//----- (10049B30) --------------------------------------------------------
bool __cdecl sub_10049B30(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**TYPE**", 9u);
}

//----- (10049B60) --------------------------------------------------------
bool __cdecl sub_10049B60(const void **a1, int a2)
{
  return a2 && !memcmp(*a1, "**Warning**", 0xCu);
}

//----- (10049B90) --------------------------------------------------------
int __cdecl sub_10049B90(int a1, int a2, int a3)
{
  int *v3; // esi@1
  signed int v4; // edi@1
  int result; // eax@2

  v3 = (int *)(sub_100486C0() + 36);
  v4 = 5;
  do
  {
    result = *v3;
    if ( *v3 )
    {
      result = *(_DWORD *)(result + 4);
      if ( result )
        result = ((int (__cdecl *)(int, int, int))result)(a1, a2, a3);
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  return result;
}

//----- (10049C00) --------------------------------------------------------
int __cdecl sub_10049C00(int a1, char a2)
{
  return sub_10049B90(a1, (int)&a2, 1);
}

//----- (10049C20) --------------------------------------------------------
int __cdecl sub_10049C20(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  return sub_10049B90(a1, (int)&v4, 2);
}

//----- (10049C50) --------------------------------------------------------
int __cdecl sub_10049C50(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return sub_10049B90(a1, (int)&v5, 3);
}

//----- (10049C80) --------------------------------------------------------
int __cdecl sub_10049C80(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  int v9; // [sp+Ch] [bp-4h]@1

  v7 = a3;
  v8 = a4;
  v6 = a2;
  v9 = a5;
  return sub_10049B90(a1, (int)&v6, 4);
}

//----- (10049CC0) --------------------------------------------------------
int __cdecl sub_10049CC0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+0h] [bp-14h]@1
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v9 = a4;
  v10 = a5;
  v8 = a3;
  v11 = a6;
  return sub_10049B90(a1, (int)&v7, 5);
}

//----- (10049D00) --------------------------------------------------------
int __cdecl sub_10049D00(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+0h] [bp-18h]@1
  int v9; // [sp+4h] [bp-14h]@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v8 = a2;
  v9 = a3;
  v11 = a5;
  v12 = a6;
  v10 = a4;
  v13 = a7;
  return sub_10049B90(a1, (int)&v8, 6);
}

//----- (10049D50) --------------------------------------------------------
char __cdecl sub_10049D50(int a1)
{
  char v1; // bl@1
  char *v2; // eax@1
  unsigned int v3; // ecx@1
  _DWORD *v4; // eax@1

  v1 = 0;
  v2 = sub_100486C0();
  v3 = 0;
  v4 = v2 + 36;
  do
  {
    if ( v3 >= 5 )
      break;
    if ( *v4 == a1 )
    {
      v1 = 1;
      *v4 = 0;
    }
    ++v3;
    ++v4;
  }
  while ( !v1 );
  return v1;
}

//----- (10049D80) --------------------------------------------------------
char __cdecl sub_10049D80(int a1)
{
  ++*(_DWORD *)(a1 + 328);
  return *(_BYTE *)(a1 + 52);
}

//----- (10049D90) --------------------------------------------------------
char __cdecl sub_10049D90(int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  int v4; // ebp@1
  char *v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  char *v8; // ecx@7
  char v9; // dl@8
  char v10; // cl@9
  char *v11; // ecx@10
  char *v12; // edx@13
  char v13; // cl@14
  int v14; // eax@17
  char v16[255]; // [sp+10h] [bp-104h]@12
  char v17; // [sp+10Fh] [bp-5h]@12

  v2 = a1;
  ++*(_DWORD *)(v2 + 324);
  ++*(_DWORD *)(v2 + 328);
  v3 = *(_BYTE *)(a1 + 53) == 0;
  v4 = *(_DWORD *)(a1 + 324);
  v5 = (char *)(a1 + 53);
  v6 = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  if ( !v3 )
  {
    v7 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
    if ( !v7 )
    {
LABEL_6:
      if ( *(_BYTE *)(a1 + 52) )
      {
        v8 = (char *)(a1 + 53);
        do
          v9 = *v8++;
        while ( v9 );
        v10 = *(&v8[a1 - 2] - a1);
        if ( v10 == 92 || (v3 = v10 == 47, v11 = word_1007F98C, v3) )
          v11 = &byte_10080D49;
        _snprintf(v16, 0x100u, "%s%s%s%s", a1 + 53, v11, a2, *(_DWORD *)(a1 + 48));
        v17 = 0;
      }
      else
      {
        v12 = (char *)(v16 - v5);
        do
        {
          v13 = *v5;
          v5[(_DWORD)v12] = *v5;
          ++v5;
        }
        while ( v13 );
      }
      if ( (unsigned __int8)sub_1005A3D0(v16) )
        sub_1005A3B0((int)v16);
      *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = sub_1005A3E0((int)v16, 1);
      v14 = *(_DWORD *)a1;
      if ( !*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) && v14 > 0 )
        *(_DWORD *)a1 = v14 - 1;
      return 1;
    }
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( v7 )
        ++*(_DWORD *)a1;
      goto LABEL_6;
    }
  }
  if ( v6 == 1 && v4 == 1 )
    return 1;
  return 0;
}
// 1005A3D0: using guessed type _DWORD __cdecl sub_1005A3D0(_DWORD);
// 10049D90: using guessed type char var_104[255];

//----- (10049F10) --------------------------------------------------------
signed int __cdecl sub_10049F10(int a1)
{
  signed int result; // eax@1
  int v2; // edx@1
  int v3; // edx@1

  result = 1;
  v2 = 16 * *(_DWORD *)a1;
  *(_DWORD *)(v2 + a1 + 4) = 0;
  v3 = v2 + a1 + 4;
  *(_DWORD *)(v3 + 4) = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 312) = 5;
  return result;
}

//----- (10049F50) --------------------------------------------------------
signed int __cdecl sub_10049F50(int a1, int a2, int a3)
{
  char *v3; // eax@3
  char v4; // cl@4
  signed int result; // eax@5

  switch ( a1 )
  {
    case 8:
    case 9:
      if ( *(_DWORD *)a2 != 5 )
        goto LABEL_6;
      v3 = (char *)(a2 + 4);
      do
      {
        v4 = *v3;
        v3[a3 + 53 - (a2 + 4)] = *v3;
        ++v3;
      }
      while ( v4 );
      *(_BYTE *)(a3 + 52) = a1 != 8;
      result = 0;
      break;
    case 10:
      if ( *(_DWORD *)a2 )
        goto LABEL_6;
      *(_BYTE *)(a3 + 53) = 0;
      *(_BYTE *)(a3 + 52) = 0;
      result = 0;
      break;
    case 11:
      if ( *(_DWORD *)a2 == 1 )
      {
        *(_BYTE *)(a3 + 309) = *(_BYTE *)(a2 + 4);
        result = 0;
      }
      else
      {
LABEL_6:
        result = 9;
      }
      break;
    default:
      result = 4;
      break;
  }
  return result;
}

//----- (10049FF0) --------------------------------------------------------
char __cdecl sub_10049FF0(int a1)
{
  int v1; // edx@3

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( *(_DWORD *)(a1 + 328) == 1 )
    {
      v1 = 16 * *(_DWORD *)a1 + a1 + 4;
      *(_DWORD *)v1 = 0;
      *(_DWORD *)(v1 + 4) = 0;
      *(_DWORD *)(v1 + 8) = 0;
      *(_DWORD *)(v1 + 12) = 0;
      if ( *(_DWORD *)a1 > 0 )
        --*(_DWORD *)a1;
    }
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return *(_BYTE *)(a1 + 52);
}

//----- (1004A050) --------------------------------------------------------
char __cdecl sub_1004A050(int a1, void (__cdecl *a2)(int))
{
  char result; // al@6

  --*(_DWORD *)(a1 + 328);
  if ( *(_BYTE *)(a1 + 52) )
  {
    if ( a2 )
      a2(a1);
    sub_1005A390(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    result = 1;
  }
  else
  {
    result = 0;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return result;
}

//----- (1004A0C0) --------------------------------------------------------
char *__cdecl sub_1004A0C0(char *a1)
{
  char *v1; // esi@1
  size_t v2; // edi@1
  char *v3; // eax@1
  char *v4; // eax@2
  unsigned int v5; // eax@3
  char *v6; // eax@5
  char *v7; // eax@7

  v1 = a1;
  v2 = 255;
  v3 = strstr(a1, "$Id: ");
  if ( v3 )
  {
    v1 = v3 + 5;
    v4 = strchr(v3 + 5, 44);
    if ( v4 )
    {
      v5 = v4 - v1;
      if ( v5 < 0x100 )
        goto LABEL_9;
    }
  }
  else
  {
    v6 = strrchr(a1, 47);
    if ( v6 )
    {
      v1 = v6 + 1;
      v2 = strlen(v6 + 1);
    }
    v7 = strrchr(v1, 92);
    if ( v7 )
    {
      v1 = v7 + 1;
      v5 = strlen(v7 + 1);
LABEL_9:
      v2 = v5;
      goto LABEL_10;
    }
  }
LABEL_10:
  strncpy(&byte_109CA338, v1, v2);
  *(&byte_109CA338 + v2) = 0;
  return &byte_109CA338;
}

//----- (1004A160) --------------------------------------------------------
int __cdecl sub_1004A160(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 44) = a2;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 53) = 0;
  *(_BYTE *)(a1 + 309) = 1;
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1004A1D0) --------------------------------------------------------
bool __cdecl sub_1004A1D0(int a1, unsigned int a2, int a3)
{
  bool result; // al@9
  int v4; // ecx@11
  int v5; // edx@11
  int v6; // [sp+4h] [bp-4h]@3

  if ( a2 <= 4
    || sub_1006AAB7(*(_DWORD *)(a1 + 12), (int)"%d", (unsigned int)&a2) != 1
    || sub_1006AAB7(*(_DWORD *)(a1 + 16), (int)"%d", (unsigned int)&v6) != 1 )
  {
    result = 0;
    *(_BYTE *)(a3 + 316) = 0;
  }
  else
  {
    result = a2 == 4 || !a2 || a2 == 1 || a2 == 2 || a2 == 3;
    v4 = a3;
    *(_DWORD *)(a3 + 312) = a2;
    v5 = v6;
    *(_BYTE *)(v4 + 316) = result;
    *(_DWORD *)(v4 + 320) = v5;
  }
  return result;
}

//----- (1004A260) --------------------------------------------------------
char __cdecl sub_1004A260(int a1, int a2, char a3, char a4)
{
  int v4; // ecx@2
  int v5; // eax@3
  bool v6; // zf@3
  signed int v7; // eax@6
  char result; // al@14

  switch ( a2 )
  {
    case 3:
      v4 = a1;
      if ( a3 )
        goto LABEL_11;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 1;
      goto LABEL_4;
    case 7:
      v4 = a1;
      v5 = *(_DWORD *)(a1 + 312);
      v6 = v5 == 2;
LABEL_4:
      if ( !v6 && v5 != 3 )
        goto LABEL_12;
      v7 = *(_DWORD *)(v4 + 320);
      if ( v7 <= 1 )
      {
        *(_DWORD *)(v4 + 320) = 0;
LABEL_11:
        *(_DWORD *)(v4 + 312) = 5;
      }
      else
      {
        *(_DWORD *)(v4 + 320) = v7 - 1;
      }
LABEL_12:
      if ( *(_BYTE *)(v4 + 316) )
      {
        if ( *(_DWORD *)(v4 + 312) == 5 )
        {
          result = 1;
          *(_BYTE *)(v4 + 316) = 0;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        result = a4;
      }
      return result;
    default:
      v4 = a1;
      goto LABEL_11;
  }
}

//----- (1004A310) --------------------------------------------------------
char __cdecl sub_1004A310(int a1)
{
  return *(_BYTE *)(a1 + 316);
}

//----- (1004A320) --------------------------------------------------------
char __cdecl sub_1004A320(int a1, void (__cdecl *a2)(int))
{
  char v2; // bl@1

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 52) && *(_DWORD *)(a1 + 324) > 0 || *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    v2 = 1;
    if ( a2 )
      a2(a1);
  }
  if ( *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) )
  {
    sub_1005A390(*(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36));
    *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36) = 0;
    if ( *(_DWORD *)a1 > 0 )
      --*(_DWORD *)a1;
    v2 = 1;
  }
  *(_DWORD *)(a1 + 312) = 5;
  *(_BYTE *)(a1 + 316) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  return v2;
}

//----- (1004A3A0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1004A3A0(int a1, const char *a2))(const char *)
{
  int v2; // edx@1
  int (__cdecl *result)(const char *); // eax@2

  v2 = *(_DWORD *)(a1 + 4 * *(_DWORD *)a1 + 36);
  if ( v2 )
  {
    result = (int (__cdecl *)(const char *))sub_1005A460((int)a2, strlen(a2), v2);
  }
  else
  {
    result = *(int (__cdecl **)(const char *))(a1 + 44);
    if ( result )
      result = (int (__cdecl *)(const char *))result(a2);
  }
  return result;
}

//----- (1004A3F0) --------------------------------------------------------
signed int __cdecl sub_1004A3F0(int a1, void (__cdecl *a2)(int))
{
  signed int result; // eax@1

  sub_1004A320(a1, a2);
  result = 1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

//----- (1004A440) --------------------------------------------------------
char *__cdecl sub_1004A440(int a1, int a2, int a3, size_t a4, char *a5)
{
  char v5; // cl@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  char *v9; // eax@14
  char *v10; // eax@14
  char *v11; // eax@15
  unsigned int v12; // ecx@19
  char v13; // cl@20
  bool v14; // zf@21
  char *v15; // ecx@21
  char v17[256]; // [sp+Ch] [bp-104h]@8

  v5 = *(_BYTE *)a1;
  v6 = 0;
  v7 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_12;
  v8 = a1;
  do
  {
    if ( v5 == 46 )
    {
      v7 = v6;
    }
    else if ( v5 == 47 || v5 == 92 )
    {
      v6 = 0;
      v7 = 0;
      goto LABEL_9;
    }
    v17[v6++] = v5;
LABEL_9:
    v5 = *(_BYTE *)(v8++ + 1);
  }
  while ( v5 );
  if ( v7 )
  {
    v17[v7] = 0;
    goto LABEL_13;
  }
LABEL_12:
  v17[v6] = 0;
LABEL_13:
  switch ( a2 )
  {
    case 1:
      v9 = sub_1005DA20("CFG_ActDir", (int)&byte_10080D49);
      v10 = sub_1005DA20("CFG_ActDirRuntime", (int)v9);
      break;
    case 2:
      v11 = sub_1005DA20("CFG_ExpDir", (int)&byte_10080D49);
      v10 = sub_1005DA20("CFG_ExpDirRuntime", (int)v11);
      break;
    case 3:
      v10 = sub_1005DA20("CFG_ActDir", (int)&byte_10080D49);
      break;
    case 4:
      v10 = sub_1005DA20("CFG_ExpDir", (int)&byte_10080D49);
      break;
    default:
      v10 = &byte_10080D49;
      break;
  }
  v12 = strlen(v10);
  if ( !v12 || (v13 = v10[v12 - 1], v13 == 47) || (v14 = v13 == 92, v15 = word_1007F98C, v14) )
    v15 = &byte_10080D49;
  _snprintf(a5, a4, "%s%s%s_%s.bmp", v10, v15, v17, a3);
  a5[a4 - 1] = 0;
  return a5;
}
// 1004A440: using guessed type char var_104[256];

//----- (1004A5C0) --------------------------------------------------------
int sub_1004A5C0()
{
  return dword_109CF028[sub_10047780()];
}
// 109CF028: using guessed type int dword_109CF028[];

//----- (1004A5D0) --------------------------------------------------------
const char *__cdecl sub_1004A5D0(unsigned int a1)
{
  const char *result; // eax@2

  if ( a1 >= 3 )
    result = "Unknown Type Of Testing";
  else
    result = off_10103C34[a1];
  return result;
}
// 10103C34: using guessed type char *off_10103C34[7];

//----- (1004A5F0) --------------------------------------------------------
int __cdecl sub_1004A5F0(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+8h] [bp-204h]@1
  char v6; // [sp+107h] [bp-105h]@1
  char v7; // [sp+108h] [bp-104h]@1
  char v8; // [sp+207h] [bp-5h]@1

  _snprintf(&v5, 0x100u, "%d", a3);
  v6 = 0;
  _snprintf(&v7, 0x100u, "%d", a4);
  v8 = 0;
  return sub_10049CC0(3, (int)"**SUBGROUP**", a1, a2, (int)&v5, (int)&v7);
}

//----- (1004A6A0) --------------------------------------------------------
int __cdecl sub_1004A6A0(int a1)
{
  int result; // eax@1

  result = sub_10047780();
  dword_109D1134[result] = a1;
  return result;
}
// 109D1134: using guessed type int dword_109D1134[];

//----- (1004A6C0) --------------------------------------------------------
int __cdecl sub_1004A6C0(int a1)
{
  int result; // eax@1

  result = sub_10047780();
  dword_109CF028[result] = a1;
  return result;
}
// 109CF028: using guessed type int dword_109CF028[];

//----- (1004A6E0) --------------------------------------------------------
char *sub_1004A6E0(char *a1, ...)
{
  int v1; // esi@1
  char *result; // eax@1
  va_list va; // [sp+10h] [bp+8h]@1

  va_start(va, a1);
  v1 = sub_10047780() << 8;
  _vsnprintf(&byte_109CA438[v1], 0x100u, a1, va);
  result = &byte_109CA438[v1];
  byte_109CA536[v1] = 42;
  byte_109CA537[v1] = 0;
  return result;
}

//----- (1004A720) --------------------------------------------------------
char *__usercall sub_1004A720@<eax>(char a1@<al>, unsigned __int8 a2@<cl>)
{
  char *result; // eax@3

  if ( a2 && a2 != 1 )
    result = off_10103C48[a1 & 1];
  else
    result = off_10103C40[a2];
  return result;
}
// 10103C40: using guessed type char *off_10103C40[4];
// 10103C48: using guessed type char *off_10103C48[2];

//----- (1004A740) --------------------------------------------------------
char __usercall sub_1004A740@<al>(int a1@<esi>, char *a2, int a3, size_t a4, long double a5)
{
  const char *v5; // ebp@1
  int v6; // edi@1
  char v7; // cl@1
  char result; // al@5
  long double v9; // st7@6
  signed int v10; // eax@7
  int v11; // ecx@10
  int v12; // ebp@10
  int v13; // edx@10
  int v14; // edi@10
  int v15; // edi@16
  int v16; // eax@30
  char v17; // [sp+18h] [bp+4h]@1

  v5 = a2;
  v6 = sub_10047780();
  v17 = a2[a3 - 2];
  v7 = v17;
  if ( v17 == 100 || v17 == 117 )
  {
    v16 = sub_1004A5C0() - 1;
    if ( v16 )
    {
      if ( v16 == 1 )
      {
        strncpy((char *)(a1 + 1), v5, a4 - 1);
        *(_BYTE *)(a1 + 1) = 35;
        *(_BYTE *)a1 = 37;
        result = 0;
        *(_BYTE *)(a3 + a1 - 1) = 111;
      }
      else
      {
        strncpy((char *)a1, v5, a4);
        result = 0;
      }
    }
    else
    {
      strncpy((char *)(a1 + 1), v5, a4 - 1);
      *(_BYTE *)(a1 + 1) = 35;
      *(_BYTE *)a1 = 37;
      result = 0;
      *(_BYTE *)(a3 + a1 - 1) = 120;
    }
  }
  else if ( v17 == 102 || v17 == 103 )
  {
    v9 = fabs(a5);
    if ( 0.0 == v9 )
    {
      v10 = 0;
    }
    else
    {
      v10 = (signed int)floor(log10(v9));
      v7 = v17;
    }
    if ( v7 == 102 )
    {
      v11 = dword_109D2728[v6];
      v12 = dword_109D273C[v6];
      v13 = v11 + v10;
      v14 = v11 + v10;
      if ( v11 + v10 >= 9 )
        v14 = 9;
      if ( v11 <= v14 )
      {
        if ( v13 >= 9 )
          v13 = 9;
      }
      else
      {
        v13 = v11;
      }
    }
    else
    {
      v11 = dword_109CF03C[v6];
      v12 = dword_109D1120[v6];
      v13 = v11 + v10;
      v15 = v11 + v10;
      if ( v11 + v10 >= 14 )
        v15 = 14;
      if ( v11 <= v15 )
      {
        if ( v13 >= 14 )
          v13 = 14;
      }
      else
      {
        v13 = v11;
      }
    }
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
      else if ( v11 <= v10 || v10 < -4 )
      {
        _snprintf((char *)a1, a4, "%%.%de", v13);
        result = 1;
      }
      else
      {
        _snprintf((char *)a1, a4, "%%.%df", v11);
        result = 1;
      }
    }
    else
    {
      _snprintf((char *)a1, a4, "%%.%de", v13);
      result = 1;
    }
  }
  else
  {
    strncpy((char *)a1, v5, a4);
    result = 0;
  }
  return result;
}
// 109CF03C: using guessed type int dword_109CF03C[];
// 109D1120: using guessed type int dword_109D1120[];
// 109D2728: using guessed type int dword_109D2728[];
// 109D273C: using guessed type int dword_109D273C[];

//----- (1004A960) --------------------------------------------------------
int __cdecl sub_1004A960(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10047780();
  dword_109D1120[result] = a1;
  if ( a2 >= 0 )
  {
    dword_109CF03C[result] = a2;
    if ( a2 > 14 )
    {
      v3 = sub_1004A6E0(
             "Floating point (double) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             14);
      result = sub_10049C80(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"909", (int)v3);
    }
  }
  else
  {
    dword_109CF03C[result] = 8;
  }
  return result;
}
// 109CF03C: using guessed type int dword_109CF03C[];
// 109D1120: using guessed type int dword_109D1120[];

//----- (1004A9C0) --------------------------------------------------------
int __cdecl sub_1004A9C0(int a1)
{
  return sub_1004A960(0, a1);
}

//----- (1004A9D0) --------------------------------------------------------
int __cdecl sub_1004A9D0(int a1, int a2)
{
  int result; // eax@1
  char *v3; // eax@4

  result = sub_10047780();
  dword_109D273C[result] = a1;
  if ( a2 >= 0 )
  {
    dword_109D2728[result] = a2;
    if ( a2 > 9 )
    {
      v3 = sub_1004A6E0(
             "Floating point (float) precision set to a value (%d) greater than supported by the UTF (%d)",
             a2,
             9);
      result = sub_10049C80(3, (int)"**Warning**", (int)"..\\lib\\utf\\utf_verify.c", (int)"977", (int)v3);
    }
  }
  else
  {
    dword_109D2728[result] = 8;
  }
  return result;
}
// 109D2728: using guessed type int dword_109D2728[];
// 109D273C: using guessed type int dword_109D273C[];

//----- (1004AA30) --------------------------------------------------------
int __cdecl sub_1004AA30(int a1)
{
  return sub_1004A9D0(0, a1);
}

//----- (1004AA40) --------------------------------------------------------
bool __cdecl sub_1004AA40(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  bool v8; // bl@4
  char *v9; // eax@7
  char *v10; // edx@7
  int v11; // esi@8
  int v12; // edi@19
  char *v14; // [sp+Ch] [bp-2Ch]@7
  int v15; // [sp+10h] [bp-28h]@7
  int v16; // [sp+14h] [bp-24h]@7
  int v17; // [sp+18h] [bp-20h]@7
  char *v18; // [sp+1Ch] [bp-1Ch]@7
  char *v19; // [sp+20h] [bp-18h]@7
  const char *v20; // [sp+24h] [bp-14h]@7
  char *v21; // [sp+28h] [bp-10h]@7
  char *v22; // [sp+2Ch] [bp-Ch]@7
  int v23; // [sp+30h] [bp-8h]@8
  int v24; // [sp+34h] [bp-4h]@8

  if ( a2 )
  {
    if ( a6 == 1 )
    {
      if ( a7 )
        goto LABEL_4;
    }
    else if ( a6 || a7 != 1 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
  else
  {
    if ( a6 == 1 )
    {
      if ( a7 != 1 )
      {
LABEL_4:
        v8 = 0;
        goto LABEL_5;
      }
    }
    else if ( a6 || a7 )
    {
      goto LABEL_4;
    }
    v8 = 1;
  }
LABEL_5:
  if ( sub_100486E0() )
    v8 = v8 == 0;
  v9 = (&off_10103C18)[4 * a2];
  v15 = a3;
  v14 = v9;
  v17 = a5;
  v16 = a4;
  v20 = "bool";
  v10 = off_10103C08[v8 != 0];
  v19 = off_10103C10[a1];
  v18 = v10;
  v21 = sub_1004A720(0, a6);
  v22 = sub_1004A720(1, a7);
  if ( a8 )
  {
    v23 = 0;
    v24 = a8;
    v11 = 11;
  }
  else
  {
    v11 = 9;
  }
  v12 = sub_1005E060();
  sub_10049B90(7, (int)&v14, v11);
  sub_1005E070(v12);
  return v8;
}
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004AB80) --------------------------------------------------------
bool __cdecl sub_1004AB80(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, int a8)
{
  int v8; // edi@1
  unsigned __int8 v9; // al@14
  unsigned __int8 v10; // al@17
  int v11; // edi@25
  char *v12; // esi@26
  char *v13; // edx@28
  int v14; // ebx@30
  int v15; // edx@33
  int v16; // ecx@33
  bool v17; // cf@34
  unsigned __int8 v18; // al@36
  int v19; // eax@38
  bool v21; // [sp+1Bh] [bp-5Dh]@2
  char v22; // [sp+1Fh] [bp-59h]@25
  unsigned int v23; // [sp+20h] [bp-58h]@1
  char *v24; // [sp+3Ch] [bp-3Ch]@28
  int v25; // [sp+40h] [bp-38h]@28
  int v26; // [sp+44h] [bp-34h]@28
  int v27; // [sp+48h] [bp-30h]@28
  char *v28; // [sp+4Ch] [bp-2Ch]@28
  char *v29; // [sp+50h] [bp-28h]@28
  const char *v30; // [sp+54h] [bp-24h]@28
  char *v31; // [sp+58h] [bp-20h]@28
  char *v32; // [sp+5Ch] [bp-1Ch]@28
  char *v33; // [sp+60h] [bp-18h]@28
  int v34; // [sp+64h] [bp-14h]@29
  char v35; // [sp+68h] [bp-10h]@25

  v8 = sub_10047780();
  v23 = 9;
  switch ( a2 )
  {
    case 0:
      v21 = a6 == a7;
      break;
    case 1:
      v21 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_22;
      v21 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_22;
      v21 = 1;
      break;
    case 4:
      v21 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_22;
      v21 = 1;
      break;
    case 6:
      if ( a7 )
        v9 = a7;
      else
        v9 = 0;
      if ( a6 < v9 )
        goto LABEL_45;
      v10 = a7;
      if ( (signed int)a7 >= 255 )
        v10 = -1;
      v21 = 1;
      if ( a6 > v10 )
LABEL_45:
        v21 = 0;
      v23 = 10;
      break;
    default:
LABEL_22:
      v21 = 0;
      break;
  }
  if ( sub_100486E0() )
    v21 = v21 == 0;
  sub_1004A740((int)&v35, "%c", 3, 0xCu, (double)a6);
  v11 = 3072 * v8;
  _snprintf(&byte_109CB428[v11], 0x400u, &v35, a6);
  byte_109CB826[v11] = 42;
  byte_109CB827[v11] = 0;
  v22 = sub_1004A740((int)&v35, "%c", 3, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v11], 0x400u, &v35, a7);
  byte_109CBC26[v11] = 42;
  byte_109CBC27[v11] = 0;
  if ( v23 <= 9 )
  {
    v12 = &byte_109CBC28[v11];
    byte_109CBC28[v11] = 0;
  }
  else
  {
    v22 = sub_1004A740((int)&v35, "%c", 3, 0xCu, 0.0);
    v12 = &byte_109CBC28[v11];
    _snprintf(&byte_109CBC28[v11], 0x400u, &v35, 0);
    byte_109CC026[v11] = 42;
    byte_109CC027[v11] = 0;
  }
  v24 = (&off_10103C18)[4 * a2];
  v26 = a4;
  v27 = a5;
  v25 = a3;
  v30 = "char";
  v31 = &byte_109CB428[v11];
  v32 = &byte_109CB828[v11];
  v13 = off_10103C10[a1];
  v28 = off_10103C08[v21 != 0];
  v29 = v13;
  v33 = v12;
  if ( a8 )
  {
    v34 = a8;
    v23 = 11;
  }
  v14 = sub_1005E060();
  sub_10049B90(7, (int)&v24, v23);
  if ( v22 && a6 != a7 && fabs((double)(a6 - a7)) > 0.0 )
  {
    v15 = (int)v32;
    v16 = (int)v31;
    while ( 1 )
    {
      v17 = *(_BYTE *)v16 < *(_BYTE *)v15;
      if ( *(_BYTE *)v16 != *(_BYTE *)v15 )
        break;
      if ( !*(_BYTE *)v16 )
        goto LABEL_38;
      v18 = *(_BYTE *)(v16 + 1);
      v17 = v18 < *(_BYTE *)(v15 + 1);
      if ( v18 != *(_BYTE *)(v15 + 1) )
        break;
      v16 += 2;
      v15 += 2;
      if ( !v18 )
      {
LABEL_38:
        v19 = 0;
        goto LABEL_40;
      }
    }
    v19 = -v17 - (v17 - 1);
LABEL_40:
    if ( !v19 )
    {
      nullsub_1(v16, v15);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v14);
  return v21;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004AF30) --------------------------------------------------------
bool __cdecl sub_1004AF30(int a1, int a2, int a3, int a4, int a5, double a6, double a7, double a8, int a9)
{
  double v9; // st6@1
  long double v10; // st7@4
  int v11; // edi@8
  int v12; // edi@21
  char *v13; // esi@22
  double v14; // st5@28
  double v15; // st3@30
  double v16; // st5@30
  char *v17; // ecx@37
  int v18; // ebx@39
  int v19; // edx@42
  int v20; // ecx@42
  bool v21; // cf@43
  unsigned __int8 v22; // al@45
  int v23; // eax@47
  bool v25; // [sp+27h] [bp-61h]@10
  char v26; // [sp+2Bh] [bp-5Dh]@21
  unsigned int v27; // [sp+2Ch] [bp-5Ch]@8
  char *v28; // [sp+4Ch] [bp-3Ch]@37
  int v29; // [sp+50h] [bp-38h]@37
  int v30; // [sp+54h] [bp-34h]@37
  int v31; // [sp+58h] [bp-30h]@37
  char *v32; // [sp+5Ch] [bp-2Ch]@37
  char *v33; // [sp+60h] [bp-28h]@37
  const char *v34; // [sp+64h] [bp-24h]@37
  char *v35; // [sp+68h] [bp-20h]@37
  char *v36; // [sp+6Ch] [bp-1Ch]@37
  char *v37; // [sp+70h] [bp-18h]@37
  int v38; // [sp+74h] [bp-14h]@38
  char v39; // [sp+78h] [bp-10h]@21

  v9 = a8;
  if ( a2 != 6
    || -0.000001 != a8
    || (a7 >= 0.0 ? (v9 = a7 * 0.000001, v10 = 0.000001) : (v10 = 0.000001, v9 = -0.000001 * a7), v9 >= v10) )
  {
    v10 = v9;
  }
  v11 = sub_10047780();
  v27 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_18;
      v25 = 1;
      break;
    case 1:
      v25 = a7 != a6;
      break;
    case 2:
      if ( a7 != a6 && a7 < a6 )
        goto LABEL_18;
      goto LABEL_14;
    case 3:
      if ( a7 == a6 || a7 < a6 )
        goto LABEL_18;
      v25 = 1;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_18;
      v25 = 1;
      break;
    case 5:
      if ( a7 != a6 && a7 >= a6 )
        goto LABEL_18;
LABEL_14:
      v25 = 1;
      break;
    case 6:
      v14 = v10 - 1.797693134862316e308;
      if ( a7 > v10 - 1.797693134862316e308 )
        v14 = a7;
      v15 = v14;
      v16 = a7;
      if ( v15 - v10 > a6 )
        goto LABEL_54;
      if ( 1.797693134862316e308 - v10 <= a7 )
        v16 = 1.797693134862316e308 - v10;
      if ( v10 + v16 < a6 )
      {
LABEL_54:
        v25 = 0;
        v27 = 10;
      }
      else
      {
        v25 = 1;
        v27 = 10;
      }
      break;
    default:
LABEL_18:
      v25 = 0;
      break;
  }
  if ( sub_100486E0() )
    v25 = v25 == 0;
  sub_1004A740((int)&v39, (char *)&unk_10103F00, 3, 0xCu, a6);
  v12 = 3072 * v11;
  _snprintf(&byte_109CB428[v12], 0x400u, &v39);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v26 = sub_1004A740((int)&v39, (char *)&unk_10103F00, 3, 0xCu, a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v39, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v27 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v13 = &byte_109CBC28[v12];
    v26 = sub_1004A740((int)&v39, (char *)&unk_10103F00, 3, 0xCu, v10);
    _snprintf(&byte_109CBC28[v12], 0x400u, &v39, LODWORD(v10), (_DWORD)(*(unsigned __int64 *)&v10 >> 32));
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v28 = (&off_10103C18)[4 * a2];
  v31 = a5;
  v30 = a4;
  v29 = a3;
  v34 = "double";
  v35 = &byte_109CB428[v12];
  v37 = v13;
  v17 = off_10103C10[a1];
  v32 = off_10103C08[v25 != 0];
  v33 = v17;
  v36 = &byte_109CB828[v12];
  if ( a9 )
  {
    v38 = a9;
    v27 = 11;
  }
  v18 = sub_1005E060();
  sub_10049B90(7, (int)&v28, v27);
  if ( v26 && a6 != a7 && fabs(a6 - a7) > v10 )
  {
    v19 = (int)v36;
    v20 = (int)v35;
    while ( 1 )
    {
      v21 = *(_BYTE *)v20 < *(_BYTE *)v19;
      if ( *(_BYTE *)v20 != *(_BYTE *)v19 )
        break;
      if ( !*(_BYTE *)v20 )
        goto LABEL_47;
      v22 = *(_BYTE *)(v20 + 1);
      v21 = v22 < *(_BYTE *)(v19 + 1);
      if ( v22 != *(_BYTE *)(v19 + 1) )
        break;
      v20 += 2;
      v19 += 2;
      if ( !v22 )
      {
LABEL_47:
        v23 = 0;
        goto LABEL_49;
      }
    }
    v23 = -v21 - (v21 - 1);
LABEL_49:
    if ( !v23 )
    {
      nullsub_1(v20, v19);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v18);
  return v25;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004B380) --------------------------------------------------------
bool __cdecl sub_1004B380(int a1, int a2, int a3, int a4, int a5, float a6, float a7, float a8, int a9)
{
  double v9; // st7@1
  double v10; // st6@1
  double v11; // st7@4
  float v12; // ST38_4@6
  double v13; // st7@6
  double v14; // st7@8
  double v15; // st6@8
  int v16; // edi@8
  double v17; // st5@24
  double v18; // st3@26
  double v19; // st5@26
  int v20; // edi@35
  char *v21; // esi@36
  char *v22; // ecx@38
  int v23; // ebx@40
  int v24; // edx@43
  int v25; // ecx@43
  bool v26; // cf@44
  unsigned __int8 v27; // al@46
  int v28; // eax@48
  bool v30; // [sp+1Bh] [bp-59h]@10
  char v31; // [sp+1Fh] [bp-55h]@35
  unsigned int v32; // [sp+20h] [bp-54h]@8
  float v33; // [sp+24h] [bp-50h]@8
  char *v34; // [sp+38h] [bp-3Ch]@38
  int v35; // [sp+3Ch] [bp-38h]@38
  int v36; // [sp+40h] [bp-34h]@38
  int v37; // [sp+44h] [bp-30h]@38
  char *v38; // [sp+48h] [bp-2Ch]@38
  char *v39; // [sp+4Ch] [bp-28h]@38
  const char *v40; // [sp+50h] [bp-24h]@38
  char *v41; // [sp+54h] [bp-20h]@38
  char *v42; // [sp+58h] [bp-1Ch]@38
  char *v43; // [sp+5Ch] [bp-18h]@38
  int v44; // [sp+60h] [bp-14h]@39
  char v45; // [sp+64h] [bp-10h]@35

  v9 = a7;
  v10 = a8;
  if ( a2 != 6
    || -0.0000099999997 != v10
    || (v9 >= 0.0 ? (v11 = v9 * 0.000009999999747378752) : (v11 = v9 * -0.000009999999747378752),
        v12 = v11,
        v13 = 0.0000099999997,
        v10 = v12,
        v12 >= 0.0000099999997) )
  {
    v13 = v10;
  }
  v33 = v13;
  v14 = v33;
  v15 = a6;
  v16 = sub_10047780();
  v32 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a7 != a6 )
        goto LABEL_32;
      v30 = 1;
      break;
    case 1:
      v30 = a7 != a6;
      break;
    case 2:
      if ( a7 != v15 && a7 < (double)a6 )
        goto LABEL_32;
      goto LABEL_14;
    case 3:
      if ( a7 == v15 || a7 < (double)a6 )
        goto LABEL_32;
      v30 = 1;
      break;
    case 4:
      if ( a7 >= (double)a6 )
        goto LABEL_32;
      v30 = 1;
      break;
    case 5:
      if ( a7 != v15 && a7 >= (double)a6 )
        goto LABEL_32;
LABEL_14:
      v30 = 1;
      break;
    case 6:
      v17 = v14 - 3.402823466385289e38;
      if ( a7 > v14 - 3.402823466385289e38 )
        v17 = a7;
      v18 = v17 - v14;
      v19 = a7;
      if ( v18 > v15 )
        goto LABEL_55;
      if ( 3.402823466385289e38 - v14 <= v19 )
        v19 = 3.402823466385289e38 - v14;
      if ( v15 > v14 + v19 )
      {
LABEL_55:
        v30 = 0;
        v32 = 10;
      }
      else
      {
        v30 = 1;
        v32 = 10;
      }
      break;
    default:
LABEL_32:
      v30 = 0;
      break;
  }
  if ( sub_100486E0() )
    v30 = v30 == 0;
  sub_1004A740((int)&v45, "%f", 3, 0xCu, a6);
  v20 = 3072 * v16;
  _snprintf(&byte_109CB428[v20], 0x400u, &v45);
  byte_109CB826[v20] = 42;
  byte_109CB827[v20] = 0;
  v31 = sub_1004A740((int)&v45, "%f", 3, 0xCu, a7);
  _snprintf(&byte_109CB828[v20], 0x400u, &v45, a7);
  byte_109CBC26[v20] = 42;
  byte_109CBC27[v20] = 0;
  if ( v32 <= 9 )
  {
    v21 = &byte_109CBC28[v20];
    byte_109CBC28[v20] = 0;
  }
  else
  {
    v21 = &byte_109CBC28[v20];
    v31 = sub_1004A740((int)&v45, "%f", 3, 0xCu, v33);
    _snprintf(&byte_109CBC28[v20], 0x400u, &v45, v33);
    byte_109CC026[v20] = 42;
    byte_109CC027[v20] = 0;
  }
  v34 = (&off_10103C18)[4 * a2];
  v37 = a5;
  v36 = a4;
  v35 = a3;
  v40 = "float";
  v41 = &byte_109CB428[v20];
  v42 = &byte_109CB828[v20];
  v43 = v21;
  v22 = off_10103C08[v30 != 0];
  v39 = off_10103C10[a1];
  v38 = v22;
  if ( a9 )
  {
    v44 = a9;
    v32 = 11;
  }
  v23 = sub_1005E060();
  sub_10049B90(7, (int)&v34, v32);
  if ( v31 && a7 != a6 && v33 < fabs(a6 - a7) )
  {
    v24 = (int)v42;
    v25 = (int)v41;
    while ( 1 )
    {
      v26 = *(_BYTE *)v25 < *(_BYTE *)v24;
      if ( *(_BYTE *)v25 != *(_BYTE *)v24 )
        break;
      if ( !*(_BYTE *)v25 )
        goto LABEL_48;
      v27 = *(_BYTE *)(v25 + 1);
      v26 = v27 < *(_BYTE *)(v24 + 1);
      if ( v27 != *(_BYTE *)(v24 + 1) )
        break;
      v25 += 2;
      v24 += 2;
      if ( !v27 )
      {
LABEL_48:
        v28 = 0;
        goto LABEL_50;
      }
    }
    v28 = -v26 - (v26 - 1);
LABEL_50:
    if ( !v28 )
    {
      nullsub_1(v25, v24);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v23);
  return v30;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004B840) --------------------------------------------------------
bool __cdecl sub_1004B840(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-55h]@2
  char v23; // [sp+1Fh] [bp-51h]@24
  unsigned int v24; // [sp+20h] [bp-50h]@1
  char *v25; // [sp+34h] [bp-3Ch]@27
  int v26; // [sp+38h] [bp-38h]@27
  int v27; // [sp+3Ch] [bp-34h]@27
  int v28; // [sp+40h] [bp-30h]@27
  char *v29; // [sp+44h] [bp-2Ch]@27
  char *v30; // [sp+48h] [bp-28h]@27
  void *v31; // [sp+4Ch] [bp-24h]@27
  char *v32; // [sp+50h] [bp-20h]@27
  char *v33; // [sp+54h] [bp-1Ch]@27
  char *v34; // [sp+58h] [bp-18h]@27
  int v35; // [sp+5Ch] [bp-14h]@28
  char v36; // [sp+60h] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_44;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v22 = 1;
      if ( a6 > a8 + v11 )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v23 = sub_1004A740((int)&v36, "%d", 3, 0xCu, (double)a8);
    v13 = &byte_109CBC28[v12];
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v26 = a3;
  v31 = &unk_10103F44;
  v32 = &byte_109CB428[v12];
  v33 = &byte_109CB828[v12];
  v34 = v13;
  v14 = off_10103C08[v22 != 0];
  v30 = off_10103C10[a1];
  v29 = v14;
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004BC00) --------------------------------------------------------
bool __cdecl sub_1004BC00(int a1, int a2, int a3, int a4, int a5, __int16 a6, __int16 a7, __int16 a8, int a9)
{
  int v9; // edi@1
  __int16 v10; // ax@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-61h]@2
  char v23; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v24; // [sp+24h] [bp-58h]@1
  char *v25; // [sp+40h] [bp-3Ch]@27
  int v26; // [sp+44h] [bp-38h]@27
  int v27; // [sp+48h] [bp-34h]@27
  int v28; // [sp+4Ch] [bp-30h]@27
  char *v29; // [sp+50h] [bp-2Ch]@27
  char *v30; // [sp+54h] [bp-28h]@27
  const char *v31; // [sp+58h] [bp-24h]@27
  char *v32; // [sp+5Ch] [bp-20h]@27
  char *v33; // [sp+60h] [bp-1Ch]@27
  char *v34; // [sp+64h] [bp-18h]@27
  int v35; // [sp+68h] [bp-14h]@28
  char v36; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 0x8000;
      if ( v11 < a7 )
        LOWORD(v11) = a7;
      if ( a6 < (signed __int16)(v11 - a8) )
        goto LABEL_44;
      if ( 0x7FFF - a8 <= a7 )
        v10 = 0x7FFF - a8;
      v22 = 1;
      if ( a6 > (signed __int16)(a8 + v10) )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v13 = &byte_109CBC28[v12];
    v23 = sub_1004A740((int)&v36, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v32 = &byte_109CB428[v12];
  v26 = a3;
  v31 = "sint16";
  v33 = &byte_109CB828[v12];
  v34 = v13;
  v14 = off_10103C10[a1];
  v29 = off_10103C08[v22 != 0];
  v30 = v14;
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004C000) --------------------------------------------------------
bool __cdecl sub_1004C000(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-55h]@2
  char v23; // [sp+1Fh] [bp-51h]@24
  unsigned int v24; // [sp+20h] [bp-50h]@1
  char *v25; // [sp+34h] [bp-3Ch]@27
  int v26; // [sp+38h] [bp-38h]@27
  int v27; // [sp+3Ch] [bp-34h]@27
  int v28; // [sp+40h] [bp-30h]@27
  char *v29; // [sp+44h] [bp-2Ch]@27
  char *v30; // [sp+48h] [bp-28h]@27
  const char *v31; // [sp+4Ch] [bp-24h]@27
  char *v32; // [sp+50h] [bp-20h]@27
  char *v33; // [sp+54h] [bp-1Ch]@27
  char *v34; // [sp+58h] [bp-18h]@27
  int v35; // [sp+5Ch] [bp-14h]@28
  char v36; // [sp+60h] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_44;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v22 = 1;
      if ( a6 > a8 + v11 )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, (char *)&unk_100AC4D0, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, (char *)&unk_100AC4D0, 4, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v23 = sub_1004A740((int)&v36, (char *)&unk_100AC4D0, 4, 0xCu, (double)a8);
    v13 = &byte_109CBC28[v12];
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v26 = a3;
  v31 = "sint32";
  v32 = &byte_109CB428[v12];
  v33 = &byte_109CB828[v12];
  v34 = v13;
  v14 = off_10103C08[v22 != 0];
  v30 = off_10103C10[a1];
  v29 = v14;
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004C3C0) --------------------------------------------------------
bool __cdecl sub_1004C3C0(int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, int a9)
{
  unsigned int v9; // edx@22
  unsigned int v10; // esi@22
  unsigned int v11; // eax@27
  int v12; // ecx@27
  int v13; // edi@37
  char *v14; // esi@38
  char *v15; // edx@40
  int v16; // ebx@42
  int v17; // edx@45
  int v18; // ecx@45
  bool v19; // cf@46
  unsigned __int8 v20; // al@48
  int v21; // eax@50
  bool v23; // [sp+1Bh] [bp-5Dh]@3
  char v24; // [sp+1Fh] [bp-59h]@37
  unsigned int v25; // [sp+20h] [bp-58h]@1
  int v26; // [sp+30h] [bp-48h]@1
  char *v27; // [sp+3Ch] [bp-3Ch]@40
  int v28; // [sp+40h] [bp-38h]@40
  int v29; // [sp+44h] [bp-34h]@40
  int v30; // [sp+48h] [bp-30h]@40
  char *v31; // [sp+4Ch] [bp-2Ch]@40
  char *v32; // [sp+50h] [bp-28h]@40
  const char *v33; // [sp+54h] [bp-24h]@40
  char *v34; // [sp+58h] [bp-20h]@40
  char *v35; // [sp+5Ch] [bp-1Ch]@40
  char *v36; // [sp+60h] [bp-18h]@40
  int v37; // [sp+64h] [bp-14h]@41
  char v38; // [sp+68h] [bp-10h]@37

  v26 = sub_10047780();
  v25 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_34;
      v23 = 1;
      goto LABEL_35;
    case 1:
      v23 = a6 != a7;
      goto LABEL_35;
    case 2:
      if ( a6 != a7
        && SHIDWORD(a6) >= SHIDWORD(a7)
        && (SHIDWORD(a6) > SHIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || SHIDWORD(a6) > SHIDWORD(a7) )
        goto LABEL_34;
      if ( SHIDWORD(a6) < SHIDWORD(a7) )
      {
LABEL_9:
        v23 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_34:
        v23 = 0;
      }
      else
      {
        v23 = 1;
      }
LABEL_35:
      if ( sub_100486E0() )
        v23 = v23 == 0;
      sub_1004A740((int)&v38, "%I64d", 6, 0xCu, (double)a6);
      v13 = 3072 * v26;
      _snprintf(&byte_109CB428[3072 * v26], 0x400u, &v38, a6);
      byte_109CB826[v13] = 42;
      byte_109CB827[v13] = 0;
      v24 = sub_1004A740((int)&v38, "%I64d", 6, 0xCu, (double)a7);
      _snprintf(&byte_109CB828[3072 * v26], 0x400u, &v38, a7);
      byte_109CBC26[v13] = 42;
      byte_109CBC27[v13] = 0;
      if ( v25 <= 9 )
      {
        v14 = &byte_109CBC28[v13];
        byte_109CBC28[v13] = 0;
      }
      else
      {
        v24 = sub_1004A740((int)&v38, "%I64d", 6, 0xCu, (double)a8);
        v14 = &byte_109CBC28[v13];
        _snprintf(&byte_109CBC28[v13], 0x400u, &v38, a8);
        byte_109CC026[v13] = 42;
        byte_109CC027[v13] = 0;
      }
      v27 = (&off_10103C18)[4 * a2];
      v29 = a4;
      v30 = a5;
      v28 = a3;
      v33 = "sint64";
      v34 = &byte_109CB428[3072 * v26];
      v35 = &byte_109CB828[3072 * v26];
      v15 = off_10103C10[a1];
      v31 = off_10103C08[v23 != 0];
      v32 = v15;
      v36 = v14;
      if ( a9 )
      {
        v37 = a9;
        v25 = 11;
      }
      v16 = sub_1005E060();
      sub_10049B90(7, (int)&v27, v25);
      if ( !v24 || a6 == a7 || (double)a8 >= fabs((double)(a6 - a7)) )
        goto LABEL_54;
      v17 = (int)v35;
      v18 = (int)v34;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_34;
      v23 = 1;
      goto LABEL_35;
    case 5:
      if ( a6 != a7
        && SHIDWORD(a6) <= SHIDWORD(a7)
        && (SHIDWORD(a6) < SHIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
      {
        goto LABEL_34;
      }
      v23 = 1;
      goto LABEL_35;
    case 6:
      v9 = a8;
      v10 = HIDWORD(a8) + 2147483648;
      if ( (signed int)(HIDWORD(a8) + 2147483648) < SHIDWORD(a7)
        || (signed int)(HIDWORD(a8) + 2147483648) <= SHIDWORD(a7) && (unsigned int)a8 < (unsigned int)a7 )
      {
        v10 = HIDWORD(a7);
        v9 = a7;
      }
      if ( a6 < (signed __int64)(__PAIR__(v10, v9) - a8) )
        goto LABEL_57;
      v11 = -1 - a8;
      v12 = 0x7FFFFFFF - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > SHIDWORD(a7) || v12 >= SHIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_57:
        v23 = 0;
        v25 = 10;
      }
      else
      {
        v23 = 1;
        v25 = 10;
      }
      goto LABEL_35;
    default:
      goto LABEL_34;
  }
  while ( 1 )
  {
    v19 = *(_BYTE *)v18 < *(_BYTE *)v17;
    if ( *(_BYTE *)v18 != *(_BYTE *)v17 )
      break;
    if ( !*(_BYTE *)v18 )
      goto LABEL_50;
    v20 = *(_BYTE *)(v18 + 1);
    v19 = v20 < *(_BYTE *)(v17 + 1);
    if ( v20 != *(_BYTE *)(v17 + 1) )
      break;
    v18 += 2;
    v17 += 2;
    if ( !v20 )
    {
LABEL_50:
      v21 = 0;
      goto LABEL_52;
    }
  }
  v21 = -v19 - (v19 - 1);
LABEL_52:
  if ( !v21 )
  {
    nullsub_1(v18, v17);
    sub_10049C80(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
LABEL_54:
  sub_1005E070(v16);
  return v23;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004C900) --------------------------------------------------------
bool __cdecl sub_1004C900(int a1, int a2, int a3, int a4, int a5, char a6, char a7, char a8, int a9)
{
  int v9; // edi@1
  char v10; // al@13
  int v11; // ecx@13
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-61h]@2
  char v23; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v24; // [sp+24h] [bp-58h]@1
  char *v25; // [sp+40h] [bp-3Ch]@27
  int v26; // [sp+44h] [bp-38h]@27
  int v27; // [sp+48h] [bp-34h]@27
  int v28; // [sp+4Ch] [bp-30h]@27
  char *v29; // [sp+50h] [bp-2Ch]@27
  char *v30; // [sp+54h] [bp-28h]@27
  const char *v31; // [sp+58h] [bp-24h]@27
  char *v32; // [sp+5Ch] [bp-20h]@27
  char *v33; // [sp+60h] [bp-1Ch]@27
  char *v34; // [sp+64h] [bp-18h]@27
  int v35; // [sp+68h] [bp-14h]@28
  char v36; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a7;
      v11 = a8 - 128;
      if ( v11 < a7 )
        LOBYTE(v11) = a7;
      if ( a6 < (char)(v11 - a8) )
        goto LABEL_44;
      if ( 127 - a8 <= a7 )
        v10 = 127 - a8;
      v22 = 1;
      if ( a6 > (char)(a8 + v10) )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, "%d", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, "%d", 3, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v13 = &byte_109CBC28[v12];
    v23 = sub_1004A740((int)&v36, "%d", 3, 0xCu, (double)a8);
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v32 = &byte_109CB428[v12];
  v26 = a3;
  v31 = "sint8";
  v33 = &byte_109CB828[v12];
  v34 = v13;
  v14 = off_10103C10[a1];
  v29 = off_10103C08[v22 != 0];
  v30 = v14;
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - (signed int)a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004CCE0) --------------------------------------------------------
bool __cdecl sub_1004CCE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, signed int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-55h]@2
  char v23; // [sp+1Fh] [bp-51h]@24
  unsigned int v24; // [sp+20h] [bp-50h]@1
  char *v25; // [sp+34h] [bp-3Ch]@27
  int v26; // [sp+38h] [bp-38h]@27
  int v27; // [sp+3Ch] [bp-34h]@27
  int v28; // [sp+40h] [bp-30h]@27
  char *v29; // [sp+44h] [bp-2Ch]@27
  char *v30; // [sp+48h] [bp-28h]@27
  const char *v31; // [sp+4Ch] [bp-24h]@27
  char *v32; // [sp+50h] [bp-20h]@27
  char *v33; // [sp+54h] [bp-1Ch]@27
  char *v34; // [sp+58h] [bp-18h]@27
  int v35; // [sp+5Ch] [bp-14h]@28
  char v36; // [sp+60h] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a8 + 2147483648;
      if ( (signed int)(a8 + 2147483648) < a7 )
        v10 = a7;
      if ( a6 < (signed int)(v10 - a8) )
        goto LABEL_44;
      v11 = 0x7FFFFFFF - a8;
      if ( 0x7FFFFFFF - a8 > a7 )
        v11 = a7;
      v22 = 1;
      if ( a6 > a8 + v11 )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, (char *)&unk_100AC4D0, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, (char *)&unk_100AC4D0, 4, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v23 = sub_1004A740((int)&v36, (char *)&unk_100AC4D0, 4, 0xCu, (double)a8);
    v13 = &byte_109CBC28[v12];
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v26 = a3;
  v31 = "long int";
  v32 = &byte_109CB428[v12];
  v33 = &byte_109CB828[v12];
  v34 = v13;
  v14 = off_10103C08[v22 != 0];
  v30 = off_10103C10[a1];
  v29 = v14;
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004D0A0) --------------------------------------------------------
bool __cdecl sub_1004D0A0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-61h]@2
  char v23; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v24; // [sp+20h] [bp-5Ch]@1
  char *v25; // [sp+40h] [bp-3Ch]@27
  int v26; // [sp+44h] [bp-38h]@27
  int v27; // [sp+48h] [bp-34h]@27
  int v28; // [sp+4Ch] [bp-30h]@27
  char *v29; // [sp+50h] [bp-2Ch]@27
  char *v30; // [sp+54h] [bp-28h]@27
  const char *v31; // [sp+58h] [bp-24h]@27
  char *v32; // [sp+5Ch] [bp-20h]@27
  char *v33; // [sp+60h] [bp-1Ch]@27
  char *v34; // [sp+64h] [bp-18h]@27
  int v35; // [sp+68h] [bp-14h]@28
  char v36; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_44;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v22 = 1;
      if ( a6 > a8 + v11 )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v23 = sub_1004A740((int)&v36, "%u", 3, 0xCu, (double)a8);
    v13 = &byte_109CBC28[v12];
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v26 = a3;
  v31 = "unsigned int";
  v34 = v13;
  v14 = off_10103C08[v22 != 0];
  v30 = off_10103C10[a1];
  v29 = v14;
  v32 = &byte_109CB428[v12];
  v33 = &byte_109CB828[v12];
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004D440) --------------------------------------------------------
bool __cdecl sub_1004D440(int a1, int a2, int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8, int a9)
{
  int v9; // edi@1
  unsigned __int16 v10; // ax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-61h]@2
  char v23; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v24; // [sp+24h] [bp-58h]@1
  char *v25; // [sp+40h] [bp-3Ch]@27
  int v26; // [sp+44h] [bp-38h]@27
  int v27; // [sp+48h] [bp-34h]@27
  int v28; // [sp+4Ch] [bp-30h]@27
  char *v29; // [sp+50h] [bp-2Ch]@27
  char *v30; // [sp+54h] [bp-28h]@27
  const char *v31; // [sp+58h] [bp-24h]@27
  char *v32; // [sp+5Ch] [bp-20h]@27
  char *v33; // [sp+60h] [bp-1Ch]@27
  char *v34; // [sp+64h] [bp-18h]@27
  int v35; // [sp+68h] [bp-14h]@28
  char v36; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int16)(v10 - a8) )
        goto LABEL_44;
      v11 = 0xFFFF - a8;
      if ( v11 > a7 )
        LOWORD(v11) = a7;
      v22 = 1;
      if ( a6 > (unsigned __int16)(a8 + v11) )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v13 = &byte_109CBC28[v12];
    v23 = sub_1004A740((int)&v36, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v32 = &byte_109CB428[v12];
  v26 = a3;
  v31 = "uint16";
  v33 = &byte_109CB828[v12];
  v34 = v13;
  v14 = off_10103C10[a1];
  v29 = off_10103C08[v22 != 0];
  v30 = v14;
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004D840) --------------------------------------------------------
bool __cdecl sub_1004D840(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-61h]@2
  char v23; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v24; // [sp+20h] [bp-5Ch]@1
  char *v25; // [sp+40h] [bp-3Ch]@27
  int v26; // [sp+44h] [bp-38h]@27
  int v27; // [sp+48h] [bp-34h]@27
  int v28; // [sp+4Ch] [bp-30h]@27
  char *v29; // [sp+50h] [bp-2Ch]@27
  char *v30; // [sp+54h] [bp-28h]@27
  const char *v31; // [sp+58h] [bp-24h]@27
  char *v32; // [sp+5Ch] [bp-20h]@27
  char *v33; // [sp+60h] [bp-1Ch]@27
  char *v34; // [sp+64h] [bp-18h]@27
  int v35; // [sp+68h] [bp-14h]@28
  char v36; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_44;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v22 = 1;
      if ( a6 > a8 + v11 )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, (char *)&unk_1007F988, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, (char *)&unk_1007F988, 4, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v23 = sub_1004A740((int)&v36, (char *)&unk_1007F988, 4, 0xCu, (double)a8);
    v13 = &byte_109CBC28[v12];
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v26 = a3;
  v31 = "uint32";
  v34 = v13;
  v14 = off_10103C08[v22 != 0];
  v30 = off_10103C10[a1];
  v29 = v14;
  v32 = &byte_109CB428[v12];
  v33 = &byte_109CB828[v12];
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004DBE0) --------------------------------------------------------
bool __cdecl sub_1004DBE0(int a1, int a2, int a3, int a4, int a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, int a9)
{
  unsigned int v9; // esi@22
  unsigned int v10; // edx@23
  unsigned int v11; // eax@26
  unsigned int v12; // ecx@26
  int v13; // edi@36
  char *v14; // ebx@36
  char *v15; // esi@37
  char *v16; // ecx@39
  int v17; // ebx@41
  int v18; // edx@44
  int v19; // ecx@44
  bool v20; // cf@45
  unsigned __int8 v21; // al@47
  int v22; // eax@49
  bool v24; // [sp+18h] [bp-64h]@3
  char v25; // [sp+27h] [bp-55h]@36
  unsigned int v26; // [sp+28h] [bp-54h]@1
  int v27; // [sp+2Ch] [bp-50h]@1
  char *v28; // [sp+2Ch] [bp-50h]@36
  char *v29; // [sp+40h] [bp-3Ch]@39
  int v30; // [sp+44h] [bp-38h]@39
  int v31; // [sp+48h] [bp-34h]@39
  int v32; // [sp+4Ch] [bp-30h]@39
  char *v33; // [sp+50h] [bp-2Ch]@39
  char *v34; // [sp+54h] [bp-28h]@39
  const char *v35; // [sp+58h] [bp-24h]@39
  char *v36; // [sp+5Ch] [bp-20h]@39
  char *v37; // [sp+60h] [bp-1Ch]@39
  char *v38; // [sp+64h] [bp-18h]@39
  int v39; // [sp+68h] [bp-14h]@40
  char v40; // [sp+6Ch] [bp-10h]@36

  v27 = sub_10047780();
  v26 = 9;
  switch ( a2 )
  {
    case 0:
      if ( a6 != a7 )
        goto LABEL_33;
      v24 = 1;
      goto LABEL_34;
    case 1:
      v24 = a6 != a7;
      goto LABEL_34;
    case 2:
      if ( a6 != a7 && HIDWORD(a6) >= HIDWORD(a7) && (HIDWORD(a6) > HIDWORD(a7) || (unsigned int)a6 > (unsigned int)a7) )
        goto LABEL_33;
      goto LABEL_9;
    case 3:
      if ( a6 == a7 || HIDWORD(a6) > HIDWORD(a7) )
        goto LABEL_33;
      if ( HIDWORD(a6) < HIDWORD(a7) )
      {
LABEL_9:
        v24 = 1;
      }
      else if ( (unsigned int)a6 > (unsigned int)a7 )
      {
LABEL_33:
        v24 = 0;
      }
      else
      {
        v24 = 1;
      }
LABEL_34:
      if ( sub_100486E0() )
        v24 = v24 == 0;
      sub_1004A740((int)&v40, "%I64u", 6, 0xCu, (double)a6);
      v13 = 3072 * v27;
      v14 = &byte_109CB428[3072 * v27];
      _snprintf(&byte_109CB428[3072 * v27], 0x400u, &v40, a6);
      byte_109CB826[v13] = 42;
      byte_109CB827[v13] = 0;
      v25 = sub_1004A740((int)&v40, "%I64u", 6, 0xCu, (double)a7);
      v28 = &byte_109CB828[3072 * v27];
      _snprintf(&byte_109CB828[v13], 0x400u, &v40, a7);
      byte_109CBC26[v13] = 42;
      byte_109CBC27[v13] = 0;
      if ( v26 <= 9 )
      {
        v15 = &byte_109CBC28[v13];
        byte_109CBC28[v13] = 0;
      }
      else
      {
        v25 = sub_1004A740((int)&v40, "%I64u", 6, 0xCu, (double)a8);
        v15 = &byte_109CBC28[v13];
        _snprintf(&byte_109CBC28[v13], 0x400u, &v40, a8);
        byte_109CC026[v13] = 42;
        byte_109CC027[v13] = 0;
      }
      v29 = (&off_10103C18)[4 * a2];
      v32 = a5;
      v31 = a4;
      v38 = v15;
      v30 = a3;
      v35 = "uint64";
      v36 = v14;
      v16 = off_10103C10[a1];
      v33 = off_10103C08[v24 != 0];
      v34 = v16;
      v37 = v28;
      if ( a9 )
      {
        v39 = a9;
        v26 = 11;
      }
      v17 = sub_1005E060();
      sub_10049B90(7, (int)&v29, v26);
      if ( !v25 || a6 == a7 || (double)a8 >= fabs((double)(a6 - a7)) )
        goto LABEL_53;
      v18 = (int)v37;
      v19 = (int)v36;
      break;
    case 4:
      if ( a6 <= a7 )
        goto LABEL_33;
      v24 = 1;
      goto LABEL_34;
    case 5:
      if ( a6 != a7 && HIDWORD(a6) <= HIDWORD(a7) && (HIDWORD(a6) < HIDWORD(a7) || (unsigned int)a6 <= (unsigned int)a7) )
        goto LABEL_33;
      v24 = 1;
      goto LABEL_34;
    case 6:
      v9 = HIDWORD(a7);
      if ( a8 < a7 )
      {
        v10 = a7;
      }
      else
      {
        v9 = HIDWORD(a8);
        v10 = a8;
      }
      if ( a6 < __PAIR__(v9, v10) - a8 )
        goto LABEL_56;
      v11 = -1 - a8;
      v12 = -1 - (((unsigned int)a8 > 0xFFFFFFFF) + HIDWORD(a8));
      if ( v12 > HIDWORD(a7) || v12 >= HIDWORD(a7) && v11 > (unsigned int)a7 )
      {
        v12 = HIDWORD(a7);
        v11 = a7;
      }
      if ( a6 > a8 + __PAIR__(v12, v11) )
      {
LABEL_56:
        v24 = 0;
        v26 = 10;
      }
      else
      {
        v24 = 1;
        v26 = 10;
      }
      goto LABEL_34;
    default:
      goto LABEL_33;
  }
  while ( 1 )
  {
    v20 = *(_BYTE *)v19 < *(_BYTE *)v18;
    if ( *(_BYTE *)v19 != *(_BYTE *)v18 )
      break;
    if ( !*(_BYTE *)v19 )
      goto LABEL_49;
    v21 = *(_BYTE *)(v19 + 1);
    v20 = v21 < *(_BYTE *)(v18 + 1);
    if ( v21 != *(_BYTE *)(v18 + 1) )
      break;
    v19 += 2;
    v18 += 2;
    if ( !v21 )
    {
LABEL_49:
      v22 = 0;
      goto LABEL_51;
    }
  }
  v22 = -v20 - (v20 - 1);
LABEL_51:
  if ( !v22 )
  {
    nullsub_1(v19, v18);
    sub_10049C80(
      3,
      (int)"**Error**",
      a3,
      a4,
      (int)"Test definition error: Floating point values differ by less than the floating point output precision. The out"
           "put can not accurately represent the difference between the actual and expected values in this test case.");
  }
LABEL_53:
  sub_1005E070(v17);
  return v24;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004E1C0) --------------------------------------------------------
bool __cdecl sub_1004E1C0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, int a9)
{
  int v9; // edi@1
  unsigned __int8 v10; // al@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // ebx@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-61h]@2
  char v23; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v24; // [sp+24h] [bp-58h]@1
  char *v25; // [sp+40h] [bp-3Ch]@27
  int v26; // [sp+44h] [bp-38h]@27
  int v27; // [sp+48h] [bp-34h]@27
  int v28; // [sp+4Ch] [bp-30h]@27
  char *v29; // [sp+50h] [bp-2Ch]@27
  char *v30; // [sp+54h] [bp-28h]@27
  const char *v31; // [sp+58h] [bp-24h]@27
  char *v32; // [sp+5Ch] [bp-20h]@27
  char *v33; // [sp+60h] [bp-1Ch]@27
  char *v34; // [sp+64h] [bp-18h]@27
  int v35; // [sp+68h] [bp-14h]@28
  char v36; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < (unsigned __int8)(v10 - a8) )
        goto LABEL_44;
      v11 = 255 - a8;
      if ( v11 > a7 )
        LOBYTE(v11) = a7;
      v22 = 1;
      if ( a6 > (unsigned __int8)(a8 + v11) )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, "%u", 3, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, "%u", 3, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v13 = &byte_109CBC28[v12];
    v23 = sub_1004A740((int)&v36, "%u", 3, 0xCu, (double)a8);
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v32 = &byte_109CB428[v12];
  v26 = a3;
  v31 = "uint8";
  v33 = &byte_109CB828[v12];
  v34 = v13;
  v14 = off_10103C10[a1];
  v29 = off_10103C08[v22 != 0];
  v30 = v14;
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004E5B0) --------------------------------------------------------
bool __cdecl sub_1004E5B0(int a1, int a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  unsigned int v10; // eax@13
  int v11; // eax@16
  int v12; // edi@24
  char *v13; // esi@25
  char *v14; // ecx@27
  int v15; // esi@29
  int v16; // edx@32
  int v17; // ecx@32
  bool v18; // cf@33
  unsigned __int8 v19; // al@35
  int v20; // eax@37
  bool v22; // [sp+1Bh] [bp-61h]@2
  char v23; // [sp+1Fh] [bp-5Dh]@24
  unsigned int v24; // [sp+20h] [bp-5Ch]@1
  char *v25; // [sp+40h] [bp-3Ch]@27
  int v26; // [sp+44h] [bp-38h]@27
  int v27; // [sp+48h] [bp-34h]@27
  int v28; // [sp+4Ch] [bp-30h]@27
  char *v29; // [sp+50h] [bp-2Ch]@27
  char *v30; // [sp+54h] [bp-28h]@27
  const char *v31; // [sp+58h] [bp-24h]@27
  char *v32; // [sp+5Ch] [bp-20h]@27
  char *v33; // [sp+60h] [bp-1Ch]@27
  char *v34; // [sp+64h] [bp-18h]@27
  int v35; // [sp+68h] [bp-14h]@28
  char v36; // [sp+6Ch] [bp-10h]@24

  v9 = sub_10047780();
  v24 = 9;
  switch ( a2 )
  {
    case 0:
      v22 = a6 == a7;
      break;
    case 1:
      v22 = a6 != a7;
      break;
    case 2:
      if ( a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 3:
      if ( a6 == a7 || a6 > a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 4:
      v22 = a6 > a7;
      break;
    case 5:
      if ( a6 != a7 && a6 <= a7 )
        goto LABEL_21;
      v22 = 1;
      break;
    case 6:
      v10 = a8;
      if ( a8 < a7 )
        v10 = a7;
      if ( a6 < v10 - a8 )
        goto LABEL_44;
      v11 = -1 - a8;
      if ( -1 - a8 > a7 )
        v11 = a7;
      v22 = 1;
      if ( a6 > a8 + v11 )
LABEL_44:
        v22 = 0;
      v24 = 10;
      break;
    default:
LABEL_21:
      v22 = 0;
      break;
  }
  if ( sub_100486E0() )
    v22 = v22 == 0;
  sub_1004A740((int)&v36, (char *)&unk_1007F988, 4, 0xCu, (double)a6);
  v12 = 3072 * v9;
  _snprintf(&byte_109CB428[v12], 0x400u, &v36, a6);
  byte_109CB826[v12] = 42;
  byte_109CB827[v12] = 0;
  v23 = sub_1004A740((int)&v36, (char *)&unk_1007F988, 4, 0xCu, (double)a7);
  _snprintf(&byte_109CB828[v12], 0x400u, &v36, a7);
  byte_109CBC26[v12] = 42;
  byte_109CBC27[v12] = 0;
  if ( v24 <= 9 )
  {
    v13 = &byte_109CBC28[v12];
    byte_109CBC28[v12] = 0;
  }
  else
  {
    v23 = sub_1004A740((int)&v36, (char *)&unk_1007F988, 4, 0xCu, (double)a8);
    v13 = &byte_109CBC28[v12];
    _snprintf(&byte_109CBC28[v12], 0x400u, &v36, a8);
    byte_109CC026[v12] = 42;
    byte_109CC027[v12] = 0;
  }
  v25 = (&off_10103C18)[4 * a2];
  v28 = a5;
  v27 = a4;
  v26 = a3;
  v31 = "unsigned long int";
  v34 = v13;
  v14 = off_10103C08[v22 != 0];
  v30 = off_10103C10[a1];
  v29 = v14;
  v32 = &byte_109CB428[v12];
  v33 = &byte_109CB828[v12];
  if ( a9 )
  {
    v35 = a9;
    v24 = 11;
  }
  v15 = sub_1005E060();
  sub_10049B90(7, (int)&v25, v24);
  if ( v23 && a6 != a7 && (double)a8 < fabs((double)(a6 - a7)) )
  {
    v16 = (int)v33;
    v17 = (int)v32;
    while ( 1 )
    {
      v18 = *(_BYTE *)v17 < *(_BYTE *)v16;
      if ( *(_BYTE *)v17 != *(_BYTE *)v16 )
        break;
      if ( !*(_BYTE *)v17 )
        goto LABEL_37;
      v19 = *(_BYTE *)(v17 + 1);
      v18 = v19 < *(_BYTE *)(v16 + 1);
      if ( v19 != *(_BYTE *)(v16 + 1) )
        break;
      v17 += 2;
      v16 += 2;
      if ( !v19 )
      {
LABEL_37:
        v20 = 0;
        goto LABEL_39;
      }
    }
    v20 = -v18 - (v18 - 1);
LABEL_39:
    if ( !v20 )
    {
      nullsub_1(v17, v16);
      sub_10049C80(
        3,
        (int)"**Error**",
        a3,
        a4,
        (int)"Test definition error: Floating point values differ by less than the floating point output precision. The o"
             "utput can not accurately represent the difference between the actual and expected values in this test case.");
    }
  }
  sub_1005E070(v15);
  return v22;
}
// 10060D70: using guessed type int __fastcall nullsub_1(_DWORD, _DWORD);
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004E950) --------------------------------------------------------
int sub_1004E950()
{
  int v0; // esi@1
  int result; // eax@1

  v0 = sub_10047780();
  sub_1004A6A0(1);
  sub_1004AA30(-1);
  result = sub_1004A9C0(-1);
  dword_109CF028[v0] = 0;
  return result;
}
// 109CF028: using guessed type int dword_109CF028[];

//----- (1004E980) --------------------------------------------------------
BOOL __usercall sub_1004E980@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<ebx>, unsigned int a3, char a4, int a5, const char **a6)
{
  const char **v6; // ebp@1
  _BYTE *v7; // esi@1
  int v8; // edi@1
  int v9; // esi@6
  const char *v11; // [sp+Ch] [bp-34h]@6
  char v12; // [sp+10h] [bp-30h]@1
  char v13; // [sp+20h] [bp-20h]@1
  char v14; // [sp+30h] [bp-10h]@1

  v6 = a6;
  v7 = a1;
  LOBYTE(a6) = 0;
  v8 = sub_10047780();
  sub_1005E0A0((int)&v13);
  sub_1005E0A0((int)&v14);
  sub_1005E0A0((int)&v12);
  if ( !v7 || !*v7 )
  {
    v11 = "Actual file not supplied";
    goto LABEL_13;
  }
  if ( !a2 || !*a2 )
  {
    v11 = "Expected file not supplied";
LABEL_13:
    v9 = 1;
    goto LABEL_14;
  }
  if ( sub_1005ECF0((int (__cdecl *)(unsigned int))sub_1004A920, v7, (int)&v13) )
  {
    if ( sub_1005ECF0((int (__cdecl *)(unsigned int))sub_1004A920, a2, (int)&v14) )
    {
      v9 = sub_1005EB60(
             dword_109D1134[v8],
             (int)&v13,
             (int)&v14,
             a3,
             a4,
             (int (__cdecl *)(unsigned int))sub_1004A920,
             (void (__cdecl *)(_DWORD))sub_1004A940,
             (int)&v12,
             (char *)&a6,
             &v11);
      if ( (_BYTE)a6 )
        sub_1005EF90((int)&v12, a5);
    }
    else
    {
      v11 = "Expected bitmap file read failed";
      v9 = 2;
    }
  }
  else
  {
    v11 = "Actual bitmap file read failed";
    v9 = 2;
  }
LABEL_14:
  sub_1005E170((void (__cdecl *)(_DWORD))sub_1004A940, (int)&v12);
  sub_1005E170((void (__cdecl *)(_DWORD))sub_1004A940, (int)&v13);
  sub_1005E170((void (__cdecl *)(_DWORD))sub_1004A940, (int)&v14);
  if ( v6 )
    *v6 = v11;
  return v9 == 0;
}
// 1004A920: using guessed type int sub_1004A920();
// 1004A940: using guessed type int sub_1004A940();
// 109D1134: using guessed type int dword_109D1134[];

//----- (1004EAF0) --------------------------------------------------------
bool __usercall sub_1004EAF0@<al>(int a1@<edx>, int a2@<ecx>, int a3, int a4, int a5, const char *a6, const char *a7, char a8, int a9)
{
  const char *v9; // ebp@1
  const char *v10; // esi@1
  unsigned int v11; // ebx@8
  unsigned int v12; // edi@8
  bool v13; // zf@11
  bool v14; // bl@13
  int v15; // esi@15
  char *v16; // eax@15
  char *v17; // edx@15
  char *v18; // ecx@15
  int v19; // esi@16
  int v20; // edi@18
  const char *v22; // [sp+14h] [bp-148h]@1
  int v23; // [sp+18h] [bp-144h]@1
  int v24; // [sp+24h] [bp-138h]@1
  int v25; // [sp+28h] [bp-134h]@1
  char *v26; // [sp+2Ch] [bp-130h]@15
  int v27; // [sp+30h] [bp-12Ch]@15
  int v28; // [sp+34h] [bp-128h]@15
  int v29; // [sp+38h] [bp-124h]@15
  char *v30; // [sp+3Ch] [bp-120h]@15
  char *v31; // [sp+40h] [bp-11Ch]@15
  const char *v32; // [sp+44h] [bp-118h]@15
  char *v33; // [sp+48h] [bp-114h]@15
  char *v34; // [sp+4Ch] [bp-110h]@15
  int v35; // [sp+50h] [bp-10Ch]@16
  int v36; // [sp+54h] [bp-108h]@16
  char v37; // [sp+58h] [bp-104h]@9
  char v38; // [sp+156h] [bp-6h]@9
  char v39; // [sp+157h] [bp-5h]@9

  v9 = a6;
  v10 = a7;
  v25 = a2;
  v23 = a1;
  v22 = a7;
  v24 = sub_10047780();
  if ( !a6 )
    v9 = "(NULL)";
  if ( !a7 )
  {
    v22 = "(NULL)";
    v10 = "(NULL)";
  }
  if ( a8 )
  {
    if ( !a4 && !sub_100486E0() )
    {
      v11 = strlen(v9);
      v12 = strlen(v10);
      if ( v11 != v12 )
      {
        _snprintf(&v37, 0x100u, "%s - strlen()", v23);
        v38 = 42;
        v39 = 0;
        sub_1004D0A0(0, 0, (int)"..\\lib\\utf\\utf_verify.c", (int)"2499", (int)&v37, v11, v12, 0, 0);
      }
    }
  }
  if ( !strcmp(v9, v10) )
    v13 = a4 == 0;
  else
    v13 = a4 == 1;
  v14 = v13;
  if ( sub_100486E0() )
    v14 = v14 == 0;
  v15 = 3072 * v24;
  _snprintf(&byte_109CB428[3072 * v24], 0x400u, "%s", v9);
  byte_109CB826[v15] = 42;
  byte_109CB827[v15] = 0;
  _snprintf(&byte_109CB828[3072 * v24], 0x400u, "%s", v22);
  v16 = (&off_10103C18)[4 * a4];
  v27 = a5;
  v26 = v16;
  v29 = v23;
  v28 = v25;
  byte_109CBC26[v15] = 42;
  v17 = off_10103C08[v14 != 0];
  v18 = off_10103C10[a3];
  byte_109CBC27[v15] = 0;
  v30 = v17;
  v31 = v18;
  v32 = "string";
  v33 = &byte_109CB428[3072 * v24];
  v34 = &byte_109CB828[3072 * v24];
  if ( a9 )
  {
    v35 = 0;
    v36 = a9;
    v19 = 11;
  }
  else
  {
    v19 = 9;
  }
  v20 = sub_1005E060();
  sub_10049B90(7, (int)&v26, v19);
  sub_1005E070(v20);
  return v14;
}
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;

//----- (1004ED60) --------------------------------------------------------
char __cdecl sub_1004ED60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // esi@1
  int v10; // esi@4
  char *v11; // eax@4
  char v12; // cl@5
  char *v13; // eax@6
  char v14; // cl@7
  char v15; // bl@8
  char *v16; // edx@10
  bool v17; // zf@10
  int v18; // esi@12
  int v19; // edi@17
  unsigned int v21; // [sp+10h] [bp-258h]@2
  char *v22; // [sp+14h] [bp-254h]@4
  int v23; // [sp+18h] [bp-250h]@1
  char *v24; // [sp+1Ch] [bp-24Ch]@4
  int v25; // [sp+20h] [bp-248h]@1
  char *v26; // [sp+24h] [bp-244h]@4
  char *v27; // [sp+28h] [bp-240h]@4
  int v28; // [sp+2Ch] [bp-23Ch]@1
  int v29; // [sp+30h] [bp-238h]@1
  char *v30; // [sp+34h] [bp-234h]@10
  int v31; // [sp+38h] [bp-230h]@10
  int v32; // [sp+3Ch] [bp-22Ch]@10
  int v33; // [sp+40h] [bp-228h]@10
  char *v34; // [sp+44h] [bp-224h]@10
  char *v35; // [sp+48h] [bp-220h]@10
  const char *v36; // [sp+4Ch] [bp-21Ch]@10
  char *v37; // [sp+50h] [bp-218h]@12
  char *v38; // [sp+54h] [bp-214h]@12
  char *v39; // [sp+58h] [bp-210h]@12
  char *v40; // [sp+5Ch] [bp-20Ch]@14
  char v41[2]; // [sp+64h] [bp-204h]@2
  char v42; // [sp+163h] [bp-105h]@3
  char v43; // [sp+164h] [bp-104h]@14
  char v44; // [sp+263h] [bp-5h]@14

  v28 = a4;
  v23 = a5;
  v25 = a7;
  v9 = sub_10047780();
  v29 = v9;
  if ( a8 == 65278 )
  {
    v21 = dword_109D1134[v9] != 0 ? 0x32 : 0;
    strcpy(v41, "0");
  }
  else
  {
    v21 = a8;
    _snprintf(v41, 0x100u, "%u", a8);
    v42 = 0;
  }
  v10 = 560 * v9;
  v22 = &byte_109D2750[v10];
  sub_1004A440(a3, 1, a6, 0x230u, &byte_109D2750[v10]);
  v27 = &byte_109CF050[v10];
  sub_1004A440(a3, 2, a7, 0x230u, &byte_109CF050[v10]);
  v24 = &byte_109D0630[v10];
  sub_1004A440(a3, 3, a6, 0x230u, &byte_109D0630[v10]);
  v26 = &byte_109D1148[v10];
  sub_1004A440(a3, 4, a7, 0x230u, &byte_109D1148[v10]);
  _snprintf(&byte_109D1C38[v10], 0x230u, "%s_Diff_", a6);
  v11 = &byte_109D1C38[v10];
  byte_109D1E67[v10] = 0;
  do
    v12 = *v11++;
  while ( v12 );
  sub_1004A440(a3, 0, v25, 560 - (v11 - &byte_109D1C38[v10 + 1]), &byte_109D1C38[v10] + v11 - &byte_109D1C38[v10 + 1]);
  v13 = &byte_109D1C38[v10];
  byte_109D1E67[v10] = 0;
  do
    v14 = *v13++;
  while ( v14 );
  *(&byte_109D1C34[v10] + v13 - &byte_109D1C38[v10 + 1]) = 0;
  sub_1004A440(a3, 1, (int)&byte_109D1C38[v10], 0x230u, &byte_109CA938[v10]);
  sub_1004A440(a3, 1, (int)&byte_109D1C38[v10], 0x230u, &byte_109CFB40[v10]);
  v15 = sub_1004E980(v22, v27, v21, a2 == 1, (int)&byte_109CA938[v10], (const char **)&v22);
  if ( sub_100486E0() )
    v15 = v15 == 0;
  v30 = (&off_10103C18)[4 * a2];
  v32 = v28;
  v33 = v23;
  v31 = a3;
  v36 = "bitmap-strict";
  v16 = off_10103C10[a1];
  v34 = off_10103C08[v15 != 0];
  v17 = dword_109D1134[v29] == 0;
  v35 = v16;
  if ( !v17 )
    v36 = "bitmap-lenient";
  v37 = v24;
  v38 = v26;
  v39 = v41;
  v18 = 10;
  if ( !v15 && v22 )
  {
    _snprintf(&v43, 0x100u, "Info: %s", v22);
    v44 = 0;
    v40 = &v43;
    v18 = 11;
  }
  if ( a9 )
    (&v30)[4 * v18++] = (char *)a9;
  v19 = sub_1005E060();
  sub_10049B90(7, (int)&v30, v18);
  sub_1005E070(v19);
  return v15;
}
// 10103C08: using guessed type char *off_10103C08[5];
// 10103C10: using guessed type char *off_10103C10[3];
// 10103C18: using guessed type char *off_10103C18;
// 109D1134: using guessed type int dword_109D1134[];

//----- (1004F060) --------------------------------------------------------
bool __cdecl sub_1004F060(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [sp+Ch] [bp-104h]@1
  char v10; // [sp+10Ah] [bp-6h]@1
  char v11; // [sp+10Bh] [bp-5h]@1

  _snprintf(&v9, 0x100u, "%s (ptr diff)", a5);
  v10 = 42;
  v11 = 0;
  return sub_1004B840(a1, a2, a3, a4, (int)&v9, a6 - a7, 0, 0, a8);
}

//----- (1004F110) --------------------------------------------------------
bool __cdecl sub_1004F110(int a1, int a2, int a3, int a4, int a5, const char *a6, const char *a7, int a8)
{
  return sub_1004EAF0(a5, a4, a1, a2, a3, a6, a7, 1, a8);
}

//----- (1004F150) --------------------------------------------------------
const char *__cdecl sub_1004F150(int a1, int a2)
{
  const char *result; // eax@3

  if ( a2 <= 0 )
  {
    result = "\x1B[32;40mPASS\x1B[0m";
    if ( !*(_BYTE *)(a1 + 576) )
      result = "PASS";
  }
  else if ( *(_BYTE *)(a1 + 576) )
  {
    result = "\x1B[31;40mFAILED\x1B[0m";
  }
  else
  {
    result = "FAIL";
  }
  return result;
}

//----- (1004F190) --------------------------------------------------------
char __cdecl sub_1004F190(int a1, int *a2, unsigned int a3)
{
  int *v3; // ebx@1
  int v4; // ebp@1
  int v5; // eax@1
  char *v6; // ebp@1
  char *v7; // eax@11
  int v8; // ecx@12
  int v9; // ST44_4@13
  bool v10; // zf@18
  signed int v11; // edx@24
  const char *v12; // eax@32
  _BYTE *v13; // eax@39
  int v14; // eax@44
  bool v15; // sf@44
  char v16; // cl@45
  char *v17; // eax@50
  int v18; // edx@52
  int v19; // edi@53
  unsigned int v20; // eax@53
  const char *v21; // ecx@53
  _DWORD *v22; // edx@53
  int v23; // esi@57
  int v24; // eax@58
  _BYTE *v25; // ecx@58
  _BYTE *v26; // edx@58
  int v27; // eax@60
  _BYTE *v28; // ecx@60
  _BYTE *v29; // edx@60
  _BYTE *v30; // ecx@62
  _BYTE *v31; // edx@62
  signed int v32; // eax@64
  signed int v33; // edi@73
  int v34; // esi@74
  int v35; // ecx@76
  int v36; // edx@82
  int v37; // eax@83
  int *v38; // eax@106
  char *v39; // ebx@106
  char *v40; // edi@109
  char *v41; // esi@112
  char *v42; // eax@114
  int v43; // ST30_4@123
  const char *v44; // eax@142
  const char *v45; // eax@148
  char *v47; // [sp-14h] [bp-340h]@69
  char v48; // [sp+12h] [bp-31Ah]@24
  char v49; // [sp+13h] [bp-319h]@21
  signed int v50; // [sp+18h] [bp-314h]@52
  char *v51; // [sp+18h] [bp-314h]@94
  char *v52; // [sp+1Ch] [bp-310h]@97
  char *v53; // [sp+20h] [bp-30Ch]@103
  char *v54; // [sp+24h] [bp-308h]@45
  char v55[508]; // [sp+28h] [bp-304h]@11
  char v56; // [sp+224h] [bp-108h]@44
  char v57; // [sp+227h] [bp-105h]@11
  char v58; // [sp+228h] [bp-104h]@123
  char v59; // [sp+327h] [bp-5h]@123

  v3 = a2;
  v4 = sub_10047780();
  LOBYTE(v5) = a1;
  v6 = (char *)&unk_109D3248 + 580 * v4;
  switch ( a1 )
  {
    case 0:
      LOBYTE(v5) = sub_1004A3F0((int)v6, 0);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, "Resetting test status\r\n");
      return v5;
    case 1:
      LOBYTE(v5) = sub_10049F10((int)v6);
      if ( v6[577] && !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, "Clearing test status\r\n");
      return v5;
    case 11:
      LOBYTE(v5) = sub_1004A3F0((int)v6, 0);
      return v5;
    case 4:
      sub_10049D90((int)v6, *a2);
      if ( v6[577] && !v6[578] )
      {
        v7 = sub_1004A0C0((char *)a2[1]);
        _snprintf(v55, 0x200u, "Test Suite: %s (%s)\r\n", *a2, v7);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
      }
      LOBYTE(v5) = 0;
      v8 = (int)&v6[16 * *(_DWORD *)v6 + 4];
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 12) = 0;
      return v5;
    case 5:
      v9 = *a2;
      LOBYTE(v5) = sub_10049D80((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Group: %s - Begin\r\n\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 6:
      LOBYTE(v5) = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8] = 0;
      *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4] = 0;
      v10 = v6[577] == 0;
      *((_DWORD *)v6 + 143) = 0;
      if ( !v10 && !v6[578] )
      {
        _snprintf(v55, 0x200u, "\r\nTest Case: %s\r\n\r\n", *a2);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, v55);
      }
      return v5;
    case 7:
      v49 = sub_10049780((int)a2, a3);
      if ( !v49 && !v6[577] )
        goto LABEL_83;
      if ( v6[578] )
        goto LABEL_81;
      v11 = 0;
      v48 = 0;
      if ( a3 > 7 )
        v11 = strlen((const char *)a2[7]);
      if ( a3 > 8 )
        v11 += strlen((const char *)a2[8]);
      if ( a3 > 3 )
        v11 += strlen((const char *)a2[3]);
      if ( v11 > 100 )
        v48 = 1;
      v12 = sub_1004F150((int)v6, (unsigned __int8)v49);
      _snprintf(v55, 0x200u, "%s ", v12);
      v57 = 0;
      sub_1004A3A0((int)v6, v55);
      if ( a3 > 7 )
      {
        _snprintf(v55, 0x200u, " ACT: %-17s", a2[7]);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
        if ( v48 )
          sub_1004A3A0((int)v6, "\r\n     ");
      }
      if ( a3 > 8 )
      {
        _snprintf(v55, 0x200u, " EXP: %-17s", a2[8]);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
        if ( v48 )
          sub_1004A3A0((int)v6, "\r\n     ");
      }
      if ( a3 > 9 )
      {
        v13 = (_BYTE *)a2[9];
        if ( v13 )
        {
          if ( *v13 )
          {
            if ( memcmp((const void *)a2[9], "0", 2u) )
            {
              _snprintf(v55, 0x200u, " TOL: %-17s", a2[9]);
              v57 = 0;
              sub_1004A3A0((int)v6, v55);
              if ( v48 )
                sub_1004A3A0((int)v6, "\r\n     ");
            }
          }
        }
      }
      v14 = _snprintf(v55, 0x1FCu, " %s", a2[3]);
      v15 = v14 < 0;
      v56 = 0;
      if ( v14 > 0 )
      {
        do
        {
          v16 = (char)(&v54)[v14 + 3];
          if ( v16 != 10 && v16 != 13 )
            break;
          LOBYTE((&v54)[4 * --v14 + 13]) = 0;
        }
        while ( v14 > 0 );
        v15 = v14 < 0;
      }
      if ( !v15 )
      {
        v17 = &v55[v14];
        *(_WORD *)v17 = 2573;
        v17[2] = 0;
      }
      sub_1004A3A0((int)v6, v55);
      if ( a3 <= 0xA )
        goto LABEL_72;
      v18 = 10;
      v50 = 10;
      if ( (signed int)a3 <= 10 )
        goto LABEL_72;
      do
      {
        v19 = v3[v18];
        v20 = 6;
        v21 = "Info: ";
        v22 = (_DWORD *)v3[v18];
        do
        {
          if ( *v22 != *(_DWORD *)v21 )
            goto LABEL_57;
          v20 -= 4;
          v21 += 4;
          ++v22;
        }
        while ( v20 >= 4 );
        if ( !v20 )
          goto LABEL_67;
LABEL_57:
        v23 = *(_BYTE *)v22 - *v21;
        if ( *(_BYTE *)v22 == *v21 )
        {
          v24 = v20 - 1;
          v25 = v21 + 1;
          v26 = (char *)v22 + 1;
          if ( !v24
            || (v23 = *v26 - *v25, *v26 == *v25)
            && ((v27 = v24 - 1, v28 = v25 + 1, v29 = v26 + 1, !v27)
             || (v23 = *v29 - *v28, *v29 == *v28)
             && ((v30 = v28 + 1, v31 = v29 + 1, v27 == 1) || (v23 = *v31 - *v30, *v31 == *v30))) )
          {
            v3 = a2;
LABEL_67:
            v32 = 0;
            goto LABEL_68;
          }
        }
        v3 = a2;
        v32 = 1;
        if ( v23 <= 0 )
          v32 = -1;
LABEL_68:
        if ( v32 )
        {
          _snprintf(v55, 0x200u, "      Post Analysis: %s\r\n", v19);
          v47 = v55;
        }
        else
        {
          _snprintf(v55, 0x200u, "      Compare Info: %s\r\n", v19 + 6);
          v47 = v55;
        }
        v57 = 0;
        sub_1004A3A0((int)v6, v47);
        v18 = v50++ + 1;
      }
      while ( v50 < (signed int)a3 );
LABEL_72:
      if ( v6[309] )
      {
        v33 = 0;
        if ( *((_DWORD *)v6 + 143) > 0 )
        {
          v34 = (int)(v6 + 336);
          do
          {
            if ( v33 >= 20 )
              break;
            v35 = *(_DWORD *)(v34 - 4);
            if ( *(_DWORD *)(v34 + 4) )
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s - %s\r\n", v33, v35, *(_DWORD *)v34, *(_DWORD *)(v34 + 4));
            else
              _snprintf(v55, 0x200u, "      Trace[%i]: %s:%s\r\n", v33, v35, *(_DWORD *)v34);
            v57 = 0;
            sub_1004A3A0((int)v6, v55);
            ++v33;
            v34 += 12;
          }
          while ( v33 < *((_DWORD *)v6 + 143) );
        }
        _snprintf(v55, 0x200u, "      Location: %s:%s\r\n", v3[1], v3[2]);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
      }
LABEL_81:
      if ( v49 )
      {
        v36 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v36 + 4];
        v5 = (int)&v6[v36 + 4];
      }
      else
      {
LABEL_83:
        v37 = 16 * *(_DWORD *)v6;
        ++*(_DWORD *)&v6[v37 + 8];
        v5 = (int)&v6[v37 + 8];
      }
      return v5;
    case 9:
      LOBYTE(v5) = sub_10049FF0((int)v6);
      if ( !(_BYTE)v5 && v6[577] && !v6[578] )
      {
        _snprintf(v55, 0x200u, "Test Group: %s - End\r\n", *a2);
        goto LABEL_17;
      }
      return v5;
    case 3:
      LOBYTE(v5) = sub_10049AA0((const void **)a2, a3);
      if ( !(_BYTE)v5 && !v6[578] )
      {
        if ( v6[577]
          || sub_10049B60((const void **)a2, a3)
          || (LOBYTE(v5) = sub_100499B0((const void **)a2, a3), (_BYTE)v5) )
        {
          if ( a3 <= 8 )
            v51 = &byte_10080D49;
          else
            v51 = (char *)a2[8];
          if ( a3 <= 7 )
            v52 = &byte_10080D49;
          else
            v52 = (char *)a2[7];
          if ( a3 <= 6 )
            v54 = &byte_10080D49;
          else
            v54 = (char *)a2[6];
          if ( a3 <= 5 )
            v53 = &byte_10080D49;
          else
            v53 = (char *)a2[5];
          if ( a3 <= 4 )
          {
            v38 = a2;
            v39 = &byte_10080D49;
          }
          else
          {
            v38 = a2;
            v39 = (char *)a2[4];
          }
          if ( a3 <= 3 )
            v40 = &byte_10080D49;
          else
            v40 = (char *)v38[3];
          if ( a3 )
            v41 = (char *)*v38;
          else
            v41 = &byte_10080D49;
          v10 = sub_10049A70((const void **)a2, a3) == 0;
          v42 = &byte_10080D49;
          if ( v10 )
            v42 = "   ";
          _snprintf(v55, 0x200u, "%s%s %s %s %s %s %s %s\r\n", v42, v41, v40, v39, v53, v54, v52, v51);
          v57 = 0;
          LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, v55);
        }
      }
      return v5;
    case 2:
      if ( v6[578] )
        return v5;
      if ( sub_100497B0((const void **)a2, a3) )
      {
        dword_109D3240 = 2;
        sub_1004A3A0((int)v6, (const char *)&word_1007F968);
        sub_1004A3A0((int)v6, "   Command Format:\r\n");
        sub_1004A3A0(
          (int)v6,
          "       <global-command> [<arguments>]  : Runs the global command with the optional arguments\r\n");
        sub_1004A3A0(
          (int)v6,
          "                                         Commands may consist of multiple words. Arguments may\r\n");
        sub_1004A3A0(
          (int)v6,
          "                                         or may not be required and will be either booleans,\r\n");
        sub_1004A3A0(
          (int)v6,
          "                                         integers (32-bit signed or unsigned), floats, or\r\n");
        sub_1004A3A0((int)v6, "                                         strings depending upon the command\r\n");
        sub_1004A3A0((int)v6, "       <suite>                         : Runs all the test cases of the test suite\r\n");
        sub_1004A3A0(
          (int)v6,
          "       <suite> <case>                  : Runs the specific test case of the test suite\r\n");
        sub_1004A3A0(
          (int)v6,
          "       <suite> <command> [<arguments>] : Runs the test suite specific command with optional arguments\r\n");
        sub_1004A3A0((int)v6, (const char *)&word_1007F968);
        sub_1004A3A0((int)v6, "   Notes:\r\n");
        sub_1004A3A0((int)v6, "       Commands, suite names and test case names are case-insensitive.\r\n");
        sub_1004A3A0((int)v6, (const char *)&word_1007F968);
        sub_1004A3A0(
          (int)v6,
          "       In the command table below, indentation indicates the command is a sub-command of the unindented\r\n");
        sub_1004A3A0(
          (int)v6,
          "       command. Each test case and test suite command is shown indented below the test suite. To run\r\n");
        sub_1004A3A0(
          (int)v6,
          "       a test case or test suite command, you must enter the full command which consists of the both\r\n");
        sub_1004A3A0((int)v6, "       the suite name and the test case or test suite command.\r\n");
        sub_1004A3A0((int)v6, (const char *)&word_1007F968);
        sub_1004A3A0(
          (int)v6,
          "       In the command table below, ***global-commands*** is a place-holder to identify the set of\r\n");
        sub_1004A3A0(
          (int)v6,
          "       global commands and is not a real test suite name. The global commands should be entered\r\n");
        sub_1004A3A0((int)v6, "       without a test suite name.\r\n");
        sub_1004A3A0((int)v6, (const char *)&word_1007F968);
        sub_1004A3A0((int)v6, "   Examples:\r\n");
        sub_1004A3A0(
          (int)v6,
          "       help                            : Displays a brief help message showing all the test suites\r\n");
        sub_1004A3A0((int)v6, "       help -q                         : Quite help; Equivalent to help\r\n");
        sub_1004A3A0(
          (int)v6,
          "       help -v                         : Verbose help; Displays all available help information\r\n");
        sub_1004A3A0(
          (int)v6,
          "       help utf_validate.c             : Displays verbose help for the utf_validate.c test suite\r\n");
        sub_1004A3A0(
          (int)v6,
          "       all                             : Will run all the test cases of the test suites\r\n");
        sub_1004A3A0(
          (int)v6,
          "       utf_validate.c                  : Runs all the test cases of the utf_validate.c suite\r\n");
        sub_1004A3A0(
          (int)v6,
          "       utf_validate.c FAIL ON          : Enables the failing test cases of the utf_validate.c test suite\r\n");
        sub_1004A3A0(
          (int)v6,
          "       utf_validate.c Failing_Cases    : Runs the failing test case of the utf_validate.c test suite\r\n");
        sub_1004A3A0((int)v6, (const char *)&word_1007F968);
        sub_1004A3A0((int)v6, "   Command                                 Description\r\n");
        LOBYTE(v5) = (unsigned int)sub_1004A3A0(
                                     (int)v6,
                                     "   --------------------------------        --------------------------------\r\n");
        return v5;
      }
      if ( sub_10049840((const void **)a2, a3) )
      {
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, (const char *)&word_1007F968);
        return v5;
      }
      if ( sub_10049810((const void **)a2, a3) )
      {
        _snprintf(&v58, 0x100u, "%s %s", a2[3], a2[4]);
        v43 = a2[5];
        v59 = 0;
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s %s\r\n",
          dword_109D3240,
          &byte_10080D49,
          &v58,
          6 - dword_109D3240,
          " ",
          v43);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, v55);
        return v5;
      }
      if ( sub_10049870((const void **)a2, a3) )
      {
        LOBYTE(v5) = sub_100498A0((int)a2, a3);
        if ( (_BYTE)v5 )
        {
          dword_109D3240 += 2;
          return v5;
        }
        if ( sub_100498E0((int)a2, a3) )
        {
          LOBYTE(v5) = 2;
          if ( dword_109D3240 < 2 )
            dword_109D3240 = 0;
          else
            dword_109D3240 -= 2;
          return v5;
        }
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s group\r\n",
          dword_109D3240,
          &byte_10080D49,
          a2[2],
          6 - dword_109D3240,
          " ",
          a2[2]);
LABEL_134:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, v55);
        return v5;
      }
      if ( sub_100497E0((const void **)a2, a3) )
      {
        _snprintf(
          v55,
          0x200u,
          "   %*s%-33s%*s Runs the %s case\r\n",
          dword_109D3240,
          &byte_10080D49,
          a2[3],
          6 - dword_109D3240,
          " ",
          a2[3]);
        goto LABEL_134;
      }
      if ( sub_10049950((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s Runs the %s suite\r\n", a2[1], a2[1]);
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, v55);
      }
      else if ( sub_10049920((const void **)a2, a3) )
      {
        _snprintf(v55, 0x200u, "   %-39s A test results listener\r\n", a2[1]);
LABEL_17:
        v57 = 0;
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, v55);
      }
      else
      {
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, "Unknown test help event\r\n");
      }
      return v5;
    case 8:
      if ( v6[577] && !v6[578] )
      {
        v44 = sub_1004F150((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        _snprintf(v55, 0x200u, "\r\n   Test Case Results: %s\r\n", v44);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Passed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 8]);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
        _snprintf(v55, 0x200u, "      Failed Tests: %4d\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 4]);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
      }
      v5 = (int)&v6[16 * *(_DWORD *)v6];
      if ( *(_DWORD *)(v5 + 4) )
        ++*(_DWORD *)(v5 + 12);
      else
        ++*(_DWORD *)(v5 + 16);
      return v5;
    case 10:
      if ( v6[577] && !v6[578] )
      {
        v45 = sub_1004F150((int)v6, *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        _snprintf(v55, 0x200u, "\r\nTest Suite Results: %s\r\n", v45);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Passed Cases: %4d\r\n", *(_DWORD *)&v6[16 * (*(_DWORD *)v6 + 1)]);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
        _snprintf(v55, 0x200u, "   Failed Cases: %4d\r\n\r\n", *(_DWORD *)&v6[16 * *(_DWORD *)v6 + 12]);
        v57 = 0;
        sub_1004A3A0((int)v6, v55);
      }
      LOBYTE(v5) = sub_1004A050((int)v6, 0);
      return v5;
    case 12:
      LOBYTE(v5) = sub_1004A320((int)v6, 0);
      return v5;
    case 13:
      if ( a3 >= 2 )
      {
        v5 = *((_DWORD *)v6 + 143);
        if ( v5 < 20 )
        {
          *(_DWORD *)&v6[12 * v5 + 332] = *a2;
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143) + 28)] = a2[1];
          v5 = 3 * *((_DWORD *)v6 + 143);
          *(_DWORD *)&v6[12 * (*((_DWORD *)v6 + 143))++ + 340] = a2[2];
        }
      }
      return v5;
    case 14:
      --*((_DWORD *)v6 + 143);
      return v5;
    default:
      if ( !v6[578] )
        LOBYTE(v5) = (unsigned int)sub_1004A3A0((int)v6, "Unknown test event\r\n");
      return v5;
  }
}
// 1007F968: using guessed type __int16 word_1007F968;
// 109D3240: using guessed type int dword_109D3240;
// 1004F190: using guessed type char var_304[508];

//----- (1004FF40) --------------------------------------------------------
signed int __cdecl sub_1004FF40(int a1, int a2)
{
  char *v2; // eax@1

  v2 = (char *)&unk_109D3248 + 580 * sub_10047780();
  if ( a1 == 12 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[576] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else if ( a1 == 13 )
  {
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[577] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  else
  {
    if ( a1 != 14 )
      return sub_10049F50(a1, a2, (int)v2);
    if ( *(_DWORD *)a2 == 1 )
    {
      v2[578] = *(_BYTE *)(a2 + 4);
      return 0;
    }
  }
  return 9;
}

//----- (1004FFC0) --------------------------------------------------------
char **__cdecl sub_1004FFC0(int a1)
{
  char *v1; // eax@1

  v1 = (char *)&unk_109D3248 + 580 * sub_10047780();
  v1[576] = 1;
  v1[577] = 1;
  v1[578] = 0;
  sub_1004A160((int)v1, a1, (int)".txt");
  return &off_101042F8;
}
// 101042F8: using guessed type char *off_101042F8;

//----- (10050000) --------------------------------------------------------
int (__cdecl *__cdecl sub_10050000(const char *a1))(const char *)
{
  int v1; // eax@1

  v1 = sub_10047780();
  return sub_1004A3A0((int)&unk_109D3DA0 + 1812 * v1, a1);
}

//----- (10050020) --------------------------------------------------------
const char *sub_10050020()
{
  return "See version control for test execution date";
}

//----- (10050030) --------------------------------------------------------
__int64 sub_10050030()
{
  return 0i64;
}

//----- (10050040) --------------------------------------------------------
const char *sub_10050040()
{
  return "Not Available";
}

//----- (10050050) --------------------------------------------------------
int __usercall sub_10050050@<eax>(_BYTE *a1@<edi>, int a2)
{
  char v2; // al@1
  int v3; // esi@1
  char v4; // bl@2
  char v5; // cl@3
  _BYTE *v6; // edx@4

  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = *(_BYTE *)(v3 + a2);
    if ( !v4 )
      break;
    v5 = *a1;
    if ( *a1 )
    {
      v6 = a1;
      while ( v5 != v4 )
      {
        v5 = (v6++)[1];
        if ( !v5 )
          goto LABEL_9;
      }
      v2 = 1;
    }
LABEL_9:
    ++v3;
    if ( v2 )
      return v3 - 1;
  }
  if ( v2 )
    --v3;
  return v3;
}

//----- (100500A0) --------------------------------------------------------
signed int __cdecl sub_100500A0(int a1, int a2)
{
  int v2; // eax@1

  v2 = sub_10047780();
  return sub_10049F50(a1, a2, (int)&unk_109D3DA0 + 1812 * v2);
}

//----- (100501F0) --------------------------------------------------------
int __usercall sub_100501F0@<eax>(char *a1@<ecx>, _DWORD *a2@<esi>, int a3)
{
  char *v3; // edi@1
  char *v4; // eax@1
  unsigned int v5; // kr00_4@1
  char v6; // cl@1
  char *v7; // eax@4
  char *v8; // eax@4
  char *v9; // eax@5
  unsigned __int8 *v10; // eax@6
  unsigned __int8 *v11; // eax@9
  signed int i; // edi@9
  int result; // eax@11
  int v14; // ecx@11
  unsigned __int8 *v15; // [sp+8h] [bp-10Ch]@9
  unsigned __int8 *v16; // [sp+Ch] [bp-108h]@1
  char v17; // [sp+10h] [bp-104h]@1
  char v18[253]; // [sp+11h] [bp-103h]@3
  char v19; // [sp+10Eh] [bp-6h]@1

  v3 = a1;
  sub_1005EFD0((int)&a2[151 * (*a2 + 1)], (int)sub_10050000, 0);
  *(_QWORD *)&a2[2 * *a2 + 147] = sub_10050030();
  v4 = sub_1005DA20("CFG_StyleSheetDir", (int)"/Starteam/GDU1XXX/Verification/Automated_Test_Scripts/Stylesheets/");
  _snprintf(&v17, 0xFFu, v4);
  v19 = 0;
  v5 = strlen(&v17);
  v6 = (char)(&v16)[v5 + 3];
  if ( v6 != 92 && v6 != 47 )
  {
    *(&v17 + v5) = 47;
    v18[v5] = 0;
  }
  sub_1005F420((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<?xml version=\"1.0\" encoding=\"Windows-1252\"?>", 0);
  v7 = sub_1005DA20("CFG_StyleSheet", (int)"std_output_frmt.xsl");
  _snprintf((char *)&a2[151 * *a2 + 174], 0x200u, "<?xml-stylesheet type=\"text/xsl\" href=\"%s%s\"?>", &v17, v7);
  BYTE3(a2[151 * *a2 + 301]) = 0;
  sub_1005F420((int)&a2[151 * *a2 + 151], (unsigned __int8 *)&a2[151 * *a2 + 174], 0);
  sub_1005F420((int)&a2[151 * (*a2 + 1)], (unsigned __int8 *)"<!-- saved from url=(0021)http://www.garmin.com -->", 0);
  sub_1005F3A0((int)&a2[151 * (*a2 + 1)], (int)"TestResults");
  sub_1005F230((int)&a2[151 * (*a2 + 1)], (int)"xmlns", (unsigned __int8 *)"http://www.garmin.com/GATE");
  v8 = sub_1005DA20("CFG_OutputTestRevision", (int)"False");
  if ( !sub_10047830(v8, (int)"True") )
  {
    v9 = strstr(v3, "$Id: ");
    if ( v9 )
      v10 = (unsigned __int8 *)(v9 + 5);
    else
      v10 = (unsigned __int8 *)v3;
    sub_1005F470((int)&a2[151 * (*a2 + 1)], (int)"Version", v10);
    sub_1005F470((int)&a2[151 * (*a2 + 1)], (int)"ResultVersion", (unsigned __int8 *)"$Id$");
  }
  sub_1005F3A0((int)&a2[151 * (*a2 + 1)], (int)"Config");
  sub_1005F3A0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
  sub_1005F470((int)&a2[151 * (*a2 + 1)], (int)"Name", (unsigned __int8 *)"CFG_TestFile");
  v11 = (unsigned __int8 *)sub_1004A0C0(v3);
  sub_1005F470((int)&a2[151 * (*a2 + 1)], (int)"Value", v11);
  sub_1005F320((int)&a2[151 * (*a2 + 1)]);
  for ( i = 0; sub_1005D9E0(i, &v15, &v16); ++i )
  {
    sub_1005F3A0((int)&a2[151 * (*a2 + 1)], (int)"TestVar");
    sub_1005F470((int)&a2[151 * (*a2 + 1)], (int)"Name", v15);
    sub_1005F470((int)&a2[151 * (*a2 + 1)], (int)"Value", v16);
    sub_1005F320((int)&a2[151 * (*a2 + 1)]);
  }
  sub_1005F320((int)&a2[151 * (*a2 + 1)]);
  sub_1005F3A0((int)&a2[151 * (*a2 + 1)], (int)"TestProcedure");
  sub_1005F230((int)&a2[151 * (*a2 + 1)], (int)"name", (unsigned __int8 *)a3);
  result = 0;
  v14 = (int)&a2[4 * *a2 + 1];
  *(_DWORD *)v14 = 0;
  *(_DWORD *)(v14 + 4) = 0;
  *(_DWORD *)(v14 + 8) = 0;
  *(_DWORD *)(v14 + 12) = 0;
  return result;
}
// 100501F0: using guessed type char var_103[253];

//----- (10050570) --------------------------------------------------------
char __cdecl sub_10050570(int a1, const void **a2, unsigned int a3)
{
  int v3; // ebp@1
  int v4; // eax@1
  char *v5; // ebp@1
  const char *v6; // ebx@3
  int v7; // esi@4
  int v8; // ST14_4@5
  int v9; // eax@12
  const char *v10; // eax@13
  const char *v11; // eax@15
  int v12; // ST14_4@17
  int v13; // ecx@29
  const void *v14; // ST24_4@43
  int v15; // ST04_4@44
  _BYTE *v16; // eax@87
  _BYTE *v17; // eax@94
  _BYTE *v18; // eax@100
  int v19; // ST20_4@104
  unsigned int v20; // esi@105
  _DWORD *v21; // edx@106
  unsigned int v22; // eax@106
  const char *v23; // ecx@106
  int v24; // esi@110
  int v25; // eax@111
  _BYTE *v26; // ecx@111
  _BYTE *v27; // edx@111
  int v28; // eax@113
  _BYTE *v29; // ecx@113
  _BYTE *v30; // edx@113
  _BYTE *v31; // ecx@115
  _BYTE *v32; // edx@115
  bool v33; // zf@117
  bool v34; // sf@117
  signed int v35; // eax@117
  const char *v36; // eax@129
  const char *v37; // eax@131
  const char *v39; // [sp-10h] [bp-124h]@73
  unsigned __int8 *v40; // [sp-Ch] [bp-120h]@73
  char v41; // [sp+9h] [bp-10Bh]@46
  char v42; // [sp+Ah] [bp-10Ah]@46
  char v43; // [sp+Bh] [bp-109h]@46
  char *v44; // [sp+Ch] [bp-108h]@91
  signed int v45; // [sp+Ch] [bp-108h]@105
  char v46[255]; // [sp+10h] [bp-104h]@5
  char v47; // [sp+10Fh] [bp-5h]@44

  v3 = sub_10047780();
  LOBYTE(v4) = a1;
  v5 = (char *)&unk_109D3DA0 + 1812 * v3;
  switch ( a1 )
  {
    case 3:
      if ( sub_10049B00(a2, a3) )
      {
        v6 = (const char *)a2[3];
        do
        {
          v4 = sub_10050050(", \t", (int)v6);
          v7 = v4;
          if ( v4 )
          {
            strncpy(v46, v6, v4);
            v8 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
            v46[v7] = 0;
            sub_1005F3A0(v8, (int)"Req");
            sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"id", (unsigned __int8 *)v46);
            LOBYTE(v4) = (unsigned int)sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
            v6 += v7;
          }
          else
          {
            ++v6;
          }
        }
        while ( *v6 );
      }
      else if ( sub_10049AD0(a2, a3) )
      {
        if ( sub_1004A260((int)v5, 3, 1, 0) )
          sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        v9 = *((_DWORD *)v5 + 146);
        if ( v9 > 0 )
        {
          *((_DWORD *)v5 + 146) = v9 - 1;
          sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
          v10 = "true";
          if ( *((_DWORD *)v5 + 144) <= 0 )
            v10 = "false";
          sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v10);
          v11 = "true";
          if ( *((_DWORD *)v5 + 145) <= 0 )
            v11 = "false";
          sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v11);
          sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          v12 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          *((_DWORD *)v5 + 144) = 0;
          *((_DWORD *)v5 + 145) = 0;
          sub_1005F320(v12);
          sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        }
        LOBYTE(v4) = (unsigned int)sub_1005F230(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"title",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10049A10(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1005F470(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"Method",
                                     (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 146);
      }
      else if ( sub_10049B30(a2, a3) )
      {
        LOBYTE(v4) = (unsigned int)sub_1005F470(
                                     (int)&v5[604 * (*(_DWORD *)v5 + 1)],
                                     (int)"TestType",
                                     (unsigned __int8 *)a2[3]);
      }
      else if ( sub_10049AA0(a2, a3) )
      {
        if ( sub_1004A260((int)v5, 3, 1, 0) )
          sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1004A1D0((int)a2, a3, (int)v5);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      }
      else if ( sub_10049A40(a2, a3) )
      {
        sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Results");
        v13 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        if ( *(_BYTE *)a2[3] == 48 )
        {
          sub_1005F230(v13, (int)"success", (unsigned __int8 *)"0");
          sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"error_msg", (unsigned __int8 *)a2[3] + 1);
        }
        else
        {
          sub_1005F230(v13, (int)"success", (unsigned __int8 *)&unk_100A3AB8);
        }
        if ( v5[309] )
        {
          sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
          sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
        }
        sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        LOBYTE(v4) = sub_1004A260((int)v5, 3, 0, 0);
        if ( (_BYTE)v4 )
          LOBYTE(v4) = (unsigned int)sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      else
      {
        LOBYTE(v4) = sub_100499E0(a2, a3);
        if ( (_BYTE)v4 )
        {
          if ( !sub_1004A310((int)v5) )
            sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
          sub_1005F470((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
          LOBYTE(v4) = sub_1004A260((int)v5, 3, 0, 1);
          if ( (_BYTE)v4 )
            LOBYTE(v4) = (unsigned int)sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      return v4;
    case 4:
      LOBYTE(v4) = sub_10049D90((int)v5, (int)*a2);
      if ( (_BYTE)v4 )
        LOBYTE(v4) = sub_100501F0((char *)a2[1], v5, (int)*a2);
      return v4;
    case 5:
      v14 = *a2;
      LOBYTE(v4) = sub_10049D80((int)v5);
      if ( !(_BYTE)v4 )
      {
        sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
        _snprintf(v46, 0x100u, "Test Group: %s", *a2);
        v15 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
        v47 = 0;
        sub_1005F470(v15, (int)"Method", (unsigned __int8 *)v46);
        LOBYTE(v4) = (unsigned int)sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      return v4;
    case 6:
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      LOBYTE(v4) = sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestGroup");
      return v4;
    case 7:
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( a3 <= 6 )
        goto LABEL_56;
      if ( !memcmp(a2[6], "bool", 5u) || !memcmp(a2[6], "char", 5u) || !memcmp(a2[6], "string", 7u) )
      {
        v42 = 1;
        goto LABEL_56;
      }
      if ( !memcmp(a2[6], "bitmap", 7u) || !memcmp(a2[6], "bitmap-lenient", 0xFu) )
        goto LABEL_55;
      if ( !memcmp(a2[6], "bitmap-strict", 0xEu) )
      {
        v43 = 1;
LABEL_55:
        v41 = 1;
      }
LABEL_56:
      if ( !*((_DWORD *)v5 + 146) )
      {
        sub_1005F470(
          (int)&v5[604 * (*(_DWORD *)v5 + 1)],
          (int)"Method",
          (unsigned __int8 *)"Method Placeholder -- Add UTF_grp to test case");
        sub_1005F470((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestType", (unsigned __int8 *)"Low Level Testing");
        ++*((_DWORD *)v5 + 146);
      }
      if ( !sub_1004A310((int)v5) )
        sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"TestStep");
      if ( sub_10049980((int)a2, a3) )
      {
        if ( *(_BYTE *)a2[3] )
        {
          sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction");
          sub_1005F2D0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (unsigned __int8 *)a2[3]);
          sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
        ++*((_DWORD *)v5 + 145);
      }
      else
      {
        if ( *(_BYTE *)a2[3] )
          sub_1005F470((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Instruction", (unsigned __int8 *)a2[3]);
        ++*((_DWORD *)v5 + 144);
      }
      sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Compare");
      if ( sub_10049780((int)a2, a3) )
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 4];
        sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Fail");
      }
      else
      {
        ++*(_DWORD *)&v5[16 * *(_DWORD *)v5 + 8];
        sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"results", (unsigned __int8 *)"Pass");
      }
      sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"type", (unsigned __int8 *)*a2);
      sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"class", (unsigned __int8 *)a2[5]);
      if ( a3 <= 6 )
        goto LABEL_77;
      if ( v41 )
      {
        sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"datatype", (unsigned __int8 *)"bitmap");
        if ( !v43 )
        {
          sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"strict", (unsigned __int8 *)"false");
          goto LABEL_77;
        }
        v40 = (unsigned __int8 *)"true";
        v39 = "strict";
      }
      else
      {
        v40 = (unsigned __int8 *)a2[6];
        v39 = "datatype";
      }
      sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)v39, v40);
LABEL_77:
      if ( v5[309] )
      {
        sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"file", (unsigned __int8 *)a2[1]);
        sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"line", (unsigned __int8 *)a2[2]);
      }
      if ( a3 > 7 )
      {
        sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Actual");
        if ( v42 )
          sub_1005F280((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        else
          sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"actual", (unsigned __int8 *)a2[7]);
        sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      }
      if ( a3 > 8 )
      {
        if ( v42 )
        {
          sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Expected");
          sub_1005F280((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)a2[8]);
          sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
          if ( a3 > 9 )
          {
            v16 = a2[9];
            if ( v16 )
            {
              if ( *v16 )
              {
                sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Tolerance");
                sub_1005F280((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"tolerance", (unsigned __int8 *)a2[9]);
                sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
              }
            }
          }
        }
        else
        {
          if ( v41 )
          {
            v44 = "!";
            if ( memcmp(*a2, &unk_100C5038, 3u) )
              v44 = &byte_10080D49;
            if ( a3 > 9 && (v17 = a2[9]) != 0 && *v17 && memcmp(a2[9], "0", 2u) )
              _snprintf(v46, 0x100u, "%s%s+/-%s", v44, a2[8], a2[9]);
            else
              _snprintf(v46, 0x100u, "%s%s", v44, a2[8]);
          }
          else if ( a3 > 9 && (v18 = a2[9]) != 0 && *v18 )
          {
            _snprintf(v46, 0x100u, "N EQ %s(+/-)%s", a2[8], a2[9]);
          }
          else
          {
            _snprintf(v46, 0x100u, "N %s %s", *a2, a2[8]);
          }
          v19 = (int)&v5[604 * (*(_DWORD *)v5 + 1)];
          v47 = 0;
          sub_1005F3A0(v19, (int)"Expected");
          sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"expected", (unsigned __int8 *)v46);
          sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
        }
      }
      v20 = 10;
      v45 = 10;
      if ( a3 <= 0xA )
        goto LABEL_125;
      break;
    case 8:
      if ( sub_1004A260((int)v5, 8, 1, 0) )
        sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"RangeTested");
      v36 = "true";
      if ( *((_DWORD *)v5 + 144) <= 0 )
        v36 = "false";
      sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Normal", (unsigned __int8 *)v36);
      v37 = "true";
      if ( *((_DWORD *)v5 + 145) <= 0 )
        v37 = "false";
      sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"Robustness", (unsigned __int8 *)v37);
      sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      LOBYTE(v4) = (unsigned int)sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
      return v4;
    case 9:
      LOBYTE(v4) = sub_10049FF0((int)v5);
      return v4;
    case 10:
      LOBYTE(v4) = sub_1004A050((int)v5, (void (__cdecl *)(int))sub_100500D0);
      return v4;
    case 0:
    case 11:
      sub_1004A3F0((int)v5, (void (__cdecl *)(int))sub_100500D0);
      goto LABEL_139;
    case 1:
      sub_10049F10((int)v5);
      goto LABEL_139;
    case 12:
      sub_1004A320((int)v5, (void (__cdecl *)(int))sub_100500D0);
LABEL_139:
      LOBYTE(v4) = 0;
      *((_DWORD *)v5 + 144) = 0;
      *((_DWORD *)v5 + 145) = 0;
      *((_DWORD *)v5 + 146) = 0;
      return v4;
    default:
      return v4;
  }
  do
  {
    v21 = a2[v20];
    v22 = 6;
    v23 = "Info: ";
    do
    {
      if ( *v21 != *(_DWORD *)v23 )
        goto LABEL_110;
      v22 -= 4;
      v23 += 4;
      ++v21;
    }
    while ( v22 >= 4 );
    if ( !v22 )
      goto LABEL_120;
LABEL_110:
    v24 = *(_BYTE *)v21 - *v23;
    if ( *(_BYTE *)v21 == *v23 )
    {
      v25 = v22 - 1;
      v26 = v23 + 1;
      v27 = (char *)v21 + 1;
      if ( !v25
        || (v24 = *v27 - *v26, *v27 == *v26)
        && ((v28 = v25 - 1, v29 = v26 + 1, v30 = v27 + 1, !v28)
         || (v24 = *v30 - *v29, *v30 == *v29)
         && ((v31 = v29 + 1, v32 = v30 + 1, v28 == 1) || (v24 = *v32 - *v31, *v32 == *v31))) )
      {
        v20 = v45;
LABEL_120:
        v35 = 0;
        goto LABEL_121;
      }
    }
    v33 = v24 == 0;
    v34 = v24 < 0;
    v20 = v45;
    v35 = 1;
    if ( v34 || v33 )
      v35 = -1;
LABEL_121:
    if ( v35 )
    {
      sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"PostAnalysis");
      sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"note", (unsigned __int8 *)a2[v20]);
      sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    else
    {
      sub_1005F3A0((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"CompareInfo");
      sub_1005F230((int)&v5[604 * (*(_DWORD *)v5 + 1)], (int)"comp_info", (unsigned __int8 *)a2[v20] + 6);
      sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
    }
    v45 = ++v20;
  }
  while ( v20 < a3 );
LABEL_125:
  sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  LOBYTE(v4) = sub_1004A260((int)v5, 7, 0, 1);
  if ( (_BYTE)v4 )
    LOBYTE(v4) = (unsigned int)sub_1005F320((int)&v5[604 * (*(_DWORD *)v5 + 1)]);
  return v4;
}
// 100500D0: using guessed type int sub_100500D0();
// 10050570: using guessed type char var_104[255];

//----- (10051390) --------------------------------------------------------
char **__cdecl sub_10051390(int a1)
{
  char *v1; // esi@1
  int v2; // esi@1
  signed int v3; // edi@1

  v1 = (char *)&unk_109D3DA0 + 1812 * sub_10047780();
  *((_DWORD *)v1 + 146) = 0;
  sub_1004A160((int)v1, a1, (int)".xml");
  v2 = (int)(v1 + 604);
  v3 = 2;
  do
  {
    sub_1005EFD0(v2, (int)sub_10050000, 0);
    v2 += 604;
    --v3;
  }
  while ( v3 );
  return &off_10105088;
}
// 10105088: using guessed type char *off_10105088;

//----- (10051400) --------------------------------------------------------
int __cdecl sub_10051400(int *a1, int a2)
{
  int result; // eax@1

  result = a2 + (*(int (**)(void))dword_10A09228)();
  *a1 = result;
  return result;
}
// 10A09228: using guessed type int dword_10A09228;

//----- (10051430) --------------------------------------------------------
char __cdecl sub_10051430(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x319u )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 115, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_1011F130[8 * a1];
  *a4 = word_1011F132[a2 + 4 * a1];
  return 1;
}
// 1011F132: using guessed type __int16 word_1011F132[];

//----- (10051490) --------------------------------------------------------
char __cdecl sub_10051490(unsigned __int16 a1, unsigned __int8 a2, _BYTE *a3, _WORD *a4)
{
  if ( a1 >= 0x145u )
  {
    sub_10028BC0("..\\lib\\acl\\iop\\dscrt\\iop_dscrt_data_tbl_utl.c", 320, 0, 0);
    return 0;
  }
  if ( a2 >= 3u )
    return 0;
  *a3 = byte_101209F8[16 * a1];
  *a4 = word_10120A00[a2 + 8 * a1];
  return 1;
}
// 10120A00: using guessed type __int16 word_10120A00[];

//----- (100514F0) --------------------------------------------------------
char __cdecl sub_100514F0(_DWORD *a1)
{
  void *v1; // ecx@0
  char v2; // al@1
  char v3; // al@1
  char result; // al@3
  char v5; // [sp+7h] [bp-5h]@1
  int v6; // [sp+8h] [bp-4h]@2

  v2 = sub_10043C20(v1);
  v5 = sub_10043EA0(v2, 1);
  v3 = sub_1002CC90(&v5, 1u, (int)&unk_101060B8, 4, 3, 2);
  v5 = v3;
  if ( v3 != 2 && sub_10015AC0(6, (unsigned __int16)word_101060BA[2 * (unsigned __int8)v3], &v6) )
  {
    result = 1;
    *a1 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 101060BA: using guessed type __int16 word_101060BA[];

//----- (10051560) --------------------------------------------------------
__int16 *__cdecl sub_10051560(char a1, unsigned __int16 a2)
{
  char *v2; // eax@1
  signed int v3; // ecx@1
  unsigned __int8 v4; // bl@3
  char v5; // cl@6
  int v6; // eax@6
  unsigned __int16 *v7; // esi@25
  int v8; // edi@25
  int v9; // eax@29
  unsigned __int16 *v10; // esi@32
  int v11; // edi@32
  int v12; // eax@36
  char v14; // [sp+8h] [bp-224h]@3
  char v15; // [sp+9h] [bp-223h]@3
  unsigned __int8 v16; // [sp+Ah] [bp-222h]@3
  char v17; // [sp+Bh] [bp-221h]@26
  unsigned __int16 v18; // [sp+Ch] [bp-220h]@26
  char v19[4]; // [sp+10h] [bp-21Ch]@3
  char v20; // [sp+14h] [bp-218h]@4
  char v21[20]; // [sp+15h] [bp-217h]@8
  char v22; // [sp+29h] [bp-203h]@9
  __int16 v23; // [sp+2Ch] [bp-200h]@13
  __int16 v24; // [sp+2Eh] [bp-1FEh]@15
  __int16 v25[100]; // [sp+98h] [bp-194h]@3
  __int16 v26[100]; // [sp+160h] [bp-CCh]@3

  v2 = byte_109D610A;
  v3 = 203;
  do
  {
    *((_WORD *)v2 - 1) = a2;
    *v2 = 3;
    v2 += 4;
    --v3;
  }
  while ( v3 );
  v4 = 0;
  v14 = 0;
  v16 = 0;
  v15 = 0;
  memset(v26, 0, 0xC8u);
  memset(v25, 0, 0xC8u);
  v19[0] = 0;
  do
  {
    if ( !sub_1005F550(v19[0], &v20) )
      goto LABEL_20;
    if ( v20 )
    {
LABEL_9:
      ++v15;
      if ( v22 )
      {
        if ( v22 == 1 )
        {
          if ( !v23 )
            goto LABEL_20;
          v25[v4] = v23;
LABEL_19:
          ++v4;
          goto LABEL_20;
        }
        if ( v22 != 2 )
          goto LABEL_20;
      }
      else if ( v24 )
      {
        v26[v16++] = v24;
      }
      if ( !v23 )
        goto LABEL_20;
      v25[v4] = v23;
      goto LABEL_19;
    }
    v5 = 0;
    v6 = 0;
    while ( v5 )
    {
      v5 = v21[v6++];
      if ( v5 != *(&byte_10080D49 + v6) )
        goto LABEL_9;
    }
LABEL_20:
    ++v19[0];
  }
  while ( v19[0] < 0x64u );
  if ( v15 )
  {
    if ( !a1 )
    {
      word_109D6108[0] = 6;
      byte_109D610A[0] = 1;
      word_109D610C = 10;
      byte_109D610E = 1;
      v14 = 2;
    }
    if ( v4 )
    {
      v7 = (unsigned __int16 *)v25;
      v8 = v4;
      do
      {
        if ( sub_10051490(*v7, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v9 = 2 * (unsigned __int8)v14;
          word_109D6108[v9] = v18;
          byte_109D610A[v9 * 2] = 1;
          ++v14;
        }
        ++v7;
        --v8;
      }
      while ( v8 );
    }
    if ( v16 )
    {
      v10 = (unsigned __int16 *)v26;
      v11 = v16;
      do
      {
        if ( sub_10051430(*v10, 0, &v17, &v18) == 1 && v17 == a1 && v18 < a2 )
        {
          v12 = 2 * (unsigned __int8)v14;
          word_109D6108[v12] = v18;
          byte_109D610A[v12 * 2] = 1;
          ++v14;
        }
        ++v10;
        --v11;
      }
      while ( v11 );
    }
  }
  return word_109D6108;
}
// 109D6108: using guessed type __int16 word_109D6108[];
// 109D610C: using guessed type __int16 word_109D610C;
// 109D610E: using guessed type char byte_109D610E;
// 10051560: using guessed type __int16 var_CC[100];
// 10051560: using guessed type __int16 var_194[100];
// 10051560: using guessed type char var_217[20];

//----- (100517D0) --------------------------------------------------------
int __cdecl sub_100517D0(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10107598 + a1);
        break;
      case 0:
        result = (int)*(&off_101075A4 + a1);
        break;
      case 1:
        result = (int)*(&off_101075B0 + a1);
        break;
      case 2:
        result = (int)*(&off_101075BC + a1);
        break;
      case 3:
        result = (int)*(&off_101075C8 + a1);
        break;
      case 5:
        result = (int)*(&off_101075D4 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 10107598: using guessed type void *off_10107598;
// 101075A4: using guessed type void *off_101075A4;
// 101075B0: using guessed type void *off_101075B0;
// 101075BC: using guessed type void *off_101075BC;
// 101075C8: using guessed type void *off_101075C8;
// 101075D4: using guessed type void *off_101075D4;

//----- (10051850) --------------------------------------------------------
int __cdecl sub_10051850(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10107508 + a1);
        break;
      case 0:
        result = (int)*(&off_10107514 + a1);
        break;
      case 1:
        result = (int)*(&off_10107520 + a1);
        break;
      case 2:
        result = (int)*(&off_1010752C + a1);
        break;
      case 3:
        result = (int)*(&off_10107538 + a1);
        break;
      case 5:
        result = (int)*(&off_10107544 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 10107508: using guessed type void *off_10107508;
// 10107514: using guessed type void *off_10107514;
// 10107520: using guessed type void *off_10107520;
// 1010752C: using guessed type void *off_1010752C;
// 10107538: using guessed type void *off_10107538;
// 10107544: using guessed type void *off_10107544;

//----- (100518D0) --------------------------------------------------------
int __cdecl sub_100518D0(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_101075E0 + a1);
        break;
      case 0:
        result = (int)*(&off_101075EC + a1);
        break;
      case 1:
        result = (int)*(&off_101075F8 + a1);
        break;
      case 2:
        result = (int)*(&off_10107604 + a1);
        break;
      case 3:
        result = (int)*(&off_10107610 + a1);
        break;
      case 5:
        result = (int)*(&off_1010761C + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 101075E0: using guessed type void *off_101075E0;
// 101075EC: using guessed type void *off_101075EC;
// 101075F8: using guessed type void *off_101075F8;
// 10107604: using guessed type void *off_10107604;
// 10107610: using guessed type void *off_10107610;
// 1010761C: using guessed type void *off_1010761C;

//----- (10051950) --------------------------------------------------------
void *__cdecl sub_10051950(unsigned __int8 a1, char a2)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 3u )
  {
    switch ( a2 )
    {
      case 6:
        result = *(&off_10107550 + a1);
        break;
      case 0:
        result = *(&off_1010755C + a1);
        break;
      case 1:
        result = *(&off_10107568 + a1);
        break;
      case 2:
        result = *(&off_10107574 + a1);
        break;
      case 3:
        result = *(&off_10107580 + a1);
        break;
      case 5:
        result = &unk_101068E4;
        break;
      default:
        return result;
    }
  }
  return result;
}
// 10107550: using guessed type void *off_10107550;
// 1010755C: using guessed type void *off_1010755C;
// 10107568: using guessed type void *off_10107568;
// 10107574: using guessed type void *off_10107574;
// 10107580: using guessed type void *off_10107580;

//----- (100519D0) --------------------------------------------------------
int __cdecl sub_100519D0(char a1)
{
  return sub_1002CC90(&a1, 1u, (int)&unk_10107628, 28, 12, 11);
}

//----- (100519F0) --------------------------------------------------------
int __cdecl sub_100519F0(char a1)
{
  return sub_1002CC90(&a1, 1u, (int)&unk_10106F98, 16, 11, 11);
}

//----- (10051A10) --------------------------------------------------------
int __cdecl sub_10051A10(char a1)
{
  return sub_1002CC90(&a1, 1u, (int)&unk_10107048, 64, 19, 19);
}

//----- (10051A30) --------------------------------------------------------
void *__cdecl sub_10051A30(char a1, unsigned __int8 a2, char a3)
{
  void *v3; // esi@1
  unsigned __int8 v4; // al@3
  void *result; // eax@4

  v3 = 0;
  if ( a2 >= 3u || (unsigned __int8)a1 > 0x3Fu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_100519D0(a1);
    switch ( a3 )
    {
      case 6:
        result = &unk_101068D0;
        break;
      case 0:
        result = *(&off_1010762C + a2 + 7 * v4);
        break;
      case 1:
        result = *(&off_10107638 + a2 + 7 * v4);
        break;
      case 2:
        result = &unk_101068DC;
        break;
      case 3:
        result = &unk_101068E0;
        break;
      case 5:
        v3 = &unk_101068E4;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 1010762C: using guessed type void *off_1010762C;
// 10107638: using guessed type void *off_10107638;

//----- (10051AF0) --------------------------------------------------------
void *__cdecl sub_10051AF0(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0xBu )
  {
    result = 0;
  }
  else
  {
    v4 = sub_100519F0(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_10106F9C + a1 + 4 * v4);
        break;
      case 0:
        result = &unk_101068D4;
        break;
      case 1:
        result = &unk_101068D8;
        break;
      case 2:
        result = &unk_101068DC;
        break;
      case 3:
        result = &unk_101068E0;
        break;
      case 5:
        v3 = &unk_101068E4;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 10106F9C: using guessed type void *off_10106F9C;

//----- (10051B90) --------------------------------------------------------
void *__cdecl sub_10051B90(unsigned __int8 a1, char a2, char a3)
{
  void *v3; // esi@1
  int v4; // eax@3
  void *result; // eax@4

  v3 = 0;
  if ( a1 >= 3u || (unsigned __int8)a2 >= 0x13u )
  {
    result = 0;
  }
  else
  {
    v4 = sub_10051A10(a2);
    switch ( a3 )
    {
      case 6:
        result = *(&off_1010704C + a1 + 16 * v4);
        break;
      case 0:
        result = *(&off_10107058 + a1 + 16 * v4);
        break;
      case 1:
        result = *(&off_10107064 + a1 + 16 * v4);
        break;
      case 2:
        result = *(&off_10107070 + a1 + 16 * v4);
        break;
      case 3:
        result = *(&off_1010707C + a1 + 16 * v4);
        break;
      case 5:
        v3 = &unk_101068E4;
        goto LABEL_10;
      default:
LABEL_10:
        result = v3;
        break;
    }
  }
  return result;
}
// 1010704C: using guessed type void *off_1010704C;
// 10107058: using guessed type void *off_10107058;
// 10107064: using guessed type void *off_10107064;
// 10107070: using guessed type void *off_10107070;
// 1010707C: using guessed type void *off_1010707C;

//----- (10051C60) --------------------------------------------------------
char sub_10051C60()
{
  return *(_BYTE *)(dword_10A09AC0 + 33316);
}
// 10A09AC0: using guessed type int dword_10A09AC0;

//----- (10051C70) --------------------------------------------------------
BOOL __fastcall sub_10051C70(int a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  return sub_10029700(6, 1, 27, 0, (int)&v2, 4) && v2 & 1;
}

//----- (10051CA0) --------------------------------------------------------
void *__cdecl sub_10051CA0(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_101078EC;
      break;
    case 0:
      result = &unk_101078F0;
      break;
    case 1:
      result = &unk_101078F4;
      break;
    case 2:
      result = &unk_10107900;
      break;
    case 3:
      result = &unk_101078FC;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10051CF0) --------------------------------------------------------
char sub_10051CF0()
{
  signed int v0; // esi@1
  char result; // al@11

  qmemcpy(dword_109D6AD8, &unk_101079B8, 0x5Cu);
  v0 = 23;
  if ( sub_10032850(0) == 1 )
  {
    dword_109D6B34 = 65569;
    dword_109D6B38 = 65910;
    dword_109D6B3C = 65909;
    dword_109D6B40 = 65912;
    dword_109D6B44 = 65914;
    dword_109D6B48 = 65913;
    dword_109D6B4C = 65578;
    dword_109D6B50 = 65852;
    dword_109D6B54 = 65908;
    dword_109D6B58 = 65898;
    v0 = 33;
  }
  if ( sub_10032850(7u) == 1 || sub_10032850(8u) == 1 )
    dword_109D6AD8[v0++] = 65635;
  if ( sub_10032340(0, 4u) || sub_10032340(1u, 4u) )
  {
    dword_109D6AD8[v0] = 65951;
    dword_109D6ADC[v0] = 65952;
    dword_109D6AE0[v0] = 65950;
    dword_109D6AE4[v0] = 65949;
    dword_109D6AE8[v0] = 65953;
    v0 += 5;
  }
  if ( sub_10032850(2u) == 1 )
  {
    dword_109D6AD8[v0] = 65906;
    dword_109D6ADC[v0] = 65905;
    dword_109D6AE0[v0] = 65907;
    dword_109D6AE4[v0] = 65912;
    dword_109D6AE8[v0] = 65914;
    dword_109D6AEC[v0] = 65913;
    dword_109D6AF0[v0] = 65578;
    dword_109D6AF4[v0] = 65569;
    dword_109D6AF8[v0] = 65944;
    dword_109D6AFC[v0] = 65945;
    dword_109D6B00[v0] = 65946;
    dword_109D6B04[v0] = 65947;
    dword_109D6B08[v0] = 65954;
    v0 += 13;
  }
  result = sub_100324A0(1);
  if ( result )
  {
    dword_109D6AD8[v0] = 65569;
    dword_109D6ADC[v0] = 65944;
    dword_109D6AE0[v0] = 65945;
    dword_109D6AE4[v0] = 65946;
    dword_109D6AE8[v0] = 65947;
    result = 122;
    dword_109D6AEC[v0] = 65954;
    dword_109D6AF0[v0] = 65912;
    dword_109D6AF4[v0] = 65914;
    dword_109D6AF8[v0] = 65913;
    dword_109D6AFC[v0] = 65578;
    v0 += 10;
  }
  LOWORD(dword_109D6AD8[v0]) = 904;
  BYTE2(dword_109D6AD8[v0]) = 3;
  return result;
}
// 109D6AD8: using guessed type int dword_109D6AD8[];
// 109D6ADC: using guessed type int dword_109D6ADC[];
// 109D6AE0: using guessed type int dword_109D6AE0[];
// 109D6AE4: using guessed type int dword_109D6AE4[];
// 109D6AE8: using guessed type int dword_109D6AE8[];
// 109D6AEC: using guessed type int dword_109D6AEC[];
// 109D6AF0: using guessed type int dword_109D6AF0[];
// 109D6AF4: using guessed type int dword_109D6AF4[];
// 109D6AF8: using guessed type int dword_109D6AF8[];
// 109D6AFC: using guessed type int dword_109D6AFC[];
// 109D6B00: using guessed type int dword_109D6B00[];
// 109D6B04: using guessed type int dword_109D6B04[];
// 109D6B08: using guessed type int dword_109D6B08[];
// 109D6B34: using guessed type int dword_109D6B34;
// 109D6B38: using guessed type int dword_109D6B38;
// 109D6B3C: using guessed type int dword_109D6B3C;
// 109D6B40: using guessed type int dword_109D6B40;
// 109D6B44: using guessed type int dword_109D6B44;
// 109D6B48: using guessed type int dword_109D6B48;
// 109D6B4C: using guessed type int dword_109D6B4C;
// 109D6B50: using guessed type int dword_109D6B50;
// 109D6B54: using guessed type int dword_109D6B54;
// 109D6B58: using guessed type int dword_109D6B58;

//----- (10051F80) --------------------------------------------------------
int *__cdecl sub_10051F80(char a1)
{
  int *result; // eax@2

  switch ( a1 )
  {
    case 6:
      result = (int *)&unk_101078EC;
      break;
    case 0:
      result = (int *)&unk_101079A8;
      break;
    case 1:
      result = (int *)&unk_101078F4;
      break;
    case 2:
      sub_10051CF0();
      result = dword_109D6AD8;
      break;
    case 3:
      result = (int *)&unk_10107AAC;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 109D6AD8: using guessed type int dword_109D6AD8[];

//----- (10051FE0) --------------------------------------------------------
void *__cdecl sub_10051FE0(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_10107AE8;
        break;
      case 0:
        result = &unk_10107AEC;
        break;
      case 1:
        result = &unk_10107AF0;
        break;
      case 2:
        result = &unk_10107B44;
        break;
      case 3:
        result = &unk_10107B68;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10052040) --------------------------------------------------------
int __cdecl sub_10052040(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x33u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1010BD4C + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_1010BD54 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_1010BD5C + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_1010BD64 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_1010BD6C + a1 + 11 * a2);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 189, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1010BD4C: using guessed type void *off_1010BD4C;
// 1010BD54: using guessed type void *off_1010BD54;
// 1010BD5C: using guessed type void *off_1010BD5C;
// 1010BD64: using guessed type void *off_1010BD64;
// 1010BD6C: using guessed type void *off_1010BD6C;

//----- (10052110) --------------------------------------------------------
int __cdecl sub_10052110(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
  unsigned __int8 v4; // cl@2
  int result; // eax@8
  int v6; // [sp-Ch] [bp-7Ch]@13
  char v7; // [sp-8h] [bp-78h]@13
  char v8; // [sp+8h] [bp-68h]@6

  if ( a1 >= 2u || (v4 = a2, a2 >= 0xAu) || a3 >= 4u )
  {
LABEL_22:
    result = 0;
  }
  else if ( a3 == 1 )
  {
    if ( !a2 )
    {
      _snprintf(&v8, 0x64u, "INVALID CONFIG: anlg_in chnl %d - format %d", 0, 1);
      sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 265, 0, &v8);
      v4 = 0;
    }
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_1010C610 + a1 + 10 * v4);
        break;
      case 0:
        result = (int)*(&off_1010C618 + a1 + 10 * v4);
        break;
      case 1:
        result = (int)*(&off_1010C620 + a1 + 10 * v4);
        break;
      case 2:
        result = (int)*(&off_1010C628 + a1 + 10 * v4);
        break;
      case 3:
        result = (int)*(&off_1010C630 + a1 + 10 * v4);
        break;
      default:
        v7 = 0;
        v6 = 292;
        goto LABEL_21;
    }
  }
  else
  {
    switch ( a4 )
    {
      case 6:
        result = (int)*(&off_1010C7A0 + a1 + 10 * a3);
        break;
      case 0:
        result = (int)*(&off_1010C7A8 + a1 + 10 * a3);
        break;
      case 1:
        result = (int)*(&off_1010C7B0 + a1 + 10 * a3);
        break;
      case 2:
        result = (int)*(&off_1010C7B8 + a1 + 10 * a3);
        break;
      case 3:
        result = (int)*(&off_1010C7C0 + a1 + 10 * a3);
        break;
      default:
        v7 = 0;
        v6 = 322;
LABEL_21:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", v6, v7, 0);
        goto LABEL_22;
    }
  }
  return result;
}
// 1010C610: using guessed type void *off_1010C610;
// 1010C618: using guessed type void *off_1010C618;
// 1010C620: using guessed type void *off_1010C620;
// 1010C628: using guessed type void *off_1010C628;
// 1010C630: using guessed type void *off_1010C630;
// 1010C7A0: using guessed type void *off_1010C7A0;
// 1010C7A8: using guessed type void *off_1010C7A8;
// 1010C7B0: using guessed type void *off_1010C7B0;
// 1010C7B8: using guessed type void *off_1010C7B8;
// 1010C7C0: using guessed type void *off_1010C7C0;

//----- (100523B0) --------------------------------------------------------
int __cdecl sub_100523B0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0xBu )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1010C840 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_1010C848 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_1010C850 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_1010C858 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_1010C860 + a1 + 10 * a2);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 407, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1010C840: using guessed type void *off_1010C840;
// 1010C848: using guessed type void *off_1010C848;
// 1010C850: using guessed type void *off_1010C850;
// 1010C858: using guessed type void *off_1010C858;
// 1010C860: using guessed type void *off_1010C860;

//----- (10052480) --------------------------------------------------------
int __cdecl sub_10052480(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 8u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1010C9FC + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_1010CA04 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_1010CA0C + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_1010CA14 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_1010CA1C + a1 + 11 * a2);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 606, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1010C9FC: using guessed type void *off_1010C9FC;
// 1010CA04: using guessed type void *off_1010CA04;
// 1010CA0C: using guessed type void *off_1010CA0C;
// 1010CA14: using guessed type void *off_1010CA14;
// 1010CA1C: using guessed type void *off_1010CA1C;

//----- (10052550) --------------------------------------------------------
int __cdecl sub_10052550(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 3u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1010CB58 + a1 + 10 * a2);
        break;
      case 0:
        result = (int)*(&off_1010CB60 + a1 + 10 * a2);
        break;
      case 1:
        result = (int)*(&off_1010CB68 + a1 + 10 * a2);
        break;
      case 2:
        result = (int)*(&off_1010CB70 + a1 + 10 * a2);
        break;
      case 3:
        result = (int)*(&off_1010CB78 + a1 + 10 * a2);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 689, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1010CB58: using guessed type void *off_1010CB58;
// 1010CB60: using guessed type void *off_1010CB60;
// 1010CB68: using guessed type void *off_1010CB68;
// 1010CB70: using guessed type void *off_1010CB70;
// 1010CB78: using guessed type void *off_1010CB78;

//----- (10052620) --------------------------------------------------------
int __cdecl sub_10052620(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1010CBD0 + a1);
        break;
      case 0:
        result = (int)*(&off_1010CBD8 + a1);
        break;
      case 1:
        result = (int)*(&off_1010CBE0 + a1);
        break;
      case 2:
        result = (int)*(&off_1010CBE8 + a1);
        break;
      case 3:
        result = (int)*(&off_1010CBF0 + a1);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 768, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 1010CBD0: using guessed type void *off_1010CBD0;
// 1010CBD8: using guessed type void *off_1010CBD8;
// 1010CBE0: using guessed type void *off_1010CBE0;
// 1010CBE8: using guessed type void *off_1010CBE8;
// 1010CBF0: using guessed type void *off_1010CBF0;

//----- (100526B0) --------------------------------------------------------
int __cdecl sub_100526B0(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1010CBF8 + a1);
        break;
      case 0:
        result = (int)*(&off_1010CC00 + a1);
        break;
      case 1:
        result = (int)*(&off_1010CC08 + a1);
        break;
      case 2:
        result = (int)*(&off_1010CC10 + a1);
        break;
      case 3:
        result = (int)*(&off_1010CC18 + a1);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 847, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 1010CBF8: using guessed type void *off_1010CBF8;
// 1010CC00: using guessed type void *off_1010CC00;
// 1010CC08: using guessed type void *off_1010CC08;
// 1010CC10: using guessed type void *off_1010CC10;
// 1010CC18: using guessed type void *off_1010CC18;

//----- (10052740) --------------------------------------------------------
int __cdecl sub_10052740(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1010CC20 + a1);
        break;
      case 0:
        result = (int)*(&off_1010CC28 + a1);
        break;
      case 1:
        result = (int)*(&off_1010CC30 + a1);
        break;
      case 2:
        result = (int)*(&off_1010CC38 + a1);
        break;
      case 3:
        result = (int)*(&off_1010CC40 + a1);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 927, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 1010CC20: using guessed type void *off_1010CC20;
// 1010CC28: using guessed type void *off_1010CC28;
// 1010CC30: using guessed type void *off_1010CC30;
// 1010CC38: using guessed type void *off_1010CC38;
// 1010CC40: using guessed type void *off_1010CC40;

//----- (100527D0) --------------------------------------------------------
int __cdecl sub_100527D0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x31u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1010CC4C + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_1010CC54 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_1010CC5C + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_1010CC64 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_1010CC6C + a1 + 11 * a2);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1118, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1010CC4C: using guessed type void *off_1010CC4C;
// 1010CC54: using guessed type void *off_1010CC54;
// 1010CC5C: using guessed type void *off_1010CC5C;
// 1010CC64: using guessed type void *off_1010CC64;
// 1010CC6C: using guessed type void *off_1010CC6C;

//----- (100528A0) --------------------------------------------------------
int __cdecl sub_100528A0(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 2u || a2 >= 0x1Du )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_1010D4BC + a1 + 11 * a2);
        break;
      case 0:
        result = (int)*(&off_1010D4C4 + a1 + 11 * a2);
        break;
      case 1:
        result = (int)*(&off_1010D4CC + a1 + 11 * a2);
        break;
      case 2:
        result = (int)*(&off_1010D4D4 + a1 + 11 * a2);
        break;
      case 3:
        result = (int)*(&off_1010D4DC + a1 + 11 * a2);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1308, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 1010D4BC: using guessed type void *off_1010D4BC;
// 1010D4C4: using guessed type void *off_1010D4C4;
// 1010D4CC: using guessed type void *off_1010D4CC;
// 1010D4D4: using guessed type void *off_1010D4D4;
// 1010D4DC: using guessed type void *off_1010D4DC;

//----- (10052970) --------------------------------------------------------
int __cdecl sub_10052970(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1010D9DC + a1);
        break;
      case 0:
        result = (int)*(&off_1010D9E4 + a1);
        break;
      case 1:
        result = (int)*(&off_1010D9EC + a1);
        break;
      case 2:
        result = (int)*(&off_1010D9F4 + a1);
        break;
      case 3:
        result = (int)*(&off_1010D9FC + a1);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1466, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 1010D9DC: using guessed type void *off_1010D9DC;
// 1010D9E4: using guessed type void *off_1010D9E4;
// 1010D9EC: using guessed type void *off_1010D9EC;
// 1010D9F4: using guessed type void *off_1010D9F4;
// 1010D9FC: using guessed type void *off_1010D9FC;

//----- (10052A00) --------------------------------------------------------
int __cdecl sub_10052A00(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1010DA04 + a1);
        break;
      case 0:
        result = (int)*(&off_1010DA0C + a1);
        break;
      case 1:
        result = (int)*(&off_1010DA14 + a1);
        break;
      case 2:
        result = (int)*(&off_1010DA1C + a1);
        break;
      case 3:
        result = (int)*(&off_1010DA24 + a1);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1545, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 1010DA04: using guessed type void *off_1010DA04;
// 1010DA0C: using guessed type void *off_1010DA0C;
// 1010DA14: using guessed type void *off_1010DA14;
// 1010DA1C: using guessed type void *off_1010DA1C;
// 1010DA24: using guessed type void *off_1010DA24;

//----- (10052A90) --------------------------------------------------------
int __cdecl sub_10052A90(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 2u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 8);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 16);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 32);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gia\\iop_gia_frmt_info_tbl.c", 1627, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (10052B30) --------------------------------------------------------
int __cdecl sub_10052B30(unsigned __int8 a1, char a2)
{
  return sub_10052A90((int)&off_1010DA54, a1, a2);
}
// 1010DA54: using guessed type void *off_1010DA54;

//----- (10052B50) --------------------------------------------------------
int __cdecl sub_10052B50(unsigned __int8 a1, char a2)
{
  return sub_10052A90((int)&off_1010DA2C, a1, a2);
}
// 1010DA2C: using guessed type void *off_1010DA2C;

//----- (10052B70) --------------------------------------------------------
char __cdecl sub_10052B70(unsigned __int16 a1, _BYTE *a2, _WORD *a3)
{
  char result; // al@4

  if ( a1 < 0x1D8u && a2 && a3 )
  {
    *a2 = byte_1010DB00[4 * a1];
    *a3 = word_1010DB02[2 * a1];
    result = 1;
  }
  else
  {
    sub_10028BC0("..\\lib\\adl\\iop_eau_data_tbl.c", 614, 0, 0);
    result = 0;
  }
  return result;
}
// 1010DB02: using guessed type __int16 word_1010DB02[];

//----- (10052BD0) --------------------------------------------------------
char __cdecl sub_10052BD0(char a1, __int16 a2, unsigned __int16 *a3)
{
  char result; // al@1
  int v4; // ecx@3
  unsigned __int16 v5; // si@5

  result = 0;
  if ( a3 )
  {
    *a3 = 0;
    while ( 1 )
    {
      v4 = 2 * *a3;
      if ( word_1010DB02[v4] == a2 && byte_1010DB00[v4 * 2] == a1 )
        break;
      v5 = *a3 + 1;
      *a3 = v5;
      if ( v5 >= 0x1D8u )
        return result;
    }
    result = 1;
  }
  return result;
}
// 1010DB02: using guessed type __int16 word_1010DB02[];

//----- (10052C30) --------------------------------------------------------
void *__cdecl sub_10052C30(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_1010E280;
        break;
      case 0:
        result = &unk_1010E284;
        break;
      case 1:
        result = &unk_1010E288;
        break;
      case 2:
        result = &unk_1010E310;
        break;
      case 3:
        result = &unk_1010E384;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10052C90) --------------------------------------------------------
int __cdecl sub_10052C90(unsigned __int8 a1, char a2)
{
  int result; // eax@1

  result = 0;
  if ( a2 >= 7 || a1 >= 2u )
  {
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_1010E464 + a1);
        break;
      case 0:
        result = (int)*(&off_1010E46C + a1);
        break;
      case 1:
        result = (int)*(&off_1010E474 + a1);
        break;
      case 2:
        result = (int)*(&off_1010E47C + a1);
        break;
      case 3:
        result = (int)*(&off_1010E484 + a1);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 1010E464: using guessed type void *off_1010E464;
// 1010E46C: using guessed type void *off_1010E46C;
// 1010E474: using guessed type void *off_1010E474;
// 1010E47C: using guessed type void *off_1010E47C;
// 1010E484: using guessed type void *off_1010E484;

//----- (10052D10) --------------------------------------------------------
int __cdecl sub_10052D10(unsigned __int8 a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 < 2u )
    result = dword_1010E48C[a1];
  return result;
}
// 1010E48C: using guessed type int dword_1010E48C[];

//----- (10052D30) --------------------------------------------------------
int __cdecl sub_10052D30(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x23u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_10110914 + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_10110920 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_1011092C + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_10110938 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_10110944 + a1 + 16 * a2);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 209, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 10110914: using guessed type void *off_10110914;
// 10110920: using guessed type void *off_10110920;
// 1011092C: using guessed type void *off_1011092C;
// 10110938: using guessed type void *off_10110938;
// 10110944: using guessed type void *off_10110944;

//----- (10052E00) --------------------------------------------------------
int __cdecl sub_10052E00(unsigned __int8 a1, char a2)
{
  int result; // eax@3

  if ( a1 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a2 )
    {
      case 6:
        result = (int)*(&off_10110898 + a1);
        break;
      case 0:
        result = (int)*(&off_101108A4 + a1);
        break;
      case 1:
        result = (int)*(&off_101108B0 + a1);
        break;
      case 2:
        result = (int)*(&off_101108BC + a1);
        break;
      case 3:
        result = (int)*(&off_101108C8 + a1);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 313, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}
// 10110898: using guessed type void *off_10110898;
// 101108A4: using guessed type void *off_101108A4;
// 101108B0: using guessed type void *off_101108B0;
// 101108BC: using guessed type void *off_101108BC;
// 101108C8: using guessed type void *off_101108C8;

//----- (10052E90) --------------------------------------------------------
int __cdecl sub_10052E90(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  int result; // eax@4

  if ( a1 >= 3u || a2 >= 0x21u )
  {
LABEL_10:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = (int)*(&off_101111D4 + a1 + 16 * a2);
        break;
      case 0:
        result = (int)*(&off_101111E0 + a1 + 16 * a2);
        break;
      case 1:
        result = (int)*(&off_101111EC + a1 + 16 * a2);
        break;
      case 2:
        result = (int)*(&off_101111F8 + a1 + 16 * a2);
        break;
      case 3:
        result = (int)*(&off_10111204 + a1 + 16 * a2);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 504, 0, 0);
        goto LABEL_10;
    }
  }
  return result;
}
// 101111D4: using guessed type void *off_101111D4;
// 101111E0: using guessed type void *off_101111E0;
// 101111EC: using guessed type void *off_101111EC;
// 101111F8: using guessed type void *off_101111F8;
// 10111204: using guessed type void *off_10111204;

//----- (10052F60) --------------------------------------------------------
int __cdecl sub_10052F60(int a1, unsigned __int8 a2, char a3)
{
  int result; // eax@3

  if ( a2 >= 3u )
  {
LABEL_9:
    result = 0;
  }
  else
  {
    switch ( a3 )
    {
      case 6:
        result = *(_DWORD *)(a1 + 4 * a2);
        break;
      case 0:
        result = *(_DWORD *)(a1 + 4 * a2 + 12);
        break;
      case 1:
        result = *(_DWORD *)(a1 + 4 * a2 + 24);
        break;
      case 2:
        result = *(_DWORD *)(a1 + 4 * a2 + 36);
        break;
      case 3:
        result = *(_DWORD *)(a1 + 4 * a2 + 48);
        break;
      default:
        sub_10028BC0("..\\lib\\acl\\iop\\gsd\\iop_gsd_frmt_info_tbl.c", 583, 0, 0);
        goto LABEL_9;
    }
  }
  return result;
}

//----- (10053000) --------------------------------------------------------
int __cdecl sub_10053000(unsigned __int8 a1, char a2)
{
  return sub_10052F60((int)&off_101108D4, a1, a2);
}
// 101108D4: using guessed type void *off_101108D4;

//----- (10053020) --------------------------------------------------------
void *__cdecl sub_10053020(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_10111A40;
      break;
    case 0:
      result = &unk_10111A44;
      break;
    case 1:
      result = &unk_10111C48;
      break;
    case 2:
      result = &unk_10111A4C;
      break;
    case 3:
      result = &unk_10111A50;
      break;
    case 5:
      result = &unk_10111A54;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10053080) --------------------------------------------------------
void *__cdecl sub_10053080(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_10111A58;
      break;
    case 0:
      result = &unk_10111A84;
      break;
    case 1:
      result = &unk_10111AA8;
      break;
    case 2:
      result = &unk_10111AD8;
      break;
    case 3:
      result = &unk_10111B50;
      break;
    case 5:
      result = &unk_10111A54;
      break;
    default:
      return result;
  }
  return result;
}

//----- (100530E0) --------------------------------------------------------
void *__cdecl sub_100530E0(char a1)
{
  void *result; // eax@1

  result = 0;
  switch ( a1 )
  {
    case 6:
      result = &unk_10111A40;
      break;
    case 0:
      result = &unk_10111C54;
      break;
    case 1:
      result = &unk_10111A48;
      break;
    case 2:
      result = &unk_10111C68;
      break;
    case 3:
      result = &unk_10111A50;
      break;
    case 5:
      result = &unk_10111A54;
      break;
    default:
      return result;
  }
  return result;
}

//----- (10053140) --------------------------------------------------------
int __cdecl sub_10053140(char a1, char a2)
{
  int result; // eax@1
  char v3; // cl@2

  result = 0;
  switch ( a1 )
  {
    case 3:
      v3 = 0;
      break;
    case 4:
      v3 = 1;
      break;
    case 5:
      v3 = 2;
      break;
    default:
      if ( a1 != 6 )
        return 0;
      v3 = 3;
      break;
  }
  switch ( a2 )
  {
    case 6:
      result = (int)*(&off_10111C78 + (unsigned __int8)v3);
      break;
    case 0:
      result = (int)*(&off_10111C88 + (unsigned __int8)v3);
      break;
    case 1:
      result = (int)*(&off_10111C98 + (unsigned __int8)v3);
      break;
    case 2:
      result = (int)*(&off_10111CA8 + (unsigned __int8)v3);
      break;
    case 3:
      result = (int)*(&off_10111CB8 + (unsigned __int8)v3);
      break;
    case 5:
      result = (int)*(&off_10111CC8 + (unsigned __int8)v3);
      break;
    default:
      return result;
  }
  return result;
}
// 10111C78: using guessed type void *off_10111C78;
// 10111C88: using guessed type void *off_10111C88;
// 10111C98: using guessed type void *off_10111C98;
// 10111CA8: using guessed type void *off_10111CA8;
// 10111CB8: using guessed type void *off_10111CB8;
// 10111CC8: using guessed type void *off_10111CC8;

//----- (100531E0) --------------------------------------------------------
void *__cdecl sub_100531E0(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_10111CD8;
        break;
      case 0:
        result = &unk_10111CDC;
        break;
      case 1:
        result = &unk_10111D10;
        break;
      case 2:
        result = &unk_10111D40;
        break;
      case 3:
        result = &unk_10111D80;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (10053240) --------------------------------------------------------
void *__cdecl sub_10053240(char a1)
{
  void *result; // eax@1

  result = 0;
  if ( a1 < 7 )
  {
    switch ( a1 )
    {
      case 6:
        result = &unk_10111DA8;
        break;
      case 0:
        result = &unk_10111DAC;
        break;
      case 1:
        result = &unk_10111DC8;
        break;
      case 2:
        result = &unk_10111E0C;
        break;
      case 3:
        result = &unk_10111E20;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (100532A0) --------------------------------------------------------
char __cdecl sub_100532A0(char a1)
{
  char result; // al@3

  if ( a1 == 20 )
  {
    result = 0;
  }
  else if ( a1 == 21 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100532C0) --------------------------------------------------------
signed int __usercall sub_100532C0@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi@1
  signed int result; // eax@1
  int v5; // esi@1
  unsigned __int16 v6; // bx@2
  unsigned __int16 v7; // ax@2
  unsigned int v8; // ebx@2
  unsigned __int16 v9; // dx@2
  int v10; // edx@2
  int v11; // eax@2
  int v12; // esi@2
  unsigned int v13; // edx@2
  int v14; // eax@2
  int v15; // esi@2
  unsigned int v16; // ST2C_4@4
  unsigned int v17; // ST30_4@4
  unsigned int v18; // ST34_4@4
  unsigned int v19; // esi@4
  unsigned int v20; // ST2C_4@5
  unsigned int v21; // ST30_4@5
  unsigned int v22; // ST34_4@5
  unsigned int v23; // esi@5
  unsigned int v24; // ST30_4@6
  unsigned int v25; // ST34_4@6
  unsigned int v26; // edx@6
  unsigned int v27; // esi@6
  __int16 v28; // ST38_2@6
  unsigned int v29; // ST1C_4@6
  unsigned int v30; // ST20_4@6
  unsigned int v31; // ST24_4@6
  unsigned int v32; // esi@6
  unsigned int v33; // edx@6
  unsigned int v34; // ST30_4@6
  unsigned int v35; // ST34_4@6
  unsigned int v36; // esi@6
  unsigned int v37; // ST1C_4@6
  unsigned int v38; // ST20_4@6
  unsigned int v39; // ST24_4@6
  unsigned int v40; // esi@6
  unsigned int v41; // ST30_4@6
  unsigned int v42; // edx@6
  unsigned int v43; // ST34_4@6
  unsigned int v44; // esi@6
  unsigned int v45; // ST1C_4@6
  unsigned int v46; // ST20_4@6
  unsigned int v47; // ST24_4@6
  unsigned int v48; // esi@6
  unsigned int v49; // edx@6
  unsigned int v50; // ST30_4@6
  unsigned int v51; // ST34_4@6
  unsigned int v52; // esi@6
  unsigned int v53; // ST1C_4@6
  unsigned int v54; // ST20_4@6
  unsigned int v55; // ST24_4@6
  unsigned int v56; // ST28_4@6
  unsigned int v57; // ST30_4@6
  unsigned int v58; // edx@6
  unsigned int v59; // ST34_4@6
  unsigned int v60; // ST38_4@6
  unsigned int v61; // ST20_4@6
  unsigned int v62; // ST24_4@6
  unsigned int v63; // ebx@6
  unsigned int v64; // eax@6
  unsigned int v65; // [sp+14h] [bp-20h]@2
  unsigned int v66; // [sp+18h] [bp-1Ch]@2
  unsigned int v67; // [sp+1Ch] [bp-18h]@2
  unsigned int v68; // [sp+20h] [bp-14h]@2

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( *(_BYTE *)(v3 + 260) & 1 )
  {
    BYTE1(result) = *(_BYTE *)(a2 + 3);
    HIBYTE(v6) = *(_BYTE *)(a2 + 7);
    LOBYTE(result) = *(_BYTE *)(a2 + 2);
    LOBYTE(v6) = *(_BYTE *)(a2 + 6);
    v65 = *(_DWORD *)v3 ^ (*(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (result << 8)) << 8));
    HIBYTE(v7) = *(_BYTE *)(a2 + 11);
    v8 = *(_DWORD *)(v3 + 4) ^ (*(_BYTE *)(a2 + 4) | ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8));
    LOBYTE(v7) = *(_BYTE *)(a2 + 10);
    v66 = v8;
    HIBYTE(v9) = *(_BYTE *)(a2 + 15);
    v67 = *(_DWORD *)(v3 + 8) ^ (*(_BYTE *)(v5 + 8) | ((*(_BYTE *)(v5 + 9) | (v7 << 8)) << 8));
    LOBYTE(v9) = *(_BYTE *)(v5 + 14);
    v10 = *(_BYTE *)(v5 + 13) | (v9 << 8);
    v11 = *(_BYTE *)(v5 + 12);
    v12 = *(_DWORD *)(v3 + 256);
    v13 = *(_DWORD *)(v3 + 12) ^ (v11 | (v10 << 8));
    v14 = v3 + 16 * (v12 - 9);
    v15 = v12 - 12;
    v68 = v13;
    if ( v15 )
    {
      if ( v15 != 2 )
      {
LABEL_6:
        v24 = *(_DWORD *)(v14 + 4) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v66] ^ *(_DWORD *)&dword_10117570[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v68 >> 16)];
        v25 = *(_DWORD *)(v14 + 8) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v66 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v68)];
        v26 = *(_DWORD *)v14 ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v13 >> 24)];
        v27 = *(_DWORD *)(v14 + 12) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v66 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v67 >> 24)];
        v28 = *(_WORD *)(v14 + 12) ^ dword_10116970[2 * (unsigned __int8)v68] ^ dword_10116D70[2 * BYTE1(v65)] ^ dword_10117170[2 * (unsigned __int8)(v66 >> 16)] ^ dword_10117570[2 * (v67 >> 24)];
        v29 = *(_DWORD *)(v14 + 16) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v26] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v24)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v25 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v27 >> 24)];
        v30 = *(_DWORD *)(v14 + 20) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v24] ^ *(_DWORD *)&dword_10117570[2 * (v26 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v25)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v27 >> 16)];
        v31 = *(_DWORD *)(v14 + 24) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v25] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v26 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v24 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * HIBYTE(v28)];
        v32 = *(_DWORD *)(v14 + 28) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v28] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v26)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v24 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v25 >> 24)];
        v33 = *(_DWORD *)(v14 + 32) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v29] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v30)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v31 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v32 >> 24)];
        v34 = *(_DWORD *)(v14 + 36) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v30] ^ *(_DWORD *)&dword_10117570[2 * (v29 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v31)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v32 >> 16)];
        v35 = *(_DWORD *)(v14 + 40) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v31] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v29 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v30 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v32)];
        v36 = *(_DWORD *)(v14 + 44) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v32] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v29)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v30 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v31 >> 24)];
        v37 = *(_DWORD *)(v14 + 48) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v33] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v34)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v35 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v36 >> 24)];
        v38 = *(_DWORD *)(v14 + 52) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v34] ^ *(_DWORD *)&dword_10117570[2 * (v33 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v35)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v36 >> 16)];
        v39 = *(_DWORD *)(v14 + 56) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v35] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v33 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v34 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v36)];
        v40 = *(_DWORD *)(v14 + 60) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v36] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v33)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v34 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v35 >> 24)];
        v41 = *(_DWORD *)(v14 + 68) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v38] ^ *(_DWORD *)&dword_10117570[2 * (v37 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v39)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v40 >> 16)];
        v42 = *(_DWORD *)(v14 + 64) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v37] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v38)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v39 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v40 >> 24)];
        v43 = *(_DWORD *)(v14 + 72) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v39] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v37 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v38 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v40)];
        v44 = *(_DWORD *)(v14 + 76) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v40] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v37)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v38 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v39 >> 24)];
        v45 = *(_DWORD *)(v14 + 80) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v42] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v41)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v43 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v44 >> 24)];
        v46 = *(_DWORD *)(v14 + 84) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v41] ^ *(_DWORD *)&dword_10117570[2 * (v42 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v43)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v44 >> 16)];
        v47 = *(_DWORD *)(v14 + 88) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v43] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v42 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v41 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v44)];
        v48 = *(_DWORD *)(v14 + 92) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v44] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v42)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v41 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v43 >> 24)];
        v49 = *(_DWORD *)(v14 + 96) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v45] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v46)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v47 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v48 >> 24)];
        v50 = *(_DWORD *)(v14 + 100) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v46] ^ *(_DWORD *)&dword_10117570[2 * (v45 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v47)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v48 >> 16)];
        v51 = *(_DWORD *)(v14 + 104) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v47] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v45 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v46 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v48)];
        v52 = *(_DWORD *)(v14 + 108) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v48] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v45)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v46 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v47 >> 24)];
        v53 = *(_DWORD *)(v14 + 112) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v49] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v50)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v51 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v52 >> 24)];
        v54 = *(_DWORD *)(v14 + 116) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v50] ^ *(_DWORD *)&dword_10117570[2 * (v49 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v51)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v52 >> 16)];
        v55 = *(_DWORD *)(v14 + 120) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v51] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v49 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v50 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v52)];
        v56 = *(_DWORD *)(v14 + 124) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v52] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v49)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v50 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v51 >> 24)];
        v57 = *(_DWORD *)(v14 + 132) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v54] ^ *(_DWORD *)&dword_10117570[2 * (v53 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v55)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v56 >> 16)];
        v58 = *(_DWORD *)(v14 + 128) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v53] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v54)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v55 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v56 >> 24)];
        v59 = *(_DWORD *)(v14 + 136) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v55] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v53 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v54 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v56)];
        v60 = *(_DWORD *)(v14 + 140) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v56] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v53)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v54 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v55 >> 24)];
        v61 = *(_DWORD *)(v14 + 148) ^ dword_10117970[(unsigned __int8)v57] ^ dword_10118570[v58 >> 24] ^ dword_10117D70[BYTE1(v59)] ^ dword_10118170[(unsigned __int8)(v60 >> 16)];
        v62 = *(_DWORD *)(v14 + 152) ^ dword_10117970[(unsigned __int8)v59] ^ dword_10118170[(unsigned __int8)(v58 >> 16)] ^ dword_10118570[v57 >> 24] ^ dword_10117D70[BYTE1(v60)];
        v63 = *(_DWORD *)(v14 + 156) ^ dword_10117970[(unsigned __int8)v60] ^ dword_10117D70[BYTE1(v58)] ^ dword_10118170[(unsigned __int8)(v57 >> 16)] ^ dword_10118570[v59 >> 24];
        v64 = *(_DWORD *)(v14 + 144) ^ dword_10117970[(unsigned __int8)v58] ^ dword_10117D70[BYTE1(v57)] ^ dword_10118170[(unsigned __int8)(v59 >> 16)] ^ dword_10118570[v60 >> 24];
        *(_BYTE *)(a3 + 1) = BYTE1(v64);
        *(_BYTE *)a3 = v64;
        *(_BYTE *)(a3 + 2) = v64 >> 16;
        *(_BYTE *)(a3 + 3) = BYTE3(v64);
        *(_BYTE *)(a3 + 5) = BYTE1(v61);
        *(_BYTE *)(a3 + 4) = v61;
        *(_BYTE *)(a3 + 7) = BYTE3(v61);
        *(_BYTE *)(a3 + 6) = v61 >> 16;
        *(_BYTE *)(a3 + 9) = BYTE1(v62);
        *(_BYTE *)(a3 + 8) = v62;
        *(_BYTE *)(a3 + 11) = BYTE3(v62);
        *(_BYTE *)(a3 + 10) = v62 >> 16;
        *(_BYTE *)(a3 + 12) = v63;
        *(_BYTE *)(a3 + 13) = BYTE1(v63);
        *(_BYTE *)(a3 + 15) = BYTE3(v63);
        *(_BYTE *)(a3 + 14) = v63 >> 16;
        return 1;
      }
      v16 = *(_DWORD *)(v14 - 64) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v13 >> 24)];
      v17 = *(_DWORD *)(v14 - 60) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_10117570[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v13 >> 16)];
      v18 = *(_DWORD *)(v14 - 56) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v68)];
      v19 = *(_DWORD *)(v14 - 52) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v13] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v67 >> 24)];
      v8 = *(_DWORD *)(v14 - 44) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v17] ^ *(_DWORD *)&dword_10117570[2 * (v16 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v18)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v19 >> 16)];
      v67 = *(_DWORD *)(v14 - 40) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v18] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v16 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v17 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v19)];
      v65 = *(_DWORD *)(v14 - 48) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v16] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v17)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v18 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v19 >> 24)];
      v13 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v18 >> 24)];
      v68 = *(_DWORD *)(v14 - 36) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v19] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v16)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v17 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v18 >> 24)];
    }
    v20 = *(_DWORD *)(v14 - 32) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v65] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v8)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v67 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v13 >> 24)];
    v21 = *(_DWORD *)(v14 - 28) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v8] ^ *(_DWORD *)&dword_10117570[2 * (v65 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v67)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v68 >> 16)];
    v22 = *(_DWORD *)(v14 - 24) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v67] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v65 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v8 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v68)];
    v23 = *(_DWORD *)(v14 - 20) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v68] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v65)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v8 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v67 >> 24)];
    v8 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_10117570[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v23 >> 16)];
    v67 = *(_DWORD *)(v14 - 8) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v22] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v20 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v21 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v23)];
    v65 = *(_DWORD *)(v14 - 16) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v20] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v21)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v22 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v23 >> 24)];
    v66 = *(_DWORD *)(v14 - 12) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v21] ^ *(_DWORD *)&dword_10117570[2 * (v20 >> 24)] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v22)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v23 >> 16)];
    v13 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v22 >> 24)];
    v68 = *(_DWORD *)(v14 - 4) ^ *(_DWORD *)&dword_10116970[2 * (unsigned __int8)v23] ^ *(_DWORD *)&dword_10116D70[2 * BYTE1(v20)] ^ *(_DWORD *)&dword_10117170[2 * (unsigned __int8)(v21 >> 16)] ^ *(_DWORD *)&dword_10117570[2 * (v22 >> 24)];
    goto LABEL_6;
  }
  return result;
}
// 10117970: using guessed type int dword_10117970[];
// 10117D70: using guessed type int dword_10117D70[];
// 10118170: using guessed type int dword_10118170[];
// 10118570: using guessed type int dword_10118570[];

//----- (10054370) --------------------------------------------------------
int __usercall sub_10054370@<eax>(int a1@<esi>, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // edi@1
  unsigned int v5; // eax@3
  bool v6; // zf@4

  result = *(_DWORD *)(a1 + 456);
  v4 = 0;
  if ( a3 )
  {
    do
    {
      if ( result == 16 )
      {
        v5 = 0;
        do
        {
          v6 = (*(_BYTE *)(v5 + a1))++ == -1;
          if ( !v6 )
            break;
          ++v5;
        }
        while ( v5 < 8 );
        sub_100532C0(a1 + 32, a1, a1 + 16);
        result = 0;
      }
      *(_BYTE *)(v4++ + a2) ^= *(_BYTE *)(a1 + 16 + result++);
    }
    while ( v4 < a3 );
  }
  *(_DWORD *)(a1 + 456) = result;
  return result;
}

//----- (100543D0) --------------------------------------------------------
signed int __usercall sub_100543D0@<eax>(int a1@<eax>, int a2, int a3)
{
  int v3; // ebp@1
  unsigned __int16 v4; // dx@1
  int v5; // edx@1
  unsigned __int16 v6; // cx@1
  int v7; // esi@1
  int v8; // edi@1
  unsigned int v9; // ecx@1
  unsigned __int16 v10; // dx@2
  int v11; // edx@2
  int v12; // ebx@2
  int v13; // edx@3
  int v14; // ST20_4@3
  int v15; // edx@3
  int v16; // ST24_4@3
  int v17; // edx@3
  int v18; // ST28_4@3
  unsigned int v19; // edx@3
  int v20; // ebp@3
  int v21; // esi@3
  int v22; // edi@3
  unsigned int v23; // ecx@3
  int v24; // ST20_4@3
  int v25; // ebx@3
  unsigned int v26; // edx@3
  int v27; // ST28_4@3
  int v28; // ebp@3
  int v29; // esi@3
  int v30; // edi@3
  unsigned int v31; // ecx@3
  int v32; // ST10_4@3
  int v33; // ebx@3
  int v34; // ebp@3
  unsigned int v35; // edx@3
  int v36; // ST28_4@3
  int v37; // ST24_4@3
  int v38; // ebp@3
  int v39; // esi@3
  int v40; // edi@3
  unsigned int v41; // ecx@3
  int v42; // ebx@3
  unsigned int v43; // edx@3
  int v44; // ebp@3
  int v45; // esi@3
  int v46; // edi@3
  unsigned int v47; // ecx@3
  int v48; // ST10_4@3
  int v49; // ST20_4@3
  int v50; // ebp@3
  int v51; // ebx@3
  unsigned int v52; // edx@3
  int v53; // ST28_4@3
  int v54; // ST24_4@3
  int v55; // ebp@3
  int v56; // esi@3
  int v57; // edi@3
  unsigned int v58; // ecx@3
  int v59; // ebx@3
  unsigned int v60; // edx@3
  int v61; // ST28_4@3
  int v62; // ST24_4@3
  int v63; // ebp@3
  int v64; // esi@3
  int v65; // edi@3
  unsigned int v66; // ecx@3
  int v67; // ST10_4@3
  int v68; // ebx@3
  unsigned int v69; // edx@3
  int v70; // ebp@3
  int v71; // ebp@3
  int v72; // esi@3
  int v73; // edi@3
  signed int result; // eax@3
  int v75; // edx@4
  int v76; // ST20_4@4
  unsigned int v77; // edx@4
  int v78; // ebp@4
  int v79; // esi@4
  int v80; // edi@4
  int v81; // ecx@4
  unsigned int v82; // edx@4
  int v83; // ST20_4@4
  int v84; // ebp@4
  int v85; // esi@4
  int v86; // edi@4
  int v87; // ecx@4
  int v88; // ebx@4
  unsigned int v89; // edx@4
  int v90; // ebp@4
  int v91; // esi@4
  int v92; // edi@4
  int v93; // ecx@4
  unsigned int v94; // edx@4
  int v95; // ST20_4@4
  int v96; // ebp@4
  int v97; // esi@4
  int v98; // edi@4
  int v99; // ecx@4
  unsigned int v100; // edx@4
  int v101; // ST20_4@4
  int v102; // ST10_4@4
  int v103; // ebp@4
  int v104; // esi@4
  int v105; // edi@4
  int v106; // ST10_4@4
  int v107; // ecx@4
  unsigned int v108; // edx@4
  int v109; // ST20_4@4
  int v110; // ebp@4
  int v111; // esi@4
  int v112; // edi@4
  int v113; // ecx@4
  unsigned int v114; // edx@4
  int v115; // ST20_4@4
  int v116; // ebp@4
  int v117; // esi@4
  int v118; // edi@4
  int v119; // ecx@4
  unsigned int v120; // edx@4
  int v121; // ST10_4@4
  int v122; // ebp@4
  int v123; // ebp@4
  int v124; // esi@4
  int v125; // edi@4
  int v126; // ebp@5
  int v127; // esi@5
  int v128; // edi@5
  unsigned int v129; // ecx@5
  int v130; // edx@5
  int v131; // esi@5
  int v132; // edi@5
  unsigned int v133; // ecx@5
  int v134; // ebp@5
  int v135; // esi@5
  int v136; // edi@5
  unsigned int v137; // ecx@5
  int v138; // edx@5
  int v139; // esi@5
  int v140; // edi@5
  unsigned int v141; // ecx@5
  int v142; // ebp@5
  int v143; // esi@5
  int v144; // edi@5
  unsigned int v145; // ecx@5
  int v146; // edx@5
  int v147; // esi@5
  int v148; // edi@5
  unsigned int v149; // ecx@5
  int v150; // ebp@5
  int v151; // esi@5
  int v152; // edi@5
  unsigned int v153; // ecx@5
  int v154; // edx@5
  int v155; // esi@5
  int v156; // edi@5
  unsigned int v157; // ecx@5
  int v158; // ebp@5
  int v159; // esi@5
  int v160; // edi@5
  unsigned int v161; // ecx@5
  int v162; // edx@5
  int v163; // edx@5
  int v164; // esi@5
  int v165; // edi@5
  int v166; // [sp+10h] [bp-20h]@1

  *(_DWORD *)(a1 + 260) = 17;
  v3 = a2;
  HIBYTE(v4) = *(_BYTE *)(a2 + 3);
  LOBYTE(v4) = *(_BYTE *)(a2 + 2);
  v5 = *(_BYTE *)a2 | ((*(_BYTE *)(a2 + 1) | (v4 << 8)) << 8);
  *(_DWORD *)a1 = v5;
  HIBYTE(v6) = *(_BYTE *)(a2 + 7);
  v166 = v5;
  LOBYTE(v6) = *(_BYTE *)(a2 + 6);
  v7 = ((*(_BYTE *)(a2 + 5) | (v6 << 8)) << 8) | *(_BYTE *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v7;
  HIBYTE(v6) = *(_BYTE *)(a2 + 11);
  LOBYTE(v6) = *(_BYTE *)(a2 + 10);
  v8 = ((*(_BYTE *)(v3 + 9) | (v6 << 8)) << 8) | *(_BYTE *)(v3 + 8);
  *(_DWORD *)(a1 + 8) = v8;
  HIBYTE(v6) = *(_BYTE *)(a2 + 15);
  LOBYTE(v6) = *(_BYTE *)(a2 + 14);
  v9 = *(_BYTE *)(v3 + 12) | ((*(_BYTE *)(v3 + 13) | (v6 << 8)) << 8);
  *(_DWORD *)(a1 + 12) = v9;
  if ( a3 == 16 )
  {
    v126 = v5 ^ dword_10118570[(unsigned __int8)v9] ^ dword_10117970[BYTE1(v9)] ^ dword_10117D70[(unsigned __int8)(v9 >> 16)] ^ dword_10118170[v9 >> 24] ^ 1;
    v127 = v126 ^ v7;
    *(_DWORD *)(a1 + 16) = v126;
    *(_DWORD *)(a1 + 20) = v127;
    v128 = v127 ^ v8;
    *(_DWORD *)(a1 + 24) = v128;
    v129 = v128 ^ v9;
    *(_DWORD *)(a1 + 28) = v129;
    v130 = v126 ^ dword_10118570[(unsigned __int8)v129] ^ dword_10117970[BYTE1(v129)] ^ dword_10117D70[(unsigned __int8)(v129 >> 16)] ^ dword_10118170[v129 >> 24] ^ 2;
    v131 = v130 ^ v127;
    *(_DWORD *)(a1 + 32) = v130;
    *(_DWORD *)(a1 + 36) = v131;
    v132 = v131 ^ v128;
    *(_DWORD *)(a1 + 40) = v132;
    v133 = v132 ^ v129;
    *(_DWORD *)(a1 + 44) = v133;
    v134 = v130 ^ dword_10118570[(unsigned __int8)v133] ^ dword_10117970[BYTE1(v133)] ^ dword_10117D70[(unsigned __int8)(v133 >> 16)] ^ dword_10118170[v133 >> 24] ^ 4;
    v135 = v134 ^ v131;
    v136 = v135 ^ v132;
    v137 = v136 ^ v133;
    *(_DWORD *)(a1 + 48) = v134;
    *(_DWORD *)(a1 + 52) = v135;
    *(_DWORD *)(a1 + 56) = v136;
    *(_DWORD *)(a1 + 60) = v137;
    v138 = v134 ^ dword_10118570[(unsigned __int8)v137] ^ dword_10117970[BYTE1(v137)] ^ dword_10117D70[(unsigned __int8)(v137 >> 16)] ^ dword_10118170[v137 >> 24] ^ 8;
    *(_DWORD *)(a1 + 64) = v138;
    v139 = v138 ^ v135;
    *(_DWORD *)(a1 + 68) = v139;
    v140 = v139 ^ v136;
    *(_DWORD *)(a1 + 72) = v140;
    v141 = v140 ^ v137;
    *(_DWORD *)(a1 + 76) = v141;
    v142 = v138 ^ dword_10118570[(unsigned __int8)v141] ^ dword_10117970[BYTE1(v141)] ^ dword_10117D70[(unsigned __int8)(v141 >> 16)] ^ dword_10118170[v141 >> 24] ^ 0x10;
    v143 = v142 ^ v139;
    v144 = v143 ^ v140;
    v145 = v144 ^ v141;
    *(_DWORD *)(a1 + 80) = v142;
    *(_DWORD *)(a1 + 84) = v143;
    *(_DWORD *)(a1 + 88) = v144;
    *(_DWORD *)(a1 + 92) = v145;
    v146 = v142 ^ dword_10118570[(unsigned __int8)v145] ^ dword_10117970[BYTE1(v145)] ^ dword_10117D70[(unsigned __int8)(v145 >> 16)] ^ dword_10118170[v145 >> 24] ^ 0x20;
    v147 = v146 ^ v143;
    v148 = v147 ^ v144;
    v149 = v148 ^ v145;
    *(_DWORD *)(a1 + 100) = v147;
    *(_DWORD *)(a1 + 104) = v148;
    *(_DWORD *)(a1 + 108) = v149;
    *(_DWORD *)(a1 + 96) = v146;
    v150 = v146 ^ dword_10118570[(unsigned __int8)v149] ^ dword_10117970[BYTE1(v149)] ^ dword_10117D70[(unsigned __int8)(v149 >> 16)] ^ dword_10118170[v149 >> 24] ^ 0x40;
    v151 = v150 ^ v147;
    v152 = v151 ^ v148;
    v153 = v152 ^ v149;
    *(_DWORD *)(a1 + 112) = v150;
    *(_DWORD *)(a1 + 116) = v151;
    *(_DWORD *)(a1 + 120) = v152;
    *(_DWORD *)(a1 + 124) = v153;
    v154 = v150 ^ dword_10118570[(unsigned __int8)v153] ^ dword_10117970[BYTE1(v153)] ^ dword_10117D70[(unsigned __int8)(v153 >> 16)] ^ dword_10118170[v153 >> 24] ^ 0x80;
    v155 = v154 ^ v151;
    *(_DWORD *)(a1 + 128) = v154;
    *(_DWORD *)(a1 + 132) = v155;
    v156 = v155 ^ v152;
    *(_DWORD *)(a1 + 136) = v156;
    v157 = v156 ^ v153;
    *(_DWORD *)(a1 + 140) = v157;
    v158 = v154 ^ dword_10118570[(unsigned __int8)v157] ^ dword_10117970[BYTE1(v157)] ^ dword_10117D70[(unsigned __int8)(v157 >> 16)] ^ dword_10118170[v157 >> 24] ^ 0x1B;
    v159 = v158 ^ v155;
    v160 = v159 ^ v156;
    v161 = v160 ^ v157;
    *(_DWORD *)(a1 + 148) = v159;
    *(_DWORD *)(a1 + 152) = v160;
    *(_DWORD *)(a1 + 144) = v158;
    *(_DWORD *)(a1 + 156) = v161;
    v162 = dword_10118570[(unsigned __int8)v161] ^ dword_10117970[BYTE1(v161)] ^ dword_10117D70[(unsigned __int8)(v161 >> 16)] ^ dword_10118170[v161 >> 24];
    *(_DWORD *)(a1 + 256) = 10;
    v163 = v158 ^ v162 ^ 0x36;
    v164 = v163 ^ v159;
    v165 = v164 ^ v160;
    *(_DWORD *)(a1 + 168) = v165;
    *(_DWORD *)(a1 + 164) = v164;
    *(_DWORD *)(a1 + 160) = v163;
    *(_DWORD *)(a1 + 172) = v165 ^ v161;
    result = 1;
  }
  else
  {
    HIBYTE(v10) = *(_BYTE *)(a2 + 19);
    LOBYTE(v10) = *(_BYTE *)(a2 + 18);
    v11 = v10 << 8;
    v12 = *(_BYTE *)(a2 + 17);
    if ( a3 == 24 )
    {
      v75 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v75;
      v76 = v75;
      BYTE1(v75) = *(_BYTE *)(a2 + 23);
      LOBYTE(v75) = *(_BYTE *)(a2 + 22);
      v77 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v75 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v77;
      v78 = v166 ^ dword_10118570[(unsigned __int8)v77] ^ dword_10117970[BYTE1(v77)] ^ dword_10117D70[(unsigned __int8)(v77 >> 16)] ^ dword_10118170[v77 >> 24] ^ 1;
      v79 = v78 ^ v7;
      v80 = v79 ^ v8;
      v81 = v80 ^ v9;
      *(_DWORD *)(a1 + 40) = v81 ^ v76;
      v82 = v81 ^ v76 ^ v77;
      v83 = v81 ^ v76;
      *(_DWORD *)(a1 + 36) = v81;
      *(_DWORD *)(a1 + 24) = v78;
      *(_DWORD *)(a1 + 28) = v79;
      *(_DWORD *)(a1 + 32) = v80;
      *(_DWORD *)(a1 + 44) = v82;
      v84 = v78 ^ dword_10118570[(unsigned __int8)v82] ^ dword_10117970[BYTE1(v82)] ^ dword_10117D70[(unsigned __int8)(v82 >> 16)] ^ dword_10118170[v82 >> 24] ^ 2;
      v85 = v84 ^ v79;
      v86 = v85 ^ v80;
      v87 = v86 ^ v81;
      v89 = v87 ^ v83 ^ v82;
      v88 = v87 ^ v83;
      *(_DWORD *)(a1 + 64) = v87 ^ v83;
      *(_DWORD *)(a1 + 48) = v84;
      *(_DWORD *)(a1 + 52) = v85;
      *(_DWORD *)(a1 + 56) = v86;
      *(_DWORD *)(a1 + 60) = v87;
      *(_DWORD *)(a1 + 68) = v89;
      v90 = v84 ^ dword_10118570[(unsigned __int8)v89] ^ dword_10117970[BYTE1(v89)] ^ dword_10117D70[(unsigned __int8)(v89 >> 16)] ^ dword_10118170[v89 >> 24] ^ 4;
      v91 = v90 ^ v85;
      v92 = v91 ^ v86;
      v93 = v92 ^ v87;
      *(_DWORD *)(a1 + 88) = v93 ^ v88;
      v94 = v93 ^ v88 ^ v89;
      v95 = v93 ^ v88;
      *(_DWORD *)(a1 + 84) = v93;
      *(_DWORD *)(a1 + 72) = v90;
      *(_DWORD *)(a1 + 76) = v91;
      *(_DWORD *)(a1 + 80) = v92;
      *(_DWORD *)(a1 + 92) = v94;
      v96 = v90 ^ dword_10118570[(unsigned __int8)v94] ^ dword_10117970[BYTE1(v94)] ^ dword_10117D70[(unsigned __int8)(v94 >> 16)] ^ dword_10118170[v94 >> 24] ^ 8;
      v97 = v96 ^ v91;
      v98 = v97 ^ v92;
      v99 = v98 ^ v93;
      *(_DWORD *)(a1 + 112) = v99 ^ v95;
      v100 = v99 ^ v95 ^ v94;
      v101 = v99 ^ v95;
      *(_DWORD *)(a1 + 108) = v99;
      v102 = v96;
      *(_DWORD *)(a1 + 96) = v96;
      *(_DWORD *)(a1 + 100) = v97;
      *(_DWORD *)(a1 + 104) = v98;
      *(_DWORD *)(a1 + 116) = v100;
      v103 = v96 ^ dword_10118570[(unsigned __int8)v100] ^ dword_10117970[BYTE1(v100)] ^ dword_10117D70[(unsigned __int8)(v100 >> 16)] ^ dword_10118170[v100 >> 24] ^ 0x10;
      v104 = v103 ^ v97;
      v105 = v104 ^ v98;
      v106 = v102 ^ dword_10118570[(unsigned __int8)v100] ^ dword_10117970[BYTE1(v100)] ^ dword_10117D70[(unsigned __int8)(v100 >> 16)] ^ dword_10118170[v100 >> 24] ^ 0x10;
      *(_DWORD *)(a1 + 120) = v103;
      *(_DWORD *)(a1 + 124) = v104;
      *(_DWORD *)(a1 + 128) = v105;
      v107 = v105 ^ v99;
      *(_DWORD *)(a1 + 136) = v107 ^ v101;
      v108 = v107 ^ v101 ^ v100;
      v109 = v107 ^ v101;
      *(_DWORD *)(a1 + 132) = v107;
      *(_DWORD *)(a1 + 140) = v108;
      v110 = v106 ^ dword_10118570[(unsigned __int8)v108] ^ dword_10117970[BYTE1(v108)] ^ dword_10117D70[(unsigned __int8)(v108 >> 16)] ^ dword_10118170[v108 >> 24] ^ 0x20;
      v111 = v110 ^ v104;
      v112 = v111 ^ v105;
      v113 = v112 ^ v107;
      *(_DWORD *)(a1 + 160) = v113 ^ v109;
      v114 = v113 ^ v109 ^ v108;
      v115 = v113 ^ v109;
      *(_DWORD *)(a1 + 156) = v113;
      *(_DWORD *)(a1 + 144) = v110;
      *(_DWORD *)(a1 + 148) = v111;
      *(_DWORD *)(a1 + 152) = v112;
      *(_DWORD *)(a1 + 164) = v114;
      v116 = v110 ^ dword_10118570[(unsigned __int8)v114] ^ dword_10117970[BYTE1(v114)] ^ dword_10117D70[(unsigned __int8)(v114 >> 16)] ^ dword_10118170[v114 >> 24] ^ 0x40;
      v117 = v116 ^ v111;
      v118 = v117 ^ v112;
      v119 = v118 ^ v113;
      v120 = v119 ^ v115 ^ v114;
      *(_DWORD *)(a1 + 180) = v119;
      *(_DWORD *)(a1 + 184) = v119 ^ v115;
      v121 = v116;
      *(_DWORD *)(a1 + 168) = v116;
      *(_DWORD *)(a1 + 172) = v117;
      *(_DWORD *)(a1 + 176) = v118;
      *(_DWORD *)(a1 + 188) = v120;
      v122 = dword_10118570[(unsigned __int8)v120] ^ dword_10117970[BYTE1(v120)] ^ dword_10117D70[(unsigned __int8)(v120 >> 16)] ^ dword_10118170[v120 >> 24];
      *(_DWORD *)(a1 + 256) = 12;
      v123 = v121 ^ v122 ^ 0x80;
      v124 = v123 ^ v117;
      v125 = v124 ^ v118;
      *(_DWORD *)(a1 + 200) = v125;
      *(_DWORD *)(a1 + 196) = v124;
      *(_DWORD *)(a1 + 192) = v123;
      *(_DWORD *)(a1 + 204) = v125 ^ v119;
      result = 1;
    }
    else
    {
      v13 = *(_BYTE *)(a2 + 16) | ((v12 | v11) << 8);
      *(_DWORD *)(a1 + 16) = v13;
      v14 = v13;
      BYTE1(v13) = *(_BYTE *)(a2 + 23);
      LOBYTE(v13) = *(_BYTE *)(a2 + 22);
      v15 = *(_BYTE *)(a2 + 20) | ((*(_BYTE *)(a2 + 21) | ((unsigned __int16)v13 << 8)) << 8);
      *(_DWORD *)(a1 + 20) = v15;
      v16 = v15;
      BYTE1(v15) = *(_BYTE *)(a2 + 27);
      LOBYTE(v15) = *(_BYTE *)(a2 + 26);
      v17 = *(_BYTE *)(a2 + 24) | ((*(_BYTE *)(a2 + 25) | ((unsigned __int16)v15 << 8)) << 8);
      *(_DWORD *)(a1 + 24) = v17;
      v18 = v17;
      BYTE1(v17) = *(_BYTE *)(a2 + 31);
      LOBYTE(v17) = *(_BYTE *)(a2 + 30);
      v19 = *(_BYTE *)(a2 + 28) | ((*(_BYTE *)(a2 + 29) | ((unsigned __int16)v17 << 8)) << 8);
      *(_DWORD *)(a1 + 28) = v19;
      v20 = v166 ^ dword_10118570[(unsigned __int8)v19] ^ dword_10117970[BYTE1(v19)] ^ dword_10117D70[(unsigned __int8)(v19 >> 16)] ^ dword_10118170[v19 >> 24] ^ 1;
      v21 = v20 ^ v7;
      v22 = v21 ^ v8;
      v23 = v22 ^ v9;
      *(_DWORD *)(a1 + 32) = v20;
      *(_DWORD *)(a1 + 36) = v21;
      *(_DWORD *)(a1 + 40) = v22;
      *(_DWORD *)(a1 + 44) = v23;
      v24 = dword_10117970[(unsigned __int8)v23] ^ dword_10117D70[BYTE1(v23)] ^ dword_10118170[(unsigned __int8)(v23 >> 16)] ^ dword_10118570[v23 >> 24] ^ v14;
      *(_DWORD *)(a1 + 48) = v24;
      v25 = v24 ^ v16 ^ v18;
      v26 = v25 ^ v19;
      *(_DWORD *)(a1 + 56) = v25;
      v27 = v24 ^ v16 ^ v18;
      *(_DWORD *)(a1 + 52) = v24 ^ v16;
      *(_DWORD *)(a1 + 60) = v26;
      v28 = v20 ^ dword_10118570[(unsigned __int8)v26] ^ dword_10117970[BYTE1(v26)] ^ dword_10117D70[(unsigned __int8)(v26 >> 16)] ^ dword_10118170[v26 >> 24] ^ 2;
      v29 = v28 ^ v21;
      *(_DWORD *)(a1 + 64) = v28;
      v30 = v29 ^ v22;
      v31 = v30 ^ v23;
      *(_DWORD *)(a1 + 76) = v31;
      v32 = v28;
      *(_DWORD *)(a1 + 68) = v29;
      *(_DWORD *)(a1 + 72) = v30;
      v33 = dword_10117970[(unsigned __int8)v31] ^ dword_10117D70[BYTE1(v31)] ^ dword_10118170[(unsigned __int8)(v31 >> 16)] ^ dword_10118570[v31 >> 24] ^ v24;
      v34 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 80) = v33;
      *(_DWORD *)(a1 + 88) = v34 ^ v27;
      v35 = v34 ^ v27 ^ v26;
      v36 = v34 ^ v27;
      v37 = v33 ^ v24 ^ v16;
      *(_DWORD *)(a1 + 84) = v34;
      *(_DWORD *)(a1 + 92) = v35;
      v38 = v32 ^ dword_10118570[(unsigned __int8)v35] ^ dword_10117970[BYTE1(v35)] ^ dword_10117D70[(unsigned __int8)(v35 >> 16)] ^ dword_10118170[v35 >> 24] ^ 4;
      v39 = v38 ^ v29;
      *(_DWORD *)(a1 + 96) = v38;
      *(_DWORD *)(a1 + 100) = v39;
      v40 = v39 ^ v30;
      v41 = v40 ^ v31;
      *(_DWORD *)(a1 + 108) = v41;
      *(_DWORD *)(a1 + 104) = v40;
      v42 = dword_10117970[(unsigned __int8)v41] ^ dword_10117D70[BYTE1(v41)] ^ dword_10118170[(unsigned __int8)(v41 >> 16)] ^ dword_10118570[v41 >> 24] ^ v33;
      *(_DWORD *)(a1 + 112) = v42;
      v43 = v42 ^ v37 ^ v36 ^ v35;
      *(_DWORD *)(a1 + 120) = v42 ^ v37 ^ v36;
      *(_DWORD *)(a1 + 116) = v42 ^ v37;
      *(_DWORD *)(a1 + 124) = v43;
      v44 = v38 ^ dword_10118570[(unsigned __int8)v43] ^ dword_10117970[BYTE1(v43)] ^ dword_10117D70[(unsigned __int8)(v43 >> 16)] ^ dword_10118170[v43 >> 24] ^ 8;
      v45 = v44 ^ v39;
      v46 = v45 ^ v40;
      v47 = v46 ^ v41;
      *(_DWORD *)(a1 + 128) = v44;
      *(_DWORD *)(a1 + 132) = v45;
      *(_DWORD *)(a1 + 136) = v46;
      *(_DWORD *)(a1 + 140) = v47;
      v48 = v44;
      v49 = dword_10117970[(unsigned __int8)v47] ^ dword_10117D70[BYTE1(v47)] ^ dword_10118170[(unsigned __int8)(v47 >> 16)] ^ dword_10118570[v47 >> 24] ^ v42;
      *(_DWORD *)(a1 + 144) = v49;
      v50 = v49 ^ v42 ^ v37;
      v51 = v50 ^ v42 ^ v37 ^ v36;
      v52 = v51 ^ v43;
      *(_DWORD *)(a1 + 152) = v51;
      v53 = v51;
      *(_DWORD *)(a1 + 148) = v50;
      v54 = v50;
      *(_DWORD *)(a1 + 156) = v52;
      v55 = v48 ^ dword_10118570[(unsigned __int8)v52] ^ dword_10117970[BYTE1(v52)] ^ dword_10117D70[(unsigned __int8)(v52 >> 16)] ^ dword_10118170[v52 >> 24] ^ 0x10;
      v56 = v55 ^ v45;
      *(_DWORD *)(a1 + 160) = v55;
      v57 = v56 ^ v46;
      v58 = v57 ^ v47;
      *(_DWORD *)(a1 + 172) = v58;
      *(_DWORD *)(a1 + 164) = v56;
      *(_DWORD *)(a1 + 168) = v57;
      v59 = dword_10117970[(unsigned __int8)v58] ^ dword_10117D70[BYTE1(v58)] ^ dword_10118170[(unsigned __int8)(v58 >> 16)] ^ dword_10118570[v58 >> 24] ^ v49;
      *(_DWORD *)(a1 + 176) = v59;
      *(_DWORD *)(a1 + 184) = v59 ^ v54 ^ v53;
      v60 = v59 ^ v54 ^ v53 ^ v52;
      v61 = v59 ^ v54 ^ v53;
      v62 = v59 ^ v54;
      *(_DWORD *)(a1 + 180) = v62;
      *(_DWORD *)(a1 + 188) = v60;
      v63 = v55 ^ dword_10118570[(unsigned __int8)v60] ^ dword_10117970[BYTE1(v60)] ^ dword_10117D70[(unsigned __int8)(v60 >> 16)] ^ dword_10118170[v60 >> 24] ^ 0x20;
      v64 = v63 ^ v56;
      *(_DWORD *)(a1 + 192) = v63;
      v65 = v64 ^ v57;
      v66 = v65 ^ v58;
      *(_DWORD *)(a1 + 204) = v66;
      v67 = v63;
      *(_DWORD *)(a1 + 196) = v64;
      *(_DWORD *)(a1 + 200) = v65;
      v68 = dword_10117970[(unsigned __int8)v66] ^ dword_10117D70[BYTE1(v66)] ^ dword_10118170[(unsigned __int8)(v66 >> 16)] ^ dword_10118570[v66 >> 24] ^ v59;
      *(_DWORD *)(a1 + 208) = v68;
      *(_DWORD *)(a1 + 216) = v68 ^ v62 ^ v61;
      v69 = v68 ^ v62 ^ v61 ^ v60;
      *(_DWORD *)(a1 + 212) = v68 ^ v62;
      *(_DWORD *)(a1 + 220) = v69;
      v70 = dword_10118570[(unsigned __int8)v69] ^ dword_10117970[BYTE1(v69)] ^ dword_10117D70[(unsigned __int8)(v69 >> 16)] ^ dword_10118170[v69 >> 24];
      *(_DWORD *)(a1 + 256) = 14;
      v71 = v67 ^ v70 ^ 0x40;
      v72 = v71 ^ v64;
      v73 = v72 ^ v65;
      *(_DWORD *)(a1 + 232) = v73;
      *(_DWORD *)(a1 + 228) = v72;
      *(_DWORD *)(a1 + 224) = v71;
      *(_DWORD *)(a1 + 236) = v73 ^ v66;
      result = 1;
    }
  }
  return result;
}
// 10117970: using guessed type int dword_10117970[];
// 10117D70: using guessed type int dword_10117D70[];
// 10118170: using guessed type int dword_10118170[];
// 10118570: using guessed type int dword_10118570[];

//----- (10055150) --------------------------------------------------------
void *__usercall sub_10055150@<eax>(void *a1@<eax>)
{
  return memset(a1, 0, 0xA0u);
}

//----- (10055170) --------------------------------------------------------
unsigned int __cdecl sub_10055170(int a1, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@1
  _BYTE *v4; // ecx@3
  char v5; // dl@3
  unsigned __int64 v6; // [sp+Ch] [bp-8h]@1

  v2 = sub_10060900();
  v6 = ((unsigned __int64)(unsigned int)v2 << 32) + (unsigned int)j_TSK_pvg_get_us_timer();
  result = 0;
  do
  {
    if ( result >= a2 )
      break;
    v4 = (_BYTE *)(result + a1);
    v5 = *((_BYTE *)&v6 + result++ + a1 - a1);
    *v4 = v5;
  }
  while ( result < 8 );
  return result;
}
// 100609A0: using guessed type int j_TSK_pvg_get_us_timer(void);

//----- (100551D0) --------------------------------------------------------
int __usercall sub_100551D0@<eax>(int result@<eax>)
{
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 8) = 1732584193;
  *(_DWORD *)(result + 12) = -271733879;
  *(_DWORD *)(result + 16) = -1732584194;
  *(_DWORD *)(result + 20) = &unk_10325476;
  *(_DWORD *)(result + 24) = -1009589776;
  return result;
}

//----- (10055210) --------------------------------------------------------
int __usercall sub_10055210@<eax>(int result@<eax>)
{
  int v1; // ebx@1
  int v2; // esi@1
  int v3; // edx@1
  unsigned int v4; // ST28_4@1
  int v5; // edx@1
  int v6; // ST18_4@1
  unsigned int v7; // ST2C_4@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // ST14_4@1
  int v12; // ST20_4@1
  unsigned int v13; // ST30_4@1
  int v14; // esi@1
  unsigned int v15; // ST34_4@1
  int v16; // edi@1
  int v17; // edi@1
  int v18; // ecx@1
  int v19; // ST1C_4@1
  int v20; // ebx@1
  unsigned int v21; // ebp@1
  unsigned int v22; // ST38_4@1
  int v23; // edx@1
  int v24; // ST10_4@1
  unsigned int v25; // ST3C_4@1
  int v26; // esi@1
  int v27; // esi@1
  int v28; // ST18_4@1
  int v29; // ebp@1
  unsigned int v30; // ST40_4@1
  int v31; // edi@1
  int v32; // ebx@1
  int v33; // ST14_4@1
  unsigned int v34; // ST44_4@1
  int v35; // edi@1
  int v36; // ST20_4@1
  int v37; // ST1C_4@1
  unsigned int v38; // ST48_4@1
  int v39; // ebx@1
  int v40; // ebx@1
  int v41; // ecx@1
  int v42; // ebp@1
  unsigned int v43; // ST4C_4@1
  int v44; // edx@1
  int v45; // edx@1
  int v46; // ST10_4@1
  int v47; // esi@1
  unsigned int v48; // ST50_4@1
  int v49; // esi@1
  int v50; // ST18_4@1
  unsigned int v51; // ST54_4@1
  int v52; // edi@1
  int v53; // ebx@1
  int v54; // ST14_4@1
  unsigned int v55; // ST58_4@1
  int v56; // edi@1
  int v57; // ST20_4@1
  int v58; // ebx@1
  unsigned int v59; // ST5C_4@1
  int v60; // ebx@1
  int v61; // ecx@1
  int v62; // ST14_4@1
  int v63; // ST1C_4@1
  unsigned int v64; // ST60_4@1
  int v65; // edx@1
  int v66; // edx@1
  int v67; // ST10_4@1
  unsigned int v68; // ST64_4@1
  int v69; // esi@1
  int v70; // esi@1
  int v71; // ST18_4@1
  int v72; // ebp@1
  int v73; // ecx@1
  int v74; // ebx@1
  int v75; // ST68_4@1
  int v76; // edi@1
  int v77; // edi@1
  int v78; // ST14_4@1
  int v79; // ST20_4@1
  int v80; // ecx@1
  int v81; // ST6C_4@1
  int v82; // edi@1
  int v83; // ecx@1
  int v84; // ST70_4@1
  int v85; // ebx@1
  int v86; // ST1C_4@1
  int v87; // ebx@1
  int v88; // ecx@1
  int v89; // ST14_4@1
  int v90; // ecx@1
  int v91; // ST74_4@1
  int v92; // edx@1
  int v93; // edx@1
  int v94; // ST10_4@1
  int v95; // ecx@1
  int v96; // ST78_4@1
  int v97; // esi@1
  int v98; // esi@1
  int v99; // ST18_4@1
  int v100; // ebx@1
  int v101; // ecx@1
  int v102; // edi@1
  int v103; // ST7C_4@1
  int v104; // edi@1
  int v105; // ST20_4@1
  int v106; // ecx@1
  int v107; // ST80_4@1
  int v108; // edx@1
  int v109; // edx@1
  int v110; // ecx@1
  int v111; // ST84_4@1
  int v112; // ebx@1
  int v113; // ebx@1
  int v114; // ST14_4@1
  int v115; // ecx@1
  int v116; // ebp@1
  int v117; // ST88_4@1
  int v118; // edi@1
  int v119; // edi@1
  int v120; // ST10_4@1
  int v121; // ebp@1
  int v122; // ecx@1
  int v123; // ST8C_4@1
  int v124; // edx@1
  int v125; // ebp@1
  int v126; // edx@1
  int v127; // ecx@1
  int v128; // ST18_4@1
  int v129; // ST90_4@1
  int v130; // esi@1
  int v131; // esi@1
  int v132; // ST20_4@1
  int v133; // ecx@1
  int v134; // ST94_4@1
  int v135; // edi@1
  int v136; // edi@1
  int v137; // ecx@1
  int v138; // ST98_4@1
  int v139; // ebx@1
  int v140; // ebx@1
  int v141; // ST14_4@1
  int v142; // ecx@1
  int v143; // ebp@1
  int v144; // ST9C_4@1
  int v145; // esi@1
  int v146; // esi@1
  int v147; // ST10_4@1
  int v148; // ebp@1
  int v149; // ecx@1
  int v150; // STA0_4@1
  int v151; // edi@1
  int v152; // ebp@1
  int v153; // edx@1
  int v154; // ecx@1
  int v155; // ST18_4@1
  int v156; // STA4_4@1
  int v157; // edi@1
  int v158; // edi@1
  int v159; // ST20_4@1
  int v160; // ecx@1
  int v161; // STA8_4@1
  int v162; // esi@1
  int v163; // esi@1
  int v164; // ecx@1
  int v165; // STAC_4@1
  int v166; // ebx@1
  int v167; // ebx@1
  int v168; // ST14_4@1
  int v169; // ecx@1
  int v170; // ebp@1
  int v171; // STB0_4@1
  int v172; // edi@1
  int v173; // edi@1
  int v174; // ST10_4@1
  int v175; // ebp@1
  int v176; // ecx@1
  int v177; // STB4_4@1
  int v178; // esi@1
  int v179; // ebp@1
  int v180; // edx@1
  int v181; // ST18_4@1
  int v182; // ecx@1
  int v183; // STB8_4@1
  int v184; // esi@1
  int v185; // ebx@1
  int v186; // ST20_4@1
  int v187; // esi@1
  int v188; // ecx@1
  int v189; // STBC_4@1
  int v190; // edi@1
  int v191; // edi@1
  int v192; // ST1C_4@1
  int v193; // ecx@1
  int v194; // ebp@1
  int v195; // STC0_4@1
  int v196; // edx@1
  int v197; // ecx@1
  int v198; // esi@1
  int v199; // STC4_4@1
  int v200; // ebp@1
  int v201; // esi@1
  int v202; // ST10_4@1
  int v203; // ecx@1
  int v204; // ebp@1
  int v205; // edi@1
  int v206; // STC8_4@1
  int v207; // ST1C_4@1
  int v208; // ecx@1
  int v209; // STCC_4@1
  int v210; // ebx@1
  int v211; // ST18_4@1
  int v212; // ecx@1
  int v213; // STD0_4@1
  int v214; // edx@1
  int v215; // edi@1
  int v216; // ebx@1
  int v217; // ecx@1
  int v218; // edx@1
  int v219; // ebx@1
  int v220; // ecx@1
  int v221; // ST1C_4@1
  int v222; // ebp@1
  int v223; // STD4_4@1
  int v224; // ST10_4@1
  int v225; // edx@1
  int v226; // ecx@1
  int v227; // ST14_4@1
  int v228; // STD8_4@1
  int v229; // ebp@1
  int v230; // ebx@1
  int v231; // ecx@1
  int v232; // esi@1
  int v233; // ST10_4@1
  int v234; // ecx@1
  int v235; // STDC_4@1
  int v236; // edi@1
  int v237; // ebx@1
  int v238; // ecx@1
  int v239; // edi@1
  int v240; // STE0_4@1
  int v241; // ebx@1
  int v242; // ST18_4@1
  int v243; // ST1C_4@1
  int v244; // ecx@1
  int v245; // edx@1
  int v246; // STE4_4@1
  int v247; // edi@1
  int v248; // ebx@1
  int v249; // ecx@1
  int v250; // edx@1
  int v251; // ebx@1
  int v252; // ecx@1
  int v253; // ST1C_4@1
  int v254; // ebp@1
  int v255; // STE8_4@1
  int v256; // ST10_4@1
  int v257; // edx@1
  int v258; // ecx@1
  int v259; // ebx@1
  int v260; // ST14_4@1
  int v261; // STEC_4@1
  int v262; // ebp@1
  int v263; // ecx@1
  int v264; // esi@1
  int v265; // ST10_4@1
  int v266; // ecx@1
  int v267; // edi@1
  int v268; // STF0_4@1
  int v269; // ebx@1
  int v270; // edi@1
  int v271; // ecx@1
  int v272; // ebx@1
  int v273; // STF4_4@1
  int v274; // ST1C_4@1
  int v275; // ST18_4@1
  int v276; // ecx@1
  int v277; // edx@1
  int v278; // edi@1
  int v279; // STF8_4@1
  int v280; // ebx@1
  int v281; // ecx@1
  int v282; // edx@1
  int v283; // ST1C_4@1
  int v284; // ecx@1
  int v285; // ST10_4@1
  int v286; // STFC_4@1
  int v287; // ebp@1
  int v288; // edx@1
  int v289; // ecx@1
  int v290; // ST100_4@1
  int v291; // ST14_4@1
  int v292; // ebp@1
  int v293; // ebx@1
  int v294; // ecx@1
  int v295; // esi@1
  int v296; // ST10_4@1
  int v297; // ecx@1
  int v298; // edi@1
  int v299; // ST104_4@1
  int v300; // ebx@1
  int v301; // edi@1
  int v302; // ecx@1
  int v303; // ebx@1
  int v304; // ST108_4@1
  int v305; // ST1C_4@1
  int v306; // ST18_4@1
  int v307; // ecx@1
  int v308; // edi@1
  int v309; // ST10C_4@1
  int v310; // ebx@1
  int v311; // edx@1
  int v312; // ecx@1
  int v313; // ST1C_4@1
  int v314; // ecx@1
  int v315; // ST110_4@1
  int v316; // ebp@1
  int v317; // ebx@1
  int v318; // edx@1
  int v319; // ecx@1
  int v320; // ST114_4@1
  int v321; // ST14_4@1
  int v322; // ebp@1
  int v323; // edi@1
  int v324; // ecx@1
  int v325; // edx@1
  int v326; // ebp@1
  int v327; // ST118_4@1
  int v328; // esi@1
  int v329; // ST10_4@1
  int v330; // ecx@1
  int v331; // ST18_4@1
  int v332; // ST11C_4@1
  int v333; // ebx@1
  int v334; // esi@1
  int v335; // edi@1
  int v336; // edi@1
  int v337; // ST20_4@1
  int v338; // ebx@1
  int v339; // ecx@1
  int v340; // edx@1
  int v341; // ST120_4@1
  int v342; // edx@1
  int v343; // ecx@1
  int v344; // ST124_4@1
  int v345; // ebx@1
  int v346; // ebx@1
  int v347; // ecx@1
  int v348; // ST14_4@1
  int v349; // ST128_4@1
  int v350; // ebp@1
  int v351; // edi@1
  int v352; // edi@1
  int v353; // ecx@1
  int v354; // ST10_4@1
  int v355; // ST12C_4@1
  int v356; // ebp@1
  int v357; // edx@1
  int v358; // ST18_4@1
  int v359; // ecx@1
  int v360; // ST130_4@1
  int v361; // edx@1
  int v362; // esi@1
  int v363; // esi@1
  int v364; // ST20_4@1
  int v365; // ecx@1
  int v366; // ebx@1
  int v367; // edi@1
  int v368; // ST134_4@1
  int v369; // edi@1
  int v370; // ecx@1
  int v371; // ebp@1
  int v372; // ST138_4@1
  int v373; // ebx@1
  int v374; // ebx@1
  int v375; // ecx@1
  int v376; // ST14_4@1
  int v377; // ST13C_4@1
  int v378; // ebp@1
  int v379; // esi@1
  int v380; // esi@1
  int v381; // ecx@1
  int v382; // ST10_4@1
  int v383; // ST140_4@1
  int v384; // ebp@1
  int v385; // edi@1
  int v386; // edi@1
  int v387; // ecx@1
  int v388; // ebp@1
  int v389; // edx@1
  int v390; // ST18_4@1
  int v391; // ebx@1
  int v392; // ST20_4@1
  int v393; // edx@1
  int v394; // ST14_4@1
  int v395; // esi@1
  int v396; // ST148_4@1
  int v397; // ST10_4@1
  int v398; // ST1C_4@1
  int v399; // edx@1
  int v400; // ebx@1
  int v401; // ST14C_4@1
  int v402; // esi@1
  int v403; // ebx@1
  int v404; // ST18_4@1
  int v405; // ST14_4@1
  int v406; // edx@1
  int v407; // edi@1
  int v408; // esi@1
  int v409; // ebx@1
  int v410; // ST20_4@1
  int v411; // esi@1
  int v412; // ST10_4@1
  int v413; // ebx@1
  int v414; // edi@1
  int v415; // ebp@1
  int v416; // edi@1
  int v417; // ST24_4@1
  int v418; // ST1C_4@1
  int v419; // edi@1
  int v420; // ebx@1
  int v421; // ST20_4@1
  int v422; // edx@1
  int v423; // ebx@1
  int v424; // edx@1
  int v425; // ebx@1
  int v426; // ST1C_4@1
  int v427; // esi@1
  int v428; // ebx@1
  int v429; // esi@1
  int v430; // ecx@1
  int v431; // ebx@1
  int v432; // ebx@1
  int v433; // edx@1
  int v434; // ecx@1

  v1 = *(_DWORD *)(result + 8);
  v2 = *(_DWORD *)(result + 12);
  v3 = __ROL4__(*(_DWORD *)(result + 8), 5);
  v4 = ((*(_DWORD *)(result + 28) & 0xFF00 | (*(_DWORD *)(result + 28) << 16)) << 8) | (((*(_DWORD *)(result + 28) >> 16) | *(_DWORD *)(result + 28) & 0xFF0000u) >> 8);
  v5 = v4
     + *(_DWORD *)(result + 24)
     + v3
     + (v2 & *(_DWORD *)(result + 16) ^ *(_DWORD *)(result + 20) & ~*(_DWORD *)(result + 12))
     + 1518500249;
  v2 = __ROR4__(v2, 2);
  v6 = v2;
  v7 = ((*(_DWORD *)(result + 32) & 0xFF00 | (*(_DWORD *)(result + 32) << 16)) << 8) | (((*(_DWORD *)(result + 32) >> 16) | *(_DWORD *)(result + 32) & 0xFF0000u) >> 8);
  v8 = v1 & v2 ^ *(_DWORD *)(result + 16) & ~v1;
  v9 = __ROL4__(v5, 5);
  v10 = *(_DWORD *)(result + 20) + v7 + v9 + v8 + 1518500249;
  v1 = __ROR4__(v1, 2);
  v11 = v10;
  v10 = __ROL4__(v10, 5);
  v12 = v1;
  v13 = ((*(_DWORD *)(result + 36) & 0xFF00 | (*(_DWORD *)(result + 36) << 16)) << 8) | (((*(_DWORD *)(result + 36) >> 16) | *(_DWORD *)(result + 36) & 0xFF0000u) >> 8);
  v14 = *(_DWORD *)(result + 16) + v13 + v10 + (v1 & v5 ^ v6 & ~v5) + 1518500249;
  v5 = __ROR4__(v5, 2);
  v15 = ((*(_DWORD *)(result + 40) & 0xFF00 | (*(_DWORD *)(result + 40) << 16)) << 8) | (((*(_DWORD *)(result + 40) >> 16) | *(_DWORD *)(result + 40) & 0xFF0000u) >> 8);
  v16 = __ROL4__(v14, 5);
  v17 = v6 + v15 + v16 + (v11 & v5 ^ v1 & ~v11) + 1518500249;
  v18 = __ROR4__(v11, 2);
  v19 = v5;
  v20 = __ROL4__(v17, 5);
  v21 = (((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8))
      + v20
      + (v14 & v18 ^ v5 & ~v14);
  v22 = ((*(_DWORD *)(result + 44) & 0xFF00 | (*(_DWORD *)(result + 44) << 16)) << 8) | (((*(_DWORD *)(result + 44) >> 16) | *(_DWORD *)(result + 44) & 0xFF0000u) >> 8);
  v14 = __ROR4__(v14, 2);
  v23 = v12 + v21 + 1518500249;
  v24 = v14;
  v25 = ((*(_DWORD *)(result + 48) & 0xFF00 | (*(_DWORD *)(result + 48) << 16)) << 8) | (((*(_DWORD *)(result + 48) >> 16) | *(_DWORD *)(result + 48) & 0xFF0000u) >> 8);
  v26 = __ROL4__(v23, 5);
  v27 = v19 + v25 + v26 + (v17 & v24 ^ v18 & ~v17) + 1518500249;
  v17 = __ROR4__(v17, 2);
  v28 = v17;
  v29 = v23 & v17;
  v30 = ((*(_DWORD *)(result + 52) & 0xFF00 | (*(_DWORD *)(result + 52) << 16)) << 8) | (((*(_DWORD *)(result + 52) >> 16) | *(_DWORD *)(result + 52) & 0xFF0000u) >> 8);
  v31 = __ROL4__(v27, 5);
  v32 = v18 + v30 + v31 + (v29 ^ v24 & ~v23) + 1518500249;
  v23 = __ROR4__(v23, 2);
  v33 = v32;
  v32 = __ROL4__(v32, 5);
  v34 = ((*(_DWORD *)(result + 56) & 0xFF00 | (*(_DWORD *)(result + 56) << 16)) << 8) | (((*(_DWORD *)(result + 56) >> 16) | *(_DWORD *)(result + 56) & 0xFF0000u) >> 8);
  v35 = v24 + v34 + v32 + (v23 & v27 ^ v28 & ~v27) + 1518500249;
  v27 = __ROR4__(v27, 2);
  v36 = v23;
  v37 = v27;
  v38 = ((*(_DWORD *)(result + 60) & 0xFF00 | (*(_DWORD *)(result + 60) << 16)) << 8) | (((*(_DWORD *)(result + 60) >> 16) | *(_DWORD *)(result + 60) & 0xFF0000u) >> 8);
  v39 = __ROL4__(v35, 5);
  v40 = v28 + v38 + v39 + (v33 & v27 ^ v23 & ~v33) + 1518500249;
  v41 = __ROR4__(v33, 2);
  v42 = v35 & v41 ^ v27 & ~v35;
  v43 = ((*(_DWORD *)(result + 64) & 0xFF00 | (*(_DWORD *)(result + 64) << 16)) << 8) | (((*(_DWORD *)(result + 64) >> 16) | *(_DWORD *)(result + 64) & 0xFF0000u) >> 8);
  v44 = __ROL4__(v40, 5);
  v35 = __ROR4__(v35, 2);
  v45 = v36 + v43 + v44 + v42 + 1518500249;
  v46 = v35;
  v47 = __ROL4__(v45, 5);
  v48 = ((*(_DWORD *)(result + 68) & 0xFF00 | (*(_DWORD *)(result + 68) << 16)) << 8) | (((*(_DWORD *)(result + 68) >> 16) | *(_DWORD *)(result + 68) & 0xFF0000u) >> 8);
  v49 = v37 + v48 + v47 + (v40 & v35 ^ v41 & ~v40) + 1518500249;
  v40 = __ROR4__(v40, 2);
  v50 = v40;
  v51 = ((*(_DWORD *)(result + 72) & 0xFF00 | (*(_DWORD *)(result + 72) << 16)) << 8) | (((*(_DWORD *)(result + 72) >> 16) | *(_DWORD *)(result + 72) & 0xFF0000u) >> 8);
  v52 = __ROL4__(v49, 5);
  v53 = v41 + v51 + v52 + (v45 & v40 ^ v46 & ~v45) + 1518500249;
  v54 = v53;
  v45 = __ROR4__(v45, 2);
  v53 = __ROL4__(v53, 5);
  v55 = ((*(_DWORD *)(result + 76) & 0xFF00 | (*(_DWORD *)(result + 76) << 16)) << 8) | (((*(_DWORD *)(result + 76) >> 16) | *(_DWORD *)(result + 76) & 0xFF0000u) >> 8);
  v56 = v46 + v55 + v53 + (v45 & v49 ^ v50 & ~v49) + 1518500249;
  v49 = __ROR4__(v49, 2);
  v57 = v45;
  v58 = __ROL4__(v56, 5);
  v59 = ((*(_DWORD *)(result + 80) & 0xFF00 | (*(_DWORD *)(result + 80) << 16)) << 8) | (((*(_DWORD *)(result + 80) >> 16) | *(_DWORD *)(result + 80) & 0xFF0000u) >> 8);
  v60 = v50 + v59 + v58 + (v54 & v49 ^ v45 & ~v54) + 1518500249;
  v61 = __ROR4__(v54, 2);
  v62 = v61;
  v63 = v49;
  v64 = ((*(_DWORD *)(result + 84) & 0xFF00 | (*(_DWORD *)(result + 84) << 16)) << 8) | (((*(_DWORD *)(result + 84) >> 16) | *(_DWORD *)(result + 84) & 0xFF0000u) >> 8);
  v65 = __ROL4__(v60, 5);
  v66 = v57 + v64 + v65 + (v56 & v61 ^ v49 & ~v56) + 1518500249;
  v56 = __ROR4__(v56, 2);
  v67 = v56;
  v68 = ((*(_DWORD *)(result + 88) & 0xFF00 | (*(_DWORD *)(result + 88) << 16)) << 8) | (((*(_DWORD *)(result + 88) >> 16) | *(_DWORD *)(result + 88) & 0xFF0000u) >> 8);
  v69 = __ROL4__(v66, 5);
  v70 = v63 + v68 + v69 + (v60 & v56 ^ v61 & ~v60) + 1518500249;
  v60 = __ROR4__(v60, 2);
  v71 = v60;
  v72 = v60;
  v73 = __ROL4__(v4 ^ v13 ^ v38 ^ v59, 1);
  v74 = v56 & ~v66;
  v75 = v73;
  v76 = __ROL4__(v70, 5);
  v77 = v62 + v73 + v76 + (v66 & v72 ^ v74) + 1518500249;
  v66 = __ROR4__(v66, 2);
  v78 = v77;
  v79 = v66;
  v80 = __ROL4__(v7 ^ v15 ^ v43 ^ v64, 1);
  v81 = v80;
  v77 = __ROL4__(v77, 5);
  v82 = v67 + v80 + v77 + (v66 & v70 ^ v71 & ~v70) + 1518500249;
  v70 = __ROR4__(v70, 2);
  v83 = __ROL4__(v13 ^ v22 ^ v48 ^ v68, 1);
  v84 = v83;
  v85 = __ROL4__(v82, 5);
  v86 = v70;
  v87 = v71 + v83 + v85 + (v78 & v70 ^ v66 & ~v78) + 1518500249;
  v88 = __ROR4__(v78, 2);
  v89 = v88;
  v90 = __ROL4__(v15 ^ v25 ^ v51 ^ v75, 1);
  v91 = v90;
  v92 = __ROL4__(v87, 5);
  v93 = v79 + v90 + v92 + (v82 & v89 ^ v70 & ~v82) + 1518500249;
  v82 = __ROR4__(v82, 2);
  v94 = v82;
  v95 = __ROL4__(v22 ^ v30 ^ v55 ^ v81, 1);
  v96 = v95;
  v97 = __ROL4__(v93, 5);
  v98 = v86 + v95 + v97 + (v87 ^ v82 ^ v89) + 1859775393;
  v87 = __ROR4__(v87, 2);
  v99 = v87;
  v100 = v87 ^ v82;
  v101 = __ROL4__(v25 ^ v34 ^ v59 ^ v84, 1);
  v102 = __ROL4__(v98, 5);
  v103 = v101;
  v104 = v89 + v101 + v102 + (v93 ^ v100) + 1859775393;
  v93 = __ROR4__(v93, 2);
  v105 = v93;
  v106 = __ROL4__(v30 ^ v38 ^ v64 ^ v91, 1);
  v107 = v106;
  v108 = __ROL4__(v104, 5);
  v109 = v94 + v106 + v108 + (v105 ^ v99 ^ v98) + 1859775393;
  v98 = __ROR4__(v98, 2);
  v110 = __ROL4__(v34 ^ v43 ^ v68 ^ v96, 1);
  v111 = v110;
  v112 = __ROL4__(v109, 5);
  v113 = v99 + v110 + v112 + (v105 ^ v104 ^ v98) + 1859775393;
  v104 = __ROR4__(v104, 2);
  v114 = v104;
  v115 = __ROL4__(v38 ^ v48 ^ v75 ^ v103, 1);
  v116 = v109 ^ v104 ^ v98;
  v117 = v115;
  v118 = __ROL4__(v113, 5);
  v119 = v105 + v115 + v118 + v116 + 1859775393;
  v109 = __ROR4__(v109, 2);
  v120 = v109;
  v121 = v109 ^ v114;
  v122 = __ROL4__(v43 ^ v51 ^ v81 ^ v107, 1);
  v123 = v122;
  v124 = __ROL4__(v119, 5);
  v125 = v122 + v124 + (v113 ^ v121);
  v113 = __ROR4__(v113, 2);
  v126 = v98 + v125 + 1859775393;
  v127 = __ROL4__(v48 ^ v55 ^ v84 ^ v111, 1);
  v128 = v113;
  v129 = v127;
  v130 = __ROL4__(v126, 5);
  v131 = v114 + v127 + v130 + (v119 ^ v113 ^ v120) + 1859775393;
  v119 = __ROR4__(v119, 2);
  v132 = v119;
  v133 = __ROL4__(v51 ^ v59 ^ v91 ^ v117, 1);
  v134 = v133;
  v135 = __ROL4__(v131, 5);
  v136 = v120 + v133 + v135 + (v132 ^ v113 ^ v126) + 1859775393;
  v126 = __ROR4__(v126, 2);
  v137 = __ROL4__(v55 ^ v64 ^ v96 ^ v123, 1);
  v138 = v137;
  v139 = __ROL4__(v136, 5);
  v140 = v128 + v137 + v139 + (v132 ^ v131 ^ v126) + 1859775393;
  v131 = __ROR4__(v131, 2);
  v141 = v131;
  v142 = __ROL4__(v59 ^ v68 ^ v103 ^ v129, 1);
  v143 = v136 ^ v131 ^ v126;
  v144 = v142;
  v145 = __ROL4__(v140, 5);
  v146 = v132 + v142 + v145 + v143 + 1859775393;
  v136 = __ROR4__(v136, 2);
  v147 = v136;
  v148 = v136 ^ v141;
  v149 = __ROL4__(v64 ^ v75 ^ v107 ^ v134, 1);
  v150 = v149;
  v151 = __ROL4__(v146, 5);
  v152 = v149 + v151 + (v140 ^ v148);
  v140 = __ROR4__(v140, 2);
  v153 = v126 + v152 + 1859775393;
  v154 = __ROL4__(v68 ^ v81 ^ v111 ^ v138, 1);
  v155 = v140;
  v156 = v154;
  v157 = __ROL4__(v153, 5);
  v158 = v141 + v154 + v157 + (v146 ^ v140 ^ v147) + 1859775393;
  v146 = __ROR4__(v146, 2);
  v159 = v146;
  v160 = __ROL4__(v75 ^ v84 ^ v117 ^ v144, 1);
  v161 = v160;
  v162 = __ROL4__(v158, 5);
  v163 = v147 + v160 + v162 + (v159 ^ v140 ^ v153) + 1859775393;
  v153 = __ROR4__(v153, 2);
  v164 = __ROL4__(v81 ^ v91 ^ v123 ^ v150, 1);
  v165 = v164;
  v166 = __ROL4__(v163, 5);
  v167 = v155 + v164 + v166 + (v159 ^ v158 ^ v153) + 1859775393;
  v158 = __ROR4__(v158, 2);
  v168 = v158;
  v169 = __ROL4__(v84 ^ v96 ^ v129 ^ v156, 1);
  v170 = v163 ^ v158 ^ v153;
  v171 = v169;
  v172 = __ROL4__(v167, 5);
  v173 = v159 + v169 + v172 + v170 + 1859775393;
  v163 = __ROR4__(v163, 2);
  v174 = v163;
  v175 = v163 ^ v168;
  v176 = __ROL4__(v91 ^ v103 ^ v134 ^ v161, 1);
  v177 = v176;
  v178 = __ROL4__(v173, 5);
  v179 = v176 + v178 + (v167 ^ v175);
  v167 = __ROR4__(v167, 2);
  v180 = v153 + v179 + 1859775393;
  v181 = v167;
  v182 = __ROL4__(v96 ^ v107 ^ v138 ^ v165, 1);
  v183 = v182;
  v184 = __ROL4__(v180, 5);
  v185 = v168 + v182 + v184 + (v173 ^ v167 ^ v174) + 1859775393;
  v173 = __ROR4__(v173, 2);
  v186 = v173;
  v187 = v173;
  v188 = __ROL4__(v103 ^ v111 ^ v144 ^ v171, 1);
  v189 = v188;
  v190 = __ROL4__(v185, 5);
  v191 = v174 + v188 + v190 + (v187 ^ v181 ^ v180) + 1859775393;
  v180 = __ROR4__(v180, 2);
  v192 = v180;
  v193 = __ROL4__(v107 ^ v117 ^ v150 ^ v177, 1);
  v194 = __ROL4__(v191, 5);
  v195 = v193;
  v196 = v181 + v193 + v194 + (v187 ^ v185 ^ v180) + 1859775393;
  v185 = __ROR4__(v185, 2);
  v197 = __ROL4__(v111 ^ v123 ^ v156 ^ v183, 1);
  v198 = __ROL4__(v196, 5);
  v199 = v197;
  v200 = v197 + v198 + (v191 ^ v185 ^ v192);
  v191 = __ROR4__(v191, 2);
  v201 = v186 + v200 + 1859775393;
  v202 = v191;
  v203 = __ROL4__(v117 ^ v129 ^ v161 ^ v189, 1);
  v204 = __ROL4__(v201, 5);
  v205 = v192 + v203 + (v196 & v191 ^ v185 & (v196 ^ v191)) + v204 - 1894007588;
  v206 = v203;
  v207 = v205;
  v196 = __ROR4__(v196, 2);
  v208 = __ROL4__(v123 ^ v134 ^ v165 ^ v195, 1);
  v209 = v208;
  v210 = v185 + v208 + (v201 & v196 ^ v202 & (v201 ^ v196));
  v205 = __ROL4__(v205, 5);
  v201 = __ROR4__(v201, 2);
  v211 = v196;
  v212 = __ROL4__(v129 ^ v138 ^ v171 ^ v199, 1);
  v213 = v212;
  v214 = v202 + v212 + (v201 & v196 ^ v207 & (v201 ^ v196));
  v215 = v210 + v205 - 1894007588;
  v216 = __ROL4__(v215, 5);
  v217 = __ROR4__(v207, 2);
  v218 = v214 + v216 - 1894007588;
  v219 = v217;
  v220 = __ROL4__(v134 ^ v144 ^ v177 ^ v206, 1);
  v221 = v219;
  v222 = v211 + v220 + (v201 & v215 ^ v219 & (v201 ^ v215));
  v223 = v220;
  v224 = v218;
  v218 = __ROL4__(v218, 5);
  v215 = __ROR4__(v215, 2);
  v225 = v218 + v222 - 1894007588;
  v226 = __ROL4__(v138 ^ v150 ^ v183 ^ v209, 1);
  v227 = v215;
  v228 = v226;
  v229 = v226 + (v224 & v215 ^ v219 & (v224 ^ v215));
  v230 = __ROL4__(v225, 5);
  v231 = __ROR4__(v224, 2);
  v232 = v230 + v201 + v229 - 1894007588;
  v233 = v231;
  v234 = __ROL4__(v144 ^ v156 ^ v189 ^ v213, 1);
  v235 = v234;
  v236 = v221 + v234 + (v225 & v233 ^ v215 & (v225 ^ v233));
  v237 = __ROL4__(v232, 5);
  v225 = __ROR4__(v225, 2);
  v238 = __ROL4__(v150 ^ v161 ^ v195 ^ v223, 1);
  v239 = v236 + v237 - 1894007588;
  v240 = v238;
  v241 = v227 + v238 + (v232 & v225 ^ v233 & (v232 ^ v225));
  v242 = v225;
  v243 = v239;
  v239 = __ROL4__(v239, 5);
  v232 = __ROR4__(v232, 2);
  v244 = __ROL4__(v156 ^ v165 ^ v199 ^ v228, 1);
  v245 = v233 + v244 + (v232 & v225 ^ v243 & (v232 ^ v225));
  v246 = v244;
  v247 = v241 + v239 - 1894007588;
  v248 = __ROL4__(v247, 5);
  v249 = __ROR4__(v243, 2);
  v250 = v245 + v248 - 1894007588;
  v251 = v249;
  v252 = __ROL4__(v161 ^ v171 ^ v206 ^ v235, 1);
  v253 = v251;
  v254 = v242 + v252 + (v232 & v247 ^ v251 & (v232 ^ v247));
  v255 = v252;
  v256 = v250;
  v250 = __ROL4__(v250, 5);
  v247 = __ROR4__(v247, 2);
  v257 = v250 + v254 - 1894007588;
  v258 = __ROL4__(v165 ^ v177 ^ v209 ^ v240, 1);
  v259 = __ROL4__(v257, 5);
  v260 = v247;
  v261 = v258;
  v262 = v258 + (v256 & v247 ^ v253 & (v256 ^ v247));
  v263 = __ROR4__(v256, 2);
  v264 = v259 + v232 + v262 - 1894007588;
  v265 = v263;
  v266 = __ROL4__(v171 ^ v183 ^ v213 ^ v246, 1);
  v267 = v253 + v266 + (v257 & v265 ^ v247 & (v257 ^ v265));
  v268 = v266;
  v269 = __ROL4__(v264, 5);
  v257 = __ROR4__(v257, 2);
  v270 = v267 + v269 - 1894007588;
  v271 = __ROL4__(v177 ^ v189 ^ v223 ^ v255, 1);
  v272 = v260 + v271 + (v264 & v257 ^ v265 & (v264 ^ v257));
  v273 = v271;
  v274 = v270;
  v270 = __ROL4__(v270, 5);
  v264 = __ROR4__(v264, 2);
  v275 = v257;
  v276 = __ROL4__(v183 ^ v195 ^ v228 ^ v261, 1);
  v277 = v265 + v276 + (v264 & v257 ^ v274 & (v264 ^ v257));
  v278 = v272 + v270 - 1894007588;
  v279 = v276;
  v280 = __ROL4__(v278, 5);
  v281 = __ROR4__(v274, 2);
  v282 = v277 + v280 - 1894007588;
  v283 = v281;
  v284 = __ROL4__(v189 ^ v199 ^ v235 ^ v268, 1);
  v285 = v282;
  v282 = __ROL4__(v282, 5);
  v286 = v284;
  v287 = v275 + v284 + (v264 & v278 ^ v283 & (v264 ^ v278));
  v278 = __ROR4__(v278, 2);
  v288 = v282 + v287 - 1894007588;
  v289 = __ROL4__(v195 ^ v206 ^ v240 ^ v273, 1);
  v290 = v289;
  v291 = v278;
  v292 = v289 + (v285 & v278 ^ v283 & (v285 ^ v278));
  v293 = __ROL4__(v288, 5);
  v294 = __ROR4__(v285, 2);
  v295 = v293 + v264 + v292 - 1894007588;
  v296 = v294;
  v297 = __ROL4__(v199 ^ v209 ^ v246 ^ v279, 1);
  v298 = v283 + v297 + (v288 & v296 ^ v278 & (v288 ^ v296));
  v299 = v297;
  v300 = __ROL4__(v295, 5);
  v288 = __ROR4__(v288, 2);
  v301 = v298 + v300 - 1894007588;
  v302 = __ROL4__(v206 ^ v213 ^ v255 ^ v286, 1);
  v303 = v291 + v302 + (v295 & v288 ^ v296 & (v295 ^ v288));
  v304 = v302;
  v305 = v301;
  v306 = v288;
  v301 = __ROL4__(v301, 5);
  v295 = __ROR4__(v295, 2);
  v307 = __ROL4__(v209 ^ v223 ^ v261 ^ v290, 1);
  v308 = v303 + v301 - 1894007588;
  v309 = v307;
  v310 = __ROL4__(v308, 5);
  v311 = v296 + v307 + (v295 & v288 ^ v305 & (v295 ^ v288)) + v310 - 1894007588;
  v312 = __ROR4__(v305, 2);
  v313 = v312;
  v314 = __ROL4__(v213 ^ v228 ^ v268 ^ v299, 1);
  v315 = v314;
  v316 = v306 + v314 + (v295 & v308 ^ v313 & (v295 ^ v308));
  v317 = v311;
  v311 = __ROL4__(v311, 5);
  v308 = __ROR4__(v308, 2);
  v318 = v311 + v316 - 1894007588;
  v319 = __ROL4__(v223 ^ v235 ^ v273 ^ v304, 1);
  v320 = v319;
  v321 = v308;
  v322 = v319 + (v317 & v308 ^ v313 & (v317 ^ v308));
  v323 = v318;
  v318 = __ROL4__(v318, 5);
  v317 = __ROR4__(v317, 2);
  v324 = __ROL4__(v228 ^ v240 ^ v279 ^ v309, 1);
  v325 = v318 + v295 + v322 - 1894007588;
  v326 = v313 + v324 + (v323 ^ v317 ^ v321);
  v327 = v324;
  v328 = __ROL4__(v325, 5);
  v323 = __ROR4__(v323, 2);
  v329 = v317;
  v330 = __ROL4__(v235 ^ v246 ^ v286 ^ v315, 1);
  v331 = v323;
  v332 = v330;
  v333 = v321 + v330 + (v325 ^ v323 ^ v317);
  v334 = v328 + v326 - 899497514;
  v335 = __ROL4__(v334, 5);
  v336 = v333 + v335 - 899497514;
  v325 = __ROR4__(v325, 2);
  v337 = v325;
  v338 = v325 ^ v331 ^ v334;
  v339 = __ROL4__(v240 ^ v255 ^ v290 ^ v320, 1);
  v340 = __ROL4__(v336, 5);
  v341 = v339;
  v334 = __ROR4__(v334, 2);
  v342 = v329 + v339 + v338 + v340 - 899497514;
  v343 = __ROL4__(v246 ^ v261 ^ v299 ^ v327, 1);
  v344 = v343;
  v345 = __ROL4__(v342, 5);
  v346 = v345 + v331 + v343 + (v337 ^ v336 ^ v334) - 899497514;
  v336 = __ROR4__(v336, 2);
  v347 = __ROL4__(v255 ^ v268 ^ v304 ^ v332, 1);
  v348 = v336;
  v349 = v347;
  v350 = v337 + v347 + (v342 ^ v336 ^ v334);
  v351 = __ROL4__(v346, 5);
  v342 = __ROR4__(v342, 2);
  v352 = v351 + v350 - 899497514;
  v353 = __ROL4__(v261 ^ v273 ^ v309 ^ v341, 1);
  v354 = v342;
  v355 = v353;
  v356 = v353 + (v346 ^ v342 ^ v348);
  v357 = __ROL4__(v352, 5);
  v346 = __ROR4__(v346, 2);
  v358 = v346;
  v359 = __ROL4__(v268 ^ v279 ^ v315 ^ v344, 1);
  v360 = v359;
  v361 = v357 + v334 + v356 - 899497514;
  v362 = __ROL4__(v361, 5);
  v363 = v348 + v359 + (v352 ^ v346 ^ v354) + v362 - 899497514;
  v352 = __ROR4__(v352, 2);
  v364 = v352;
  v365 = __ROL4__(v273 ^ v286 ^ v320 ^ v349, 1);
  v366 = v352 ^ v346 ^ v361;
  v367 = __ROL4__(v363, 5);
  v368 = v365;
  v369 = v354 + v365 + v366 + v367 - 899497514;
  v361 = __ROR4__(v361, 2);
  v370 = __ROL4__(v279 ^ v290 ^ v327 ^ v355, 1);
  v371 = v358 + v370 + (v364 ^ v363 ^ v361);
  v372 = v370;
  v373 = __ROL4__(v369, 5);
  v363 = __ROR4__(v363, 2);
  v374 = v373 + v371 - 899497514;
  v375 = __ROL4__(v286 ^ v299 ^ v332 ^ v360, 1);
  v376 = v363;
  v377 = v375;
  v378 = v364 + v375 + (v369 ^ v363 ^ v361);
  v379 = __ROL4__(v374, 5);
  v380 = v379 + v378 - 899497514;
  v369 = __ROR4__(v369, 2);
  v381 = __ROL4__(v290 ^ v304 ^ v341 ^ v368, 1);
  v382 = v369;
  v383 = v381;
  v384 = v381 + (v374 ^ v369 ^ v376);
  v385 = __ROL4__(v380, 5);
  v386 = v385 + v361 + v384 - 899497514;
  v374 = __ROR4__(v374, 2);
  v387 = __ROL4__(v299 ^ v309 ^ v344 ^ v372, 1);
  v388 = v376 + v387 + (v380 ^ v374 ^ v382);
  v389 = __ROL4__(v386, 5);
  v380 = __ROR4__(v380, 2);
  v390 = v374;
  v391 = v389 + v388 - 899497514;
  v392 = v380;
  v393 = __ROL4__(v304 ^ v315 ^ v349 ^ v377, 1);
  v394 = v391;
  v391 = __ROL4__(v391, 5);
  v395 = v382 + v393 + (v380 ^ v390 ^ v386) + v391 - 899497514;
  v386 = __ROR4__(v386, 2);
  v396 = v393;
  v397 = v395;
  v398 = v386;
  v399 = __ROL4__(v309 ^ v320 ^ v355 ^ v383, 1);
  v400 = __ROL4__(v395, 5);
  v401 = v399;
  v402 = __ROR4__(v394, 2);
  v403 = v400 + v390 + v399 + (v392 ^ v394 ^ v386) - 899497514;
  v404 = v403;
  v405 = v402;
  v406 = __ROL4__(v315 ^ v327 ^ v360 ^ v387, 1);
  v403 = __ROL4__(v403, 5);
  v407 = v392 + v406 + (v397 ^ v402 ^ v386) + v403 - 899497514;
  v408 = __ROR4__(v397, 2);
  v409 = v408;
  v410 = v407;
  v411 = __ROL4__(v320 ^ v332 ^ v368 ^ v396, 1);
  v407 = __ROL4__(v407, 5);
  v412 = v409;
  v413 = v407 + v398 + v411 + (v404 ^ v409 ^ v405) - 899497514;
  v414 = __ROR4__(v404, 2);
  v415 = v414;
  v416 = __ROL4__(v327 ^ v341 ^ v372 ^ v401, 1);
  v417 = v416;
  v418 = v413;
  v413 = __ROL4__(v413, 5);
  v419 = v405 + v416 + (v410 ^ v415 ^ v412) + v413 - 899497514;
  v420 = __ROR4__(v410, 2);
  v421 = v420;
  v422 = __ROL4__(v332 ^ v344 ^ v377 ^ v406, 1);
  v423 = __ROL4__(v419, 5);
  v424 = v412 + (v421 ^ v415 ^ v418) + v423 + v422 - 899497514;
  v425 = __ROR4__(v418, 2);
  v426 = v425;
  v427 = __ROL4__(v341 ^ v349 ^ v383 ^ v411, 1);
  v428 = __ROL4__(v424, 5);
  v429 = v415 + (v421 ^ v419 ^ v426) + v428 + v427 - 899497514;
  v419 = __ROR4__(v419, 2);
  v430 = __ROL4__(v417 ^ v344 ^ v355 ^ v387, 1);
  v431 = __ROL4__(v429, 5);
  v432 = v421 + (v424 ^ v419 ^ v426) + v431 + v430 - 899497514 + *(_DWORD *)(result + 8);
  *(_DWORD *)(result + 12) += v429;
  v424 = __ROR4__(v424, 2);
  v433 = *(_DWORD *)(result + 16) + v424;
  *(_DWORD *)(result + 20) += v419;
  v434 = *(_DWORD *)(result + 24);
  *(_DWORD *)(result + 8) = v432;
  *(_DWORD *)(result + 16) = v433;
  *(_DWORD *)(result + 24) = v426 + v434;
  return result;
}

//----- (10056930) --------------------------------------------------------
unsigned int __usercall sub_10056930@<eax>(int a1@<esi>, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // eax@4
  unsigned int v5; // eax@7
  unsigned int result; // eax@7
  int v7; // edx@8

  v2 = *(_DWORD *)a1 & 0x3F;
  v3 = v2 >> 2;
  *(_DWORD *)(a1 + 4 * v3 + 28) = dword_10118998[*(_BYTE *)a1 & 3] | *(_DWORD *)(a1 + 4 * v3 + 28) & dword_101189A8[*(_BYTE *)a1 & 3];
  if ( v2 > 0x37 )
  {
    if ( v2 < 0x3C )
      *(_DWORD *)(a1 + 88) = 0;
    sub_10055210(a1);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = v3 + 1;
  if ( v3 + 1 < 0xE )
LABEL_6:
    memset((void *)(a1 + 4 * v4 + 28), 0, 4 * (14 - v4));
  v5 = 8 * *(_DWORD *)a1;
  *(_DWORD *)(a1 + 84) = ((((unsigned int)(*(_QWORD *)a1 >> 29) << 16) | (*(_QWORD *)a1 >> 29) & 0xFF00) << 8) | ((((unsigned int)(*(_QWORD *)a1 >> 29) >> 16) | (*(_QWORD *)a1 >> 29) & 0xFF0000) >> 8);
  *(_DWORD *)(a1 + 88) = (((v5 << 16) | v5 & 0xFF00) << 8) | (((v5 >> 16) | v5 & 0xFF0000) >> 8);
  sub_10055210(a1);
  result = 0;
  do
  {
    v7 = *(_DWORD *)(a1 + 4 * (result >> 2) + 8) >> 8 * (~(_BYTE)result & 3);
    *(_BYTE *)(++result + a2 - 1) = v7;
  }
  while ( result < 0x14 );
  return result;
}
// 10118998: using guessed type int dword_10118998[];
// 101189A8: using guessed type int dword_101189A8[];

//----- (10056A30) --------------------------------------------------------
void *__usercall sub_10056A30@<eax>(size_t a1@<eax>, char *a2@<ecx>, _DWORD *a3)
{
  int v3; // ebp@1
  size_t v4; // ebx@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  size_t v7; // esi@1
  char *v9; // [sp+14h] [bp+4h]@1

  v3 = (int)a3;
  v4 = a1;
  v5 = *a3 & 0x3F;
  v6 = a1 + *a3;
  v7 = 64 - v5;
  v9 = a2;
  *(_DWORD *)v3 = v6;
  if ( v6 < v4 )
    ++*(_DWORD *)(v3 + 4);
  if ( v4 >= v7 )
  {
    do
    {
      memcpy((void *)(v5 + v3 + 28), v9, v7);
      v9 += v7;
      v4 -= v7;
      v7 = 64;
      v5 = 0;
      sub_10055210(v3);
    }
    while ( v4 >= 0x40 );
  }
  return memcpy((void *)(v5 + v3 + 28), v9, v4);
}

//----- (10056AB0) --------------------------------------------------------
void *__usercall sub_10056AB0@<eax>(int a1@<eax>, size_t a2@<ebx>, char *a3)
{
  int v3; // edi@1
  void *result; // eax@1
  unsigned int v5; // eax@4
  _DWORD *v6; // eax@6

  v3 = a1;
  result = *(void **)(a1 + 156);
  if ( result != (void *)-1 )
  {
    if ( (unsigned int)result > 0x40 )
    {
      sub_10056930(v3 + 64, v3);
      *(_DWORD *)(v3 + 156) = 20;
    }
    memset((void *)(v3 + *(_DWORD *)(v3 + 156)), 0, 64 - *(_DWORD *)(v3 + 156));
    v5 = 0;
    do
      *(_DWORD *)(v3 + 4 * v5++) ^= 0x36363636u;
    while ( v5 < 0x10 );
    v6 = (_DWORD *)sub_100551D0(v3 + 64);
    result = sub_10056A30(0x40u, (char *)v3, v6);
    *(_DWORD *)(v3 + 156) = -1;
  }
  if ( a2 )
    result = sub_10056A30(a2, a3, (_DWORD *)(v3 + 64));
  return result;
}

//----- (10056B50) --------------------------------------------------------
int __usercall sub_10056B50@<eax>(int a1@<edi>, int a2, size_t a3)
{
  unsigned int v3; // eax@3
  int result; // eax@5
  char v5; // [sp+8h] [bp-18h]@3

  if ( *(_DWORD *)(a1 + 156) != -1 )
    sub_10056AB0(a1, 0, 0);
  sub_10056930(a1 + 64, (int)&v5);
  v3 = 0;
  do
    *(_DWORD *)(a1 + 4 * v3++) ^= 0x6A6A6A6Au;
  while ( v3 < 0x10 );
  sub_100551D0(a1 + 64);
  sub_10056A30(0x40u, (char *)a1, (_DWORD *)(a1 + 64));
  sub_10056A30(0x14u, &v5, (_DWORD *)(a1 + 64));
  result = sub_10056930(a1 + 64, (int)&v5);
  if ( a3 )
    result = (int)memcpy((void *)a2, &v5, a3);
  return result;
}

//----- (10056C10) --------------------------------------------------------
int __usercall sub_10056C10@<eax>(size_t a1@<edi>, int a2@<esi>, void *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = *(_DWORD *)(a2 + 156);
  if ( v3 + a1 <= 0x40 )
  {
    memcpy((void *)(a2 + v3), a3, a1);
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  else
  {
    sub_100551D0(a2 + 64);
    sub_10056A30(*(_DWORD *)(a2 + 156), (char *)a2, (_DWORD *)(a2 + 64));
    sub_10056A30(a1, (char *)a3, (_DWORD *)(a2 + 64));
    *(_DWORD *)(a2 + 156) += a1;
    result = 0;
  }
  return result;
}

//----- (10056C70) --------------------------------------------------------
int __usercall sub_10056C70@<eax>(char *a1@<edi>)
{
  unsigned int v1; // ebp@1
  signed int v2; // eax@2
  int v3; // edx@4
  int v4; // ecx@4
  int v5; // edx@4
  unsigned int v6; // esi@4
  size_t v7; // eax@4
  int v8; // ebx@6
  int v9; // edx@8
  int result; // eax@8
  int v11; // ecx@8
  int v12; // edx@8
  char v13; // [sp+Ch] [bp-5Ch]@8
  int v14; // [sp+14h] [bp-54h]@4
  int v15; // [sp+18h] [bp-50h]@4
  int v16; // [sp+1Ch] [bp-4Ch]@4
  int v17; // [sp+20h] [bp-48h]@4
  int v18; // [sp+24h] [bp-44h]@4
  char v19[64]; // [sp+28h] [bp-40h]@6

  v1 = 0;
  do
  {
    v2 = v1;
    if ( !v1 )
      v2 = 260;
    v3 = *(_DWORD *)&a1[v2 - 16];
    v14 = *(_DWORD *)&a1[v2 - 20];
    v4 = *(_DWORD *)&a1[v2 - 12];
    v15 = v3;
    v5 = *(_DWORD *)&a1[v2 - 8];
    v6 = 260 - v1;
    v18 = *(_DWORD *)&a1[v2 - 4];
    v16 = v4;
    v17 = v5;
    v7 = 64;
    if ( 260 - v1 <= 0x40 )
      v7 = 260 - v1;
    v8 = (int)&a1[v1];
    memcpy(v19, &a1[v1], v7);
    if ( v6 < 0x40 )
      memcpy(&v19[v6], a1, 64 - v6);
    sub_10055210((int)&v13);
    v9 = v15;
    result = v16;
    *(_DWORD *)v8 = v14;
    v11 = v17;
    *(_DWORD *)(v8 + 4) = v9;
    v12 = v18;
    *(_DWORD *)(v8 + 8) = result;
    v1 += 20;
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(v8 + 16) = v12;
  }
  while ( v1 < 0x104 );
  return result;
}
// 10056C70: using guessed type char var_40[64];

//----- (10056D30) --------------------------------------------------------
int __usercall sub_10056D30@<eax>(int a1@<ebx>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // eax@3
  char v3; // cl@4
  char v4; // dl@4
  char v5; // cl@4
  char v6; // dl@4
  char *v8; // [sp+Ch] [bp-4h]@1

  v8 = (char *)(a1 + 260);
  v1 = 0;
  qmemcpy((void *)(a1 + 260), (const void *)a1, 0x104u);
  do
    v1 += (*(int (__cdecl **)(unsigned int, unsigned int))(a1 + 524))(a1 + v1, 260 - v1);
  while ( v1 < 0x104 );
  v2 = 0;
  do
  {
    v3 = *(_BYTE *)(v2 + a1 + 261);
    *(_BYTE *)(v2 + a1) ^= ~v8[v2];
    v4 = *(_BYTE *)(v2 + a1 + 262);
    *(_BYTE *)(v2 + a1 + 1) ^= ~v3;
    v5 = *(_BYTE *)(v2 + a1 + 263);
    *(_BYTE *)(v2 + a1 + 2) ^= ~v4;
    v6 = *(_BYTE *)(v2 + a1 + 264);
    *(_BYTE *)(v2 + a1 + 3) ^= ~v5;
    *(_BYTE *)(v2 + a1 + 4) ^= ~v6;
    v2 += 5;
  }
  while ( v2 < 0x104 );
  sub_10056C70((char *)a1);
  return sub_10056C70(v8);
}

//----- (10056DF0) --------------------------------------------------------
char __cdecl sub_10056DF0(char *a1, size_t a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10056AB0(a3 + 296, a2, a1);
    sub_10054370(a3, (int)a1, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10056E40) --------------------------------------------------------
char __cdecl sub_10056E40(char *a1, unsigned int a2, int a3)
{
  char result; // al@4

  if ( a1 && a2 && a3 )
  {
    sub_10054370(a3, (int)a1, a2);
    sub_10056AB0(a3 + 296, a2, a1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10056E90) --------------------------------------------------------
bool __cdecl sub_10056E90(int a1, int a2)
{
  if ( a2 )
    sub_10056B50(a2 + 296, a1, 0xAu);
  return a2 != 0;
}

//----- (10056EC0) --------------------------------------------------------
int __usercall sub_10056EC0@<eax>(char *a1@<edx>, void *a2@<ecx>, size_t a3, size_t a4, int a5, int a6, unsigned int a7)
{
  void *v7; // esi@1
  char *v8; // ebx@1
  int result; // eax@1
  unsigned int v10; // edx@1
  unsigned int v11; // ebx@2
  size_t v12; // edx@3
  char v13; // al@6
  char v14; // al@6
  bool v15; // zf@7
  unsigned int v16; // eax@9
  unsigned int v17; // ecx@9
  int *v18; // [sp+10h] [bp-228h]@2
  unsigned int v19; // [sp+14h] [bp-224h]@2
  int v20; // [sp+18h] [bp-220h]@4
  signed int v21; // [sp+1Ch] [bp-21Ch]@2
  unsigned int v22; // [sp+20h] [bp-218h]@1
  char v23; // [sp+28h] [bp-210h]@3
  char v24; // [sp+C8h] [bp-170h]@1
  char v25; // [sp+168h] [bp-D0h]@1
  int v26; // [sp+20Ch] [bp-2Ch]@2
  int v27; // [sp+210h] [bp-28h]@3
  int v28; // [sp+214h] [bp-24h]@3
  int v29; // [sp+218h] [bp-20h]@3
  int v30; // [sp+21Ch] [bp-1Ch]@3
  int v31; // [sp+220h] [bp-18h]@3
  char v32[16]; // [sp+224h] [bp-14h]@6

  v7 = a2;
  v8 = a1;
  sub_10055150(&v24);
  sub_10056C10(a3, (int)&v24, v7);
  qmemcpy(&v25, &v24, 0xA0u);
  sub_10056AB0((int)&v25, a4, v8);
  result = -858993459 * (a7 - 1);
  v10 = (a7 - 1) / 0x14;
  v22 = v10 + 1;
  if ( v10 != -1 )
  {
    v11 = 1;
    v19 = 0;
    v21 = 1;
    v18 = &v26;
    do
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      qmemcpy(&v23, &v25, 0xA0u);
      LOBYTE(v31) = BYTE3(v11);
      BYTE2(v31) = BYTE1(v11);
      BYTE1(v31) = v11 >> 16;
      BYTE3(v31) = v11;
      v12 = 4;
      if ( a5 )
      {
        v20 = a5;
        do
        {
          sub_10056AB0((int)&v23, v12, (char *)&v31);
          sub_10056B50((int)&v23, (int)&v31, 0x14u);
          v12 = 0;
          do
          {
            *((_BYTE *)&v26 + v12) ^= *((_BYTE *)&v31 + v12);
            v13 = *((_BYTE *)&v31 + v12 + 2);
            *((_BYTE *)&v26 + v12 + 1) ^= *((_BYTE *)&v31 + v12 + 1);
            *((_BYTE *)&v26 + v12 + 2) ^= v13;
            v14 = v32[v12];
            *((_BYTE *)&v26 + v12 + 3) ^= *((_BYTE *)&v31 + v12 + 3);
            *((_BYTE *)&v27 + v12) ^= v14;
            v12 += 5;
          }
          while ( v12 < 0x14 );
          v15 = v20-- == 1;
          qmemcpy(&v23, &v24, 0xA0u);
        }
        while ( !v15 );
        v11 = v21;
      }
      v16 = v19;
      v17 = 0;
      do
      {
        if ( v16 >= a7 )
          break;
        *(_BYTE *)(v16 + a6) = *((_BYTE *)v18 + v16);
        ++v17;
        ++v16;
      }
      while ( v17 < 0x14 );
      v19 += 20;
      v18 -= 5;
      result = ++v11 - 1;
      v21 = v11;
    }
    while ( v11 - 1 < v22 );
  }
  return result;
}
// 10056EC0: using guessed type char var_14[16];

//----- (100570D0) --------------------------------------------------------
int __usercall sub_100570D0@<eax>(void *a1@<eax>, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1

  v2 = (int)a1;
  memset(a1, 0, 0x210u);
  *(_DWORD *)(v2 + 524) = a2;
  sub_10056D30(v2);
  v3 = 20;
  do
  {
    sub_10056C70((char *)v2);
    --v3;
  }
  while ( v3 );
  return sub_10056D30(v2);
}

//----- (10057120) --------------------------------------------------------
char *__cdecl sub_10057120(int a1, int a2)
{
  void *v2; // ecx@0
  char *result; // eax@1
  unsigned int v4; // ebp@1
  int v5; // edi@1
  char *v6; // ebx@1
  size_t v7; // esi@4

  result = (char *)a2;
  v4 = a1;
  v5 = *(_DWORD *)(a2 + 520);
  v6 = (char *)v2;
  if ( a1 )
  {
    while ( 1 )
    {
      v7 = 260 - v5;
      if ( v4 < 260 - v5 )
        v7 = v4;
      result = (char *)memcpy(v6, &result[v5 + 260], v7);
      v6 += v7;
      v5 += v7;
      v4 -= v7;
      if ( v5 == 260 )
      {
        result = (char *)sub_10056D30(a2);
        v5 = 0;
      }
      if ( !v4 )
        break;
      result = (char *)a2;
    }
    *(_DWORD *)(a2 + 520) = v5;
  }
  else
  {
    *(_DWORD *)(a2 + 520) = v5;
  }
  return result;
}

//----- (100571B0) --------------------------------------------------------
signed int __cdecl sub_100571B0(char a1, void *a2, size_t a3, char *a4, _WORD *a5, int a6)
{
  signed int result; // eax@2
  int v7; // ebx@6
  char v8; // [sp+Ch] [bp-48h]@6
  char v9[8]; // [sp+14h] [bp-40h]@6
  __int16 v10[26]; // [sp+1Ch] [bp-38h]@6

  if ( a3 <= 0x80 )
  {
    if ( (unsigned __int8)(a1 - 1) > 2u )
    {
      result = -101;
    }
    else if ( a6 )
    {
      *(_BYTE *)(a6 + 464) = a1;
      v7 = a1 & 3;
      *(_DWORD *)(a6 + 460) = a3;
      sub_10056EC0(a4, a2, a3, 4 * v7 + 4, 1000, (int)&v8, 16 * v7 + 18);
      *(_DWORD *)(a6 + 456) = 16;
      *(_DWORD *)a6 = 0;
      *(_DWORD *)(a6 + 4) = 0;
      *(_DWORD *)(a6 + 8) = 0;
      *(_DWORD *)(a6 + 12) = 0;
      sub_100543D0(a6 + 32, (int)&v8, 8 * v7 + 8);
      sub_10055150((void *)(a6 + 296));
      sub_10056C10(8 * v7 + 8, a6 + 296, &v9[8 * v7]);
      *a5 = v10[8 * v7];
      result = 0;
    }
    else
    {
      result = -102;
    }
  }
  else
  {
    result = -100;
  }
  return result;
}
// 100571B0: using guessed type char var_40[8];
// 100571B0: using guessed type __int16 var_38[26];

//----- (100572E0) --------------------------------------------------------
bool __cdecl sub_100572E0(void *a1, int a2)
{
  bool v2; // bl@3
  int v4; // [sp+Ch] [bp-214h]@5

  v2 = a1 && a2;
  sub_100570D0(&v4, (int)sub_10055170);
  if ( v2 )
    sub_10057120(a2, (int)&v4);
  return v2;
}

//----- (10057360) --------------------------------------------------------
BOOL __usercall sub_10057360@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // ecx@3
  int v4; // ecx@4

  *(_WORD *)(*(_DWORD *)(a1 + 5712) + 2 * *(_DWORD *)(a1 + 5728)) = a3;
  *(_BYTE *)(*(_DWORD *)(a1 + 5716) + (*(_DWORD *)(a1 + 5728))++) = a2;
  if ( a3 )
  {
    ++*(_DWORD *)(a1 + 2920);
    ++*(_WORD *)(a1 + 4 * (unsigned __int8)byte_101191B0[a2] + 3964);
    v3 = a3 - 1;
    if ( v3 >= 0x100 )
      v4 = (unsigned __int8)byte_101190B0[v3 >> 7];
    else
      v4 = (unsigned __int8)byte_10118FB0[v3];
    ++*(_WORD *)(a1 + 4 * v4 + 5228);
  }
  else
  {
    ++*(_WORD *)(a1 + 4 * a2 + 2936);
  }
  return *(_DWORD *)(a1 + 5728) == *(_DWORD *)(a1 + 5724) - 1;
}

//----- (10057400) --------------------------------------------------------
int __usercall sub_10057400@<eax>(int result@<eax>)
{
  signed int v1; // ecx@1
  __int16 v2; // cx@4

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)((*(_DWORD *)(result + 5812))++ + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
    *(_DWORD *)(result + 2932) = 0;
    *(_WORD *)(result + 2924) = 0;
  }
  else if ( v1 >= 8 )
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) -= 8;
    *(_WORD *)(result + 2924) = v2;
  }
  return result;
}

//----- (10057490) --------------------------------------------------------
unsigned int __fastcall sub_10057490(unsigned int a1, int a2)
{
  unsigned int v2; // eax@1
  int v3; // esi@2

  v2 = 0;
  do
  {
    v3 = a1 & 1;
    --a2;
    a1 >>= 1;
    v2 = 2 * (v3 | v2);
  }
  while ( a2 > 0 );
  return v2 >> 1;
}

//----- (100574B0) --------------------------------------------------------
int __usercall sub_100574B0@<eax>(int result@<eax>)
{
  signed int v1; // edx@1
  char v2; // bl@2
  int v3; // edx@2

  v1 = *(_DWORD *)(result + 2932);
  if ( v1 <= 8 )
  {
    if ( v1 > 0 )
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2924);
    v2 = *(_BYTE *)(result + 2925);
    v3 = *(_DWORD *)(result + 5800);
    *(_BYTE *)(++*(_DWORD *)(result + 5812) + v3) = v2;
    ++*(_DWORD *)(result + 5812);
    *(_WORD *)(result + 2924) = 0;
    *(_DWORD *)(result + 2932) = 0;
  }
  return result;
}

//----- (10057540) --------------------------------------------------------
int __usercall sub_10057540@<eax>(int result@<eax>, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // ecx@1
  int v5; // ebp@2
  int v6; // esi@2
  int v7; // ecx@2
  int v8; // edi@3
  int v9; // esi@4
  int v10; // edx@4
  int v11; // ecx@4
  int v12; // edx@4
  int v13; // ecx@4
  int v14; // edx@6
  int v15; // edi@7
  int v16; // edx@7
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edi@9
  int v20; // esi@10
  int v21; // ecx@10
  int v22; // edx@11
  int v23; // ecx@11
  int v24; // edx@11
  int v25; // ecx@11
  unsigned int v26; // ebp@14
  int v27; // edi@15
  int v28; // edx@17
  int v29; // ecx@17
  unsigned __int16 v30; // si@18
  int v31; // edx@18
  int v32; // ecx@18
  int v33; // edx@18
  int v34; // esi@20
  int v35; // ecx@21
  int v36; // ebp@21
  int v37; // edx@22
  int v38; // ecx@22
  int v39; // edx@22
  int v40; // edi@26
  int v41; // ecx@26
  unsigned __int16 v42; // si@27
  int v43; // edx@27
  int v44; // ecx@27
  int v45; // edx@27
  int v46; // [sp+10h] [bp-Ch]@6
  int v47; // [sp+14h] [bp-8h]@6
  int v48; // [sp+14h] [bp-8h]@17
  unsigned int v49; // [sp+18h] [bp-4h]@2

  v3 = a2;
  v4 = 0;
  if ( *(_DWORD *)(result + 5728) )
  {
    do
    {
      v5 = *(_WORD *)(*(_DWORD *)(result + 5712) + 2 * v4);
      v6 = *(_BYTE *)(v4 + *(_DWORD *)(result + 5716));
      v49 = v4 + 1;
      v7 = *(_DWORD *)(result + 2932);
      if ( v5 )
      {
        v14 = (unsigned __int8)byte_101191B0[v6];
        v46 = *(_WORD *)(v3 + 4 * v14 + 1030);
        v47 = (unsigned __int8)byte_101191B0[v6];
        if ( v7 <= 16 - v46 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a2 + 4 * v14 + 1028) << v7;
          *(_DWORD *)(result + 2932) = v46 + v7;
        }
        else
        {
          v15 = *(_WORD *)(a2 + 4 * v14 + 1028);
          v16 = v15 << v7;
          v17 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v16;
          *(_BYTE *)(v17 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v18 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          LOWORD(v15) = (unsigned __int16)v15 >> (16 - v18);
          *(_DWORD *)(result + 2932) = v18 + v46 - 16;
          v14 = v47;
          *(_WORD *)(result + 2924) = v15;
        }
        v19 = dword_101189B8[v14];
        v3 = a2;
        if ( v19 )
        {
          v20 = v6 - dword_101192B0[v14];
          v21 = *(_DWORD *)(result + 2932);
          if ( v21 <= 16 - v19 )
          {
            *(_WORD *)(result + 2924) |= v20 << v21;
            v25 = v19 + v21;
          }
          else
          {
            v22 = v20 << v21;
            v23 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v22;
            *(_BYTE *)(v23 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v24 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v3 = a2;
            v25 = v24 + v19 - 16;
            *(_WORD *)(result + 2924) = (unsigned __int16)v20 >> (16 - v24);
          }
          *(_DWORD *)(result + 2932) = v25;
        }
        v26 = v5 - 1;
        if ( v26 >= 0x100 )
          v27 = (unsigned __int8)byte_101190B0[v26 >> 7];
        else
          v27 = (unsigned __int8)byte_10118FB0[v26];
        v28 = *(_WORD *)(a3 + 4 * v27 + 2);
        v29 = *(_DWORD *)(result + 2932);
        v48 = *(_WORD *)(a3 + 4 * v27 + 2);
        if ( v29 <= 16 - v28 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(a3 + 4 * v27) << v29;
          *(_DWORD *)(result + 2932) = v28 + v29;
        }
        else
        {
          v30 = *(_WORD *)(a3 + 4 * v27);
          v31 = *(_WORD *)(a3 + 4 * v27) << v29;
          v32 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v31;
          *(_BYTE *)(v32 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v33 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v3 = a2;
          *(_DWORD *)(result + 2932) = v33 + v48 - 16;
          *(_WORD *)(result + 2924) = v30 >> (16 - v33);
        }
        v34 = dword_10118A40[v27];
        if ( !v34 )
          goto LABEL_25;
        v35 = *(_DWORD *)(result + 2932);
        v36 = v26 - dword_10119328[v27];
        if ( v35 <= 16 - v34 )
        {
          *(_WORD *)(result + 2924) |= v36 << v35;
          v13 = v34 + v35;
        }
        else
        {
          v37 = v36 << v35;
          v38 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v37;
          *(_BYTE *)(v38 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v39 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v39 + v34 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v36 >> (16 - v39);
        }
      }
      else
      {
        v8 = *(_WORD *)(v3 + 4 * v6 + 2);
        if ( v7 <= 16 - v8 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 4 * v6) << v7;
          v13 = v8 + v7;
        }
        else
        {
          v9 = *(_WORD *)(v3 + 4 * v6);
          v10 = v9 << v7;
          v11 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v10;
          *(_BYTE *)(v11 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v12 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v13 = v12 + v8 - 16;
          *(_WORD *)(result + 2924) = (unsigned __int16)v9 >> (16 - v12);
        }
      }
      *(_DWORD *)(result + 2932) = v13;
LABEL_25:
      v4 = v49;
    }
    while ( v49 < *(_DWORD *)(result + 5728) );
  }
  v40 = *(_WORD *)(v3 + 1026);
  v41 = *(_DWORD *)(result + 2932);
  if ( v41 <= 16 - v40 )
  {
    *(_WORD *)(result + 2924) |= *(_WORD *)(v3 + 1024) << v41;
    *(_DWORD *)(result + 2932) = v40 + v41;
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  else
  {
    v42 = *(_WORD *)(v3 + 1024);
    v43 = *(_WORD *)(v3 + 1024) << v41;
    v44 = *(_DWORD *)(result + 5800);
    *(_WORD *)(result + 2924) |= v43;
    *(_BYTE *)(v44 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
    *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = *(_BYTE *)(result + 2925);
    v45 = *(_DWORD *)(result + 2932);
    ++*(_DWORD *)(result + 5812);
    *(_DWORD *)(result + 2932) = v45 + v40 - 16;
    *(_WORD *)(result + 2924) = v42 >> (16 - v45);
    *(_DWORD *)(result + 2928) = *(_WORD *)(v3 + 1026);
  }
  return result;
}
// 101189B8: using guessed type int dword_101189B8[];
// 10118A40: using guessed type int dword_10118A40[];
// 101192B0: using guessed type int dword_101192B0[];
// 10119328: using guessed type int dword_10119328[];

//----- (100579C0) --------------------------------------------------------
int __usercall sub_100579C0@<eax>(int a1@<eax>, _BYTE *a2@<edx>, int a3@<ecx>)
{
  int v3; // ebx@1
  _BYTE *v4; // edi@1
  int result; // eax@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // edx@1
  int i; // esi@1

  v3 = a3;
  v4 = a2;
  result = sub_100574B0(a1);
  v6 = *(_DWORD *)(result + 5812);
  v7 = *(_DWORD *)(result + 5800);
  *(_DWORD *)(result + 2928) = 8;
  *(_BYTE *)(v6 + v7) = v3;
  v8 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v8) = BYTE1(v3);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~(_BYTE)v3;
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = ~BYTE1(v3);
  for ( i = ++*(_DWORD *)(result + 5812); v3; ++v4 )
  {
    *(_BYTE *)(i + *(_DWORD *)(result + 5800)) = *v4;
    i = ++*(_DWORD *)(result + 5812);
    --v3;
  }
  return result;
}

//----- (10057A70) --------------------------------------------------------
void *__usercall sub_10057A70@<eax>(int a1@<edi>)
{
  void *result; // eax@1
  int v2; // ebx@1
  size_t v3; // esi@1
  bool v4; // zf@4

  result = *(void **)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(v2 + 5812);
  if ( v3 > (unsigned int)result )
    v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    result = memcpy(*(void **)(a1 + 12), *(const void **)(v2 + 5808), v3);
    *(_DWORD *)(a1 + 12) += v3;
    *(_DWORD *)(v2 + 5808) += v3;
    *(_DWORD *)(a1 + 20) += v3;
    *(_DWORD *)(a1 + 16) -= v3;
    v4 = *(_DWORD *)(v2 + 5812) == v3;
    *(_DWORD *)(v2 + 5812) -= v3;
    if ( v4 )
      *(_DWORD *)(v2 + 5808) = *(_DWORD *)(v2 + 5800);
  }
  return result;
}

//----- (10057AD0) --------------------------------------------------------
int __usercall sub_10057AD0@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ecx@1
  int v3; // ebp@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@3
  int v9; // ecx@3
  int v10; // esi@6
  int v11; // ebx@8
  int i; // ecx@13
  int v13; // edx@17
  int v14; // ebx@18
  int v15; // ecx@19
  int v16; // esi@20
  int v17; // [sp+Ch] [bp-20h]@1
  int *v18; // [sp+10h] [bp-1Ch]@2
  int v19; // [sp+10h] [bp-1Ch]@17
  signed int v20; // [sp+14h] [bp-18h]@2
  int v21; // [sp+18h] [bp-14h]@1
  int v22; // [sp+1Ch] [bp-10h]@2
  int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)a2;
  v24 = *(_DWORD *)(v2 + 8);
  v4 = *(_DWORD *)(v2 + 16);
  v21 = *(_DWORD *)v2;
  v25 = *(_DWORD *)(v2 + 4);
  v5 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 28) = 0;
  v23 = v5;
  v6 = 0;
  *(_WORD *)(v3 + 4 * *(_DWORD *)(result + 4 * *(_DWORD *)(result + 2328) + 32) + 2) = 0;
  v7 = *(_DWORD *)(result + 2328) + 1;
  v17 = 0;
  if ( v7 < 573 )
  {
    v18 = (int *)(result + 4 * v7 + 32);
    v22 = 573 - v7;
    v20 = 573;
    do
    {
      v8 = *v18;
      v9 = *(_WORD *)(v3 + 4 * *(_WORD *)(v3 + 4 * *v18 + 2) + 2) + 1;
      if ( v9 > v4 )
      {
        ++v6;
        v9 = v4;
        v17 = v6;
      }
      *(_WORD *)(v3 + 4 * v8 + 2) = v9;
      if ( v8 <= v23 )
      {
        ++*(_WORD *)(result + 2 * v9);
        v10 = 0;
        if ( v8 >= v24 )
          v10 = *(_DWORD *)(v25 + 4 * (v8 - v24));
        v11 = *(_WORD *)(v3 + 4 * v8);
        *(_DWORD *)(result + 2912) += v11 * (v10 + v9);
        if ( v21 )
          *(_DWORD *)(result + 2916) += v11 * (v10 + *(_WORD *)(v21 + 4 * v8 + 2));
        v6 = v17;
      }
      ++v18;
      --v22;
    }
    while ( v22 );
    if ( v6 )
    {
      do
      {
        for ( i = v4 - 1; !*(_WORD *)(result + 2 * i); --i )
          ;
        --*(_WORD *)(result + 2 * i);
        *(_WORD *)(result + 2 * i + 2) += 2;
        --*(_WORD *)(result + 2 * v4);
        v6 -= 2;
      }
      while ( v6 > 0 );
      for ( ; v4; --v4 )
      {
        v13 = *(_WORD *)(result + 2 * v4);
        v19 = *(_WORD *)(result + 2 * v4);
        if ( *(_WORD *)(result + 2 * v4) )
        {
          v14 = result + 4 * v20 + 32;
          do
          {
            v15 = *(_DWORD *)(v14 - 4);
            --v20;
            v14 -= 4;
            if ( v15 <= v23 )
            {
              v16 = *(_WORD *)(v3 + 4 * v15 + 2);
              if ( v16 != v4 )
              {
                *(_DWORD *)(result + 2912) += *(_WORD *)(v3 + 4 * v15) * (v4 - v16);
                *(_WORD *)(v3 + 4 * v15 + 2) = v4;
              }
              v13 = --v19;
            }
          }
          while ( v13 );
        }
      }
    }
  }
  return result;
}

//----- (10057CA0) --------------------------------------------------------
signed int __usercall sub_10057CA0@<eax>(int a1@<edx>, int a2@<ebx>, int a3@<edi>)
{
  __int16 v3; // cx@1
  signed int result; // eax@1
  int v5; // edx@1
  int i; // esi@3
  int v7; // edx@4
  unsigned int v8; // ecx@5
  __int16 v9; // [sp+4h] [bp-24h]@2
  char v10; // [sp+6h] [bp-22h]@1

  v3 = 0;
  result = 1;
  v5 = a1 - (_DWORD)&v10;
  do
  {
    v3 = 2 * (v3 + *(__int16 *)((char *)&v9 + 2 * result + v5));
    *(&v9 + result++) = v3;
  }
  while ( result <= 15 );
  for ( i = 0; i <= a2; ++i )
  {
    v7 = *(_WORD *)(a3 + 4 * i + 2);
    if ( *(_WORD *)(a3 + 4 * i + 2) )
    {
      v8 = (unsigned __int16)(*(&v9 + v7))++;
      result = sub_10057490(v8, v7);
      *(_WORD *)(a3 + 4 * i) = result;
    }
  }
  return result;
}

//----- (10057D20) --------------------------------------------------------
_WORD *__fastcall sub_10057D20(int a1, int a2)
{
  _WORD *v2; // eax@1
  signed int v3; // ecx@1
  _WORD *v4; // eax@3
  signed int v5; // ecx@3
  _WORD *result; // eax@5
  signed int v7; // ecx@5

  v2 = (_WORD *)(a2 + 2936);
  v3 = 286;
  do
  {
    *v2 = 0;
    v2 += 2;
    --v3;
  }
  while ( v3 );
  v4 = (_WORD *)(a2 + 5228);
  v5 = 30;
  do
  {
    *v4 = 0;
    v4 += 2;
    --v5;
  }
  while ( v5 );
  result = (_WORD *)(a2 + 5472);
  v7 = 19;
  do
  {
    *result = 0;
    result += 2;
    --v7;
  }
  while ( v7 );
  *(_DWORD *)(a2 + 2916) = 0;
  *(_DWORD *)(a2 + 2912) = 0;
  *(_DWORD *)(a2 + 2920) = 0;
  *(_DWORD *)(a2 + 5728) = 0;
  *(_WORD *)(a2 + 3960) = 1;
  return result;
}

//----- (10057D90) --------------------------------------------------------
signed int __usercall sub_10057D90@<eax>(int a1@<esi>)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // eax@1
  int v4; // edx@1
  signed int result; // eax@1

  v1 = *(_DWORD *)(a1 + 5764);
  v2 = *(_DWORD *)(a1 + 5736);
  *(_DWORD *)(a1 + 5744) = 2 * *(_DWORD *)(a1 + 5748);
  *(_WORD *)(v2 + 2 * v1 - 2) = 0;
  memset(*(void **)(a1 + 5736), 0, 2 * *(_DWORD *)(a1 + 5764) - 2);
  v3 = 6 * *(_BYTE *)(a1 + 5784);
  *(_DWORD *)(a1 + 5700) = (unsigned __int16)word_101193A2[6 * *(_BYTE *)(a1 + 5784)];
  *(_DWORD *)(a1 + 5704) = (unsigned __int16)word_101193A0[v3];
  *(_DWORD *)(a1 + 5708) = (unsigned __int16)word_101193A4[v3];
  v4 = (unsigned __int16)word_101193A6[v3];
  result = 2;
  *(_DWORD *)(a1 + 5680) = 0;
  *(_DWORD *)(a1 + 5664) = 0;
  *(_DWORD *)(a1 + 5688) = 0;
  *(_DWORD *)(a1 + 5676) = 0;
  *(_DWORD *)(a1 + 5760) = 0;
  *(_DWORD *)(a1 + 5696) = v4;
  *(_DWORD *)(a1 + 5692) = 2;
  *(_DWORD *)(a1 + 5668) = 2;
  return result;
}
// 101193A0: using guessed type __int16 word_101193A0[];
// 101193A2: using guessed type __int16 word_101193A2[];
// 101193A4: using guessed type __int16 word_101193A4[];
// 101193A6: using guessed type __int16 word_101193A6[];

//----- (10057E50) --------------------------------------------------------
unsigned int __usercall sub_10057E50@<eax>(int a1@<esi>, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // edi@1
  int v6; // ecx@4
  unsigned int v7; // ebx@4
  int v8; // edx@8
  char v9; // al@11
  int v10; // edx@11
  unsigned int v11; // ecx@12
  _BYTE *v12; // edx@12
  char v13; // al@13
  _BYTE *v14; // edx@13
  char v15; // al@14
  _BYTE *v16; // edx@14
  char v17; // al@15
  _BYTE *v18; // edx@15
  char v19; // al@16
  _BYTE *v20; // edx@16
  char v21; // al@17
  _BYTE *v22; // edx@17
  char v23; // al@18
  _BYTE *v24; // edx@18
  char v25; // al@19
  _BYTE *v26; // edx@19
  char v27; // al@20
  int v28; // edx@22
  unsigned int result; // eax@27
  char v30; // [sp+Fh] [bp-11h]@4
  unsigned int v31; // [sp+10h] [bp-10h]@1
  int v32; // [sp+14h] [bp-Ch]@4
  unsigned int v33; // [sp+18h] [bp-8h]@2
  char v34; // [sp+24h] [bp+4h]@4

  v2 = *(_DWORD *)(a1 + 5748);
  v3 = *(_DWORD *)(a1 + 5680);
  v4 = a2;
  v31 = *(_DWORD *)(a1 + 5696);
  v5 = *(_DWORD *)(a1 + 5692);
  if ( v3 <= v2 - 262 )
    v33 = 0;
  else
    v33 = v3 - v2 + 262;
  v6 = *(_DWORD *)(a1 + 5740) + v3;
  v34 = *(_BYTE *)(v6 + v5 - 1);
  v32 = *(_DWORD *)(a1 + 5708);
  v7 = v6 + 258;
  v30 = *(_BYTE *)(v6 + v5);
  if ( v5 >= *(_DWORD *)(a1 + 5704) )
    v31 >>= 2;
  if ( *(_DWORD *)(a1 + 5708) > *(_DWORD *)(a1 + 5688) )
    v32 = *(_DWORD *)(a1 + 5688);
  do
  {
    v8 = v4 + *(_DWORD *)(a1 + 5740);
    if ( *(_BYTE *)(v8 + v5) == v30 && *(_BYTE *)(v8 + v5 - 1) == v34 && *(_BYTE *)v8 == *(_BYTE *)v6 )
    {
      v9 = *(_BYTE *)(v8 + 1);
      v10 = v8 + 1;
      if ( v9 == *(_BYTE *)(v6 + 1) )
      {
        v11 = v6 + 2;
        v12 = (_BYTE *)(v10 + 1);
        do
        {
          v13 = *(_BYTE *)(v11++ + 1);
          v14 = v12 + 1;
          if ( v13 != *v14 )
            break;
          v15 = *(_BYTE *)(v11++ + 1);
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *(_BYTE *)(v11++ + 1);
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *(_BYTE *)(v11++ + 1);
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *(_BYTE *)(v11++ + 1);
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *(_BYTE *)(v11++ + 1);
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *(_BYTE *)(v11++ + 1);
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *(_BYTE *)(v11++ + 1);
          v12 = v26 + 1;
          if ( v27 != *v12 )
            break;
        }
        while ( v11 < v7 );
        v28 = v11 - v7 + 258;
        v6 = v7 - 258;
        if ( v28 > (signed int)v5 )
        {
          *(_DWORD *)(a1 + 5684) = v4;
          v5 = v28;
          if ( v28 >= v32 )
            break;
          v34 = *(_BYTE *)(v28 + v6 - 1);
          v30 = *(_BYTE *)(v28 + v6);
        }
      }
    }
    v4 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & *(_DWORD *)(a1 + 5756)));
    if ( v4 <= v33 )
      break;
    --v31;
  }
  while ( v31 );
  result = *(_DWORD *)(a1 + 5688);
  if ( v5 <= result )
    result = v5;
  return result;
}

//----- (10058000) --------------------------------------------------------
unsigned int __usercall sub_10058000@<eax>(int a1@<esi>, int a2)
{
  int v2; // ecx@1
  char v3; // dl@1
  int v4; // eax@1
  int v5; // ecx@1
  unsigned int v6; // edi@1
  unsigned int v7; // eax@3
  _BYTE *v8; // ecx@3
  char v9; // dl@4
  _BYTE *v10; // ecx@4
  char v11; // dl@5
  _BYTE *v12; // ecx@5
  char v13; // dl@6
  _BYTE *v14; // ecx@6
  char v15; // dl@7
  _BYTE *v16; // ecx@7
  char v17; // dl@8
  _BYTE *v18; // ecx@8
  char v19; // dl@9
  _BYTE *v20; // ecx@9
  char v21; // dl@10
  _BYTE *v22; // ecx@10
  char v23; // dl@11
  unsigned int v24; // ecx@13
  unsigned int result; // eax@13

  v2 = *(_DWORD *)(a1 + 5740);
  v3 = *(_BYTE *)(v2 + a2);
  v4 = v2 + *(_DWORD *)(a1 + 5680);
  v5 = a2 + v2;
  v6 = v4 + 258;
  if ( v3 != *(_BYTE *)v4 || *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1) )
  {
    result = 2;
  }
  else
  {
    v7 = v4 + 2;
    v8 = (_BYTE *)(v5 + 2);
    do
    {
      v9 = *(_BYTE *)(v7++ + 1);
      v10 = v8 + 1;
      if ( v9 != *v10 )
        break;
      v11 = *(_BYTE *)(v7++ + 1);
      v12 = v10 + 1;
      if ( v11 != *v12 )
        break;
      v13 = *(_BYTE *)(v7++ + 1);
      v14 = v12 + 1;
      if ( v13 != *v14 )
        break;
      v15 = *(_BYTE *)(v7++ + 1);
      v16 = v14 + 1;
      if ( v15 != *v16 )
        break;
      v17 = *(_BYTE *)(v7++ + 1);
      v18 = v16 + 1;
      if ( v17 != *v18 )
        break;
      v19 = *(_BYTE *)(v7++ + 1);
      v20 = v18 + 1;
      if ( v19 != *v20 )
        break;
      v21 = *(_BYTE *)(v7++ + 1);
      v22 = v20 + 1;
      if ( v21 != *v22 )
        break;
      v23 = *(_BYTE *)(v7++ + 1);
      v8 = v22 + 1;
      if ( v23 != *v8 )
        break;
    }
    while ( v7 < v6 );
    v24 = *(_DWORD *)(a1 + 5688);
    result = v7 - v6 + 258;
    *(_DWORD *)(a1 + 5684) = a2;
    if ( result > v24 )
      result = v24;
  }
  return result;
}

//----- (100580D0) --------------------------------------------------------
int __usercall sub_100580D0@<eax>(int result@<eax>, int a2@<edi>, int a3)
{
  int v3; // edx@1
  int v4; // ebp@1
  int v5; // ecx@1
  bool v6; // sf@1
  unsigned __int8 v7; // of@1
  int v8; // esi@3
  int v9; // ebp@3
  unsigned __int16 v10; // dx@3
  unsigned __int16 v11; // bx@3
  int v12; // esi@8
  unsigned __int16 v13; // dx@8
  unsigned __int16 v14; // bx@8
  int v15; // edx@11
  int v16; // [sp+8h] [bp-4h]@1

  v3 = *(_DWORD *)(result + 2324);
  v4 = *(_DWORD *)(result + 4 * a3 + 32);
  v5 = 2 * a3;
  v7 = __OFSUB__(2 * a3, v3);
  v6 = 2 * a3 - v3 < 0;
  v16 = *(_DWORD *)(result + 4 * a3 + 32);
  if ( 2 * a3 > v3 )
  {
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  else
  {
    while ( 1 )
    {
      if ( v6 ^ v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v5 + 36);
        v9 = *(_DWORD *)(result + 4 * v5 + 32);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 2332) <= *(_BYTE *)(result + v9 + 2332) )
          ++v5;
        v4 = v16;
      }
      v12 = *(_DWORD *)(result + 4 * v5 + 32);
      v13 = *(_WORD *)(a2 + 4 * v4);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 32) = v4;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v4 + 2332) <= *(_BYTE *)(v12 + result + 2332) )
        break;
      *(_DWORD *)(result + 4 * a3 + 32) = v12;
      v15 = *(_DWORD *)(result + 2324);
      a3 = v5;
      v5 *= 2;
      v7 = __OFSUB__(v5, v15);
      v6 = v5 - v15 < 0;
      if ( v5 > v15 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 32) = v4;
  }
  return result;
}

//----- (10058180) --------------------------------------------------------
int __usercall sub_10058180@<eax>(int result@<eax>, __int16 a2@<cx>)
{
  int v2; // edi@1

  *(_BYTE *)(*(_DWORD *)(result + 5800) + *(_DWORD *)(result + 5812)) = HIBYTE(a2);
  v2 = *(_DWORD *)(result + 5800);
  *(_BYTE *)(++*(_DWORD *)(result + 5812) + v2) = a2;
  ++*(_DWORD *)(result + 5812);
  return result;
}

//----- (100581C0) --------------------------------------------------------
unsigned int __usercall sub_100581C0@<eax>(unsigned int a1@<edx>, int a2@<esi>, void *a3)
{
  int v3; // ecx@1
  unsigned int v4; // edi@1
  unsigned int result; // eax@4

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a2 + 4);
  if ( v4 > a1 )
    v4 = a1;
  if ( v4 )
  {
    *(_DWORD *)(a2 + 4) -= v4;
    if ( *(_DWORD *)(v3 + 5780) == 1 )
      *(_DWORD *)(a2 + 28) = sub_10034AE0(*(_DWORD *)(a2 + 28), *(_BYTE **)a2, v4);
    memcpy(a3, *(const void **)a2, v4);
    *(_DWORD *)a2 += v4;
    *(_DWORD *)(a2 + 8) += v4;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10058220) --------------------------------------------------------
signed int __usercall sub_10058220@<eax>(signed int result@<eax>, int a2@<ecx>, int a3)
{
  signed int v3; // edi@1
  signed int v4; // edx@1
  signed int v5; // ebp@1
  int v6; // ebx@1
  signed int v7; // ecx@1
  signed int v8; // esi@1
  _WORD *v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@4

  v3 = *(_WORD *)(result + 2);
  v4 = 0;
  v5 = -1;
  v6 = a2;
  v7 = 7;
  v8 = 4;
  if ( !*(_WORD *)(result + 2) )
  {
    v7 = 138;
    v8 = 3;
  }
  *(_WORD *)(result + 4 * v6 + 6) = -1;
  if ( v6 >= 0 )
  {
    v10 = v6 + 1;
    v9 = (_WORD *)(result + 6);
    do
    {
      result = v3;
      v3 = *v9;
      if ( ++v4 >= v7 || result != v3 )
      {
        if ( v4 >= v8 )
        {
          if ( result )
          {
            if ( result != v5 )
              ++*(_WORD *)(a3 + 4 * result + 5472);
            ++*(_WORD *)(a3 + 5536);
          }
          else if ( v4 > 10 )
          {
            ++*(_WORD *)(a3 + 5544);
          }
          else
          {
            ++*(_WORD *)(a3 + 5540);
          }
        }
        else
        {
          *(_WORD *)(a3 + 4 * result + 5472) += v4;
        }
        v4 = 0;
        v5 = result;
        if ( v3 )
        {
          if ( result == v3 )
          {
            v7 = 6;
            v8 = 3;
          }
          else
          {
            v7 = 7;
            v8 = 4;
          }
        }
        else
        {
          v7 = 138;
          v8 = 3;
        }
      }
      v9 += 2;
      --v10;
    }
    while ( v10 );
  }
  return result;
}

//----- (10058300) --------------------------------------------------------
int __usercall sub_10058300@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>)
{
  signed int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // ecx@1
  signed int v6; // edi@1
  signed int v7; // edx@5
  int v8; // edi@8
  int v9; // ecx@8
  unsigned __int16 v10; // si@9
  int v11; // edx@9
  int v12; // ecx@9
  int v13; // edx@9
  __int16 v14; // si@9
  int v15; // ecx@9
  int v16; // ecx@15
  unsigned __int16 v17; // si@16
  int v18; // edi@16
  int v19; // ecx@16
  int v20; // ebx@16
  int v21; // ecx@16
  int v22; // ecx@19
  unsigned __int16 v23; // si@20
  int v24; // edi@20
  int v25; // ecx@20
  int v26; // ebx@20
  int v27; // ecx@20
  int v28; // esi@22
  int v29; // edi@23
  int v30; // ecx@23
  int v31; // ebx@23
  int v32; // ecx@24
  int v33; // ecx@25
  unsigned __int16 v34; // si@27
  int v35; // edi@27
  int v36; // ecx@27
  int v37; // ebx@27
  int v38; // ecx@27
  int v39; // esi@29
  int v40; // edi@30
  int v41; // ecx@30
  int v42; // ebx@30
  unsigned __int16 v43; // si@33
  int v44; // edi@33
  int v45; // ecx@33
  int v46; // ebx@33
  int v47; // ecx@33
  int v48; // esi@35
  int v49; // edi@36
  int v50; // ecx@36
  int v51; // ebx@36
  signed int v52; // [sp+10h] [bp-18h]@5
  signed int v53; // [sp+14h] [bp-14h]@1
  _WORD *v54; // [sp+18h] [bp-10h]@4
  signed int v55; // [sp+1Ch] [bp-Ch]@1
  int v56; // [sp+1Ch] [bp-Ch]@15
  int v57; // [sp+1Ch] [bp-Ch]@19
  int v58; // [sp+1Ch] [bp-Ch]@26
  int v59; // [sp+1Ch] [bp-Ch]@32
  int v60; // [sp+20h] [bp-8h]@4
  signed int v61; // [sp+24h] [bp-4h]@5

  v3 = 0;
  v4 = a3;
  v5 = 7;
  v6 = 4;
  v53 = *(_WORD *)(a2 + 2);
  v55 = -1;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( v4 >= 0 )
  {
    v54 = (_WORD *)(a2 + 6);
    v60 = v4 + 1;
    do
    {
      v7 = v53;
      ++v3;
      v61 = v53;
      v53 = *v54;
      v52 = v3;
      if ( v3 < v5 && v7 == *v54 )
        goto LABEL_44;
      if ( v3 < v6 )
      {
        do
        {
          v8 = *(_WORD *)(result + 4 * v7 + 5474);
          v9 = *(_DWORD *)(result + 2932);
          if ( v9 <= 16 - v8 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v15 = v8 + v9;
          }
          else
          {
            v10 = *(_WORD *)(result + 4 * v7 + 5472);
            v11 = *(_WORD *)(result + 4 * v7 + 5472) << v9;
            v12 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v11;
            *(_BYTE *)(v12 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v13 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v14 = v10 >> (16 - v13);
            v15 = v13 + v8 - 16;
            v7 = v61;
            *(_WORD *)(result + 2924) = v14;
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v15;
          v52 = v3;
        }
        while ( v3 );
        goto LABEL_39;
      }
      if ( v7 )
      {
        if ( v7 != v55 )
        {
          v16 = *(_DWORD *)(result + 2932);
          v56 = *(_WORD *)(result + 4 * v7 + 5474);
          if ( v16 <= 16 - v56 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v21 = v56 + v16;
          }
          else
          {
            v17 = *(_WORD *)(result + 4 * v7 + 5472);
            v18 = *(_WORD *)(result + 4 * v7 + 5472) << v16;
            v19 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v18;
            *(_BYTE *)(v19 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v20 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v21 = v20 + v56 - 16;
            *(_WORD *)(result + 2924) = v17 >> (16 - v20);
            v3 = v52;
          }
          --v3;
          *(_DWORD *)(result + 2932) = v21;
          v52 = v3;
        }
        v22 = *(_DWORD *)(result + 2932);
        v57 = *(_WORD *)(result + 5538);
        if ( v22 <= 16 - v57 )
        {
          *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5536) << v22;
          v27 = v57 + v22;
        }
        else
        {
          v23 = *(_WORD *)(result + 5536);
          v24 = *(_WORD *)(result + 5536) << v22;
          v25 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v24;
          *(_BYTE *)(v25 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v26 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          v27 = v26 + v57 - 16;
          *(_WORD *)(result + 2924) = v23 >> (16 - v26);
          v3 = v52;
        }
        v28 = v3 - 3;
        *(_DWORD *)(result + 2932) = v27;
        if ( v27 > 14 )
        {
          v29 = v28 << v27;
          v30 = *(_DWORD *)(result + 5800);
          *(_WORD *)(result + 2924) |= v29;
          *(_BYTE *)(v30 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
          *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
          v31 = *(_DWORD *)(result + 2932);
          ++*(_DWORD *)(result + 5812);
          *(_DWORD *)(result + 2932) = v31 - 14;
          *(_WORD *)(result + 2924) = (unsigned __int16)v28 >> (16 - v31);
          goto LABEL_39;
        }
        *(_WORD *)(result + 2924) |= v28 << v27;
        v32 = v27 + 2;
      }
      else
      {
        v33 = *(_DWORD *)(result + 2932);
        if ( v3 > 10 )
        {
          v59 = *(_WORD *)(result + 5546);
          if ( v33 <= 16 - v59 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5544) << v33;
            v47 = v59 + v33;
          }
          else
          {
            v43 = *(_WORD *)(result + 5544);
            v44 = *(_WORD *)(result + 5544) << v33;
            v45 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v44;
            *(_BYTE *)(v45 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v46 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v47 = v46 + v59 - 16;
            *(_WORD *)(result + 2924) = v43 >> (16 - v46);
            v3 = v52;
          }
          v48 = v3 - 11;
          *(_DWORD *)(result + 2932) = v47;
          if ( v47 > 9 )
          {
            v49 = v48 << v47;
            v50 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v49;
            *(_BYTE *)(v50 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v51 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v51 - 9;
            *(_WORD *)(result + 2924) = (unsigned __int16)v48 >> (16 - v51);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v48 << v47;
          v32 = v47 + 7;
        }
        else
        {
          v58 = *(_WORD *)(result + 5542);
          if ( v33 <= 16 - v58 )
          {
            *(_WORD *)(result + 2924) |= *(_WORD *)(result + 5540) << v33;
            v38 = v58 + v33;
          }
          else
          {
            v34 = *(_WORD *)(result + 5540);
            v35 = *(_WORD *)(result + 5540) << v33;
            v36 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v35;
            *(_BYTE *)(v36 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v37 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            v38 = v37 + v58 - 16;
            *(_WORD *)(result + 2924) = v34 >> (16 - v37);
            v3 = v52;
          }
          v39 = v3 - 3;
          *(_DWORD *)(result + 2932) = v38;
          if ( v38 > 13 )
          {
            v40 = v39 << v38;
            v41 = *(_DWORD *)(result + 5800);
            *(_WORD *)(result + 2924) |= v40;
            *(_BYTE *)(v41 + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
            *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
            v42 = *(_DWORD *)(result + 2932);
            ++*(_DWORD *)(result + 5812);
            *(_DWORD *)(result + 2932) = v42 - 13;
            *(_WORD *)(result + 2924) = (unsigned __int16)v39 >> (16 - v42);
            goto LABEL_39;
          }
          *(_WORD *)(result + 2924) |= v39 << v38;
          v32 = v38 + 3;
        }
      }
      *(_DWORD *)(result + 2932) = v32;
LABEL_39:
      v3 = 0;
      v55 = v7;
      if ( v53 )
      {
        if ( v7 == v53 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v54 += 2;
      --v60;
    }
    while ( v60 );
  }
  return result;
}

//----- (100588A0) --------------------------------------------------------
_WORD *__fastcall sub_100588A0(int a1, int a2)
{
  *(_DWORD *)(a2 + 5628) = a2 + 2936;
  *(_DWORD *)(a2 + 5652) = a2 + 5472;
  *(_DWORD *)(a2 + 5636) = &off_10119554;
  *(_DWORD *)(a2 + 5640) = a2 + 5228;
  *(_DWORD *)(a2 + 5648) = &off_10119568;
  *(_DWORD *)(a2 + 5660) = &unk_1011957C;
  *(_WORD *)(a2 + 2924) = 0;
  *(_DWORD *)(a2 + 2932) = 0;
  *(_DWORD *)(a2 + 2928) = 8;
  return sub_10057D20(a2 + 5228, a2);
}
// 10119554: using guessed type void *off_10119554;
// 10119568: using guessed type void *off_10119568;

//----- (10058900) --------------------------------------------------------
signed int __cdecl sub_10058900(int a1)
{
  int v1; // esi@2
  int v2; // eax@3
  int v3; // ecx@5
  signed int result; // eax@5

  if ( a1 && (v1 = *(_DWORD *)(a1 + 24)) != 0 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(v1 + 5808) = *(_DWORD *)(v1 + 5800);
    v2 = *(_DWORD *)(v1 + 5780);
    *(_DWORD *)(v1 + 5812) = 0;
    if ( v2 < 0 )
      *(_DWORD *)(v1 + 5780) = -v2;
    *(_DWORD *)(v1 + 5788) = *(_DWORD *)(v1 + 5780) != 0 ? 42 : 113;
    *(_DWORD *)(a1 + 28) = sub_10034AE0(0, 0, 0);
    *(_DWORD *)(v1 + 5792) = 0;
    sub_100588A0(v3, v1);
    sub_10057D90(v1);
    result = 0;
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (10058990) --------------------------------------------------------
int __usercall sub_10058990@<eax>(int a1@<eax>)
{
  signed int v1; // ecx@1
  int v2; // edx@2
  signed int v3; // ecx@4
  int v4; // edx@5
  int result; // eax@7
  signed int v6; // ecx@7
  int v7; // edx@9
  signed int v8; // ecx@11
  int v9; // edx@12

  v1 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) |= 2 << v1;
  if ( v1 <= 13 )
  {
    *(_DWORD *)(a1 + 2932) = v1 + 3;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v2 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v2 - 13;
    *(_WORD *)(a1 + 2924) = 2u >> (16 - v2);
  }
  v3 = *(_DWORD *)(a1 + 2932);
  *(_WORD *)(a1 + 2924) = *(_WORD *)(a1 + 2924);
  if ( v3 <= 9 )
  {
    *(_DWORD *)(a1 + 2932) = v3 + 7;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 5800) + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v4 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v4 - 9;
    *(_WORD *)(a1 + 2924) = 0;
  }
  result = sub_10057400(a1);
  v6 = *(_DWORD *)(result + 2932);
  if ( *(_DWORD *)(result + 2928) - v6 + 11 < 9 )
  {
    *(_WORD *)(result + 2924) |= 2 << v6;
    if ( v6 <= 13 )
    {
      *(_DWORD *)(result + 2932) = v6 + 3;
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v7 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v7 - 13;
      *(_WORD *)(result + 2924) = 2u >> (16 - v7);
    }
    v8 = *(_DWORD *)(result + 2932);
    *(_WORD *)(result + 2924) = *(_WORD *)(result + 2924);
    if ( v8 > 9 )
    {
      *(_BYTE *)(*(_DWORD *)(result + 5800) + (*(_DWORD *)(result + 5812))++) = *(_BYTE *)(result + 2924);
      *(_BYTE *)(*(_DWORD *)(result + 5812) + *(_DWORD *)(result + 5800)) = *(_BYTE *)(result + 2925);
      v9 = *(_DWORD *)(result + 2932);
      ++*(_DWORD *)(result + 5812);
      *(_DWORD *)(result + 2932) = v9 - 9;
      *(_WORD *)(result + 2924) = 0;
      result = sub_10057400(result);
      *(_DWORD *)(result + 2928) = 7;
      return result;
    }
    *(_DWORD *)(result + 2932) = v8 + 7;
    result = sub_10057400(result);
  }
  *(_DWORD *)(result + 2928) = 7;
  return result;
}

//----- (10058BD0) --------------------------------------------------------
int __usercall sub_10058BD0@<eax>(int a1@<eax>, int a2@<ecx>, _BYTE *a3, int a4)
{
  int v4; // esi@1
  signed int v5; // ecx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  int result; // eax@2

  v4 = a2;
  v5 = *(_DWORD *)(a1 + 2932);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 2924) |= v4 << v5;
    *(_DWORD *)(a1 + 2932) = v5 + 3;
    result = sub_100579C0(a1, a3, a4);
  }
  else
  {
    v6 = v4 << v5;
    v7 = *(_DWORD *)(a1 + 5800);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + (*(_DWORD *)(a1 + 5812))++) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) = (unsigned __int16)v4 >> (16 - v8);
    *(_DWORD *)(a1 + 2932) = v8 - 13;
    result = sub_100579C0(a1, a3, a4);
  }
  return result;
}

//----- (10058C70) --------------------------------------------------------
signed int __usercall sub_10058C70@<eax>(int a1@<esi>, int a2)
{
  int v2; // eax@1
  int v3; // ebp@1
  signed int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  signed int v7; // eax@8
  signed int i; // ebp@14
  int v9; // ebx@16
  int v10; // eax@17
  int v11; // edx@17
  int v12; // ebp@17
  int v13; // eax@17
  unsigned __int8 v14; // cl@17
  int v16; // [sp+Ch] [bp-8h]@1
  int v17; // [sp+10h] [bp-4h]@1

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)v2;
  v17 = *(_DWORD *)(v2 + 12);
  v4 = -1;
  v5 = *(_DWORD *)a2;
  v6 = 0;
  v16 = -1;
  *(_DWORD *)(a1 + 2324) = 0;
  for ( *(_DWORD *)(a1 + 2328) = 573; v6 < v17; ++v6 )
  {
    if ( *(_WORD *)(v5 + 4 * v6) )
    {
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v6;
      v16 = v6;
      *(_BYTE *)(v6 + a1 + 2332) = 0;
      v4 = v6;
    }
    else
    {
      *(_WORD *)(v5 + 4 * v6 + 2) = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 2324) < 2 )
  {
    do
    {
      if ( v4 >= 2 )
        v7 = 0;
      else
        v7 = ++v4;
      *(_DWORD *)(a1 + 4 * ++*(_DWORD *)(a1 + 2324) + 32) = v7;
      *(_WORD *)(v5 + 4 * v7) = 1;
      *(_BYTE *)(a1 + v7 + 2332) = 0;
      --*(_DWORD *)(a1 + 2912);
      if ( v3 )
        *(_DWORD *)(a1 + 2916) -= *(_WORD *)(v3 + 4 * v7 + 2);
    }
    while ( *(_DWORD *)(a1 + 2324) < 2 );
    v16 = v4;
  }
  *(_DWORD *)(a2 + 4) = v4;
  for ( i = *(_DWORD *)(a1 + 2324) / 2; i >= 1; --i )
    sub_100580D0(a1, v5, i);
  v9 = v17;
  do
  {
    v10 = *(_DWORD *)(a1 + 2324);
    v11 = *(_DWORD *)(a1 + 4 * v10 + 32);
    v12 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 2324) = v10 - 1;
    *(_DWORD *)(a1 + 36) = v11;
    sub_100580D0(a1, v5, 1);
    v13 = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v12;
    *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = v13;
    *(_WORD *)(v5 + 4 * v9) = *(_WORD *)(v5 + 4 * v12) + *(_WORD *)(v5 + 4 * v13);
    v14 = *(_BYTE *)(a1 + v13 + 2332);
    if ( *(_BYTE *)(a1 + v12 + 2332) >= v14 )
      v14 = *(_BYTE *)(a1 + v12 + 2332);
    *(_BYTE *)(a1 + v9 + 2332) = v14 + 1;
    *(_WORD *)(v5 + 4 * v13 + 2) = v9;
    *(_WORD *)(v5 + 4 * v12 + 2) = v9;
    *(_DWORD *)(a1 + 36) = v9++;
    sub_100580D0(a1, v5, 1);
  }
  while ( *(_DWORD *)(a1 + 2324) >= 2 );
  *(_DWORD *)(a1 + 4 * --*(_DWORD *)(a1 + 2328) + 32) = *(_DWORD *)(a1 + 36);
  sub_10057AD0(a1, a2);
  return sub_10057CA0(a1, v16, v5);
}

//----- (10058E50) --------------------------------------------------------
unsigned int __usercall sub_10058E50@<eax>(int a1@<edi>)
{
  size_t v1; // ebx@1
  unsigned int result; // eax@2
  unsigned int v3; // ebp@2
  int v4; // edx@3
  int v5; // eax@3
  _WORD *v6; // ecx@3
  int v7; // eax@4
  __int16 v8; // ax@5
  size_t v9; // edx@8
  _WORD *v10; // ecx@8
  int v11; // eax@9
  int v12; // esi@14
  unsigned int v13; // edx@15
  int v14; // esi@16
  int v15; // eax@16
  int v16; // ecx@16

  v1 = *(_DWORD *)(a1 + 5748);
  do
  {
    result = *(_DWORD *)(a1 + 5680);
    v3 = *(_DWORD *)(a1 + 5744) - result - *(_DWORD *)(a1 + 5688);
    if ( result >= v1 + *(_DWORD *)(a1 + 5748) - 262 )
    {
      memcpy(*(void **)(a1 + 5740), (const void *)(*(_DWORD *)(a1 + 5740) + v1), v1);
      v4 = *(_DWORD *)(a1 + 5764);
      v5 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5684) -= v1;
      *(_DWORD *)(a1 + 5680) -= v1;
      *(_DWORD *)(a1 + 5664) -= v1;
      v6 = (_WORD *)(v5 + 2 * v4);
      do
      {
        v7 = *(v6 - 1);
        --v6;
        if ( v7 < v1 )
          v8 = 0;
        else
          v8 = v7 - v1;
        --v4;
        *v6 = v8;
      }
      while ( v4 );
      v9 = v1;
      v10 = (_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * v1);
      do
      {
        v11 = *(v10 - 1);
        --v10;
        if ( v11 < v1 )
          result = 0;
        else
          result = v11 - v1;
        --v9;
        *v10 = result;
      }
      while ( v9 );
      v3 += v1;
    }
    v12 = *(_DWORD *)(a1 + 2908);
    if ( !*(_DWORD *)(v12 + 4) )
      break;
    result = sub_100581C0(v3, v12, (void *)(*(_DWORD *)(a1 + 5688) + *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)));
    *(_DWORD *)(a1 + 5688) += result;
    v13 = *(_DWORD *)(a1 + 5688);
    if ( v13 >= 3 )
    {
      v14 = *(_DWORD *)(a1 + 5680) + *(_DWORD *)(a1 + 5740);
      v15 = *(_BYTE *)v14;
      v16 = *(_DWORD *)(a1 + 5776);
      *(_DWORD *)(a1 + 5760) = v15;
      result = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v14 + 1) ^ (v15 << v16));
      *(_DWORD *)(a1 + 5760) = result;
    }
  }
  while ( v13 < 0x106 && *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 4) );
  return result;
}

//----- (10058F90) --------------------------------------------------------
int __usercall sub_10058F90@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // edx@2
  signed int v9; // ecx@4
  int v10; // edx@5
  int v11; // ecx@5
  int v12; // edx@5
  signed int v13; // ecx@7
  int v14; // edx@8
  int v15; // ecx@8
  int v16; // edx@8
  int i; // edi@10
  signed int v18; // ecx@11
  int v19; // edx@11
  unsigned __int16 v20; // si@12
  int v21; // edx@12
  int v22; // ecx@12
  int v23; // edx@12
  int v24; // eax@15

  v4 = *(_DWORD *)(a1 + 2932);
  v5 = a4;
  if ( v4 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a2 - 257) << v4;
    *(_DWORD *)(a1 + 2932) = v4 + 5;
  }
  else
  {
    v6 = (a2 - 257) << v4;
    v7 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v8 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    v5 = a4;
    *(_DWORD *)(a1 + 2932) = v8 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a2 - 257) >> (16 - v8);
  }
  v9 = *(_DWORD *)(a1 + 2932);
  if ( v9 <= 11 )
  {
    *(_WORD *)(a1 + 2924) |= (a3 - 1) << v9;
    *(_DWORD *)(a1 + 2932) = v9 + 5;
  }
  else
  {
    v10 = (a3 - 1) << v9;
    v11 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v10;
    *(_BYTE *)(v11 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v12 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v12 - 11;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(a3 - 1) >> (16 - v12);
  }
  v13 = *(_DWORD *)(a1 + 2932);
  if ( v13 <= 12 )
  {
    *(_WORD *)(a1 + 2924) |= (v5 - 4) << v13;
    *(_DWORD *)(a1 + 2932) = v13 + 4;
  }
  else
  {
    v14 = (v5 - 4) << v13;
    v15 = *(_DWORD *)(a1 + 5812);
    *(_WORD *)(a1 + 2924) |= v14;
    *(_BYTE *)(v15 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
    *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
    v16 = *(_DWORD *)(a1 + 2932);
    ++*(_DWORD *)(a1 + 5812);
    *(_DWORD *)(a1 + 2932) = v16 - 12;
    *(_WORD *)(a1 + 2924) = (unsigned __int16)(v5 - 4) >> (16 - v16);
  }
  for ( i = 0; i < v5; ++i )
  {
    v18 = *(_DWORD *)(a1 + 2932);
    v19 = (unsigned __int8)byte_10118A2C[i];
    if ( v18 <= 13 )
    {
      *(_WORD *)(a1 + 2924) |= *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      *(_DWORD *)(a1 + 2932) = v18 + 3;
    }
    else
    {
      v20 = *(_WORD *)(a1 + 4 * v19 + 5474);
      v21 = *(_WORD *)(a1 + 4 * v19 + 5474) << v18;
      v22 = *(_DWORD *)(a1 + 5812);
      *(_WORD *)(a1 + 2924) |= v21;
      *(_BYTE *)(v22 + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2924);
      *(_BYTE *)(++*(_DWORD *)(a1 + 5812) + *(_DWORD *)(a1 + 5800)) = *(_BYTE *)(a1 + 2925);
      v23 = *(_DWORD *)(a1 + 2932);
      ++*(_DWORD *)(a1 + 5812);
      v5 = a4;
      *(_DWORD *)(a1 + 2932) = v23 - 13;
      *(_WORD *)(a1 + 2924) = v20 >> (16 - v23);
    }
  }
  v24 = sub_10058300(a1, a1 + 2936, a2 - 1);
  return sub_10058300(v24, v24 + 5228, a3 - 1);
}

//----- (10059240) --------------------------------------------------------
signed int __cdecl sub_10059240(int a1, int a2)
{
  int v2; // esi@3
  int v3; // eax@6
  signed int result; // eax@9
  int v5; // ebx@10
  char v6; // al@12
  int v7; // eax@14
  unsigned int v8; // ecx@17
  int v9; // eax@19
  int v10; // eax@20
  int v11; // eax@29
  signed int v12; // eax@36
  int v13; // eax@50
  bool v14; // zf@50

  if ( !a1 || (unsigned int)a2 > 4 )
    return -2;
  v2 = *(_DWORD *)(a1 + 24);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) )
    return -2;
  v3 = *(_DWORD *)(v2 + 5788);
  if ( v3 == 666 && a2 != 4 )
    return -2;
  if ( !*(_DWORD *)(a1 + 16) )
    return -5;
  v5 = *(_DWORD *)(v2 + 5792);
  *(_DWORD *)(v2 + 2908) = a1;
  *(_DWORD *)(v2 + 5792) = a2;
  if ( v3 == 42 )
  {
    if ( *(_BYTE *)(v2 + 5796) >= 2 || (v6 = *(_BYTE *)(v2 + 5784), v6 < 2) )
    {
      v7 = 0;
    }
    else if ( v6 >= 6 )
    {
      v7 = (v6 != 6) + 2;
    }
    else
    {
      v7 = 1;
    }
    v8 = (v7 << 6) | (((*(_DWORD *)(v2 + 5752) - 8) << 12) + 2048);
    if ( *(_DWORD *)(v2 + 5680) )
      v8 |= 0x20u;
    *(_DWORD *)(v2 + 5788) = 113;
    v9 = sub_10058180(v2, 31 * (v8 / 0x1F + 1));
    if ( *(_DWORD *)(v2 + 5680) )
    {
      v10 = sub_10058180(v9, *(_WORD *)(a1 + 30));
      sub_10058180(v10, *(_WORD *)(a1 + 28));
    }
    *(_DWORD *)(a1 + 28) = sub_10034AE0(0, 0, 0);
  }
  if ( *(_DWORD *)(v2 + 5812) )
  {
    sub_10057A70(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
LABEL_24:
      *(_DWORD *)(v2 + 5792) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v5 && a2 != 4 )
  {
    return -5;
  }
  v11 = *(_DWORD *)(v2 + 5788);
  if ( v11 == 666 )
  {
    if ( *(_DWORD *)(a1 + 4) )
      return -5;
LABEL_33:
    if ( !*(_DWORD *)(v2 + 5688) && (!a2 || v11 == 666) )
      goto LABEL_47;
    goto LABEL_36;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    goto LABEL_33;
LABEL_36:
  v12 = (*(&off_101193A8 + 3 * *(_BYTE *)(v2 + 5784)))(v2, a2);
  if ( v12 == 2 || v12 == 3 )
    *(_DWORD *)(v2 + 5788) = 666;
  if ( !v12 || v12 == 2 )
  {
    if ( *(_DWORD *)(a1 + 16) )
      return 0;
    *(_DWORD *)(v2 + 5792) = -1;
    return 0;
  }
  if ( v12 == 1 )
  {
    if ( a2 == 1 )
    {
      sub_10058990(v2);
    }
    else
    {
      sub_10058BD0(v2, 0, 0, 0);
      if ( a2 == 3 )
      {
        *(_WORD *)(*(_DWORD *)(v2 + 5736) + 2 * *(_DWORD *)(v2 + 5764) - 2) = 0;
        memset(*(void **)(v2 + 5736), 0, 2 * *(_DWORD *)(v2 + 5764) - 2);
      }
    }
    sub_10057A70(a1);
    if ( !*(_DWORD *)(a1 + 16) )
      goto LABEL_24;
  }
LABEL_47:
  if ( a2 != 4 )
    return 0;
  if ( *(_DWORD *)(v2 + 5780) > 0 )
  {
    v13 = sub_10058180(v2, *(_WORD *)(a1 + 30));
    sub_10058180(v13, *(_WORD *)(a1 + 28));
    sub_10057A70(a1);
    v14 = *(_DWORD *)(v2 + 5812) == 0;
    *(_DWORD *)(v2 + 5780) = -*(_DWORD *)(v2 + 5780);
    result = v14;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 101193A8: using guessed type int (__cdecl *off_101193A8)(int, int);

//----- (10059500) --------------------------------------------------------
signed int __cdecl sub_10059500(int a1, unsigned __int8 a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  signed int v8; // edx@1
  int v9; // eax@5
  unsigned int v10; // edi@12
  signed int v11; // ebp@12
  signed int v12; // eax@12
  int v13; // ebp@14
  int v14; // esi@14
  int v15; // esi@14
  int v16; // esi@14
  signed int result; // eax@14

  v8 = 1;
  if ( a1 && a7 )
  {
    if ( a2 == -1 )
      a2 = 6;
    v9 = a4;
    if ( a4 < 0 )
    {
      v8 = 0;
      v9 = -a4;
      a4 = -a4;
    }
    if ( (unsigned int)(a5 - 1) > 7 || a3 != 8 || (unsigned int)(v9 - 9) > 6 || a2 > 9u || a6 > 3u )
    {
      result = -2;
    }
    else
    {
      v10 = 1 << (a5 + 6);
      v11 = 1 << v9;
      v12 = 1 << (a5 + 7);
      if ( (signed int)(2 * (v12 + 2 * (v10 + v11) + 2908)) > a8 || a7 & 3 )
      {
        result = -4;
      }
      else
      {
        *(_DWORD *)(a1 + 24) = a7;
        *(_DWORD *)(a7 + 5780) = v8;
        *(_DWORD *)(a7 + 5764) = v12;
        *(_DWORD *)(a7 + 5752) = a4;
        *(_DWORD *)(a7 + 5768) = a5 + 7;
        *(_DWORD *)(a7 + 5772) = v12 - 1;
        *(_DWORD *)(a7 + 5756) = v11 - 1;
        *(_DWORD *)(a7 + 5748) = v11;
        *(_DWORD *)(a7 + 5740) = a7 + 5816;
        v13 = 2 * v11;
        v14 = v13 + a7 + 5816;
        *(_DWORD *)(a7 + 5732) = v14;
        v15 = v13 + v14;
        *(_DWORD *)(a7 + 5776) = (a5 + 9) / 3u;
        *(_DWORD *)(a7 + 5736) = v15;
        v16 = v15 + 2 * (1 << (a5 + 7));
        *(_DWORD *)(a7 + 5804) = 4 * v10;
        *(_DWORD *)(a7 + 5716) = v10 + v16 + 2 * v10;
        *(_DWORD *)(a7 + 5712) = v16 + 2 * (v10 >> 1);
        *(_DWORD *)(a7 + 5724) = v10;
        *(_DWORD *)(a7 + 5800) = v16;
        *(_BYTE *)(a7 + 5784) = a2;
        *(_BYTE *)(a7 + 5796) = a6;
        *(_BYTE *)(a7 + 5720) = 8;
        result = sub_10058900(a1);
      }
    }
  }
  else
  {
    result = -2;
  }
  return result;
}

//----- (100596B0) --------------------------------------------------------
signed int __usercall sub_100596B0@<eax>(int a1@<eax>)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  sub_10058220(a1 + 2936, *(_DWORD *)(a1 + 5632), a1);
  sub_10058220(v1 + 5228, *(_DWORD *)(v1 + 5644), v1);
  sub_10058C70(v1, v1 + 5652);
  result = 18;
  while ( !*(_WORD *)(v1 + 4 * (unsigned __int8)byte_10118A2C[result] + 5474) )
  {
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_10118A2B[result] + 5474) )
    {
      *(_DWORD *)(v1 + 2912) += 3 * --result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_10118A2A[result] + 5474) )
    {
      result -= 2;
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
    if ( *(_WORD *)(v1 + 4 * (unsigned __int8)byte_10118A29[result] + 5474) )
    {
      result -= 3;
      break;
    }
    result -= 4;
    if ( result < 3 )
    {
      *(_DWORD *)(v1 + 2912) += 3 * result + 17;
      return result;
    }
  }
  *(_DWORD *)(v1 + 2912) += 3 * result + 17;
  return result;
}

//----- (10059780) --------------------------------------------------------
_WORD *__usercall sub_10059780@<eax>(int a1@<eax>, int a2@<ecx>, int a3)
{
  int v3; // ebp@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@1
  _BYTE *v7; // edi@2
  signed int v8; // eax@5
  unsigned int v9; // edx@5
  unsigned int v10; // ecx@5
  int v11; // ecx@11
  bool v12; // zf@12
  signed int v13; // ecx@12
  int v14; // eax@13
  int v15; // edx@14
  int v16; // ecx@14
  int v17; // edx@14
  int v18; // edx@17
  int v19; // eax@18
  int v20; // ecx@18
  int v21; // ebx@18
  _WORD *result; // eax@21
  signed int v23; // [sp+14h] [bp+4h]@4

  v3 = a3;
  v4 = a2;
  v5 = a1;
  v6 = *(_DWORD *)(a2 + 5664);
  if ( v6 < 0 )
    v7 = 0;
  else
    v7 = (_BYTE *)(v6 + *(_DWORD *)(a2 + 5740));
  v23 = 0;
  if ( *(_BYTE *)(a2 + 5784) <= 0 )
  {
    v10 = v5 + 5;
LABEL_8:
    v9 = v10;
    goto LABEL_9;
  }
  sub_10058C70(a2, a2 + 5628);
  sub_10058C70(v4, v4 + 5640);
  v8 = sub_100596B0(v4);
  v9 = (unsigned int)(*(_DWORD *)(v4 + 2912) + 10) >> 3;
  v10 = (unsigned int)(*(_DWORD *)(v4 + 2916) + 10) >> 3;
  v23 = v8;
  if ( v10 <= v9 )
    goto LABEL_8;
LABEL_9:
  if ( v5 + 4 <= v9 && v7 )
  {
    sub_10058BD0(v4, v3, v7, v5);
  }
  else
  {
    v12 = v10 == v9;
    v13 = *(_DWORD *)(v4 + 2932);
    if ( v12 )
    {
      v14 = v3 + 2;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v14 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v15 = v14 << v13;
        v16 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v15;
        *(_BYTE *)(v16 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v17 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v17 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v14 >> (16 - v17);
      }
      sub_10057540(v4, (int)&unk_10118AB8, (int)&unk_10118F38);
    }
    else
    {
      v18 = v3 + 4;
      if ( v13 <= 13 )
      {
        *(_WORD *)(v4 + 2924) |= v18 << v13;
        *(_DWORD *)(v4 + 2932) = v13 + 3;
      }
      else
      {
        v19 = v18 << v13;
        v20 = *(_DWORD *)(v4 + 5800);
        *(_WORD *)(v4 + 2924) |= v19;
        *(_BYTE *)(v20 + (*(_DWORD *)(v4 + 5812))++) = *(_BYTE *)(v4 + 2924);
        *(_BYTE *)(*(_DWORD *)(v4 + 5812) + *(_DWORD *)(v4 + 5800)) = *(_BYTE *)(v4 + 2925);
        v21 = *(_DWORD *)(v4 + 2932);
        ++*(_DWORD *)(v4 + 5812);
        *(_DWORD *)(v4 + 2932) = v21 - 13;
        *(_WORD *)(v4 + 2924) = (unsigned __int16)v18 >> (16 - v21);
      }
      sub_10058F90(v4, *(_DWORD *)(v4 + 5632) + 1, *(_DWORD *)(v4 + 5644) + 1, v23 + 1);
      sub_10057540(v4, v4 + 2936, v4 + 5228);
    }
  }
  result = sub_10057D20(v11, v4);
  if ( v3 )
    result = (_WORD *)sub_100574B0(v4);
  return result;
}

//----- (100599A0) --------------------------------------------------------
signed int __cdecl sub_100599A0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  int v4; // edx@7
  int v5; // edi@7
  int v6; // eax@7
  int v7; // ecx@7
  unsigned int v8; // eax@9
  char v9; // cl@10
  unsigned int v10; // eax@11
  unsigned int v11; // eax@16
  BOOL v12; // eax@17
  unsigned int v13; // ecx@17
  int v14; // edi@20
  int v15; // ecx@20
  int v16; // edx@20
  int v17; // ebx@20
  int v19; // edi@22
  int v20; // ecx@22
  int v21; // edx@22
  int v22; // edi@26
  signed int result; // eax@27
  int v24; // edi@28
  int v25; // eax@28

  v2 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10058E50(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    if ( v2 )
    {
      v8 = *(_DWORD *)(a1 + 5680) - v2;
      if ( v8 <= *(_DWORD *)(a1 + 5748) - 262 )
      {
        v9 = *(_BYTE *)(a1 + 5796);
        if ( v9 < 2 )
        {
          v10 = sub_10057E50(a1, v2);
LABEL_15:
          *(_DWORD *)(a1 + 5668) = v10;
          goto LABEL_16;
        }
        if ( v9 == 3 && v8 == 1 )
        {
          v10 = sub_10058000(a1, v2);
          goto LABEL_15;
        }
      }
    }
LABEL_16:
    v11 = *(_DWORD *)(a1 + 5668);
    if ( v11 < 3 )
    {
      v12 = sub_10057360(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680)), 0);
      --*(_DWORD *)(a1 + 5688);
    }
    else
    {
      v12 = sub_10057360(a1, v11 - 3, *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684));
      v13 = *(_DWORD *)(a1 + 5668);
      *(_DWORD *)(a1 + 5688) -= v13;
      if ( v13 > *(_DWORD *)(a1 + 5700) || *(_DWORD *)(a1 + 5688) < 3u )
      {
        *(_DWORD *)(a1 + 5680) += v13;
        v19 = *(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680);
        v20 = *(_DWORD *)(a1 + 5776);
        *(_DWORD *)(a1 + 5668) = 0;
        v21 = *(_BYTE *)v19;
        *(_DWORD *)(a1 + 5760) = v21;
        *(_DWORD *)(a1 + 5760) = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(v19 + 1) ^ (v21 << v20));
        goto LABEL_25;
      }
      *(_DWORD *)(a1 + 5668) = v13 - 1;
      do
      {
        v14 = ++*(_DWORD *)(a1 + 5680);
        v15 = *(_DWORD *)(a1 + 5736);
        v16 = *(_DWORD *)(a1 + 5772) & ((*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)) ^ *(_BYTE *)(*(_DWORD *)(a1 + 5740) + v14 + 2));
        v17 = *(_DWORD *)(a1 + 5756);
        *(_DWORD *)(a1 + 5760) = v16;
        *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v14 & v17)) = *(_WORD *)(v15 + 2 * v16);
        v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
        *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
      }
      while ( (*(_DWORD *)(a1 + 5668))-- != 1 );
    }
    ++*(_DWORD *)(a1 + 5680);
LABEL_25:
    if ( v12 )
    {
      sub_10059780(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
      v22 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10057A70(v22);
      if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        return 0;
    }
  }
  sub_10059780(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v24 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10057A70(v24);
  v25 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v25) = a2 == 4;
    result = 2 * v25 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (10059CB0) --------------------------------------------------------
signed int __cdecl sub_10059CB0(int a1, int a2)
{
  unsigned int v2; // ebp@1
  unsigned int v3; // eax@3
  int v4; // edx@8
  int v5; // edi@8
  int v6; // eax@8
  int v7; // ecx@8
  unsigned int v8; // ecx@9
  int v9; // edx@9
  unsigned int v10; // eax@11
  char v11; // cl@12
  unsigned int v12; // eax@13
  unsigned int v13; // eax@18
  unsigned int v14; // eax@23
  int v15; // ecx@25
  unsigned int v16; // ebp@25
  BOOL v17; // eax@25
  int v18; // ecx@25
  BOOL v19; // ebx@25
  unsigned int v20; // edi@26
  int v21; // ecx@27
  int v22; // edx@27
  int v23; // eax@27
  int v25; // eax@29
  int v26; // edi@30
  signed int result; // eax@31
  int v28; // edi@34
  int v29; // ecx@35
  int v30; // edi@40
  unsigned int v31; // [sp+10h] [bp-4h]@1

  v2 = 0;
  v31 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 < 0x106 )
    {
      sub_10058E50(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = *(_DWORD *)(a1 + 5680);
      v5 = *(_DWORD *)(a1 + 5756);
      v6 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v4 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
      v7 = *(_DWORD *)(a1 + 5736);
      *(_DWORD *)(a1 + 5760) = v6;
      *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v4 & v5)) = *(_WORD *)(v7 + 2 * v6);
      v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      v2 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
      *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
    }
    v8 = *(_DWORD *)(a1 + 5668);
    v9 = *(_DWORD *)(a1 + 5684);
    *(_DWORD *)(a1 + 5692) = v8;
    *(_DWORD *)(a1 + 5672) = v9;
    *(_DWORD *)(a1 + 5668) = 2;
    if ( !v2 )
      goto LABEL_23;
    if ( v8 >= *(_DWORD *)(a1 + 5700) )
      goto LABEL_23;
    v10 = *(_DWORD *)(a1 + 5680) - v2;
    if ( v10 > *(_DWORD *)(a1 + 5748) - 262 )
      goto LABEL_23;
    v11 = *(_BYTE *)(a1 + 5796);
    if ( v11 < 2 )
    {
      v12 = sub_10057E50(a1, v2);
LABEL_17:
      *(_DWORD *)(a1 + 5668) = v12;
      goto LABEL_18;
    }
    if ( v11 == 3 && v10 == 1 )
    {
      v12 = sub_10058000(a1, v2);
      goto LABEL_17;
    }
LABEL_18:
    v13 = *(_DWORD *)(a1 + 5668);
    if ( v13 <= 5
      && (*(_BYTE *)(a1 + 5796) == 1
       || v13 == 3 && (unsigned int)(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5684)) > 0x1000) )
    {
      *(_DWORD *)(a1 + 5668) = 2;
    }
LABEL_23:
    v14 = *(_DWORD *)(a1 + 5692);
    if ( v14 < 3 || *(_DWORD *)(a1 + 5668) > v14 )
    {
      if ( *(_DWORD *)(a1 + 5676) )
      {
        if ( sub_10057360(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0) )
        {
          sub_10059780(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, 0);
          v28 = *(_DWORD *)(a1 + 2908);
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
          sub_10057A70(v28);
        }
        v29 = *(_DWORD *)(a1 + 2908);
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        if ( !*(_DWORD *)(v29 + 16) )
          return 0;
      }
      else
      {
        ++*(_DWORD *)(a1 + 5680);
        --*(_DWORD *)(a1 + 5688);
        *(_DWORD *)(a1 + 5676) = 1;
      }
    }
    else
    {
      v15 = *(_DWORD *)(a1 + 5680);
      v16 = v15 + *(_DWORD *)(a1 + 5688) - 3;
      v17 = sub_10057360(a1, v14 - 3, v15 - *(_DWORD *)(a1 + 5672) - 1);
      v18 = *(_DWORD *)(a1 + 5692);
      v19 = v17;
      *(_DWORD *)(a1 + 5688) += 1 - v18;
      *(_DWORD *)(a1 + 5692) = v18 - 2;
      do
      {
        v20 = ++*(_DWORD *)(a1 + 5680);
        if ( v20 <= v16 )
        {
          v21 = *(_DWORD *)(a1 + 5736);
          v22 = *(_DWORD *)(a1 + 5772) & (*(_BYTE *)(*(_DWORD *)(a1 + 5740) + v20 + 2) ^ (*(_DWORD *)(a1 + 5760) << *(_DWORD *)(a1 + 5776)));
          v23 = *(_DWORD *)(a1 + 5756);
          *(_DWORD *)(a1 + 5760) = v22;
          *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (v20 & v23)) = *(_WORD *)(v21 + 2 * v22);
          v31 = *(_WORD *)(*(_DWORD *)(a1 + 5732) + 2 * (*(_DWORD *)(a1 + 5680) & *(_DWORD *)(a1 + 5756)));
          *(_WORD *)(*(_DWORD *)(a1 + 5736) + 2 * *(_DWORD *)(a1 + 5760)) = *(_WORD *)(a1 + 5680);
        }
      }
      while ( (*(_DWORD *)(a1 + 5692))-- != 1 );
      v25 = ++*(_DWORD *)(a1 + 5680);
      *(_DWORD *)(a1 + 5676) = 0;
      *(_DWORD *)(a1 + 5668) = 2;
      if ( v19 )
      {
        sub_10059780(v25 - *(_DWORD *)(a1 + 5664), a1, 0);
        v26 = *(_DWORD *)(a1 + 2908);
        *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
        sub_10057A70(v26);
        if ( !*(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
          return 0;
      }
      v2 = v31;
    }
  }
  if ( *(_DWORD *)(a1 + 5676) )
  {
    sub_10057360(a1, *(_BYTE *)(*(_DWORD *)(a1 + 5740) + *(_DWORD *)(a1 + 5680) - 1), 0);
    *(_DWORD *)(a1 + 5676) = 0;
  }
  sub_10059780(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v30 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10057A70(v30);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
    result = 2 * (a2 == 4) + 1;
  else
    result = a2 != 4 ? 0 : 2;
  return result;
}

//----- (1005A0C0) --------------------------------------------------------
signed int __cdecl sub_1005A0C0(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // eax@3
  bool v4; // zf@5
  int v5; // edx@5
  unsigned int v6; // ecx@5
  unsigned int v7; // eax@5
  int v8; // edi@7
  unsigned int v9; // eax@8
  int v10; // edi@9
  signed int result; // eax@10
  int v12; // edi@12
  int v13; // eax@12

  v2 = 0xFFFF;
  if ( (unsigned int)(*(_DWORD *)(a1 + 5804) - 5) <= 0xFFFF )
    v2 = *(_DWORD *)(a1 + 5804) - 5;
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 5688);
    if ( v3 <= 1 )
    {
      sub_10058E50(a1);
      v3 = *(_DWORD *)(a1 + 5688);
      if ( !v3 )
        break;
    }
    v4 = v3 + *(_DWORD *)(a1 + 5680) == 0;
    *(_DWORD *)(a1 + 5680) += v3;
    v5 = *(_DWORD *)(a1 + 5664);
    v6 = *(_DWORD *)(a1 + 5680);
    *(_DWORD *)(a1 + 5688) = 0;
    v7 = v5 + v2;
    if ( !v4 && v6 < v7
      || (*(_DWORD *)(a1 + 5688) = v6 - v7,
          *(_DWORD *)(a1 + 5680) = v7,
          sub_10059780(v2, a1, 0),
          v8 = *(_DWORD *)(a1 + 2908),
          *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680),
          sub_10057A70(v8),
          *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16)) )
    {
      v9 = *(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664);
      if ( v9 < *(_DWORD *)(a1 + 5748) - 262 )
        continue;
      sub_10059780(v9, a1, 0);
      v10 = *(_DWORD *)(a1 + 2908);
      *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
      sub_10057A70(v10);
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  sub_10059780(*(_DWORD *)(a1 + 5680) - *(_DWORD *)(a1 + 5664), a1, a2 == 4);
  v12 = *(_DWORD *)(a1 + 2908);
  *(_DWORD *)(a1 + 5664) = *(_DWORD *)(a1 + 5680);
  sub_10057A70(v12);
  v13 = 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 2908) + 16) )
  {
    LOBYTE(v13) = a2 == 4;
    result = 2 * v13 + 1;
  }
  else
  {
    result = a2 != 4 ? 0 : 2;
  }
  return result;
}

//----- (1005A230) --------------------------------------------------------
signed int __cdecl sub_1005A230(unsigned int a1)
{
  int v1; // eax@1

  v1 = sub_10038960(a1);
  return sub_10039EF0(v1);
}

//----- (1005A310) --------------------------------------------------------
signed int __cdecl sub_1005A310(unsigned int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  signed int result; // eax@3

  v4 = sub_10038960(a1);
  v5 = v4;
  if ( v4 < 0xFFFFFFC2 && v4 )
  {
    if ( sub_1003A3D0(v4, a4, 0) == a4 )
      result = sub_1003A370(v5, a2, a3);
    else
      result = -15;
  }
  else
  {
    result = -6;
  }
  return result;
}

//----- (1005A370) --------------------------------------------------------
signed int __cdecl sub_1005A370(unsigned int a1, int a2, int a3)
{
  unsigned int v3; // eax@1

  v3 = sub_10038960(a1);
  return sub_1003A3D0(v3, a2, a3);
}

//----- (1005A390) --------------------------------------------------------
BOOL __cdecl sub_1005A390(unsigned int a1)
{
  j_FIL_vfs_clean_invalidate_cache(a1);
  return sub_10061070(a1) == 0;
}
// 10061060: using guessed type int __cdecl j_FIL_vfs_clean_invalidate_cache(_DWORD);

//----- (1005A3B0) --------------------------------------------------------
BOOL __cdecl sub_1005A3B0(int a1)
{
  return j_FIL_vfs_delete(a1) == 0;
}
// 100610D0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);

//----- (1005A3E0) --------------------------------------------------------
unsigned int __cdecl sub_1005A3E0(int a1, char a2)
{
  unsigned int result; // eax@7
  int v3; // [sp-Ch] [bp-Ch]@3
  signed int v4; // [sp-8h] [bp-8h]@2

  switch ( a2 )
  {
    case 0:
      v4 = 4;
      goto LABEL_6;
    case 1:
      v4 = 10;
      v3 = a1;
      goto LABEL_7;
    case 2:
      v4 = 14;
      v3 = a1;
      goto LABEL_7;
    case 3:
      v4 = 78;
LABEL_6:
      v3 = a1;
LABEL_7:
      result = j_FIL_vfs_open(v3, v4, 0);
      if ( result >= 0xFFFFFFC2 || !result )
        goto LABEL_9;
      break;
    default:
LABEL_9:
      result = 0;
      break;
  }
  return result;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (1005A440) --------------------------------------------------------
signed int __cdecl sub_1005A440(void *a1, int a2, unsigned int a3)
{
  return sub_100611A0(a3, a1, a2);
}

//----- (1005A460) --------------------------------------------------------
int __cdecl sub_1005A460(int a1, int a2, int a3)
{
  return j_FIL_vfs_write(a3, a1, a2);
}
// 10061330: using guessed type int __cdecl j_FIL_vfs_write(_DWORD, _DWORD, _DWORD);

//----- (1005A480) --------------------------------------------------------
char __cdecl sub_1005A480(const char *a1, const char *a2)
{
  bool v2; // bl@1
  unsigned int v3; // edi@6
  unsigned int v4; // ebp@7
  int v5; // esi@8
  bool i; // zf@8
  char v8; // [sp+Ch] [bp-204h]@8

  v2 = 0;
  if ( !a1 || !*a1 || !a2 || !*a2 )
    return v2;
  if ( strcmp(a1, a2) )
  {
    v3 = sub_1005A3E0((int)a1, 0);
    if ( v3 )
    {
      v4 = sub_1005A3E0((int)a2, 1);
      if ( v4 )
      {
        v5 = sub_1005A440(&v8, 512, v3);
        for ( i = v5 == 0; v5 > 0; i = v5 == 0 )
        {
          v5 -= sub_1005A460((int)&v8, v5, v4);
          if ( !v5 )
            v5 = sub_1005A440(&v8, 512, v3);
        }
        v2 = i;
        sub_1005A390(v4);
      }
      sub_1005A390(v3);
    }
    return v2;
  }
  return 1;
}

//----- (1005A5C0) --------------------------------------------------------
int __cdecl sub_1005A5C0(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  unsigned __int8 v5; // [sp+13h] [bp-1h]@2

  v3 = 0;
  while ( 1 )
  {
    if ( sub_1005A440(&v5, 1, a3) <= 0 || v5 == -1 )
    {
      *(_BYTE *)(v3 + a1) = 0;
      return v3 > 0 ? a1 : 0;
    }
    if ( v5 == 10 )
      break;
    if ( v5 != 13 )
    {
      *(_BYTE *)(v3++ + a1) = v5;
      if ( v3 >= a2 - 2 )
      {
        *(_BYTE *)(v3 + a1 + 1) = 0;
        return a1;
      }
    }
  }
  *(_BYTE *)(v3 + a1) = 0;
  return a1;
}

//----- (1005A640) --------------------------------------------------------
char __cdecl sub_1005A640(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // ecx@2
  int v5; // [sp+0h] [bp-Ch]@1
  __int16 v6; // [sp+4h] [bp-8h]@2
  int v7; // [sp+8h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_10A09214)(a1, 12, &v5);
  if ( result )
  {
    v3 = v6;
    *(_DWORD *)a2 = v5;
    v4 = v7 & 0xFFFFFF;
    *(_WORD *)(a2 + 4) = v3;
    *(_DWORD *)(a2 + 8) = v4;
    result = 1;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (1005A690) --------------------------------------------------------
char __cdecl sub_1005A690(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  __int16 v4; // cx@2
  __int16 v5; // dx@2
  __int16 v6; // cx@2
  int v7; // edx@2
  __int16 v8; // cx@2
  unsigned int v9; // ecx@2
  int v10; // edx@2
  __int16 v11; // [sp+0h] [bp-1Ch]@1
  __int16 v12; // [sp+2h] [bp-1Ah]@2
  __int16 v13; // [sp+4h] [bp-18h]@2
  __int16 v14; // [sp+6h] [bp-16h]@2
  __int16 v15; // [sp+8h] [bp-14h]@2
  int v16; // [sp+Ah] [bp-12h]@2
  __int16 v17; // [sp+Eh] [bp-Eh]@2
  int v18; // [sp+12h] [bp-Ah]@2
  unsigned int v19; // [sp+16h] [bp-6h]@2
  char v20; // [sp+1Ah] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_10A09214)(a1, 27, &v11);
  if ( result )
  {
    v3 = v12;
    *(_WORD *)a2 = v11;
    v4 = v13;
    *(_WORD *)(a2 + 2) = v3;
    v5 = v14;
    *(_WORD *)(a2 + 4) = v4;
    v6 = v15;
    *(_WORD *)(a2 + 6) = v5;
    *(_DWORD *)(a2 + 12) = v16;
    v7 = v18;
    *(_WORD *)(a2 + 8) = v6;
    v8 = v17;
    *(_DWORD *)(a2 + 20) = v7;
    *(_WORD *)(a2 + 16) = v8;
    v9 = v19;
    *(_DWORD *)(a2 + 24) = v19 & 3;
    *(_DWORD *)(a2 + 28) = (v9 >> 2) & 1;
    v10 = (v9 >> 3) & 3;
    *(_DWORD *)(a2 + 36) = (v9 >> 5) & 1;
    LOBYTE(v9) = v20;
    *(_DWORD *)(a2 + 32) = v10;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v9 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v9 >> 6;
    result = 1;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (1005A740) --------------------------------------------------------
char __cdecl sub_1005A740(int a1, int a2)
{
  char result; // al@1
  char v3; // ah^2@2
  __int16 v4; // dx@2
  __int16 v5; // dx@2
  int v6; // [sp+0h] [bp-8h]@1
  unsigned int v7; // [sp+4h] [bp-4h]@2

  result = (*(int (__cdecl **)(int, signed int, int *))dword_10A09214)(a1, 8, &v6);
  if ( result )
  {
    v3 = BYTE3(v6);
    *(_DWORD *)a2 = v6 & 0xFFFFFF;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = v3;
    v5 = (unsigned __int8)v7 ^ v4;
    *(_DWORD *)(a2 + 8) = v7 >> 8;
    *(_WORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (1005A7A0) --------------------------------------------------------
char __cdecl sub_1005A7A0(int a1, int a2)
{
  char result; // al@1
  __int16 v3; // dx@2
  int v4; // esi@2
  unsigned int v5; // ecx@2
  __int16 v6; // [sp+0h] [bp-14h]@1
  __int16 v7; // [sp+2h] [bp-12h]@2
  __int16 v8; // [sp+4h] [bp-10h]@2
  __int16 v9; // [sp+6h] [bp-Eh]@2
  __int16 v10; // [sp+8h] [bp-Ch]@2
  unsigned __int16 v11; // [sp+Ah] [bp-Ah]@2
  int v12; // [sp+Ch] [bp-8h]@2
  char v13; // [sp+12h] [bp-2h]@2

  result = (*(int (__cdecl **)(int, signed int, __int16 *))dword_10A09214)(a1, 19, &v6);
  if ( result )
  {
    v3 = v7;
    *(_WORD *)a2 = v6;
    *(_WORD *)(a2 + 4) = v8;
    *(_WORD *)(a2 + 8) = v10;
    *(_WORD *)(a2 + 2) = v3;
    v4 = v11;
    *(_WORD *)(a2 + 6) = v9;
    LOBYTE(v3) = v13;
    *(_DWORD *)(a2 + 12) = v4 + ((v13 & 7) << 16);
    *(_WORD *)(a2 + 16) = v12 & 0x3FFF;
    v5 = *(int *)((char *)&v12 + 2);
    *(_DWORD *)(a2 + 20) = *(int *)((char *)&v12 + 2) & 0xFFFFFF;
    *(_DWORD *)(a2 + 24) = (v5 >> 24) & 3;
    *(_DWORD *)(a2 + 28) = (v5 >> 26) & 1;
    *(_DWORD *)(a2 + 36) = (v5 >> 29) & 1;
    *(_DWORD *)(a2 + 32) = (v5 >> 27) & 3;
    *(_BYTE *)(a2 + 40) = ((unsigned __int8)v3 >> 3) & 7;
    *(_BYTE *)(a2 + 41) = (unsigned __int8)v3 >> 6;
    result = 1;
  }
  return result;
}
// 10A09214: using guessed type int dword_10A09214;

//----- (1005A870) --------------------------------------------------------
bool __cdecl sub_1005A870(void *a1)
{
  char v1; // al@1

  v1 = sub_10015AC0(1, 1946, a1);
  *((_DWORD *)a1 + 1) = (unsigned int)(*((_DWORD *)a1 + 1) * (unsigned __int64)(unsigned int)&unk_10624DD3 >> 32) >> 6;
  return v1 && !sub_1001C4F0((int)a1);
}

//----- (1005A8B0) --------------------------------------------------------
char __cdecl sub_1005A8B0(char a1)
{
  return byte_1011DE51[2 * (unsigned __int8)sub_1002CC90(&a1, 1u, (int)&unk_1011DE50, 2, 4, 3)];
}

//----- (1005A8E0) --------------------------------------------------------
char __cdecl sub_1005A8E0(char a1, void *a2)
{
  void *v3; // esi@6
  char v4; // al@6

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v3 = a2;
      v4 = sub_10015AC0(1, 546, a2);
    }
    else
    {
      if ( a1 != 2 )
      {
        sub_10028BC0("..\\lib\\acl\\iop\\iop_com_intf.c", 187, 0, 0);
        return 0;
      }
      v3 = a2;
      v4 = sub_1005A870(a2);
    }
  }
  else
  {
    v3 = a2;
    v4 = sub_10015AC0(1, 538, a2);
  }
  if ( !v4 || sub_1001C4F0((int)v3) )
    return 0;
  return 1;
}

//----- (1005A960) --------------------------------------------------------
int __cdecl sub_1005A960(char a1, _DWORD *a2)
{
  int result; // eax@1
  int v3; // [sp+4h] [bp-Ch]@1
  int v4; // [sp+8h] [bp-8h]@1

  v3 = 0;
  v4 = 0;
  LOBYTE(result) = sub_1005A8E0(a1, &v3);
  *a2 = v4;
  return result;
}

//----- (1005A9B0) --------------------------------------------------------
char sub_1005A9B0()
{
  return 2;
}

//----- (1005A9C0) --------------------------------------------------------
int __cdecl sub_1005A9C0(char a1, char *a2)
{
  int result; // eax@1
  char *v3; // edi@2
  char *v4; // esi@3
  int v5; // edi@3

  result = sub_1002CC90(&a1, 1u, (int)&unk_1011DE78, 68, 4, 4);
  if ( result < 4 )
  {
    v3 = a2;
    if ( a2 )
    {
      v4 = (char *)&unk_1011DE79 + 68 * result;
      qmemcpy(a2, v4, 0x40u);
      v4 += 64;
      v5 = (int)(v3 + 64);
      *(_WORD *)v5 = *(_WORD *)v4;
      *(_BYTE *)(v5 + 2) = v4[2];
    }
  }
  return result;
}

//----- (1005AA10) --------------------------------------------------------
int __cdecl sub_1005AA10(char a1, char a2)
{
  int v2; // esi@1
  int result; // eax@4

  v2 = dword_1011E794[2 * sub_1002CC90(&a1, 1u, (int)&unk_1011E790, 8, 3, 3)];
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      result = v2 + dword_1011E7D4[2 * sub_1002CC90(&a2, 1u, (int)&unk_1011E7D0, 8, 6, 6)];
    }
    else if ( a1 == 2 )
    {
      result = v2 + dword_1011E804[2 * sub_1002CC90(&a2, 1u, (int)&unk_1011E800, 8, 5, 5)];
    }
    else
    {
      result = v2;
    }
  }
  else
  {
    result = v2 + dword_1011E7AC[2 * sub_1002CC90(&a2, 1u, (int)&unk_1011E7A8, 8, 5, 5)];
  }
  return result;
}
// 1011E794: using guessed type int dword_1011E794[];
// 1011E7AC: using guessed type int dword_1011E7AC[];
// 1011E7D4: using guessed type int dword_1011E7D4[];
// 1011E804: using guessed type int dword_1011E804[];

//----- (1005AAC0) --------------------------------------------------------
bool __usercall sub_1005AAC0@<al>(unsigned __int8 a1@<al>, char a2, unsigned __int8 a3)
{
  return a2 == 7 && a3 >= (unsigned __int8)byte_10116137[44 * a1] - (unsigned __int8)byte_10116132[44 * a1];
}

//----- (1005AAF0) --------------------------------------------------------
char __usercall sub_1005AAF0@<al>(unsigned __int8 a1@<bl>, size_t a2@<edi>, int a3@<esi>, char a4, unsigned __int8 a5, void *a6)
{
  int v6; // eax@2
  char result; // al@3
  int v8; // eax@4

  if ( sub_1005AAC0(a1, a4, a5) )
  {
    v6 = a3
       + sub_1005AA10(a1, 6)
       + 36 * (a5 + (unsigned __int8)byte_10116132[44 * a1] - (unsigned __int8)byte_10116137[44 * a1]);
    if ( *(_BYTE *)(v6 + 2) == 6 )
    {
      memcpy(a6, (const void *)(v6 + 4), a2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v8 = sub_1005AA10(a1, a4);
    memcpy(a6, (const void *)(a3 + v8 + a2 * a5), a2);
    result = 1;
  }
  return result;
}

//----- (1005AB90) --------------------------------------------------------
char __cdecl sub_1005AB90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10045120(a1);
  sub_10060E00(v5, (int)&v7, 3684);
  return sub_1005AAF0(a2, 0x2Cu, (int)&v7, a3, a4, a5);
}

//----- (1005AC10) --------------------------------------------------------
char __cdecl sub_1005AC10(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10045120(a1);
  sub_10060E00(v5, (int)&v7, 3684);
  return sub_1005AAF0(a2, 3u, (int)&v7, a3, a4, a5);
}

//----- (1005AC90) --------------------------------------------------------
char __cdecl sub_1005AC90(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10045120(a1);
  sub_10060E00(v5, (int)&v7, 3684);
  return sub_1005AAF0(a2, 0x24u, (int)&v7, a3, a4, a5);
}

//----- (1005AD10) --------------------------------------------------------
char __cdecl sub_1005AD10(char a1, unsigned __int8 a2, char a3, unsigned __int8 a4, void *a5)
{
  int v5; // eax@1
  char v7; // [sp+Ch] [bp-E64h]@1

  memset(&v7, 0, 0xE64u);
  v5 = sub_10045120(a1);
  sub_10060E00(v5, (int)&v7, 3684);
  return sub_1005AAF0(a2, 0xCu, (int)&v7, a3, a4, a5);
}

//----- (1005AD90) --------------------------------------------------------
char __usercall sub_1005AD90@<al>(void *a1@<esi>)
{
  char result; // al@2
  bool v2; // zf@3
  float *v3; // [sp+0h] [bp-8h]@0

  if ( sub_1005F6A0(4035, v3) )
  {
    result = 1;
  }
  else
  {
    v2 = (unsigned __int8)sub_10030F60(1, 741, 0, 4, a1) == 0;
    result = 1;
    if ( v2 )
      result = 0;
  }
  return result;
}

//----- (1005ADD0) --------------------------------------------------------
char __usercall sub_1005ADD0@<al>(float *a1@<esi>)
{
  char result; // al@1
  void *v2; // [sp+0h] [bp-8h]@0

  result = sub_10033F20(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (1005ADF0) --------------------------------------------------------
char __cdecl sub_1005ADF0(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_10060E40(6081, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (1005AE50) --------------------------------------------------------
char __cdecl sub_1005AE50(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_10060E40(6937, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (1005AEB0) --------------------------------------------------------
char __cdecl sub_1005AEB0(float *a1)
{
  char v1; // bl@1
  double v2; // st7@1
  char result; // al@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v5 = 9.8999998e24;
  v1 = 0;
  sub_10060E40(6938, &v4, 4, &v5);
  v2 = v4;
  if ( v4 != 9.8999998e24 )
  {
    v1 = 1;
    v4 = v2 / 3600.0;
    v2 = v4;
  }
  result = v1;
  *a1 = v2;
  return result;
}

//----- (1005AF10) --------------------------------------------------------
char __usercall sub_1005AF10@<al>(int a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  float v4; // ST14_4@5
  char result; // al@5
  float v6; // [sp+Ch] [bp-8h]@1
  float v7; // [sp+10h] [bp-4h]@1

  v1 = sub_100472F0(0x4B6u, &v6);
  v2 = sub_100472F0(0x4B7u, &v7);
  if ( v1 )
  {
    v3 = v6;
    if ( v2 )
    {
      if ( v7 <= v3 )
        v3 = v7;
      v4 = v3;
      result = sub_1005F600(v4, a1);
    }
    else
    {
      result = sub_1005F600(v6, a1);
    }
  }
  else if ( v2 )
  {
    result = sub_1005F600(v7, a1);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005AFB0) --------------------------------------------------------
char __cdecl sub_1005AFB0(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_10030F60(1, 949, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005B000) --------------------------------------------------------
char __cdecl sub_1005B000(float *a1)
{
  char result; // al@2
  float v2; // [sp+4h] [bp-4h]@1

  if ( (unsigned __int8)sub_10030F60(1, 950, 0, 4, &v2) )
  {
    result = 1;
    *a1 = 1000.0 * v2 / (10.0 - v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005B050) --------------------------------------------------------
char __cdecl sub_1005B050(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_10030F60(0, 400, 0, 4, &v3) && (unsigned __int8)sub_10030F60(1, 527, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005B0B0) --------------------------------------------------------
char __cdecl sub_1005B0B0(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_10030F60(0, 401, 0, 4, &v3) && (unsigned __int8)sub_10030F60(1, 530, 0, 4, &v2) )
  {
    result = 1;
    *a1 = v2 * v3 * 0.1047197580337524;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005B110) --------------------------------------------------------
char __usercall sub_1005B110@<al>(float *a1@<esi>, char a2)
{
  char v2; // bl@1
  char result; // al@6
  float v4; // [sp+4h] [bp-Ch]@1
  int v5; // [sp+8h] [bp-8h]@1
  float v6; // [sp+Ch] [bp-4h]@1
  char v7; // [sp+14h] [bp+4h]@2
  char v8; // [sp+14h] [bp+4h]@7

  v4 = 9.8999998e24;
  v6 = 9.8999998e24;
  v2 = 0;
  v5 = 0;
  if ( a2 )
  {
    v7 = sub_10030F60(6, 617, 0, 4, &v5);
    if ( sub_1005F6A0(4026, &v4) )
    {
      v2 = 1;
      if ( v7 && v5 & 0x1000 && sub_1005F6A0(4028, &v6) )
      {
LABEL_6:
        result = 1;
        *a1 = v6 + v4;
        return result;
      }
      goto LABEL_11;
    }
  }
  else
  {
    v8 = sub_10030F60(6, 620, 0, 4, &v5);
    if ( sub_1005F6A0(4027, &v4) )
    {
      v2 = 1;
      if ( v8 && v5 & 0x1000 && sub_1005F6A0(4029, &v6) )
        goto LABEL_6;
LABEL_11:
      *a1 = v4;
      return v2;
    }
  }
  return v2;
}

//----- (1005B200) --------------------------------------------------------
char __cdecl sub_1005B200(float a1, int a2)
{
  float v2; // ecx@0
  char v3; // al@3
  char result; // al@5
  float v5; // [sp+0h] [bp-4h]@1

  v5 = v2;
  if ( LOBYTE(a1) == 1 )
  {
    if ( !sub_1005F6A0(65, &v5) )
      return 0;
    v3 = sub_1005F6A0(498, &a1);
  }
  else
  {
    if ( !sub_1005F6A0(61, &v5) )
      return 0;
    v3 = sub_1005F6A0(477, &a1);
  }
  if ( v3 )
  {
    result = 1;
    *(float *)a2 = (a1 + v5) * 0.5;
    return result;
  }
  return 0;
}

//----- (1005B270) --------------------------------------------------------
char __usercall sub_1005B270@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st7@2
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_10030F60(1, 740, 0, 4, &v5);
  v2 = sub_10030F60(1, 2172, 0, 4, &v6);
  if ( v1 )
  {
    v3 = v5;
    if ( !v2 || (v5 = v3 - v6, LODWORD(v5) &= 0x7FFFFFFFu, v5 <= 304.8) )
    {
      *a1 = v3;
      return 1;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (1005B2F0) --------------------------------------------------------
char __cdecl sub_1005B2F0(float *a1)
{
  char result; // al@4
  int v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( (unsigned __int8)sub_10030F60(1, 120, 0, 4, &v3)
    && (unsigned __int8)sub_10030F60(1, 1775, 0, 4, &v2)
    && !(v2 & 0x7C0000) )
  {
    *a1 = v3;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005B350) --------------------------------------------------------
char __cdecl sub_1005B350(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_10030F60(1, 122, 0, 4, &v5) || !(unsigned __int8)sub_10030F60(1, 996, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (1005B3E0) --------------------------------------------------------
char __cdecl sub_1005B3E0(float *a1)
{
  char v1; // bl@1
  int v2; // eax@3
  char result; // al@14
  int v4; // [sp+4h] [bp-8h]@2
  float v5; // [sp+8h] [bp-4h]@1

  v1 = 0;
  if ( !(unsigned __int8)sub_10030F60(1, 127, 0, 4, &v5) || !(unsigned __int8)sub_10030F60(1, 1004, 0, 4, &v4) )
    goto LABEL_18;
  v2 = v4;
  if ( v4 & 0x40000 )
    v1 = 1;
  if ( v2 & 0x80000 )
    ++v1;
  if ( v2 & 0x100000 )
    ++v1;
  if ( v2 & 0x200000 )
    ++v1;
  if ( v2 & 0x400000 )
    ++v1;
  if ( (unsigned __int8)v1 < 2u )
  {
    *a1 = v5;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (1005B470) --------------------------------------------------------
char __usercall sub_1005B470@<al>(float *a1@<esi>)
{
  double v1; // st7@15
  double v2; // st6@19
  double v3; // st7@25
  double v4; // st7@31
  char result; // al@36
  char v6; // [sp+4h] [bp-2Ch]@2
  char v7; // [sp+5h] [bp-2Bh]@5
  char v8; // [sp+6h] [bp-2Ah]@8
  char v9; // [sp+7h] [bp-29h]@11
  float v10; // [sp+8h] [bp-28h]@2
  float v11; // [sp+Ch] [bp-24h]@21
  float v12; // [sp+10h] [bp-20h]@17
  float v13; // [sp+14h] [bp-1Ch]@14
  float v14; // [sp+18h] [bp-18h]@23
  float v15; // [sp+1Ch] [bp-14h]@29
  float v16; // [sp+20h] [bp-10h]@1
  float v17; // [sp+24h] [bp-Ch]@21
  double v18; // [sp+28h] [bp-8h]@21

  *a1 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 1744, 0, 4, &v16) )
    goto LABEL_40;
  v16 = v16 * 61.02374267578125;
  v10 = v16;
  if ( (unsigned __int8)sub_10030F60(1, 134, 0, 1, &v6) && !v6 )
    v10 = v10 + 39.90000152587891;
  if ( (unsigned __int8)sub_10030F60(1, 634, 0, 1, &v7) && !v7 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_10030F60(1, 649, 0, 1, &v8) && !v8 )
    v10 = v10 + 2.5;
  if ( (unsigned __int8)sub_10030F60(1, 1757, 0, 1, &v9) && v9 )
    v10 = v10 + 13.5;
  if ( sub_10033F20(&v13) )
    v1 = v13 * 1.799999952316284 + 32.0;
  else
    v1 = -65.0;
  v13 = v1;
  if ( (unsigned __int8)sub_10030F60(1, 1743, 0, 4, &v12) && v12 != 0.0 )
    v2 = v12 * 0.000145037702168338;
  else
    v2 = 3040.0;
  v12 = v2;
  v17 = v13 + 460.0;
  v18 = 0.0000344 - (v17 - 528.0) * 0.00000005;
  v11 = v18 * (v12 - 100.0) + 1.003999948501587;
  v11 = 100.0 - v17 * (v11 * 248.0) / v12;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  if ( (unsigned __int8)sub_10030F60(1, 1741, 0, 4, &v14) && v14 != 0.0 )
    v3 = v14 * 0.000145037702168338;
  else
    v3 = 3040.0;
  v14 = v3;
  v11 = (v14 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v11 * 124.0 * v17 / v14;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v4 = (unsigned __int8)sub_10030F60(1, 1742, 0, 4, &v15) && v15 != 0.0 ? v15 * 0.000145037702168338 : 3040.0;
  v15 = v4;
  v16 = (v15 - 100.0) * v18 + 1.003999948501587;
  v11 = 50.0 - v16 * 124.0 * v17 / v15;
  if ( v11 > 0.0 )
    v10 = v11 + v10;
  v17 = v12 * 631.0 / 250000.0;
  v10 = v17 + v10;
  v17 = 631.0 * ((v13 - 59.0) * 0.0004556);
  v17 = v17 + v10;
  v17 = (v17 - 300.0 + 100.0) / 100.0;
  if ( v17 <= 1.25 )
  {
    *a1 = v17;
    result = 1;
  }
  else
  {
LABEL_40:
    result = 0;
  }
  return result;
}

//----- (1005B810) --------------------------------------------------------
char __usercall sub_1005B810@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  *a1 = 0.0;
  if ( sub_100472F0(0x40Du, &v3) && sub_100472F0(0x40Eu, &v2) && v2 != 0.0 )
  {
    result = 1;
    *a1 = v3 / v2 * 11.35624027252197 + 0.1147093996405602;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005B880) --------------------------------------------------------
char __usercall sub_1005B880@<al>(float *a1@<esi>)
{
  char result; // al@1
  float *v2; // [sp+0h] [bp-8h]@0

  result = sub_10034010(v2);
  if ( result )
    result = 1;
  else
    *a1 = 9.8999998e24;
  return result;
}

//----- (1005B8A0) --------------------------------------------------------
char __usercall sub_1005B8A0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  char result; // al@4
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_100472F0(0x4Fu, &v5);
  v2 = sub_100472F0(0x7EAu, &v6);
  if ( v1 )
  {
    if ( !v2 )
    {
      result = 1;
      *a1 = v5;
      return result;
    }
    v3 = v5;
    v5 = v6 - v5;
    LODWORD(v5) &= 0x7FFFFFFFu;
    if ( v5 <= 34473.789 )
    {
      result = 1;
      *a1 = (v6 + v3) * 0.5;
      return result;
    }
  }
  else if ( v2 )
  {
    result = 1;
    *a1 = v6;
    return result;
  }
  return 0;
}

//----- (1005B930) --------------------------------------------------------
void __usercall sub_1005B930(float *a1@<esi>)
{
  char v1; // bl@1
  char v2; // al@1
  double v3; // st6@3
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@1

  v1 = sub_100472F0(0x51u, &v4);
  v2 = sub_100472F0(0x7EBu, &v5);
  if ( v1 )
  {
    if ( !v2 )
    {
      *a1 = v4;
      return;
    }
    v3 = v4;
    v4 = v5 - v4;
    LODWORD(v4) &= 0x7FFFFFFFu;
    if ( v4 <= 5.0 )
    {
      *a1 = (v5 + v3) * 0.5;
      return;
    }
  }
  else if ( v2 )
  {
    *a1 = v5;
    return;
  }
  *a1 = 21.1;
}

//----- (1005B9C0) --------------------------------------------------------
char __cdecl sub_1005B9C0(float *a1)
{
  char v1; // bl@1
  char result; // al@2
  float v3; // [sp+8h] [bp-18h]@1
  double v4; // [sp+Ch] [bp-14h]@1
  float v5; // [sp+14h] [bp-Ch]@2
  double v6; // [sp+18h] [bp-8h]@2

  v1 = sub_1005B8A0((float *)&v4);
  sub_1005B930(&v3);
  if ( v1 )
  {
    v5 = (v3 + 67.77799987792969) / 27.77799987792969;
    v3 = (*(float *)&v4 + 517.0900268554688) / 4137139.5;
    v4 = v5 * 27.79999923706055;
    v5 = pow(315.0 - v4, 2.0);
    v6 = v5 * 5.470000147278498e-11;
    v5 = pow(v3 * 41.40000152587891, 2.0);
    v6 = v5 * v6;
    v5 = pow(215.0 - v4, 2.0);
    v5 = v6 - v5 * 0.00000005260000079942984 * 41.40000152587891 * v3 + 1.0;
    *a1 = v3 / (v4 + 205.3000030517578) * (1.0 / v5 * 127823.0) - 195.0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005BAE0) --------------------------------------------------------
char __usercall sub_1005BAE0@<al>(float *a1@<esi>, float a2)
{
  char v2; // bl@1
  double v3; // st7@3
  long double v4; // st7@3
  float v6; // [sp+0h] [bp-20h]@1
  float v7; // [sp+4h] [bp-1Ch]@1
  float v8; // [sp+8h] [bp-18h]@3
  float v9; // [sp+Ch] [bp-14h]@1
  int v10; // [sp+10h] [bp-10h]@3
  float v11; // [sp+14h] [bp-Ch]@5
  float v12; // [sp+18h] [bp-8h]@5
  float v13; // [sp+1Ch] [bp-4h]@5
  float v14; // [sp+24h] [bp+4h]@3
  float v15; // [sp+24h] [bp+4h]@3
  unsigned __int8 v16; // [sp+24h] [bp+4h]@3

  v2 = 0;
  v9 = a2 * 32.0 * 0.0005787039990536869;
  v7 = 0.0;
  v6 = 0.0;
  if ( sub_100472F0(0x4Fu, &v7) && sub_100472F0(0x51u, &v6) )
  {
    *(float *)&v10 = v7 / 101325.0;
    v14 = v6 + 273.0;
    v7 = v7 * 0.000145037702168338;
    v6 = v6 * 1.799999952316284 + 32.0;
    v15 = v14 * 0.08205779641866684 / *(float *)&v10;
    v3 = v15 * 0.002983009908348322;
    v16 = 0;
    v8 = v3;
    v4 = v9;
    do
    {
      if ( v16 >= 5u )
        break;
      v12 = pow(v4, 2.0);
      v11 = pow(v8 / v9, 2.0);
      v11 = (v9 - 0.5099999904632568 * v8) * (v11 * 5140.0 + v7 + 14.69999980926514)
          - (v6 + 460.0) * 10.71000003814697 * v8;
      v13 = v11;
      v11 = pow(v8, 2.0);
      v12 = -((v11 * 7864200.0 + 10710.0 * v12 * v6 + v12 * 510.0 * v7 - 10280000.0 * v9 * v8 + v12 * 4934097.0)
            / (v12
             * 1000.0));
      v13 = v13 / v12;
      v8 = v8 - v13;
      v4 = v9;
      v10 = LODWORD(v13) & 0x7FFFFFFF;
      if ( COERCE_FLOAT(LODWORD(v13) & 0x7FFFFFFF) < 0.001 )
      {
        v2 = 1;
        *a1 = v8 / 0.002983009908348322;
      }
      ++v16;
    }
    while ( !v2 );
  }
  return v2;
}

//----- (1005BCE0) --------------------------------------------------------
char __usercall sub_1005BCE0@<al>(float *a1@<esi>, float a2)
{
  char v2; // al@3
  char result; // al@5
  float v4; // [sp+4h] [bp-4h]@3

  if ( LOBYTE(a2) )
  {
    if ( !sub_10015A90(1, 1516, 0, 4, &a2) )
      return 0;
    v2 = sub_10015A90(0, 356, 0, 4, &v4);
  }
  else
  {
    if ( !sub_10015A90(1, 2447, 0, 4, &a2) )
      return 0;
    v2 = sub_10015A90(0, 357, 0, 4, &v4);
  }
  if ( v2 )
  {
    result = 1;
    *a1 = a2 - v4;
    return result;
  }
  return 0;
}

//----- (1005BD70) --------------------------------------------------------
char __usercall sub_1005BD70@<al>(float *a1@<eax>)
{
  return sub_10043480(a1);
}

//----- (1005BD80) --------------------------------------------------------
char __usercall sub_1005BD80@<al>(float *a1@<eax>)
{
  return sub_10043550(a1);
}

//----- (1005BD90) --------------------------------------------------------
char __usercall sub_1005BD90@<al>(float *a1@<eax>)
{
  return sub_10043620(a1);
}

//----- (1005BDA0) --------------------------------------------------------
char __usercall sub_1005BDA0@<al>(float *a1@<eax>)
{
  return sub_100436F0(a1);
}

//----- (1005BDB0) --------------------------------------------------------
int __usercall sub_1005BDB0@<eax>(char a1@<dl>, int a2@<ecx>, float *a3)
{
  int result; // eax@1
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  result = sub_10030F60(a1, a2, 0, 4, &v4);
  if ( (_BYTE)result )
    *a3 = (double)v4 * 0.00000008381903171539307;
  return result;
}

//----- (1005BDE0) --------------------------------------------------------
char __usercall sub_1005BDE0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  double v2; // st7@3
  char result; // al@9
  float v4; // [sp+4h] [bp-8h]@1
  float v5; // [sp+8h] [bp-4h]@2

  v1 = 0;
  if ( sub_10015A90(6, 41, 0, 4, &v4) && sub_10015A90(6, 42, 0, 4, &v5) )
  {
    v2 = (v5 + v4) * 0.5;
LABEL_8:
    *a1 = v2;
    v1 = 1;
    goto LABEL_9;
  }
  if ( sub_10015A90(6, 41, 0, 4, &v4) )
  {
    v2 = v4;
    goto LABEL_8;
  }
  if ( sub_10015A90(6, 42, 0, 4, &v5) )
  {
    v2 = v5;
    goto LABEL_8;
  }
LABEL_9:
  result = v1;
  *a1 = *a1 * 1.943844437599182;
  return result;
}

//----- (1005BE80) --------------------------------------------------------
char __usercall sub_1005BE80@<al>(float *a1@<esi>)
{
  char result; // al@6
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@3
  char v4; // [sp+7h] [bp-B5h]@4
  char v5; // [sp+8h] [bp-B4h]@5
  char v6; // [sp+9h] [bp-B3h]@2
  float v7; // [sp+14h] [bp-A8h]@6
  float v8; // [sp+20h] [bp-9Ch]@9

  if ( (unsigned __int8)sub_10030F60(6, 429, 0, 180, &v2) )
  {
    if ( v6 )
    {
LABEL_9:
      result = 1;
      *a1 = v8;
      return result;
    }
    if ( (!v3 || !v4) && v5 )
      goto LABEL_6;
  }
  if ( (unsigned __int8)sub_10030F60(6, 430, 0, 180, &v2) )
  {
    if ( v6 )
      goto LABEL_9;
    if ( (!v3 || !v4) && v5 )
    {
LABEL_6:
      result = 1;
      *a1 = v7;
      return result;
    }
  }
  return 0;
}

//----- (1005BF60) --------------------------------------------------------
char __cdecl sub_1005BF60(float *a1)
{
  char result; // al@3
  float v2; // [sp+4h] [bp-8h]@2
  float v3; // [sp+8h] [bp-4h]@1

  if ( sub_1005F6A0(87, &v3) && sub_1005F6A0(88, &v2) )
  {
    result = 1;
    *a1 = (v2 + v3) * 0.5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005BFB0) --------------------------------------------------------
char __usercall sub_1005BFB0@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+6h] [bp-B6h]@2
  char v4; // [sp+7h] [bp-B5h]@3
  float v5; // [sp+Ch] [bp-B0h]@5
  float v6; // [sp+18h] [bp-A4h]@9

  if ( (unsigned __int8)sub_10030F60(6, 429, 0, 180, &v2) )
  {
    if ( v3 && v4 )
      goto LABEL_9;
    if ( v2 )
    {
LABEL_5:
      result = 1;
      *a1 = v5;
      return result;
    }
  }
  if ( (unsigned __int8)sub_10030F60(6, 430, 0, 180, &v2) )
  {
    if ( v3 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v6;
      return result;
    }
    if ( v2 )
      goto LABEL_5;
  }
  return 0;
}

//----- (1005C090) --------------------------------------------------------
char __usercall sub_1005C090@<al>(float *a1@<esi>)
{
  char result; // al@5
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+5h] [bp-B7h]@4
  char v4; // [sp+6h] [bp-B6h]@3
  char v5; // [sp+7h] [bp-B5h]@2
  float v6; // [sp+10h] [bp-ACh]@5
  float v7; // [sp+1Ch] [bp-A0h]@9

  if ( (unsigned __int8)sub_10030F60(6, 429, 0, 180, &v2) )
  {
    if ( v5 && v4 )
      goto LABEL_9;
    if ( v3 )
    {
LABEL_5:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_10030F60(6, 430, 0, 180, &v2) )
  {
    if ( v5 && v4 )
    {
LABEL_9:
      result = 1;
      *a1 = v7;
      return result;
    }
    if ( v3 )
      goto LABEL_5;
  }
  return 0;
}

//----- (1005C170) --------------------------------------------------------
char __usercall sub_1005C170@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+44h] [bp-78h]@2
  float v4; // [sp+50h] [bp-6Ch]@3

  if ( (unsigned __int8)sub_10030F60(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_10030F60(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005C210) --------------------------------------------------------
char __usercall sub_1005C210@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+40h] [bp-7Ch]@2
  float v4; // [sp+48h] [bp-74h]@3

  if ( (unsigned __int8)sub_10030F60(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_10030F60(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005C2B0) --------------------------------------------------------
char __usercall sub_1005C2B0@<al>(float *a1@<esi>)
{
  char result; // al@3
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+41h] [bp-7Bh]@2
  float v4; // [sp+4Ch] [bp-70h]@3

  if ( (unsigned __int8)sub_10030F60(6, 429, 0, 180, &v2) && v3
    || (unsigned __int8)sub_10030F60(6, 430, 0, 180, &v2) && v3 )
  {
    result = 1;
    *a1 = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005C350) --------------------------------------------------------
char __usercall sub_1005C350@<al>(float *a1@<esi>)
{
  char result; // al@4
  char v2; // [sp+4h] [bp-B8h]@1
  char v3; // [sp+80h] [bp-3Ch]@2
  char v4; // [sp+81h] [bp-3Bh]@3
  float v5; // [sp+8Ch] [bp-30h]@7
  float v6; // [sp+98h] [bp-24h]@4

  if ( (unsigned __int8)sub_10030F60(6, 429, 0, 180, &v2) )
  {
    if ( v3 )
    {
LABEL_7:
      result = 1;
      *a1 = v5;
      return result;
    }
    if ( v4 )
    {
LABEL_4:
      result = 1;
      *a1 = v6;
      return result;
    }
  }
  if ( (unsigned __int8)sub_10030F60(6, 430, 0, 180, &v2) )
  {
    if ( v3 )
      goto LABEL_7;
    if ( v4 )
      goto LABEL_4;
  }
  return 0;
}

//----- (1005C430) --------------------------------------------------------
char __cdecl sub_1005C430(float *a1)
{
  double v1; // st7@2
  char result; // al@5
  float v3; // ST04_4@5
  float v4; // [sp+0h] [bp-Ch]@1
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v4 = 9.8999998e24;
  v5 = sub_10043800();
  if ( sub_10043380(&v6) && (v1 = v5, v5 != 9.8999998e24) )
  {
    if ( v1 >= 3785.411865234375 || v6 <= 0.0001051503277267329 )
    {
      result = 1;
      *a1 = v4;
    }
    else
    {
      result = 1;
      v3 = v1 / v6;
      *a1 = v3;
    }
  }
  else
  {
    *a1 = v4;
    result = 0;
  }
  return result;
}

//----- (1005C4D0) --------------------------------------------------------
bool __cdecl sub_1005C4D0(float *a1)
{
  char v1; // bl@1
  bool v2; // al@1
  double v3; // st6@5
  float v5; // [sp+4h] [bp-8h]@1
  float v6; // [sp+8h] [bp-4h]@1

  v1 = sub_1005C430(&v5);
  v2 = sub_1002BFC0(&v6);
  if ( !v1
    || !v2
    || v5 == 9.8999998e24
    || (LODWORD(v6) & 0x7F800000) == 2139095040
    || (v5 = v5 * v6, v3 = v5, v5 > 37040000.0) )
  {
    v5 = 9.8999998e24;
    v3 = (float)9.8999998e24;
  }
  *a1 = v3;
  return v2 && v1 && v3 != 9.8999998e24;
}

//----- (1005C580) --------------------------------------------------------
char __usercall sub_1005C580@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_10030F60(1, 90, 0, 4, &v2)
    && (unsigned __int8)sub_10030F60(1, 115, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005C600) --------------------------------------------------------
char __usercall sub_1005C600@<al>(float *a1@<esi>)
{
  char result; // al@5
  float v2; // [sp+4h] [bp-8h]@1
  float v3; // [sp+8h] [bp-4h]@2

  *a1 = 9.8999998e24;
  if ( (unsigned __int8)sub_10030F60(1, 527, 0, 4, &v2)
    && (unsigned __int8)sub_10030F60(1, 530, 0, 4, &v3)
    && v2 != 9.8999998e24
    && v3 != 9.8999998e24 )
  {
    result = 1;
    *a1 = v3 - v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005C690) --------------------------------------------------------
char __usercall sub_1005C690@<al>(float *a1@<esi>)
{
  char result; // al@4
  float v2; // [sp+0h] [bp-Ch]@1
  float v3; // [sp+4h] [bp-8h]@2
  float v4; // [sp+8h] [bp-4h]@3

  *a1 = 9.8999998e24;
  if ( sub_1002BFC0(&v2) && (v3 = v2, (LODWORD(v2) & 0x7F800000) != 2139095040) && sub_10043380(&v4) )
  {
    result = 1;
    if ( v4 > 0.0001051503277267329 )
      *a1 = v2 / v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005C700) --------------------------------------------------------
int __cdecl sub_1005C700(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10030F60(1, 74, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 75, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 76, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 77, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 78, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 79, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (1005C930) --------------------------------------------------------
int __cdecl sub_1005C930(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10030F60(1, 99, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 100, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 101, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 102, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 103, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 104, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (1005CB60) --------------------------------------------------------
int __cdecl sub_1005CB60(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10030F60(1, 68, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 69, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 70, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 71, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 72, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 73, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (1005CD90) --------------------------------------------------------
int __cdecl sub_1005CD90(float *a1)
{
  char v1; // bl@1
  double v2; // st6@18
  int result; // eax@33
  float v4; // [sp+4h] [bp-1Ch]@1
  float v5; // [sp+8h] [bp-18h]@1
  float v6; // [sp+Ch] [bp-14h]@3
  float v7; // [sp+10h] [bp-10h]@5
  float v8; // [sp+14h] [bp-Ch]@7
  float v9; // [sp+18h] [bp-8h]@9
  float v10; // [sp+1Ch] [bp-4h]@11

  v4 = -9.8999998e24;
  v1 = 0;
  if ( !(unsigned __int8)sub_10030F60(1, 93, 0, 4, &v5) )
    v5 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 94, 0, 4, &v6) )
    v6 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 95, 0, 4, &v7) )
    v7 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 96, 0, 4, &v8) )
    v8 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 97, 0, 4, &v9) )
    v9 = 9.8999998e24;
  if ( !(unsigned __int8)sub_10030F60(1, 98, 0, 4, &v10) )
    v10 = 9.8999998e24;
  if ( v5 != 9.8999998e24 && v5 > -9.8999998e24 )
  {
    v4 = v5;
    v1 = 1;
  }
  if ( v6 == 9.8999998e24 || v4 + 0.05000000074505806 >= v6 )
  {
    v2 = 0.05000000074505806;
  }
  else
  {
    v2 = 0.05000000074505806;
    v1 = 1;
    v4 = v6;
  }
  if ( v7 != 9.8999998e24 && v4 + v2 < v7 )
  {
    v4 = v7;
    v1 = 1;
  }
  if ( v8 != 9.8999998e24 && v4 + v2 < v8 )
  {
    v4 = v8;
    v1 = 1;
  }
  if ( v9 != 9.8999998e24 && v4 + v2 < v9 )
  {
    v4 = v9;
    v1 = 1;
  }
  if ( v10 != 9.8999998e24 && v10 > v2 + v4 )
  {
    v4 = v10;
    v1 = 1;
  }
  if ( -9.8999998e24 == v4 )
  {
    *a1 = 9.8999998e24;
    result = (unsigned __int8)v1;
  }
  else
  {
    *a1 = v4;
    result = (unsigned __int8)v1;
  }
  return result;
}

//----- (1005CFC0) --------------------------------------------------------
char __usercall sub_1005CFC0@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@4
  float v3; // [sp+4h] [bp-24h]@1
  float v4; // [sp+8h] [bp-20h]@1
  char v5; // [sp+Ch] [bp-1Ch]@1
  float v6; // [sp+18h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  v4 = sub_10043800();
  sub_10060E40(41109, &v5, 24, &unk_1011EA80);
  if ( v6 != 9.8999998e24 && v4 != 9.8999998e24 )
  {
    v1 = 1;
    v3 = v4 - v6;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (1005D050) --------------------------------------------------------
char __usercall sub_1005D050@<al>(float *a1@<esi>)
{
  char v1; // bl@1
  char result; // al@3
  float v3; // [sp+4h] [bp-20h]@1
  char v4; // [sp+8h] [bp-1Ch]@1
  float v5; // [sp+14h] [bp-10h]@1

  v3 = 9.8999998e24;
  v1 = 0;
  sub_10060E40(41109, &v4, 24, &unk_1011EA80);
  if ( v5 != 9.8999998e24 )
  {
    v3 = v5;
    v1 = 1;
  }
  result = v1;
  *a1 = v3;
  return result;
}

//----- (1005D0C0) --------------------------------------------------------
bool __cdecl sub_1005D0C0(float *a1)
{
  bool v1; // bl@1
  bool result; // al@3
  float v3; // [sp+4h] [bp-4h]@1

  v3 = 9.8999998e24;
  v1 = sub_1002E600(&v3, 0, 0, 2) != 0;
  if ( 9.8999998e24 != v3 )
    v3 = sub_1002E300() + v3;
  result = v1;
  *a1 = v3;
  return result;
}

//----- (1005D120) --------------------------------------------------------
char __cdecl sub_1005D120(float a1, void *a2)
{
  __int16 v2; // cx@1
  char result; // al@4
  double v4; // st7@32
  double v5; // st7@69
  float v6; // ST0C_4@70
  float v7; // [sp+Ch] [bp-4h]@1
  float v8; // [sp+14h] [bp+4h]@32
  float v9; // [sp+14h] [bp+4h]@35

  HIBYTE(v2) = BYTE1(a1);
  v7 = 9.8999998e24;
  if ( (signed int)LOWORD(a1) > 301 )
  {
    switch ( LOWORD(a1) )
    {
      case 0x12Eu:
        v5 = 511.0;
        goto LABEL_70;
      case 0x12Fu:
        v5 = 1000.0;
        goto LABEL_70;
      case 0x191u:
        result = sub_1005B810((float *)a2);
        break;
      case 0x192u:
        result = sub_1005B200(0.0, (int)a2);
        break;
      case 0x193u:
        result = sub_1005B200(COERCE_FLOAT(1), (int)a2);
        break;
      case 0x194u:
        result = sub_1005BF60((float *)a2);
        break;
      case 0x195u:
        result = sub_1005AF10((int)a2);
        break;
      case 0x196u:
      case 0x197u:
        result = sub_1005B110((float *)a2, LOWORD(a1) == 406);
        break;
      case 0x198u:
      case 0x199u:
        LOBYTE(v2) = LOWORD(a1) == 408;
        result = ((char (__usercall *)@<al>(float *@<esi>, __int16))sub_1005BCE0)((float *)a2, v2);
        break;
      case 0x19Au:
        result = sub_1005BDE0((float *)a2);
        break;
      case 0x19Bu:
        result = sub_1005AD90(a2);
        break;
      case 0x19Cu:
        result = sub_1005BD80((float *)a2);
        break;
      case 0x19Du:
        result = sub_1005BD90((float *)a2);
        break;
      case 0x19Eu:
        result = sub_1005BD70((float *)a2);
        break;
      case 0x19Fu:
        result = sub_1005BDA0((float *)a2);
        break;
      case 0x1A0u:
        result = sub_10060E40(9145, a2, 4, &v7) == 0;
        break;
      default:
LABEL_88:
        sub_10028BC0("..\\lib\\adl\\dat_custom_proc_prj.c", 724, 0, 0);
        result = 0;
        break;
    }
  }
  else if ( LOWORD(a1) == 301 )
  {
    v5 = 295.0;
LABEL_70:
    v6 = v5;
    result = sub_1005BAE0((float *)a2, v6);
  }
  else
  {
    switch ( LOWORD(a1) )
    {
      case 0u:
        return sub_1005C170((float *)a2);
      case 1u:
        return sub_1005C350((float *)a2);
      case 2u:
        return sub_1005BFB0((float *)a2);
      case 3u:
        return sub_1005C090((float *)a2);
      case 4u:
        return sub_1005BE80((float *)a2);
      case 5u:
        return sub_1005B9C0((float *)a2);
      case 7u:
        return sub_1005C210((float *)a2);
      case 6u:
        return sub_1005C2B0((float *)a2);
      case 9u:
        return sub_1005AFB0((float *)a2);
      case 0xAu:
        return sub_1005B000((float *)a2);
      case 0xBu:
        return sub_1005B470((float *)a2);
      case 0xDu:
        *(float *)a2 = sub_10042D10();
        return 1;
      case 0x38u:
        return sub_1005B8A0((float *)a2);
      case 0x39u:
        sub_1005B930((float *)a2);
        goto LABEL_18;
      case 0x3Au:
        return sub_1005B350((float *)a2);
      case 0x3Bu:
        return sub_1005B3E0((float *)a2);
      case 0x3Cu:
        return sub_1005B2F0((float *)a2);
      case 0x3Du:
        return sub_1005B270((float *)a2);
      case 8u:
        return sub_1005ADD0((float *)a2);
      case 0xCu:
        return sub_1005B880((float *)a2);
      case 0xEu:
        return sub_10043410((float *)a2);
      case 0xFu:
        return sub_10043790((float *)a2);
      case 0x10u:
        return sub_100432D0((float *)a2);
      case 0x11u:
        return sub_100438E0((float *)a2);
      case 0x12u:
        return sub_10043340((float *)a2);
      case 0x13u:
        return sub_10043360((float *)a2);
      case 0x14u:
        return sub_10043380((float *)a2);
      case 0x15u:
        v8 = sub_10043800();
        v4 = v8;
        *(float *)a2 = v8;
        goto LABEL_33;
      case 0x35u:
        v9 = sub_10042CE0();
        v4 = v9;
        *(float *)a2 = v9;
LABEL_33:
        if ( 9.8999998e24 == v4 )
          result = 0;
        else
LABEL_18:
          result = 1;
        break;
      case 0x16u:
        result = sub_1005B050((float *)a2);
        break;
      case 0x17u:
        result = sub_1005B0B0((float *)a2);
        break;
      case 0x18u:
        result = sub_1005C430((float *)a2);
        break;
      case 0x19u:
        result = sub_1005C4D0((float *)a2);
        break;
      case 0x1Au:
        result = sub_1005C580((float *)a2);
        break;
      case 0x1Bu:
        result = sub_1005C600((float *)a2);
        break;
      case 0x1Cu:
        result = sub_1005C690((float *)a2);
        break;
      case 0x1Du:
        result = sub_1005C700((float *)a2);
        break;
      case 0x1Eu:
        result = sub_1005C930((float *)a2);
        break;
      case 0x1Fu:
        result = sub_1005CB60((float *)a2);
        break;
      case 0x20u:
        result = sub_1005CD90((float *)a2);
        break;
      case 0x21u:
        result = sub_1005BDB0(6, 59, (float *)a2);
        break;
      case 0x22u:
        result = sub_1005BDB0(6, 60, (float *)a2);
        break;
      case 0x23u:
        result = sub_1005BDB0(6, 61, (float *)a2);
        break;
      case 0x24u:
        result = sub_1005BDB0(6, 62, (float *)a2);
        break;
      case 0x25u:
        result = sub_1005ADF0((float *)a2);
        break;
      case 0x26u:
        result = sub_1005AE50((float *)a2);
        break;
      case 0x27u:
        result = sub_1005AEB0((float *)a2);
        break;
      case 0x2Au:
        result = sub_10060E40(9000, a2, 4, &v7) == 0;
        break;
      case 0x2Bu:
        result = sub_10060E40(9001, a2, 4, &v7) == 0;
        break;
      case 0x2Cu:
        result = sub_10060E40(9002, a2, 4, &v7) == 0;
        break;
      case 0x2Du:
        result = sub_10060E40(9003, a2, 4, &v7) == 0;
        break;
      case 0x2Eu:
        result = sub_10060E40(9004, a2, 4, &v7) == 0;
        break;
      case 0x2Fu:
        result = sub_10060E40(9005, a2, 4, &v7) == 0;
        break;
      case 0x30u:
        result = sub_10060E40(9006, a2, 4, &v7) == 0;
        break;
      case 0x31u:
        result = sub_10060E40(9007, a2, 4, &v7) == 0;
        break;
      case 0x32u:
        result = sub_10060E40(9008, a2, 4, &v7) == 0;
        break;
      case 0x33u:
        result = sub_10060E40(9009, a2, 4, &v7) == 0;
        break;
      case 0x34u:
        result = sub_10060E40(9010, a2, 4, &v7) == 0;
        break;
      case 0x28u:
        result = sub_1005CFC0((float *)a2);
        break;
      case 0x29u:
        result = sub_1005D050((float *)a2);
        break;
      case 0x36u:
        result = sub_1005D0C0((float *)a2);
        break;
      case 0x37u:
        result = sub_1002E600((float *)a2, 0, 0, 2) != 0;
        break;
      default:
        goto LABEL_88;
    }
  }
  return result;
}

//----- (1005D9D0) --------------------------------------------------------
int __cdecl sub_1005D9D0(int a1)
{
  return (*(int (**)(void))(a1 + 4))();
}

//----- (1005D9E0) --------------------------------------------------------
char __cdecl sub_1005D9E0(signed int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax@2
  char result; // al@4

  if ( a1 < 50 && ((v3 = 592 * a1, byte_109E4358[592 * a1]) || byte_109E43A8[v3]) )
  {
    *a2 = &byte_109E4358[v3];
    *a3 = &byte_109E43A8[v3];
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005DA20) --------------------------------------------------------
char *__cdecl sub_1005DA20(const char *a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v3 = byte_109E4358;
  v4 = 0;
  while ( strcmp(v3, a1) )
  {
    v4 += 592;
    ++v2;
    v3 += 592;
    if ( v4 >= 0x73A0 )
      return (char *)a2;
  }
  return &byte_109E43A8[592 * v2];
}

//----- (1005DA90) --------------------------------------------------------
char *__usercall sub_1005DA90@<eax>(char *result@<eax>)
{
  char v1; // cl@2

  for ( ; *result; ++result )
  {
    v1 = *result;
    if ( *result == 10 || v1 == 35 )
    {
      *result = 0;
    }
    else if ( v1 == 92 )
    {
      *result = 47;
    }
  }
  return result;
}

//----- (1005DAC0) --------------------------------------------------------
void __cdecl sub_1005DAC0(char *a1)
{
  char *v1; // eax@3
  char *v2; // edi@3
  char *v3; // eax@4
  int v4; // ST14_4@5
  char *v5; // eax@5
  char v6; // [sp+4h] [bp-204h]@1

  v6 = 0;
  if ( a1 )
  {
    if ( *a1 )
    {
      v1 = strstr(a1, "$$(");
      v2 = v1;
      if ( v1 )
      {
        v3 = strchr(v1 + 3, 41);
        if ( v3 )
        {
          *v2 = 0;
          *v3 = 0;
          v4 = (int)(v3 + 1);
          v5 = sub_1005DA20(v2 + 3, (int)&byte_10080D49);
          sprintf(&v6, "%s%s%s", a1, v5, v4);
          sub_1005DAC0(&v6);
          strcpy(a1, &v6);
        }
      }
    }
  }
}

//----- (1005DB80) --------------------------------------------------------
void __cdecl sub_1005DB80(char *a1, char *a2)
{
  char *v2; // eax@2
  int v3; // edx@2
  char *v4; // esi@2
  char v5; // cl@3
  char *v6; // eax@4
  char *v7; // esi@4
  char *v8; // edx@4
  char v9; // cl@5

  if ( dword_109E4350 < 50 )
  {
    v2 = a1;
    v3 = 592 * dword_109E4350;
    v4 = (char *)(&byte_109E4358[592 * dword_109E4350] - a1);
    do
    {
      v5 = *v2;
      v2[(_DWORD)v4] = *v2;
      ++v2;
    }
    while ( v5 );
    v6 = a2;
    v7 = &byte_109E43A8[v3];
    v8 = (char *)(&byte_109E43A8[v3] - a2);
    do
    {
      v9 = *v6;
      v6[(_DWORD)v8] = *v6;
      ++v6;
    }
    while ( v9 );
    sub_1005DAC0(v7);
    ++dword_109E4350;
  }
}
// 109E4350: using guessed type int dword_109E4350;

//----- (1005DBE0) --------------------------------------------------------
void *__cdecl sub_1005DBE0(int a1)
{
  void *result; // eax@1
  unsigned int v2; // eax@2
  unsigned int v3; // ebp@2
  char *v4; // edi@4
  char *v5; // esi@4
  char *v6; // eax@4
  const char *v7; // esi@6
  const char *v8; // ebx@6
  char *v9; // edi@6
  char *v10; // eax@6
  char v11; // [sp+4h] [bp-204h]@3

  result = memset(byte_109E4358, 0, 0x73A0u);
  dword_109E4350 = 0;
  if ( a1 )
  {
    v2 = sub_1005A3E0(a1, 0);
    v3 = v2;
    if ( v2 )
    {
      if ( sub_1005A5C0((int)&v11, 512, v2) )
      {
        do
        {
          sub_1005DA90(&v11);
          v4 = strstr(&v11, "=");
          v5 = strstr(&v11, "<Var name=\"");
          v6 = strstr(&v11, " value=\"");
          if ( v5 && v6 )
          {
            v7 = v5 + 11;
            v8 = v6 + 8;
            v9 = strchr(v7, 34);
            v10 = strchr(v8, 34);
            if ( v9 )
            {
              if ( v10 )
              {
                *v9 = 0;
                *v10 = 0;
                sub_1005DB80((char *)v7, (char *)v8);
              }
            }
          }
          else if ( v4 && !strpbrk(&v11, "<>") )
          {
            *v4 = 0;
            sub_1005DB80(&v11, v4 + 1);
          }
        }
        while ( sub_1005A5C0((int)&v11, 512, v3) );
      }
      result = (void *)sub_1005A390(v3);
    }
    else
    {
      result = (void *)sub_10049D00(
                         3,
                         (int)"**Warning**",
                         (int)"..\\lib\\utf\\utf_cnfg.c",
                         (int)"269",
                         (int)"Configuration File",
                         a1,
                         (int)"Unable to open configuration file");
    }
  }
  return result;
}
// 109E4350: using guessed type int dword_109E4350;

//----- (1005DD70) --------------------------------------------------------
int __cdecl sub_1005DD70(int a1, int a2)
{
  unsigned int v2; // eax@5
  int v3; // eax@8
  int v4; // eax@10
  int result; // eax@11

  if ( a2 && *(_DWORD *)(a2 + 8) && *(_WORD *)(a2 + 12) && *(_DWORD *)(a2 + 4) )
  {
    v2 = *(_DWORD *)(a1 + 4);
    if ( v2 < 0xFFFFFFC2 && v2 )
    {
      j_IOP_pvg_sk_close(v2, *(_DWORD *)(a2 + 20));
      *(_DWORD *)(a1 + 4) = 0;
    }
    *(_BYTE *)(*(_WORD *)(a2 + 12) + *(_DWORD *)(a2 + 8) - 1) = 0;
    *(_DWORD *)a1 = a2;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 30) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_BYTE *)(a1 + 28) = 0;
    v3 = j_IOP_pvg_sk_create_id(*(_WORD *)a2);
    *(_DWORD *)(a1 + 4) = v3;
    if ( *(_DWORD *)(a2 + 36) )
      j_IOP_pvg_sk_set_addr(v3, 0, *(_DWORD *)(a2 + 36));
    v4 = *(_DWORD *)(a1 + 4);
    if ( *(_BYTE *)(a2 + 14) & 8 )
      result = j_IOP_pvg_sk_connect(v4, *(_DWORD *)(a2 + 16));
    else
      result = j_IOP_pvg_sk_accept(v4, a1 + 8, *(_DWORD *)(a2 + 16));
  }
  else
  {
    result = -59;
  }
  return result;
}
// 10061F70: using guessed type int __cdecl j_IOP_pvg_sk_accept(_DWORD, _DWORD, _DWORD);
// 10061F80: using guessed type int __cdecl j_IOP_pvg_sk_close(_DWORD, _DWORD);
// 10061F90: using guessed type int __cdecl j_IOP_pvg_sk_connect(_DWORD, _DWORD);
// 10061FA0: using guessed type int __cdecl j_IOP_pvg_sk_create_id(_DWORD);
// 10062050: using guessed type int __cdecl j_IOP_pvg_sk_set_addr(_DWORD, _DWORD, _DWORD);

//----- (1005DEB0) --------------------------------------------------------
char __usercall sub_1005DEB0@<al>(int a1@<eax>, int a2@<ebx>, signed int a3, _WORD *a4, char a5)
{
  _WORD *v5; // edx@1
  int v6; // esi@1
  char result; // al@1
  char v8; // cl@5
  unsigned __int16 v9; // cx@11
  signed int v10; // edi@12
  signed int v11; // esi@12
  size_t v12; // ebp@13

  v5 = a4;
  v6 = a1;
  result = 0;
  if ( *a4 >= a3 )
  {
    *a4 = 0;
    *(_BYTE *)a2 = 0;
  }
  if ( a5 == -1 )
    *(_BYTE *)(v6 + 28) = 3;
  v8 = *(_BYTE *)(v6 + 28);
  if ( v8 )
  {
    *(_BYTE *)(v6 + 28) = v8 - 1;
    result = 0;
  }
  else if ( a5 != 13 && a5 != 10 && a5 )
  {
    *(_BYTE *)((*a4)++ + a2) = a5;
  }
  else
  {
    v9 = *a4;
    if ( *a4 )
    {
      v10 = v9;
      v11 = 0;
      if ( (signed int)v9 > 0 )
      {
        v12 = v9 - 1;
        do
        {
          if ( *(_BYTE *)(v11 + a2) == 8 )
          {
            if ( v11 )
            {
              memcpy_0((void *)(v11 + a2 - 1), (const void *)(v11 + a2 + 1), v10 - v11 - 1);
              v10 -= 2;
              v12 -= 2;
              v11 -= 2;
            }
            else
            {
              memcpy_0((void *)a2, (const void *)(a2 + 1), v12);
              --v10;
              --v12;
              v11 = -1;
            }
            v5 = a4;
          }
          ++v11;
        }
        while ( v11 < v10 );
      }
      *(_BYTE *)(v10 + a2) = 0;
      result = 1;
      *v5 = 0;
    }
  }
  return result;
}

//----- (1005DF80) --------------------------------------------------------
signed int __cdecl sub_1005DF80(_DWORD *a1, char *a2)
{
  int v2; // esi@1
  int v3; // ebx@4
  int v4; // ebp@4
  int v5; // eax@5
  signed int v6; // edi@5
  int v7; // ST0C_4@9
  char v8; // al@11
  int v10; // [sp+4h] [bp-38h]@4
  __int16 v11; // [sp+8h] [bp-34h]@9

  v2 = (int)a1;
  if ( a1 && *a1 && a2 )
  {
    *a2 = 0;
    v3 = *(_DWORD *)v2;
    v10 = *(_DWORD *)v2;
    v4 = 0;
    while ( 1 )
    {
      v5 = sub_10061FB0(*(_DWORD *)(v2 + 4), (int)&a1, 1, 0, v4);
      v6 = v5;
      if ( v5 == -57 )
      {
        if ( v4 == *(_DWORD *)(v3 + 24) )
          return v6;
        v4 = *(_DWORD *)(v3 + 24);
        v6 = 1;
      }
      else
      {
        if ( v5 >= 0 )
        {
          v8 = sub_1005DEB0(v2, *(_DWORD *)(v3 + 8), *(_WORD *)(v3 + 12), (_WORD *)(v2 + 30), (char)a1);
          v3 = v10;
          *a2 = v8;
          *(_DWORD *)(v2 + 24) += v6;
        }
        else
        {
          v7 = *(_DWORD *)(v2 + 4);
          v11 = 0;
          j_IOP_pvg_sk_status(v7, &v11);
          if ( !(v11 & 0x44) )
            sub_1005DD70(v2, v3);
        }
        if ( v6 <= 0 )
          return v6;
      }
      if ( *a2 )
        return v6;
    }
  }
  return -59;
}
// 10062060: using guessed type int __cdecl j_IOP_pvg_sk_status(_DWORD, _DWORD);

//----- (1005E060) --------------------------------------------------------
int sub_1005E060()
{
  return 0;
}

//----- (1005E070) --------------------------------------------------------
void __cdecl sub_1005E070(int a1)
{
  if ( a1 > 0 )
    exit_1(14);
}

//----- (1005E0A0) --------------------------------------------------------
int __cdecl sub_1005E0A0(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (1005E0C0) --------------------------------------------------------
bool __cdecl sub_1005E0C0(int a1)
{
  return *(_DWORD *)a1 && *(_DWORD *)(a1 + 4) && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12);
}

//----- (1005E0F0) --------------------------------------------------------
void *__cdecl sub_1005E0F0(int a1, int a2, int a3, int (__cdecl *a4)(unsigned int), int a5)
{
  void *v5; // eax@1

  *(_DWORD *)a5 = a1;
  *(_DWORD *)(a5 + 4) = a2;
  *(_DWORD *)(a5 + 8) = a3;
  v5 = (void *)a4(a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
  *(_DWORD *)(a5 + 12) = v5;
  return memset(v5, 0, a1 * a2 * ((unsigned int)(a3 + 7) >> 3));
}

//----- (1005E130) --------------------------------------------------------
unsigned int __usercall sub_1005E130@<eax>(int a1@<edx>, int a2, int a3)
{
  return *(_DWORD *)(a1 + 12) + ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3) * (a3 + a2 * *(_DWORD *)(a1 + 4));
}

//----- (1005E150) --------------------------------------------------------
int __usercall sub_1005E150@<eax>(int result@<eax>, int a2@<ecx>)
{
  *(_BYTE *)(result + 2) = *(_BYTE *)(a2 + 2);
  *(_BYTE *)(result + 1) = *(_BYTE *)(a2 + 1);
  *(_BYTE *)result = *(_BYTE *)a2;
  return result;
}

//----- (1005E170) --------------------------------------------------------
char __cdecl sub_1005E170(void (__cdecl *a1)(_DWORD), int a2)
{
  char result; // al@1

  result = sub_1005E0C0(a2);
  if ( result )
  {
    a1(*(_DWORD *)(a2 + 12));
    result = sub_1005E0A0(a2);
  }
  return result;
}

//----- (1005E1A0) --------------------------------------------------------
signed int __cdecl sub_1005E1A0(_DWORD *a1, int a2, signed int a3, int a4, _DWORD *a5)
{
  int v5; // ebp@1
  signed int result; // eax@1
  unsigned int v7; // ebx@1
  bool v8; // zf@1
  unsigned int v9; // esi@2
  unsigned int v10; // edi@3
  _BYTE *v11; // eax@3
  _BYTE *v12; // ecx@3
  __int64 v13; // rax@3
  __int64 v14; // rax@4
  __int64 v15; // rax@5
  int v16; // eax@6
  signed int v17; // [sp+Ch] [bp+4h]@1

  v5 = (int)a1;
  result = 0;
  v7 = 0;
  v8 = *a1 == 0;
  v17 = 0;
  if ( v8 )
  {
    *a5 = 0;
  }
  else
  {
    do
    {
      v9 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        do
        {
          v10 = sub_1005E130(v5, v7, v9);
          v11 = (_BYTE *)sub_1005E130(a2, v7, v9);
          v12 = v11;
          v13 = *(_BYTE *)v10 - *v11;
          if ( (signed int)((HIDWORD(v13) ^ v13) - HIDWORD(v13)) > a3
            || (v14 = *(_BYTE *)(v10 + 1) - v12[1], (signed int)((HIDWORD(v14) ^ v14) - HIDWORD(v14)) > a3)
            || (v15 = *(_BYTE *)(v10 + 2) - v12[2], (signed int)((HIDWORD(v15) ^ v15) - HIDWORD(v15)) > a3) )
          {
            v17 = 4;
            v16 = sub_1005E130(a4, v7, v9);
            sub_1005E150(v16, (int)&unk_1011ED24);
          }
          ++v9;
        }
        while ( v9 < *(_DWORD *)(v5 + 4) );
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)v5 );
    result = v17;
    *a5 = 0;
  }
  return result;
}

//----- (1005E280) --------------------------------------------------------
void __cdecl sub_1005E280(int a1, int a2, int a3)
{
  unsigned int *v3; // edx@1
  unsigned int v4; // ebp@1
  unsigned int v5; // eax@2
  unsigned int v6; // esi@3
  unsigned int v7; // edi@4
  unsigned int v8; // ebx@4
  unsigned int v9; // ebp@4
  __int64 v10; // rax@4
  __int64 v11; // rax@4
  unsigned int v12; // [sp+4h] [bp-4h]@1

  v3 = (unsigned int *)a1;
  v4 = 0;
  v12 = 0;
  if ( *(_DWORD *)a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    do
    {
      v6 = 0;
      if ( v5 )
      {
        do
        {
          v7 = sub_1005E130((int)v3, v4, v6);
          v8 = sub_1005E130(a2, v4, v6);
          v9 = sub_1005E130(a3, v4, v6);
          v10 = *(_BYTE *)(v7 + 2) - *(_BYTE *)(v8 + 2);
          *(_BYTE *)(v9 + 2) = (BYTE4(v10) ^ v10) - BYTE4(v10);
          v11 = *(_BYTE *)(v7 + 1) - *(_BYTE *)(v8 + 1);
          *(_BYTE *)(v9 + 1) = (BYTE4(v11) ^ v11) - BYTE4(v11);
          v3 = (unsigned int *)a1;
          *(_BYTE *)v9 = abs(*(_BYTE *)v7 - *(_BYTE *)v8);
          v5 = *(_DWORD *)(a1 + 4);
          v4 = v12;
          ++v6;
        }
        while ( v6 < v5 );
      }
      v12 = ++v4;
    }
    while ( v4 < *v3 );
  }
}

//----- (1005E330) --------------------------------------------------------
void *__usercall sub_1005E330@<eax>(int a1@<edi>, int a2@<esi>, unsigned int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@3
  int v5; // ebp@4
  int v6; // eax@4
  int v7; // ebp@4
  int v8; // eax@4
  int v9; // ST5C_4@4
  int v10; // eax@4
  int v11; // ebp@4
  int v12; // eax@4
  unsigned int v13; // ebx@6
  size_t v14; // ST3C_4@7
  const void *v15; // ST38_4@7
  void *v16; // eax@7
  unsigned int i; // ebp@8
  unsigned int v18; // ebx@9
  int v19; // ST5C_4@10
  int v20; // eax@10
  int v21; // ST5C_4@10
  int v22; // eax@10
  size_t v23; // ST3C_4@11
  const void *v24; // ST38_4@11
  void *v25; // eax@11
  unsigned int v26; // ebx@12
  size_t v27; // ST3C_4@13
  const void *v28; // ST38_4@13
  void *v29; // eax@13
  void *result; // eax@13
  int v31; // [sp+8h] [bp-18h]@1
  unsigned int v32; // [sp+Ch] [bp-14h]@1
  int v33; // [sp+10h] [bp-10h]@3
  int v34; // [sp+14h] [bp-Ch]@1
  int v35; // [sp+18h] [bp-8h]@1

  v3 = 2 * a3 + *(_DWORD *)a2;
  v35 = 2 * a3 + *(_DWORD *)a2;
  v34 = 2 * a3 + *(_DWORD *)(a2 + 4);
  v32 = (unsigned int)(*(_DWORD *)(a2 + 8) + 7) >> 3;
  v31 = 0;
  while ( 1 )
  {
    v4 = 0;
    v33 = v3 - v31 - 1;
    do
    {
      v5 = sub_1005E130(a1, v31, v4);
      v6 = sub_1005E130(a2, 0, 0);
      sub_1005E150(v5, v6);
      v7 = sub_1005E130(a1, v33, v4);
      v8 = sub_1005E130(a2, *(_DWORD *)a2 - 1, 0);
      sub_1005E150(v7, v8);
      v9 = sub_1005E130(a1, v31, v34 - v4 - 1);
      v10 = sub_1005E130(a2, 0, *(_DWORD *)(a2 + 4) - 1);
      sub_1005E150(v9, v10);
      v11 = sub_1005E130(a1, v33, v34 - v4 - 1);
      v12 = sub_1005E130(a2, *(_DWORD *)a2 - 1, *(_DWORD *)(a2 + 4) - 1);
      sub_1005E150(v11, v12);
      ++v4;
    }
    while ( v4 <= a3 );
    if ( ++v31 > a3 )
      break;
    v3 = v35;
  }
  v13 = 0;
  do
  {
    v14 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v15 = (const void *)sub_1005E130(a2, 0, 1);
    v16 = (void *)sub_1005E130(a1, v13, a3 + 1);
    memcpy(v16, v15, v14);
    ++v13;
  }
  while ( v13 <= a3 );
  for ( i = 1; i < *(_DWORD *)a2 - 1; ++i )
  {
    v18 = 0;
    do
    {
      v19 = sub_1005E130(a1, a3 + i, v18);
      v20 = sub_1005E130(a2, i, 0);
      sub_1005E150(v19, v20);
      v21 = sub_1005E130(a1, i + a3, v34 - v18 - 1);
      v22 = sub_1005E130(a2, i, *(_DWORD *)(a2 + 4) - 1);
      sub_1005E150(v21, v22);
      ++v18;
    }
    while ( v18 <= a3 );
    v23 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v24 = (const void *)sub_1005E130(a2, i, 1);
    v25 = (void *)sub_1005E130(a1, a3 + i, a3 + 1);
    memcpy(v25, v24, v23);
  }
  v26 = 0;
  do
  {
    v27 = v32 * (*(_DWORD *)(a2 + 4) - 2);
    v28 = (const void *)sub_1005E130(a2, *(_DWORD *)a2 - 1, 1);
    v29 = (void *)sub_1005E130(a1, v35 - v26 - 1, a3 + 1);
    result = memcpy(v29, v28, v27);
    ++v26;
  }
  while ( v26 <= a3 );
  return result;
}

//----- (1005E5B0) --------------------------------------------------------
void __cdecl sub_1005E5B0(int a1, int a2)
{
  unsigned int v2; // ebx@1
  unsigned int v3; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // edi@4
  unsigned int v6; // ecx@4
  char v7; // al@4

  v2 = 0;
  if ( *(_DWORD *)a1 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    do
    {
      v4 = 0;
      if ( v3 )
      {
        do
        {
          v5 = sub_1005E130(a1, v2, v4);
          v6 = sub_1005E130(a2, v2, v4++);
          v7 = (signed int)((double)*(_BYTE *)(v5 + 2) * 0.300000011920929
                          + (double)*(_BYTE *)(v5 + 1) * 0.5899999737739563
                          + (double)*(_BYTE *)v5 * 0.1099999994039536);
          *(_BYTE *)(v6 + 2) = v7;
          *(_BYTE *)(v6 + 1) = v7;
          *(_BYTE *)v6 = v7;
          v3 = *(_DWORD *)(a1 + 4);
        }
        while ( v4 < v3 );
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)a1 );
  }
}

//----- (1005E680) --------------------------------------------------------
char __cdecl sub_1005E680(int a1, int (__cdecl *a2)(unsigned int), void (__cdecl *a3)(_DWORD), int a4)
{
  char result; // al@1

  result = sub_1005E0C0(a1);
  if ( result )
  {
    result = sub_1005E0C0(a4);
    if ( result )
    {
      sub_1005E170(a3, a4);
      sub_1005E0F0(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a4);
      result = (unsigned int)memcpy(
                               *(void **)(a4 + 12),
                               *(const void **)(a1 + 12),
                               *(_DWORD *)(a1 + 4) * *(_DWORD *)a1 * ((unsigned int)(*(_DWORD *)(a1 + 8) + 7) >> 3));
    }
  }
  return result;
}

//----- (1005E6F0) --------------------------------------------------------
int __usercall sub_1005E6F0@<eax>(unsigned int a1@<eax>, int (__cdecl *a2)(unsigned int)@<ecx>, int a3, int a4, float a5, float a6, int a7, int a8, int a9)
{
  int (__cdecl *v9)(unsigned int); // edi@1
  long double v10; // st7@1
  unsigned int v11; // ecx@1
  signed int v12; // kr00_4@1
  int v13; // ebx@1
  int v14; // esi@3
  int result; // eax@5
  double v16; // st6@7
  int v17; // eax@7
  double v18; // st3@7
  int v19; // edi@9
  double v20; // rt0@11
  double v21; // st3@11
  double v22; // st6@11
  int v23; // eax@11
  int v24; // ecx@12
  int v25; // ebp@14
  float *v26; // esi@14
  unsigned int v27; // eax@15
  signed int v28; // ecx@15
  float v29; // ST50_4@15
  signed int v30; // edx@15
  signed int v31; // eax@15
  int v32; // ecx@20
  double v33; // st2@20
  double v34; // rtt@21
  double v35; // rt0@23
  double v36; // st2@23
  double v37; // st3@23
  double v38; // rtt@26
  unsigned int v39; // eax@28
  bool v40; // sf@28
  unsigned __int8 v41; // of@28
  float v42; // [sp+8h] [bp-48h]@11
  int v43; // [sp+Ch] [bp-44h]@8
  int v44; // [sp+10h] [bp-40h]@9
  int v45; // [sp+14h] [bp-3Ch]@6
  int v46; // [sp+18h] [bp-38h]@7
  int v47; // [sp+20h] [bp-30h]@11
  signed int v48; // [sp+24h] [bp-2Ch]@1
  int v49; // [sp+28h] [bp-28h]@12
  float v50; // [sp+30h] [bp-20h]@22
  float v51; // [sp+34h] [bp-1Ch]@11
  float v52; // [sp+38h] [bp-18h]@11
  float v53; // [sp+3Ch] [bp-14h]@11
  char v54; // [sp+40h] [bp-10h]@6

  v9 = a2;
  v10 = sqrt((double)a1);
  v11 = (signed int)v10;
  v12 = (signed int)v10;
  v13 = (signed int)v10 / 2;
  v48 = (signed int)v10;
  if ( v9 && a7 )
  {
    v14 = a3;
    if ( *(_DWORD *)(a3 + 4) >= v11 || *(_DWORD *)a3 >= v11 )
    {
      *(_DWORD *)a9 = 0;
      sub_1005E0F0(2 * v13 + *(_DWORD *)a3, 2 * v13 + *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), v9, (int)&v54);
      sub_1005E330((int)&v54, a3, v12 / 2);
      v45 = v12 / 2;
      if ( v13 < v13 + *(_DWORD *)a3 )
      {
        v16 = 0.0;
        v17 = v13 + *(_DWORD *)(a3 + 4);
        v46 = 0;
        v18 = a6;
        do
        {
          v43 = v12 / 2;
          if ( v13 < v17 )
          {
            v19 = v12 / -2;
            v44 = 0;
            while ( 1 )
            {
              v20 = v18;
              v21 = v16;
              v22 = v20;
              v51 = 0.0;
              v42 = v21;
              v52 = 0.0;
              v53 = 0.0;
              v23 = v19;
              v47 = v19;
              if ( v19 <= v13 )
              {
                v24 = v48 * (v19 + v13);
                v49 = v48 * (v19 + v13);
                do
                {
                  if ( v19 <= v13 )
                  {
                    v25 = v23 + v45;
                    v26 = (float *)(a4 + 4 * (v13 + v19 + v24));
                    do
                    {
                      v27 = sub_1005E130((int)&v54, v25, v19 + v43);
                      v28 = *(_BYTE *)(v27 + 2);
                      v29 = *v26;
                      v30 = *(_BYTE *)(v27 + 1);
                      v31 = *(_BYTE *)v27;
                      ++v19;
                      ++v26;
                      v51 = (double)v28 * v29 + v51;
                      v52 = (double)v30 * v29 + v52;
                      v53 = (double)v31 * v29 + v53;
                      v42 = v29 + v42;
                    }
                    while ( v19 <= v13 );
                    v14 = a3;
                    v23 = v47;
                    v24 = v49;
                    v19 = v12 / -2;
                  }
                  v24 += v48;
                  v47 = ++v23;
                  v49 = v24;
                }
                while ( v23 <= v13 );
              }
              if ( v21 == v22 )
                v22 = v42;
              v32 = 0;
              v33 = a5 + v22;
              while ( 1 )
              {
                v50 = *(&v51 + v32) / v33;
                *(&v51 + v32) = v50;
                if ( v50 > v21 )
                {
                  if ( v50 > 255.0 )
                    *(&v51 + v32) = 255.0;
                  v38 = v33;
                  v36 = v21;
                  v37 = v38;
                }
                else
                {
                  v35 = v33;
                  v36 = v21;
                  v37 = v35;
                  *(&v51 + v32) = v36;
                }
                if ( (unsigned int)++v32 >= 3 )
                  break;
                v34 = v36;
                v33 = v37;
                v21 = v34;
              }
              v39 = sub_1005E130(a8, v46, v44++);
              *(_BYTE *)(v39 + 2) = (signed int)v51;
              *(_BYTE *)(v39 + 1) = (signed int)v52;
              *(_BYTE *)v39 = (signed int)v53;
              v17 = *(_DWORD *)(v14 + 4) + v13;
              v41 = __OFSUB__(v43 + 1, v17);
              v40 = v43++ + 1 - v17 < 0;
              v18 = v22;
              v16 = v36;
              if ( !(v40 ^ v41) )
                break;
              v19 = v12 / -2;
            }
          }
          ++v46;
          ++v45;
        }
        while ( v45 < v13 + *(_DWORD *)v14 );
      }
      sub_1005E170((void (__cdecl *)(_DWORD))a7, (int)&v54);
      result = 0;
    }
    else
    {
      *(_DWORD *)a9 = "Bitmap too small to filter -- filtering has been disabled";
      sub_1005E680(a3, v9, (void (__cdecl *)(_DWORD))a7, a8);
      result = 0;
    }
  }
  else
  {
    *(_DWORD *)a9 = "Dynamic memory function pointers are required for bitmap filtering";
    result = 1;
  }
  return result;
}

//----- (1005EA50) --------------------------------------------------------
int __usercall sub_1005EA50@<eax>(int (__cdecl *a1)(unsigned int)@<eax>, int a2@<ecx>, int a3, unsigned int a4, void (__cdecl *a5)(_DWORD), int a6, int a7)
{
  int (__cdecl *v7)(unsigned int); // edi@1
  int v8; // esi@1
  unsigned int v9; // ebx@1
  int v10; // ebp@1
  unsigned int v11; // edi@2
  unsigned int v12; // eax@3
  int v13; // eax@6
  int v15; // [sp+24h] [bp-20h]@1
  int v16; // [sp+34h] [bp-10h]@1

  v7 = a1;
  v8 = a2;
  sub_1005E0F0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(a2 + 8), a1, (int)&v16);
  sub_1005E280(v8, a3, (int)&v16);
  sub_1005E0F0(*(_DWORD *)v8, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 8), v7, (int)&v15);
  v9 = 0;
  v10 = sub_1005E6F0(9u, v7, (int)&v16, (int)&unk_1011ED00, 0.0, 0.0, (int)a5, (int)&v15, a7);
  if ( *(_DWORD *)v8 )
  {
    do
    {
      v11 = 0;
      if ( *(_DWORD *)(v8 + 4) )
      {
        do
        {
          v12 = sub_1005E130((int)&v15, v9, v11);
          if ( *(_BYTE *)(v12 + 2) > a4 || *(_BYTE *)(v12 + 1) > a4 || *(_BYTE *)v12 > a4 )
          {
            v10 = 4;
            v13 = sub_1005E130(a6, v9, v11);
            sub_1005E150(v13, (int)&unk_1011ED24);
          }
          ++v11;
        }
        while ( v11 < *(_DWORD *)(v8 + 4) );
      }
      ++v9;
    }
    while ( v9 < *(_DWORD *)v8 );
  }
  sub_1005E170(a5, (int)&v15);
  sub_1005E170(a5, (int)&v16);
  return v10;
}

//----- (1005EB60) --------------------------------------------------------
int __cdecl sub_1005EB60(int a1, int a2, int a3, unsigned int a4, char a5, int (__cdecl *a6)(unsigned int), void (__cdecl *a7)(_DWORD), int a8, char *a9, const char **a10)
{
  bool v10; // cl@6
  bool v11; // al@13
  bool v12; // zf@16
  int result; // eax@16
  const char *v14; // ecx@17
  int v15; // ecx@22
  int v16; // eax@23
  char v17; // [sp+Bh] [bp-5h]@1
  const char *v18; // [sp+Ch] [bp-4h]@1

  v17 = 0;
  v18 = 0;
  v10 = a2 && *(_DWORD *)a2 && *(_DWORD *)(a2 + 4) && *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 12);
  v11 = a3 && *(_DWORD *)a3 && *(_DWORD *)(a3 + 4) && *(_DWORD *)(a3 + 8) && *(_DWORD *)(a3 + 12);
  if ( !v10 )
  {
    v12 = v11 == 0;
    result = 2;
    if ( v12 )
      v14 = "Actual and Expected bitmaps unavailable";
    else
      v14 = "Actual bitmap is unavailable";
    goto LABEL_33;
  }
  if ( !v11 )
  {
    v14 = "Expected bitmap is unavailable";
    result = 2;
    goto LABEL_33;
  }
  if ( *(_DWORD *)a2 != *(_DWORD *)a3
    || (v15 = *(_DWORD *)(a2 + 4), v15 != *(_DWORD *)(a3 + 4))
    || (v16 = *(_DWORD *)(a2 + 8), v16 != *(_DWORD *)(a3 + 8)) )
  {
    v14 = "Bitmap sizes are different";
    result = 3;
    goto LABEL_33;
  }
  if ( !a6 || !a7 )
  {
    v14 = "Dynamic memory function pointers are required for comparison (build environment error)";
    result = 1;
    goto LABEL_33;
  }
  sub_1005E0F0(*(_DWORD *)a2, v15, v16, a6, a8);
  sub_1005E5B0(a3, a8);
  if ( a1 )
    result = sub_1005EA50(a6, a2, a3, a4, a7, a8, (int)&v18);
  else
    result = sub_1005E1A0((_DWORD *)a2, a3, a4, a8, &v18);
  if ( !a5 )
    goto LABEL_48;
  if ( result == 4 )
  {
    result = 0;
LABEL_32:
    v14 = v18;
    goto LABEL_33;
  }
  if ( result )
  {
LABEL_48:
    if ( result != 4 )
      goto LABEL_32;
  }
  else
  {
    result = 4;
  }
  if ( a5 )
  {
    v14 = "Images match";
  }
  else
  {
    v17 = 1;
    v14 = "Pixel mismatch";
  }
LABEL_33:
  if ( a10 )
    *a10 = v14;
  if ( a9 )
    *a9 = v17;
  return result;
}

//----- (1005ECF0) --------------------------------------------------------
char __cdecl sub_1005ECF0(int (__cdecl *a1)(unsigned int), _BYTE *a2, int a3)
{
  char v3; // bl@1
  unsigned int v4; // eax@5
  unsigned int v5; // esi@5
  char *v6; // ebp@11
  int v7; // esi@11
  unsigned int v8; // ebx@11
  int v9; // edi@11
  char result; // al@20
  char v11; // [sp+8h] [bp-40h]@14
  unsigned int v12; // [sp+Ch] [bp-3Ch]@5
  __int16 v13; // [sp+10h] [bp-38h]@6
  int v14; // [sp+1Ah] [bp-2Eh]@8
  char v15; // [sp+20h] [bp-28h]@9
  int v16; // [sp+24h] [bp-24h]@11
  unsigned int v17; // [sp+28h] [bp-20h]@11
  unsigned __int16 v18; // [sp+2Eh] [bp-1Ah]@10
  char v19; // [sp+4Ch] [bp+4h]@11

  v3 = 0;
  if ( a1 && a2 && *a2 )
  {
    if ( a3 )
    {
      v4 = sub_1005A3E0((int)a2, 0);
      v5 = v4;
      v12 = v4;
      if ( v4 )
      {
        if ( sub_1005A440(&v13, 14, v4) == 14
          && v13 == 19778
          && v14 == 54
          && sub_1005A440(&v15, 40, v5) == 40
          && v18 == 24 )
        {
          sub_1005E0F0(v17, v16, 24, a1, a3);
          v6 = *(char **)(a3 + 12);
          v7 = v16 * (((unsigned int)v18 + 7) >> 3);
          v8 = 0;
          v9 = -(v16 * (((unsigned int)v18 + 7) >> 3)) & 3;
          v19 = 1;
          if ( v17 )
          {
            while ( sub_1005A440(v6, v7, v12) == v7 && (!v9 || sub_1005A440(&v11, v9, v12) == v9) )
            {
              ++v8;
              v6 += v7;
              if ( v8 >= v17 )
                goto LABEL_18;
            }
            v19 = 0;
          }
LABEL_18:
          v3 = v19;
          v5 = v12;
        }
        sub_1005A390(v5);
      }
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1005EE40) --------------------------------------------------------
char __usercall sub_1005EE40@<al>(int a1@<edx>, int a2@<ecx>, unsigned int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@1
  unsigned int v10; // ebx@1
  int v12; // [sp+10h] [bp-40h]@4
  int v13; // [sp+14h] [bp-3Ch]@4
  __int16 v14; // [sp+18h] [bp-38h]@1
  int v15; // [sp+1Ah] [bp-36h]@1
  __int16 v16; // [sp+1Eh] [bp-32h]@1
  __int16 v17; // [sp+20h] [bp-30h]@1
  int v18; // [sp+22h] [bp-2Eh]@1
  int v19; // [sp+28h] [bp-28h]@1
  int v20; // [sp+2Ch] [bp-24h]@1
  unsigned int v21; // [sp+30h] [bp-20h]@1
  __int16 v22; // [sp+34h] [bp-1Ch]@1
  __int16 v23; // [sp+36h] [bp-1Ah]@1
  int v24; // [sp+38h] [bp-18h]@1
  int v25; // [sp+3Ch] [bp-14h]@1
  int v26; // [sp+40h] [bp-10h]@1
  int v27; // [sp+44h] [bp-Ch]@1
  int v28; // [sp+48h] [bp-8h]@1
  int v29; // [sp+4Ch] [bp-4h]@1
  char v30; // [sp+54h] [bp+4h]@1

  v5 = a3;
  v6 = a1 * ((unsigned int)(a2 + 7) >> 3);
  v7 = -(a1 * ((unsigned int)(a2 + 7) >> 3)) & 3;
  v8 = a3 * (v7 + v6);
  v25 = v8;
  v15 = v8 + 54;
  v16 = 0;
  v17 = 0;
  v29 = 0;
  v28 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v14 = 19778;
  v18 = 54;
  v19 = 40;
  v23 = a2;
  v21 = v5;
  v20 = a1;
  v22 = 1;
  v9 = sub_1005A3E0(a5, 1);
  v10 = v9;
  if ( v9 )
  {
    if ( sub_1005A460((int)&v14, 14, v9) == 14 && sub_1005A460((int)&v19, 40, v10) == 40 )
    {
      v30 = 1;
      v12 = a4;
      v13 = 0;
      if ( v5 )
      {
        while ( sub_1005A460(v12, v6, v10) == v6 && (!v7 || sub_1005A460((int)&unk_1011EEC8, v7, v10) == v7) )
        {
          v12 += v6;
          if ( ++v13 >= v5 )
          {
            sub_1005A390(v10);
            return 1;
          }
        }
        v30 = 0;
      }
    }
    sub_1005A390(v10);
  }
  return v30;
}

//----- (1005EF90) --------------------------------------------------------
char __cdecl sub_1005EF90(int a1, int a2)
{
  char result; // al@2

  if ( sub_1005E0C0(a1) )
    result = sub_1005EE40(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)a1, *(_DWORD *)(a1 + 12), a2);
  else
    result = 0;
  return result;
}

//----- (1005EFD0) --------------------------------------------------------
int __cdecl sub_1005EFD0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 84) = a3;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 88) = a2;
  return result;
}

//----- (1005EFF0) --------------------------------------------------------
int (__cdecl *__usercall sub_1005EFF0@<eax>(int a1@<eax>, int a2@<ecx>))(int)
{
  int (__cdecl *result)(int); // eax@1

  result = *(int (__cdecl **)(int))(a1 + 88);
  if ( result )
    result = (int (__cdecl *)(int))result(a2);
  return result;
}

//----- (1005F000) --------------------------------------------------------
int __usercall sub_1005F000@<eax>(unsigned __int8 *a1@<eax>, int a2)
{
  signed int v2; // edi@1
  int v3; // ebp@1
  unsigned __int8 *v4; // ebx@1
  unsigned __int8 v5; // al@2
  int v6; // esi@4

  v2 = 0;
  v3 = a2 + 92;
  *(_BYTE *)(a2 + 92) = 0;
  v4 = a1;
  do
  {
    v5 = *v4;
    if ( !*v4 )
      break;
    switch ( v5 )
    {
      case 0x22u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1869967654;
        *(_WORD *)(v6 + 4) = 15220;
        *(_BYTE *)(v6 + 6) = 0;
        break;
      case 0x3Cu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997485606;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x3Eu:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 997484326;
        *(_BYTE *)(v6 + 4) = 0;
        break;
      case 0x26u:
        v6 = v2 + v3;
        *(_DWORD *)v6 = 1886216486;
        *(_WORD *)(v6 + 4) = 59;
        break;
      case 7u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 24924;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 8u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 25180;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xCu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 26204;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xAu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 28252;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xDu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29276;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 9u:
        v6 = v2 + v3;
        *(_WORD *)v6 = 29788;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      case 0xBu:
        v6 = v2 + v3;
        *(_WORD *)v6 = 30300;
        *(_BYTE *)(v6 + 2) = 0;
        break;
      default:
        v6 = v2 + v3;
        if ( isprint(v5) )
        {
          *(_BYTE *)v6 = *v4;
          *(_BYTE *)(v2 + a2 + 93) = 0;
        }
        else
        {
          _snprintf((char *)(v2 + v3), 512 - v2, "\\x%x", *v4);
          *(_BYTE *)(a2 + 603) = 0;
        }
        break;
    }
    v2 += strlen((const char *)v6);
    ++v4;
  }
  while ( v2 < 502 );
  return a2 + 92;
}

//----- (1005F230) --------------------------------------------------------
int (__cdecl *__cdecl sub_1005F230(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1005EFF0(a1, (int)" ");
  sub_1005EFF0(a1, a2);
  sub_1005EFF0(a1, (int)&unk_1011F114);
  v3 = sub_1005F000(a3, a1);
  sub_1005EFF0(a1, v3);
  return sub_1005EFF0(a1, (int)&unk_1011F110);
}

//----- (1005F280) --------------------------------------------------------
int (__cdecl *__cdecl sub_1005F280(int a1, int a2, unsigned __int8 *a3))(int)
{
  int v3; // eax@1

  sub_1005EFF0(a1, (int)" ");
  sub_1005EFF0(a1, a2);
  sub_1005EFF0(a1, (int)&unk_1011F11C);
  v3 = sub_1005F000(a3, a1);
  sub_1005EFF0(a1, v3);
  return sub_1005EFF0(a1, (int)&unk_1011F118);
}

//----- (1005F2D0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1005F2D0(int a1, unsigned __int8 *a2))(int)
{
  int (__cdecl *result)(int); // eax@1
  int v3; // eax@4

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      sub_1005EFF0(a1, (int)&unk_1011F120);
      *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    }
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 7) = 1;
    v3 = sub_1005F000(a2, a1);
    result = sub_1005EFF0(a1, v3);
  }
  return result;
}

//----- (1005F320) --------------------------------------------------------
int (__cdecl *__cdecl sub_1005F320(int a1))(int)
{
  int (__cdecl *result)(int); // eax@1
  void *v2; // ecx@3
  bool v3; // zf@7

  result = *(int (__cdecl **)(int))(a1 + 80);
  if ( (signed int)result > 0 )
  {
    if ( *(_BYTE *)(a1 + 8 * (_DWORD)result - 8) )
    {
      v2 = &unk_1011F128;
    }
    else
    {
      if ( !*(_BYTE *)(a1 + 8 * (_DWORD)result - 7) )
        sub_1005EFF0(a1, dword_1011F07C[(signed int)result]);
      sub_1005EFF0(a1, (int)&unk_1011F124);
      sub_1005EFF0(a1, *(_DWORD *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 4));
      v2 = &unk_1011F120;
    }
    result = sub_1005EFF0(a1, (int)v2);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
    v3 = (*(_DWORD *)(a1 + 80))-- == 1;
    if ( v3 )
      result = sub_1005EFF0(a1, (int)&word_1007F968);
  }
  return result;
}
// 1007F968: using guessed type __int16 word_1007F968;
// 1011F07C: using guessed type int dword_1011F07C[];

//----- (1005F3A0) --------------------------------------------------------
int __cdecl sub_1005F3A0(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  if ( v2 > 0 && *(_BYTE *)(a1 + 8 * v2 - 8) )
  {
    sub_1005EFF0(a1, (int)&unk_1011F120);
    *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80) - 8) = 0;
  }
  sub_1005EFF0(a1, *((_DWORD *)&off_1011F080 + *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 84)));
  sub_1005EFF0(a1, (int)&unk_1011F12C);
  sub_1005EFF0(a1, a2);
  *(_BYTE *)(a1 + 8 * *(_DWORD *)(a1 + 80)) = 1;
  result = *(_DWORD *)(a1 + 80);
  *(_BYTE *)(a1 + 8 * result + 1) = 0;
  *(_DWORD *)(a1 + 8 * (*(_DWORD *)(a1 + 80))++ + 4) = a2;
  return result;
}

//----- (1005F420) --------------------------------------------------------
int (__cdecl *__cdecl sub_1005F420(int a1, unsigned __int8 *a2, char a3))(int)
{
  int v3; // eax@2
  int (__cdecl *result)(int); // eax@2

  if ( a3 )
  {
    v3 = sub_1005F000(a2, a1);
    sub_1005EFF0(a1, v3);
    result = sub_1005EFF0(a1, (int)&word_1007F968);
  }
  else
  {
    sub_1005EFF0(a1, (int)a2);
    result = sub_1005EFF0(a1, (int)&word_1007F968);
  }
  return result;
}
// 1007F968: using guessed type __int16 word_1007F968;

//----- (1005F470) --------------------------------------------------------
int (__cdecl *__cdecl sub_1005F470(int a1, int a2, unsigned __int8 *a3))(int)
{
  sub_1005F3A0(a1, a2);
  if ( a3 && *a3 )
    sub_1005F2D0(a1, a3);
  return sub_1005F320(a1);
}

//----- (1005F4B0) --------------------------------------------------------
int (__cdecl *__cdecl sub_1005F4B0(int a1, int a2, int a3))(int)
{
  char v4; // [sp+8h] [bp-24h]@1
  char v5; // [sp+27h] [bp-5h]@1

  _snprintf(&v4, 0x20u, "%d", a3);
  v5 = 0;
  return sub_1005F470(a1, a2, (unsigned __int8 *)&v4);
}

//----- (1005F510) --------------------------------------------------------
bool __thiscall sub_1005F510(void *this)
{
  void *v2; // [sp-2h] [bp-4h]@1

  v2 = this;
  return !sub_10060D80(6569, (int)&v2 + 3, 1) && (BYTE3(v2) == 4 || BYTE3(v2) == 2 || BYTE3(v2) == 5);
}

//----- (1005F550) --------------------------------------------------------
char __cdecl sub_1005F550(char a1, void *a2)
{
  void *v3; // ecx@3
  char v4; // al@5

  if ( sub_10060D80((unsigned __int8)a1 + 36000, (int)a2, 132) )
    return 0;
  v3 = a2;
  if ( !a2 || *(_BYTE *)a2 )
  {
LABEL_8:
    if ( *((_BYTE *)a2 + 21) == 4 )
    {
      if ( *((_BYTE *)a2 + 24) == 1 )
      {
        if ( !sub_1005F510(v3) )
        {
          sub_10028BC0("..\\lib\\adl\\sys_utl_airframe_tests.c", 206, 0, 0);
          memset(a2, 0, 0x84u);
        }
      }
      else if ( *((_BYTE *)a2 + 24) == 3 && !*((_BYTE *)a2 + 58) )
      {
        *((_DWORD *)a2 + 15) |= 0x200u;
        return 1;
      }
    }
  }
  else
  {
    v4 = 0;
    while ( v4 )
    {
      v4 = *((_BYTE *)v3 + 1);
      v3 = (char *)v3 + 1;
      if ( v4 != *((_BYTE *)v3 + &byte_10080D49 - (_BYTE *)a2) )
        goto LABEL_8;
    }
  }
  return 1;
}

//----- (1005F600) --------------------------------------------------------
char __cdecl sub_1005F600(float a1, int a2)
{
  double v2; // st7@1
  long double v3; // st7@1
  char result; // al@2
  float v5; // [sp+4h] [bp+4h]@1
  float v6; // [sp+4h] [bp+4h]@4
  float v7; // [sp+4h] [bp+4h]@5

  v2 = a1;
  v5 = a1 / 101325.0;
  v3 = v2 / 22631.953125;
  if ( v3 > 0.0 )
  {
    if ( v5 <= 0.223360002040863 )
    {
      v7 = log(v3);
      result = 1;
      *(float *)a2 = 11000.232421875 - v7 * 6341.615234375;
    }
    else
    {
      v6 = pow(v5, 0.1902630904662425);
      result = 1;
      *(float *)a2 = (v6 - 1.0) * -44330.76953125;
    }
  }
  else
  {
    *(float *)a2 = 9.8999998e24;
    result = 0;
  }
  return result;
}

//----- (1005F6A0) --------------------------------------------------------
char __cdecl sub_1005F6A0(int a1, float *a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  void *v4; // ecx@1
  int v5; // edi@1
  char result; // al@5
  int v7; // eax@7
  int v8; // ebp@7
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@1
  float v11; // [sp+10h] [bp-8h]@1

  v11 = 9.8999998e24;
  *a2 = 9.8999998e24;
  LOBYTE(v9) = 0;
  v10 = 0;
  v2 = sub_10047680(a1);
  v3 = sub_1005F8B0(a1);
  v5 = v3;
  if ( !v2 )
    goto LABEL_15;
  if ( !v3 )
    return sub_100472F0(a1, a2);
  if ( *(_WORD *)(v2 + 12) != 6 )
    goto LABEL_15;
  if ( sub_1002C5E0(v4) == 4 )
  {
    *a2 = *(float *)(v2 + 8);
    return 1;
  }
  if ( (unsigned __int8)(*(_BYTE *)(v5 + 2) - 1) <= 2u )
  {
    v7 = sub_1005F800(&v9, (void *)(v5 + 4), 0xCu, 27, 100);
    *a2 = v11;
    v8 = v7;
    result = sub_10060900() - v10 < (unsigned int)(unsigned __int16)word_10123C48[*(_BYTE *)(v5 + 3)] ? v9 : 0;
    if ( v8 >= 0 )
    {
      if ( result )
        result = sub_10046EF0(v2, a2);
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\dat\\dat_proc_float.c", 174, 0, 0);
      result = 0;
    }
  }
  else
  {
LABEL_15:
    result = 0;
  }
  return result;
}
// 10123C48: using guessed type __int16 word_10123C48[];

//----- (1005F800) --------------------------------------------------------
int __cdecl sub_1005F800(void *a1, void *a2, size_t a3, int a4, int a5)
{
  int result; // eax@8

  if ( a3 > 4 || a3 == 3 || a3 - 1 > 3 || ((unsigned int)a2 | (unsigned int)a1) & (a3 - 1) )
  {
    if ( sub_10060A60(a4, a5) )
    {
      result = -1;
    }
    else
    {
      memcpy(a1, a2, a3);
      sub_10060A00(a4);
      result = 1;
    }
  }
  else
  {
    switch ( a3 )
    {
      case 1u:
        result = 0;
        *(_BYTE *)a1 = *(_BYTE *)a2;
        break;
      case 2u:
        *(_WORD *)a1 = *(_WORD *)a2;
        result = 0;
        break;
      case 4u:
        result = 0;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        break;
      default:
        memcpy(a1, a2, a3);
        result = 0;
        break;
    }
  }
  return result;
}

//----- (1005F8B0) --------------------------------------------------------
int __cdecl sub_1005F8B0(unsigned __int16 a1)
{
  int v1; // ecx@1
  unsigned __int16 v2; // ax@3
  int result; // eax@4

  v1 = sub_10030F90();
  if ( v1 && a1 < 0xFE3u && (v2 = *(_WORD *)(v1 + 2 * a1 + 0x2000), v2 < 0x2000u) )
    result = v1 + v2;
  else
    result = 0;
  return result;
}

//----- (1005F8F0) --------------------------------------------------------
char __cdecl sub_1005F8F0(float a1, int a2, int a3)
{
  char v3; // bl@8
  char result; // al@8
  unsigned __int8 v5; // [sp+Ch] [bp-28h]@1
  unsigned __int8 v6; // [sp+18h] [bp-1Ch]@2
  char v7; // [sp+1Ah] [bp-1Ah]@6

  sub_10062A20((int)&v5);
  if ( LOBYTE(a1) < v5
    || LOBYTE(a1) >= v6 && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_10A09ABC + 816) != 3)
    || LOBYTE(a1) >= 0x66u
    || v7
    || sub_10062720(1) )
  {
    result = 0;
  }
  else
  {
    sub_100422A0();
    v3 = sub_100605B0(a1, a2, a3);
    sub_10042290();
    result = v3;
  }
  return result;
}
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (1005F9A0) --------------------------------------------------------
double __cdecl sub_1005F9A0(float a1, float a2)
{
  double result; // st7@1

  result = a1;
  if ( a2 >= (double)a1 )
    result = a2;
  return result;
}

//----- (1005F9C0) --------------------------------------------------------
void __cdecl sub_1005F9C0(int a1, int a2, int a3, int a4, int a5, float a6)
{
  double v6; // st7@4
  int v7; // [sp+18h] [bp+Ch]@6
  float v8; // [sp+18h] [bp+Ch]@6

  sub_100632B0(a1, a2, (float *)a4, (float *)a5);
  if ( (_BYTE)a3 != 1 && *(float *)a4 > 25.0 )
  {
    if ( (_BYTE)a3 )
      v6 = sub_10062650(a3);
    else
      v6 = a6;
    *(float *)&v7 = v6;
    v8 = *(float *)a5 - *(float *)&v7;
    *(float *)a5 = v8;
    *(float *)a5 = sub_100680D0(v8);
  }
}

//----- (1005FA30) --------------------------------------------------------
void __usercall sub_1005FA30(int a1@<ebx>, int a2@<edi>, float a3, float a4)
{
  long double v4; // st7@1
  double v5; // st7@4
  double v6; // ST20_8@7
  double v7; // st7@7
  double v8; // st7@7
  long double v9; // st7@7
  signed int v10; // esi@7
  long double v11; // st7@7
  long double v12; // st7@7
  long double v13; // st7@8
  long double v14; // st4@8
  double v15; // st7@8
  long double v16; // st4@8
  double v17; // st5@10
  float v18; // ST20_4@10
  float v19; // [sp+18h] [bp-78h]@1
  double v20; // [sp+18h] [bp-78h]@7
  double v21; // [sp+20h] [bp-70h]@7
  double v22; // [sp+28h] [bp-68h]@8
  double v23; // [sp+30h] [bp-60h]@7
  double v24; // [sp+38h] [bp-58h]@8
  double v25; // [sp+40h] [bp-50h]@7
  double v26; // [sp+48h] [bp-48h]@7
  double v27; // [sp+50h] [bp-40h]@7
  double v28; // [sp+58h] [bp-38h]@7
  double v29; // [sp+60h] [bp-30h]@7
  double v30; // [sp+68h] [bp-28h]@7
  double v31; // [sp+70h] [bp-20h]@7
  double v32; // [sp+78h] [bp-18h]@8
  double v33; // [sp+80h] [bp-10h]@8
  double v34; // [sp+88h] [bp-8h]@7

  v19 = *(float *)a2;
  v4 = v19;
  if ( (LODWORD(v19) & 0x7F800000) == 2139095040 || v4 > 1.570796251296997 )
  {
    v5 = 1.5707963;
    goto LABEL_6;
  }
  if ( v4 < -1.570796251296997 )
  {
    v5 = -1.5707963;
LABEL_6:
    v19 = v5;
    v4 = v19;
  }
  v6 = sin(v4) * 0.9966471893352525 / cos(v19);
  v27 = sin(a4);
  v7 = cos(a4);
  v23 = v7;
  v8 = sub_10068260(v6, v7);
  v28 = v8 + v8;
  v25 = 1.0 / sqrt(v6 * v6 + 1.0);
  v26 = v6 * v25;
  v34 = v25 * v27;
  v30 = v34 * v34;
  v31 = 1.0 - v30;
  v9 = sqrt(v31 * 0.006739496742276474 + 1.0);
  v10 = 0;
  v11 = (v9 + 1.0 - 2.0) / (v9 + 1.0);
  v29 = (v11 * 0.375 * v11 - 1.0) * v11;
  v12 = a3 / 0.9966471893352525 / 6378137.0 / ((v11 * v11 * 0.25 + 1.0) / (1.0 - v11));
  v21 = v12;
  v20 = v12;
  do
  {
    v22 = sin(v12);
    v24 = cos(v20);
    v13 = cos(v20 + v28);
    v33 = v13;
    ++v10;
    v32 = v13 * v13 + v13 * v13 - 1.0;
    v14 = v29 * (((v32 * v24 + (v32 + v32 - 1.0) * (v22 * v22 * 4.0 - 3.0) * v13 * v29 / 6.0) * v29 * 0.25 - v13) * v22);
    v15 = v20;
    v20 = v14 + v21;
    v16 = v20 - v15;
    v12 = v20;
  }
  while ( fabs(v16) > 0.00000005 && v10 < 20 );
  *(float *)a1 = sub_10068260(
                   v22 * v25 * v23 + v24 * v26,
                   sqrt((v24 * v25 * v23 - v22 * v26) * (v24 * v25 * v23 - v22 * v26) + v30) * 0.9966471893352525);
  v17 = v31 * ((4.0 - 3.0 * v31) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
  v18 = sub_10068260(v22 * v27, v24 * v25 - v22 * v26 * v23)
      - 0.00335281066474748 * ((1.0 - v17) * (((v32 * v24 * v17 + v33) * v22 * v17 + v20) * v34))
      + *(float *)(a2 + 4);
  *(float *)(a1 + 4) = sub_100680D0(v18);
}

//----- (1005FD20) --------------------------------------------------------
void __usercall sub_1005FD20(int a1@<esi>)
{
  double v1; // st7@1
  float v2; // ST04_4@4
  double v3; // st6@4

  v1 = 1.570796370506287;
  while ( *(float *)a1 > v1 || *(float *)a1 < -1.570796370506287 )
  {
    v2 = *(float *)(a1 + 4) + 3.141592741012573;
    *(float *)(a1 + 4) = sub_100680D0(v2);
    v1 = 1.570796370506287;
    v3 = *(float *)a1;
    if ( v3 <= 1.570796370506287 )
      *(float *)a1 = -3.141592741012573 - v3;
    else
      *(float *)a1 = 3.141592741012573 - v3;
  }
}

//----- (1005FD90) --------------------------------------------------------
void __cdecl sub_1005FD90(int a1, float a2, float a3, int a4)
{
  double v4; // st5@4
  double v5; // st5@8
  double v6; // st6@10
  int v7; // ecx@13
  float v8; // edx@13
  double v9; // st7@14
  float i; // [sp+14h] [bp-24h]@16
  char v11; // [sp+18h] [bp-20h]@16
  float v12; // [sp+1Ch] [bp-1Ch]@16
  float v13; // [sp+20h] [bp-18h]@13
  float v14; // [sp+24h] [bp-14h]@8
  int v15; // [sp+28h] [bp-10h]@16
  float v16; // [sp+2Ch] [bp-Ch]@16
  int v17; // [sp+30h] [bp-8h]@13
  float v18; // [sp+34h] [bp-4h]@13

  if ( fabs(a2) < 0.0000009999999974752427 )
  {
    *(_DWORD *)a4 = *(_DWORD *)a1;
    *(_DWORD *)(a4 + 4) = *(_DWORD *)(a1 + 4);
    return;
  }
  if ( fabs(*(float *)a1 - 1.570796370506287) < 0.0000009999999974752427 )
  {
    v4 = 3.1415925;
LABEL_7:
    a3 = v4;
    goto LABEL_8;
  }
  if ( fabs(*(float *)a1 + 1.570796370506287) < 0.0000009999999974752427 )
  {
    v4 = 0.0;
    goto LABEL_7;
  }
LABEL_8:
  v5 = a3;
  v14 = fabs(a3);
  if ( v14 < 0.000001 || 3.1415926535898 - v5 < 0.0000009999999974752427 )
  {
    v6 = v14;
  }
  else
  {
    v6 = v14;
    if ( v5 + 3.1415926535898 >= 0.0000009999999974752427 )
    {
      sub_1005FA30(a4, a1, a2, a3);
      return;
    }
  }
  v7 = *(_DWORD *)a1;
  v8 = *(float *)(a1 + 4);
  v14 = a2;
  v17 = v7;
  v13 = a3;
  v18 = v8;
  if ( v6 >= 0.000001 )
    v9 = -1.5707964;
  else
    v9 = 1.5707964;
  *(float *)&v15 = v9;
  v16 = v18;
  sub_10062EE0((int)&v17, (int)&v15, &v12, (float *)&v11, (float *)&v11);
  for ( i = a2 - v12; i > 0.0; i = i - v12 )
  {
    v14 = v13 + 3.141592741012573;
    v13 = sub_100680D0(v14);
    v14 = v16 + 3.141592741012573;
    v16 = sub_100680D0(v14);
    v14 = i;
    v17 = v15;
    *(float *)&v15 = -*(float *)&v15;
    v18 = v16;
    sub_10062EE0((int)&v17, (int)&v15, &v12, (float *)&v11, (float *)&v11);
  }
  sub_1005FA30(a4, (int)&v17, v14, v13);
}

//----- (1005FFA0) --------------------------------------------------------
void __cdecl sub_1005FFA0(int a1, float a2, float a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  double v6; // st7@1
  double v7; // st7@2
  float v8; // [sp+14h] [bp-8h]@1
  int v9; // [sp+18h] [bp-4h]@1

  v4 = a1;
  v8 = cos(*(float *)a1);
  a2 = a2 / 6378137.0;
  sub_10068220(a3, (int)&v9, (int)&a1);
  v5 = a4;
  v6 = a2;
  *(float *)a4 = *(float *)&a1 * a2 + *(float *)v4;
  LODWORD(a2) = LODWORD(v8) & 0x7FFFFFFF;
  if ( COERCE_FLOAT(LODWORD(v8) & 0x7FFFFFFF) <= 0.000001 )
    v7 = *(float *)(v4 + 4);
  else
    v7 = v6 * *(float *)&v9 / v8 + *(float *)(v4 + 4);
  *(float *)(v5 + 4) = v7;
  *(float *)(v5 + 4) = sub_100680D0(*(float *)(v5 + 4));
  sub_1005FD20(v5);
}

//----- (10060050) --------------------------------------------------------
int __cdecl sub_10060050(int a1, float a2, float a3, int a4, int a5, float a6)
{
  double v6; // st7@3
  char v8; // [sp+Ch] [bp-8h]@1
  int v9; // [sp+24h] [bp+10h]@5
  int v10; // [sp+24h] [bp+10h]@5

  sub_10068110(a1, (int)&v8);
  if ( (_BYTE)a4 != 1 )
  {
    if ( (_BYTE)a4 )
      v6 = sub_10062650(a4);
    else
      v6 = a6;
    *(float *)&v9 = v6;
    *(float *)&v10 = *(float *)&v9 + a3;
    a3 = sub_100680D0(*(float *)&v10);
  }
  sub_1005FD90((int)&v8, a2, a3, (int)&v8);
  return sub_10068240((int)&v8, a5);
}

//----- (100600E0) --------------------------------------------------------
char __cdecl sub_100600E0(int a1, float a2, int a3, float a4, char a5, int a6)
{
  char v6; // bl@1
  double v7; // st6@2
  double v8; // st7@3
  float v9; // ST2C_4@7
  float v10; // ST08_4@5
  float v11; // ST24_4@5
  double v12; // st7@5
  float v13; // ST24_4@7
  float v14; // ST24_4@7
  float v16; // ST20_4@9
  float v17; // ST1C_4@9
  double v18; // st5@9
  float v19; // ST1C_4@14
  double v20; // st6@15
  float v21; // ST04_4@22
  float v22; // [sp+4h] [bp-38h]@3
  int v23; // [sp+8h] [bp-34h]@3
  float v24; // [sp+18h] [bp-24h]@5
  float v25; // [sp+18h] [bp-24h]@9
  int v26; // [sp+1Ch] [bp-20h]@5
  float v27; // [sp+1Ch] [bp-20h]@7
  float v28; // [sp+20h] [bp-1Ch]@7
  float v29; // [sp+20h] [bp-1Ch]@9
  float v30; // [sp+2Ch] [bp-10h]@1
  float v31; // [sp+30h] [bp-Ch]@1
  double v32; // [sp+34h] [bp-8h]@7

  v6 = 1;
  sub_100634A0((float *)a1, (float *)a3, (int)&v30);
  if ( COERCE_FLOAT(LODWORD(v31) & 0x7FFFFFFF) >= 25.0 )
  {
    v7 = v30;
  }
  else
  {
    v7 = v30;
    if ( COERCE_FLOAT(LODWORD(v30) & 0x7FFFFFFF) < 25.0 )
    {
      v23 = a6;
      v22 = a2;
      v8 = a4;
      goto LABEL_22;
    }
  }
  v24 = v7 * v7 + v31 * v31;
  v10 = v7;
  v11 = a2 - sub_100682D0(v10, v31);
  v26 = LODWORD(v11) & 0x7FFFFFFF;
  v12 = COERCE_FLOAT(LODWORD(v11) & 0x7FFFFFFF);
  if ( v12 > 3.141592741012573 )
    *(float *)&v26 = 6.283185482025146 - v12;
  v13 = sqrt(v24);
  v32 = v13 * -2.0;
  v14 = cos(*(float *)&v26);
  v28 = v14 * v32;
  v9 = a4 * a4;
  v27 = v28 * v28 - (v24 - v9) * 4.0;
  if ( v27 < 0.0 )
    return 0;
  v16 = sqrt(v27);
  v17 = -v28;
  v18 = v17;
  v25 = (v16 + v17) * 0.5;
  v29 = (v18 - v16) * 0.5;
  if ( a5 )
  {
    v8 = v25;
    if ( COERCE_FLOAT(LODWORD(v29) & 0x7FFFFFFF) < (double)COERCE_FLOAT(LODWORD(v25) & 0x7FFFFFFF) )
      v8 = v29;
  }
  else if ( v29 >= 0.0 || v25 >= 0.0 )
  {
    v20 = v25;
    if ( v29 < 0.0 || v20 >= 0.0 && v20 <= v29 )
      v8 = v25;
    else
      v8 = v29;
  }
  else
  {
    v6 = 0;
    v19 = sub_1005F9A0(v25, v29);
    v8 = v19;
  }
  v23 = a6;
  v22 = a2;
LABEL_22:
  v21 = v8;
  sub_1005FFA0(a1, v21, v22, v23);
  return v6;
}

//----- (10060340) --------------------------------------------------------
char __cdecl sub_10060340(int a1, float a2, int a3, float a4, int a5)
{
  char v5; // bl@1
  float v7; // [sp+18h] [bp-2Ch]@2
  int v8; // [sp+1Ch] [bp-28h]@1
  int v9; // [sp+24h] [bp-20h]@1
  int v10; // [sp+2Ch] [bp-18h]@1
  char v11; // [sp+34h] [bp-10h]@2
  char v12; // [sp+3Ch] [bp-8h]@2

  sub_10068110(a1, (int)&v10);
  sub_10068110(a3, (int)&v8);
  v5 = sub_100600E0((int)&v8, a4, (int)&v10, a2, 0, (int)&v9);
  if ( v5 )
  {
    sub_10063390((int)&v8, COERCE_FLOAT(&v9), &v7, (int)&v12, (float *)&v11);
    sub_1005FD90((int)&v8, v7, a4, (int)&v9);
    sub_10068240((int)&v9, a5);
  }
  return v5;
}

//----- (100603F0) --------------------------------------------------------
char sub_100603F0()
{
  char result; // al@2

  if ( !sub_1002BA70() || (result = *(_BYTE *)(dword_10A09ABC + 812), (unsigned __int8)result >= 0x66u) && result != -1 )
    result = -1;
  return result;
}
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (10060410) --------------------------------------------------------
void __cdecl sub_10060410(int a1, int a2, int a3, float *a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@3
  int v7; // ebx@5
  float *v8; // eax@9
  char v9; // [sp+10h] [bp-8h]@5

  v5 = a1;
  *(float *)&a1 = *(double *)a1;
  *(float *)&a1 = *(float *)&a1 - 6.283185005187988;
  a1 &= 0x7FFFFFFFu;
  if ( *(float *)&a1 < 0.1
    || (*(float *)&a1 = *(double *)(v5 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (v6 = a2,
        *(float *)&a1 = *(double *)a2,
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1)
    || (*(float *)&a1 = *(double *)(a2 + 8),
        *(float *)&a1 = *(float *)&a1 - 6.283185005187988,
        a1 &= 0x7FFFFFFFu,
        *(float *)&a1 < 0.1) )
  {
    v8 = (float *)a5;
    *a4 = 9.9999996e24;
    *v8 = 9.9999996e24;
  }
  else
  {
    sub_10068110(v5, (int)&v9);
    v7 = a3;
    if ( (_BYTE)a3 )
      *(float *)&a1 = sub_10062650(a3);
    else
      sub_10028080(&v9, &a1);
    sub_1005F9C0(v5, v6, v7, (int)a4, a5, *(float *)&a1);
  }
}
// 10028080: using guessed type _DWORD __cdecl sub_10028080(_DWORD, _DWORD);

//----- (10060540) --------------------------------------------------------
int __cdecl sub_10060540(int a1, float a2, float a3, int a4, int a5)
{
  float v6; // [sp+1Ch] [bp-Ch]@2
  char v7; // [sp+20h] [bp-8h]@1

  sub_10068110(a1, (int)&v7);
  if ( (_BYTE)a4 )
    v6 = 0.0;
  else
    sub_10028080(&v7, &v6);
  return sub_10060050(a1, a2, a3, a4, a5, v6);
}
// 10028080: using guessed type _DWORD __cdecl sub_10028080(_DWORD, _DWORD);

//----- (100605B0) --------------------------------------------------------
char __cdecl sub_100605B0(float a1, int a2, int a3)
{
  double v3; // st7@1
  unsigned __int8 v4; // bl@1
  float *v5; // esi@1
  int v6; // ebp@1
  unsigned __int8 v7; // cl@1
  char result; // al@1
  int v9; // edx@5
  int v10; // eax@6
  unsigned int v11; // ecx@6
  double v12; // st6@7
  int v13; // eax@10
  int v14; // edi@10
  double v15; // st6@11
  double v16; // st6@13
  double v17; // st7@16
  double v18; // st6@16
  double v19; // rt1@18
  char v20; // bl@22
  double v21; // st6@25
  float v22; // [sp+10h] [bp+4h]@7
  float v23; // [sp+10h] [bp+4h]@7
  float v24; // [sp+10h] [bp+4h]@7
  float v25; // [sp+10h] [bp+4h]@25
  _BYTE *v26; // [sp+14h] [bp+8h]@1

  v3 = 0.0;
  v4 = LOBYTE(a1);
  v5 = (float *)a2;
  *(float *)a2 = 0.0;
  *(_DWORD *)a3 = 0x7FFFFFFF;
  v6 = dword_10A09ABC;
  v26 = (_BYTE *)(dword_10A09ABC + 812);
  v7 = *(_BYTE *)(dword_10A09ABC + 812);
  result = 0;
  if ( LOBYTE(a1) < v7
    || LOBYTE(a1) >= *(_BYTE *)(dword_10A09AB0 + 4)
    && ((unsigned __int8)(LOBYTE(a1) - 100) > 1u || *(_BYTE *)(dword_10A09ABC + 816) != 3) )
  {
    return result;
  }
  v9 = v7 + 1;
  if ( LOBYTE(a1) - v9 + 1 >= 4 )
  {
    v10 = 180 * v9;
    v11 = (((unsigned int)LOBYTE(a1) - v9 - 3) >> 2) + 1;
    v9 += 4 * v11;
    do
    {
      v12 = *(float *)(v10 + dword_10A09AB0 + 696);
      v10 += 720;
      --v11;
      v22 = v12 + *v5;
      *v5 = v22;
      v23 = v22 + *(float *)(v10 + dword_10A09AB0 + 156);
      *v5 = v23;
      v24 = v23 + *(float *)(v10 + dword_10A09AB0 + 336);
      *v5 = v24;
      *v5 = v24 + *(float *)(v10 + dword_10A09AB0 + 516);
    }
    while ( v11 );
    v6 = dword_10A09ABC;
  }
  if ( v9 <= v4 )
  {
    v13 = 180 * v9;
    v14 = v4 - v9 + 1;
    do
    {
      v15 = *(float *)(v13 + dword_10A09AB0 + 696);
      v13 += 180;
      --v14;
      *v5 = v15 + *v5;
    }
    while ( v14 );
    v6 = dword_10A09ABC;
  }
  v16 = 9.9999996e24;
  if ( 9.9999996e24 == *(float *)(v6 + 316) || 9.9999996e24 == *(float *)(v6 + 332) )
  {
    v18 = 0.0;
    v17 = 9.9999996e24;
    *v5 = 0.0;
  }
  else
  {
    if ( *(_BYTE *)(180 * *v26 + dword_10A09AB0 + 671) == 21 )
      goto LABEL_19;
    *v5 = sub_10042280(*(_DWORD *)(v6 + 296)) * *(float *)(dword_10A09ABC + 332)
        + *(float *)(dword_10A09ABC + 316)
        + *v5;
    v17 = 9.9999996e24;
    v18 = 0.0;
  }
  v19 = v18;
  v16 = v17;
  v3 = v19;
LABEL_19:
  *(_DWORD *)v5 = COERCE_UNSIGNED_INT(*v5) & 0x7FFFFFFF;
  if ( (COERCE_UNSIGNED_INT(*v5) & 0x7F800000) == 2139095040 || v16 < *v5 || v3 > *v5 )
  {
    *v5 = v3;
    v20 = 0;
  }
  else
  {
    v20 = 1;
  }
  if ( *(_BYTE *)(dword_10A09ABC + 660) )
  {
    v25 = *v5 / *(float *)(dword_10A09ABC + 688) + 0.5;
    v21 = v25;
    if ( (LODWORD(v25) & 0x7F800000) == 2139095040 || v21 > 2147418112.0 || v21 < v3 )
    {
      *(_DWORD *)a3 = 0x7FFFFFFF;
      result = 0;
    }
    else
    {
      *(_DWORD *)a3 = (signed int)v21;
      result = v20;
    }
  }
  else
  {
    result = v20;
  }
  return result;
}
// 10042280: using guessed type double __cdecl sub_10042280(_DWORD);
// 10A09AB0: using guessed type int dword_10A09AB0;
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (10060810) --------------------------------------------------------
int __cdecl sub_10060810(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_crit_lvl(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068530: using guessed type int __cdecl TSK_pvg_get_crit_lvl(_DWORD);

//----- (10060830) --------------------------------------------------------
int sub_10060830()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_id();
  SYS_exit_krnl();
  return v0;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068536: using guessed type int TSK_pvg_get_id(void);

//----- (10060850) --------------------------------------------------------
int __cdecl sub_10060850(int a1, int a2, int a3)
{
  int v3; // esi@1

  SYS_enter_krnl();
  v3 = TSK_pvg_get_mon_data(a1, a2, a3);
  SYS_exit_krnl();
  return v3;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006853C: using guessed type int __cdecl TSK_pvg_get_mon_data(_DWORD, _DWORD, _DWORD);

//----- (10060880) --------------------------------------------------------
int __cdecl sub_10060880(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_msg(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068542: using guessed type int __cdecl TSK_pvg_get_msg(_DWORD, _DWORD);

//----- (100608B0) --------------------------------------------------------
__int16 __cdecl sub_100608B0(int a1)
{
  __int16 v1; // si@1

  SYS_enter_krnl();
  v1 = TSK_pvg_get_run_state(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068548: using guessed type int __cdecl TSK_pvg_get_run_state(_DWORD);

//----- (100608D0) --------------------------------------------------------
int __cdecl sub_100608D0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_get_smphr_stats(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006854E: using guessed type int __cdecl TSK_pvg_get_smphr_stats(_DWORD, _DWORD);

//----- (10060900) --------------------------------------------------------
int sub_10060900()
{
  int v0; // esi@1

  SYS_enter_krnl();
  v0 = TSK_pvg_get_timer();
  SYS_exit_krnl();
  return v0;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068554: using guessed type int TSK_pvg_get_timer(void);

//----- (10060920) --------------------------------------------------------
int __cdecl sub_10060920(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_get_tsk_info(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006855A: using guessed type int __cdecl TSK_pvg_get_tsk_info(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10060950) --------------------------------------------------------
int sub_10060950()
{
  char v1; // [sp+0h] [bp-84h]@1
  int v2; // [sp+24h] [bp-60h]@1
  int v3; // [sp+34h] [bp-50h]@1

  sub_10060850(-2, (int)&v1, 0);
  return v3 + 1000 * v2;
}

//----- (100609B0) --------------------------------------------------------
int __cdecl sub_100609B0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_kill_process(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068566: using guessed type int __cdecl TSK_pvg_kill_process(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100609E0) --------------------------------------------------------
int __cdecl sub_100609E0(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_proc_status(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006856C: using guessed type int __cdecl TSK_pvg_proc_status(_DWORD);

//----- (10060A00) --------------------------------------------------------
int __cdecl sub_10060A00(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_release_smphr(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068572: using guessed type int __cdecl TSK_pvg_release_smphr(_DWORD);

//----- (10060A20) --------------------------------------------------------
signed int __cdecl sub_10060A20(int a1, int a2)
{
  int v2; // esi@4
  signed int result; // eax@4

  if ( a2 && (!*(_DWORD *)(a2 + 4) || *(_DWORD *)a2) )
  {
    SYS_enter_krnl();
    v2 = TSK_pvg_reply_msg(a1, a2);
    SYS_exit_krnl();
    result = v2;
  }
  else
  {
    result = 20;
  }
  return result;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068578: using guessed type int __cdecl TSK_pvg_reply_msg(_DWORD, _DWORD);

//----- (10060A60) --------------------------------------------------------
int __cdecl sub_10060A60(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_reserve_smphr(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006857E: using guessed type int __cdecl TSK_pvg_reserve_smphr(_DWORD, _DWORD);

//----- (10060A90) --------------------------------------------------------
int __cdecl sub_10060A90(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_evnt(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068584: using guessed type int __cdecl TSK_pvg_send_evnt(_DWORD, _DWORD);

//----- (10060AC0) --------------------------------------------------------
int __cdecl sub_10060AC0(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1

  SYS_enter_krnl();
  v4 = TSK_pvg_send_msg(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006858A: using guessed type int __cdecl TSK_pvg_send_msg(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10060AF0) --------------------------------------------------------
int __cdecl sub_10060AF0(int a1, int a2)
{
  int v2; // esi@1

  SYS_enter_krnl();
  v2 = TSK_pvg_send_msg_ex(a1, a2);
  SYS_exit_krnl();
  return v2;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068590: using guessed type int __cdecl TSK_pvg_send_msg_ex(_DWORD, _DWORD);

//----- (10060B20) --------------------------------------------------------
int __cdecl sub_10060B20(int a1)
{
  SYS_enter_krnl();
  TSK_pvg_set_proc_status(a1);
  return SYS_exit_krnl();
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068596: using guessed type int __cdecl TSK_pvg_set_proc_status(_DWORD);

//----- (10060B40) --------------------------------------------------------
signed int __cdecl sub_10060B40(int a1, int a2)
{
  signed int result; // eax@3
  char v3; // [sp+0h] [bp-10h]@1
  int v4; // [sp+8h] [bp-8h]@4
  char v5; // [sp+Ch] [bp-4h]@3

  if ( sub_100608D0(a1, (int)&v3) )
  {
    result = -1;
  }
  else if ( a2 == -2 )
  {
    result = v5 & 1;
  }
  else
  {
    result = v4 == a2;
  }
  return result;
}

//----- (10060B90) --------------------------------------------------------
int __cdecl sub_10060B90(int a1)
{
  int v1; // esi@1

  SYS_enter_krnl();
  v1 = TSK_pvg_suspend(a1);
  SYS_exit_krnl();
  return v1;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006859C: using guessed type int __cdecl TSK_pvg_suspend(_DWORD);

//----- (10060BB0) --------------------------------------------------------
char __cdecl sub_10060BB0(int a1, int a2)
{
  unsigned int v2; // esi@1
  char result; // al@4

  v2 = a2 + sub_10060900();
  if ( sub_100609E0(a1) == 5 )
    goto LABEL_4;
  while ( sub_10060900() < v2 )
  {
    sub_10060B90(20);
    if ( sub_100609E0(a1) == 5 )
      goto LABEL_4;
  }
  if ( sub_100609E0(a1) == 5 )
  {
LABEL_4:
    result = 1;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\tsk\\tsk_usr.c", 1769, 0, 0);
    result = 0;
  }
  return result;
}

//----- (10060C20) --------------------------------------------------------
int __cdecl sub_10060C20(_BYTE *a1)
{
  int v1; // edi@1
  int v2; // eax@2
  char v4; // [sp+8h] [bp-4h]@2

  SYS_enter_krnl();
  v1 = TSK_pvg_wait_evnt(a1);
  SYS_exit_krnl();
  if ( *a1 & 0x20 )
  {
    v2 = sub_10060830();
    sub_10060920((int)&v4, 5, v2, 4);
  }
  return v1;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 100685A2: using guessed type int __cdecl TSK_pvg_wait_evnt(_DWORD);

//----- (10060C60) --------------------------------------------------------
int __cdecl sub_10060C60(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) != 1 && !a1 )
    result = sub_10060A00(a2);
  return result;
}
// 1007F414: using guessed type void *tsk_app_hdr_ptr;

//----- (10060C90) --------------------------------------------------------
int __cdecl sub_10060C90(int a1, int a2)
{
  int result; // eax@2

  if ( *((_BYTE *)tsk_app_hdr_ptr + 8) == 1 )
    result = 0;
  else
    result = sub_10060A60(a1, a2);
  return result;
}
// 1007F414: using guessed type void *tsk_app_hdr_ptr;

//----- (10060CB0) --------------------------------------------------------
bool __cdecl sub_10060CB0(int a1)
{
  return sub_10060B40(a1, -2) > 0;
}

//----- (10060CD0) --------------------------------------------------------
int __cdecl sub_10060CD0(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = 0;
  result = 42066;
  while ( dword_10128470[2 * v1] != a1 )
  {
    if ( (unsigned int)++v1 >= 0xA5 )
      return result;
  }
  return dword_10128474[2 * v1];
}
// 10128470: using guessed type int dword_10128470[];
// 10128474: using guessed type int dword_10128474[];

//----- (10060D20) --------------------------------------------------------
unsigned int __cdecl sub_10060D20(unsigned int a1)
{
  unsigned int result; // eax@1

  result = 43;
  if ( a1 < 0xA452 )
    result = (unsigned int)((unsigned __int16)a1 * (unsigned __int64)(unsigned int)&unk_10624DD3 >> 32) >> 6;
  return result;
}

//----- (10060D80) --------------------------------------------------------
int __cdecl sub_10060D80(int a1, int a2, int a3)
{
  return reg_read(a1, a2, a3, 0);
}
// 100685BA: using guessed type int __cdecl reg_read(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10060DA0) --------------------------------------------------------
int __cdecl sub_10060DA0(int a1, int a2, __int16 a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+8h] [bp-8h]@1

  v7 = 0;
  *(_DWORD *)a5 = 0;
  LOWORD(v7) = a3;
  *(_DWORD *)(a5 + 4) = -1;
  return reg_read_from_xml(a1, &v6, a4, a2, v7, a5);
}
// 100685C0: using guessed type int __cdecl reg_read_from_xml(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10060E00) --------------------------------------------------------
char __cdecl sub_10060E00(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10060D80(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10028BC0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1255, 1, 0);
  return v3;
}

//----- (10060E40) --------------------------------------------------------
int __cdecl sub_10060E40(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // esi@1

  result = sub_10060D80(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    result = v5;
  }
  return result;
}

//----- (10060E80) --------------------------------------------------------
int __cdecl sub_10060E80(int a1, int a2, int a3)
{
  int result; // eax@1

  result = sub_10060D80(a1 | 0x20000, a2, a3);
  if ( result == -46 )
    result = 0;
  return result;
}

//----- (10060EB0) --------------------------------------------------------
int __cdecl sub_10060EB0(int a1, int a2, int a3)
{
  return sub_10060E80(a1 | 0x40000, a2, a3);
}

//----- (10060ED0) --------------------------------------------------------
int __cdecl sub_10060ED0(int a1, int a2, int a3)
{
  return reg_write(a1, a2, a3, 0);
}
// 100685C6: using guessed type int __cdecl reg_write(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10060EF0) --------------------------------------------------------
int __cdecl sub_10060EF0(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@2
  int result; // eax@4
  int v6; // [sp+10h] [bp-4h]@1

  v6 = sub_10060ED0(a1, a2, a3);
  v3 = 0;
  if ( (unsigned __int8)sub_10062070() )
  {
    v4 = sub_10060CD0(a1);
    if ( v4 != 42066 )
      v3 = sub_10060ED0(v4, a2, a3);
  }
  result = v6;
  if ( !v6 )
    result = v3;
  return result;
}
// 10062070: using guessed type int sub_10062070(void);

//----- (10060F50) --------------------------------------------------------
int __cdecl sub_10060F50(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_10060EF0(a1, a2, a3);
  v4 = result;
  if ( result )
  {
    sub_10028BC0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1742, 1, 0);
    result = v4;
  }
  return result;
}

//----- (10060F90) --------------------------------------------------------
char __cdecl sub_10060F90(int a1, int a2, int a3)
{
  int v3; // eax@1

  v3 = sub_10060ED0(a1, a2, a3);
  if ( v3 )
    LOBYTE(v3) = sub_10028BC0("..\\lib\\acl\\kernel\\reg_usr_intf.c", 1826, 1, 0);
  return v3;
}

//----- (10061000) --------------------------------------------------------
int __cdecl sub_10061000(int a1, void *a2, int a3, void *a4)
{
  int result; // eax@1
  int v5; // edi@1

  result = sub_10060D80(a1, (int)a2, a3);
  v5 = result;
  if ( result )
  {
    memcpy(a2, a4, (unsigned __int16)a3);
    sub_10060ED0(a1, (int)a4, a3);
    result = v5;
  }
  return result;
}

//----- (10061070) --------------------------------------------------------
signed int __cdecl sub_10061070(unsigned int a1)
{
  signed int result; // eax@4
  int v2; // eax@8
  int v3; // edx@9

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_16;
  if ( (a1 & 3) == 1 )
    return sub_1005A230(a1);
  if ( a1 && (a1 & 3) == 2 )
  {
    v2 = 0;
    if ( !dword_109FF0F0 )
      goto LABEL_11;
    while ( 1 )
    {
      v3 = dword_109FF0F8[v2];
      if ( *(_DWORD *)v3 == a1 )
        break;
      if ( ++v2 >= (unsigned int)dword_109FF0F0 )
        goto LABEL_11;
    }
    if ( v2 != -1 )
    {
      sub_10062080(
        v2,
        *(_DWORD *)(dword_109FF0F8[v2] + 12),
        *(_DWORD *)(v3 + 16),
        *(_BYTE *)(v3 + 32),
        *(_WORD *)(v3 + 20),
        *(_DWORD *)(v3 + 4));
      result = sub_10061070(a1 & 0xFFFFFFFC);
    }
    else
    {
LABEL_11:
      result = -6;
    }
  }
  else
  {
LABEL_16:
    result = FIL_vfs_close();
  }
  return result;
}
// 100685E4: using guessed type int FIL_vfs_close(void);
// 109FF0F0: using guessed type int dword_109FF0F0;
// 109FF0F8: using guessed type int dword_109FF0F8[];

//----- (100610B0) --------------------------------------------------------
signed int __cdecl sub_100610B0(unsigned int a1)
{
  signed int result; // eax@3

  if ( a1 < 0xFFFFFFC2 && a1 )
    result = sub_10061070(a1);
  else
    result = -6;
  return result;
}

//----- (100610F0) --------------------------------------------------------
int __cdecl sub_100610F0(int a1, void *a2)
{
  unsigned int v2; // edi@4
  int v3; // ebx@7
  int v4; // eax@7
  int result; // eax@5

  if ( (unsigned int)a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
  {
    v2 = sub_10038960(a1);
    memset(a2, 0, 0x3Cu);
    if ( v2 )
    {
      sub_1002C120((int)a2 + 48, &unk_10119598, 10);
      *((_DWORD *)a2 + 3) = *(_DWORD *)(v2 + 44);
      *((_DWORD *)a2 + 4) = 0;
      *((_DWORD *)a2 + 8) = 1;
      *((_DWORD *)a2 + 9) = *(_DWORD *)(v2 + 40);
      sub_1002CA60(*(_WORD *)(v2 + 34), *(_WORD *)(v2 + 32), (_DWORD *)a2 + 6);
      v3 = *((_DWORD *)a2 + 6);
      *((_DWORD *)a2 + 5) = v3;
      *((_DWORD *)a2 + 7) = v3;
      v4 = *(_DWORD *)(v2 + 58);
      *((_DWORD *)a2 + 10) = v4;
      *((_DWORD *)a2 + 1) = (v4 & 0x10) != 0 ? 4096 : 0x2000;
      result = 0;
    }
    else
    {
      result = -6;
    }
  }
  else
  {
    result = FIL_vfs_fstat();
  }
  return result;
}
// 100685F6: using guessed type int FIL_vfs_fstat(void);

//----- (10061120) --------------------------------------------------------
int __cdecl sub_10061120(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-1Ch]@1
  __int64 v7; // [sp+4h] [bp-18h]@1
  __int64 v8; // [sp+10h] [bp-Ch]@1

  v7 = a2;
  v8 = a4;
  return FIL_vfs_memmove_swi(&v6, a1, v7, HIDWORD(v7), a3, v8, HIDWORD(v8), a5);
}
// 100685FC: using guessed type int __cdecl FIL_vfs_memmove_swi(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100611A0) --------------------------------------------------------
signed int __cdecl sub_100611A0(unsigned int a1, void *a2, int a3)
{
  unsigned int v3; // eax@4
  signed int result; // eax@4
  int v5; // eax@7

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
  {
    v3 = sub_10038960(a1);
    return sub_1003A370(v3, (int)a2, a3);
  }
  if ( a1 && (a1 & 3) == 2 )
  {
    v5 = sub_100613E0(a1 & 0xFFFFFFFC, 0, 1);
    result = sub_10062420(a1, a2, a3, v5, (unsigned __int64)v5 >> 32);
  }
  else
  {
LABEL_11:
    result = FIL_vfs_read();
  }
  return result;
}
// 10068614: using guessed type int FIL_vfs_read(void);

//----- (100611F0) --------------------------------------------------------
signed int __cdecl sub_100611F0(unsigned int a1, void *a2, int a3, int a4, int a5)
{
  signed int result; // eax@4

  if ( a1 >= 0xFFFFFFC2 || !a1 )
    goto LABEL_11;
  if ( (a1 & 3) == 1 )
    return sub_1005A310(a1, (int)a2, a3, a4);
  if ( a1 && (a1 & 3) == 2 )
    result = sub_10062420(a1, a2, a3, a4, a5);
  else
LABEL_11:
    result = FIL_vfs_read_ofst(a1, a2, a3, &a4);
  return result;
}
// 10068620: using guessed type int __cdecl FIL_vfs_read_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10061290) --------------------------------------------------------
signed int __cdecl sub_10061290(unsigned int a1, int a2, int a3, int a4)
{
  signed int result; // eax@4

  if ( a1 < 0xFFFFFFC2 && a1 && (a1 & 3) == 1 )
    result = sub_1005A370(a1, a2, a4);
  else
    result = FIL_vfs_seek(a1 & 0xFFFFFFFC, a2, a3, a4);
  return result;
}
// 10068632: using guessed type int __cdecl FIL_vfs_seek(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100612E0) --------------------------------------------------------
__int64 __cdecl sub_100612E0(int a1)
{
  return FIL_vfs_size(a1 & 0xFFFFFFFC);
}
// 10068638: using guessed type int __cdecl FIL_vfs_size(_DWORD);

//----- (10061310) --------------------------------------------------------
int __cdecl sub_10061310(int a1, int a2, int a3)
{
  return FIL_vfs_truncate(a1, a2, a3);
}
// 10068644: using guessed type int __cdecl FIL_vfs_truncate(_DWORD, _DWORD, _DWORD);

//----- (10061340) --------------------------------------------------------
int __cdecl sub_10061340(int a1, int a2, int a3, char a4)
{
  return FIL_vfs_write_ofst(a1, a2, a3, &a4);
}
// 10068650: using guessed type int __cdecl FIL_vfs_write_ofst(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10061360) --------------------------------------------------------
char __cdecl sub_10061360(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 772, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10061070(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (10061390) --------------------------------------------------------
char __cdecl sub_10061390(int a1)
{
  unsigned int v1; // eax@1
  char result; // al@3

  v1 = j_FIL_vfs_open(a1, 516, 0);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    sub_10061070(v1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);

//----- (100613C0) --------------------------------------------------------
int __cdecl sub_100613C0(int a1, int a2, int a3)
{
  return j_FIL_vfs_read_dir_cnt(a1, a2, a3, -1);
}
// 100611E0: using guessed type int __cdecl j_FIL_vfs_read_dir_cnt(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100613E0) --------------------------------------------------------
signed int __cdecl sub_100613E0(unsigned int a1, int a2, int a3)
{
  return sub_10061290(a1, a2, (unsigned __int64)a2 >> 32, a3);
}

//----- (10061400) --------------------------------------------------------
int __cdecl sub_10061400(int a1, int a2, int a3)
{
  return sub_10061310(a1, a2, a3);
}

//----- (10061420) --------------------------------------------------------
int __cdecl sub_10061420(const char *a1)
{
  const char *v1; // edi@1
  int i; // esi@1
  int v3; // esi@3
  int result; // eax@3
  unsigned int v5; // eax@5
  unsigned int v6; // esi@5
  int v7; // ebx@7
  char *v8; // ebp@9
  char *v9; // eax@10
  char *v10; // edi@12
  char v11; // cl@13
  char v12; // dl@15
  unsigned int v13; // eax@16
  char *v14; // edi@16
  char v15; // cl@17
  int v16; // eax@19
  int v17; // eax@22
  signed int v18; // [sp+10h] [bp-1A0h]@9
  int v19; // [sp+18h] [bp-198h]@3
  unsigned int v20; // [sp+1Ch] [bp-194h]@5
  char v21; // [sp+20h] [bp-190h]@12
  char v22; // [sp+A0h] [bp-110h]@8

  v1 = a1;
  for ( i = 0; ; i = v19 )
  {
    v3 = i + 1;
    v19 = v3;
    result = j_FIL_vfs_rmdir(v1);
    if ( result != -30 || v3 >= 200000 )
      break;
    v5 = j_FIL_vfs_open(v1, 260, 0);
    v6 = v5;
    v20 = v5;
    if ( v5 < 0xFFFFFFC2 && v5 )
      v7 = sub_100613C0(v5, (int)&v22, 268);
    else
      v7 = v5;
    v8 = &v22;
    v18 = v7 < 0 ? 0 : v7;
    if ( (v7 < 0 ? 0 : v7) > 0 )
    {
      do
      {
        v9 = v8 + 24;
        if ( memcmp(&unk_100AA300, v8 + 24, 2u) )
        {
          if ( memcmp(&unk_100A5FA4, v8 + 24, 3u) )
          {
            strcpy(&v21, a1);
            v10 = (char *)&v20 + 3;
            do
              v11 = (v10++)[1];
            while ( v11 );
            *(_WORD *)v10 = 47;
            do
              v12 = *v9++;
            while ( v12 );
            v13 = v9 - (v8 + 24);
            v14 = (char *)&v20 + 3;
            do
              v15 = (v14++)[1];
            while ( v15 );
            qmemcpy(v14, v8 + 24, v13);
            v16 = *((_DWORD *)v8 + 5) & 0x1000 ? sub_10061420(&v21) : j_FIL_vfs_delete(&v21);
            v7 = v16;
            if ( v16 )
              break;
          }
        }
        v17 = *((_WORD *)v8 + 2);
        v8 += v17;
        v18 -= v17;
      }
      while ( v18 > 0 );
      v1 = a1;
      v6 = v20;
    }
    if ( v6 < 0xFFFFFFC2 )
    {
      if ( v6 )
        sub_10061070(v6);
    }
    if ( v7 )
      return v7;
  }
  return result;
}
// 100610D0: using guessed type int __cdecl j_FIL_vfs_delete(_DWORD);
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10061280: using guessed type int __cdecl j_FIL_vfs_rmdir(_DWORD);

//----- (10061680) --------------------------------------------------------
int sub_10061680()
{
  int result; // eax@2

  if ( sub_10062570() )
    result = j_HWM_pvg_get_anlg_outp(4);
  else
    result = j_HWM_pvg_get_anlg_outp(0);
  return result;
}
// 100615F0: using guessed type int __cdecl j_HWM_pvg_get_anlg_outp(_DWORD);

//----- (100616A0) --------------------------------------------------------
int __cdecl sub_100616A0(int a1, int a2)
{
  int v2; // esi@3

  if ( *(_DWORD *)(a1 + 8) < 0 )
    sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 127, 0, 0);
  v2 = j_mem_unmap(a2 - 12, *(_DWORD *)(a1 + 8) + 12);
  if ( v2 )
    sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 132, 1, 0);
  return v2;
}
// 10062610: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10061700) --------------------------------------------------------
signed int __cdecl sub_10061700(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@3

  v1 = **(_DWORD **)(a1 + 16);
  if ( v1 < 0xFFFFFFC2 && v1 )
  {
    if ( *(_BYTE *)(v1 - 3) || *(_BYTE *)(a1 + 4) & 8 )
    {
      if ( *(_BYTE *)(a1 + 4) & 1 )
      {
        *(_BYTE *)(v1 - 3) = 0;
        result = 1;
      }
      else
      {
        sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 474, 1, 0);
        result = 0;
      }
    }
    else
    {
      sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 465, 1, 0);
      result = 1;
    }
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 455, 1, 0);
    result = 0;
  }
  return result;
}

//----- (10061780) --------------------------------------------------------
int __usercall sub_10061780@<eax>(const char **a1@<esi>)
{
  unsigned int v1; // ebp@1
  unsigned int v2; // edi@2
  char v3; // ST28_1@2
  unsigned int v4; // eax@5
  char *v5; // edi@9
  char v6; // al@10
  unsigned int v7; // eax@12
  char v8; // ST28_1@12
  signed int v9; // ebx@15
  int v10; // eax@19
  int result; // eax@47
  unsigned int v12; // [sp+Ch] [bp-98h]@1
  int v13; // [sp+14h] [bp-90h]@29
  char v14; // [sp+1Dh] [bp-87h]@30
  char v15; // [sp+1Fh] [bp-85h]@9
  char v16; // [sp+20h] [bp-84h]@8

  v1 = 0;
  v12 = 0;
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    v2 = j_FIL_vfs_open(*a1, 4, 0);
    v3 = 4;
  }
  else
  {
    strncpy(&v16, *a1, 0x7Du);
    if ( !(*((_BYTE *)a1 + 4) & 8) )
    {
      v5 = &v15;
      do
        v6 = (v5++)[1];
      while ( v6 );
      *(_DWORD *)v5 = 7368052;
    }
    v12 = j_FIL_vfs_open(*a1, 6, 1809);
    v7 = j_FIL_vfs_open(&v16, 14, 1809);
    v2 = v7;
    v8 = 6;
    if ( v7 >= 0xFFFFFFC2 || !v7 )
    {
      sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 589, 1, 0);
      goto LABEL_39;
    }
    v9 = sub_100613E0(v7, 0, 2);
    if ( v9 < 0 )
    {
      sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 602, 1, 0);
      goto LABEL_39;
    }
    if ( (signed int)a1[2] < 0 )
      sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 610, 0, 0);
    v10 = (int)(a1[2] + 12);
    if ( v9 < v10 && sub_10061400(v2, v10, (unsigned __int64)v10 >> 32) < 0 )
    {
      sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 625, 1, 0);
      goto LABEL_39;
    }
  }
  if ( v2 >= 0xFFFFFFC2 )
    goto LABEL_42;
  if ( v2 )
  {
    v4 = ((int (__cdecl *)(unsigned int, _DWORD, const char *, _DWORD))j_FIL_vfs_mmap)(v2, 0, a1[2] + 12, 0);
    v1 = v4;
    if ( v4 < 0xFFFFFFC2 && v4 )
    {
      if ( !(*((_BYTE *)a1 + 4) & 1) )
      {
        if ( *(_BYTE *)(v4 + 9) || *(_BYTE *)(v4 + 8) != 56 )
        {
          sub_100616A0((int)a1, v4 + 12);
          v1 = 0;
        }
        goto LABEL_39;
      }
      *(_DWORD *)(v4 + 4) = sub_10060900();
      if ( *((_BYTE *)a1 + 4) & 4 )
        memset((void *)(v1 + 12), (int)a1[3], (size_t)a1[2]);
      if ( v12 < 0xFFFFFFC2 && v12 )
      {
        if ( *((_BYTE *)a1 + 4) & 8 )
        {
          ++*(_DWORD *)v1;
        }
        else if ( sub_100611A0(v12, &v13, 12) == 12 )
        {
          *(_DWORD *)v1 = ++v13;
          v14 = 1;
          *(_BYTE *)(v1 + 9) = 1;
          if ( sub_10061340(v12, (int)&v13, 12, 0) != 12 )
          {
            sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 725, 1, 0);
            goto LABEL_39;
          }
        }
      }
      else
      {
        *(_BYTE *)(v1 + 9) = 1;
        *(_DWORD *)v1 = 1;
      }
      *(_BYTE *)(v1 + 8) = 56;
      if ( !(*((_BYTE *)a1 + 4) & 8) && j_FIL_vfs_rename(&v16, *a1) )
        sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 759, 1, 0);
      goto LABEL_39;
    }
    sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 664, 0, 0);
  }
LABEL_39:
  if ( v2 < 0xFFFFFFC2 && v2 )
    sub_10061070(v2);
LABEL_42:
  if ( v12 < 0xFFFFFFC2 && v12 )
    sub_10061070(v12);
  if ( v1 < 0xFFFFFFC2 && v1 )
    result = v1 + 12;
  else
    result = v1;
  return result;
}
// 10061180: using guessed type int __cdecl j_FIL_vfs_mmap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10061190: using guessed type int __cdecl j_FIL_vfs_open(_DWORD, _DWORD, _DWORD);
// 10061270: using guessed type int __cdecl j_FIL_vfs_rename(_DWORD, _DWORD);

//----- (10061A80) --------------------------------------------------------
int __usercall sub_10061A80@<eax>(int a1@<eax>, int a2@<ecx>)
{
  return j_mem_unmap(a2 - 12, a1 + 12);
}
// 10062610: using guessed type int __cdecl j_mem_unmap(_DWORD, _DWORD);

//----- (10061AA0) --------------------------------------------------------
signed int __cdecl sub_10061AA0(int a1)
{
  unsigned int v1; // eax@1
  char v2; // bl@1
  int *v3; // edi@6
  int v4; // eax@6
  int v5; // ecx@6
  int v6; // ebp@6
  unsigned int v8; // eax@15

  v1 = **(_DWORD **)(a1 + 16);
  v2 = 0;
  if ( v1 != -858993460 && (v1 < 0xFFFFFFC2 && v1 || v1 == -15) )
  {
    if ( v1 < 0xFFFFFFC2 && v1 && !*(_BYTE *)(v1 - 3) )
      return 1;
  }
  else
  {
    sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 211, 0, *(char **)a1);
    **(_DWORD **)(a1 + 16) = -15;
  }
  v3 = *(int **)(a1 + 16);
  v4 = sub_10060C90(81, 5000);
  v5 = *v3;
  v6 = v4;
  if ( (unsigned int)*v3 < 0xFFFFFFC2 && v5 )
  {
    if ( !*(_BYTE *)(v5 - 3) )
    {
      sub_10060C60(v4, 81);
      return 1;
    }
    *v3 = -15;
    sub_10061A80(*(_DWORD *)(a1 + 8), v5);
  }
  v8 = sub_10061780((const char **)a1);
  if ( v8 < 0xFFFFFFC2 && v8 )
  {
    *v3 = v8;
    if ( !*(_BYTE *)(v8 - 3) )
      v2 = 1;
  }
  sub_10060C60(v6, 81);
  return (unsigned __int8)v2;
}

//----- (10061B70) --------------------------------------------------------
int __cdecl sub_10061B70(LONG Value)
{
  char v1; // al@1
  int result; // eax@3
  int v3; // edi@3
  unsigned __int32 v4; // eax@5
  int v5; // ebx@5

  v1 = *(_BYTE *)(Value + 4);
  if ( v1 & 2 || !(v1 & 1) )
  {
    sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 360, 1, 0);
    result = 0;
  }
  else
  {
    result = sub_10061780((const char **)Value);
    v3 = result;
    if ( (unsigned int)result < 0xFFFFFFC2 && result )
    {
      v4 = InterlockedExchange(*(volatile LONG **)(Value + 16), result);
      v5 = v4;
      if ( v4 < 0xFFFFFFC2 && v4 )
      {
        if ( *(_DWORD *)(Value + 8) < 0 )
          sub_10028BC0("..\\lib\\acl\\kernel\\mem_usr_share.c", 388, 0, 0);
        sub_10061A80(*(_DWORD *)(Value + 8), v5);
      }
      result = v3;
    }
  }
  return result;
}

//----- (10061C00) --------------------------------------------------------
__int16 sub_10061C00()
{
  int v0; // esi@1
  unsigned int v1; // eax@1

  v0 = (signed __int16)j_HWM_pvg_get_frmt_adc(1);
  v1 = (unsigned __int16)((v0 + (signed __int16)j_HWM_pvg_get_frmt_adc(0)) / 2);
  if ( v1 >= 0x2710 )
    LOWORD(v1) = 10000;
  return sub_10062590(v1);
}
// 10061600: using guessed type int __cdecl j_HWM_pvg_get_frmt_adc(_DWORD);

//----- (10061C40) --------------------------------------------------------
void __cdecl sub_10061C40(int a1, _BYTE *a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_get(a1, a2);
  SYS_exit_krnl();
  sub_10062620(a1, a2);
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 1006868C: using guessed type int __cdecl SYS_pvg_ftr_get(_DWORD, _DWORD);

//----- (10061C70) --------------------------------------------------------
int __cdecl sub_10061C70(int a1, int a2)
{
  SYS_enter_krnl();
  SYS_pvg_ftr_set(a1, a2);
  return SYS_exit_krnl();
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068692: using guessed type int __cdecl SYS_pvg_ftr_set(_DWORD, _DWORD);

//----- (10061C90) --------------------------------------------------------
int __cdecl sub_10061C90(char a1)
{
  int result; // eax@1
  int v2; // ecx@1

  result = -1;
  v2 = 0;
  while ( byte_10125AD0[8 * v2] != a1 )
  {
    if ( (unsigned int)++v2 >= 8 )
      return result;
  }
  return dword_10125AD4[2 * v2];
}
// 10125AD4: using guessed type int dword_10125AD4[];

//----- (10061CC0) --------------------------------------------------------
__int16 __cdecl sub_10061CC0(int a1, int a2, int a3, int a4)
{
  __int16 v4; // si@1

  SYS_enter_krnl();
  v4 = HWM_pvg_read_rgn(a1, a2, a3, a4);
  SYS_exit_krnl();
  return v4;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 10068698: using guessed type int __cdecl HWM_pvg_read_rgn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10061D00) --------------------------------------------------------
__int16 __cdecl sub_10061D00(int a1, _DWORD *a2, _BYTE *a3)
{
  __int16 result; // ax@1
  char v4; // [sp+8h] [bp-ECh]@1
  unsigned __int8 v5; // [sp+Ah] [bp-EAh]@1
  int v6; // [sp+10h] [bp-E4h]@1

  j_HWM_pvg_rgn_get_info(a1, &v4);
  result = v5;
  *a2 = v6;
  *a3 = 2;
  return result;
}
// 10061CF0: using guessed type int __cdecl j_HWM_pvg_rgn_get_info(_DWORD, _DWORD);

//----- (10061D60) --------------------------------------------------------
int __cdecl sub_10061D60(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1002C660(v1);
  a1 = v2;
  v3 = sub_1002CC90(&a1, 4u, (int)&unk_101267C8, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_101267CC[2 * v3];
}
// 101267CC: using guessed type int dword_101267CC[];

//----- (10061DA0) --------------------------------------------------------
int __cdecl sub_10061DA0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1002C660(v1);
  a1 = v2;
  v3 = sub_1002CC90(&a1, 4u, (int)&unk_10126800, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_10126804[2 * v3];
}
// 10126804: using guessed type int dword_10126804[];

//----- (10061DE0) --------------------------------------------------------
int __cdecl sub_10061DE0(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1002C660(v1);
  a1 = v2;
  v3 = sub_1002CC90(&a1, 4u, (int)&unk_10126838, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_1012683C[2 * v3];
}
// 1012683C: using guessed type int dword_1012683C[];

//----- (10061E20) --------------------------------------------------------
int __cdecl sub_10061E20(int a1)
{
  void *v1; // ecx@0
  int v2; // eax@1
  int v3; // eax@3

  v2 = a1;
  if ( !a1 )
    v2 = sub_1002C660(v1);
  a1 = v2;
  v3 = sub_1002CC90(&a1, 4u, (int)&unk_10126870, 8, 7, -1);
  if ( v3 == -1 )
    v3 = 0;
  return dword_10126874[2 * v3];
}
// 10126874: using guessed type int dword_10126874[];

//----- (10061E60) --------------------------------------------------------
int __cdecl sub_10061E60(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  int v6; // eax@8

  result = 0;
  if ( a1 )
  {
    v5 = sub_10061DA0(a4);
    result = sub_10060D80(v5, a1, 104);
  }
  if ( a2 && !result )
    result = sub_10060D80(3532, a2, 2);
  if ( a3 )
  {
    if ( !result )
    {
      v6 = sub_10061D60(a4);
      result = sub_10060D80(v6, a3, 6);
    }
  }
  return result;
}

//----- (10061ED0) --------------------------------------------------------
int __cdecl sub_10061ED0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  int v5; // eax@3
  int v6; // eax@6
  int v7; // eax@7

  result = 0;
  if ( a1 )
  {
    v4 = sub_10061E20(a3);
    result = sub_10060D80(v4, a1, 64);
    if ( result == -7 )
    {
      sub_10060B90(100);
      v5 = sub_10061E20(a3);
      result = sub_10060D80(v5, a1, 64);
    }
  }
  if ( a2 && !result )
  {
    v6 = sub_10061DE0(a3);
    result = sub_10060D80(v6, a2, 8);
    if ( result == -7 )
    {
      sub_10060B90(100);
      v7 = sub_10061DE0(a3);
      result = sub_10060D80(v7, a2, 8);
    }
  }
  return result;
}

//----- (10061FB0) --------------------------------------------------------
int __cdecl sub_10061FB0(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_recv_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 100686BC: using guessed type int __cdecl IOP_pvg_sk_recv_swi(_DWORD, _DWORD);

//----- (10062000) --------------------------------------------------------
int __cdecl sub_10062000(int a1, int a2, int a3, __int16 a4, int a5)
{
  int v5; // esi@1
  int v7; // [sp+4h] [bp-10h]@1
  int v8; // [sp+8h] [bp-Ch]@1
  __int16 v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  SYS_enter_krnl();
  v5 = IOP_pvg_sk_send_swi(a1, &v7);
  SYS_exit_krnl();
  return v5;
}
// 1006850C: using guessed type int SYS_exit_krnl(void);
// 10068518: using guessed type int SYS_enter_krnl(void);
// 100686C2: using guessed type int __cdecl IOP_pvg_sk_send_swi(_DWORD, _DWORD);

//----- (10062080) --------------------------------------------------------
unsigned int __cdecl sub_10062080(int a1, int a2, unsigned int a3, char a4, unsigned __int16 a5, int a6)
{
  size_t v6; // ebp@1
  int *v7; // esi@1
  size_t v8; // ebx@1
  int v9; // edx@1
  unsigned int v10; // edi@1
  int v11; // ebx@2
  int v12; // edx@3
  int *v13; // ebp@3
  int v14; // eax@3
  int v15; // eax@3
  unsigned int result; // eax@4
  void **v17; // [sp+10h] [bp-Ch]@1
  void **v18; // [sp+20h] [bp+4h]@1

  v6 = 8 * a5;
  v7 = &dword_109FF0F8[a1];
  v8 = 32 * (a3 / (1 << a4));
  v9 = a2 - v8 - v6;
  *v7 = v9 + a3 - 52;
  v17 = (void **)&dword_109FF0B0[a1];
  dword_109FF0B0[a1] = a3 + v9;
  dword_109FF070[a1] = a3 + a2 - v8;
  v18 = (void **)&dword_109FF070[a1];
  memset((void *)(v9 + a3 - 52), 0, 0x34u);
  memset(*v17, 0, v6);
  memset(*v18, 0, v8);
  *(_DWORD *)(*v7 + 24) = 1 << a4;
  *(_DWORD *)(*v7 + 28) = ~(*(_DWORD *)(*v7 + 24) - 1);
  *(_BYTE *)(*v7 + 32) = a4;
  *(_DWORD *)(*v7 + 12) = a2;
  *(_DWORD *)(*v7 + 16) = a3;
  *(_DWORD *)(*v7 + 8) = a3 / (1 << a4) - (v8 + v6 + 52) / (1 << a4) - 1;
  *(_DWORD *)(*v7 + 4) = a6;
  *(_WORD *)(*v7 + 20) = a5;
  *(_DWORD *)*v7 = -1;
  *(_DWORD *)(*v7 + 36) = *v7 + 36;
  *(_DWORD *)(*v7 + 40) = *v7 + 36;
  *(_DWORD *)(*v7 + 44) = *v7 + 44;
  *(_DWORD *)(*v7 + 48) = *v7 + 44;
  v10 = 0;
  if ( *(_DWORD *)(*v7 + 8) )
  {
    v11 = 0;
    do
    {
      v12 = *v7;
      v13 = *(int **)(*v7 + 40);
      v14 = (int)*v18 + v11;
      *(_DWORD *)(v12 + 40) = v14;
      *(_DWORD *)v14 = v12 + 36;
      *(_DWORD *)(v14 + 4) = v13;
      *v13 = v14;
      v15 = a2 + v10++ * *(_DWORD *)(*v7 + 24);
      *(_DWORD *)((char *)*v18 + v11 + 28) = v15;
      v11 += 32;
    }
    while ( v10 < *(_DWORD *)(*v7 + 8) );
  }
  result = 0;
  if ( *(_WORD *)(*v7 + 20) )
  {
    do
    {
      *((_DWORD *)*v17 + 2 * result) = (char *)*v17 + 8 * result;
      *((_DWORD *)*v17 + 2 * result + 1) = (char *)*v17 + 8 * result;
      ++result;
    }
    while ( result < *(_WORD *)(*v7 + 20) );
  }
  return result;
}
// 109FF0B0: using guessed type int dword_109FF0B0[];
// 109FF0F8: using guessed type int dword_109FF0F8[];

//----- (10062230) --------------------------------------------------------
int __usercall sub_10062230@<eax>(int a1@<esi>)
{
  int v1; // eax@1
  int *v2; // ecx@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  _DWORD *v6; // edx@3
  int v7; // ecx@3
  _DWORD *v8; // edx@3
  int v9; // ecx@3
  int v10; // edx@3

  v1 = dword_109FF0F8[a1];
  v2 = (int *)(v1 + 36);
  if ( (int *)*v2 == v2 )
  {
    v4 = *(_DWORD *)(v1 + 44);
    v5 = *(_DWORD *)(v4 - 8);
    v6 = *(_DWORD **)(v4 - 4);
    result = v4 - 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v7 = *(_DWORD *)(result + 8);
    v8 = *(_DWORD **)(result + 12);
    *(_DWORD *)(v7 + 4) = v8;
    *v8 = v7;
    v9 = dword_109FF0F8[a1];
    v10 = *(_DWORD *)(v9 + 36);
    v9 += 36;
    *(_DWORD *)(v10 + 4) = result;
    *(_DWORD *)result = v10;
    *(_DWORD *)(result + 4) = v9;
    *(_DWORD *)v9 = result;
  }
  else
  {
    result = *v2;
  }
  return result;
}
// 109FF0F8: using guessed type int dword_109FF0F8[];

//----- (100622E0) --------------------------------------------------------
int __cdecl sub_100622E0(int a1, unsigned __int64 a2)
{
  int v2; // edi@1
  int *v3; // ebx@1
  signed int v4; // eax@1
  _DWORD *v5; // ecx@2
  int v6; // eax@2
  int *v7; // eax@2
  int v8; // ecx@2
  _DWORD *v9; // edx@2
  int v10; // eax@2
  int v11; // ecx@2
  int result; // eax@2

  v2 = sub_10062230(a1);
  v3 = &dword_109FF0F8[a1];
  v4 = sub_100611F0(
         *(_DWORD *)dword_109FF0F8[a1] & 0xFFFFFFFC,
         *(void **)(v2 + 28),
         *(_DWORD *)(dword_109FF0F8[a1] + 24),
         a2,
         SHIDWORD(a2));
  if ( v4 <= 0 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD **)(v2 + 4);
    *(_WORD *)(v2 + 24) = v4;
    v6 = *(_DWORD *)v2;
    *(_QWORD *)(v2 + 16) = a2;
    *(_DWORD *)(v6 + 4) = v5;
    *v5 = v6;
    v7 = (int *)(dword_109FF0B0[a1] + 8 * ((unsigned int)(a2 >> *(_BYTE *)(*v3 + 32)) % *(_WORD *)(*v3 + 20)));
    v8 = *v7;
    *(_DWORD *)(v8 + 4) = v2;
    *(_DWORD *)(v2 + 4) = v7;
    *(_DWORD *)v2 = v8;
    *v7 = v2;
    v9 = *(_DWORD **)(*v3 + 48);
    v10 = *v3 + 44;
    v11 = v2 + 8;
    *(_DWORD *)(v10 + 4) = v2 + 8;
    *(_DWORD *)v11 = v10;
    result = v2;
    *(_DWORD *)(v11 + 4) = v9;
    *v9 = v2 + 8;
  }
  return result;
}
// 109FF0B0: using guessed type int dword_109FF0B0[];
// 109FF0F8: using guessed type int dword_109FF0F8[];

//----- (10062390) --------------------------------------------------------
int __usercall sub_10062390@<eax>(int a1@<ebx>, unsigned __int64 a2)
{
  int *v2; // edi@1
  int *v3; // ecx@1
  int result; // eax@1
  int v5; // edx@5
  _DWORD *v6; // esi@5
  int v7; // ecx@5
  _DWORD *v8; // esi@5
  int v9; // edx@5

  v2 = &dword_109FF0F8[a1];
  v3 = (int *)(dword_109FF0B0[a1]
             + 8 * ((unsigned int)(a2 >> *(_BYTE *)(dword_109FF0F8[a1] + 32)) % *(_WORD *)(dword_109FF0F8[a1] + 20)));
  result = *v3;
  if ( (int *)*v3 == v3 )
  {
LABEL_4:
    result = sub_100622E0(a1, a2);
  }
  else
  {
    while ( *(_QWORD *)(result + 16) != a2 )
    {
      result = *(_DWORD *)result;
      if ( (int *)result == v3 )
        goto LABEL_4;
    }
    v5 = *(_DWORD *)(result + 8);
    v6 = *(_DWORD **)(result + 12);
    v7 = result + 8;
    *(_DWORD *)(v5 + 4) = v6;
    *v6 = v5;
    v8 = *(_DWORD **)(*v2 + 48);
    v9 = *v2 + 44;
    *(_DWORD *)(v9 + 4) = result + 8;
    *(_DWORD *)(v7 + 4) = v8;
    *(_DWORD *)v7 = v9;
    *v8 = result + 8;
  }
  return result;
}
// 109FF0B0: using guessed type int dword_109FF0B0[];
// 109FF0F8: using guessed type int dword_109FF0F8[];

//----- (10062420) --------------------------------------------------------
unsigned int __cdecl sub_10062420(int a1, void *a2, int a3, int a4, int a5)
{
  unsigned int v5; // ebp@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // edx@2
  unsigned int result; // eax@4
  int v10; // eax@7
  int v11; // esi@10
  int v12; // eax@10
  int v13; // ecx@11
  unsigned int v14; // eax@11
  const void *v15; // ecx@11
  size_t v16; // esi@12
  int v17; // ecx@13
  int v18; // et0@17

  v5 = a3;
  v6 = 0;
  v7 = a4;
  if ( !dword_109FF0F0 )
    goto LABEL_24;
  while ( 1 )
  {
    v8 = dword_109FF0F8[v6];
    if ( *(_DWORD *)v8 == a1 )
      break;
    if ( ++v6 >= (unsigned int)dword_109FF0F0 )
      return -1;
  }
  if ( v6 != -1 )
  {
    v10 = *(_DWORD *)(v8 + 4);
    if ( v10 != 138 )
      sub_10060A60(v10, -1);
    if ( a3 )
    {
      while ( 1 )
      {
        v11 = v7 & ~*(_DWORD *)(dword_109FF0F8[v6] + 28);
        v12 = sub_10062390(v6, (unsigned int)v7 & *(_DWORD *)(dword_109FF0F8[v6] + 28));
        if ( !v12 )
          break;
        v13 = *(_DWORD *)(v12 + 28);
        v14 = *(_WORD *)(v12 + 24) - v11;
        v15 = (const void *)(v11 + v13);
        if ( v5 <= v14 )
        {
          v16 = v5;
        }
        else
        {
          v16 = v14;
          if ( !v14 )
            goto LABEL_13;
        }
        memcpy(a2, v15, v16);
        v5 -= v16;
        v18 = (v16 + __PAIR__((unsigned int)a5, v7)) >> 32;
        v7 += v16;
        a5 = v18;
        a2 = (char *)a2 + v16;
        if ( !v5 )
          goto LABEL_13;
      }
      if ( *(_DWORD *)(dword_109FF0F8[v6] + 4) != 138 )
        sub_10060A00(*(_DWORD *)(dword_109FF0F8[v6] + 4));
      result = -1;
    }
    else
    {
LABEL_13:
      v17 = dword_109FF0F8[v6];
      if ( *(_DWORD *)(v17 + 4) != 138 )
        sub_10060A00(*(_DWORD *)(v17 + 4));
      result = a3 - v5;
    }
  }
  else
  {
LABEL_24:
    result = -1;
  }
  return result;
}
// 109FF0F0: using guessed type int dword_109FF0F0;
// 109FF0F8: using guessed type int dword_109FF0F8[];

//----- (10062570) --------------------------------------------------------
bool sub_10062570()
{
  unsigned int v0; // eax@1

  v0 = j_HWM_pvg_read_reg(0);
  return v0 >= 0x17 && (v0 <= 0x18 || v0 == 40);
}
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);

//----- (10062590) --------------------------------------------------------
__int16 __cdecl sub_10062590(unsigned __int16 a1)
{
  int v1; // eax@1
  signed int v2; // eax@3
  unsigned int v3; // ecx@3
  int v4; // eax@6

  v1 = j_HWM_pvg_read_reg(0);
  if ( v1 != 33 && v1 != 49 )
  {
    LOWORD(v4) = a1;
  }
  else
  {
    v2 = 1;
    v3 = 6;
    do
    {
      if ( a1 <= (unsigned __int16)word_10128AC8[v3] )
        break;
      v3 += 6;
      ++v2;
    }
    while ( v3 < 54 );
    v4 = (dword_10128AD0[3 * (v2 - 1)] + dword_10128ACC[3 * (v2 - 1)] * a1) / 0x2000;
    if ( v4 > 0 )
    {
      if ( (unsigned int)v4 >= 0x2710 )
        LOWORD(v4) = 10000;
    }
    else
    {
      LOWORD(v4) = 0;
    }
  }
  return v4;
}
// 10061670: using guessed type int __cdecl j_HWM_pvg_read_reg(_DWORD);
// 10128AC8: using guessed type __int16 word_10128AC8[];
// 10128ACC: using guessed type int dword_10128ACC[];
// 10128AD0: using guessed type int dword_10128AD0[];

//----- (10062620) --------------------------------------------------------
void __cdecl sub_10062620(__int16 a1, _BYTE *a2)
{
  void *v2; // ecx@0
  void *v3; // ecx@2

  if ( a1 == 29 && sub_1002C5A0(v2) && sub_1002C600(v3) != 1 )
    *a2 = 0;
}

//----- (10062650) --------------------------------------------------------
double __cdecl sub_10062650(char a1)
{
  double v1; // st7@5
  double result; // st7@9
  float v3; // [sp+0h] [bp-4h]@1

  v3 = 0.0;
  if ( !sub_1002BA70() )
    goto LABEL_13;
  if ( !a1 )
  {
    v1 = *(float *)(dword_10A09ABC + 124);
    goto LABEL_8;
  }
  if ( a1 == 2 )
  {
    v1 = *(float *)(dword_10A09ABC + 860);
    goto LABEL_8;
  }
  if ( a1 == 3 )
  {
    v1 = *(float *)(dword_10A09ABC + 1204);
LABEL_8:
    v3 = v1;
  }
  result = v3;
  if ( (LODWORD(v3) & 0x7F800000) == 2139095040 || result > 3.141592502593994 || result < -3.141592502593994 )
  {
    v3 = 0.0;
LABEL_13:
    result = v3;
  }
  return result;
}
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (100626E0) --------------------------------------------------------
signed int __cdecl sub_100626E0(char a1)
{
  return (signed int)(sub_10062650(a1) * 683565248.0);
}

//----- (10062700) --------------------------------------------------------
signed int sub_10062700()
{
  signed int result; // eax@2

  if ( sub_1002BA70() )
    result = *(_DWORD *)(dword_10A09ABC + 840);
  else
    result = 0x3FFFF;
  return result;
}
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (10062720) --------------------------------------------------------
char __cdecl sub_10062720(char a1)
{
  char v1; // bl@1
  unsigned __int8 v2; // al@2
  char v3; // al@3

  v1 = 0;
  if ( sub_1002BA70() )
  {
    sub_100422A0();
    v2 = *(_BYTE *)(dword_10A09ABC + 812);
    if ( v2 != -1 )
    {
      v3 = *(_BYTE *)(180 * v2 + dword_10A09AB0 + 671);
      if ( (v3 == 18 || v3 == 19 || v3 == 20 || v3 == 21 || v3 == 22) && (!a1 || v3 == 21) )
        v1 = 1;
    }
    sub_10042290();
  }
  return v1;
}
// 10A09AB0: using guessed type int dword_10A09AB0;
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (10062790) --------------------------------------------------------
char __cdecl sub_10062790(char a1, char a2, float *a3)
{
  char v3; // bl@1
  int v4; // edi@3
  int *v5; // eax@3
  double v6; // st7@7
  char v8; // [sp+Fh] [bp-31h]@1
  float v9; // [sp+10h] [bp-30h]@3
  float v10; // [sp+10h] [bp-30h]@11
  char v11; // [sp+18h] [bp-28h]@2
  char v12; // [sp+26h] [bp-1Ah]@2

  *a3 = 0.0;
  v3 = 0;
  v8 = sub_10062720(0);
  if ( !sub_1002BA70() )
    return v3;
  sub_10062A20((int)&v11);
  if ( v12 )
    return v3;
  sub_100422A0();
  v9 = 0.0;
  v4 = *(_DWORD *)(dword_10A09ABC + 296);
  v5 = (int *)(dword_10A09ABC + 296);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      if ( a1 == 2 )
      {
        *a3 = *(float *)(dword_10A09ABC + 560) - *(float *)(dword_10A09ABC + 720);
        v3 = *(_BYTE *)(dword_10A09ABC + 673);
      }
      goto LABEL_11;
    }
    *a3 = *(float *)(dword_10A09ABC + 312);
    v6 = *(float *)(dword_10A09ABC + 328);
    goto LABEL_10;
  }
  if ( !v8 )
  {
    *a3 = *(float *)(dword_10A09ABC + 308);
    v6 = *(float *)(dword_10A09ABC + 324);
LABEL_10:
    v4 = *v5;
    v9 = v6;
    v3 = 1;
  }
LABEL_11:
  sub_10042290();
  v10 = sub_10042280(v4) * v9 + *a3;
  *a3 = v10;
  if ( a1 != 2 )
    *a3 = v10 - sub_10062650(a2);
  *a3 = sub_100680D0(*a3);
  return v3;
}
// 10042280: using guessed type double __cdecl sub_10042280(_DWORD);
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (100628D0) --------------------------------------------------------
char __cdecl sub_100628D0(char a1, float *a2)
{
  char v2; // bl@1
  double v3; // st7@7
  char result; // al@13
  float v5; // [sp+8h] [bp-2Ch]@1
  char v6; // [sp+Ch] [bp-28h]@2
  char v7; // [sp+1Ah] [bp-1Ah]@2

  *a2 = 0.0;
  v2 = 0;
  v5 = 0.0;
  if ( !sub_1002BA70() )
    return v2;
  sub_10062A20((int)&v6);
  if ( v7 || sub_10062720(1) )
    return v2;
  sub_100422A0();
  if ( a1 )
  {
    if ( a1 == 1 )
    {
      *a2 = *(float *)(dword_10A09ABC + 316);
      v3 = *(float *)(dword_10A09ABC + 332);
    }
    else
    {
      if ( a1 != 2 )
        goto LABEL_11;
      *a2 = *(float *)(dword_10A09ABC + 340);
      v3 = *(float *)(dword_10A09ABC + 336);
    }
  }
  else
  {
    *a2 = *(float *)(dword_10A09ABC + 304);
    v3 = *(float *)(dword_10A09ABC + 320);
  }
  v5 = v3;
  v2 = 1;
LABEL_11:
  *a2 = sub_10042280(*(_DWORD *)(dword_10A09ABC + 296)) * v5 + *a2;
  sub_10042290();
  if ( a1 == 1 )
  {
    *(_DWORD *)a2 = COERCE_UNSIGNED_INT(*a2) & 0x7FFFFFFF;
    return v2;
  }
  if ( a1 || !*(_BYTE *)(dword_10A09ABC + 288) )
    return v2;
  result = v2;
  if ( (*(_DWORD *)a2 >> 31) & 1 )
    *a2 = 0.0;
  return result;
}
// 10042280: using guessed type double __cdecl sub_10042280(_DWORD);
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (10062A20) --------------------------------------------------------
char __cdecl sub_10062A20(int a1)
{
  char result; // al@1
  int v2; // ecx@2
  char v3; // al@4
  unsigned __int8 v4; // al@16

  *(_DWORD *)(a1 + 16) = 0x3FFFF;
  *(_BYTE *)a1 = -1;
  *(_DWORD *)(a1 + 20) = 0x3FFFF;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_BYTE *)(a1 + 2) = 1;
  *(_BYTE *)(a1 + 3) = 1;
  *(_BYTE *)(a1 + 4) = 6;
  *(_BYTE *)(a1 + 5) = -1;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = -1;
  *(_BYTE *)(a1 + 9) = 0;
  *(_BYTE *)(a1 + 13) = 0;
  *(_BYTE *)(a1 + 10) = -1;
  *(_BYTE *)(a1 + 11) = 0;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = 0;
  *(_BYTE *)(a1 + 14) = 1;
  *(_BYTE *)(a1 + 15) = 0;
  result = sub_1002BA70();
  if ( result )
  {
    sub_100422A0();
    *(_BYTE *)(a1 + 8) = *(_BYTE *)(dword_10A09ABC + 815);
    *(_BYTE *)(a1 + 4) = *(_BYTE *)(dword_10A09ABC + 94);
    *(_BYTE *)(a1 + 11) = *(_BYTE *)(dword_10A09ABC + 97);
    *(_BYTE *)(a1 + 1) = *(_BYTE *)(dword_10A09AB0 + 239);
    *(_BYTE *)(a1 + 15) = *(_BYTE *)(dword_10A09ABC + 826);
    strncpy((char *)(a1 + 24), (const char *)(dword_10A09ABC + 872), 0xCu);
    *(_BYTE *)(a1 + 35) = 0;
    *(_BYTE *)(a1 + 6) = *(_BYTE *)(dword_10A09ABC + 784);
    *(_BYTE *)(a1 + 14) = 0;
    v2 = dword_10A09ABC;
    if ( *(_BYTE *)(dword_10A09ABC + 669) && !*(_BYTE *)(dword_10A09ABC + 667)
      || (v3 = *(_BYTE *)(dword_10A09ABC + 159)) != 0
      && *(_BYTE *)(dword_10A09ABC + 667)
      && !*(_BYTE *)(dword_10A09ABC + 661)
      && (v3 != 2 || -1.0 == *(float *)(dword_10A09ABC + 116))
      || !*(_BYTE *)(dword_10A09ABC + 672) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_10A09ABC;
    }
    else if ( *(_BYTE *)(dword_10A09ABC + 101) == 4
           && *(_BYTE *)(dword_10A09ABC + 812) >= *(_BYTE *)(dword_10A09AB0 + 241)
           && !*(_BYTE *)(dword_10A09ABC + 89)
           && -1.0 == *(float *)(dword_10A09ABC + 116) )
    {
      *(_BYTE *)(a1 + 14) = 1;
      v2 = dword_10A09ABC;
    }
    *(_BYTE *)(a1 + 9) = *(_BYTE *)(v2 + 816);
    *(_BYTE *)(a1 + 5) = *(_BYTE *)(dword_10A09AB0 + 241);
    v4 = *(_BYTE *)(a1 + 9) - 1;
    *(_BYTE *)(a1 + 10) = *(_BYTE *)(dword_10A09AB0 + 244);
    if ( v4 > 2u )
    {
      *(_BYTE *)(a1 + 9) = 0;
      *(_DWORD *)(a1 + 16) = 0x3FFFF;
      *(_DWORD *)(a1 + 20) = 0x3FFFF;
      *(_BYTE *)(a1 + 12) = 0;
      *(_BYTE *)a1 = -1;
      *(_BYTE *)(a1 + 2) = 1;
      *(_BYTE *)(a1 + 3) = 1;
      *(_BYTE *)(a1 + 7) = -1;
      *(_BYTE *)(a1 + 14) = 1;
      result = sub_10042290();
    }
    else
    {
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(dword_10A09ABC + 836);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(dword_10A09ABC + 840);
      *(_BYTE *)a1 = *(_BYTE *)(dword_10A09ABC + 812);
      *(_BYTE *)(a1 + 13) = *(_BYTE *)(dword_10A09ABC + 825);
      if ( *(_DWORD *)(dword_10A09ABC + 892) )
        *(_BYTE *)(a1 + 3) = 0;
      else
        *(_BYTE *)(a1 + 3) = *(_BYTE *)(dword_10A09ABC + 288);
      *(_BYTE *)(a1 + 2) = *(_BYTE *)(dword_10A09ABC + 288);
      *(_BYTE *)(a1 + 7) = *(_BYTE *)(dword_10A09ABC + 813);
      *(_BYTE *)(a1 + 12) = *(_BYTE *)(dword_10A09AB0 + 4);
      result = sub_10042290();
    }
  }
  return result;
}
// 10A09AB0: using guessed type int dword_10A09AB0;
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (10062C70) --------------------------------------------------------
char sub_10062C70()
{
  unsigned __int8 v0; // cl@2
  signed int v1; // eax@4

  if ( !sub_1002BA70() )
  {
    LOBYTE(v1) = 0;
    return v1;
  }
  v0 = *(_BYTE *)(dword_10A09ABC + 1200);
  if ( v0 || (v0 = *(_BYTE *)(dword_10A09ABC + 814)) != 0 )
  {
    LOBYTE(v1) = v0;
    if ( v0 < 4u )
      return v1;
    v1 = 4;
  }
  else
  {
    v1 = *(_BYTE *)(dword_10A09ABC + 122) == 0;
  }
  if ( v1 == 4 )
    LOBYTE(v1) = 0;
  return v1;
}
// 10A09ABC: using guessed type int dword_10A09ABC;

//----- (10062CC0) --------------------------------------------------------
void __cdecl sub_10062CC0(float *a1, float *a2, float *a3, int a4)
{
  float v4; // [sp+0h] [bp-4h]@1

  sub_100634A0(a1, a2, a4);
  v4 = sqrt(sub_10063560(a4, a4));
  *a3 = v4;
  if ( v4 >= 0.1000000014901161 )
  {
    *(float *)a4 = *(float *)a4 / v4;
    *(float *)(a4 + 4) = *(float *)(a4 + 4) / *a3;
  }
  else
  {
    *(float *)(a4 + 4) = 1.0;
    *(float *)a4 = 0.0;
  }
}

//----- (10062D20) --------------------------------------------------------
int __cdecl sub_10062D20(float a1, float a2, int a3)
{
  float v3; // ST00_4@1
  float v4; // ST04_4@1
  float v5; // ST00_4@1
  float v6; // ST04_4@1
  double v7; // ST08_8@1
  float v8; // ST04_4@1
  float v9; // ST00_4@1
  float v10; // ST04_4@1
  float v11; // ST04_4@1
  double v12; // ST08_8@1
  float v13; // ST04_4@1
  float v14; // ST00_4@1
  float v15; // ST04_4@1
  float v16; // ST04_4@1
  double v17; // ST08_8@1
  float v18; // ST04_4@1
  float v19; // ST00_4@1
  float v20; // ST04_4@1
  float v21; // ST04_4@1
  double v22; // ST08_8@1
  float v23; // ST04_4@1
  float v24; // ST00_4@1
  float v25; // ST04_4@1
  int result; // eax@1
  float v27; // ST04_4@1
  float v28; // ST04_4@1
  float v29; // [sp+18h] [bp+8h]@1
  float v30; // [sp+18h] [bp+8h]@1

  v3 = sin(a2 * 4.0);
  v4 = v3;
  v5 = sin(a1 * 4.0);
  v6 = v4 - v5;
  v7 = v6 * 0.00001062759019987425 * 0.25;
  v8 = sin(a2 + a2);
  v9 = v8;
  v10 = sin(a1 + a1);
  v11 = v9 - v10;
  v12 = v7 - v11 * 0.00506310909986496 * 0.5;
  v13 = sin(a2 * 6.0);
  v14 = v13;
  v15 = sin(a1 * 6.0);
  v16 = v14 - v15;
  v17 = v12 - v16 * 0.00000002082037831030448 / 6.0;
  v18 = sin(a2 * 8.0);
  v19 = v18;
  v20 = sin(a1 * 8.0);
  v21 = v19 - v20;
  v22 = v21 * 3.932370748471747e-11 * 0.125 + v17;
  v23 = sin(a2 * 10.0);
  v24 = v23;
  v25 = sin(a1 * 10.0);
  result = a3;
  v27 = v24 - v25;
  v28 = v22 - v27 * 7.108452959288594e-14 / 10.0;
  v29 = a2 - a1;
  v30 = v29 * 1.005052447319031;
  *(float *)a3 = fabs((v28 + v30) * 6335439.327292892);
  return result;
}

//----- (10062EE0) --------------------------------------------------------
void __cdecl sub_10062EE0(int a1, int a2, float *a3, float *a4, float *a5)
{
  float v5; // ST38_4@1
  float v6; // ST38_4@1
  long double v7; // ST38_8@5
  long double v8; // ST48_8@5
  long double v9; // st7@5
  signed int v10; // ebx@5
  long double v11; // st5@5
  long double v12; // st7@5
  long double v13; // st7@6
  double v14; // st7@6
  double v15; // st4@6
  double v16; // st3@6
  double v17; // st2@8
  double v18; // STB8_8@8
  double v19; // ST60_8@10
  double v20; // ST50_8@10
  long double v21; // st7@10
  long double v22; // st7@10
  double v23; // [sp+40h] [bp-90h]@6
  double v24; // [sp+48h] [bp-88h]@6
  double v25; // [sp+50h] [bp-80h]@5
  double v26; // [sp+58h] [bp-78h]@5
  double v27; // [sp+60h] [bp-70h]@5
  double v28; // [sp+68h] [bp-68h]@6
  double v29; // [sp+70h] [bp-60h]@6
  double v30; // [sp+78h] [bp-58h]@5
  double v31; // [sp+80h] [bp-50h]@6
  double v32; // [sp+88h] [bp-48h]@6
  double v33; // [sp+90h] [bp-40h]@5
  double v34; // [sp+98h] [bp-38h]@5
  double v35; // [sp+A0h] [bp-30h]@8
  double v36; // [sp+A8h] [bp-28h]@6
  double v37; // [sp+B0h] [bp-20h]@5
  double v38; // [sp+C0h] [bp-10h]@5

  v5 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
  v6 = fabs(sub_100680D0(v5));
  if ( v6 >= 0.000001 )
  {
    v7 = sin(*(float *)a1) * 0.9966471893352525 / cos(*(float *)a1);
    v8 = sin(*(float *)a2) * 0.9966471893352525 / cos(*(float *)a2);
    v33 = 1.0 / sqrt(v7 * v7 + 1.0);
    v9 = 1.0 / sqrt(v8 * v8 + 1.0);
    v10 = 0;
    v37 = v9;
    v34 = v33 * v9;
    v25 = v34 * v8;
    v27 = v25 * v7;
    v26 = *(float *)(a2 + 4) - *(float *)(a1 + 4);
    v11 = v9;
    v12 = v26;
    v30 = v11 * (v33 * v7);
    v38 = v27 + v27;
    do
    {
      v29 = sin(v12);
      v13 = cos(v26);
      v32 = v13;
      v24 = v25 - v13 * v30;
      v36 = sqrt(v29 * v37 * (v29 * v37) + v24 * v24);
      v28 = v13 * v34 + v27;
      v23 = sub_10068260(v36, v28);
      v14 = v29 * v34 / v36;
      v15 = 1.0 - v14 * v14;
      v16 = v38;
      v31 = v38;
      if ( v15 > 0.0 )
      {
        v16 = v28 - v38 / v15;
        v31 = v16;
      }
      ++v10;
      v35 = v16 * v16 + v16 * v16 - 1.0;
      v17 = v15 * ((4.0 - v15 * 3.0) * 0.00335281066474748 + 4.0) * 0.00335281066474748 * 0.0625;
      v18 = v26;
      v12 = 0.00335281066474748 * ((1.0 - v17) * (v14 * (v36 * (v16 + v35 * v28 * v17) * v17 + v23)))
          + *(float *)(a2 + 4)
          - *(float *)(a1 + 4);
      v26 = v12;
    }
    while ( fabs(v18 - v12) > 0.00000005 && v10 < 20 );
    v19 = sub_10068260(v29 * v37, v24);
    v20 = sub_10068260(v29 * v33, v32 * v25 - v30);
    v21 = sqrt(v15 * 0.006739496742276252 + 1.0);
    v22 = (v21 + 1.0 - 2.0) / (v21 + 1.0);
    *a3 = (0.25 * (v22 * v22) + 1.0)
        / (1.0 - v22)
        * ((v22 * 0.375 * v22 - 1.0)
         * v22
         * (v36
          * (v31
           + ((1.0 - v35 - v35) * (v36 * v36 * 4.0 - 3.0) * v31 * ((v22 * 0.375 * v22 - 1.0) * v22) / 6.0 - v35 * v28)
           * ((v22 * 0.375 * v22 - 1.0)
            * v22)
           * 0.25))
         + v23)
        * 6378137.0
        * 0.9966471893352525;
    *a4 = v19;
    *a5 = v20;
  }
  else
  {
    sub_10062D20(*(float *)a1, *(float *)a2, (int)a3);
    if ( *(float *)a1 >= (double)*(float *)a2 )
    {
      *a4 = 3.1415925;
      *a5 = 3.1415925;
    }
    else
    {
      *a4 = 0.0;
      *a5 = 0.0;
    }
  }
}

//----- (100632B0) --------------------------------------------------------
void __cdecl sub_100632B0(int a1, int a2, float *a3, float *a4)
{
  float v4; // ST14_4@1
  float v5; // ST14_4@1
  float v6; // [sp+Ch] [bp-1Ch]@1
  float v7; // [sp+10h] [bp-18h]@1
  float v8; // [sp+14h] [bp-14h]@1
  float v9; // [sp+18h] [bp-10h]@1
  float v10; // [sp+1Ch] [bp-Ch]@1
  float v11; // [sp+20h] [bp-8h]@3
  float v12; // [sp+24h] [bp-4h]@3

  sub_10068110(a1, (int)&v9);
  sub_10068110(a2, (int)&v7);
  v4 = v10 - v8;
  v6 = sub_100680D0(v4);
  v5 = v9 - v7;
  if ( COERCE_FLOAT(LODWORD(v5) & 0x7FFFFFFF) >= 0.0014486233 || COERCE_FLOAT(LODWORD(v6) & 0x7FFFFFFF) >= 0.0014486233 )
  {
    sub_10062EE0((int)&v9, (int)&v7, a3, a4, &v6);
  }
  else
  {
    sub_10062CC0(&v9, &v7, a3, (int)&v11);
    *a4 = sub_100682D0(v11, v12);
  }
}

//----- (10063390) --------------------------------------------------------
int __cdecl sub_10063390(int a1, float a2, float *a3, int a4, float *a5)
{
  float *v5; // esi@1
  float *v6; // edi@1
  int v7; // ebx@3
  int result; // eax@3

  v5 = (float *)a1;
  v6 = (float *)LODWORD(a2);
  *(float *)&a1 = *(float *)(a1 + 4) - *(float *)(LODWORD(a2) + 4);
  a2 = sub_100680D0(*(float *)&a1);
  *(float *)&a1 = *v5 - *v6;
  a1 &= 0x7FFFFFFFu;
  if ( *(float *)&a1 >= 0.0014486233
    || (a1 = LODWORD(a2) & 0x7FFFFFFF, COERCE_FLOAT(LODWORD(a2) & 0x7FFFFFFF) >= 0.0014486233) )
  {
    sub_10062EE0((int)v5, (int)v6, a3, (float *)&a1, &a2);
    sub_10068220(*(float *)&a1, a4, a4 + 4);
    result = sub_10068220(a2, (int)a5, (int)(a5 + 1));
  }
  else
  {
    v7 = a4;
    sub_10062CC0(v5, v6, a3, a4);
    result = (int)a5;
    *a5 = *(float *)v7;
    *(float *)(result + 4) = *(float *)(v7 + 4);
  }
  return result;
}

//----- (10063470) --------------------------------------------------------
double __cdecl sub_10063470(float a1)
{
  float v2; // [sp+4h] [bp+4h]@1

  v2 = pow(a1 / 101325.0, 0.190228059887886);
  return (float)((1.0 - v2) * -44330.765625);
}

//----- (100634A0) --------------------------------------------------------
void __cdecl sub_100634A0(float *a1, float *a2, int a3)
{
  float *v3; // esi@1
  float *v4; // edi@1
  int v5; // [sp+18h] [bp-8h]@1
  int v6; // [sp+1Ch] [bp-4h]@1
  float v7; // [sp+24h] [bp+4h]@1
  float v8; // [sp+24h] [bp+4h]@1
  float v9; // [sp+24h] [bp+4h]@1
  float v10; // [sp+24h] [bp+4h]@1
  float v11; // [sp+28h] [bp+8h]@1
  float v12; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v4 = a2;
  v7 = (*a1 + *a2) * 0.5;
  sub_10068220(v7, (int)&v5, (int)&v6);
  v8 = 1.0 / (1.0 - *(float *)&v5 * (0.00669437999013 * *(float *)&v5));
  v11 = sqrt(v8) * 6378137.0;
  v9 = 0.99330562000987 * v11 * v8;
  v12 = v11 * *(float *)&v6;
  *(float *)(a3 + 4) = (*v4 - *v3) * v9;
  v10 = v4[1] - v3[1];
  *(float *)a3 = v10;
  *(float *)a3 = sub_100680D0(v10) * v12;
}

//----- (10063560) --------------------------------------------------------
double __cdecl sub_10063560(int a1, int a2)
{
  return (float)(*(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)a1 * *(float *)a2);
}

//----- (10063580) --------------------------------------------------------
char __cdecl sub_10063580(int a1, __int16 a2, __int16 a3, __int16 a4, int a5, __int16 a6, __int16 a7)
{
  char result; // al@4
  char v8; // [sp+0h] [bp-17Ch]@55
  char v9; // [sp+4h] [bp-178h]@49
  char v10; // [sp+8h] [bp-174h]@43
  char v11; // [sp+Ch] [bp-170h]@37
  char v12; // [sp+10h] [bp-16Ch]@31
  char v13; // [sp+14h] [bp-168h]@25
  char v14; // [sp+18h] [bp-164h]@19
  char v15; // [sp+1Ch] [bp-160h]@13
  char v16; // [sp+20h] [bp-15Ch]@98
  char v17; // [sp+21h] [bp-15Bh]@98
  __int16 v18; // [sp+22h] [bp-15Ah]@98
  __int16 v19; // [sp+24h] [bp-158h]@98
  __int16 v20; // [sp+26h] [bp-156h]@98
  int v21; // [sp+2Ch] [bp-150h]@98
  char v22; // [sp+30h] [bp-14Ch]@96
  char v23; // [sp+31h] [bp-14Bh]@96
  __int16 v24; // [sp+32h] [bp-14Ah]@96
  __int16 v25; // [sp+34h] [bp-148h]@96
  __int16 v26; // [sp+36h] [bp-146h]@96
  int v27; // [sp+3Ch] [bp-140h]@96
  char v28; // [sp+40h] [bp-13Ch]@94
  char v29; // [sp+41h] [bp-13Bh]@94
  __int16 v30; // [sp+42h] [bp-13Ah]@94
  __int16 v31; // [sp+44h] [bp-138h]@94
  __int16 v32; // [sp+46h] [bp-136h]@94
  int v33; // [sp+4Ch] [bp-130h]@94
  char v34; // [sp+50h] [bp-12Ch]@92
  char v35; // [sp+51h] [bp-12Bh]@92
  __int16 v36; // [sp+52h] [bp-12Ah]@92
  __int16 v37; // [sp+54h] [bp-128h]@92
  __int16 v38; // [sp+56h] [bp-126h]@92
  int v39; // [sp+5Ch] [bp-120h]@92
  char v40; // [sp+60h] [bp-11Ch]@90
  char v41; // [sp+61h] [bp-11Bh]@90
  __int16 v42; // [sp+62h] [bp-11Ah]@90
  __int16 v43; // [sp+64h] [bp-118h]@90
  __int16 v44; // [sp+66h] [bp-116h]@90
  int v45; // [sp+6Ch] [bp-110h]@90
  char v46; // [sp+70h] [bp-10Ch]@88
  char v47; // [sp+71h] [bp-10Bh]@88
  __int16 v48; // [sp+72h] [bp-10Ah]@88
  __int16 v49; // [sp+74h] [bp-108h]@88
  __int16 v50; // [sp+76h] [bp-106h]@88
  int v51; // [sp+7Ch] [bp-100h]@88
  char v52; // [sp+80h] [bp-FCh]@86
  char v53; // [sp+81h] [bp-FBh]@86
  __int16 v54; // [sp+82h] [bp-FAh]@86
  __int16 v55; // [sp+84h] [bp-F8h]@86
  __int16 v56; // [sp+86h] [bp-F6h]@86
  int v57; // [sp+8Ch] [bp-F0h]@86
  char v58; // [sp+90h] [bp-ECh]@84
  char v59; // [sp+91h] [bp-EBh]@84
  __int16 v60; // [sp+92h] [bp-EAh]@84
  __int16 v61; // [sp+94h] [bp-E8h]@84
  __int16 v62; // [sp+96h] [bp-E6h]@84
  int v63; // [sp+9Ch] [bp-E0h]@84
  char v64; // [sp+A0h] [bp-DCh]@79
  char v65; // [sp+A1h] [bp-DBh]@79
  __int16 v66; // [sp+A2h] [bp-DAh]@79
  __int16 v67; // [sp+A4h] [bp-D8h]@79
  __int16 v68; // [sp+A6h] [bp-D6h]@79
  int v69; // [sp+ACh] [bp-D0h]@79
  char v70; // [sp+B0h] [bp-CCh]@77
  char v71; // [sp+B1h] [bp-CBh]@77
  __int16 v72; // [sp+B2h] [bp-CAh]@77
  __int16 v73; // [sp+B4h] [bp-C8h]@77
  __int16 v74; // [sp+B6h] [bp-C6h]@77
  int v75; // [sp+BCh] [bp-C0h]@77
  char v76; // [sp+C0h] [bp-BCh]@75
  char v77; // [sp+C1h] [bp-BBh]@75
  __int16 v78; // [sp+C2h] [bp-BAh]@75
  __int16 v79; // [sp+C4h] [bp-B8h]@75
  __int16 v80; // [sp+C6h] [bp-B6h]@75
  int v81; // [sp+CCh] [bp-B0h]@75
  char v82; // [sp+D0h] [bp-ACh]@73
  char v83; // [sp+D1h] [bp-ABh]@73
  __int16 v84; // [sp+D2h] [bp-AAh]@73
  __int16 v85; // [sp+D4h] [bp-A8h]@73
  __int16 v86; // [sp+D6h] [bp-A6h]@73
  int v87; // [sp+DCh] [bp-A0h]@73
  char v88; // [sp+E0h] [bp-9Ch]@71
  char v89; // [sp+E1h] [bp-9Bh]@71
  __int16 v90; // [sp+E2h] [bp-9Ah]@71
  __int16 v91; // [sp+E4h] [bp-98h]@71
  __int16 v92; // [sp+E6h] [bp-96h]@71
  int v93; // [sp+ECh] [bp-90h]@71
  char v94; // [sp+F0h] [bp-8Ch]@69
  char v95; // [sp+F1h] [bp-8Bh]@69
  __int16 v96; // [sp+F2h] [bp-8Ah]@69
  __int16 v97; // [sp+F4h] [bp-88h]@69
  __int16 v98; // [sp+F6h] [bp-86h]@69
  int v99; // [sp+FCh] [bp-80h]@69
  char v100; // [sp+100h] [bp-7Ch]@67
  char v101; // [sp+101h] [bp-7Bh]@67
  __int16 v102; // [sp+102h] [bp-7Ah]@67
  __int16 v103; // [sp+104h] [bp-78h]@67
  __int16 v104; // [sp+106h] [bp-76h]@67
  int v105; // [sp+10Ch] [bp-70h]@67
  char v106; // [sp+110h] [bp-6Ch]@65
  char v107; // [sp+111h] [bp-6Bh]@65
  __int16 v108; // [sp+112h] [bp-6Ah]@65
  __int16 v109; // [sp+114h] [bp-68h]@65
  __int16 v110; // [sp+116h] [bp-66h]@65
  int v111; // [sp+11Ch] [bp-60h]@65
  __int16 v112; // [sp+120h] [bp-5Ch]@1
  char v113; // [sp+127h] [bp-55h]@64
  __int16 v114; // [sp+128h] [bp-54h]@1
  int v115; // [sp+12Ch] [bp-50h]@61
  __int16 v116; // [sp+130h] [bp-4Ch]@1
  char v117; // [sp+137h] [bp-45h]@57
  __int16 v118; // [sp+138h] [bp-44h]@61
  __int16 v119; // [sp+13Ah] [bp-42h]@61
  __int16 v120; // [sp+13Ch] [bp-40h]@8
  __int16 v121; // [sp+140h] [bp-3Ch]@61
  __int16 v122; // [sp+144h] [bp-38h]@8
  char v123; // [sp+148h] [bp-34h]@9
  char v124; // [sp+149h] [bp-33h]@21
  char v125; // [sp+14Ah] [bp-32h]@33
  char v126; // [sp+14Bh] [bp-31h]@57
  char v127; // [sp+14Ch] [bp-30h]@45
  char v128; // [sp+14Dh] [bp-2Fh]@27
  char v129; // [sp+14Eh] [bp-2Eh]@15
  char v130; // [sp+14Fh] [bp-2Dh]@39
  __int16 v131; // [sp+150h] [bp-2Ch]@9
  __int16 v132; // [sp+154h] [bp-28h]@1
  __int16 v133; // [sp+158h] [bp-24h]@61
  __int16 v134; // [sp+15Ah] [bp-22h]@61
  char v135; // [sp+15Ch] [bp-20h]@59
  char v136; // [sp+15Dh] [bp-1Fh]@67
  char v137; // [sp+15Eh] [bp-1Eh]@71
  char v138; // [sp+15Fh] [bp-1Dh]@79
  char v139; // [sp+160h] [bp-1Ch]@75
  char v140; // [sp+161h] [bp-1Bh]@69
  char v141; // [sp+162h] [bp-1Ah]@65
  char v142; // [sp+163h] [bp-19h]@73
  __int16 v143; // [sp+168h] [bp-14h]@1
  int v144; // [sp+16Ch] [bp-10h]@57
  __int16 v145; // [sp+170h] [bp-Ch]@1
  __int16 v146; // [sp+174h] [bp-8h]@9
  __int16 v147; // [sp+178h] [bp-4h]@9

  v114 = a2;
  v132 = a3;
  v112 = a6;
  v143 = a7;
  v116 = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  v145 = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 46) = a6;
  *(_WORD *)(a1 + 44) = v143;
  v112 += *(_WORD *)(a1 + 42);
  v143 += *(_WORD *)(a1 + 40);
  v114 += *(_WORD *)(a1 + 42);
  v132 += *(_WORD *)(a1 + 40);
  if ( v116 != v112 || v145 != v143 )
  {
    if ( a5 & 1 )
    {
      v122 = v116;
      v116 = v112;
      v112 = v122;
      v120 = v145;
      v145 = v143;
      v143 = v120;
    }
    sub_100647D0((int)&v123, v116 - v114, v145 - v132, v112 - v114, v143 - v132);
    v146 = (unsigned int)(46341 * a4) >> 16;
    v131 = v146 - 1;
    v147 = v146 + 1;
    if ( v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v147 + v114 < *(_WORD *)(a1 + 26)
      || v131 + v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v132 < *(_WORD *)(a1 + 24) )
    {
      v15 = 0;
    }
    else
    {
      v15 = -1;
    }
    v129 &= v15;
    if ( v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v147 + v114 < *(_WORD *)(a1 + 26)
      || v132 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 - v131 < *(_WORD *)(a1 + 24) )
    {
      v14 = 0;
    }
    else
    {
      v14 = -1;
    }
    v124 &= v14;
    if ( v114 - v147 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 < (signed int)*(_WORD *)(a1 + 26)
      || v131 + v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v132 < *(_WORD *)(a1 + 24) )
    {
      v13 = 0;
    }
    else
    {
      v13 = -1;
    }
    v128 &= v13;
    if ( v114 - v147 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 < (signed int)*(_WORD *)(a1 + 26)
      || v132 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 - v131 < *(_WORD *)(a1 + 24) )
    {
      v12 = 0;
    }
    else
    {
      v12 = -1;
    }
    v125 &= v12;
    if ( v131 + v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v114 < *(_WORD *)(a1 + 26)
      || v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v147 + v132 < *(_WORD *)(a1 + 24) )
    {
      v11 = 0;
    }
    else
    {
      v11 = -1;
    }
    v130 &= v11;
    if ( v114 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 - v131 < *(_WORD *)(a1 + 26)
      || v132 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v147 + v132 < *(_WORD *)(a1 + 24) )
    {
      v10 = 0;
    }
    else
    {
      v10 = -1;
    }
    v127 &= v10;
    if ( v131 + v114 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v114 < *(_WORD *)(a1 + 26)
      || v132 - v147 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v9 = 0;
    }
    else
    {
      v9 = -1;
    }
    v123 &= v9;
    if ( v114 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v114 - v131 < *(_WORD *)(a1 + 26)
      || v132 - v147 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v132 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v8 = 0;
    }
    else
    {
      v8 = -1;
    }
    v126 &= v8;
    v144 = 0;
    v117 = 0;
    while ( v144 < 8 )
    {
      *(&v135 + v144) = *(_BYTE *)(a1 + 1);
      v117 |= *(&v123 + v144++);
    }
    result = v117;
    if ( v117 )
    {
      v121 = 0;
      v122 = 0;
      v120 = a4;
      v115 = 1 - a4;
      v119 = v116;
      v118 = v145;
      v134 = v112;
      v133 = v143;
      while ( v122 < v120 )
      {
        if ( v115 >= 0 )
        {
          v113 = 0;
          if ( v129 )
          {
            v106 = 6;
            v107 = v129;
            v108 = v120 + v132;
            v109 = v121 + v114;
            v110 = v122 + v114;
            v111 = a5;
            *(_BYTE *)(a1 + 1) = v141;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100646C0(a1, (int)&v106, (int)&v118, (int)&v133);
            v141 = *(_BYTE *)(a1 + 1);
          }
          if ( v124 )
          {
            v100 = 1;
            v101 = v124;
            v102 = v132 - v120;
            v103 = v122 + v114;
            v104 = v121 + v114;
            v105 = a5;
            *(_BYTE *)(a1 + 1) = v136;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100646C0(a1, (int)&v100, (int)&v118, (int)&v133);
            v136 = *(_BYTE *)(a1 + 1);
          }
          if ( v128 )
          {
            v94 = 5;
            v95 = v128;
            v96 = v120 + v132;
            v97 = v114 - v122;
            v98 = v114 - v121;
            v99 = a5;
            *(_BYTE *)(a1 + 1) = v140;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100646C0(a1, (int)&v94, (int)&v118, (int)&v133);
            v140 = *(_BYTE *)(a1 + 1);
          }
          if ( v125 )
          {
            v88 = 2;
            v89 = v125;
            v90 = v132 - v120;
            v91 = v114 - v121;
            v92 = v114 - v122;
            v93 = a5;
            *(_BYTE *)(a1 + 1) = v137;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100646C0(a1, (int)&v88, (int)&v118, (int)&v133);
            v137 = *(_BYTE *)(a1 + 1);
          }
          if ( v130 )
          {
            v82 = 7;
            v83 = v130;
            v84 = v120 + v114;
            v85 = v122 + v132;
            v86 = v121 + v132;
            v87 = a5;
            *(_BYTE *)(a1 + 1) = v142;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100646C0(a1, (int)&v82, (int)&v118, (int)&v133);
            v142 = *(_BYTE *)(a1 + 1);
          }
          if ( v127 )
          {
            v76 = 4;
            v77 = v127;
            v78 = v114 - v120;
            v79 = v121 + v132;
            v80 = v122 + v132;
            v81 = a5;
            *(_BYTE *)(a1 + 1) = v139;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100646C0(a1, (int)&v76, (int)&v118, (int)&v133);
            v139 = *(_BYTE *)(a1 + 1);
          }
          if ( v123 )
          {
            v70 = 0;
            v71 = v123;
            v72 = v120 + v114;
            v73 = v132 - v121;
            v74 = v132 - v122;
            v75 = a5;
            *(_BYTE *)(a1 + 1) = v135;
            *(_WORD *)(a1 + 16) = -v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100646C0(a1, (int)&v70, (int)&v118, (int)&v133);
            v135 = *(_BYTE *)(a1 + 1);
          }
          if ( v126 )
          {
            v64 = 3;
            v65 = v126;
            v66 = v114 - v120;
            v67 = v132 - v122;
            v68 = v132 - v121;
            v69 = a5;
            *(_BYTE *)(a1 + 1) = v138;
            *(_WORD *)(a1 + 16) = v113;
            *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
            sub_100646C0(a1, (int)&v64, (int)&v118, (int)&v133);
            v138 = *(_BYTE *)(a1 + 1);
          }
          v121 = v122 + 1;
          v115 -= 2 * v120-- - 2;
        }
        v115 += 2 * v122++ + 3;
      }
      result = v120;
      if ( v122 == v120 )
      {
        v113 = 0;
        if ( v129 )
        {
          v58 = 6;
          v59 = v129;
          v60 = v120 + v132;
          v61 = v121 + v114;
          v62 = v122 + v114;
          v63 = a5;
          *(_BYTE *)(a1 + 1) = v141;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100646C0(a1, (int)&v58, (int)&v118, (int)&v133);
          v141 = *(_BYTE *)(a1 + 1);
        }
        if ( v124 )
        {
          v52 = 1;
          v53 = v124;
          v54 = v132 - v120;
          v55 = v122 + v114;
          v56 = v121 + v114;
          v57 = a5;
          *(_BYTE *)(a1 + 1) = v136;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100646C0(a1, (int)&v52, (int)&v118, (int)&v133);
          v136 = *(_BYTE *)(a1 + 1);
        }
        if ( v128 )
        {
          v46 = 5;
          v47 = v128;
          v48 = v120 + v132;
          v49 = v114 - v122;
          v50 = v114 - v121;
          v51 = a5;
          *(_BYTE *)(a1 + 1) = v140;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100646C0(a1, (int)&v46, (int)&v118, (int)&v133);
          v140 = *(_BYTE *)(a1 + 1);
        }
        if ( v125 )
        {
          v40 = 2;
          v41 = v125;
          v42 = v132 - v120;
          v43 = v114 - v121;
          v44 = v114 - v122;
          v45 = a5;
          *(_BYTE *)(a1 + 1) = v137;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100646C0(a1, (int)&v40, (int)&v118, (int)&v133);
          v137 = *(_BYTE *)(a1 + 1);
        }
        if ( v130 )
        {
          v34 = 7;
          v35 = v130;
          v36 = v120 + v114;
          v37 = v122 + v132;
          v38 = v121 + v132;
          v39 = a5;
          *(_BYTE *)(a1 + 1) = v142;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100646C0(a1, (int)&v34, (int)&v118, (int)&v133);
          v142 = *(_BYTE *)(a1 + 1);
        }
        if ( v127 )
        {
          v28 = 4;
          v29 = v127;
          v30 = v114 - v120;
          v31 = v121 + v132;
          v32 = v122 + v132;
          v33 = a5;
          *(_BYTE *)(a1 + 1) = v139;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100646C0(a1, (int)&v28, (int)&v118, (int)&v133);
          v139 = *(_BYTE *)(a1 + 1);
        }
        if ( v123 )
        {
          v22 = 0;
          v23 = v123;
          v24 = v120 + v114;
          v25 = v132 - v121;
          v26 = v132 - v122;
          v27 = a5;
          *(_BYTE *)(a1 + 1) = v135;
          *(_WORD *)(a1 + 16) = -v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100646C0(a1, (int)&v22, (int)&v118, (int)&v133);
          v135 = *(_BYTE *)(a1 + 1);
        }
        result = v126;
        if ( v126 )
        {
          v16 = 3;
          v17 = v126;
          v18 = v114 - v120;
          v19 = v132 - v122;
          v20 = v132 - v121;
          v21 = a5;
          *(_BYTE *)(a1 + 1) = v138;
          *(_WORD *)(a1 + 16) = v113;
          *(_WORD *)(a1 + 18) = *(_WORD *)(a1 + 16);
          sub_100646C0(a1, (int)&v16, (int)&v118, (int)&v133);
          result = a1;
          v138 = *(_BYTE *)(a1 + 1);
        }
      }
    }
  }
  else if ( a5 & 2 )
  {
    result = sub_10065620(a1, a2, a3, a4, 0);
  }
  else
  {
    result = sub_100655C0(a1, a6, a7);
  }
  return result;
}

//----- (100646C0) --------------------------------------------------------
char *__cdecl sub_100646C0(int a1, int a2, int a3, int a4)
{
  if ( (*(_BYTE *)a2 + 1) & 2 )
  {
    *(_WORD *)(a2 + 8) = *(_WORD *)(a3 + 2);
    *(_WORD *)(a2 + 10) = *(_WORD *)(a4 + 2);
  }
  else
  {
    *(_WORD *)(a2 + 8) = *(_WORD *)a3;
    *(_WORD *)(a2 + 10) = *(_WORD *)a4;
  }
  return off_10129110[*(_BYTE *)a2](a1, a2);
}
// 10129110: using guessed type int (__cdecl *off_10129110[16])(int, int);

//----- (10064730) --------------------------------------------------------
char __cdecl sub_10064730(int a1, int a2)
{
  *(_WORD *)(a1 + 8) = *(_WORD *)a2;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a2 + 4) - *(_WORD *)(a2 + 2);
  return sub_10066150(a1);
}

//----- (10064780) --------------------------------------------------------
char *__cdecl sub_10064780(int a1, int a2)
{
  *(_WORD *)(a1 + 10) = *(_WORD *)a2;
  *(_WORD *)(a1 + 8) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 4) - *(_WORD *)(a2 + 2);
  return sub_10066320(a1);
}

//----- (100647D0) --------------------------------------------------------
signed int __cdecl sub_100647D0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  signed int result; // eax@3
  int v6; // edx@7
  int v7; // eax@11
  char v8; // [sp+5h] [bp-3h]@1
  char i; // [sp+5h] [bp-3h]@2
  unsigned __int8 v10; // [sp+5h] [bp-3h]@3
  bool v11; // [sp+6h] [bp-2h]@7
  char v12; // [sp+7h] [bp-1h]@1

  v8 = sub_10064920(a2, a3);
  v12 = sub_10064920(a4, a5);
  if ( (unsigned __int8)v8 == (unsigned __int8)v12 )
  {
    switch ( v8 )
    {
      case 0:
      case 7:
        v6 = a5 < a3;
        v11 = a5 > a3;
        break;
      case 1:
      case 2:
        v6 = a4 < a2;
        v11 = a4 > a2;
        break;
      case 3:
      case 4:
        v6 = a5 < a3;
        v11 = a5 < a3;
        break;
      default:
        v6 = a4 < a2;
        v11 = a4 < a2;
        break;
    }
    LOBYTE(v6) = v11;
    BYTE1(v6) = v11;
    v7 = v6 << 16;
    LOWORD(v7) = v6;
    *(_DWORD *)a1 = v7;
    *(_DWORD *)(a1 + 4) = v7;
    result = v11 != 0 ? 10 : 13;
    *(_BYTE *)(a1 + (unsigned __int8)v8) = result;
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_BYTE *)(a1 + (unsigned __int8)v8) = 5;
    *(_BYTE *)(a1 + (unsigned __int8)v12) = 9;
    for ( i = v8 + 1; ; i = v10 + 1 )
    {
      v10 = i & 7;
      result = v10;
      if ( v10 == (unsigned __int8)v12 )
        break;
      *(_BYTE *)(a1 + v10) = 1;
    }
  }
  return result;
}

//----- (10064920) --------------------------------------------------------
char __cdecl sub_10064920(__int16 a1, __int16 a2)
{
  char v3; // [sp+1h] [bp-1h]@3

  if ( a1 >= 0 )
  {
    if ( a1 <= 0 )
    {
      v3 = 4 * (a2 >= 0) + 2;
    }
    else if ( a2 > 0 )
    {
      v3 = (a1 >= a2) + 6;
    }
    else
    {
      v3 = a1 <= -a2;
    }
  }
  else if ( a2 >= 0 )
  {
    v3 = (a1 >= -a2) + 4;
  }
  else
  {
    v3 = (a1 <= a2) + 2;
  }
  return v3;
}

//----- (100649C0) --------------------------------------------------------
char *__cdecl sub_100649C0(int a1, int a2)
{
  __int16 v2; // ST08_2@7
  char *result; // eax@11
  __int16 v4; // ST08_2@20
  int v5; // [sp+4h] [bp-8h]@3
  __int16 v6; // [sp+8h] [bp-4h]@3

  if ( (*(_BYTE *)(a2 + 1) & 3) == 2 )
  {
    if ( *(_WORD *)(a2 + 8) >= (signed int)*(_WORD *)(a2 + 6) )
    {
      v5 = *(_DWORD *)(a2 + 2);
      v6 = *(_WORD *)(a2 + 6);
      if ( *(_WORD *)(a2 + 8) < (signed int)*(_WORD *)(a2 + 4) )
        HIWORD(v5) = *(_WORD *)(a2 + 8);
      --v6;
      if ( *(_WORD *)(a1 + 4) == 4 && *(_DWORD *)(a2 + 12) & 1 )
      {
        v2 = HIWORD(v5);
        HIWORD(v5) = v6;
        v6 = v2;
      }
      off_10129130[*(_BYTE *)a2](a1, (int)&v5);
    }
  }
  else if ( *(_BYTE *)(a2 + 1) & 4 )
  {
    result = (char *)*(_WORD *)(a2 + 6);
    if ( *(_WORD *)(a2 + 8) < (signed int)result )
      return result;
    if ( *(_WORD *)(a2 + 8) < (signed int)*(_WORD *)(a2 + 4) )
      *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 8);
  }
  if ( *(_BYTE *)(a2 + 1) & 8 )
  {
    result = (char *)a2;
    if ( *(_WORD *)(a2 + 10) > (signed int)*(_WORD *)(a2 + 4) )
      return result;
    if ( *(_WORD *)(a2 + 10) > (signed int)*(_WORD *)(a2 + 6) )
      *(_WORD *)(a2 + 6) = *(_WORD *)(a2 + 10);
  }
  --*(_WORD *)(a2 + 6);
  v5 = *(_DWORD *)(a2 + 2);
  v6 = *(_WORD *)(a2 + 6);
  if ( *(_WORD *)(a1 + 4) == 4 )
  {
    if ( *(_DWORD *)(a2 + 12) & 1 )
    {
      v4 = HIWORD(v5);
      HIWORD(v5) = v6;
      v6 = v4;
    }
  }
  return off_10129130[*(_BYTE *)a2](a1, (int)&v5);
}
// 10129130: using guessed type int (__cdecl *off_10129130[8])(int, int);

//----- (10064B70) --------------------------------------------------------
char *__cdecl sub_10064B70(int a1, int a2)
{
  __int16 v2; // ST08_2@7
  char *result; // eax@11
  __int16 v4; // ST08_2@20
  int v5; // [sp+4h] [bp-8h]@3
  __int16 v6; // [sp+8h] [bp-4h]@3

  if ( (*(_BYTE *)(a2 + 1) & 3) == 2 )
  {
    if ( *(_WORD *)(a2 + 8) <= (signed int)*(_WORD *)(a2 + 6) )
    {
      v5 = *(_DWORD *)(a2 + 2);
      v6 = *(_WORD *)(a2 + 6);
      if ( *(_WORD *)(a2 + 8) > (signed int)*(_WORD *)(a2 + 4) )
        HIWORD(v5) = *(_WORD *)(a2 + 8);
      ++v6;
      if ( *(_WORD *)(a1 + 4) == 4 && *(_DWORD *)(a2 + 12) & 1 )
      {
        v2 = HIWORD(v5);
        HIWORD(v5) = v6;
        v6 = v2;
      }
      off_10129130[*(_BYTE *)a2](a1, (int)&v5);
    }
  }
  else if ( *(_BYTE *)(a2 + 1) & 4 )
  {
    result = (char *)*(_WORD *)(a2 + 6);
    if ( *(_WORD *)(a2 + 8) > (signed int)result )
      return result;
    if ( *(_WORD *)(a2 + 8) > (signed int)*(_WORD *)(a2 + 4) )
      *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 8);
  }
  if ( *(_BYTE *)(a2 + 1) & 8 )
  {
    result = (char *)a2;
    if ( *(_WORD *)(a2 + 10) < (signed int)*(_WORD *)(a2 + 4) )
      return result;
    if ( *(_WORD *)(a2 + 10) < (signed int)*(_WORD *)(a2 + 6) )
      *(_WORD *)(a2 + 6) = *(_WORD *)(a2 + 10);
  }
  ++*(_WORD *)(a2 + 6);
  v5 = *(_DWORD *)(a2 + 2);
  v6 = *(_WORD *)(a2 + 6);
  if ( *(_WORD *)(a1 + 4) == 4 )
  {
    if ( *(_DWORD *)(a2 + 12) & 1 )
    {
      v4 = HIWORD(v5);
      HIWORD(v5) = v6;
      v6 = v4;
    }
  }
  return off_10129130[*(_BYTE *)a2](a1, (int)&v5);
}
// 10129130: using guessed type int (__cdecl *off_10129130[8])(int, int);

//----- (10064D20) --------------------------------------------------------
int __cdecl sub_10064D20(int a1, __int16 a2, __int16 a3, char a4)
{
  int result; // eax@25
  signed int v5; // [sp+4h] [bp-30h]@29
  int v6; // [sp+8h] [bp-2Ch]@44
  int v7; // [sp+8h] [bp-2Ch]@54
  __int16 v8; // [sp+Ch] [bp-28h]@31
  char (__cdecl *v9)(int); // [sp+10h] [bp-24h]@2
  char *(__cdecl *v10)(int); // [sp+14h] [bp-20h]@5
  __int16 v11; // [sp+18h] [bp-1Ch]@31
  signed int v12; // [sp+1Ch] [bp-18h]@31
  __int16 v13; // [sp+20h] [bp-14h]@41
  __int16 v14; // [sp+28h] [bp-Ch]@29
  __int16 v15; // [sp+2Ch] [bp-8h]@29
  __int16 v16; // [sp+30h] [bp-4h]@41

  if ( *(_DWORD *)(a1 + 72) )
    v9 = *(char (__cdecl **)(int))(a1 + 72);
  else
    v9 = sub_10066150;
  if ( *(_DWORD *)(a1 + 76) )
    v10 = *(char *(__cdecl **)(int))(a1 + 76);
  else
    v10 = sub_10066320;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 42) + *(_WORD *)(a1 + 46);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 40) + *(_WORD *)(a1 + 44);
  *(_WORD *)(a1 + 14) = *(_WORD *)(a1 + 42) + a2;
  *(_WORD *)(a1 + 12) = *(_WORD *)(a1 + 40) + a3;
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  if ( a4 & 1 )
  {
    if ( (signed int)*(_WORD *)(a1 + 10) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 10) < -8192 )
        *(_WORD *)(a1 + 10) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 10) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 8) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 8) < -8192 )
        *(_WORD *)(a1 + 8) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 8) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 14) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 14) < -8192 )
        *(_WORD *)(a1 + 14) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 14) = 0x1FFF;
    }
    if ( (signed int)*(_WORD *)(a1 + 12) <= 0x1FFF )
    {
      if ( (signed int)*(_WORD *)(a1 + 12) < -8192 )
        *(_WORD *)(a1 + 12) = -8192;
    }
    else
    {
      *(_WORD *)(a1 + 12) = 0x1FFF;
    }
  }
  if ( *(_WORD *)(a1 + 10) != *(_WORD *)(a1 + 14) || (result = *(_WORD *)(a1 + 12), *(_WORD *)(a1 + 8) != result) )
  {
    v14 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
    v15 = v14;
    v5 = 1;
    if ( v14 < 0 )
    {
      v5 = -1;
      v15 = -v14;
    }
    v8 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 8);
    v11 = v8;
    v12 = 1;
    if ( v8 < 0 )
    {
      v12 = -1;
      v11 = -v8;
    }
    if ( v15 )
    {
      if ( v11 )
      {
        v13 = 2 * v15;
        v16 = 2 * v11;
        if ( v15 <= v11 )
        {
          *(_WORD *)(a1 + 16) = 0;
          *(_WORD *)(a1 + 18) = 1;
          if ( v13 >= v11 )
            *(_WORD *)(a1 + 16) -= (v12 ^ v5) + 1;
          v7 = v13 - v11 - (v5 < 0);
          *(_WORD *)(a1 + 12) = 0;
          while ( v11 )
          {
            *(_WORD *)(a1 + 12) += v12;
            if ( v7 >= 0 )
            {
              v10(a1);
              *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
              *(_WORD *)(a1 + 12) = 0;
              *(_WORD *)(a1 + 10) += v5;
              v7 -= v16;
            }
            v7 += v13;
            --v11;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 12) += v12;
          v10(a1);
          result = a1;
          *(_WORD *)(a1 + 8) += *(_WORD *)(a1 + 12);
        }
        else
        {
          *(_WORD *)(a1 + 16) = 1;
          *(_WORD *)(a1 + 18) = 0;
          if ( v16 >= v15 )
            *(_WORD *)(a1 + 18) -= (v12 ^ v5) + 1;
          v6 = v16 - v15 - (v12 < 0);
          *(_WORD *)(a1 + 14) = 0;
          while ( v15 )
          {
            *(_WORD *)(a1 + 14) += v5;
            if ( v6 >= 0 )
            {
              v9(a1);
              *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
              *(_WORD *)(a1 + 14) = 0;
              *(_WORD *)(a1 + 8) += v12;
              v6 -= v13;
            }
            v6 += v16;
            --v15;
          }
          if ( a4 & 2 )
            *(_WORD *)(a1 + 14) += v5;
          v9(a1);
          result = a1;
          *(_WORD *)(a1 + 10) += *(_WORD *)(a1 + 14);
        }
      }
      else
      {
        *(_WORD *)(a1 + 16) = 1;
        *(_WORD *)(a1 + 18) = 0;
        *(_WORD *)(a1 + 14) = v14;
        if ( a4 & 2 )
          *(_WORD *)(a1 + 14) += v5;
        result = v9(a1);
      }
    }
    else
    {
      *(_WORD *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 18) = 1;
      *(_WORD *)(a1 + 12) = v8;
      if ( a4 & 2 )
        *(_WORD *)(a1 + 12) += v12;
      result = (int)v10(a1);
    }
  }
  else if ( a4 & 2 )
  {
    *(_WORD *)(a1 + 12) = 1;
    result = (int)v10(a1);
  }
  return result;
}

//----- (10065270) --------------------------------------------------------
int __cdecl sub_10065270(int a1, __int16 a2, __int16 a3, __int16 a4)
{
  int result; // eax@5
  int v5; // [sp+0h] [bp-18h]@6
  __int16 v6; // [sp+4h] [bp-14h]@6
  int v7; // [sp+8h] [bp-10h]@1
  __int16 v8; // [sp+Ch] [bp-Ch]@6
  __int16 v9; // [sp+10h] [bp-8h]@1
  __int16 v10; // [sp+14h] [bp-4h]@1

  v7 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 48);
  v10 = *(_WORD *)(a1 + 42) + a2;
  v9 = *(_WORD *)(a1 + 40) + a3;
  if ( v10 - a4 < *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
    && a4 + v10 >= *(_WORD *)(a1 + 26)
    && v9 - a4 < *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
    && a4 + v9 >= *(_WORD *)(a1 + 24) )
  {
    v8 = 0;
    v6 = a4;
    v5 = 1 - a4;
    while ( v8 < v6 )
    {
      if ( v5 >= 0 )
      {
        *(_WORD *)(a1 + 10) = v8 + v10;
        *(_WORD *)(a1 + 8) = v6 + v9;
        *(_WORD *)(a1 + 14) = v10 - v8;
        sub_100660A0(a1);
        *(_WORD *)(a1 + 8) = v9 - v6;
        sub_100660A0(a1);
        v5 -= 2 * v6-- - 2;
      }
      *(_WORD *)(a1 + 10) = v6 + v10;
      *(_WORD *)(a1 + 8) = v8 + v9;
      *(_WORD *)(a1 + 14) = v10 - v6;
      sub_100660A0(a1);
      *(_WORD *)(a1 + 8) = v9 - v8;
      sub_100660A0(a1);
      v5 += 2 * v8++ + 3;
    }
    result = v8;
    if ( v8 == v6 )
    {
      *(_WORD *)(a1 + 10) = v6 + v10;
      *(_WORD *)(a1 + 8) = v8 + v9;
      *(_WORD *)(a1 + 14) = v10 - v6;
      sub_100660A0(a1);
      *(_WORD *)(a1 + 8) = v9 - v8;
      LOBYTE(result) = sub_100660A0(a1);
    }
    *(_DWORD *)(a1 + 36) = v7;
  }
  else
  {
    result = v7;
    *(_DWORD *)(a1 + 36) = v7;
  }
  return result;
}

//----- (100654D0) --------------------------------------------------------
int __cdecl sub_100654D0(int a1, int a2, char a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 52) = a2;
  sub_100673A0(a1, 0, 0, *(_WORD *)(a2 + 6), *(_WORD *)(a2 + 4));
  *(_WORD *)(a1 + 42) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 2) = 1;
  *(_WORD *)(a1 + 34) = 1;
  *(_WORD *)(a1 + 32) = 1;
  *(_WORD *)(a1 + 4) = 3;
  *(_WORD *)(a1 + 36) = -1;
  *(_WORD *)(a1 + 38) = -1;
  *(_WORD *)(a1 + 6) = 3;
  *(_WORD *)(a1 + 48) = -1;
  *(_WORD *)(a1 + 50) = -1;
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  result = a1;
  *(_BYTE *)a1 = a3;
  return result;
}

//----- (100655C0) --------------------------------------------------------
int __cdecl sub_100655C0(int a1, __int16 a2, __int16 a3)
{
  *(_WORD *)(a1 + 46) = a2;
  *(_WORD *)(a1 + 44) = a3;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 46) + *(_WORD *)(a1 + 42);
  *(_WORD *)(a1 + 8) = *(_WORD *)(a1 + 44) + *(_WORD *)(a1 + 40);
  return sub_100662C0(a1);
}

//----- (10065620) --------------------------------------------------------
char __cdecl sub_10065620(int a1, __int16 a2, __int16 a3, __int16 a4, char a5)
{
  int v5; // ST3C_4@5
  char result; // al@5
  char v7; // [sp+0h] [bp-64h]@52
  char v8; // [sp+4h] [bp-60h]@46
  char v9; // [sp+8h] [bp-5Ch]@40
  char v10; // [sp+Ch] [bp-58h]@34
  char v11; // [sp+10h] [bp-54h]@28
  char v12; // [sp+14h] [bp-50h]@22
  char v13; // [sp+18h] [bp-4Ch]@16
  char v14; // [sp+1Ch] [bp-48h]@10
  __int16 v15; // [sp+24h] [bp-40h]@1
  int v16; // [sp+28h] [bp-3Ch]@58
  __int16 v17; // [sp+2Ch] [bp-38h]@58
  __int16 v18; // [sp+30h] [bp-34h]@58
  __int16 v19; // [sp+34h] [bp-30h]@58
  __int16 v20; // [sp+38h] [bp-2Ch]@6
  __int16 v21; // [sp+3Ch] [bp-28h]@1
  char v22; // [sp+40h] [bp-24h]@56
  char v23; // [sp+41h] [bp-23h]@64
  char v24; // [sp+42h] [bp-22h]@68
  char v25; // [sp+43h] [bp-21h]@76
  char v26; // [sp+44h] [bp-20h]@72
  char v27; // [sp+45h] [bp-1Fh]@66
  char v28; // [sp+46h] [bp-1Eh]@62
  char v29; // [sp+47h] [bp-1Dh]@70
  int v30; // [sp+48h] [bp-1Ch]@54
  __int16 v31; // [sp+4Ch] [bp-18h]@6
  char v32; // [sp+50h] [bp-14h]@48
  char v33; // [sp+51h] [bp-13h]@18
  char v34; // [sp+52h] [bp-12h]@30
  char v35; // [sp+53h] [bp-11h]@54
  char v36; // [sp+54h] [bp-10h]@42
  char v37; // [sp+55h] [bp-Fh]@24
  char v38; // [sp+56h] [bp-Eh]@12
  char v39; // [sp+57h] [bp-Dh]@36
  char v40; // [sp+5Fh] [bp-5h]@54
  __int16 v41; // [sp+60h] [bp-4h]@6

  v15 = *(_WORD *)(a1 + 42) + a2;
  v21 = *(_WORD *)(a1 + 40) + a3;
  if ( a5 & 1 )
    sub_10065270(a1, a2, a3, a4);
  if ( *(_WORD *)(a1 + 4) != 4 || (signed int)*(_WORD *)(a1 + 2) <= 1 )
  {
    v31 = 46341 * a4 / 0x10000;
    v20 = v31 - 1;
    v41 = v31 + 1;
    if ( v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v41 + v15 < *(_WORD *)(a1 + 26)
      || v20 + v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v21 < *(_WORD *)(a1 + 24) )
    {
      v14 = 0;
    }
    else
    {
      v14 = -1;
    }
    v38 = v14;
    if ( v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v41 + v15 < *(_WORD *)(a1 + 26)
      || v21 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 - v20 < *(_WORD *)(a1 + 24) )
    {
      v13 = 0;
    }
    else
    {
      v13 = -1;
    }
    v33 = v13;
    if ( v15 - v41 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 < (signed int)*(_WORD *)(a1 + 26)
      || v20 + v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || a4 + v21 < *(_WORD *)(a1 + 24) )
    {
      v12 = 0;
    }
    else
    {
      v12 = -1;
    }
    v37 = v12;
    if ( v15 - v41 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 < (signed int)*(_WORD *)(a1 + 26)
      || v21 - a4 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 - v20 < *(_WORD *)(a1 + 24) )
    {
      v11 = 0;
    }
    else
    {
      v11 = -1;
    }
    v34 = v11;
    if ( v20 + v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v15 < *(_WORD *)(a1 + 26)
      || v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v41 + v21 < *(_WORD *)(a1 + 24) )
    {
      v10 = 0;
    }
    else
    {
      v10 = -1;
    }
    v39 = v10;
    if ( v15 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 - v20 < *(_WORD *)(a1 + 26)
      || v21 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v41 + v21 < *(_WORD *)(a1 + 24) )
    {
      v9 = 0;
    }
    else
    {
      v9 = -1;
    }
    v36 = v9;
    if ( v20 + v15 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || a4 + v15 < *(_WORD *)(a1 + 26)
      || v21 - v41 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v8 = 0;
    }
    else
    {
      v8 = -1;
    }
    v32 = v8;
    if ( v15 - a4 >= *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26)
      || v15 - v20 < *(_WORD *)(a1 + 26)
      || v21 - v41 >= *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24)
      || v21 < (signed int)*(_WORD *)(a1 + 24) )
    {
      v7 = 0;
    }
    else
    {
      v7 = -1;
    }
    result = v7;
    v35 = v7;
    v30 = 0;
    v40 = 0;
    while ( v30 < 8 )
    {
      *(&v22 + v30) = *(_BYTE *)(a1 + 1);
      result = *(&v32 + v30);
      v40 |= result;
      ++v30;
    }
    if ( v40 )
    {
      v18 = 0;
      v19 = 0;
      v17 = a4;
      v16 = 1 - a4;
      while ( v19 < v17 )
      {
        if ( v16 >= 0 )
        {
          *(_WORD *)(a1 + 10) = v18 + v15;
          *(_WORD *)(a1 + 14) = v19 + 1 - v18;
          if ( v38 )
          {
            *(_WORD *)(a1 + 8) = v17 + v21;
            *(_BYTE *)(a1 + 1) = v28;
            sub_10066150(a1);
            v28 = *(_BYTE *)(a1 + 1);
          }
          if ( v33 )
          {
            *(_WORD *)(a1 + 8) = v21 - v17;
            *(_BYTE *)(a1 + 1) = v23;
            sub_10066150(a1);
            v23 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 10) = v15 - v18;
          *(_WORD *)(a1 + 14) = v18 - v19 - 1;
          if ( v37 )
          {
            *(_WORD *)(a1 + 8) = v17 + v21;
            *(_BYTE *)(a1 + 1) = v27;
            sub_10066150(a1);
            v27 = *(_BYTE *)(a1 + 1);
          }
          if ( v34 )
          {
            *(_WORD *)(a1 + 8) = v21 - v17;
            *(_BYTE *)(a1 + 1) = v24;
            sub_10066150(a1);
            v24 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 8) = v18 + v21;
          *(_WORD *)(a1 + 12) = v19 + 1 - v18;
          if ( v39 )
          {
            *(_WORD *)(a1 + 10) = v17 + v15;
            *(_BYTE *)(a1 + 1) = v29;
            sub_10066320(a1);
            v29 = *(_BYTE *)(a1 + 1);
          }
          if ( v36 )
          {
            *(_WORD *)(a1 + 10) = v15 - v17;
            *(_BYTE *)(a1 + 1) = v26;
            sub_10066320(a1);
            v26 = *(_BYTE *)(a1 + 1);
          }
          *(_WORD *)(a1 + 8) = v21 - v18;
          *(_WORD *)(a1 + 12) = v18 - v19 - 1;
          if ( v32 )
          {
            *(_WORD *)(a1 + 10) = v17 + v15;
            *(_BYTE *)(a1 + 1) = v22;
            sub_10066320(a1);
            v22 = *(_BYTE *)(a1 + 1);
          }
          if ( v35 )
          {
            *(_WORD *)(a1 + 10) = v15 - v17;
            *(_BYTE *)(a1 + 1) = v25;
            sub_10066320(a1);
            v25 = *(_BYTE *)(a1 + 1);
          }
          v18 = v19 + 1;
          v16 -= 2 * v17-- - 2;
        }
        v16 += 2 * v19++ + 3;
      }
      result = v17;
      if ( v19 == v17 )
      {
        *(_WORD *)(a1 + 10) = v18 + v15;
        *(_WORD *)(a1 + 14) = v19 + 1 - v18;
        if ( v38 )
        {
          *(_WORD *)(a1 + 8) = v17 + v21;
          *(_BYTE *)(a1 + 1) = v28;
          sub_10066150(a1);
          v28 = *(_BYTE *)(a1 + 1);
        }
        if ( v33 )
        {
          *(_WORD *)(a1 + 8) = v21 - v17;
          *(_BYTE *)(a1 + 1) = v23;
          sub_10066150(a1);
          v23 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 10) = v15 - v18;
        *(_WORD *)(a1 + 14) = v18 - v19 - 1;
        if ( v37 )
        {
          *(_WORD *)(a1 + 8) = v17 + v21;
          *(_BYTE *)(a1 + 1) = v27;
          sub_10066150(a1);
          v27 = *(_BYTE *)(a1 + 1);
        }
        if ( v34 )
        {
          *(_WORD *)(a1 + 8) = v21 - v17;
          *(_BYTE *)(a1 + 1) = v24;
          sub_10066150(a1);
          v24 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 8) = v18 + v21;
        *(_WORD *)(a1 + 12) = v19 + 1 - v18;
        if ( v39 )
        {
          *(_WORD *)(a1 + 10) = v17 + v15;
          *(_BYTE *)(a1 + 1) = v29;
          sub_10066320(a1);
          v29 = *(_BYTE *)(a1 + 1);
        }
        if ( v36 )
        {
          *(_WORD *)(a1 + 10) = v15 - v17;
          *(_BYTE *)(a1 + 1) = v26;
          sub_10066320(a1);
          v26 = *(_BYTE *)(a1 + 1);
        }
        *(_WORD *)(a1 + 8) = v21 - v18;
        result = a1;
        *(_WORD *)(a1 + 12) = v18 - v19 - 1;
        if ( v32 )
        {
          *(_WORD *)(a1 + 10) = v17 + v15;
          *(_BYTE *)(a1 + 1) = v22;
          sub_10066320(a1);
          result = *(_BYTE *)(a1 + 1);
          v22 = *(_BYTE *)(a1 + 1);
        }
        if ( v35 )
        {
          *(_WORD *)(a1 + 10) = v15 - v17;
          *(_BYTE *)(a1 + 1) = v25;
          sub_10066320(a1);
          result = *(_BYTE *)(a1 + 1);
        }
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 44);
    *(_WORD *)(a1 + 46) = a2;
    *(_WORD *)(a1 + 44) = a3 - a4;
    sub_10063580(a1, a2, a3, a4, 1, a2, a4 + a3);
    sub_10063580(a1, a2, a3, a4, 1, a2, a3 - a4);
    result = v5;
    *(_DWORD *)(a1 + 44) = v5;
  }
  return result;
}

//----- (100660A0) --------------------------------------------------------
char __cdecl sub_100660A0(int a1)
{
  int v1; // eax@3
  int v3; // [sp+0h] [bp-30h]@3
  __int16 v4; // [sp+4h] [bp-2Ch]@1
  char v5; // [sp+8h] [bp-28h]@6
  int v6; // [sp+14h] [bp-1Ch]@1

  v6 = *(_WORD *)(a1 + 10);
  v4 = *(_WORD *)(a1 + 14) - *(_WORD *)(a1 + 10);
  if ( v4 < 0 )
  {
    v6 = *(_WORD *)(a1 + 14);
    v4 = -v4;
  }
  v1 = (signed __int16)(v4 + 1);
  v6 = v1 + (v6 << 16);
  v3 = *(_WORD *)(a1 + 6);
  if ( v3 == 1 )
  {
    LOBYTE(v1) = sub_10066470(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  else if ( v3 == 3 )
  {
    LOBYTE(v1) = sub_10066960(a1, v6, *(_WORD *)(a1 + 8), (int)&v5);
  }
  return v1;
}

//----- (10066150) --------------------------------------------------------
char __cdecl sub_10066150(int a1)
{
  __int16 v1; // ax@1
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@8
  int v5; // [sp+18h] [bp-1Ch]@1

  v5 = *(_WORD *)(a1 + 10);
  v1 = *(_WORD *)(a1 + 14);
  v3 = *(_WORD *)(a1 + 14);
  if ( *(_WORD *)(a1 + 14) )
  {
    if ( v3 < 0 )
    {
      v5 += v3 + 1;
      v3 = 0x8000 - v3;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) > 1 )
    {
      LOBYTE(v1) = a1;
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
        case 2:
          LOBYTE(v1) = sub_100667F0(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
        case 4:
          LOBYTE(v1) = sub_10067120(a1, v5, (int)&v4);
          break;
        default:
          return v1;
      }
    }
    else
    {
      v1 = *(_WORD *)(a1 + 4);
      switch ( *(_WORD *)(a1 + 4) )
      {
        case 0:
          LOBYTE(v1) = sub_100667F0(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 2:
          LOBYTE(v1) = sub_100667F0(a1, v5, *(_WORD *)(a1 + 8));
          break;
        case 3:
          LOBYTE(v1) = sub_10066960(a1, v5, *(_WORD *)(a1 + 8), (int)&v4);
          break;
        case 4:
          LOBYTE(v1) = (unsigned int)sub_10066D90(a1, v5, *(_WORD *)(a1 + 8), *(int **)(a1 + 64));
          break;
        default:
          return v1;
      }
    }
  }
  return v1;
}

//----- (100662C0) --------------------------------------------------------
int __cdecl sub_100662C0(int a1)
{
  int result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  result = a1;
  v2 = *(_WORD *)(a1 + 4);
  if ( *(_WORD *)(a1 + 4) && v2 != 2 )
  {
    if ( v2 == 3 )
      result = sub_10066A70(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  else
  {
    result = sub_10066870(a1, *(_WORD *)(a1 + 10), *(_WORD *)(a1 + 8));
  }
  return result;
}

//----- (10066320) --------------------------------------------------------
char *__cdecl sub_10066320(int a1)
{
  char *result; // eax@1
  int v2; // ST18_4@3
  int v3; // [sp+8h] [bp-2Ch]@1
  char v4; // [sp+Ch] [bp-28h]@7
  int v5; // [sp+1Ch] [bp-18h]@1

  v5 = *(_WORD *)(a1 + 8);
  result = (char *)*(_WORD *)(a1 + 12);
  v3 = *(_WORD *)(a1 + 12);
  if ( *(_WORD *)(a1 + 12) )
  {
    if ( v3 < 0 )
    {
      v2 = -v3;
      v5 = v5 - v2 + 1;
      v3 = v2 + 0x8000;
    }
    v5 = v3 + (v5 << 16);
    if ( (signed int)*(_WORD *)(a1 + 2) <= 1 )
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_100668E0(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
          result = (char *)sub_10066B60(a1, v5, *(_WORD *)(a1 + 10), (int)&v4);
          break;
        case 4u:
          result = sub_10066ED0(a1, v5, *(_WORD *)(a1 + 10), *(int **)(a1 + 64));
          break;
        default:
          return result;
      }
    }
    else
    {
      result = (char *)*(_WORD *)(a1 + 4);
      switch ( result )
      {
        case 0u:
        case 2u:
          result = (char *)sub_100668E0(a1, v5, *(_WORD *)(a1 + 10));
          break;
        case 3u:
        case 4u:
          result = (char *)sub_10067260(a1, v5, (int)&v4);
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

//----- (10066470) --------------------------------------------------------
unsigned int __cdecl sub_10066470(int a1, signed int a2, int a3, int a4)
{
  unsigned int result; // eax@1

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  result = sub_10066530(a1, a4);
  if ( *(_DWORD *)a4 )
  {
    *(_DWORD *)(a4 + 32) = (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) >> (*(_BYTE *)(a4 + 12) & 0x1F)) | (*(_DWORD *)(*(_DWORD *)(a1 + 60) + 4 * (a3 & 0x1F)) << (32 - (*(_BYTE *)(a4 + 12) & 0x1F)));
    *(_DWORD *)(a4 + 36) = 1;
    result = sub_10066650(a1, a4);
  }
  return result;
}

//----- (10066530) --------------------------------------------------------
int __cdecl sub_10066530(int a1, int a2)
{
  int result; // eax@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 26) - *(_DWORD *)(a2 + 12);
  if ( *(_DWORD *)(a2 + 24) <= 0
    || (*(_DWORD *)(a2 + 12) += *(_DWORD *)(a2 + 24),
        result = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24),
        *(_DWORD *)(a2 + 20) = result,
        *(_DWORD *)(a2 + 20) > 0) )
  {
    result = *(_WORD *)(a1 + 26);
    if ( result + *(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
    {
      if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12) <= *(_DWORD *)(a2 + 20) )
        *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30) - *(_WORD *)(a2 + 12);
      result = a1;
      if ( (signed int)*(_WORD *)(a1 + 24) <= *(_DWORD *)(a2 + 16) )
      {
        result = *(_WORD *)(a1 + 24);
        if ( result + *(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
        {
          *(_DWORD *)(a2 + 24) &= ~(*(_DWORD *)(a2 + 24) >> 31);
          *(_BYTE *)a1 = 1;
          result = a2;
          *(_DWORD *)a2 = 1;
        }
      }
    }
  }
  return result;
}

//----- (10066650) --------------------------------------------------------
unsigned int __cdecl sub_10066650(int a1, int a2)
{
  unsigned int v2; // ST04_4@1
  __int16 v3; // ST0C_2@2
  char v4; // ST04_1@9
  unsigned int result; // eax@9
  unsigned int v6; // [sp+0h] [bp-1Ch]@1
  int v7; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+10h] [bp-Ch]@1
  unsigned int v10; // [sp+14h] [bp-8h]@1
  unsigned int *v11; // [sp+18h] [bp-4h]@1

  v9 = *(_DWORD *)(a2 + 20);
  v2 = 8 * *(_DWORD *)(a2 + 12);
  v11 = (unsigned int *)(**(_DWORD **)(a1 + 52)
                       + *(_DWORD *)(a2 + 16) * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                       + 4 * (v2 >> 5));
  v7 = 32 - (v2 & 0x1F);
  v10 = (*v11 >> (31 * v7 & 0x1F)) | (*v11 << (32 - (31 * v7 & 0x1F)));
  v6 = *(_DWORD *)(a2 + 32);
  do
  {
    v8 = 2 * v6 & 3;
    v6 = (v6 >> (*(_BYTE *)(a2 + 36) & 0x1F)) | (v6 << (32 - (*(_BYTE *)(a2 + 36) & 0x1F)));
    v3 = *(_WORD *)(v8 + a1 + 36);
    if ( v3 >= 0 )
      v10 = (v10 >> 8) | (*(_WORD *)(v8 + a1 + 36) << 24);
    else
      v10 = (v10 >> 8) | (v10 << 24);
    if ( --v9 )
    {
      v7 -= 8;
      if ( !v7 )
      {
        *v11 = v10;
        ++v11;
        v7 = 32;
        v10 = *v11;
      }
    }
  }
  while ( v9 );
  v4 = v7 - 8;
  result = v10 >> (v4 & 0x1F);
  *v11 = result | (v10 << (32 - (v4 & 0x1F)));
  return result;
}

//----- (100667F0) --------------------------------------------------------
int __cdecl sub_100667F0(int a1, int a2, int a3)
{
  return sub_100674B0(
           a1,
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 34) - 1 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1)) << 16) + *(_WORD *)(a1 + 32));
}

//----- (10066870) --------------------------------------------------------
int __cdecl sub_10066870(int a1, int a2, int a3)
{
  return sub_100674B0(
           a1,
           (a2 << 16) + *(_WORD *)(a1 + 34) - ((unsigned int)*(_WORD *)(a1 + 34) >> 1 << 16),
           (a3 << 16) + *(_WORD *)(a1 + 32) - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (100668E0) --------------------------------------------------------
int __cdecl sub_100668E0(int a1, int a2, int a3)
{
  return sub_100674B0(
           a1,
           ((a3 - ((unsigned int)*(_WORD *)(a1 + 34) >> 1)) << 16) + *(_WORD *)(a1 + 34),
           (a2 & 0xFFFF7FFF) + *(_WORD *)(a1 + 32) - 1 - ((unsigned int)*(_WORD *)(a1 + 32) >> 1 << 16));
}

//----- (10066960) --------------------------------------------------------
char __cdecl sub_10066960(int a1, signed int a2, int a3, int a4)
{
  char result; // al@2
  int v5; // [sp+0h] [bp-Ch]@7
  unsigned int v6; // [sp+4h] [bp-8h]@5
  _BYTE *v7; // [sp+8h] [bp-4h]@5

  *(_DWORD *)(a4 + 20) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 12) = a2 >> 16;
  *(_DWORD *)(a4 + 16) = a3;
  if ( *(_DWORD *)(a4 + 20) == 1 )
  {
    result = sub_10066A70(a1, *(_DWORD *)(a4 + 12), *(_DWORD *)(a4 + 16));
  }
  else
  {
    result = sub_10066530(a1, a4);
    if ( *(_DWORD *)a4 )
    {
      result = a1;
      if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
      {
        v7 = (_BYTE *)(*(_DWORD *)(a4 + 12) + **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
        v6 = *(_DWORD *)(a4 + 20);
        if ( v6 <= 0x10 )
        {
          v5 = *(&dword_10129158 + *(_WORD *)(a1 + 38));
          do
          {
            result = v5;
            *v7++ = v5;
            --v6;
          }
          while ( v6 );
        }
        else
        {
          result = (unsigned int)memset(v7, *(&dword_10129158 + *(_WORD *)(a1 + 38)), v6);
        }
      }
    }
  }
  return result;
}

//----- (10066A70) --------------------------------------------------------
int __cdecl sub_10066A70(int a1, signed int a2, signed int a3)
{
  int result; // eax@1
  _BYTE *v4; // ST08_4@5
  unsigned int v5; // [sp+18h] [bp+Ch]@5

  result = a1;
  if ( *(_WORD *)(a1 + 26) <= a2 )
  {
    result = *(_WORD *)(a1 + 26) + *(_WORD *)(a1 + 30);
    if ( result > a2 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 24) <= a3 )
      {
        result = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28);
        if ( result > a3 )
        {
          *(_BYTE *)a1 = 1;
          v5 = 8 * a2;
          v4 = (_BYTE *)(**(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3));
          result = **(_DWORD **)(a1 + 52) + a3 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10) + (v5 >> 3);
          *v4 = ((unsigned __int64)*(_WORD *)(a1 + 38) << (v5 & 7)) | ~(unsigned __int8)(255i64 << (v5 & 7)) & *v4;
        }
      }
    }
  }
  return result;
}

//----- (10066B60) --------------------------------------------------------
int __cdecl sub_10066B60(int a1, signed int a2, int a3, int a4)
{
  int result; // eax@1
  _BYTE *v5; // [sp+Ch] [bp-4h]@2
  int v6; // [sp+18h] [bp+8h]@1

  *(_DWORD *)(a4 + 8) = a2 & 0x7FFF;
  *(_DWORD *)(a4 + 16) = a2 >> 16;
  *(_DWORD *)(a4 + 12) = a3;
  result = sub_10066C60(a1, a4);
  v6 = result;
  if ( *(_DWORD *)(a4 + 4) )
  {
    v5 = (_BYTE *)((a3 & 0x1FFFFFFF)
                 + *(_DWORD *)(a4 + 16) * *(_WORD *)(*(_DWORD *)(result + 52) + 10)
                 + **(_DWORD **)(result + 52));
    do
    {
      *v5;
      *v5 = *(_WORD *)(v6 + 38);
      v5 += *(_WORD *)(*(_DWORD *)(v6 + 52) + 10);
      result = *(_DWORD *)(a4 + 8) - 1;
      *(_DWORD *)(a4 + 8) = result;
    }
    while ( *(_DWORD *)(a4 + 8) > 0 );
  }
  return result;
}

//----- (10066C60) --------------------------------------------------------
int __cdecl sub_10066C60(int a1, int a2)
{
  int result; // eax@3

  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 24) - *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 28) <= 0
    || (*(_DWORD *)(a2 + 16) += *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) -= *(_DWORD *)(a2 + 28),
        *(_DWORD *)(a2 + 8) > 0) )
  {
    if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) > *(_DWORD *)(a2 + 16) )
    {
      if ( *(_WORD *)(a1 + 24) + (signed int)*(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16) <= *(_DWORD *)(a2 + 8) )
        *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 24) + *(_WORD *)(a1 + 28) - *(_WORD *)(a2 + 16);
      if ( (signed int)*(_WORD *)(a1 + 26) <= *(_DWORD *)(a2 + 12) )
      {
        if ( *(_WORD *)(a1 + 26) + (signed int)*(_WORD *)(a1 + 30) > *(_DWORD *)(a2 + 12) )
        {
          *(_DWORD *)(a2 + 28) &= ~(*(_DWORD *)(a2 + 28) >> 31);
          *(_BYTE *)a1 = 1;
          *(_DWORD *)(a2 + 4) = 1;
          result = a1;
        }
        else
        {
          result = a1;
        }
      }
      else
      {
        result = a1;
      }
    }
    else
    {
      result = a1;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10066D90) --------------------------------------------------------
char *__cdecl sub_10066D90(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-30h]@1
  signed int v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+20h] [bp-10h]@1
  int v10; // [sp+24h] [bp-Ch]@1
  char *v11; // [sp+28h] [bp-8h]@1
  int v12; // [sp+2Ch] [bp-4h]@1
  signed int v13; // [sp+3Ch] [bp+Ch]@1
  int v14; // [sp+3Ch] [bp+Ch]@4

  v11 = &v5;
  v8 = a2 & 0x7FFF;
  v6 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v8 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v13 = (a2 - *((_DWORD *)v11 + 5)) << 16;
  if ( v13 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v13 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v13 + 1;
  sub_10066530(a1, (int)v11);
  result = v11;
  if ( *(_DWORD *)v11 )
  {
    v14 = *((_DWORD *)v11 + 6) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v14 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v14 & 0x1F)));
    result = (char *)sub_10066650(a1, (int)v11);
  }
  return result;
}

//----- (10066ED0) --------------------------------------------------------
char *__cdecl sub_10066ED0(int a1, signed int a2, int a3, int *a4)
{
  char *result; // eax@3
  char v5; // [sp+0h] [bp-3Ch]@1
  int v6; // [sp+8h] [bp-34h]@1
  int v7; // [sp+Ch] [bp-30h]@1
  signed int v8; // [sp+10h] [bp-2Ch]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  int v10; // [sp+24h] [bp-18h]@1
  char *v11; // [sp+28h] [bp-14h]@1
  int v12; // [sp+2Ch] [bp-10h]@1
  __int16 v13; // [sp+30h] [bp-Ch]@5
  char v14; // [sp+37h] [bp-5h]@6
  char *v15; // [sp+38h] [bp-4h]@4
  int v16; // [sp+44h] [bp+8h]@3
  signed int v17; // [sp+48h] [bp+Ch]@1
  int v18; // [sp+48h] [bp+Ch]@4
  unsigned int v19; // [sp+4Ch] [bp+10h]@4
  int v20; // [sp+4Ch] [bp+10h]@4

  v11 = &v5;
  v6 = a2 & 0x7FFF;
  v8 = a2 >> 16;
  v7 = a3;
  v9 = *a4;
  v12 = *(_BYTE *)(a1 + 1);
  v10 = v6 + v12;
  *(_BYTE *)(a1 + 1) = a2 + v12;
  v17 = (a2 - *((_DWORD *)v11 + 2)) << 16;
  if ( v17 < 0 )
  {
    v12 = *((_DWORD *)v11 + 9) - 1;
    v17 >>= 30;
  }
  *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v12 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v12 & 0x1F)));
  *((_DWORD *)v11 + 9) = v17 + 1;
  v16 = sub_10066C60(a1, (int)v11);
  result = v11;
  if ( *((_DWORD *)v11 + 1) )
  {
    v18 = *((_DWORD *)v11 + 7) * *((_DWORD *)v11 + 9);
    *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v18 & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v18 & 0x1F)));
    v19 = 8 * a3;
    v15 = (char *)(**(_DWORD **)(v16 + 52) + (v19 >> 3) + *((_DWORD *)v11 + 4) * *(_WORD *)(*(_DWORD *)(v16 + 52) + 10));
    v20 = v19 & 7;
    do
    {
      v12 = 2 * *((_DWORD *)v11 + 8) & 3;
      *((_DWORD *)v11 + 8) = (*((_DWORD *)v11 + 8) >> (v11[36] & 0x1F)) | (*((_DWORD *)v11 + 8) << (32 - (v11[36] & 0x1F)));
      v12 += v16 + 36;
      v13 = *(_WORD *)v12;
      if ( v13 >= 0 )
      {
        v14 = *v15;
        v13 <<= v20;
        v14 &= ~(unsigned __int8)(255 << v20);
        v14 |= v13;
        *v15 = v14;
      }
      v15 += *(_WORD *)(*(_DWORD *)(v16 + 52) + 10);
      --*((_DWORD *)v11 + 2);
      result = v11;
    }
    while ( *((_DWORD *)v11 + 2) );
  }
  return result;
}

//----- (10067120) --------------------------------------------------------
int __cdecl sub_10067120(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  unsigned int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  int *v10; // [sp+10h] [bp-4h]@1

  v7 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 16) = v7 >> 1;
  *(_DWORD *)(a3 + 12) = a2 - (*(_DWORD *)(a3 + 16) * *(_WORD *)(a1 + 18) << 16);
  *(_DWORD *)(a3 + 16) = *(_WORD *)(a1 + 8) - *(_DWORD *)(a3 + 16);
  v9 = *(_WORD *)(a1 + 18) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = -256 * (8 * (*(_DWORD *)(a3 + 12) << 16 >> 31) + 4);
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v10 = *(int **)(a1 + 64);
  if ( v5 )
    v10 = (int *)((char *)v10 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10066D90(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), v10);
    else
      sub_10066960(a1, a2, *(_DWORD *)(a3 + 16), a3);
    ++*(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 12) += v9;
    result = (int)v10 + (v8 >> 8);
    v10 = (int *)((char *)v10 + (v8 >> 8));
    --v7;
  }
  while ( v7 );
  return result;
}

//----- (10067260) --------------------------------------------------------
int __cdecl sub_10067260(int a1, signed int a2, int a3)
{
  int v3; // ST18_4@1
  int v4; // ecx@1
  bool v5; // sf@1
  int result; // eax@6
  int v7; // [sp+4h] [bp-10h]@1
  signed int v8; // [sp+8h] [bp-Ch]@1
  int *v9; // [sp+Ch] [bp-8h]@1
  unsigned int v10; // [sp+10h] [bp-4h]@1

  v10 = *(_WORD *)(a1 + 2);
  *(_DWORD *)(a3 + 12) = v10 >> 1;
  *(_DWORD *)(a3 + 16) = a2 - (*(_DWORD *)(a3 + 12) * *(_WORD *)(a1 + 16) << 16);
  *(_DWORD *)(a3 + 12) = *(_WORD *)(a1 + 10) - *(_DWORD *)(a3 + 12);
  v7 = *(_WORD *)(a1 + 16) << 16;
  v3 = *(_BYTE *)(a1 + 1);
  v4 = (8 * (*(_DWORD *)(a3 + 16) << 16 >> 31) + 4) << 8;
  v5 = v3 + v4 < 0;
  v8 = v3 + v4;
  v9 = *(int **)(a1 + 64);
  if ( v5 )
    v9 = (int *)((char *)v9 + -(*(_WORD *)(a1 + 2) * (v8 >> 8)) - 4);
  do
  {
    *(_BYTE *)(a1 + 1) = v8;
    if ( *(_WORD *)(a1 + 4) == 4 )
      sub_10066ED0(a1, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 12), v9);
    else
      sub_10066B60(a1, a2, *(_DWORD *)(a3 + 12), a3);
    ++*(_DWORD *)(a3 + 12);
    *(_DWORD *)(a3 + 16) += v7;
    result = (int)v9 + (v8 >> 8);
    v9 = (int *)((char *)v9 + (v8 >> 8));
    --v10;
  }
  while ( v10 );
  return result;
}

//----- (100673A0) --------------------------------------------------------
int __cdecl sub_100673A0(int a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int result; // eax@17

  if ( a2 < 0 )
    a2 = 0;
  if ( a3 < 0 )
    a3 = 0;
  if ( a4 < 1 )
    a4 = 1;
  if ( a5 < 1 )
    a5 = 1;
  if ( a2 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a2 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - 1;
  if ( a4 + a2 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) )
    a4 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 6) - a2;
  if ( a3 >= (signed int)*(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a3 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - 1;
  if ( a5 + a3 > *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) )
    a5 = *(_WORD *)(*(_DWORD *)(a1 + 52) + 4) - a3;
  *(_WORD *)(a1 + 26) = a2;
  HIWORD(result) = HIWORD(a1);
  *(_WORD *)(a1 + 30) = a4;
  LOWORD(result) = a3;
  *(_WORD *)(a1 + 24) = a3;
  *(_WORD *)(a1 + 28) = a5;
  return result;
}

//----- (100674B0) --------------------------------------------------------
int __cdecl sub_100674B0(int a1, signed int a2, signed int a3)
{
  int result; // eax@5
  int v4; // edx@10
  unsigned int v5; // ST04_4@15
  unsigned int v6; // ST20_4@16
  int v7; // ST28_4@26
  unsigned int v8; // ST18_4@32
  int v9; // [sp+0h] [bp-44h]@28
  unsigned int v10; // [sp+4h] [bp-40h]@15
  int v11; // [sp+8h] [bp-3Ch]@1
  int v12; // [sp+Ch] [bp-38h]@1
  int v13; // [sp+10h] [bp-34h]@31
  unsigned int v14; // [sp+14h] [bp-30h]@13
  int v15; // [sp+1Ch] [bp-28h]@30
  int v16; // [sp+20h] [bp-24h]@17
  int i; // [sp+20h] [bp-24h]@32
  int v18; // [sp+20h] [bp-24h]@34
  int v19; // [sp+24h] [bp-20h]@1
  unsigned int v20; // [sp+28h] [bp-1Ch]@14
  int v21; // [sp+2Ch] [bp-18h]@15
  unsigned int *v22; // [sp+30h] [bp-14h]@15
  int *v23; // [sp+30h] [bp-14h]@32
  int v24; // [sp+34h] [bp-10h]@15
  unsigned int v25; // [sp+38h] [bp-Ch]@15
  unsigned int *v26; // [sp+3Ch] [bp-8h]@13
  int v27; // [sp+40h] [bp-4h]@1

  v11 = (signed __int16)a3;
  v27 = a3 >> 16;
  v12 = (signed __int16)a2;
  v19 = a2 >> 16;
  if ( *(_WORD *)(a1 + 26) > a2 >> 16 )
  {
    v12 = (signed __int16)a2 - (*(_WORD *)(a1 + 26) - v19);
    v19 = *(_WORD *)(a1 + 26);
  }
  if ( *(_WORD *)(a1 + 24) > v27 )
  {
    v11 = (signed __int16)a3 - (*(_WORD *)(a1 + 24) - v27);
    v27 = *(_WORD *)(a1 + 24);
  }
  result = *(_WORD *)(a1 + 30);
  if ( result + *(_WORD *)(a1 + 26) > v19 )
  {
    if ( *(_WORD *)(a1 + 30) + (signed int)*(_WORD *)(a1 + 26) - v19 <= v12 )
      v12 = *(_WORD *)(a1 + 30) + *(_WORD *)(a1 + 26) - v19;
    result = *(_WORD *)(a1 + 28);
    if ( result + *(_WORD *)(a1 + 24) > v27 )
    {
      result = a1;
      if ( *(_WORD *)(a1 + 28) + (signed int)*(_WORD *)(a1 + 24) - v27 <= v11 )
      {
        v4 = *(_WORD *)(a1 + 28);
        result = v4 + *(_WORD *)(a1 + 24) - v27;
        v11 = v4 + *(_WORD *)(a1 + 24) - v27;
      }
      if ( v11 > 0 && v12 > 0 )
      {
        *(_BYTE *)a1 = 1;
        v14 = 32 - (8 * v19 & 0x1F);
        v26 = (unsigned int *)(v27 * *(_WORD *)(*(_DWORD *)(a1 + 52) + 10)
                             + **(_DWORD **)(a1 + 52)
                             + 4 * ((unsigned int)(8 * v19) >> 5));
        if ( *(_WORD *)(a1 + 4) == 2 )
        {
          v9 = v11;
          if ( v14 >= 8 * v12 )
            v14 = 8 * v12;
          v15 = 8 * v12 - v14;
          result = *(_WORD *)(a1 + 38) << 16;
          if ( !(*(_WORD *)(a1 + 38) & 0x8000) )
          {
            v13 = *(&dword_10129158 + *(_WORD *)(a1 + 38));
            do
            {
              v8 = ~(((unsigned int)(0xFFFFFFFFui64 >> v14) >> ((32 - (8 * v19 & 0x1F) - v14) & 0x1F)) | ((unsigned int)(0xFFFFFFFFui64 >> v14) << (32 - ((32 - (8 * v19 & 0x1F) - v14) & 0x1F))));
              *v26 = *v26 & ~v8 | v13 & v8;
              v23 = (int *)(v26 + 1);
              for ( i = v15 - 32; i >= 0; i -= 32 )
              {
                *v23 = v13;
                ++v23;
              }
              v18 = i + 32;
              if ( v18 )
                *v23 = *v23 & ~((1 << v18) - 1) | v13 & ((1 << v18) - 1);
              result = *(_DWORD *)(a1 + 52);
              v26 = (unsigned int *)((char *)v26 + *(_WORD *)(result + 10));
              --v9;
            }
            while ( v9 );
          }
        }
        else
        {
          v20 = (v19 << 16) & 0x1FFFFF | v11 | (v27 << 27);
          do
          {
            v5 = *(_DWORD *)(*(_DWORD *)(a1 + 60) + (v20 >> 25));
            v10 = (v5 >> ((v20 >> 16) & 0x1F)) | (v5 << (32 - ((v20 >> 16) & 0x1F)));
            v22 = v26;
            v21 = 32 - (8 * v19 & 0x1F);
            v25 = (*v26 >> (31 * v14 & 0x1F)) | (*v26 << (32 - (31 * v14 & 0x1F)));
            v24 = v12;
            do
            {
              v6 = v10 << 31;
              v10 = (v10 << 31) | (v10 >> 1);
              if ( v6 >> 31 )
                v16 = *(_WORD *)(a1 + 38);
              else
                v16 = *(_WORD *)(a1 + 36);
              if ( (signed __int16)v16 >= 0 )
                v25 = (v16 << 24) | (v25 >> 8);
              else
                v25 = (v25 >> 8) | (v25 << 24);
              if ( --v24 )
              {
                v21 -= 8;
                if ( !v21 )
                {
                  *v22 = v25;
                  ++v22;
                  v21 = 32;
                  v25 = *v22;
                }
              }
            }
            while ( v24 );
            *v22 = (v25 >> ((v21 - 8) & 0x1F)) | (v25 << (32 - ((v21 - 8) & 0x1F)));
            v26 = (unsigned int *)((char *)v26 + *(_WORD *)(*(_DWORD *)(a1 + 52) + 10));
            v7 = v20 + 0x8000000;
            result = v7 - 1;
            v20 = v7 - 1;
          }
          while ( v20 << 16 );
        }
      }
    }
  }
  return result;
}

//----- (10067980) --------------------------------------------------------
int __cdecl sub_10067980(int a1)
{
  signed __int64 v1; // rax@1
  unsigned int v2; // ebx@1
  signed __int64 v3; // rdi@1
  unsigned __int64 v4; // rax@1

  v1 = (signed int)(1686629713i64 * a1 >> 29) * (signed __int64)(signed int)(1686629713i64 * a1 >> 29);
  v2 = v1 >> 30;
  v3 = -2147483648i64 * (v2 >> 1) + 0x7FFFFFFFFFFFFFFFi64;
  v4 = (v2 >> 1) * (unsigned __int64)v2;
  return (-1184i64 * (((HIDWORD(v4) * (unsigned __int64)v2 >> 32) * v2 >> 32) * v2 >> 32)
        + 106522 * ((HIDWORD(v4) * (unsigned __int64)v2 >> 32) * v2 >> 32)
        + -5965232i64 * (HIDWORD(v4) * (unsigned __int64)v2 >> 32)
        + 178956971i64 * SHIDWORD(v4)
        + v3) >> 32;
}

//----- (10067A90) --------------------------------------------------------
int __cdecl sub_10067A90(int a1, _DWORD *a2)
{
  _DWORD *v2; // ecx@0
  int v3; // eax@1
  __int64 v4; // ST30_8@1
  unsigned int v5; // eax@1
  unsigned int v6; // ST28_4@1
  unsigned int v7; // ST20_4@1
  __int64 v8; // rax@1
  unsigned __int64 v9; // ST3C_8@1
  unsigned __int64 v10; // rax@1
  signed __int64 v11; // rdi@1
  unsigned __int64 v12; // ST3C_8@1
  __int64 v13; // ST20_8@1
  unsigned __int64 v14; // ST3C_8@1
  signed __int64 v15; // kr00_8@1
  signed __int64 v16; // rdi@1
  unsigned __int64 v17; // ST3C_8@1
  int result; // eax@1

  v3 = 1686629713i64 * a1 >> 29;
  v4 = v3;
  v5 = v3 * (signed __int64)v3 >> 30;
  v6 = v5;
  v7 = v5 >> 1;
  v8 = v5 >> 1;
  v9 = __PAIR__(HIDWORD(v8), v7);
  v10 = __PAIR__(HIDWORD(v8), v7) << 31;
  v11 = -715827883i64 * v9 + 0x7FFFFFFFFFFFFFFFi64;
  v12 = v7 * (unsigned __int64)v6;
  v13 = SHIDWORD(v12);
  v14 = HIDWORD(v12) * (unsigned __int64)v6;
  v15 = -5965232i64 * SHIDWORD(v14) + 178956971i64 * (signed int)v13 + 0x7FFFFFFFFFFFFFFFi64 - v10;
  v16 = -852176i64 * SHIDWORD(v14) + 35791394 * v13 + v11;
  v17 = HIDWORD(v14) * (unsigned __int64)v6;
  result = (signed int)((unsigned __int64)(-108i64 * SHIDWORD(v17) + 11836i64 * SHIDWORD(v17) + v16) >> 32) * v4 >> 31;
  *v2 = result;
  *a2 = (unsigned __int64)(-1184i64 * SHIDWORD(v17) + 106522i64 * SHIDWORD(v17) + v15) >> 32;
  return result;
}

//----- (10067CA0) --------------------------------------------------------
int __cdecl sub_10067CA0(int a1)
{
  int v1; // eax@1
  __int64 v2; // ST28_8@1
  signed __int64 v3; // rax@1
  unsigned int v4; // ebx@1
  signed __int64 v5; // rdi@1
  unsigned __int64 v6; // rax@1

  v1 = 1686629713i64 * a1 >> 29;
  v2 = v1;
  v3 = v1 * (signed __int64)v1;
  v4 = v3 >> 30;
  v5 = -715827883i64 * (v4 >> 1) + 0x7FFFFFFFFFFFFFFFi64;
  v6 = (v4 >> 1) * (unsigned __int64)v4;
  return (signed int)((-108i64 * (((HIDWORD(v6) * (unsigned __int64)v4 >> 32) * v4 >> 32) * v4 >> 32)
                     + 11836 * ((HIDWORD(v6) * (unsigned __int64)v4 >> 32) * v4 >> 32)
                     + -852176i64 * (HIDWORD(v6) * (unsigned __int64)v4 >> 32)
                     + 35791394i64 * SHIDWORD(v6)
                     + v5) >> 32)
       * v2 >> 31;
}

//----- (10067E30) --------------------------------------------------------
int __cdecl sub_10067E30(int a1, int *a2, int *a3)
{
  int v3; // esi@1
  int v4; // esi@2
  int v5; // edx@2
  int result; // eax@4
  int v7; // [sp+4h] [bp-4h]@1

  sub_10067A90(((a1 + 0x20000000) & 0x3FFFFFFF) - 0x20000000, &v7);
  v3 = ((a1 + 0x20000000) >> 30) & 3;
  if ( v3 )
  {
    v4 = v3 - 1;
    v5 = v7;
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        *a2 = -a1;
        result = (int)a3;
        *a3 = -v5;
      }
      else
      {
        result = (int)a2;
        *a2 = -v7;
        *a3 = a1;
      }
    }
    else
    {
      *a2 = v7;
      result = -a1;
      *a3 = -a1;
    }
  }
  else
  {
    result = a1;
    *a2 = a1;
    *a3 = v7;
  }
  return result;
}

//----- (10067ED0) --------------------------------------------------------
int __cdecl sub_10067ED0(int a1)
{
  int v1; // ecx@1
  int v2; // ecx@2
  int result; // eax@4
  int v4; // [sp-4h] [bp-4h]@3
  int v5; // [sp+4h] [bp+4h]@1

  v5 = a1 + 0x40000000;
  v1 = ((v5 + 0x20000000) >> 30) & 3;
  if ( v1 )
  {
    v2 = v1 - 1;
    if ( v2 )
    {
      v4 = ((v5 + 0x20000000) & 0x3FFFFFFF) - 0x20000000;
      if ( v2 == 1 )
        result = -sub_10067CA0(v4);
      else
        result = -sub_10067980(v4);
    }
    else
    {
      result = sub_10067980(((v5 + 0x20000000) & 0x3FFFFFFF) - 0x20000000);
    }
  }
  else
  {
    result = sub_10067CA0(((v5 + 0x20000000) & 0x3FFFFFFF) - 0x20000000);
  }
  return result;
}

//----- (10067EF0) --------------------------------------------------------
int __cdecl sub_10067EF0(signed int a1, signed int a2)
{
  int result; // eax@2

  if ( a2 > 0 )
  {
    result = a2 * (a1 / a2);
    if ( a1 == result )
    {
      result = a1;
    }
    else if ( a1 < 0 )
    {
      result -= a2;
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10067F30) --------------------------------------------------------
double __cdecl sub_10067F30(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@3
  bool v6; // c0@7
  bool v7; // c3@7
  float v8; // [sp+8h] [bp+8h]@3
  float v9; // [sp+8h] [bp+8h]@5
  float v10; // [sp+8h] [bp+8h]@6
  float v11; // [sp+8h] [bp+8h]@8

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v4 = a1;
    v8 = a1 / v2;
    v5 = v8;
    if ( v8 < -2100000000.0 || v5 > 2100000000.0 )
    {
      result = a1;
    }
    else
    {
      v9 = (double)(signed int)v5 * v2;
      if ( v9 == v4 || (v6 = 0.0 < v4, v7 = 0.0 == v4, v4 = v9, v6 || v7) )
      {
        v10 = v4;
        result = v10;
      }
      else
      {
        v11 = v9 - v2;
        result = v11;
      }
    }
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10067FD0) --------------------------------------------------------
double __cdecl sub_10067FD0(double a1, double a2)
{
  double result; // st7@1
  double v3; // [sp+0h] [bp-8h]@2

  result = 0.0;
  if ( a2 > 0.0 )
  {
    v3 = a2 + a2;
    result = fmod(a1, v3);
    if ( a2 > result )
    {
      if ( -a2 > result )
        result = result + v3;
    }
    else
    {
      result = result - v3;
    }
  }
  return result;
}

//----- (10068030) --------------------------------------------------------
double __cdecl sub_10068030(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  double v4; // st6@3
  double v5; // st5@5
  float v6; // [sp+8h] [bp+8h]@3
  float v7; // [sp+8h] [bp+8h]@3
  float v8; // [sp+8h] [bp+8h]@4
  float v9; // [sp+8h] [bp+8h]@6

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    v6 = v2 + v2;
    v4 = v6;
    v7 = a1 - (double)(signed int)(a1 / v6) * v6;
    if ( v7 < v2 )
    {
      v5 = v2;
      result = v7;
      if ( -v5 > v7 )
      {
        v9 = result + v4;
        result = v9;
      }
    }
    else
    {
      v8 = v7 - v4;
      result = v8;
    }
  }
  else
  {
    result = 0.0;
  }
  return result;
}

//----- (100680B0) --------------------------------------------------------
void __cdecl sub_100680B0(double a1)
{
  sub_10067FD0(a1, 3.1415926535898);
}

//----- (100680D0) --------------------------------------------------------
double __cdecl sub_100680D0(float a1)
{
  double result; // st7@3

  if ( a1 == -3.141592741012573 || a1 == 3.141592741012573 )
    result = -3.1415925;
  else
    result = sub_10068030(a1, 3.1415927);
  return result;
}

//----- (10068110) --------------------------------------------------------
int __cdecl sub_10068110(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(float *)a2 = *(double *)a1;
  *(float *)(a2 + 4) = *(double *)(a1 + 8);
  return result;
}

//----- (10068130) --------------------------------------------------------
int __cdecl sub_10068130(signed int a1, signed int a2)
{
  int result; // eax@2
  int v3; // [sp+4h] [bp-4h]@4

  if ( a2 > 0 )
  {
    if ( a1 >= 0 )
      v3 = a2;
    else
      v3 = -a2;
    result = a2 * (signed int)(((double)v3 * 0.5 + (double)a1) / (double)a2);
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10068180) --------------------------------------------------------
double __cdecl sub_10068180(float a1, float a2)
{
  double v2; // st7@1
  double result; // st7@2
  float v4; // [sp+8h] [bp+8h]@5

  v2 = a2;
  if ( a2 > 0.000001 )
  {
    if ( a1 < 0.0 )
      a2 = -v2;
    v4 = v2 * (double)(signed int)((a1 + a2 * 0.5) / v2);
    result = v4;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100681F0) --------------------------------------------------------
int __cdecl sub_100681F0(float a1)
{
  int result; // eax@2

  if ( a1 <= 0.0 )
  {
    if ( a1 >= 0.0 )
      result = 0;
    else
      result = -1;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10068220) --------------------------------------------------------
int __cdecl sub_10068220(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  *(float *)a3 = cos(a1);
  *(float *)a2 = sin(a1);
  return result;
}

//----- (10068240) --------------------------------------------------------
int __cdecl sub_10068240(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(double *)a2 = *(float *)a1;
  *(double *)(a2 + 8) = *(float *)(a1 + 4);
  return result;
}

//----- (10068260) --------------------------------------------------------
double __cdecl sub_10068260(double a1, double a2)
{
  double result; // st7@1

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707963267949;
      else
        result = 1.5707963267949;
    }
  }
  else
  {
    result = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      result = result + 3.1415926535898;
      sub_100680B0(result);
    }
  }
  return result;
}

//----- (100682D0) --------------------------------------------------------
double __cdecl sub_100682D0(float a1, float a2)
{
  double result; // st7@1
  float v3; // [sp+4h] [bp-4h]@6
  float v4; // [sp+10h] [bp+8h]@7

  result = 0.0;
  if ( a2 == 0.0 )
  {
    if ( a1 != 0.0 )
    {
      if ( a1 <= 0.0 )
        result = -1.5707964;
      else
        result = 1.5707964;
    }
  }
  else
  {
    v3 = atan(a1 / a2);
    if ( a2 < 0.0 )
    {
      v4 = v3 + 3.141592741012573;
      v3 = sub_100680D0(v4);
    }
    result = v3;
  }
  return result;
}

//----- (10068360) --------------------------------------------------------
int __cdecl sub_10068360(unsigned __int8 a1, unsigned int a2)
{
  return dword_10129A98[a1 ^ (unsigned __int8)a2] ^ (a2 >> 8);
}
// 10129A98: using guessed type int dword_10129A98[];

//----- (10068380) --------------------------------------------------------
unsigned int __cdecl sub_10068380(unsigned int *a1, signed int a2, unsigned int a3)
{
  unsigned int *v3; // edx@1
  unsigned int result; // eax@1
  signed int i; // esi@1
  unsigned int v6; // edi@5
  unsigned int v7; // eax@6
  unsigned int v8; // eax@6
  unsigned int v9; // eax@6
  unsigned int v10; // eax@6
  unsigned int v11; // ecx@6
  unsigned int v12; // ecx@6
  unsigned int v13; // ecx@6

  v3 = a1;
  result = a3;
  for ( i = a2; i; --i )
  {
    if ( !((unsigned __int8)v3 & 3) )
      break;
    result = dword_10129A98[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    v3 = (unsigned int *)((char *)v3 + 1);
  }
  if ( i >= 8 )
  {
    v6 = (unsigned int)i >> 3;
    do
    {
      v7 = dword_10129A98[(unsigned __int8)result ^ (unsigned __int8)*v3] ^ (result >> 8);
      v8 = dword_10129A98[(unsigned __int8)v7 ^ (unsigned __int8)(*(_WORD *)v3 >> 8)] ^ (v7 >> 8);
      v9 = dword_10129A98[(unsigned __int8)v8 ^ (unsigned __int8)(*v3 >> 16)] ^ (v8 >> 8);
      v10 = dword_10129A98[(unsigned __int8)v9 ^ (*v3 >> 24)] ^ (v9 >> 8);
      v3 += 2;
      v11 = dword_10129A98[(unsigned __int8)v10 ^ (unsigned __int8)*(v3 - 1)] ^ (v10 >> 8);
      v12 = dword_10129A98[(unsigned __int8)v11 ^ (unsigned __int8)(*((_WORD *)v3 - 2) >> 8)] ^ (v11 >> 8);
      v13 = dword_10129A98[(unsigned __int8)v12 ^ (unsigned __int8)(*(v3 - 1) >> 16)] ^ (v12 >> 8);
      i -= 8;
      --v6;
      result = dword_10129A98[(unsigned __int8)v13 ^ (*(v3 - 1) >> 24)] ^ (v13 >> 8);
    }
    while ( v6 );
  }
  for ( ; i > 0; v3 = (unsigned int *)((char *)v3 + 1) )
  {
    result = dword_10129A98[(unsigned __int8)result ^ *(_BYTE *)v3] ^ (result >> 8);
    --i;
  }
  return result;
}
// 10129A98: using guessed type int dword_10129A98[];

//----- (100684B0) --------------------------------------------------------
int __cdecl sub_100684B0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(float *)a3 = *(float *)a1 + *(float *)a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) + *(float *)(a2 + 4);
  *(float *)(a3 + 8) = *(float *)(a1 + 8) + *(float *)(a2 + 8);
  return result;
}

//----- (100684E0) --------------------------------------------------------
int __cdecl sub_100684E0(float a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(float *)a3 = *(float *)a2 * a1;
  *(float *)(a3 + 4) = *(float *)(a2 + 4) * a1;
  *(float *)(a3 + 8) = a1 * *(float *)(a2 + 8);
  return result;
}

//----- (10068FB6) --------------------------------------------------------
double __cdecl sub_10068FB6(char *String)
{
  return _atof_l(String, 0);
}

//----- (10069C2F) --------------------------------------------------------
size_t __cdecl sub_10069C2F(void *DstBuf, size_t ElementSize, size_t Count, FILE *File)
{
  return fread_s(DstBuf, 0xFFFFFFFF, ElementSize, Count, File);
}

//----- (10069D0E) --------------------------------------------------------
FILE *__cdecl sub_10069D0E(char *a1, char *a2)
{
  return _fsopen(a1, a2, 64);
}

//----- (1006AAB7) --------------------------------------------------------
int __cdecl sub_1006AAB7(int a1, int a2, char a3)
{
  return vscan_fn(sub_10072F0F, a2, 0, &a3);
}
// 1006AA4F: using guessed type int __cdecl vscan_fn(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1006B96A) --------------------------------------------------------
int __cdecl sub_1006B96A(int a1, FILE *a2)
{
  FILE *v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  int v6; // eax@15
  char *v7; // edi@15
  signed __int32 v8; // edi@15
  _BYTE *v9; // eax@20
  __int64 v10; // rax@23
  _WORD *v11; // [sp+4h] [bp-4h]@9

  v2 = a2;
  a2 = (FILE *)_fileno(a2);
  v3 = v2->_flag;
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v3 & 0x10) )
    {
      v2->_flag = v3 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v3 & 0xFFFFFFFE;
  }
  v5 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v5;
  v2->_cnt = 0;
  v11 = 0;
  if ( !(v5 & 0x10C)
    && ((void **)v2 != sub_1006F047() + 8 && (void **)v2 != sub_1006F047() + 16 || !sub_1007702E((signed int)a2)) )
  {
    _getbuf(v2);
  }
  if ( v2->_flag & 0x108 )
  {
    v6 = (int)v2->_base;
    v7 = v2->_ptr;
    v2->_ptr = (char *)(v6 + 1);
    v8 = (signed __int32)&v7[-v6];
    v2->_cnt = v2->_bufsiz - 1;
    if ( v8 <= 0 )
    {
      if ( a2 == (FILE *)-1 || a2 == (FILE *)-2 )
        v9 = &unk_1013AC58;
      else
        v9 = (_BYTE *)(dword_10A09B00[(signed int)a2 >> 5] + (((unsigned __int8)a2 & 0x1F) << 6));
      if ( v9[4] & 0x20 )
      {
        v10 = _lseeki64((int)a2, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v11 = sub_10076F0E((int)a2, v6, v8);
    }
    *v2->_base = a1;
  }
  else
  {
    v8 = 1;
    v11 = sub_10076F0E((int)a2, (int)&a1, 1u);
  }
  if ( v11 != (_WORD *)v8 )
  {
LABEL_27:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 10076FEA: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (1006C4FF) --------------------------------------------------------
int __cdecl sub_1006C4FF(int a1)
{
  int result; // eax@1

  result = a1;
  dword_109FF494 = a1;
  return result;
}
// 109FF494: using guessed type int dword_109FF494;

//----- (1006ED03) --------------------------------------------------------
signed int __cdecl sub_1006ED03(signed int a1)
{
  signed int v1; // edi@6
  void *v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( sub_10079665(a1) == -1
    || (a1 == 1 && *(_BYTE *)(dword_10A09B00[0] + 132) & 1 || a1 == 2 && *(_BYTE *)(dword_10A09B00[0] + 68) & 1)
    && (v1 = sub_10079665(2), sub_10079665(1) == v1)
    || (v2 = (void *)sub_10079665(a1), CloseHandle(v2)) )
  {
    v3 = 0;
  }
  else
  {
    v3 = GetLastError();
  }
  sub_100795E4(a1);
  *(_BYTE *)(dword_10A09B00[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1006B58B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (1006F03E) --------------------------------------------------------
int sub_1006F03E()
{
  return flsall(1);
}
// 1006EF64: using guessed type _DWORD __cdecl flsall(_DWORD);

//----- (1006F047) --------------------------------------------------------
void **sub_1006F047()
{
  return &off_1013A8D0;
}
// 1013A8D0: using guessed type void *off_1013A8D0;

//----- (1006F04D) --------------------------------------------------------
signed int sub_1006F04D()
{
  size_t v0; // eax@1
  void *v1; // eax@6
  signed int result; // eax@8
  int v3; // edx@9
  void **v4; // ecx@9
  signed int v5; // edx@12
  _DWORD *v6; // ecx@12
  int v7; // eax@13

  v0 = dword_10A0AC20;
  if ( !dword_10A0AC20 )
  {
    v0 = 512;
LABEL_5:
    dword_10A0AC20 = v0;
    goto LABEL_6;
  }
  if ( dword_10A0AC20 < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v1 = (void *)_calloc_crt(v0, 4);
  dword_10A09C18 = v1;
  if ( v1 || (dword_10A0AC20 = 20, v1 = (void *)_calloc_crt(0x14u, 4), (dword_10A09C18 = v1) != 0) )
  {
    v3 = 0;
    v4 = &off_1013A8D0;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v3) = v4;
      v4 += 8;
      v3 += 4;
      if ( (signed int)v4 >= (signed int)&byte_1013AB50 )
        break;
      v1 = dword_10A09C18;
    }
    v5 = 0;
    v6 = &unk_1013A8E0;
    do
    {
      v7 = *(_DWORD *)(((v5 & 0x1F) << 6) + dword_10A09B00[v5 >> 5]);
      if ( v7 == -1 || v7 == -2 || !v7 )
        *v6 = -2;
      v6 += 8;
      ++v5;
    }
    while ( (signed int)v6 < (signed int)&unk_1013A940 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 100704A7: using guessed type _DWORD __cdecl _calloc_crt(size_t, _DWORD);
// 1013A8D0: using guessed type void *off_1013A8D0;
// 1013AB50: using guessed type char byte_1013AB50;
// 10A09B00: using guessed type int dword_10A09B00[];
// 10A0AC20: using guessed type int dword_10A0AC20;

//----- (1006F3E6) --------------------------------------------------------
int __cdecl sub_1006F3E6(FILE *a1)
{
  int v1; // eax@3
  int v2; // eax@7
  int v3; // ST10_4@10
  char *v4; // ST0C_4@10
  int v5; // eax@10
  int v6; // eax@10
  int *v7; // edi@15
  _BYTE *v8; // eax@15
  int v9; // eax@20
  char *v10; // ecx@23
  int result; // eax@23

  if ( !a1 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v1 = a1->_flag;
  if ( !(v1 & 0x83) || v1 & 0x40 )
    return -1;
  if ( v1 & 2 )
  {
    a1->_flag = v1 | 0x20;
    return -1;
  }
  v2 = v1 | 1;
  a1->_flag = v2;
  if ( v2 & 0x10C )
    a1->_ptr = a1->_base;
  else
    _getbuf(a1);
  v3 = a1->_bufsiz;
  v4 = a1->_base;
  v5 = _fileno(a1);
  v6 = _read(v5, v4, v3);
  a1->_cnt = v6;
  if ( !v6 || v6 == -1 )
  {
    a1->_flag |= v6 != 0 ? 32 : 16;
    a1->_cnt = 0;
    return -1;
  }
  if ( !(a1->_flag & 0x82) )
  {
    if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
    {
      v8 = &unk_1013AC58;
    }
    else
    {
      v7 = &dword_10A09B00[_fileno(a1) >> 5];
      v8 = (_BYTE *)(*v7 + ((_fileno(a1) & 0x1F) << 6));
    }
    if ( (v8[4] & 0x82) == -126 )
      a1->_flag |= 0x2000u;
  }
  if ( a1->_bufsiz == 512 )
  {
    v9 = a1->_flag;
    if ( v9 & 8 )
    {
      if ( !(v9 & 0x400) )
        a1->_bufsiz = 4096;
    }
  }
  v10 = a1->_ptr;
  --a1->_cnt;
  result = (unsigned __int8)*v10;
  a1->_ptr = v10 + 1;
  return result;
}
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10076FEA: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (1006FEDF) --------------------------------------------------------
int sub_1006FEDF()
{
  int v0; // edi@1
  int i; // esi@1
  char *v2; // eax@3
  int v3; // eax@4
  int v4; // esi@12

  v0 = 0;
  _lock(1);
  for ( i = 0; i < dword_10A0AC20; ++i )
  {
    v2 = (char *)dword_10A09C18 + 4 * i;
    if ( !*(_DWORD *)v2 )
    {
      v4 = 4 * i;
      *(_DWORD *)((char *)dword_10A09C18 + v4) = _malloc_crt(0x38u);
      if ( *(_DWORD *)((char *)dword_10A09C18 + v4) )
      {
        if ( __crtInitCritSecAndSpinCount(*(_DWORD *)((char *)dword_10A09C18 + v4) + 32, 4000) )
        {
          EnterCriticalSection((LPCRITICAL_SECTION)(*(_DWORD *)((char *)dword_10A09C18 + v4) + 32));
          v0 = *(_DWORD *)((char *)dword_10A09C18 + v4);
          *(_DWORD *)(v0 + 12) = 0;
        }
        else
        {
          free(*(void **)((char *)dword_10A09C18 + v4));
          *(_DWORD *)((char *)dword_10A09C18 + v4) = 0;
        }
      }
      break;
    }
    v3 = *(_DWORD *)(*(_DWORD *)v2 + 12);
    if ( !(v3 & 0x83) && (signed __int16)v3 >= 0 )
    {
      if ( (unsigned int)(i - 3) <= 0x10 && !_mtinitlocknum(i + 16) )
        break;
      _lock_file2(i, *((_DWORD *)dword_10A09C18 + i));
      if ( !(*(_BYTE *)(*((_DWORD *)dword_10A09C18 + i) + 12) & 0x83) )
      {
        v0 = *((_DWORD *)dword_10A09C18 + i);
        break;
      }
      _unlock_file2(i, *((_DWORD *)dword_10A09C18 + i));
    }
  }
  if ( v0 )
  {
    *(_DWORD *)(v0 + 12) &= 0x8000u;
    *(_DWORD *)(v0 + 4) = 0;
    *(_DWORD *)(v0 + 8) = 0;
    *(_DWORD *)v0 = 0;
    *(_DWORD *)(v0 + 28) = 0;
    *(_DWORD *)(v0 + 16) = -1;
  }
  _unlock(1);
  return v0;
}
// 1006F15A: using guessed type _DWORD __cdecl _lock_file2(_DWORD, _DWORD);
// 1006F1BE: using guessed type _DWORD __cdecl _unlock_file2(_DWORD, _DWORD);
// 1007502E: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 10075043: using guessed type _DWORD __cdecl _mtinitlocknum(_DWORD);
// 10075106: using guessed type _DWORD __cdecl _lock(_DWORD);
// 1007A805: using guessed type _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD);
// 10A0AC20: using guessed type int dword_10A0AC20;

//----- (10070214) --------------------------------------------------------
signed int __cdecl sub_10070214(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_109FF4F0 )
  {
    *a1 = dword_109FF4F0;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 109FF4F0: using guessed type int dword_109FF4F0;

//----- (1007024B) --------------------------------------------------------
signed int __cdecl sub_1007024B(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 && dword_109FF4F0 )
  {
    *a1 = dword_109FF4FC;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 109FF4F0: using guessed type int dword_109FF4F0;
// 109FF4FC: using guessed type int dword_109FF4FC;

//----- (100707DE) --------------------------------------------------------
void sub_100707DE()
{
  void **v0; // esi@1
  void *v1; // edi@2
  unsigned int i; // eax@3

  v0 = (void **)dword_10A09B00;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (unsigned int)v1 + 2048; (unsigned int)v1 < i; i = (unsigned int)*v0 + 2048 )
      {
        if ( *((_DWORD *)v1 + 2) )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 64;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&dword_10A09C00 );
}
// 10A09B00: using guessed type int dword_10A09B00[];
// 10A09C00: using guessed type int dword_10A09C00;

//----- (10070C8B) --------------------------------------------------------
int (*sub_10070C8B())(void)
{
  int (*result)(void); // eax@1
  int (**v1)(void); // esi@1

  result = (int (*)(void))&unk_101380C0;
  v1 = (int (**)(void))&unk_101380C0;
  if ( &unk_101380C0 < &unk_101380C0 )
  {
    do
    {
      result = *v1;
      if ( *v1 )
        result = (int (*)(void))result();
      ++v1;
    }
    while ( v1 < (int (**)(void))&unk_101380C0 );
  }
  return result;
}

//----- (10070CAF) --------------------------------------------------------
void __cdecl sub_10070CAF()
{
  void (**v0)(void); // esi@1

  v0 = (void (**)(void))&unk_101380C8;
  if ( &unk_101380C8 < &unk_101380C8 )
  {
    do
    {
      if ( *v0 )
        (*v0)();
      ++v0;
    }
    while ( v0 < (void (**)(void))&unk_101380C8 );
  }
}

//----- (10072F0F) --------------------------------------------------------
int __cdecl sub_10072F0F(FILE *a1, int a2, struct localeinfo_struct *a3, int a4)
{
  unsigned __int8 *v4; // edi@1
  int result; // eax@2
  int *v6; // edi@7
  _BYTE *v7; // eax@7
  int *v8; // edi@12
  _BYTE *v9; // eax@12
  unsigned __int8 v10; // al@16
  unsigned __int8 *v11; // edi@17
  int v12; // eax@19
  _WORD *v13; // esi@24
  int v14; // ebx@25
  int v15; // eax@25
  int v16; // ST10_4@25
  int v17; // ecx@25
  int v18; // eax@35
  unsigned __int8 v19; // al@59
  signed int v20; // ebx@62
  int v21; // eax@65
  int v22; // ecx@69
  int v23; // edi@79
  signed int v24; // ebx@82
  int v25; // ebx@84
  int i; // eax@90
  int v27; // eax@91
  int v28; // ecx@92
  int v29; // eax@96
  int j; // eax@98
  int v31; // eax@99
  int v32; // ecx@100
  int v33; // eax@106
  int v34; // ecx@107
  int v35; // ecx@108
  int v36; // eax@112
  int k; // eax@115
  int v38; // eax@116
  int v39; // ecx@117
  void *v40; // ST0C_4@124
  _WORD *v41; // ST08_4@124
  int v42; // ST04_4@124
  void (__cdecl *v43)(int, _WORD *, void *, struct localeinfo_struct *); // eax@124
  _WORD *v44; // edi@129
  int v45; // ST10_4@130
  int v46; // eax@132
  signed int v47; // eax@133
  _BYTE *v48; // edi@156
  unsigned __int8 *v49; // esi@156
  unsigned __int8 v50; // dl@159
  unsigned __int8 v51; // al@165
  unsigned int v52; // edi@168
  int v53; // edx@168
  unsigned int v54; // ecx@172
  unsigned int v55; // eax@172
  unsigned __int8 v56; // al@173
  int v57; // eax@181
  int v58; // ecx@181
  int v59; // eax@219
  int v60; // ST10_4@219
  int v61; // ecx@219
  unsigned int v62; // esi@222
  int v63; // eax@225
  int v64; // ST10_4@225
  int v65; // eax@238
  int v66; // ST10_4@238
  int v67; // ecx@238
  int v68; // edi@241
  int v69; // eax@244
  int v70; // ST10_4@244
  int v71; // ebx@265
  int v72; // eax@265
  int v73; // eax@267
  int v74; // ecx@267
  bool v75; // zf@275
  int v76; // [sp-4h] [bp-80h]@18
  int v77; // [sp-4h] [bp-80h]@94
  int v78; // [sp-4h] [bp-80h]@143
  int v79; // [sp-4h] [bp-80h]@266
  _WORD **v80; // [sp+Ch] [bp-70h]@0
  struct localeinfo_struct Locale; // [sp+10h] [bp-6Ch]@16
  int v82; // [sp+18h] [bp-64h]@288
  char v83; // [sp+1Ch] [bp-60h]@287
  wchar_t DstCh[2]; // [sp+20h] [bp-5Ch]@1
  _WORD **v85; // [sp+24h] [bp-58h]@1
  int v86; // [sp+28h] [bp-54h]@24
  char SrcCh; // [sp+2Ch] [bp-50h]@143
  char v88; // [sp+2Dh] [bp-4Fh]@144
  int v89; // [sp+30h] [bp-4Ch]@1
  int v90; // [sp+34h] [bp-48h]@24
  int v91; // [sp+38h] [bp-44h]@1
  unsigned __int8 v92; // [sp+3Fh] [bp-3Dh]@24
  int v93; // [sp+40h] [bp-3Ch]@16
  _WORD *v94; // [sp+44h] [bp-38h]@58
  unsigned __int64 v95; // [sp+48h] [bp-34h]@36
  int v96; // [sp+50h] [bp-2Ch]@24
  unsigned __int8 *v97; // [sp+54h] [bp-28h]@1
  void *v98; // [sp+58h] [bp-24h]@1
  int v99; // [sp+5Ch] [bp-20h]@62
  int v100; // [sp+60h] [bp-1Ch]@24
  char v101; // [sp+64h] [bp-18h]@24
  char v102; // [sp+65h] [bp-17h]@24
  char v103; // [sp+66h] [bp-16h]@24
  char v104; // [sp+67h] [bp-15h]@16
  FILE *v105; // [sp+68h] [bp-14h]@1
  char v106; // [sp+6Eh] [bp-Eh]@24
  char v107; // [sp+6Fh] [bp-Dh]@24
  int v108; // [sp+70h] [bp-Ch]@24
  char v109; // [sp+77h] [bp-5h]@24
  int v110; // [sp+78h] [bp-4h]@1
  char v111; // [sp+7Fh] [bp+3h]@24
  int v112; // [sp+80h] [bp+4h]@16
  char v113; // [sp+84h] [bp+8h]@1
  char v114[11]; // [sp+1E4h] [bp+168h]@140
  char v115; // [sp+1EFh] [bp+173h]@159

  v4 = (unsigned __int8 *)a2;
  v85 = (_WORD **)a4;
  v105 = a1;
  v97 = (unsigned __int8 *)a2;
  v98 = &v113;
  v89 = 350;
  v91 = 0;
  *(_DWORD *)DstCh = 0;
  v110 = 0;
  if ( !a2 || !a1 )
    goto LABEL_294;
  if ( a1->_flag & 0x40 )
    goto LABEL_16;
  if ( _fileno(a1) == -1 || _fileno(a1) == -2 )
  {
    v7 = &unk_1013AC58;
  }
  else
  {
    v6 = &dword_10A09B00[_fileno(a1) >> 5];
    v7 = (_BYTE *)(*v6 + ((_fileno(a1) & 0x1F) << 6));
  }
  if ( v7[36] & 0x7F
    || (_fileno(a1) == -1 || _fileno(a1) == -2 ? (v9 = &unk_1013AC58) : (v8 = &dword_10A09B00[_fileno(a1) >> 5],
                                                                         v9 = (_BYTE *)(*v8 + ((_fileno(a1) & 0x1F) << 6))),
        v9[36] & 0x80) )
  {
LABEL_294:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = v97;
LABEL_16:
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  v10 = *v4;
  v75 = *v4 == 0;
  v104 = 0;
  v112 = 0;
  v93 = 0;
  if ( v75 )
    goto LABEL_289;
  v11 = v97;
  while ( 2 )
  {
    if ( isspace(v10) )
    {
      --v112;
      v12 = _whiteout(v105);
      if ( v12 != -1 )
        sub_1007B6DC(v12, v105);
      do
        ++v11;
      while ( isspace(*v11) );
      goto LABEL_273;
    }
    if ( *v11 != 37 )
    {
      ++v112;
      v71 = _inc(v76, v105);
      v72 = *v11++;
      v110 = v71;
      v97 = v11;
      if ( v72 == v71 )
      {
        if ( !isleadbyte((unsigned __int8)v71) )
          goto LABEL_269;
        ++v112;
        v73 = _inc(v79, v105);
        v74 = *v11++;
        v97 = v11;
        if ( v74 == v73 )
        {
          --v112;
          goto LABEL_269;
        }
        if ( v73 != -1 )
          sub_1007B6DC(v73, v105);
      }
      v75 = v71 == -1;
      goto LABEL_279;
    }
    v86 = 0;
    v92 = 0;
    v100 = 0;
    v96 = 0;
    v108 = 0;
    v101 = 0;
    v102 = 0;
    v107 = 0;
    v111 = 0;
    v103 = 0;
    v109 = 0;
    v106 = 1;
    v90 = 0;
    v13 = 0;
    do
    {
      v14 = *++v11;
      v15 = isdigit(v14);
      v17 = v16;
      if ( v15 )
      {
        ++v96;
        v108 = 10 * v108 + v14 - 48;
        continue;
      }
      if ( v14 > 78 )
      {
        if ( v14 == 104 )
        {
          --v106;
          --v109;
        }
        else
        {
          if ( v14 == 108 )
          {
            v18 = (int)(v11 + 1);
            if ( v11[1] == 108 )
              goto LABEL_36;
            ++v106;
          }
          else if ( v14 != 119 )
          {
            goto LABEL_50;
          }
          ++v109;
        }
      }
      else
      {
        if ( v14 == 78 )
          continue;
        if ( v14 == 42 )
        {
          ++v107;
          continue;
        }
        if ( v14 == 70 )
          continue;
        if ( v14 != 73 )
        {
          if ( v14 == 76 )
          {
            ++v106;
            continue;
          }
LABEL_50:
          ++v111;
          continue;
        }
        LOBYTE(v17) = v11[1];
        if ( (_BYTE)v17 == 54 )
        {
          v18 = (int)(v11 + 2);
          if ( v11[2] == 52 )
          {
LABEL_36:
            ++v90;
            v11 = (unsigned __int8 *)v18;
            v95 = 0i64;
            continue;
          }
        }
        if ( (_BYTE)v17 == 51 && v11[2] == 50 )
        {
          v11 += 2;
          continue;
        }
        if ( (_BYTE)v17 != 100 && (_BYTE)v17 != 105 && (_BYTE)v17 != 111 && (_BYTE)v17 != 120 && (_BYTE)v17 != 88 )
          goto LABEL_50;
      }
    }
    while ( !v111 );
    v97 = v11;
    if ( !v107 )
    {
      v13 = *v85;
      v80 = v85;
      ++v85;
    }
    v94 = v13;
    v111 = 0;
    if ( !v109 )
    {
      v19 = *v11;
      if ( *v11 == 83 || (v109 = -1, v19 == 67) )
        v109 = 1;
    }
    v99 = *v11 | 0x20;
    v20 = v99;
    if ( v99 != 110 )
    {
      if ( v99 == 99 || v99 == 123 )
      {
        ++v112;
        v21 = _inc(v17, v105);
      }
      else
      {
        v21 = _whiteout(v105);
      }
      v110 = v21;
      if ( v21 == -1 )
        goto LABEL_281;
      v13 = v94;
      v11 = v97;
    }
    v22 = v96;
    if ( v96 && !v108 )
      goto LABEL_275;
    if ( v20 > 111 )
    {
      if ( v20 == 112 )
      {
        v106 = 1;
      }
      else
      {
        if ( v20 == 115 )
        {
LABEL_127:
          if ( v109 > 0 )
            v103 = 1;
          goto LABEL_129;
        }
        if ( v20 != 117 )
        {
          if ( v20 == 120 )
            goto LABEL_82;
          if ( v20 != 123 )
            goto LABEL_151;
          if ( v109 > 0 )
            v103 = 1;
          v48 = v11 + 1;
          v49 = v48;
          if ( *v48 == 94 )
          {
            v49 = v48 + 1;
            v101 = -1;
          }
          memset(v114, 0, 0x20u);
          if ( *v49 == 93 )
          {
            v50 = 93;
            ++v49;
            v115 = 32;
          }
          else
          {
            v50 = v92;
          }
          while ( 1 )
          {
            v56 = *v49;
            if ( *v49 == 93 )
              break;
            ++v49;
            if ( v56 == 45 && v50 && (LOBYTE(v22) = *v49, *v49 != 93) )
            {
              ++v49;
              if ( v50 >= (unsigned __int8)v22 )
              {
                v51 = v50;
                v50 = v22;
              }
              else
              {
                v51 = v22;
              }
              if ( v50 <= v51 )
              {
                v52 = v50;
                v53 = (unsigned __int8)(v51 - v50 + 1);
                do
                {
                  v22 = v52 & 7;
                  v114[v52 >> 3] |= 1 << v22;
                  ++v52;
                  --v53;
                }
                while ( v53 );
                v20 = v99;
              }
              v50 = 0;
            }
            else
            {
              v54 = v56;
              v50 = v56;
              v55 = v54;
              v22 = v54 & 7;
              v114[v55 >> 3] |= 1 << v22;
              v20 = v99;
            }
          }
          v97 = v49;
          v13 = v94;
LABEL_129:
          --v112;
          v44 = v13;
          if ( v110 != -1 )
          {
            sub_1007B6DC(v110, v105);
            v22 = v45;
          }
          while ( 1 )
          {
            if ( v96 )
            {
              v46 = v108--;
              if ( !v46 )
                goto LABEL_200;
            }
            ++v112;
            v47 = _inc(v22, v105);
            v110 = v47;
            if ( v47 == -1 )
              goto LABEL_198;
            if ( v20 != 99 )
            {
              if ( v20 != 115 )
                goto LABEL_295;
              if ( v47 >= 9 && v47 <= 13 )
              {
LABEL_198:
                --v112;
                if ( v47 != -1 )
                  sub_1007B6DC(v47, v105);
LABEL_200:
                if ( v44 != v13 )
                {
                  if ( !v107 )
                  {
                    ++v93;
                    if ( v20 != 99 )
                    {
                      if ( v103 )
                        *v94 = 0;
                      else
                        *(_BYTE *)v94 = 0;
                    }
                  }
                  goto LABEL_264;
                }
                goto LABEL_281;
              }
              if ( v47 == 32 )
              {
LABEL_295:
                if ( v20 != 123 )
                  goto LABEL_198;
                v22 = v101 ^ v114[v47 >> 3];
                v20 = v99;
                if ( !((1 << (v47 & 7)) & v22) )
                  goto LABEL_198;
              }
            }
            if ( v107 )
            {
              v44 = (_WORD *)((char *)v44 + 1);
            }
            else
            {
              if ( v103 )
              {
                SrcCh = v47;
                if ( isleadbyte((unsigned __int8)v47) )
                {
                  ++v112;
                  v88 = _inc(v78, v105);
                }
                *(_DWORD *)DstCh = 63;
                _mbtowc_l(DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale);
                *v13 = DstCh[0];
                ++v13;
              }
              else
              {
                *(_BYTE *)v13 = v47;
                v13 = (_WORD *)((char *)v13 + 1);
              }
              v94 = v13;
            }
          }
        }
      }
LABEL_207:
      v24 = v110;
      if ( v110 == 45 )
      {
        v102 = 1;
      }
      else if ( v110 != 43 )
      {
        goto LABEL_215;
      }
      if ( !--v108 && v96 )
      {
        v111 = 1;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v96, v105);
      goto LABEL_214;
    }
    if ( v20 == 111 )
      goto LABEL_207;
    if ( v20 == 99 )
    {
      if ( !v96 )
      {
        ++v108;
        v96 = 1;
      }
      goto LABEL_127;
    }
    if ( v20 == 100 )
      goto LABEL_207;
    if ( v20 <= 100 )
      goto LABEL_151;
    if ( v20 <= 103 )
    {
      v25 = 0;
      if ( v110 == 45 )
      {
        *(_BYTE *)v98 = 45;
        v25 = 1;
        goto LABEL_87;
      }
      if ( v110 == 43 )
      {
LABEL_87:
        --v108;
        ++v112;
        v110 = _inc(v22, v105);
      }
      if ( !v96 )
        v108 = -1;
      for ( i = (unsigned __int8)v110; isdigit(i); i = (unsigned __int8)v110 )
      {
        v27 = v108--;
        if ( !v27 )
          break;
        ++v100;
        *((_BYTE *)v98 + v25++) = v110;
        if ( !__check_float_string(v25, &v113, (int)&v91) )
          goto LABEL_281;
        ++v112;
        v110 = _inc(v28, v105);
      }
      v101 = **(_BYTE **)Locale.locinfo->lconv;
      if ( v101 == (_BYTE)v110 )
      {
        v29 = v108--;
        if ( v29 )
        {
          ++v112;
          v110 = _inc(v77, v105);
          *((_BYTE *)v98 + v25++) = v101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          for ( j = (unsigned __int8)v110; isdigit(j); j = (unsigned __int8)v110 )
          {
            v31 = v108--;
            if ( !v31 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v32, v105);
          }
        }
      }
      if ( v100 && (v110 == 101 || v110 == 69) )
      {
        v33 = v108--;
        if ( v33 )
        {
          *((_BYTE *)v98 + v25++) = 101;
          if ( !__check_float_string(v25, &v113, (int)&v91) )
            goto LABEL_281;
          ++v112;
          v110 = _inc(v34, v105);
          if ( v110 == 45 )
          {
            *((_BYTE *)v98 + v25++) = 45;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
LABEL_112:
            v36 = v108--;
            if ( v36 )
            {
              ++v112;
              v110 = _inc(v35, v105);
            }
            else
            {
              v108 = 0;
            }
          }
          else if ( v110 == 43 )
          {
            goto LABEL_112;
          }
          for ( k = (unsigned __int8)v110; isdigit(k); k = (unsigned __int8)v110 )
          {
            v38 = v108--;
            if ( !v38 )
              break;
            ++v100;
            *((_BYTE *)v98 + v25++) = v110;
            if ( !__check_float_string(v25, &v113, (int)&v91) )
              goto LABEL_281;
            ++v112;
            v110 = _inc(v39, v105);
          }
        }
      }
      --v112;
      if ( v110 != -1 )
        sub_1007B6DC(v110, v105);
      if ( v100 )
      {
        if ( !v107 )
        {
          ++v93;
          v40 = v98;
          v41 = v94;
          *((_BYTE *)v98 + v25) = 0;
          v42 = v106 - 1;
          v43 = (void (__cdecl *)(int, _WORD *, void *, struct localeinfo_struct *))_decode_pointer(off_1013A2A4[0]);
          v43(v42, v41, v40, &Locale);
        }
        goto LABEL_264;
      }
      goto LABEL_281;
    }
    if ( v20 != 105 )
    {
      if ( v20 == 110 )
      {
        v23 = v112;
        if ( !v107 )
        {
LABEL_259:
          if ( v90 )
          {
            *(_QWORD *)v13 = v95;
          }
          else if ( v106 )
          {
            *(_DWORD *)v13 = v23;
          }
          else
          {
            *v13 = v23;
          }
        }
        goto LABEL_264;
      }
LABEL_151:
      if ( *v11 == v110 )
      {
        --v104;
        if ( !v107 )
          v85 = v80;
        goto LABEL_264;
      }
LABEL_275:
      v75 = v110 == -1;
LABEL_279:
      if ( !v75 )
        sub_1007B6DC(v110, v105);
      goto LABEL_281;
    }
    v99 = 100;
LABEL_82:
    v24 = v110;
    if ( v110 == 45 )
    {
      v102 = 1;
      goto LABEL_176;
    }
    if ( v110 == 43 )
    {
LABEL_176:
      if ( --v108 || !v96 )
      {
        ++v112;
        v24 = _inc(v96, v105);
        v110 = v24;
      }
      else
      {
        v111 = 1;
      }
    }
    if ( v24 == 48 )
    {
      ++v112;
      v57 = _inc(v22, v105);
      v24 = v57;
      v110 = v57;
      if ( (_BYTE)v57 != 120 && (_BYTE)v57 != 88 )
      {
        v100 = 1;
        if ( v99 != 120 )
        {
          if ( v96 )
          {
            if ( !--v108 )
              ++v111;
          }
          v99 = 111;
          goto LABEL_215;
        }
        --v112;
        if ( v57 != -1 )
          sub_1007B6DC(v57, v105);
        v24 = 48;
LABEL_214:
        v110 = v24;
        goto LABEL_215;
      }
      ++v112;
      v24 = _inc(v58, v105);
      v110 = v24;
      if ( v96 )
      {
        v108 -= 2;
        if ( v108 < 1 )
          ++v111;
      }
      v99 = 120;
    }
LABEL_215:
    if ( !v90 )
    {
      v23 = v86;
      if ( !v111 )
      {
        while ( 1 )
        {
          if ( v99 == 120 || v99 == 112 )
          {
            if ( !isxdigit((unsigned __int8)v24) )
            {
LABEL_250:
              --v112;
              if ( v24 != -1 )
                sub_1007B6DC(v24, v105);
              break;
            }
            v68 = 16 * v23;
            v69 = isdigit((unsigned __int8)v24);
            v67 = v70;
            v24 = (char)v24;
            if ( !v69 )
              v24 = (v24 & 0xFFFFFFDF) - 7;
            v110 = v24;
          }
          else
          {
            v65 = isdigit((unsigned __int8)v24);
            v67 = v66;
            if ( !v65 )
              goto LABEL_250;
            if ( v99 == 111 )
            {
              if ( v24 >= 56 )
                goto LABEL_250;
              v68 = 8 * v23;
            }
            else
            {
              v68 = 10 * v23;
            }
          }
          ++v100;
          v23 = v68 + v24 - 48;
          if ( v96 )
          {
            if ( !--v108 )
              break;
          }
          ++v112;
          v24 = _inc(v67, v105);
          v110 = v24;
        }
      }
      if ( v102 )
        v23 = -v23;
      goto LABEL_254;
    }
    if ( v111 )
      goto LABEL_233;
    while ( 2 )
    {
      if ( v99 != 120 && v99 != 112 )
      {
        v59 = isdigit((unsigned __int8)v24);
        v61 = v60;
        if ( !v59 )
          break;
        if ( v99 == 111 )
        {
          if ( v24 >= 56 )
            break;
          v62 = 8 * v95;
          HIDWORD(v95) = v95 >> 29;
        }
        else
        {
          HIDWORD(v95) = 10 * v95 >> 32;
          v62 = 10 * v95;
        }
        goto LABEL_228;
      }
      if ( isxdigit((unsigned __int8)v24) )
      {
        v62 = 16 * v95;
        HIDWORD(v95) = v95 >> 28;
        v63 = isdigit((unsigned __int8)v24);
        v61 = v64;
        v24 = (char)v24;
        if ( !v63 )
          v24 = (v24 & 0xFFFFFFDF) - 7;
        v110 = v24;
LABEL_228:
        ++v100;
        v95 = v24 - 48 + __PAIR__(HIDWORD(v95), v62);
        if ( v96 )
        {
          if ( !--v108 )
            goto LABEL_233;
        }
        ++v112;
        v24 = _inc(v61, v105);
        v110 = v24;
        continue;
      }
      break;
    }
    --v112;
    if ( v24 != -1 )
      sub_1007B6DC(v24, v105);
LABEL_233:
    v23 = v86;
    if ( v102 )
      v95 = -(signed __int64)v95;
LABEL_254:
    if ( v99 == 70 )
      v100 = 0;
    if ( !v100 )
      goto LABEL_281;
    if ( !v107 )
    {
      ++v93;
      v13 = v94;
      goto LABEL_259;
    }
LABEL_264:
    ++v104;
    v11 = v97++ + 1;
LABEL_269:
    if ( v110 != -1 )
    {
LABEL_273:
      v10 = *v11;
      if ( !*v11 )
        goto LABEL_281;
      continue;
    }
    break;
  }
  if ( *v11 == 37 && v97[1] == 110 )
  {
    v11 = v97;
    goto LABEL_273;
  }
LABEL_281:
  if ( v91 == 1 )
    free(v98);
  if ( v110 == -1 )
  {
    result = v93;
    if ( !v93 && v104 == (_BYTE)v93 )
      result = -1;
    if ( v83 )
      *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
    return result;
  }
LABEL_289:
  if ( v83 )
    *(_DWORD *)(v82 + 112) &= 0xFFFFFFFD;
  return v93;
}
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1006DC2A: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 10072ED4: using guessed type int __fastcall _inc(_DWORD, _DWORD);
// 10072EEA: using guessed type _DWORD __cdecl _whiteout(_DWORD);
// 1013A2A4: using guessed type int (*off_1013A2A4[3])();
// 10A09B00: using guessed type int dword_10A09B00[];
// 10072F0F: using guessed type char var_24[11];

//----- (10075A24) --------------------------------------------------------
#error "10075A29: positive sp value has been found (funcsize=0)"

//----- (10075A2F) --------------------------------------------------------
#error "10075A34: positive sp value has been found (funcsize=0)"

//----- (10075A3A) --------------------------------------------------------
#error "10075A3F: positive sp value has been found (funcsize=0)"

//----- (10075A40) --------------------------------------------------------
#error "10075A45: positive sp value has been found (funcsize=0)"

//----- (10075A46) --------------------------------------------------------
#error "10075A4B: positive sp value has been found (funcsize=0)"

//----- (10075A4C) --------------------------------------------------------
#error "10075A51: positive sp value has been found (funcsize=0)"

//----- (10075A52) --------------------------------------------------------
#error "10075A6D: positive sp value has been found (funcsize=0)"

//----- (10075A73) --------------------------------------------------------
#error "10075A88: positive sp value has been found (funcsize=0)"

//----- (10075A8E) --------------------------------------------------------
#error "10075AA9: positive sp value has been found (funcsize=0)"

//----- (10075AAA) --------------------------------------------------------
#error "10075AB9: positive sp value has been found (funcsize=0)"

//----- (10075ABA) --------------------------------------------------------
#error "10075ACD: positive sp value has been found (funcsize=0)"

//----- (10075ACE) --------------------------------------------------------
#error "10075ADD: positive sp value has been found (funcsize=0)"

//----- (10075ADE) --------------------------------------------------------
#error "10075AFD: positive sp value has been found (funcsize=0)"

//----- (10075B03) --------------------------------------------------------
#error "10075B1C: positive sp value has been found (funcsize=0)"

//----- (10075B22) --------------------------------------------------------
#error "10075B41: positive sp value has been found (funcsize=0)"

//----- (10075B42) --------------------------------------------------------
#error "10075B55: positive sp value has been found (funcsize=0)"

//----- (10075B56) --------------------------------------------------------
#error "10075B6D: positive sp value has been found (funcsize=0)"

//----- (10075B6E) --------------------------------------------------------
#error "10075B81: positive sp value has been found (funcsize=0)"

//----- (10075B82) --------------------------------------------------------
#error "10075BA1: positive sp value has been found (funcsize=0)"

//----- (10075BA7) --------------------------------------------------------
#error "10075BC0: positive sp value has been found (funcsize=0)"

//----- (10075BC6) --------------------------------------------------------
#error "10075BE5: positive sp value has been found (funcsize=0)"

//----- (10075BE6) --------------------------------------------------------
#error "10075BF9: positive sp value has been found (funcsize=0)"

//----- (10075BFA) --------------------------------------------------------
#error "10075C11: positive sp value has been found (funcsize=0)"

//----- (10075C12) --------------------------------------------------------
#error "10075C25: positive sp value has been found (funcsize=0)"

//----- (10075C26) --------------------------------------------------------
#error "10075C45: positive sp value has been found (funcsize=0)"

//----- (10075C4B) --------------------------------------------------------
#error "10075C64: positive sp value has been found (funcsize=0)"

//----- (10075C6A) --------------------------------------------------------
#error "10075C89: positive sp value has been found (funcsize=0)"

//----- (10075C8A) --------------------------------------------------------
#error "10075C9D: positive sp value has been found (funcsize=0)"

//----- (10075C9E) --------------------------------------------------------
#error "10075CB5: positive sp value has been found (funcsize=0)"

//----- (10075CB6) --------------------------------------------------------
#error "10075CC9: positive sp value has been found (funcsize=0)"

//----- (10075CCA) --------------------------------------------------------
#error "10075CE9: positive sp value has been found (funcsize=0)"

//----- (10075CEF) --------------------------------------------------------
#error "10075D08: positive sp value has been found (funcsize=0)"

//----- (10075D0E) --------------------------------------------------------
#error "10075D2D: positive sp value has been found (funcsize=0)"

//----- (10075D2E) --------------------------------------------------------
#error "10075D41: positive sp value has been found (funcsize=0)"

//----- (10075D42) --------------------------------------------------------
#error "10075D59: positive sp value has been found (funcsize=0)"

//----- (10075D5A) --------------------------------------------------------
#error "10075D6D: positive sp value has been found (funcsize=0)"

//----- (10075D6E) --------------------------------------------------------
#error "10075D8D: positive sp value has been found (funcsize=0)"

//----- (10075D93) --------------------------------------------------------
#error "10075DAC: positive sp value has been found (funcsize=0)"

//----- (10075DB2) --------------------------------------------------------
#error "10075DD1: positive sp value has been found (funcsize=0)"

//----- (10075DD2) --------------------------------------------------------
#error "10075DE5: positive sp value has been found (funcsize=0)"

//----- (10075DE6) --------------------------------------------------------
#error "10075DFD: positive sp value has been found (funcsize=0)"

//----- (10075DFE) --------------------------------------------------------
#error "10075E11: positive sp value has been found (funcsize=0)"

//----- (10075E12) --------------------------------------------------------
#error "10075E31: positive sp value has been found (funcsize=0)"

//----- (10075E37) --------------------------------------------------------
#error "10075E50: positive sp value has been found (funcsize=0)"

//----- (10075E56) --------------------------------------------------------
#error "10075E75: positive sp value has been found (funcsize=0)"

//----- (10075E76) --------------------------------------------------------
#error "10075E89: positive sp value has been found (funcsize=0)"

//----- (10075E8A) --------------------------------------------------------
#error "10075EA1: positive sp value has been found (funcsize=0)"

//----- (10075EA2) --------------------------------------------------------
#error "10075EB5: positive sp value has been found (funcsize=0)"

//----- (1007668B) --------------------------------------------------------
void sub_1007668B()
{
  dword_10A09AEC = 0;
}
// 10A09AEC: using guessed type int dword_10A09AEC;

//----- (10076743) --------------------------------------------------------
int sub_10076743()
{
  dword_10A0AC28 = _get_sse2_info();
  return 0;
}
// 100766E3: using guessed type int _get_sse2_info(void);
// 10A0AC28: using guessed type int dword_10A0AC28;

//----- (10076750) --------------------------------------------------------
DWORD __cdecl sub_10076750(int a1, int a2, int a3, DWORD dwMoveMethod)
{
  void *v4; // eax@1
  DWORD v6; // eax@5
  _BYTE *v7; // eax@7
  DWORD lDistanceToMove; // [sp+8h] [bp-8h]@4
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-4h]@1

  DistanceToMoveHigh = a3;
  v4 = (void *)sub_10079665(a1);
  if ( v4 == (void *)-1 )
  {
    *_errno() = 9;
    return -1;
  }
  lDistanceToMove = SetFilePointer(v4, a2, &DistanceToMoveHigh, dwMoveMethod);
  if ( lDistanceToMove == -1 )
  {
    v6 = GetLastError();
    if ( v6 )
    {
      _dosmaperr(v6);
      return -1;
    }
  }
  v7 = (_BYTE *)(dword_10A09B00[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
  *v7 &= 0xFDu;
  return lDistanceToMove;
}
// 1006B58B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (100768EC) --------------------------------------------------------
_WORD *__cdecl sub_100768EC(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // esi@5
  int v5; // edi@5
  int v6; // eax@5
  char v7; // bl@5
  int v8; // eax@13
  void *v9; // ST18_4@13
  DWORD v10; // eax@16
  const char *v11; // ebx@16
  char v12; // cl@19
  int *v13; // esi@19
  int v14; // eax@19
  int v15; // eax@20
  int v16; // eax@27
  signed int v17; // esi@27
  int v18; // eax@31
  int v19; // esi@36
  __int16 v20; // ax@39
  int v21; // ecx@45
  char v22; // dl@45
  int v23; // eax@46
  DWORD v24; // ecx@51
  char *v25; // eax@51
  char *v26; // edx@53
  char v27; // dl@53
  int v28; // ebx@56
  DWORD v29; // ecx@64
  char *v30; // eax@64
  __int16 *v31; // edx@66
  __int16 v32; // dx@66
  int v33; // ebx@69
  DWORD v34; // ecx@74
  WCHAR *v35; // eax@74
  WCHAR v36; // dx@76
  int v37; // esi@79
  int v38; // ebx@79
  DWORD Mode; // [sp+4h] [bp-7Ch]@13
  int v40; // [sp+8h] [bp-78h]@13
  char v41; // [sp+Fh] [bp-71h]@5
  int *v42; // [sp+10h] [bp-70h]@5
  DWORD v43; // [sp+14h] [bp-6Ch]@56
  int v44; // [sp+18h] [bp-68h]@1
  LPCVOID lpBuffer; // [sp+1Ch] [bp-64h]@1
  _WORD *v46; // [sp+20h] [bp-60h]@1
  DWORD NumberOfBytesWritten; // [sp+24h] [bp-5Ch]@16
  WCHAR WideCharStr[2]; // [sp+28h] [bp-58h]@20
  _WORD *v49; // [sp+2Ch] [bp-54h]@17
  char Buffer; // [sp+30h] [bp-50h]@51
  CHAR v51[688]; // [sp+184h] [bp+104h]@79
  WCHAR v52; // [sp+434h] [bp+3B4h]@74
  CHAR MultiByteStr; // [sp+588h] [bp+508h]@20
  char v54; // [sp+589h] [bp+509h]@20

  lpBuffer = (LPCVOID)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  v4 = &dword_10A09B00[a1 >> 5];
  v5 = (a1 & 0x1F) << 6;
  v6 = v5 + *v4;
  v7 = (char)(2 * *(_BYTE *)(v6 + 36)) >> 1;
  v42 = &dword_10A09B00[a1 >> 5];
  v41 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    sub_10076750(a1, 0, 0, 2u);
  if ( sub_1007702E(a1) )
  {
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x80 )
    {
      v8 = _getptd();
      v9 = *(void **)(v5 + *v4);
      v40 = *(_DWORD *)(*(_DWORD *)(v8 + 108) + 20) == 0;
      if ( GetConsoleMode(v9, &Mode) )
      {
        if ( !v40 || v7 )
        {
          v10 = GetConsoleCP();
          v11 = (const char *)lpBuffer;
          Mode = v10;
          NumberOfBytesWritten = 0;
          if ( nNumberOfBytesToWrite )
          {
            v49 = 0;
            while ( 1 )
            {
              if ( v41 )
              {
                if ( v41 == 1 || v41 == 2 )
                {
                  v19 = *(_WORD *)v11;
                  v11 += 2;
                  ++v49;
                  *(_DWORD *)WideCharStr = v19;
                  v40 = (_WORD)v19 == 10;
                }
                if ( v41 == 1 || v41 == 2 )
                {
                  v20 = _putwch_nolock(WideCharStr[0]);
                  if ( v20 != WideCharStr[0] )
                    goto LABEL_89;
                  v46 = (_WORD *)((char *)v46 + 1);
                  if ( v40 )
                  {
                    *(_DWORD *)WideCharStr = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    v46 = (_WORD *)((char *)v46 + 1);
                    ++v44;
                  }
                }
                goto LABEL_43;
              }
              v12 = *v11;
              v13 = v42;
              v40 = *v11 == 10;
              v14 = v5 + *v42;
              if ( *(_DWORD *)(v14 + 56) )
              {
                MultiByteStr = *(_BYTE *)(v14 + 52);
                v54 = v12;
                *(_DWORD *)(v14 + 56) = 0;
                v15 = mbtowc(WideCharStr, &MultiByteStr, 2u);
              }
              else
              {
                if ( isleadbyte(v12) )
                {
                  if ( nNumberOfBytesToWrite + (_BYTE *)lpBuffer - v11 <= 1 )
                  {
                    v21 = *v13;
                    v22 = *v11;
                    v46 = (_WORD *)((char *)v46 + 1);
                    *(_BYTE *)(v5 + v21 + 52) = v22;
                    *(_DWORD *)(v5 + *v13 + 56) = 1;
                    goto LABEL_90;
                  }
                  if ( mbtowc(WideCharStr, v11, 2u) == -1 )
                    goto LABEL_90;
                  ++v11;
                  v49 = (_WORD *)((char *)v49 + 1);
                  goto LABEL_27;
                }
                v15 = mbtowc(WideCharStr, v11, 1u);
              }
              if ( v15 == -1 )
                goto LABEL_90;
LABEL_27:
              ++v11;
              v49 = (_WORD *)((char *)v49 + 1);
              v16 = WideCharToMultiByte(Mode, 0, WideCharStr, 1, &MultiByteStr, 5, 0, 0);
              v17 = v16;
              if ( !v16 )
                goto LABEL_90;
              if ( !WriteFile(*(HANDLE *)(v5 + *v42), &MultiByteStr, v16, &NumberOfBytesWritten, 0) )
                goto LABEL_89;
              v46 = (_WORD *)((char *)v49 + v44);
              if ( (signed int)NumberOfBytesWritten < v17 )
                goto LABEL_90;
              if ( v40 )
              {
                v18 = *v42;
                MultiByteStr = 13;
                if ( !WriteFile(*(HANDLE *)(v5 + v18), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                if ( (signed int)NumberOfBytesWritten < 1 )
                  goto LABEL_90;
                ++v44;
                v46 = (_WORD *)((char *)v46 + 1);
              }
LABEL_43:
              if ( (unsigned int)v49 >= nNumberOfBytesToWrite )
                goto LABEL_90;
            }
          }
          goto LABEL_91;
        }
      }
    }
  }
  v23 = v5 + *v4;
  if ( *(_BYTE *)(v23 + 4) & 0x80 )
  {
    *(_DWORD *)WideCharStr = 0;
    if ( v7 )
    {
      v49 = lpBuffer;
      if ( v7 == 2 )
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v29 = (char *)v49 - (_BYTE *)lpBuffer;
          v30 = &Buffer;
          do
          {
            if ( v29 >= nNumberOfBytesToWrite )
              break;
            v31 = v49;
            ++v49;
            v32 = *v31;
            v29 += 2;
            if ( v32 == 10 )
            {
              v44 += 2;
              *(_WORD *)v30 = 13;
              v30 += 2;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *(_WORD *)v30 = v32;
            v30 += 2;
          }
          while ( NumberOfBytesWritten < 0x3FF );
          v33 = v30 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v30 - &Buffer, &v43, 0) )
            break;
          v46 = (_WORD *)((char *)v46 + v43);
          if ( (signed int)v43 < v33 || (char *)v49 - (_BYTE *)lpBuffer >= nNumberOfBytesToWrite )
            goto LABEL_90;
          v4 = v42;
        }
      }
      else
      {
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_96;
        while ( 1 )
        {
          NumberOfBytesWritten = 0;
          v34 = (char *)v49 - (_BYTE *)lpBuffer;
          v35 = &v52;
          do
          {
            if ( v34 >= nNumberOfBytesToWrite )
              break;
            v36 = *v49;
            ++v49;
            v34 += 2;
            if ( v36 == 10 )
            {
              *v35 = 13;
              ++v35;
              NumberOfBytesWritten += 2;
            }
            NumberOfBytesWritten += 2;
            *v35 = v36;
            ++v35;
          }
          while ( NumberOfBytesWritten < 0x152 );
          v37 = 0;
          v38 = WideCharToMultiByte(0xFDE9u, 0, &v52, v35 - &v52, v51, 683, 0, 0);
          if ( !v38 )
            break;
          while ( WriteFile(*(HANDLE *)(v5 + *v42), &v51[v37], v38 - v37, &v43, 0) )
          {
            v37 += v43;
            if ( v38 <= v37 )
              goto LABEL_84;
          }
          *(_DWORD *)WideCharStr = GetLastError();
LABEL_84:
          if ( v38 <= v37 )
          {
            v46 = (_WORD *)((char *)v49 - (_BYTE *)lpBuffer);
            if ( (char *)v49 - (_BYTE *)lpBuffer < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      NumberOfBytesWritten = (DWORD)lpBuffer;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_96;
      while ( 1 )
      {
        v49 = 0;
        v24 = NumberOfBytesWritten - (_DWORD)lpBuffer;
        v25 = &Buffer;
        do
        {
          if ( v24 >= nNumberOfBytesToWrite )
            break;
          v26 = (char *)NumberOfBytesWritten++;
          v27 = *v26;
          ++v24;
          if ( v27 == 10 )
          {
            ++v44;
            *v25++ = 13;
            v49 = (_WORD *)((char *)v49 + 1);
          }
          *v25++ = v27;
          v49 = (_WORD *)((char *)v49 + 1);
        }
        while ( (unsigned int)v49 < 0x400 );
        v28 = v25 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v5 + *v4), &Buffer, v25 - &Buffer, &v43, 0) )
          break;
        v46 = (_WORD *)((char *)v46 + v43);
        if ( (signed int)v43 < v28 || NumberOfBytesWritten - (unsigned int)lpBuffer >= nNumberOfBytesToWrite )
          goto LABEL_90;
        v4 = v42;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v23, lpBuffer, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)WideCharStr = 0;
    v46 = (_WORD *)v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)WideCharStr = GetLastError();
LABEL_90:
  if ( !v46 )
  {
LABEL_91:
    if ( *(_DWORD *)WideCharStr )
    {
      if ( *(_DWORD *)WideCharStr == 5 )
      {
        *_errno() = 9;
        *__doserrno() = 5;
      }
      else
      {
        _dosmaperr(*(_DWORD *)WideCharStr);
      }
      return (_WORD *)-1;
    }
    v4 = v42;
LABEL_96:
    if ( *(_BYTE *)(v5 + *v4 + 4) & 0x40 && *(_BYTE *)lpBuffer == 26 )
      return 0;
    *_errno() = 28;
    *__doserrno() = 0;
    return (_WORD *)-1;
  }
  return (_WORD *)((char *)v46 - v44);
}
// 1006B58B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1006DE46: using guessed type int _getptd(void);
// 10A09B00: using guessed type int dword_10A09B00[];
// 100768EC: using guessed type CHAR var_410[688];

//----- (10076F0E) --------------------------------------------------------
_WORD *__cdecl sub_10076F0E(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  _WORD *v6; // [sp+14h] [bp-1Ch]@9

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return (_WORD *)-1;
  }
  if ( a1 < 0
    || a1 >= uNumber
    || (v4 = &dword_10A09B00[a1 >> 5], v5 = (a1 & 0x1F) << 6, !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return (_WORD *)-1;
  }
  __lock_fhandle(a1);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = sub_100768EC(a1, a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = (_WORD *)-1;
  }
  sub_10079776(a1);
  return v6;
}
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 100796D6: using guessed type _DWORD __cdecl __lock_fhandle(_DWORD);
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (1007702E) --------------------------------------------------------
int __cdecl sub_1007702E(signed int a1)
{
  int result; // eax@2

  if ( a1 == -2 )
  {
    *_errno() = 9;
    result = 0;
  }
  else if ( a1 >= 0 && a1 < uNumber )
  {
    result = *(_BYTE *)(dword_10A09B00[a1 >> 5] + ((a1 & 0x1F) << 6) + 4) & 0x40;
  }
  else
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (100772B5) --------------------------------------------------------
int __cdecl sub_100772B5(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_10077E18((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1006E361: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1007735B) --------------------------------------------------------
int __cdecl sub_1007735B(int a1, int a2, struct localeinfo_struct *a3)
{
  signed int v3; // eax@1
  char v6; // [sp+Ch] [bp-28h]@1
  char v7; // [sp+10h] [bp-24h]@1
  int v8; // [sp+18h] [bp-1Ch]@4
  char v9; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  char v11; // [sp+24h] [bp-10h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v7, a3);
  v10 = __strgtold12_l(&v11, &v6, a2, 0, 0, 0, 0, &v7);
  v3 = sub_1007835A((int)&v11, a1);
  if ( v10 & 3 )
  {
    if ( v10 & 1 )
      goto LABEL_8;
    if ( v10 & 2 )
      goto LABEL_3;
  }
  else
  {
    if ( v3 == 1 )
    {
LABEL_3:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 3;
    }
    if ( v3 == 2 )
    {
LABEL_8:
      if ( v9 )
        *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
      return 4;
    }
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFD;
  return 0;
}
// 1006E361: using guessed type _DWORD __cdecl __strgtold12_l(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (10077E18) --------------------------------------------------------
signed int __cdecl sub_10077E18(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_1013B1B8 - 1;
    v64 = v3;
    v65 = dword_1013B1B8 / 32;
    v9 = dword_1013B1B8 % 32;
    v10 = (int *)(&v60 + dword_1013B1B8 / 32);
    v66 = 31 - dword_1013B1B8 % 32;
    if ( (1 << (31 - dword_1013B1B8 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_1013B1B4 - dword_1013B1B8 )
    {
      if ( v3 > dword_1013B1B4 )
      {
        if ( v3 < dword_1013B1B0 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_1013B1C4 + v3;
          v50 = dword_1013B1BC / 32;
          v51 = dword_1013B1BC % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_1013B1BC % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_1013B1BC / 32;
          v44 = dword_1013B1BC % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_1013B1BC % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_1013B1C4 + dword_1013B1B0;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_1013B1B4 - v64) / 32;
      v62 = v59;
      v18 = (dword_1013B1B4 - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_1013B1B8 - 1;
      v25 = dword_1013B1B8 / 32;
      v65 = dword_1013B1B8 / 32;
      v26 = (int *)(&v60 + dword_1013B1B8 / 32);
      v64 = 31 - dword_1013B1B8 % 32;
      if ( (1 << (31 - dword_1013B1B8 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_1013B1B8 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_1013B1BC + 1) / 32;
      v37 = (dword_1013B1BC + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_1013B1BC));
  if ( dword_1013B1C0 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_1013B1C0 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 1013B1B0: using guessed type int dword_1013B1B0;
// 1013B1B4: using guessed type int dword_1013B1B4;
// 1013B1B8: using guessed type int dword_1013B1B8;
// 1013B1BC: using guessed type int dword_1013B1BC;
// 1013B1C0: using guessed type int dword_1013B1C0;
// 1013B1C4: using guessed type int dword_1013B1C4;

//----- (1007835A) --------------------------------------------------------
signed int __cdecl sub_1007835A(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@13
  unsigned int v14; // edx@13
  int *v15; // ecx@13
  bool v16; // cf@14
  int v17; // eax@29
  int v18; // edx@29
  int *v19; // ebx@30
  unsigned int v20; // esi@30
  char v21; // cl@30
  signed int v22; // edx@31
  int *v23; // ecx@31
  signed int v24; // esi@36
  int v25; // eax@36
  int *v26; // ebx@36
  bool j; // zf@37
  int v28; // eax@42
  unsigned int v29; // edx@42
  int *v30; // ecx@42
  unsigned int v31; // edi@42
  signed int k; // ecx@45
  int *v33; // ecx@47
  unsigned int v34; // esi@47
  signed int v35; // edi@47
  int v36; // eax@54
  int v37; // edx@54
  int *v38; // ebx@55
  unsigned int v39; // esi@55
  char v40; // cl@55
  signed int v41; // edx@56
  int *v42; // ecx@56
  int v43; // eax@63
  int v44; // edx@63
  int *v45; // ebx@64
  unsigned int v46; // esi@64
  char v47; // cl@64
  signed int v48; // edx@65
  int *v49; // ecx@65
  int v50; // eax@71
  int v51; // edx@71
  unsigned int v52; // edi@72
  signed int v53; // edx@73
  int *v54; // ecx@73
  int v55; // ebx@79
  int v56; // edx@80
  unsigned int v57; // [sp+8h] [bp-2Ch]@7
  int v58; // [sp+Ch] [bp-28h]@7
  int v59; // [sp+10h] [bp-24h]@7
  unsigned int v60; // [sp+14h] [bp-20h]@1
  int v61; // [sp+18h] [bp-1Ch]@1
  int v62; // [sp+1Ch] [bp-18h]@1
  int v63; // [sp+20h] [bp-14h]@1
  int v64; // [sp+24h] [bp-10h]@7
  int v65; // [sp+28h] [bp-Ch]@7
  int v66; // [sp+2Ch] [bp-8h]@7
  int v67; // [sp+30h] [bp-4h]@13
  int v68; // [sp+3Ch] [bp+8h]@7
  unsigned int v69; // [sp+3Ch] [bp+8h]@13
  signed int v70; // [sp+3Ch] [bp+8h]@29
  signed int v71; // [sp+3Ch] [bp+8h]@42
  signed int v72; // [sp+3Ch] [bp+8h]@54
  signed int v73; // [sp+3Ch] [bp+8h]@63
  signed int v74; // [sp+3Ch] [bp+8h]@71

  v2 = *(_WORD *)(a1 + 10);
  v63 = *(_WORD *)(a1 + 10) & 0x8000;
  v60 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v61 = *(_DWORD *)(a1 + 2);
  v62 = v4;
  if ( v3 != -16383 )
  {
    v68 = 0;
    v57 = v60;
    v58 = v61;
    v59 = v62;
    v8 = dword_1013B1D0 - 1;
    v64 = v3;
    v65 = dword_1013B1D0 / 32;
    v9 = dword_1013B1D0 % 32;
    v10 = (int *)(&v60 + dword_1013B1D0 / 32);
    v66 = 31 - dword_1013B1D0 % 32;
    if ( (1 << (31 - dword_1013B1D0 % 32)) & *v10 )
    {
      v11 = v65;
      for ( i = (~(-1 << (31 - v9)) & *(&v60 + v65)) == 0; i; i = *(&v60 + v11) == 0 )
      {
        if ( ++v11 >= 3 )
          goto LABEL_22;
      }
      v13 = v8 / 32;
      v67 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v60 + v8 / 32);
      v69 = v14 + *v15;
      if ( v69 >= *v15 )
      {
        v16 = v69 < v14;
        goto LABEL_18;
      }
LABEL_19:
      v67 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v69;
        if ( v13 < 0 || !v67 )
          break;
        v67 = 0;
        v15 = (int *)(&v60 + v13);
        v69 = *v15 + 1;
        if ( v69 >= *v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_18:
          if ( !v16 )
            continue;
        }
        goto LABEL_19;
      }
      v68 = v67;
    }
LABEL_22:
    *v10 &= -1 << v66;
    if ( v65 + 1 < 3 )
      memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
    if ( v68 )
      ++v3;
    if ( v3 >= dword_1013B1CC - dword_1013B1D0 )
    {
      if ( v3 > dword_1013B1CC )
      {
        if ( v3 < dword_1013B1C8 )
        {
          v60 &= 0x7FFFFFFFu;
          v5 = dword_1013B1DC + v3;
          v50 = dword_1013B1D4 / 32;
          v51 = dword_1013B1D4 % 32;
          v65 = 0;
          v74 = 0;
          v67 = 32 - dword_1013B1D4 % 32;
          do
          {
            v52 = *(&v60 + v74);
            v64 = ~(-1 << v51) & *(&v60 + v74);
            *(&v60 + v74++) = v65 | (v52 >> v51);
            v65 = v64 << v67;
          }
          while ( v74 < 3 );
          v53 = 2;
          v54 = &v62 - v50;
          do
          {
            if ( v53 < v50 )
              *(&v60 + v53) = 0;
            else
              *(&v60 + v53) = *v54;
            --v53;
            --v54;
          }
          while ( v53 >= 0 );
          result = 0;
        }
        else
        {
          v61 = 0;
          v62 = 0;
          v60 = 2147483648;
          v43 = dword_1013B1D4 / 32;
          v44 = dword_1013B1D4 % 32;
          v65 = 0;
          v73 = 0;
          v67 = 32 - dword_1013B1D4 % 32;
          do
          {
            v45 = (int *)(&v60 + v73);
            v46 = *v45;
            v64 = ~(-1 << v44) & *v45;
            v47 = v67;
            *v45 = v65 | (v46 >> v44);
            ++v73;
            v65 = v64 << v47;
          }
          while ( v73 < 3 );
          v48 = 2;
          v49 = &v62 - v43;
          do
          {
            if ( v48 < v43 )
              *(&v60 + v48) = 0;
            else
              *(&v60 + v48) = *v49;
            --v48;
            --v49;
          }
          while ( v48 >= 0 );
          v5 = dword_1013B1DC + dword_1013B1C8;
          result = 1;
        }
        goto LABEL_79;
      }
      v60 = v57;
      v61 = v58;
      v17 = (dword_1013B1CC - v64) / 32;
      v62 = v59;
      v18 = (dword_1013B1CC - v64) % 32;
      v65 = 0;
      v70 = 0;
      v67 = 32 - v18;
      do
      {
        v19 = (int *)(&v60 + v70);
        v20 = *v19;
        v64 = ~(-1 << v18) & *v19;
        v21 = v67;
        *v19 = v65 | (v20 >> v18);
        ++v70;
        v65 = v64 << v21;
      }
      while ( v70 < 3 );
      v22 = 2;
      v23 = &v62 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v60 + v22) = 0;
        else
          *(&v60 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_1013B1D0 - 1;
      v25 = dword_1013B1D0 / 32;
      v65 = dword_1013B1D0 / 32;
      v26 = (int *)(&v60 + dword_1013B1D0 / 32);
      v64 = 31 - dword_1013B1D0 % 32;
      if ( (1 << (31 - dword_1013B1D0 % 32)) & *v26 )
      {
        for ( j = (~(-1 << (31 - dword_1013B1D0 % 32)) & *(&v60 + v25)) == 0; j; j = *(&v60 + v25) == 0 )
        {
          if ( ++v25 >= 3 )
            goto LABEL_52;
        }
        v28 = v24 / 32;
        v71 = 0;
        v29 = 1 << (31 - v24 % 32);
        v30 = (int *)(&v60 + v24 / 32);
        v31 = *v30 + v29;
        if ( v31 < *v30 || v31 < v29 )
          v71 = 1;
        *v30 = v31;
        for ( k = v71; --v28 >= 0 && k; k = v35 )
        {
          v33 = (int *)(&v60 + v28);
          v34 = *v33 + 1;
          v35 = 0;
          if ( v34 < *v33 || v34 < 1 )
            v35 = 1;
          *v33 = v34;
        }
      }
LABEL_52:
      *v26 &= -1 << v64;
      if ( v65 + 1 < 3 )
        memset(&v60 + v65 + 1, 0, 4 * (3 - (v65 + 1)));
      v36 = (dword_1013B1D4 + 1) / 32;
      v37 = (dword_1013B1D4 + 1) % 32;
      v65 = 0;
      v72 = 0;
      v67 = 32 - v37;
      do
      {
        v38 = (int *)(&v60 + v72);
        v39 = *v38;
        v64 = ~(-1 << v37) & *v38;
        v40 = v67;
        *v38 = v65 | (v39 >> v37);
        ++v72;
        v65 = v64 << v40;
      }
      while ( v72 < 3 );
      v41 = 2;
      v42 = &v62 - v36;
      do
      {
        if ( v41 < v36 )
          *(&v60 + v41) = 0;
        else
          *(&v60 + v41) = *v42;
        --v41;
        --v42;
      }
      while ( v41 >= 0 );
    }
    else
    {
      v60 = 0;
      v61 = 0;
      v62 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_79;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v60 + v6) )
  {
    if ( ++v6 >= 3 )
    {
      result = 0;
      goto LABEL_79;
    }
  }
  v60 = 0;
  v61 = 0;
  v62 = 0;
  result = 2;
LABEL_79:
  v55 = v60 | (v63 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_1013B1D4));
  if ( dword_1013B1D8 == 64 )
  {
    v56 = v61;
    *(_DWORD *)(a2 + 4) = v55;
    *(_DWORD *)a2 = v56;
  }
  else if ( dword_1013B1D8 == 32 )
  {
    *(_DWORD *)a2 = v55;
  }
  return result;
}
// 1013B1C8: using guessed type int dword_1013B1C8;
// 1013B1CC: using guessed type int dword_1013B1CC;
// 1013B1D0: using guessed type int dword_1013B1D0;
// 1013B1D4: using guessed type int dword_1013B1D4;
// 1013B1D8: using guessed type int dword_1013B1D8;
// 1013B1DC: using guessed type int dword_1013B1DC;

//----- (10079567) --------------------------------------------------------
int __cdecl sub_10079567(int a1, HANDLE hHandle)
{
  int *v2; // edi@3
  int v3; // esi@3
  int result; // eax@11

  if ( a1 < 0 || a1 >= uNumber || (v2 = &dword_10A09B00[a1 >> 5], v3 = (a1 & 0x1F) << 6, *(_DWORD *)(v3 + *v2) != -1) )
  {
    *_errno() = 9;
    *__doserrno() = 0;
    result = -1;
  }
  else
  {
    if ( dword_109FF168 == 1 )
    {
      if ( a1 )
      {
        if ( a1 == 1 )
        {
          SetStdHandle(0xFFFFFFF5, hHandle);
        }
        else if ( a1 == 2 )
        {
          SetStdHandle(0xFFFFFFF4, hHandle);
        }
      }
      else
      {
        SetStdHandle(0xFFFFFFF6, hHandle);
      }
    }
    *(_DWORD *)(v3 + *v2) = hHandle;
    result = 0;
  }
  return result;
}
// 109FF168: using guessed type int dword_109FF168;
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (100795E4) --------------------------------------------------------
signed int __cdecl sub_100795E4(signed int a1)
{
  int *v1; // edi@3
  int v2; // esi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < uNumber )
  {
    v1 = &dword_10A09B00[a1 >> 5];
    v2 = (a1 & 0x1F) << 6;
    v3 = v2 + *v1;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( dword_109FF168 == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v2 + *v1) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 109FF168: using guessed type int dword_109FF168;
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (10079665) --------------------------------------------------------
signed int __cdecl sub_10079665(signed int a1)
{
  signed int result; // eax@2
  int v2; // eax@5

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    result = -1;
  }
  else if ( a1 >= 0 && a1 < uNumber && (v2 = dword_10A09B00[a1 >> 5] + ((a1 & 0x1F) << 6), *(_BYTE *)(v2 + 4) & 1) )
  {
    result = *(_DWORD *)v2;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (10079776) --------------------------------------------------------
void __cdecl sub_10079776(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(dword_10A09B00[a1 >> 5] + ((a1 & 0x1F) << 6) + 12));
}
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (1007A7EB) --------------------------------------------------------
int __cdecl sub_1007A7EB(int a1)
{
  int result; // eax@1

  result = a1;
  dword_109FF7B8 = a1;
  return result;
}
// 109FF7B8: using guessed type int dword_109FF7B8;

//----- (1007ADA9) --------------------------------------------------------
int sub_1007ADA9()
{
  return _decode_pointer(dword_109FFAE0);
}
// 1006DC2A: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 109FFAE0: using guessed type int dword_109FFAE0;

//----- (1007AF66) --------------------------------------------------------
int __cdecl sub_1007AF66(int a1)
{
  int result; // eax@1

  result = a1;
  dword_109FFAEC = a1;
  return result;
}
// 109FFAEC: using guessed type int dword_109FFAEC;

//----- (1007AF70) --------------------------------------------------------
int __cdecl sub_1007AF70(int a1)
{
  int result; // eax@1

  result = a1;
  dword_109FFAF8 = a1;
  return result;
}
// 109FFAF8: using guessed type int dword_109FFAF8;

//----- (1007AF7A) --------------------------------------------------------
int __cdecl sub_1007AF7A(int a1)
{
  int result; // eax@1

  result = a1;
  dword_109FFAFC = a1;
  return result;
}
// 109FFAFC: using guessed type int dword_109FFAFC;

//----- (1007B6DC) --------------------------------------------------------
int __cdecl sub_1007B6DC(int a1, FILE *a2)
{
  int *v2; // edi@4
  _BYTE *v3; // eax@4
  int *v4; // edi@9
  _BYTE *v5; // eax@9
  int v7; // eax@16
  char *v8; // eax@24
  int v9; // eax@28

  if ( !(a2->_flag & 0x40) )
  {
    if ( _fileno(a2) == -1 || _fileno(a2) == -2 )
    {
      v3 = &unk_1013AC58;
    }
    else
    {
      v2 = &dword_10A09B00[_fileno(a2) >> 5];
      v3 = (_BYTE *)(*v2 + ((_fileno(a2) & 0x1F) << 6));
    }
    if ( v3[36] & 0x7F
      || (_fileno(a2) == -1 || _fileno(a2) == -2 ? (v5 = &unk_1013AC58) : (v4 = &dword_10A09B00[_fileno(a2) >> 5],
                                                                           v5 = (_BYTE *)(*v4
                                                                                        + ((_fileno(a2) & 0x1F) << 6))),
          v5[36] & 0x80) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  if ( a1 == -1 )
    return -1;
  v7 = a2->_flag;
  if ( !(v7 & 1) && ((char)v7 >= 0 || v7 & 2) )
    return -1;
  if ( !a2->_base )
    _getbuf(a2);
  if ( a2->_ptr == a2->_base )
  {
    if ( a2->_cnt )
      return -1;
    ++a2->_ptr;
  }
  v8 = --a2->_ptr;
  if ( a2->_flag & 0x40 )
  {
    if ( *v8 != (_BYTE)a1 )
    {
      a2->_ptr = v8 + 1;
      return -1;
    }
  }
  else
  {
    *v8 = a1;
  }
  v9 = a2->_flag;
  ++a2->_cnt;
  a2->_flag = v9 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a1;
}
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 10076FEA: using guessed type _DWORD __cdecl _getbuf(_DWORD);
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (1007B924) --------------------------------------------------------
int sub_1007B924()
{
  return 0;
}

//----- (1007D357) --------------------------------------------------------
DWORD __cdecl sub_1007D357(int a1, LONG lDistanceToMove, DWORD dwMoveMethod)
{
  void *v3; // eax@1
  DWORD result; // eax@2
  DWORD v5; // edi@3
  DWORD v6; // eax@4
  _BYTE *v7; // eax@8

  v3 = (void *)sub_10079665(a1);
  if ( v3 == (void *)-1 )
  {
    *_errno() = 9;
    result = -1;
  }
  else
  {
    v5 = SetFilePointer(v3, lDistanceToMove, 0, dwMoveMethod);
    if ( v5 == -1 )
      v6 = GetLastError();
    else
      v6 = 0;
    if ( v6 )
    {
      _dosmaperr(v6);
      result = -1;
    }
    else
    {
      v7 = (_BYTE *)(dword_10A09B00[a1 >> 5] + ((a1 & 0x1F) << 6) + 4);
      *v7 &= 0xFDu;
      result = v5;
    }
  }
  return result;
}
// 1006B58B: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (1007D3C9) --------------------------------------------------------
signed int __cdecl sub_1007D3C9(signed int a1, int a2)
{
  int *v2; // edx@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // eax@1
  _BYTE *v6; // ecx@6
  char v7; // dl@6
  signed int result; // eax@12
  int v9; // [sp+14h] [bp+8h]@1

  v2 = &dword_10A09B00[a1 >> 5];
  v3 = (a1 & 0x1F) << 6;
  v4 = *v2 + v3;
  v9 = *(_BYTE *)(v4 + 4) & 0x80;
  v5 = (char)(2 * *(_BYTE *)(v4 + 36)) >> 1;
  if ( a2 == 0x4000 )
  {
    *(_BYTE *)(v4 + 4) |= 0x80u;
    *(_BYTE *)(*v2 + v3 + 36) &= 0x80u;
  }
  else if ( a2 == 0x8000 )
  {
    *(_BYTE *)(v4 + 4) &= 0x7Fu;
  }
  else
  {
    if ( a2 == 0x10000 || a2 == 0x20000 )
    {
      *(_BYTE *)(v4 + 4) |= 0x80u;
      v6 = (_BYTE *)(*v2 + v3 + 36);
      v7 = *v6 & 0x82 | 2;
    }
    else
    {
      if ( a2 != 0x40000 )
        goto LABEL_11;
      *(_BYTE *)(v4 + 4) |= 0x80u;
      v6 = (_BYTE *)(*v2 + v3 + 36);
      v7 = *v6 & 0x81 | 1;
    }
    *v6 = v7;
  }
LABEL_11:
  if ( v9 )
    result = v5 != 0 ? 0x10000 : 0x4000;
  else
    result = 0x8000;
  return result;
}
// 10A09B00: using guessed type int dword_10A09B00[];

//----- (1007D485) --------------------------------------------------------
signed int __cdecl sub_1007D485(_DWORD *a1)
{
  signed int result; // eax@2

  if ( a1 )
  {
    *a1 = dword_109FFBDC;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 1006C605: using guessed type int __cdecl _invalid_parameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 109FFBDC: using guessed type int dword_109FFBDC;

//----- (1007D4B9) --------------------------------------------------------
int __cdecl sub_1007D4B9(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  FARPROC v5; // eax@3
  FARPROC v6; // eax@4
  FARPROC v7; // eax@4
  FARPROC v8; // eax@7
  FARPROC v9; // eax@8
  int (*v10)(void); // esi@11
  int (__stdcall *v11)(int, signed int, char *, signed int, char *); // eax@11
  int (__stdcall *v12)(int, signed int, char *, signed int, char *); // edi@11
  int v13; // eax@13
  int (*v14)(void); // eax@22
  int (__stdcall *v15)(int); // eax@25
  int (__stdcall *v16)(int, int, int, int); // eax@27
  char v18; // [sp+10h] [bp-20h]@14
  char v19; // [sp+18h] [bp-18h]@15
  char v20; // [sp+1Ch] [bp-14h]@14
  unsigned int v21; // [sp+20h] [bp-10h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+28h] [bp-8h]@1
  int v24; // [sp+2Ch] [bp-4h]@1

  v23 = _encoded_null();
  v24 = 0;
  v22 = 0;
  v21 = 0;
  if ( !dword_109FFBC8 )
  {
    v3 = LoadLibraryA("USER32.DLL");
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = GetProcAddress(v3, "MessageBoxA");
    if ( !v5 )
      return 0;
    dword_109FFBC8 = _encode_pointer(v5);
    v6 = GetProcAddress(v4, "GetActiveWindow");
    dword_109FFBCC = _encode_pointer(v6);
    v7 = GetProcAddress(v4, "GetLastActivePopup");
    dword_109FFBD0 = _encode_pointer(v7);
    if ( sub_10070214(&v22) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v22 == 2 )
    {
      v8 = GetProcAddress(v4, "GetUserObjectInformationA");
      dword_109FFBD8 = _encode_pointer(v8);
      if ( dword_109FFBD8 )
      {
        v9 = GetProcAddress(v4, "GetProcessWindowStation");
        dword_109FFBD4 = _encode_pointer(v9);
      }
    }
  }
  if ( dword_109FFBD4 == v23
    || dword_109FFBD8 == v23
    || (v10 = (int (*)(void))_decode_pointer(dword_109FFBD4),
        v11 = (int (__stdcall *)(int, signed int, char *, signed int, char *))_decode_pointer(dword_109FFBD8),
        v12 = v11,
        !v10)
    || !v11
    || (v13 = v10()) != 0 && v12(v13, 1, &v18, 12, &v20) && v19 & 1 )
  {
    if ( dword_109FFBCC != v23 )
    {
      v14 = (int (*)(void))_decode_pointer(dword_109FFBCC);
      if ( v14 )
      {
        v24 = v14();
        if ( v24 )
        {
          if ( dword_109FFBD0 != v23 )
          {
            v15 = (int (__stdcall *)(int))_decode_pointer(dword_109FFBD0);
            if ( v15 )
              v24 = v15(v24);
          }
        }
      }
    }
  }
  else
  {
    if ( sub_1007024B(&v21) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v21 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v16 = (int (__stdcall *)(int, int, int, int))_decode_pointer(dword_109FFBC8);
  if ( v16 )
    return v16(v24, a1, a2, a3);
  return 0;
}
// 1006C509: using guessed type int __cdecl _invoke_watson(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 1006DBB3: using guessed type _DWORD __cdecl _encode_pointer(_DWORD);
// 1006DC21: using guessed type int _encoded_null(void);
// 1006DC2A: using guessed type _DWORD __cdecl _decode_pointer(_DWORD);
// 109FFBC8: using guessed type int dword_109FFBC8;
// 109FFBCC: using guessed type int dword_109FFBCC;
// 109FFBD0: using guessed type int dword_109FFBD0;
// 109FFBD4: using guessed type int dword_109FFBD4;
// 109FFBD8: using guessed type int dword_109FFBD8;

#error "There were 48 decompilation failure(s) on 2117 function(s)"
